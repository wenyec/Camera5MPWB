   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB25:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      ****                                                            received. */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 214:../uvc.c      ****                                                            the current video frame. */
 215:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 216:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 217:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 218:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 219:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 220:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 221:../uvc.c      **** 
 222:../uvc.c      **** /************ control parameters array ***********
 223:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 224:../uvc.c      ****  *    e.g.
 225:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 226:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 227:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 228:../uvc.c      ****  **************************************************/
 229:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 230:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 231:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 232:../uvc.c      **** 		{BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,
 233:../uvc.c      **** 		{0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 0, 3,
 234:../uvc.c      **** 		{ContrastReg         , ContrastReg          , 2,    0,    0,  255,    0, 1, 0, 3, 0, 112, 0, 112,
 235:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 236:../uvc.c      **** 		{MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,   1,
 237:../uvc.c      **** 		{HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,   0,
 238:../uvc.c      **** 		{SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,  50,
 239:../uvc.c      **** 		{SharpnessReg        , SharpnessReg         , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 240:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 241:../uvc.c      **** 		{WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 242:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,   0,
 243:../uvc.c      **** 		{ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,  32,
 244:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 245:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 246:../uvc.c      **** 		{DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,   0,
 247:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 248:../uvc.c      **** 		{ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0,   0,
 249:../uvc.c      **** 		{SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0,   1,
 250:../uvc.c      **** 		{MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   2,
 251:../uvc.c      **** 		{NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,   0,
 252:../uvc.c      **** 		{NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 253:../uvc.c      **** 		{DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0,
 254:../uvc.c      **** 		{DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0,   0,
 255:../uvc.c      **** 		{DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 256:../uvc.c      **** 		{NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 257:../uvc.c      **** 		{AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32,   0,
 258:../uvc.c      **** 		{AExReferleveReg     , AExReferleveReg      , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 259:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0,   0,
 260:../uvc.c      **** 		{SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0,   3,
 261:../uvc.c      **** 		{0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 262:../uvc.c      **** 		{SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 263:../uvc.c      **** 		/**********************************
 264:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 265:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 266:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 267:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 268:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 269:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 270:../uvc.c      **** 		 *
 271:../uvc.c      **** 		 *********************************/
 272:../uvc.c      **** 		{0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 0,   0
 273:../uvc.c      **** };
 274:../uvc.c      **** 
 275:../uvc.c      **** #ifndef CAM720
 276:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 277:../uvc.c      **** #else
 278:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 279:../uvc.c      **** #endif
 280:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
 281:../uvc.c      **** 
 282:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 283:../uvc.c      **** 		{0x13/*Ext1BLCRangeCtlID0 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0, 0x23
 284:../uvc.c      **** 		{0x11/*Ext1BLCWeightCtlID1*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,   1, 
 285:../uvc.c      **** 		{0x17/*Ext1BLCGridCtlID2*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0, 
 286:../uvc.c      **** 		{0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,0x4
 287:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,   0,
 288:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,   0,
 289:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,   0,
 290:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0xa,
 291:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,   0,
 292:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 293:../uvc.c      **** 		{0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0,   0,
 294:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 295:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 296:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 297:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 298:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 299:../uvc.c      **** };
 300:../uvc.c      **** 
 301:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 302:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 303:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 304:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 305:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 306:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 307:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 308:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 309:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 310:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 311:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 312:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 313:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 314:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 315:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 316:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 317:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 318:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 319:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 320:../uvc.c      **** };
 321:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 322:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 323:../uvc.c      **** /*
 324:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 325:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 326:../uvc.c      ****  */
 327:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 328:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 329:../uvc.c      **** };
 330:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 331:../uvc.c      **** 		0
 332:../uvc.c      **** };
 333:../uvc.c      **** 
 334:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 335:../uvc.c      **** 
 336:../uvc.c      **** void I2CCmdHandler(){
 337:../uvc.c      **** 	uint8_t buf[2];
 338:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 339:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 340:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 341:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 342:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 343:../uvc.c      **** 	uint8_t i;
 344:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 345:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 346:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 347:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 348:../uvc.c      **** 	{
 349:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 350:../uvc.c      **** 		if(is60Hz==CyFalse)
 351:../uvc.c      **** 			{
 352:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 353:../uvc.c      **** 			}
 354:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 355:../uvc.c      **** 
 356:../uvc.c      **** 	}
 357:../uvc.c      **** 	if(CmdType == 0)//I2C read
 358:../uvc.c      **** 	{
 359:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 360:../uvc.c      **** #if 0 //for debugging
 361:../uvc.c      **** 		/* test still image operation */
 362:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 363:../uvc.c      **** 			snapButFlag = 0; //press
 364:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 365:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 366:../uvc.c      **** 			snapButFlag = 0xf; //release
 367:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 368:../uvc.c      **** 		}
 369:../uvc.c      **** 
 370:../uvc.c      **** 		/* end of the test */
 371:../uvc.c      **** #endif
 372:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 373:../uvc.c      **** 			/*
 374:../uvc.c      **** 			if(CmdRegLen == 2){
 375:../uvc.c      **** 				SensorRead2B2(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|0x1, 0, I2CCMDArry[4], I2CCMDArry[9]);
 376:../uvc.c      **** 			}
 377:../uvc.c      **** 			else{
 378:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 379:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 380:../uvc.c      **** 				if(CmdDataLen == 2){
 381:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 382:../uvc.c      **** 				}
 383:../uvc.c      **** 			}*/
 384:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 385:../uvc.c      **** 		}else{//not support currently
 386:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 387:../uvc.c      **** 		}
 388:../uvc.c      **** 	}else if(CmdType == 1){
 389:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 390:../uvc.c      **** 			if(CmdRegLen == 2){
 391:../uvc.c      **** 				for(i = 0; i<4; i++)
 392:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 393:../uvc.c      **** 			}
 394:../uvc.c      **** 			else{
 395:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 396:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 397:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 398:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 399:../uvc.c      **** 				}
 400:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 401:../uvc.c      **** 			}
 402:../uvc.c      **** 		}else{//not support currently
 403:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 404:../uvc.c      **** 		}
 405:../uvc.c      **** 
 406:../uvc.c      **** 	}
 407:../uvc.c      **** }
 408:../uvc.c      **** 
 409:../uvc.c      **** /************************************
 410:../uvc.c      ****  * set Iris mode
 411:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 412:../uvc.c      ****  */
 413:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 414:../uvc.c      **** 	uint8_t dataIdx;
 415:../uvc.c      **** 	  dataIdx = 0;
 416:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 417:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 418:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 419:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 420:../uvc.c      **** }
 421:../uvc.c      **** 
 422:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 423:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 424:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 425:../uvc.c      ****     uint16_t readCount;
 426:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 427:../uvc.c      ****     uint8_t devAdd;
 428:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 429:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 430:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 431:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 432:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 433:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 434:../uvc.c      ****     }else{
 435:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 436:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 437:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 438:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 439:../uvc.c      ****     }
 440:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 441:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 442:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 443:../uvc.c      **** #endif
 444:../uvc.c      ****     reqData = bRequest;
 445:../uvc.c      ****     /*
 446:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 447:../uvc.c      ****      */
 448:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 449:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 450:../uvc.c      ****     	goto EndofSet;
 451:../uvc.c      ****     }
 452:../uvc.c      ****     switch (bRequest)
 453:../uvc.c      **** 		 {
 454:../uvc.c      **** 
 455:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 456:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 457:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 458:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 459:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 460:../uvc.c      **** 			  break;
 461:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 462:../uvc.c      **** 
 463:../uvc.c      **** 			 switch(CtrlID)
 464:../uvc.c      **** 			 {
 465:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 466:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID0:
 467:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID1:
 468:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID2:
 469:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 470:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 471:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 472:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 473:../uvc.c      **** 			 	 		 break;
 474:../uvc.c      **** 			 	 }
 475:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 476:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 477:../uvc.c      **** 					 if(CamMode == 1){//720p
 478:../uvc.c      **** 						if(sendData >= 3){
 479:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 480:../uvc.c      **** 							sendData = 0; //set back to default
 481:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 482:../uvc.c      **** 						}
 483:../uvc.c      **** 						sendData += 4;
 484:../uvc.c      **** 					 }
 485:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 486:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 487:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 488:../uvc.c      **** 					 break;
 489:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 490:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 491:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 492:../uvc.c      **** 			 		 }
 493:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 494:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 495:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 496:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 497:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 498:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 499:../uvc.c      **** #endif
 500:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 501:../uvc.c      **** 			 		 {
 502:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 503:../uvc.c      **** 			 		 }
 504:../uvc.c      **** 			 		 break;
 505:../uvc.c      **** 				 case ExtAexModCtlID9:
 506:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 507:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 508:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 509:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 510:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 511:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 512:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 513:../uvc.c      **** 					 break;
 514:../uvc.c      **** 
 515:../uvc.c      **** 			 	 case BrgtCtlID1:
 516:../uvc.c      **** 			 		 /* cancel for 5MP w/b camera
 517:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 518:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 519:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 520:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 521:../uvc.c      **** 					 }else{
 522:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 523:../uvc.c      **** 					 }
 524:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 525:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 526:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 527:../uvc.c      **** 					 */
 528:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 529:../uvc.c      **** 					  if(Data0&0x80){
 530:../uvc.c      **** 						  Data0 = ~Data0;
 531:../uvc.c      **** 					  }else{
 532:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 533:../uvc.c      **** 					  }
 534:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 535:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 536:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 537:../uvc.c      **** 			 		 break;
 538:../uvc.c      **** 				 case HueCtlID5:
 539:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 540:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 541:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 542:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 543:../uvc.c      **** 					 break;
 544:../uvc.c      **** 				 case WBTLevCtlID11:
 545:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 546:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 547:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 548:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 549:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 550:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 551:../uvc.c      **** 					 break;
 552:../uvc.c      **** 				 case SaturCtlID6:
 553:../uvc.c      **** 				 default:
 554:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 555:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 556:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 557:../uvc.c      **** 					 break;
 558:../uvc.c      **** 			 }
 559:../uvc.c      **** 
 560:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 561:../uvc.c      **** 
 562:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 563:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 564:../uvc.c      **** #endif
 565:../uvc.c      **** 			  break;
 566:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 567:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 568:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 569:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 570:../uvc.c      **** 		 	 }
 571:../uvc.c      **** 
 572:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 573:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 574:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 575:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 576:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 577:../uvc.c      **** 			 }else
 578:../uvc.c      **** 			 {
 579:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 580:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 581:../uvc.c      **** 			 }
 582:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 583:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 584:../uvc.c      **** 			  break;
 585:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 586:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 587:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 588:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 589:../uvc.c      **** 		 	 }
 590:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 591:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 592:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 593:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 594:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 595:../uvc.c      **** 			 }else
 596:../uvc.c      **** 			 {
 597:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 598:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 599:../uvc.c      **** 			 }
 600:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 601:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 602:../uvc.c      **** 			  break;
 603:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 604:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 605:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 606:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 607:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 608:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 609:../uvc.c      **** 		 	 }
 610:../uvc.c      **** 		 	 else{
 611:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 612:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 613:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 614:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 615:../uvc.c      **** 		 	 }
 616:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 617:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 618:../uvc.c      **** 			  break;
 619:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 620:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 621:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 622:../uvc.c      **** 		 	 }
 623:../uvc.c      **** 		 	 else{
 624:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 625:../uvc.c      **** 		 	 }
 626:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 627:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 628:../uvc.c      **** 			  Len = 1;
 629:../uvc.c      **** 			  break;
 630:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 631:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 632:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 633:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 634:../uvc.c      **** 		 	 }
 635:../uvc.c      **** 
 636:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 637:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 638:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 639:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 640:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 641:../uvc.c      **** 			 }else{
 642:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 643:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 644:../uvc.c      **** 			 }
 645:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 646:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 647:../uvc.c      **** 			  break;
 648:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 649:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 650:../uvc.c      **** 				  glEp0Buffer, &readCount);
 651:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 652:../uvc.c      **** 			   {
 653:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 654:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 655:../uvc.c      **** 				  getData = glEp0Buffer[0];
 656:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 657:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 658:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 659:../uvc.c      **** #endif
 660:../uvc.c      **** 				  switch(CtrlID)
 661:../uvc.c      **** 					 {
 662:../uvc.c      **** 						 case ExtShutCtlID0:
 663:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 664:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 665:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 666:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 667:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 668:../uvc.c      **** 									 }else{
 669:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 670:../uvc.c      **** 									 }
 671:../uvc.c      **** 								 }
 672:../uvc.c      **** 							 }else{
 673:../uvc.c      **** 								 Data1 = Data0 - 1;
 674:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 675:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 676:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 677:../uvc.c      **** 									 }else{
 678:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 679:../uvc.c      **** 									 }
 680:../uvc.c      **** 								 }
 681:../uvc.c      **** 								 if(Data1 < 8){
 682:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 683:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 684:../uvc.c      **** 								 }else{
 685:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 686:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 687:../uvc.c      **** 								 }
 688:../uvc.c      **** 							 }
 689:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 690:../uvc.c      **** 							 dataIdx = 0;
 691:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 692:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 693:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 694:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 695:../uvc.c      **** 							 break;
 696:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 697:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 698:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 699:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 700:../uvc.c      **** 							 dataIdx = 0;
 701:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 702:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 703:../uvc.c      **** 							 if(getData != 0){
 704:../uvc.c      **** 								 dataIdx++;
 705:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 706:../uvc.c      **** 							 }
 707:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 708:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 709:../uvc.c      **** 							 break;
 710:../uvc.c      **** 						 case ExtCamMCtlID12:
 711:../uvc.c      **** 							 dataIdx = 0;
 712:../uvc.c      **** 							 if(Data0 <= 3){
 713:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 714:../uvc.c      **** 								 Data1 = Data0;
 715:../uvc.c      **** 							 }else{
 716:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 717:../uvc.c      **** 								 Data1 = Data0-4;
 718:../uvc.c      **** 							 }
 719:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 720:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 721:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 722:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 723:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 724:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 725:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 726:../uvc.c      **** 							 break;
 727:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 728:../uvc.c      **** 							 dataIdx = 0;
 729:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
 730:../uvc.c      **** 								 Data0 = 1;
 731:../uvc.c      **** 							 }else{ //save current sensor parameters.
 732:../uvc.c      **** 								 Data0 = 0;
 733:../uvc.c      **** 							 }
 734:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 735:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 736:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 737:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 738:../uvc.c      **** 							 break;
 739:../uvc.c      **** 						 case ExtI2CCtlID15:
 740:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 741:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 742:../uvc.c      **** 					 		 }
 743:../uvc.c      **** 					 		I2CCmdHandler();
 744:../uvc.c      **** 							 break;
 745:../uvc.c      **** 						 case Ext1BLCRangeCtlID0: //registers value BLD window enable (0x17); position (0x13); size (
 746:../uvc.c      **** 							 dataIdx = 0;
 747:../uvc.c      **** #if 0 //seperate version
 748:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
 749:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
 750:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 751:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
 752:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
 753:../uvc.c      **** 							 }else{ //disable BLD window
 754:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
 755:../uvc.c      **** 							 }
 756:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
 757:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
 758:../uvc.c      **** 							 dataIdx++;
 759:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
 760:../uvc.c      **** 							 dataIdx++;
 761:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
 762:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
 763:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
 764:../uvc.c      **** 							 dataIdx++;
 765:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
 766:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 767:../uvc.c      **** #else //combination version
 768:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 769:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 770:../uvc.c      **** 						     /* end test */
 771:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 772:../uvc.c      **** 							 dataIdx++;
 773:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 774:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 775:../uvc.c      **** 							 getData1 = Data1;
 776:../uvc.c      **** #endif
 777:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 778:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 779:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 780:../uvc.c      **** 							 break;
 781:../uvc.c      **** 						 case Ext1BLCWeightCtlID1: //register value 0x11 (need check).
 782:../uvc.c      **** 							 dataIdx = 0;
 783:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 784:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 785:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 786:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 787:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 788:../uvc.c      **** 							 break;
 789:../uvc.c      **** 						 case Ext1BLCGridCtlID2:
 790:../uvc.c      **** 							 dataIdx = 0;
 791:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 792:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 793:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 794:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 795:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 796:../uvc.c      **** 							 break;
 797:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 798:../uvc.c      **** #if 0 //cancel for 5MP w/b camera
 799:../uvc.c      **** 							 dataIdx = 0;
 800:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 801:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 802:../uvc.c      **** 							  if(Data0&0x80){
 803:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 804:../uvc.c      **** 							  }else{
 805:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 806:../uvc.c      **** 							  }
 807:../uvc.c      **** 							 Data1 |= ~0x03;
 808:../uvc.c      **** 							 Data1 &= 0xC7;
 809:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 810:../uvc.c      **** 						  	 dataIdx++;
 811:../uvc.c      **** 
 812:../uvc.c      **** 							 Data0 = (Data0 << 2);
 813:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 814:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 815:../uvc.c      **** 
 816:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 817:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 818:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 819:../uvc.c      **** #endif
 820:../uvc.c      **** 							 dataIdx = 0;
 821:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 822:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 823:../uvc.c      **** 							  if(Data0&0x80){
 824:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 825:../uvc.c      **** 							  }else{
 826:../uvc.c      **** 								  Data0 = ~Data0;
 827:../uvc.c      **** 							  }
 828:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 829:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 830:../uvc.c      **** 
 831:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 832:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 833:../uvc.c      **** 
 834:../uvc.c      **** 
 835:../uvc.c      **** 							 break;
 836:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 837:../uvc.c      **** 							 dataIdx = 0;
 838:../uvc.c      **** 
 839:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 840:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 841:../uvc.c      **** 							 dataIdx++;
 842:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 843:../uvc.c      **** 							 dataIdx++;
 844:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 845:../uvc.c      **** 							 dataIdx++;
 846:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 847:../uvc.c      **** 							 dataIdx++;
 848:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 849:../uvc.c      **** 							 dataIdx++;
 850:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 851:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 852:../uvc.c      **** 
 853:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 854:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 855:../uvc.c      **** 							 break;
 856:../uvc.c      **** 						 case SaturCtlID6:
 857:../uvc.c      **** 							 dataIdx = 0;
 858:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
 859:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 860:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 861:../uvc.c      **** 							 dataIdx++;
 862:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 863:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 864:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 865:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 866:../uvc.c      **** 							 break;
 867:../uvc.c      **** 
 868:../uvc.c      **** 						 case WBTLevCtlID11:
 869:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
 870:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
 871:../uvc.c      **** 							 dataIdx = 0;
 872:../uvc.c      **** 
 873:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 874:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 875:../uvc.c      **** 							 dataIdx++;
 876:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 877:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 878:../uvc.c      **** 
 879:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 880:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 881:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 882:../uvc.c      **** 							 break;
 883:../uvc.c      **** 						 case MFreqCtlID4:
 884:../uvc.c      **** 							 dataIdx = 0;
 885:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 886:../uvc.c      **** 							 Data0 = Data0 - 1;
 887:../uvc.c      **** 							 is60Hz = Data0;
 888:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 889:../uvc.c      **** 							 {
 890:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
 891:../uvc.c      **** 								 is60Hz = CyFalse;
 892:../uvc.c      **** 							 }
 893:../uvc.c      **** 							 else if(Data0 >2)
 894:../uvc.c      **** 							 {
 895:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
 896:../uvc.c      **** 								 is60Hz = CyTrue;
 897:../uvc.c      **** 							 }
 898:../uvc.c      **** 							 //CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
 899:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 900:../uvc.c      **** 							 {
 901:../uvc.c      **** 								 //CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 902:../uvc.c      **** 			                       switch (setRes)
 903:../uvc.c      **** 			                         {
 904:../uvc.c      **** 			                         	case 1: //1944
 905:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 906:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 907:../uvc.c      **** 			                                //CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60
 908:../uvc.c      **** 			                         		break;
 909:../uvc.c      **** 			                         	case 2: //1080
 910:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 911:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 912:../uvc.c      **** 			                                //CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60
 913:../uvc.c      **** 			                         		break;
 914:../uvc.c      **** 			                         	case 3: //720
 915:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
 916:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 917:../uvc.c      **** 			                                //CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is
 918:../uvc.c      **** 			                         		break;
 919:../uvc.c      **** 			                         	default:
 920:../uvc.c      **** 			                         		break;
 921:../uvc.c      **** 			                         }
 922:../uvc.c      **** 								 //CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 923:../uvc.c      **** 							 }
 924:../uvc.c      **** 
 925:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 926:../uvc.c      **** 							 break;
 927:../uvc.c      **** 					 	 case BLCCtlID0:
 928:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 929:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 930:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 931:../uvc.c      **** 							 {
 932:../uvc.c      **** 								 if(Data0 < 3){
 933:../uvc.c      **** 					 				 Data0 += 4;
 934:../uvc.c      **** 					 			 }else{
 935:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 936:../uvc.c      **** 									Data0 = 4; //set to default.
 937:../uvc.c      **** 					 			 }
 938:../uvc.c      **** 					 		 }
 939:../uvc.c      **** 							 CtrlParArry[CamModeIndex][13] = Data0;
 940:../uvc.c      **** 							 dataIdx = 0;
 941:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 942:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 943:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 944:../uvc.c      **** 
 945:../uvc.c      **** 					 		 break;
 946:../uvc.c      **** 						 default:
 947:../uvc.c      **** 							 dataIdx = 0;
 948:../uvc.c      **** 
 949:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 950:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 951:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 952:../uvc.c      **** 
 953:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 954:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 955:../uvc.c      **** 							 break;
 956:../uvc.c      **** 					 }
 957:../uvc.c      **** 			   }else{
 958:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 959:../uvc.c      **** 			   }
 960:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 961:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
 962:../uvc.c      **** #endif
 963:../uvc.c      **** 
 964:../uvc.c      **** 			  break;
 965:../uvc.c      **** 		  default:
 966:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 967:../uvc.c      **** 			  break;
 968:../uvc.c      **** 		 }
 969:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 970:../uvc.c      **** }
 971:../uvc.c      **** /************** CT control requests handler *************************/
 972:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
 973:../uvc.c      **** 
 974:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 975:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 976:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 977:../uvc.c      ****     uint16_t readCount;
 978:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
 979:../uvc.c      ****     uint16_t diff, value, diffRd;
 980:../uvc.c      ****     uint8_t i, shutter, index;
 981:../uvc.c      ****     diff = 0xffff;
 982:../uvc.c      ****     shutter = 1;
 983:../uvc.c      ****     index = 1;
 984:../uvc.c      **** 
 985:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 986:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 987:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 988:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 989:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 990:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 991:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
 992:../uvc.c      **** #endif
 993:../uvc.c      ****     reqData = bRequest;
 994:../uvc.c      **** 
 995:../uvc.c      ****     switch (bRequest)
 996:../uvc.c      **** 		 {
 997:../uvc.c      **** 
 998:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 999:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1000:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1001:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1002:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1003:../uvc.c      **** 			  break;
1004:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1005:../uvc.c      **** 
1006:../uvc.c      **** 			 switch(CtrlID)
1007:../uvc.c      **** 			 {
1008:../uvc.c      **** 				 default:
1009:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
1010:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
1011:../uvc.c      **** 					 glEp0Buffer[2] = 0;
1012:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1013:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1014:../uvc.c      **** 					 break;
1015:../uvc.c      **** 			 }
1016:../uvc.c      **** 
1017:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1018:../uvc.c      **** 
1019:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1020:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
1021:../uvc.c      **** #endif
1022:../uvc.c      **** 			  break;
1023:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
1024:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
1025:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
1026:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
1027:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1028:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1029:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1030:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1031:../uvc.c      **** 			  break;
1032:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1033:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
1034:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
1035:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1036:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1037:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1038:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1039:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1040:../uvc.c      **** 			  break;
1041:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1042:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1043:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1044:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1045:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1046:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1047:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1048:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1049:../uvc.c      **** 			  break;
1050:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1051:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1052:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1053:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1054:../uvc.c      **** 			  Len = 1;
1055:../uvc.c      **** 			  break;
1056:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1057:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1058:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1059:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1060:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1061:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1062:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1063:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1064:../uvc.c      **** 			  break;
1065:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1066:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1067:../uvc.c      **** 			  glEp0Buffer, &readCount);
1068:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1069:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1070:../uvc.c      **** 			  value = Data1;
1071:../uvc.c      **** 
1072:../uvc.c      **** 			  switch(CtrlID)
1073:../uvc.c      **** 			  {
1074:../uvc.c      **** 		  	      case AutoExMCtlID1:
1075:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1076:../uvc.c      **** 
1077:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1078:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1079:../uvc.c      **** 				    getData = glEp0Buffer[0];
1080:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1081:../uvc.c      **** 		  		    switch (getData){
1082:../uvc.c      **** 						case 1:
1083:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1084:../uvc.c      **** 							break;
1085:../uvc.c      **** 						case 2:
1086:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1087:../uvc.c      **** 							dataIdx = 0;
1088:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1089:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1090:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1091:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1092:../uvc.c      **** 
1093:../uvc.c      **** 							break;
1094:../uvc.c      **** 						case 4:
1095:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1096:../uvc.c      **** 							break;
1097:../uvc.c      **** 						case 8:
1098:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1099:../uvc.c      **** 			  		    	dataIdx = 0;
1100:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1101:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1102:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1103:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1104:../uvc.c      **** 							break;
1105:../uvc.c      **** 		  		    }
1106:../uvc.c      **** #if 0
1107:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1108:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1109:../uvc.c      **** 						  dataIdx = 0;
1110:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1111:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1112:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1113:../uvc.c      **** 		  		    }
1114:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1115:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1116:../uvc.c      **** 		  		    }
1117:../uvc.c      **** #endif
1118:../uvc.c      **** 				    break;
1119:../uvc.c      **** 
1120:../uvc.c      **** 			  	  case ExTmACtlID3:
1121:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1122:../uvc.c      **** 
1123:../uvc.c      **** 					  value = (value << 8)|Data0;
1124:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1125:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1126:../uvc.c      **** 					  {
1127:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1128:../uvc.c      **** 						  {
1129:../uvc.c      **** 							if(value > ShutValueArry[i]){
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1131:../uvc.c      **** 							}else{
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1133:../uvc.c      **** 							}
1134:../uvc.c      **** 							  if(diff > diffRd){
1135:../uvc.c      **** 								  diff = diffRd;
1136:../uvc.c      **** 								  index = i;
1137:../uvc.c      **** 							  }
1138:../uvc.c      **** 						  }
1139:../uvc.c      **** 						  shutter = shutter+index;
1140:../uvc.c      **** 
1141:../uvc.c      **** 						  dataIdx = 0;
1142:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1143:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1144:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1145:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1146:../uvc.c      **** 
1147:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1148:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1149:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1150:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1151:../uvc.c      **** 					  }else{
1152:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1153:../uvc.c      **** 					  }
1154:../uvc.c      **** 					  getData = glEp0Buffer[0];
1155:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1156:../uvc.c      **** 					  break;
1157:../uvc.c      **** 			  	  case IriACtlID7:
1158:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1159:../uvc.c      **** 					  {
1160:../uvc.c      **** 							 dataIdx = 0;
1161:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1162:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
1163:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1164:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1165:../uvc.c      **** 
1166:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1167:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1168:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1169:../uvc.c      **** 					  }else{
1170:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1171:../uvc.c      **** 					  }
1172:../uvc.c      **** 					  getData = glEp0Buffer[0];
1173:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1174:../uvc.c      **** 
1175:../uvc.c      **** 					  break;
1176:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1177:../uvc.c      **** 					  getData = glEp0Buffer[0];
1178:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1179:../uvc.c      **** #if 1
1180:../uvc.c      **** 					  dataIdx = 0;
1181:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1182:../uvc.c      **** 					  if(getData == 1)
1183:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1184:../uvc.c      **** 					  else if(getData == 0xff)
1185:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1186:../uvc.c      **** 					  else
1187:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
1188:../uvc.c      **** 					  //dataIdx++;
1189:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1190:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1191:../uvc.c      **** #endif
1192:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1193:../uvc.c      **** 					  break;
1194:../uvc.c      **** 
1195:../uvc.c      **** 			  	  default:
1196:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1197:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1198:../uvc.c      **** 			  		 break;
1199:../uvc.c      **** 			  }
1200:../uvc.c      **** 			  break;
1201:../uvc.c      **** 		  default:
1202:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1203:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1204:../uvc.c      **** 			  break;
1205:../uvc.c      **** 		 }
1206:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1207:../uvc.c      **** 
1208:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1209:../uvc.c      **** }
1210:../uvc.c      **** 
1211:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1212:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1213:../uvc.c      **** {
1214:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1215:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1216:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1217:../uvc.c      **** 
1218:../uvc.c      ****     CtrlID = BrgtCtlID1;
1219:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1220:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1221:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1222:../uvc.c      ****     Data1 = Data0;
1223:../uvc.c      **** 
1224:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1225:../uvc.c      ****     if(Data1&0x80){
1226:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1227:../uvc.c      ****     }else{
1228:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1229:../uvc.c      ****     }
1230:../uvc.c      ****     Data0 = (Data0 << 2);
1231:../uvc.c      **** 
1232:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1233:../uvc.c      **** 
1234:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1235:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1236:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1237:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1238:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1239:../uvc.c      **** 
1240:../uvc.c      ****     CtrlID = ConsCtlID2;
1241:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1242:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1243:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1244:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1245:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1246:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1247:../uvc.c      **** 
1248:../uvc.c      ****     CtrlID = HueCtlID5;
1249:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1250:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1251:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1252:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1253:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1254:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1255:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1256:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1257:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1258:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1259:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1260:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1261:../uvc.c      **** 
1262:../uvc.c      ****     CtrlID = SaturCtlID6;
1263:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1264:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1265:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1266:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1267:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1268:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1269:../uvc.c      **** 
1270:../uvc.c      ****     CtrlID = ShapCtlID7;
1271:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1272:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1273:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1274:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1275:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1276:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1277:../uvc.c      **** 
1278:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1279:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1280:../uvc.c      **** 	return;
1281:../uvc.c      **** }
1282:../uvc.c      **** 
1283:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1284:../uvc.c      **** void
1285:../uvc.c      **** CyFxUVCAddHeader (
1286:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1287:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1288:../uvc.c      ****         )
1289:../uvc.c      **** {
1290:../uvc.c      ****     /* Copy header to buffer */
1291:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1292:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1293:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
1294:../uvc.c      **** 
1295:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1296:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1297:../uvc.c      ****     {
1298:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1299:../uvc.c      ****     }
1300:../uvc.c      **** }
1301:../uvc.c      **** 
1302:../uvc.c      **** 
1303:../uvc.c      **** /* Application Error Handler */
1304:../uvc.c      **** void
1305:../uvc.c      **** CyFxAppErrorHandler (
1306:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1307:../uvc.c      ****         )
1308:../uvc.c      **** {
1309:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1310:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1311:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1312:../uvc.c      **** 
1313:../uvc.c      ****        This function can be modified to take additional error handling actions such
1314:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1315:../uvc.c      ****      */
1316:../uvc.c      ****     for (;;)
1317:../uvc.c      ****     {
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
1320:../uvc.c      ****     }
1321:../uvc.c      **** }
1322:../uvc.c      **** 
1323:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1324:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1325:../uvc.c      ****  */
1326:../uvc.c      **** static void
1327:../uvc.c      **** CyFxUVCApplnAbortHandler (
1328:../uvc.c      ****         void)
1329:../uvc.c      **** {
1330:../uvc.c      **** 	uint32_t flag;
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1332:../uvc.c      **** 	{
1333:../uvc.c      ****         /* Clear the Video Stream Request Event */
1334:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1335:../uvc.c      **** 
1336:../uvc.c      ****         /* Set Video Stream Abort Event */
1337:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1338:../uvc.c      **** 	}
1339:../uvc.c      **** }
1340:../uvc.c      **** 
1341:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1342:../uvc.c      **** static void
1343:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1344:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1345:../uvc.c      ****         uint16_t             evdata  /* Event data */
1346:../uvc.c      ****         )
1347:../uvc.c      **** {
1348:../uvc.c      ****     switch (evtype)
1349:../uvc.c      ****     {
1350:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1351:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1352:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1353:../uvc.c      ****             gpif_initialized = 0;
1354:../uvc.c      ****             streamingStarted = CyFalse;
1355:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1356:../uvc.c      ****             break;
1357:../uvc.c      **** 
1358:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1359:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1360:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1361:../uvc.c      ****             gpif_initialized = 0;
1362:../uvc.c      ****             streamingStarted = CyFalse;
1363:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1364:../uvc.c      ****             break;
1365:../uvc.c      **** 
1366:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1367:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1368:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1369:../uvc.c      ****             gpif_initialized = 0;
1370:../uvc.c      ****             isUsbConnected = CyFalse;
1371:../uvc.c      ****             streamingStarted = CyFalse;
1372:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1373:../uvc.c      ****             break;
1374:../uvc.c      **** 
1375:../uvc.c      **** #ifdef BACKFLOW_DETECT
1376:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1377:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1378:../uvc.c      ****             break;
1379:../uvc.c      **** #endif
1380:../uvc.c      **** 
1381:../uvc.c      ****         default:
1382:../uvc.c      ****             break;
1383:../uvc.c      ****     }
1384:../uvc.c      **** }
1385:../uvc.c      **** 
1386:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1387:../uvc.c      **** static CyBool_t
1388:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1389:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1390:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1391:../uvc.c      ****         )
1392:../uvc.c      **** {
1393:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1394:../uvc.c      ****     uint32_t status;
1395:../uvc.c      **** 
1396:../uvc.c      ****     /* Obtain Request Type and Request */
1397:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1398:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1399:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1400:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1401:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1402:../uvc.c      **** 
1403:../uvc.c      ****     /* Check for UVC Class Requests */
1404:../uvc.c      ****     switch (bmReqType)
1405:../uvc.c      ****     {
1406:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1407:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1408:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1409:../uvc.c      ****             switch (wIndex & 0xFF)
1410:../uvc.c      ****             {
1411:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1412:../uvc.c      ****                     {
1413:../uvc.c      ****                         uvcHandleReq = CyTrue;
1414:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1415:../uvc.c      ****                                 CYU3P_EVENT_OR);
1416:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1417:../uvc.c      ****                         {
1418:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1419:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1420:../uvc.c      ****                         }
1421:../uvc.c      ****                     }
1422:../uvc.c      ****                     break;
1423:../uvc.c      **** 
1424:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1425:../uvc.c      ****                     {
1426:../uvc.c      ****                         uvcHandleReq = CyTrue;
1427:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1428:../uvc.c      ****                                 CYU3P_EVENT_OR);
1429:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1430:../uvc.c      ****                         {
1431:../uvc.c      ****                             /* Error handling */
1432:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1433:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1434:../uvc.c      ****                         }
1435:../uvc.c      ****                     }
1436:../uvc.c      ****                     break;
1437:../uvc.c      **** 
1438:../uvc.c      ****                 default:
1439:../uvc.c      ****                     break;
1440:../uvc.c      ****             }
1441:../uvc.c      ****             break;
1442:../uvc.c      **** 
1443:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1444:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1445:../uvc.c      ****             {
1446:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1447:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1448:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1449:../uvc.c      ****                 {
1450:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1451:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1452:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1453:../uvc.c      ****                     gpif_initialized = 0;
1454:../uvc.c      ****                     streamingStarted = CyFalse;
1455:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1456:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1457:../uvc.c      ****                     CyU3PBusyWait (100);
1458:../uvc.c      **** 
1459:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1460:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1461:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1462:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1463:../uvc.c      ****                     CyU3PBusyWait (100);
1464:../uvc.c      **** 
1465:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1466:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1467:../uvc.c      ****                     uvcHandleReq = CyTrue;
1468:../uvc.c      ****                     /* Complete Control request handshake */
1469:../uvc.c      ****                     CyU3PUsbAckSetup ();
1470:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1471:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1472:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1473:../uvc.c      **** 
1474:../uvc.c      ****                 }
1475:../uvc.c      ****             }
1476:../uvc.c      ****             break;
1477:../uvc.c      **** 
1478:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1479:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1480:../uvc.c      ****             {
1481:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1482:../uvc.c      ****                 {
1483:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1484:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1485:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1486:../uvc.c      ****                 	 * has started. */
1487:../uvc.c      ****                     if (streamingStarted == CyTrue)
1488:../uvc.c      ****                     {
1489:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1490:../uvc.c      **** 
1491:../uvc.c      ****                         /* Disable the GPIF state machine. */
1492:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1493:../uvc.c      ****                         gpif_initialized = 0;
1494:../uvc.c      ****                         streamingStarted = CyFalse;
1495:../uvc.c      **** 
1496:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1497:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1498:../uvc.c      ****                         CyU3PBusyWait (100);
1499:../uvc.c      **** 
1500:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1501:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1502:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1503:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1504:../uvc.c      ****                         CyU3PBusyWait (100);
1505:../uvc.c      **** 
1506:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1507:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1508:../uvc.c      **** 
1509:../uvc.c      ****                         uvcHandleReq = CyTrue;
1510:../uvc.c      ****                         /* Complete Control request handshake */
1511:../uvc.c      ****                         CyU3PUsbAckSetup ();
1512:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1513:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1514:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1515:../uvc.c      ****                     }
1516:../uvc.c      ****                     else
1517:../uvc.c      ****                     {
1518:../uvc.c      ****                         uvcHandleReq = CyTrue;
1519:../uvc.c      ****                         CyU3PUsbAckSetup ();
1520:../uvc.c      ****                     }
1521:../uvc.c      ****                 }
1522:../uvc.c      ****             }
1523:../uvc.c      ****             break;
1524:../uvc.c      **** 
1525:../uvc.c      ****         default:
1526:../uvc.c      ****             break;
1527:../uvc.c      ****     }
1528:../uvc.c      **** 
1529:../uvc.c      ****     /* Return status of request handling to the USB driver */
1530:../uvc.c      ****     return uvcHandleReq;
1531:../uvc.c      **** }
1532:../uvc.c      **** 
1533:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1534:../uvc.c      **** 
1535:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1536:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1537:../uvc.c      ****  */
1538:../uvc.c      **** void
1539:../uvc.c      **** CyFxUvcApplnDmaCallback (
1540:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1541:../uvc.c      ****         CyU3PDmaCbType_t      type,
1542:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1543:../uvc.c      ****         )
1544:../uvc.c      **** {
1545:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1546:../uvc.c      **** #if 1
1547:../uvc.c      ****     CyU3PReturnStatus_t status;
1548:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
1549:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
1550:../uvc.c      **** 
1551:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1552:../uvc.c      ****     {
1553:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
1554:../uvc.c      ****             {
1555:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
1556:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
1557:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1558:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
1559:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
1560:../uvc.c      ****                 	stiflag = 0x03;
1561:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
1562:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1563:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
1564:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
1565:../uvc.c      ****                 }
1566:../uvc.c      **** #endif
1567:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
1568:../uvc.c      ****                 fb++;
1569:../uvc.c      ****             }
1570:../uvc.c      ****             else
1571:../uvc.c      ****             {
1572:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1573:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1574:../uvc.c      ****                 pb++;
1575:../uvc.c      ****                 pbc = input->buffer_p.count;
1576:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
1577:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
1578:../uvc.c      ****                 //lineCount = 0; //res test
1579:../uvc.c      **** #if 1   //remove the still flag clearing here
1580:../uvc.c      ****                 if(stiflag == 0x0F){
1581:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1582:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
1583:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
1584:../uvc.c      ****                 	stiflag = 0xAA;
1585:../uvc.c      ****                 }
1586:../uvc.c      **** #endif
1587:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
1588:../uvc.c      ****             }
1589:../uvc.c      **** 
1590:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1591:../uvc.c      ****             prodCount++;
1592:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1593:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1594:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
1595:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
1596:../uvc.c      ****             {
1597:../uvc.c      ****                 prodCount--;
1598:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
1599:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
1600:../uvc.c      ****             }
1601:../uvc.c      ****     }
1602:../uvc.c      **** #endif
1603:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1604:../uvc.c      ****     {
1605:../uvc.c      ****         consCount++;
1606:../uvc.c      ****         streamingStarted = CyTrue;
1607:../uvc.c      ****     }
1608:../uvc.c      **** }
1609:../uvc.c      **** 
1610:../uvc.c      **** /*
1611:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1612:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1613:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1614:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1615:../uvc.c      ****  * to commit the buffer.
1616:../uvc.c      ****  */
1617:../uvc.c      **** static uint8_t
1618:../uvc.c      **** CyFxUvcAppCommitEOF (
1619:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1620:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1621:../uvc.c      ****         )
1622:../uvc.c      **** {
1623:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1624:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1625:../uvc.c      **** 
1626:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1627:../uvc.c      **** 
1628:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1629:../uvc.c      ****     {
1630:../uvc.c      ****         switch (stateId)
1631:../uvc.c      ****         {
1632:../uvc.c      **** 
1633:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
1634:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1635:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1636:../uvc.c      ****                 break;
1637:../uvc.c      **** 
1638:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1639:../uvc.c      ****                 socket = 0;
1640:../uvc.c      ****                 break;
1641:../uvc.c      **** 
1642:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1643:../uvc.c      ****                 socket = 1;
1644:../uvc.c      ****                 break;
1645:../uvc.c      **** 
1646:../uvc.c      ****             default:
1647:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1648:../uvc.c      ****                 /* Unexpected current state. Return error. */
1649:../uvc.c      ****             	//lineCount++;
1650:../uvc.c      ****             	return 1;
1651:../uvc.c      ****         }
1652:../uvc.c      ****     }
1653:../uvc.c      **** 
1654:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1655:../uvc.c      ****     {
1656:../uvc.c      ****         switch (stateId)
1657:../uvc.c      ****         {
1658:../uvc.c      **** #ifndef CAM720
1659:../uvc.c      **** #ifdef GPIFIIM
1660:../uvc.c      ****             case 13:
1661:../uvc.c      ****             case 24:
1662:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1663:../uvc.c      ****                 break;
1664:../uvc.c      **** 
1665:../uvc.c      ****             case 8:
1666:../uvc.c      ****                 socket = 0;
1667:../uvc.c      ****                 break;
1668:../uvc.c      **** 
1669:../uvc.c      ****             case 20:
1670:../uvc.c      ****                 socket = 1;
1671:../uvc.c      ****                 break;
1672:../uvc.c      **** #else
1673:../uvc.c      ****             case 11:
1674:../uvc.c      ****             case 18:
1675:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1676:../uvc.c      ****                 break;
1677:../uvc.c      **** 
1678:../uvc.c      ****             case 8:
1679:../uvc.c      ****                 socket = 0;
1680:../uvc.c      ****                 break;
1681:../uvc.c      **** 
1682:../uvc.c      ****             case 15:
1683:../uvc.c      ****                 socket = 1;
1684:../uvc.c      ****                 break;
1685:../uvc.c      **** #endif
1686:../uvc.c      **** #else
1687:../uvc.c      ****             case 11:
1688:../uvc.c      ****             case 18:
1689:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1690:../uvc.c      ****                 break;
1691:../uvc.c      **** 
1692:../uvc.c      ****             case 8:
1693:../uvc.c      ****                 socket = 0;
1694:../uvc.c      ****                 break;
1695:../uvc.c      **** 
1696:../uvc.c      ****             case 15:
1697:../uvc.c      ****                 socket = 1;
1698:../uvc.c      ****                 break;
1699:../uvc.c      **** 
1700:../uvc.c      **** #endif
1701:../uvc.c      ****              default:
1702:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1703:../uvc.c      ****                 /* Unexpected current state. Return error. */
1704:../uvc.c      ****                return 1;
1705:../uvc.c      ****         }
1706:../uvc.c      ****     }
1707:../uvc.c      **** 
1708:../uvc.c      ****     if (socket != 0xFF)
1709:../uvc.c      ****     {
1710:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1711:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1712:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1713:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1714:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
1715:../uvc.c      ****         {
1716:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
1717:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
1718:../uvc.c      ****         }
1719:../uvc.c      ****     }
1720:../uvc.c      **** 
1721:../uvc.c      ****     return 0;
1722:../uvc.c      **** }
1723:../uvc.c      **** 
1724:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
1725:../uvc.c      **** void
1726:../uvc.c      **** CyFxGpifCB (
1727:../uvc.c      ****         CyU3PGpifEventType event,
1728:../uvc.c      ****         uint8_t currentState
1729:../uvc.c      ****         )
1730:../uvc.c      **** {
1731:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
1732:../uvc.c      ****     {
1733:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
1734:../uvc.c      ****     	           in the UVC implementation. */
1735:../uvc.c      ****     	//hitFV = CyTrue;
1736:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
1737:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
1738:../uvc.c      ****     }
1739:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
1740:../uvc.c      **** }
1741:../uvc.c      **** 
1742:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
1743:../uvc.c      **** static void
1744:../uvc.c      **** CyFxUVCApplnDebugInit (
1745:../uvc.c      ****         void)
1746:../uvc.c      **** {
1747:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
1748:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
1749:../uvc.c      **** 
1750:../uvc.c      ****     /* Initialize the UART for printing debug messages */
1751:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
1752:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1753:../uvc.c      ****     {
1754:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
1755:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1756:../uvc.c      ****     }
1757:../uvc.c      **** 
1758:../uvc.c      ****     /* Set UART Configuration */
1759:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1760:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1761:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1762:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1763:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1764:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1765:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1766:../uvc.c      **** 
1767:../uvc.c      ****     /* Set the UART configuration */
1768:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1769:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1770:../uvc.c      ****     {
1771:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1772:../uvc.c      ****     }
1773:../uvc.c      **** 
1774:../uvc.c      ****     /* Set the UART transfer */
1775:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
1776:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1777:../uvc.c      ****     {
1778:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1779:../uvc.c      ****     }
1780:../uvc.c      **** 
1781:../uvc.c      ****     /* Initialize the Debug logger module. */
1782:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
1783:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1784:../uvc.c      ****     {
1785:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1786:../uvc.c      ****     }
1787:../uvc.c      **** 
1788:../uvc.c      ****     /* Disable log message headers. */
1789:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
1790:../uvc.c      **** }
1791:../uvc.c      **** 
1792:../uvc.c      **** /* I2C initialization. */
1793:../uvc.c      **** static void
1794:../uvc.c      **** CyFxUVCApplnI2CInit (void)
1795:../uvc.c      **** {
1796:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
1797:../uvc.c      ****     CyU3PReturnStatus_t status;
1798:../uvc.c      **** 
1799:../uvc.c      ****     status = CyU3PI2cInit ();
1800:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
1801:../uvc.c      ****     {
1802:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
1803:../uvc.c      ****         CyFxAppErrorHandler (status);
1804:../uvc.c      ****     }
1805:../uvc.c      **** 
1806:../uvc.c      ****     /*  Set I2C Configuration */
1807:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
1808:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
1809:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
1810:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
1811:../uvc.c      **** 
1812:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
1813:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
1814:../uvc.c      ****     {
1815:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
1816:../uvc.c      ****         CyFxAppErrorHandler (status);
1817:../uvc.c      ****     }
1818:../uvc.c      **** }
1819:../uvc.c      **** 
1820:../uvc.c      **** #ifdef BACKFLOW_DETECT
1821:../uvc.c      **** static void CyFxUvcAppPibCallback (
1822:../uvc.c      ****         CyU3PPibIntrType cbType,
1823:../uvc.c      ****         uint16_t cbArg)
1824:../uvc.c      **** {
1825:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
1826:../uvc.c      ****     {
1827:../uvc.c      ****         if (!back_flow_detected)
1828:../uvc.c      ****         {
1829:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
1830:../uvc.c      ****             back_flow_detected = 1;
1831:../uvc.c      ****         }
1832:../uvc.c      ****     }
1833:../uvc.c      **** }
1834:../uvc.c      **** #endif
1835:../uvc.c      **** 
1836:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1837:../uvc.c      **** static void
1838:../uvc.c      **** CyFxUvcAppDebugCallback (
1839:../uvc.c      ****         CyU3PDmaChannel   *handle,
1840:../uvc.c      ****         CyU3PDmaCbType_t   type,
1841:../uvc.c      ****         CyU3PDmaCBInput_t *input)
1842:../uvc.c      **** {
1843:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1844:../uvc.c      ****     {
1845:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
1846:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
1847:../uvc.c      ****     }
1848:../uvc.c      **** }
1849:../uvc.c      **** #endif
1850:../uvc.c      **** 
1851:../uvc.c      **** #if 0
1852:../uvc.c      **** static void CyFxAppIntEpCb(
1853:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
1854:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
1855:../uvc.c      **** 		uint8_t  ebNum)
1856:../uvc.c      **** 		{
1857:../uvc.c      **** 			//CyBool_t value;
1858:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
1859:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
1860:../uvc.c      **** 
1861:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
1862:../uvc.c      **** 		}
1863:../uvc.c      **** #endif
1864:../uvc.c      **** 
1865:../uvc.c      **** /* This function initializes the USB Module, creates event group,
1866:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
1867:../uvc.c      ****    configures the DMA module for the UVC Application */
1868:../uvc.c      **** static void
1869:../uvc.c      **** CyFxUVCApplnInit (void)
1870:../uvc.c      **** {
1871:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
1872:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
1873:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
1874:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
1875:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
1876:../uvc.c      ****     CyU3PPibClock_t              pibclock;
1877:../uvc.c      **** 
1878:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
1879:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
1880:../uvc.c      **** 
1881:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1882:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
1883:../uvc.c      **** #endif
1884:../uvc.c      **** 
1885:../uvc.c      ****     /* Create UVC event group */
1886:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
1887:../uvc.c      ****     if (apiRetStatus != 0)
1888:../uvc.c      ****     {
1889:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
1890:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1891:../uvc.c      ****     }
1892:../uvc.c      **** 
1893:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
1894:../uvc.c      ****     CyFxUvcAppPTZInit ();
1895:../uvc.c      **** #endif
1896:../uvc.c      **** 
1897:../uvc.c      ****     isUsbConnected = CyFalse;
1898:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
1899:../uvc.c      **** 
1900:../uvc.c      ****     /* Init the GPIO module */
1901:../uvc.c      ****     gpioClock.fastClkDiv = 2;
1902:../uvc.c      ****     gpioClock.slowClkDiv = 2;
1903:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
1904:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
1905:../uvc.c      ****     gpioClock.halfDiv    = 0;
1906:../uvc.c      **** 
1907:../uvc.c      ****     /* Initialize Gpio interface */
1908:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
1909:../uvc.c      ****     if (apiRetStatus != 0)
1910:../uvc.c      ****     {
1911:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
1912:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1913:../uvc.c      ****     }
1914:../uvc.c      **** 
1915:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
1916:../uvc.c      ****      * must use GpioOverride to configure it */
1917:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
1918:../uvc.c      ****     if (apiRetStatus != 0)
1919:../uvc.c      ****     {
1920:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
1921:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1922:../uvc.c      ****     }
1923:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
1924:../uvc.c      ****     if (apiRetStatus != 0)
1925:../uvc.c      ****     {
1926:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
1927:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1928:../uvc.c      ****     }
1929:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
1930:../uvc.c      ****     if (apiRetStatus != 0)
1931:../uvc.c      ****     {
1932:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
1933:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1934:../uvc.c      ****     }
1935:../uvc.c      **** 
1936:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
1937:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1938:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1939:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1940:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1941:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1942:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
1943:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1944:../uvc.c      ****     {
1945:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
1946:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1947:../uvc.c      ****     }
1948:../uvc.c      **** 
1949:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
1950:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1951:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1952:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1953:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1954:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1955:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1956:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
1957:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1958:../uvc.c      ****     {
1959:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
1960:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1961:../uvc.c      ****     }
1962:../uvc.c      **** 
1963:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
1964:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1965:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
1966:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
1967:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
1968:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
1969:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1970:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
1971:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1972:../uvc.c      ****     {
1973:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
1974:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1975:../uvc.c      ****     }
1976:../uvc.c      **** 
1977:../uvc.c      ****     /* Initialize the P-port. */
1978:../uvc.c      ****     pibclock.clkDiv      = 2;
1979:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
1980:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
1981:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
1982:../uvc.c      **** 
1983:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
1984:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1985:../uvc.c      ****     {
1986:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1987:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1988:../uvc.c      ****     }
1989:../uvc.c      **** 
1990:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
1991:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
1992:../uvc.c      **** 
1993:../uvc.c      **** #ifdef BACKFLOW_DETECT
1994:../uvc.c      ****     back_flow_detected = 0;
1995:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
1996:../uvc.c      **** #endif
1997:../uvc.c      **** 
1998:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
1999:../uvc.c      ****     SensorReset ();
2000:../uvc.c      ****     CyU3PThreadSleep(5000);
2001:../uvc.c      ****     //SensorInit ();
2002:../uvc.c      **** 
2003:../uvc.c      ****     /* USB initialization. */
2004:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
2005:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2006:../uvc.c      ****     {
2007:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2008:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2009:../uvc.c      ****     }
2010:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
2011:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
2012:../uvc.c      **** 
2013:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
2014:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
2015:../uvc.c      **** 
2016:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
2017:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
2018:../uvc.c      **** 
2019:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
2020:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
2021:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
2022:../uvc.c      **** 
2023:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
2024:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
2025:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
2026:../uvc.c      **** 
2027:../uvc.c      ****     /* Configuration descriptors. */
2028:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
2029:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
2030:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
2031:../uvc.c      **** 
2032:../uvc.c      ****     /* String Descriptors */
2033:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
2034:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
2035:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
2036:../uvc.c      **** 
2037:../uvc.c      ****     /* Configure the status interrupt endpoint.
2038:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
2039:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
2040:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
2041:../uvc.c      ****      */
2042:../uvc.c      ****     endPointConfig.enable   = 1;
2043:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
2044:../uvc.c      ****     endPointConfig.pcktSize = 64;
2045:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2046:../uvc.c      ****     endPointConfig.streams  = 0;
2047:../uvc.c      ****     endPointConfig.burstLen = 1;
2048:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
2049:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2050:../uvc.c      ****     {
2051:../uvc.c      ****         /* Error Handling */
2052:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2053:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2054:../uvc.c      ****     }
2055:../uvc.c      **** 
2056:../uvc.c      ****     /* create a DMA for interrupt endpoint */
2057:../uvc.c      ****     dmaInterConfig.size           = 1024;
2058:../uvc.c      ****     dmaInterConfig.count          = 1;
2059:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2060:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
2061:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
2062:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
2063:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
2064:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2065:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2066:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2067:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2068:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2069:../uvc.c      ****             &dmaInterConfig);
2070:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2071:../uvc.c      ****     {
2072:../uvc.c      ****         /* Error handling */
2073:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2074:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2075:../uvc.c      ****     }
2076:../uvc.c      **** 
2077:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2078:../uvc.c      ****     if (glInterStaBuffer == 0)
2079:../uvc.c      ****     {
2080:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2081:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2082:../uvc.c      ****     }
2083:../uvc.c      **** 
2084:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2085:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
2086:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2087:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2088:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2089:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2090:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2091:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2092:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2093:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2094:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2095:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2096:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2097:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2098:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2099:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2100:../uvc.c      ****             &dmaMultiConfig);
2101:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2102:../uvc.c      ****     {
2103:../uvc.c      ****         /* Error handling */
2104:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2105:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2106:../uvc.c      ****     }
2107:../uvc.c      **** 
2108:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2109:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2110:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2111:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2112:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2113:../uvc.c      ****      */
2114:../uvc.c      **** 
2115:../uvc.c      ****     endPointConfig.enable   = 1;
2116:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2117:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2118:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2119:../uvc.c      ****     endPointConfig.streams  = 0;
2120:../uvc.c      ****     endPointConfig.burstLen = 1;
2121:../uvc.c      **** 
2122:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2123:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2124:../uvc.c      ****     {
2125:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2126:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2127:../uvc.c      ****     }
2128:../uvc.c      **** 
2129:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2130:../uvc.c      **** 
2131:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2132:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2133:../uvc.c      ****     {
2134:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2135:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2136:../uvc.c      ****     }
2137:../uvc.c      **** 
2138:../uvc.c      ****     channelConfig.size           = 1024;
2139:../uvc.c      ****     channelConfig.count          = 1;
2140:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2141:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2142:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2143:../uvc.c      ****     channelConfig.prodHeader     = 0;
2144:../uvc.c      ****     channelConfig.prodFooter     = 0;
2145:../uvc.c      ****     channelConfig.consHeader     = 0;
2146:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2147:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2148:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2149:../uvc.c      **** 
2150:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2151:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2152:../uvc.c      ****     {
2153:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2154:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2155:../uvc.c      ****     }
2156:../uvc.c      **** 
2157:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2158:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2159:../uvc.c      ****     {
2160:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2161:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2162:../uvc.c      ****     }
2163:../uvc.c      **** 
2164:../uvc.c      ****     channelConfig.size           = 1024;
2165:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2166:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2167:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2168:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2169:../uvc.c      ****     channelConfig.prodHeader     = 0;
2170:../uvc.c      ****     channelConfig.prodFooter     = 0;
2171:../uvc.c      ****     channelConfig.consHeader     = 0;
2172:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2173:../uvc.c      ****     channelConfig.notification   = 0;
2174:../uvc.c      ****     channelConfig.cb             = 0;
2175:../uvc.c      **** 
2176:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2177:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2178:../uvc.c      ****     {
2179:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2180:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2181:../uvc.c      ****     }
2182:../uvc.c      **** 
2183:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2184:../uvc.c      ****     if (glDebugRspBuffer == 0)
2185:../uvc.c      ****     {
2186:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2187:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2188:../uvc.c      ****     }
2189:../uvc.c      **** #endif
2190:../uvc.c      **** 
2191:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2192:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2193:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2194:../uvc.c      ****     {
2195:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2196:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2197:../uvc.c      ****     }
2198:../uvc.c      **** 
2199:../uvc.c      ****     CyU3PBusyWait(100);
2200:../uvc.c      **** 
2201:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2202:../uvc.c      **** 
2203:../uvc.c      ****     endPointConfig.enable   = 1;
2204:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2205:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2206:../uvc.c      ****     {
2207:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2208:../uvc.c      ****     	endPointConfig.burstLen = 16;
2209:../uvc.c      ****     }
2210:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2211:../uvc.c      ****     {
2212:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2213:../uvc.c      ****     	endPointConfig.burstLen = 1;
2214:../uvc.c      ****     }
2215:../uvc.c      ****     endPointConfig.streams  = 0;
2216:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2217:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2218:../uvc.c      ****     {
2219:../uvc.c      ****         /* Error Handling */
2220:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2221:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2222:../uvc.c      ****     }
2223:../uvc.c      **** #if 0    //for still image method 3 using
2224:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2225:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2226:../uvc.c      ****     {
2227:../uvc.c      ****         /* Error Handling */
2228:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2229:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2230:../uvc.c      ****     }
2231:../uvc.c      **** #endif
2232:../uvc.c      **** 
2233:../uvc.c      **** }
2234:../uvc.c      **** 
2235:../uvc.c      **** /*
2236:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2237:../uvc.c      ****  * streaming session is started.
2238:../uvc.c      ****  */
2239:../uvc.c      **** static void
2240:../uvc.c      **** CyFxUvcAppGpifInit (
2241:../uvc.c      ****         void)
2242:../uvc.c      **** {
2243:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2244:../uvc.c      **** 
2245:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2246:../uvc.c      ****     {
2247:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2248:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2249:../uvc.c      ****     }
2250:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2251:../uvc.c      ****     {
2252:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2253:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2254:../uvc.c      ****     }
2255:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2256:../uvc.c      ****     {
2257:../uvc.c      ****         /* Error Handling */
2258:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2259:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2260:../uvc.c      ****     }
2261:../uvc.c      **** 
2262:../uvc.c      ****     /* Start the state machine from the designated start state. */
2263:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2264:../uvc.c      ****     {
2265:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2266:../uvc.c      ****     }
2267:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2268:../uvc.c      ****     {
2269:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2270:../uvc.c      ****     }
2271:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2272:../uvc.c      ****     {
2273:../uvc.c      ****         /* Error Handling */
2274:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2275:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2276:../uvc.c      ****     }
2277:../uvc.c      **** }
2278:../uvc.c      **** 
2279:../uvc.c      **** /*
2280:../uvc.c      ****  * Entry function for the UVC Application Thread
2281:../uvc.c      ****  */
2282:../uvc.c      **** 
2283:../uvc.c      **** uint32_t posTick;
2284:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2285:../uvc.c      **** 
2286:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2287:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2288:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2289:../uvc.c      **** }
2290:../uvc.c      **** 
2291:../uvc.c      **** 
2292:../uvc.c      **** void
2293:../uvc.c      **** UVCAppThread_Entry (
2294:../uvc.c      ****         uint32_t input)
2295:../uvc.c      **** {
2296:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2297:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2298:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2299:../uvc.c      ****     uint8_t i = 0;
2300:../uvc.c      ****     uint32_t flag;
2301:../uvc.c      ****     uint32_t prinflag = 0;
2302:../uvc.c      **** static uint8_t IMcount = 0;
2303:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2304:../uvc.c      ****     uint32_t frameCnt = 0;
2305:../uvc.c      **** #endif
2306:../uvc.c      ****     /* Initialize the Uart Debug Module */
2307:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2308:../uvc.c      **** 
2309:../uvc.c      ****     /* Initialize the I2C interface */
2310:../uvc.c      **** 	while (i++ < 6){
2311:../uvc.c      **** 		CyU3PThreadSleep(500);
2312:../uvc.c      **** 	}
2313:../uvc.c      **** 
2314:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2315:../uvc.c      **** 
2316:../uvc.c      ****     /* Initialize the UVC Application */
2317:../uvc.c      ****     CyFxUVCApplnInit ();
2318:../uvc.c      ****     /*
2319:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2320:../uvc.c      **** 
2321:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2322:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2323:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2324:../uvc.c      **** 
2325:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2326:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2327:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2328:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2329:../uvc.c      **** 
2330:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2331:../uvc.c      ****        of handling the abort request.
2332:../uvc.c      ****      */
2333:../uvc.c      **** 
2334:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
2335:../uvc.c      ****     //CyU3PThreadSleep(1000);
2336:../uvc.c      **** 
2337:../uvc.c      ****     for (;;)
2338:../uvc.c      ****     {
2339:../uvc.c      ****         /* Waiting for the Video Stream Event */
2340:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2341:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2342:../uvc.c      ****         {
2343:../uvc.c      **** #if 0 //test for new firmware no video bring up
2344:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2345:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2346:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2347:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2348:../uvc.c      ****             {
2349:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2350:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2351:../uvc.c      ****                 {
2352:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2353:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2354:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2355:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2356:../uvc.c      **** #endif
2357:../uvc.c      **** #endif
2358:../uvc.c      ****                     }
2359:../uvc.c      ****                 else
2360:../uvc.c      ****                 {
2361:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2362:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2363:../uvc.c      **** #ifdef USB_LOWRES_IMG
2364:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2365:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2366:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2367:../uvc.c      **** #endif
2368:../uvc.c      **** #endif
2369:../uvc.c      ****                 }
2370:../uvc.c      **** 
2371:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2372:../uvc.c      ****                 prodCount++;
2373:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2374:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2375:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2376:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2377:../uvc.c      ****                 {
2378:../uvc.c      ****                     prodCount--;
2379:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2380:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2381:../uvc.c      ****                 }
2382:../uvc.c      ****             }
2383:../uvc.c      **** #endif
2384:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2385:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2386:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2387:../uvc.c      ****             {
2388:../uvc.c      ****             	if(0&&(prinflag == 0)){
2389:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2390:../uvc.c      ****             		prinflag = 1;
2391:../uvc.c      ****             	}
2392:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2393:../uvc.c      ****             	fb=0;
2394:../uvc.c      ****             	pb=0;
2395:../uvc.c      ****             	pbc=0;
2396:../uvc.c      ****                 prodCount = 0;
2397:../uvc.c      ****                 consCount = 0;
2398:../uvc.c      ****                 hitFV     = CyFalse;
2399:../uvc.c      **** 
2400:../uvc.c      **** #ifdef BACKFLOW_DETECT
2401:../uvc.c      ****                 back_flow_detected = 0;
2402:../uvc.c      **** #endif
2403:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2404:../uvc.c      ****                 frameCnt++;
2405:../uvc.c      **** #endif
2406:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2407:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2408:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2409:../uvc.c      ****                 //}
2410:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2411:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2412:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2413:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
2414:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
2415:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
2416:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
2417:../uvc.c      ****                        	SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*bo
2418:../uvc.c      ****                      	//CyU3PThreadSleep(100);
2419:../uvc.c      ****                 		stiflag = 0xFF;
2420:../uvc.c      ****                 		IMcount = 0;
2421:../uvc.c      ****                 	}
2422:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
2423:../uvc.c      **** 
2424:../uvc.c      ****                  		if(IMcount++ >= 0x3){
2425:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
2426:../uvc.c      ****                 		stiflag = 0x0F;
2427:../uvc.c      ****                 		IMcount = 0;
2428:../uvc.c      ****                 		}
2429:../uvc.c      ****                  		/*if(IMcount > 0x4){
2430:../uvc.c      ****                 			stiflag = 0x0F;
2431:../uvc.c      ****                 			IMcount = 0;
2432:../uvc.c      ****                 		}*/
2433:../uvc.c      **** 
2434:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
2435:../uvc.c      ****                     //CyU3PThreadSleep(400);
2436:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2437:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2438:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2439:../uvc.c      **** 
2440:../uvc.c      ****                 	if(IMcount++ >= 0x4)
2441:../uvc.c      ****                 	{
2442:../uvc.c      ****                     switch (setRes)
2443:../uvc.c      ****                      {
2444:../uvc.c      ****                  	case 1: //1944
2445:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
2446:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2447:../uvc.c      ****                         //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x64:0xE
2448:../uvc.c      ****                  		break;
2449:../uvc.c      ****                  	case 2: //1080
2450:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
2451:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2452:../uvc.c      ****                         //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x54:0xD
2453:../uvc.c      ****                  		break;
2454:../uvc.c      ****                  	case 3: //720
2455:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
2456:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2457:../uvc.c      ****                         //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 0x45:0
2458:../uvc.c      ****                  		break;
2459:../uvc.c      ****                  	default:
2460:../uvc.c      ****                  		break;
2461:../uvc.c      ****                      }
2462:../uvc.c      ****                     IMcount = 0;
2463:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2464:../uvc.c      ****                 	stiflag = 0x0;
2465:../uvc.c      ****                 	}
2466:../uvc.c      ****                 }
2467:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
2468:../uvc.c      ****                 /* Reset the DMA channel. */
2469:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2470:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2471:../uvc.c      ****                 {
2472:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2473:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2474:../uvc.c      ****                 }
2475:../uvc.c      **** 
2476:../uvc.c      ****                 /* Start Channel Immediately */
2477:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2478:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2479:../uvc.c      ****                 {
2480:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2481:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2482:../uvc.c      ****                 }
2483:../uvc.c      **** 
2484:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2485:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2486:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2487:../uvc.c      ****                 }
2488:../uvc.c      ****         }
2489:../uvc.c      ****         else
2490:../uvc.c      ****         {
2491:../uvc.c      ****             /* If we have a stream abort request pending. */
2492:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2493:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2494:../uvc.c      ****             {
2495:../uvc.c      ****                 hitFV     = CyFalse;
2496:../uvc.c      ****                 prodCount = 0;
2497:../uvc.c      ****                 consCount = 0;
2498:../uvc.c      ****                 if(0&&(prinflag == 0)){
2499:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2500:../uvc.c      ****                 	prinflag = 1;
2501:../uvc.c      ****                 }
2502:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2503:../uvc.c      ****                 fb=0;
2504:../uvc.c      ****                 pb=0;
2505:../uvc.c      ****                 pbc=0;
2506:../uvc.c      **** 
2507:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2508:../uvc.c      ****                 {
2509:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2510:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2511:../uvc.c      ****                     {
2512:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2513:../uvc.c      ****                     }
2514:../uvc.c      **** 
2515:../uvc.c      ****                     /* Flush the Endpoint memory */
2516:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2517:../uvc.c      ****                 }
2518:../uvc.c      **** 
2519:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2520:../uvc.c      ****             }
2521:../uvc.c      ****             else
2522:../uvc.c      ****             {
2523:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2524:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2525:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2526:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2527:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2528:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2529:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2530:../uvc.c      ****                 {
2531:../uvc.c      ****                     /* Error handling */
2532:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2533:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2534:../uvc.c      ****                 }
2535:../uvc.c      **** 
2536:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2537:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2538:../uvc.c      ****                 {
2539:../uvc.c      **** #if 0
2540:../uvc.c      ****                 	//for start up of the AF Lens
2541:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2542:../uvc.c      ****                     CyU3PThreadSleep(500);
2543:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2544:../uvc.c      ****                     CyU3PThreadSleep(500);
2545:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2546:../uvc.c      ****                    	CyU3PThreadSleep(300);
2547:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2548:../uvc.c      ****                     CyU3PThreadSleep(500);
2549:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2550:../uvc.c      ****                     CyU3PThreadSleep(500);
2551:../uvc.c      **** #endif
2552:../uvc.c      **** #if 0
2553:../uvc.c      ****                     switch (setRes)
2554:../uvc.c      ****                     {
2555:../uvc.c      ****                     	case 1: //1944
2556:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x64, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
2557:../uvc.c      ****                     		CyU3PThreadSleep(1000);
2558:../uvc.c      ****                     		break;
2559:../uvc.c      ****                     	case 2: //1080
2560:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x54, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
2561:../uvc.c      ****                     		CyU3PThreadSleep(1000);
2562:../uvc.c      ****                     		break;
2563:../uvc.c      ****                     	case 3: //720
2564:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x45, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
2565:../uvc.c      ****                     		CyU3PThreadSleep(1000);
2566:../uvc.c      ****                     		break;
2567:../uvc.c      ****                     	default:
2568:../uvc.c      ****                     		break;
2569:../uvc.c      ****                     }
2570:../uvc.c      **** #endif
2571:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2572:../uvc.c      **** 
2573:../uvc.c      ****                     gpif_initialized = CyTrue;
2574:../uvc.c      ****                     CyU3PThreadSleep(200);
2575:../uvc.c      ****                     
2576:../uvc.c      ****                 }
2577:../uvc.c      ****                 else
2578:../uvc.c      ****                 {
2579:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2580:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2581:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2582:../uvc.c      ****                 }
2583:../uvc.c      ****             }
2584:../uvc.c      ****         }
2585:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2586:../uvc.c      **** 
2587:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2588:../uvc.c      ****         CyU3PThreadRelinquish ();
2589:../uvc.c      ****     }
2590:../uvc.c      **** }
2591:../uvc.c      **** 
2592:../uvc.c      **** /*
2593:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2594:../uvc.c      ****  */
2595:../uvc.c      **** 
2596:../uvc.c      **** static void
2597:../uvc.c      **** UVCHandleProcessingUnitRqts (
2598:../uvc.c      ****         void)
2599:../uvc.c      **** {
2600:../uvc.c      ****     uint8_t CtrlAdd;
2601:../uvc.c      **** #ifdef DbgInfo
2602:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2603:../uvc.c      **** #endif
2604:../uvc.c      ****     switch (wValue)
2605:../uvc.c      ****     {
2606:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2607:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2608:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2609:../uvc.c      ****     		break;
2610:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2611:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
2612:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
2613:../uvc.c      ****     		break;
2614:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2615:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2616:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2617:../uvc.c      **** 			break;
2618:../uvc.c      **** 
2619:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2620:../uvc.c      **** 
2621:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2622:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2623:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2624:../uvc.c      ****       		break;
2625:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2626:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2627:../uvc.c      ****      		ControlHandle(HueCtlID5);
2628:../uvc.c      ****      		break;
2629:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2630:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2631:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2632:../uvc.c      ****           		break;
2633:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2634:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2635:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2636:../uvc.c      ****           		break;
2637:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2638:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2639:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2640:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2641:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2642:../uvc.c      ****     		break;
2643:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2644:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2645:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2646:../uvc.c      ****     		break;
2647:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2648:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2649:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2650:../uvc.c      ****     		break;
2651:../uvc.c      **** 
2652:../uvc.c      ****         default:
2653:../uvc.c      ****             /*
2654:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2655:../uvc.c      ****              * other controls.
2656:../uvc.c      ****              */
2657:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2658:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2659:../uvc.c      ****             break;
2660:../uvc.c      ****     }
2661:../uvc.c      **** }
2662:../uvc.c      **** 
2663:../uvc.c      **** /*
2664:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2665:../uvc.c      ****  */
2666:../uvc.c      **** static void
2667:../uvc.c      **** UVCHandleCameraTerminalRqts (
2668:../uvc.c      ****         void)
2669:../uvc.c      **** {
2670:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2671:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2672:../uvc.c      ****     uint16_t readCount;
2673:../uvc.c      ****     uint16_t zoomVal;
2674:../uvc.c      ****     int32_t  panVal, tiltVal;
2675:../uvc.c      ****     CyBool_t sendData = CyFalse;
2676:../uvc.c      **** #endif
2677:../uvc.c      ****     uint8_t CtrlAdd;
2678:../uvc.c      **** 
2679:../uvc.c      ****     switch (wValue)
2680:../uvc.c      ****     {
2681:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2682:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2683:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2684:../uvc.c      ****     		break;
2685:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2686:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2687:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2688:../uvc.c      ****     		break;
2689:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2690:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2691:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2692:../uvc.c      **** 			break;
2693:../uvc.c      **** 
2694:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2695:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2696:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2697:../uvc.c      **** 			break;
2698:../uvc.c      **** 
2699:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2700:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2701:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2702:../uvc.c      ****       		break;
2703:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2704:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2705:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2706:../uvc.c      ****      		break;
2707:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2708:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2709:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2710:../uvc.c      ****           		break;
2711:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2712:../uvc.c      ****           		break;
2713:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2714:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
2715:../uvc.c      ****      		CTControlHandle(IriACtlID7);
2716:../uvc.c      ****      		break;
2717:../uvc.c      **** 
2718:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
2719:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
2720:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
2721:../uvc.c      ****     		break;
2722:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2723:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
2724:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
2725:../uvc.c      ****     		break;
2726:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
2727:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
2728:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
2729:../uvc.c      ****     		break;
2730:../uvc.c      **** 
2731:../uvc.c      ****         default:
2732:../uvc.c      ****             /*
2733:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2734:../uvc.c      ****              * other controls.
2735:../uvc.c      ****              */
2736:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2737:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2738:../uvc.c      ****             break;
2739:../uvc.c      ****     }
2740:../uvc.c      **** 
2741:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2742:../uvc.c      ****     switch (wValue)
2743:../uvc.c      ****     {
2744:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2745:../uvc.c      ****             switch (bRequest)
2746:../uvc.c      ****             {
2747:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2748:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
2749:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2750:../uvc.c      ****                     break;
2751:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
2752:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
2753:../uvc.c      ****                     sendData = CyTrue;
2754:../uvc.c      ****                     break;
2755:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
2756:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
2757:../uvc.c      ****                     sendData = CyTrue;
2758:../uvc.c      ****                     break;
2759:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
2760:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
2761:../uvc.c      ****                     sendData = CyTrue;
2762:../uvc.c      ****                     break;
2763:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
2764:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
2765:../uvc.c      ****                     sendData = CyTrue;
2766:../uvc.c      ****                     break;
2767:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
2768:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
2769:../uvc.c      ****                     sendData = CyTrue;
2770:../uvc.c      ****                     break;
2771:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2772:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2773:../uvc.c      ****                             glEp0Buffer, &readCount);
2774:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2775:../uvc.c      ****                     {
2776:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
2777:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
2778:../uvc.c      ****                     }
2779:../uvc.c      ****                     break;
2780:../uvc.c      ****                 default:
2781:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2782:../uvc.c      ****                     break;
2783:../uvc.c      ****             }
2784:../uvc.c      **** 
2785:../uvc.c      ****             if (sendData)
2786:../uvc.c      ****             {
2787:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
2788:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
2789:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
2790:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2791:../uvc.c      ****             }
2792:../uvc.c      ****             break;
2793:../uvc.c      **** 
2794:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
2795:../uvc.c      ****             switch (bRequest)
2796:../uvc.c      ****             {
2797:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2798:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
2799:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2800:../uvc.c      ****                     break;
2801:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2802:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
2803:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
2804:../uvc.c      ****                     sendData = CyTrue;
2805:../uvc.c      ****                     break;
2806:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2807:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
2808:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
2809:../uvc.c      ****                     sendData = CyTrue;
2810:../uvc.c      ****                     break;
2811:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2812:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
2813:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
2814:../uvc.c      ****                     sendData = CyTrue;
2815:../uvc.c      ****                     break;
2816:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
2817:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
2818:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
2819:../uvc.c      ****                     sendData = CyTrue;
2820:../uvc.c      ****                     break;
2821:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
2822:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
2823:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
2824:../uvc.c      ****                     sendData = CyTrue;
2825:../uvc.c      ****                     break;
2826:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2827:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2828:../uvc.c      ****                             glEp0Buffer, &readCount);
2829:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2830:../uvc.c      ****                     {
2831:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
2832:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
2833:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
2834:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
2835:../uvc.c      **** 
2836:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
2837:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
2838:../uvc.c      ****                     }
2839:../uvc.c      ****                     break;
2840:../uvc.c      ****                 default:
2841:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2842:../uvc.c      ****                     break;
2843:../uvc.c      ****             }
2844:../uvc.c      **** 
2845:../uvc.c      ****             if (sendData)
2846:../uvc.c      ****             {
2847:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
2848:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
2849:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
2850:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
2851:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
2852:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
2853:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
2854:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
2855:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
2856:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2857:../uvc.c      ****             }
2858:../uvc.c      ****             break;
2859:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
2860:../uvc.c      ****         default:
2861:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
2862:../uvc.c      ****             break;
2863:../uvc.c      ****     }
2864:../uvc.c      **** #endif
2865:../uvc.c      **** }
2866:../uvc.c      **** 
2867:../uvc.c      **** /*
2868:../uvc.c      ****  * Handler for UVC Interface control requests.
2869:../uvc.c      ****  */
2870:../uvc.c      **** static void
2871:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
2872:../uvc.c      ****         void)
2873:../uvc.c      **** {
2874:../uvc.c      **** 
2875:../uvc.c      ****     switch (wValue)
2876:../uvc.c      ****     {
2877:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
2878:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2879:../uvc.c      ****     		break;
2880:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
2881:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
2882:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
2883:../uvc.c      ****     		break;
2884:../uvc.c      ****     	default:
2885:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
2886:../uvc.c      ****      		break;
2887:../uvc.c      ****     }
2888:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
2889:../uvc.c      **** 
2890:../uvc.c      **** }
2891:../uvc.c      **** 
2892:../uvc.c      **** /*
2893:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
2894:../uvc.c      ****  */
2895:../uvc.c      **** static void
2896:../uvc.c      **** UVCHandleExtensionUnitRqts (
2897:../uvc.c      ****         void)
2898:../uvc.c      **** {
2899:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
2900:../uvc.c      **** 
2901:../uvc.c      **** #ifdef DbgInfo
2902:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2903:../uvc.c      **** #endif
2904:../uvc.c      ****     switch (wValue)
2905:../uvc.c      ****     {
2906:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
2907:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
2908:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
2909:../uvc.c      ****     		break;
2910:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
2911:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
2912:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
2913:../uvc.c      ****     		break;
2914:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
2915:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
2916:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
2917:../uvc.c      ****      		break;
2918:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
2919:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
2920:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
2921:../uvc.c      ****     		break;
2922:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
2923:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
2924:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
2925:../uvc.c      ****     		break;
2926:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
2927:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
2928:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
2929:../uvc.c      ****      		break;
2930:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
2931:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
2932:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
2933:../uvc.c      ****     		break;
2934:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
2935:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
2936:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
2937:../uvc.c      ****     		break;
2938:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
2939:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
2940:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
2941:../uvc.c      ****      		break;
2942:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
2943:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
2944:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
2945:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
2946:../uvc.c      ****     		}else/* no support for 1080p camera */
2947:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
2948:../uvc.c      ****     		break;
2949:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
2950:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
2951:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
2952:../uvc.c      ****     		break;
2953:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
2954:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
2955:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
2956:../uvc.c      ****     		break;
2957:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
2958:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
2959:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
2960:../uvc.c      ****     		//break;
2961:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
2962:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
2963:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
2964:../uvc.c      ****     		break;
2965:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
2966:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
2967:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
2968:../uvc.c      ****     		break;
2969:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
2970:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID0-EXUAOFFSET][0];
2971:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
2972:../uvc.c      ****     		break;
2973:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
2974:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID1-EXUAOFFSET][0];
2975:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
2976:../uvc.c      ****     		break;
2977:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
2978:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID2-EXUAOFFSET][0];
2979:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
2980:../uvc.c      ****     		break;
2981:../uvc.c      ****    	default:
2982:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
2983:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2984:../uvc.c      ****     		break;
2985:../uvc.c      ****     }
2986:../uvc.c      **** 
2987:../uvc.c      **** }
2988:../uvc.c      **** 
2989:../uvc.c      **** /*
2990:../uvc.c      ****  * Handler for the video streaming control requests.
2991:../uvc.c      ****  */
2992:../uvc.c      **** static void
2993:../uvc.c      **** UVCHandleVideoStreamingRqts (
2994:../uvc.c      ****         void)
2995:../uvc.c      **** {
2996:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2997:../uvc.c      ****     uint16_t readCount;
2998:../uvc.c      **** 
2999:../uvc.c      ****     switch (wValue)
3000:../uvc.c      ****     {
3001:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
3002:../uvc.c      ****             switch (bRequest)
3003:../uvc.c      ****             {
3004:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3005:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3006:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3007:../uvc.c      ****                     break;
3008:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3009:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3010:../uvc.c      ****                     glEp0Buffer[1] = 0;
3011:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3012:../uvc.c      ****                     break;
3013:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3014:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3015:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3016:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3017:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3018:../uvc.c      ****                     {
3019:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
3020:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
3021:../uvc.c      **** 
3022:../uvc.c      ****                     }
3023:../uvc.c      ****                     else
3024:../uvc.c      ****                     {
3025:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3026:../uvc.c      ****                     }
3027:../uvc.c      ****                     break;
3028:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3029:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3030:../uvc.c      ****                             glCommitCtrl, &readCount);
3031:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3032:../uvc.c      ****                     {
3033:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3034:../uvc.c      ****                         {
3035:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
3036:../uvc.c      ****                                active data structure. */
3037:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
3038:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
3039:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
3040:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
3041:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
3042:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
3043:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
3044:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
3045:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
3046:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
3047:../uvc.c      **** #if 0
3048:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
3049:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
3050:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
3051:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
3052:../uvc.c      **** #endif
3053:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
3054:../uvc.c      ****                        }
3055:../uvc.c      ****                     }
3056:../uvc.c      ****                     break;
3057:../uvc.c      ****                 default:
3058:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3059:../uvc.c      ****                     break;
3060:../uvc.c      ****             }
3061:../uvc.c      ****             break;
3062:../uvc.c      **** 
3063:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
3064:../uvc.c      ****             switch (bRequest)
3065:../uvc.c      ****             {
3066:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3067:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
3068:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3069:../uvc.c      ****                     break;
3070:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3071:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3072:../uvc.c      ****                     glEp0Buffer[1] = 0;
3073:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3074:../uvc.c      ****                     break;
3075:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3076:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3077:../uvc.c      ****                     {
3078:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
3079:../uvc.c      ****                     }
3080:../uvc.c      ****                     else
3081:../uvc.c      ****                     {
3082:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3083:../uvc.c      ****                     }
3084:../uvc.c      ****                     break;
3085:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3086:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
3087:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
3088:../uvc.c      ****                        */
3089:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3090:../uvc.c      ****                             glCommitCtrl, &readCount);
3091:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3092:../uvc.c      ****                     {
3093:../uvc.c      ****                         switch (glCommitCtrl[3])
3094:../uvc.c      ****                          {
3095:../uvc.c      ****                          	case 1: //1944
3096:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
3097:../uvc.c      ****                          		CyU3PThreadSleep(500);
3098:../uvc.c      ****                                 //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 
3099:../uvc.c      ****                          		break;
3100:../uvc.c      ****                          	case 2: //1080
3101:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
3102:../uvc.c      ****                          		CyU3PThreadSleep(500);
3103:../uvc.c      ****                                 //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 
3104:../uvc.c      ****                          		break;
3105:../uvc.c      ****                          	case 3: //720
3106:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
3107:../uvc.c      ****                          		CyU3PThreadSleep(500);
3108:../uvc.c      ****                                 //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz
3109:../uvc.c      ****                          		break;
3110:../uvc.c      ****                          	default:
3111:../uvc.c      ****                          		break;
3112:../uvc.c      ****                          }
3113:../uvc.c      ****                         setRes = glCommitCtrl[3];
3114:../uvc.c      **** #if 0
3115:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
3116:../uvc.c      ****                         {
3117:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
3118:../uvc.c      ****                         }
3119:../uvc.c      ****                         else
3120:../uvc.c      ****                         {
3121:../uvc.c      ****                             SensorScaling_VGA ();
3122:../uvc.c      ****                         }
3123:../uvc.c      **** #endif
3124:../uvc.c      ****                         /* We can start streaming video now. */
3125:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
3126:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
3127:../uvc.c      ****                         {
3128:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
3129:../uvc.c      ****                         }
3130:../uvc.c      ****                     }
3131:../uvc.c      ****                     break;
3132:../uvc.c      **** 
3133:../uvc.c      ****                 default:
3134:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3135:../uvc.c      ****                     break;
3136:../uvc.c      ****             }
3137:../uvc.c      ****             break;
3138:../uvc.c      **** 
3139:../uvc.c      **** /* still image streaming handler */
3140:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
3141:../uvc.c      ****                 switch (bRequest)
3142:../uvc.c      ****                 {
3143:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3144:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3145:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3146:../uvc.c      ****                         break;
3147:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3148:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3149:../uvc.c      ****                         glEp0Buffer[1] = 0;
3150:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3151:../uvc.c      ****                         break;
3152:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3153:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3154:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3155:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3156:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3157:../uvc.c      ****                         {
3158:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3159:../uvc.c      ****                         }
3160:../uvc.c      ****                         else
3161:../uvc.c      ****                         {
3162:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3163:../uvc.c      ****                         }
3164:../uvc.c      ****                         break;
3165:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3166:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3167:../uvc.c      ****                                 glCommitCtrl, &readCount);
3168:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3169:../uvc.c      ****                         {
3170:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
3171:../uvc.c      ****                             {
3172:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
3173:../uvc.c      ****                                    active data structure. */
3174:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3175:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3176:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
3177:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
3178:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
3179:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
3180:../uvc.c      ****                             }
3181:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
3182:../uvc.c      ****                         }
3183:../uvc.c      ****                         break;
3184:../uvc.c      ****                     default:
3185:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3186:../uvc.c      ****                         break;
3187:../uvc.c      ****                 }
3188:../uvc.c      ****                 break;
3189:../uvc.c      **** 
3190:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
3191:../uvc.c      ****                 switch (bRequest)
3192:../uvc.c      ****                 {
3193:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3194:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3195:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3196:../uvc.c      ****                         break;
3197:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3198:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3199:../uvc.c      ****                         glEp0Buffer[1] = 0;
3200:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3201:../uvc.c      ****                         break;
3202:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3203:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3204:../uvc.c      ****                         {
3205:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3206:../uvc.c      ****                         }
3207:../uvc.c      ****                         else
3208:../uvc.c      ****                         {
3209:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3210:../uvc.c      ****                         }
3211:../uvc.c      ****                         break;
3212:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3213:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3214:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3215:../uvc.c      ****                            */
3216:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3217:../uvc.c      ****                                 glCommitCtrl, &readCount);
3218:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3219:../uvc.c      ****                         {
3220:../uvc.c      ****     #if 0
3221:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3222:../uvc.c      ****                             {
3223:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3224:../uvc.c      ****                             }
3225:../uvc.c      ****                             else
3226:../uvc.c      ****                             {
3227:../uvc.c      ****                                 SensorScaling_VGA ();
3228:../uvc.c      ****                             }
3229:../uvc.c      ****     #endif
3230:../uvc.c      ****                             /* We can start streaming video now. */
3231:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3232:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3233:../uvc.c      ****                             {
3234:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3235:../uvc.c      ****                             }
3236:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
3237:../uvc.c      **** 
3238:../uvc.c      ****                         }
3239:../uvc.c      ****                         break;
3240:../uvc.c      **** 
3241:../uvc.c      ****                     default:
3242:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3243:../uvc.c      ****                         break;
3244:../uvc.c      ****                 }
3245:../uvc.c      ****                 break;
3246:../uvc.c      **** 
3247:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3248:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
3249:../uvc.c      ****             	switch (bRequest)
3250:../uvc.c      ****                 {
3251:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3252:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3253:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3254:../uvc.c      ****                         break;
3255:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3256:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3257:../uvc.c      ****                         glEp0Buffer[1] = 0;
3258:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3259:../uvc.c      ****                         break;
3260:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3261:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3262:../uvc.c      ****                         {
3263:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3264:../uvc.c      ****                         }
3265:../uvc.c      ****                         else
3266:../uvc.c      ****                         {
3267:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3268:../uvc.c      ****                         }
3269:../uvc.c      ****                         break;
3270:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3271:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3272:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3273:../uvc.c      ****                            */
3274:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3275:../uvc.c      ****                                 glCommitCtrl, &readCount);
3276:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3277:../uvc.c      ****                         {
3278:../uvc.c      ****     #if 1
3279:../uvc.c      ****                             /* We can start still streaming video now. */
3280:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3281:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3282:../uvc.c      ****                             {
3283:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3284:../uvc.c      ****                             }
3285:../uvc.c      ****     #endif
3286:../uvc.c      ****                             else{
3287:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
3288:../uvc.c      ****                             //stillcont = 0;
3289:../uvc.c      ****                             }
3290:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
3291:../uvc.c      ****                         }else{
3292:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3293:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3294:../uvc.c      ****                         }
3295:../uvc.c      ****                         break;
3296:../uvc.c      **** 
3297:../uvc.c      ****                     default:
3298:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3299:../uvc.c      ****                         break;
3300:../uvc.c      ****                 }
3301:../uvc.c      ****                 break;
3302:../uvc.c      **** 
3303:../uvc.c      ****         default:
3304:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3305:../uvc.c      ****             break;
3306:../uvc.c      ****     }
3307:../uvc.c      **** }
3308:../uvc.c      **** 
3309:../uvc.c      **** /*
3310:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3311:../uvc.c      ****  */
3312:../uvc.c      **** void
3313:../uvc.c      **** UVCAppEP0Thread_Entry (
3314:../uvc.c      ****         uint32_t input)
3315:../uvc.c      **** {
3316:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3317:../uvc.c      ****     uint32_t eventFlag;
3318:../uvc.c      **** 	CyBool_t value;
3319:../uvc.c      **** 	CyBool_t *valueptr = &value;
3320:../uvc.c      **** 
3321:../uvc.c      **** 
3322:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3323:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3324:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3325:../uvc.c      **** 
3326:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3327:../uvc.c      **** #endif
3328:../uvc.c      **** 
3329:../uvc.c      ****     /* for interrupt status test */
3330:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3331:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3332:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3333:../uvc.c      **** 
3334:../uvc.c      ****     for (;;)
3335:../uvc.c      ****     {
3336:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3337:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3338:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3339:../uvc.c      ****         {
3340:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3341:../uvc.c      ****             if (!isUsbConnected)
3342:../uvc.c      ****             {
3343:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3344:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3345:../uvc.c      ****                 {
3346:../uvc.c      ****                     isUsbConnected = CyTrue;
3347:../uvc.c      ****                 }
3348:../uvc.c      ****             }
3349:../uvc.c      **** //#ifdef DbgInfo
3350:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3351:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3352:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3353:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3354:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3355:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3356:../uvc.c      **** //#endif
3357:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3358:../uvc.c      ****             {
3359:../uvc.c      ****             	switch ((wIndex >> 8))
3360:../uvc.c      ****                 {
3361:../uvc.c      **** 
3362:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3363:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3364:../uvc.c      ****                         break;
3365:../uvc.c      **** 
3366:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3367:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3368:../uvc.c      ****                         break;
3369:../uvc.c      **** 
3370:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3371:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3372:../uvc.c      ****                         break;
3373:../uvc.c      **** 
3374:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3375:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3376:../uvc.c      ****                         break;
3377:../uvc.c      **** 
3378:../uvc.c      ****                     default:
3379:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3380:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3381:../uvc.c      ****                         break;
3382:../uvc.c      ****                 }
3383:../uvc.c      ****             }
3384:../uvc.c      **** 
3385:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3386:../uvc.c      ****             {
3387:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3388:../uvc.c      **** 
3389:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3390:../uvc.c      ****                 {
3391:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3392:../uvc.c      ****                 }
3393:../uvc.c      ****                 else
3394:../uvc.c      ****                 {
3395:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3396:../uvc.c      ****                 }
3397:../uvc.c      ****             }
3398:../uvc.c      **** 
3399:../uvc.c      ****             /* handle interrupt status event */
3400:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3401:../uvc.c      ****             {
3402:../uvc.c      **** 
3403:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3404:../uvc.c      ****             	/** preparing interrupt status data **/
3405:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3406:../uvc.c      **** 
3407:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3408:../uvc.c      **** 
3409:../uvc.c      **** #if 0 //for real button
3410:../uvc.c      **** 				if(value&&(!snapButFlag)){
3411:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3412:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3413:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3414:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3415:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3416:../uvc.c      **** 
3417:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3418:../uvc.c      **** 					interStabuf.size   = 1024;
3419:../uvc.c      **** 					interStabuf.status = 0;
3420:../uvc.c      **** 
3421:../uvc.c      **** 					interStabuf.count = 4;
3422:../uvc.c      **** 
3423:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3424:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3425:../uvc.c      **** 
3426:../uvc.c      **** 					/** send a interrupt status data **/
3427:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3428:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3429:../uvc.c      **** 					{
3430:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3431:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3432:../uvc.c      **** 					}
3433:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3434:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3435:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3436:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3437:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3438:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3439:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3440:../uvc.c      **** 
3441:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3442:../uvc.c      **** 					interStabuf.size   = 1024;
3443:../uvc.c      **** 					interStabuf.status = 0;
3444:../uvc.c      **** 
3445:../uvc.c      **** 					interStabuf.count = 4;
3446:../uvc.c      **** 
3447:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3448:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3449:../uvc.c      **** 
3450:../uvc.c      **** 					/** send a interrupt status data **/
3451:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3452:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3453:../uvc.c      **** 					{
3454:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3455:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3456:../uvc.c      **** 					}
3457:../uvc.c      **** 
3458:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3459:../uvc.c      **** 					stiflag = 0xFF;
3460:../uvc.c      **** 				}
3461:../uvc.c      **** #else			//for botton simulation
3462:../uvc.c      **** 				if(snapButFlag == 0x0f){
3463:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3464:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3465:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3466:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3467:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3468:../uvc.c      **** 
3469:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3470:../uvc.c      **** 					interStabuf.size   = 1024;
3471:../uvc.c      **** 					interStabuf.status = 0;
3472:../uvc.c      **** 
3473:../uvc.c      **** 					interStabuf.count = 4;
3474:../uvc.c      **** 
3475:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3476:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3477:../uvc.c      **** 
3478:../uvc.c      **** 					/** send a interrupt status data **/
3479:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3480:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3481:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3482:../uvc.c      **** 					{
3483:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3484:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3485:../uvc.c      **** 					}
3486:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3487:../uvc.c      **** 
3488:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3489:../uvc.c      **** 				}else if(!snapButFlag){
3490:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3491:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3492:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3493:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3494:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3495:../uvc.c      **** 
3496:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3497:../uvc.c      **** 					interStabuf.size   = 1024;
3498:../uvc.c      **** 					interStabuf.status = 0;
3499:../uvc.c      **** 
3500:../uvc.c      **** 					interStabuf.count = 4;
3501:../uvc.c      **** 
3502:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3503:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3504:../uvc.c      **** 
3505:../uvc.c      **** 					/** send a interrupt status data **/
3506:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3507:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3508:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3509:../uvc.c      **** 					{
3510:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3511:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3512:../uvc.c      **** 					}
3513:../uvc.c      **** 
3514:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3515:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3516:../uvc.c      **** 				}
3517:../uvc.c      **** #endif
3518:../uvc.c      **** 
3519:../uvc.c      ****             }
3520:../uvc.c      **** 
3521:../uvc.c      **** 
3522:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3523:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3524:../uvc.c      ****             {
3525:../uvc.c      ****                 /* Get the command buffer */
3526:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3527:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3528:../uvc.c      ****                 {
3529:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3530:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3531:../uvc.c      ****                 }
3532:../uvc.c      **** 
3533:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3534:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3535:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3536:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3537:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3538:../uvc.c      ****                  * register value high byte and register value low byte.
3539:../uvc.c      ****                  */
3540:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3541:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3542:../uvc.c      ****                 {
3543:../uvc.c      ****                     if (dmaInfo.count == 3)
3544:../uvc.c      ****                     {
3545:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3546:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3547:../uvc.c      ****                         dmaInfo.count = 3;
3548:../uvc.c      ****                     }
3549:../uvc.c      ****                     else if (dmaInfo.count == 4)
3550:../uvc.c      ****                     {
3551:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3552:../uvc.c      ****                         {
3553:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3554:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3555:../uvc.c      ****                         }
3556:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3557:../uvc.c      ****                     }
3558:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3559:../uvc.c      ****                 }
3560:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3561:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3562:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3563:../uvc.c      ****                  */
3564:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3565:../uvc.c      ****                 {
3566:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3567:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3568:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3569:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3570:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3571:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3572:../uvc.c      ****                         	break;
3573:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3574:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3575:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3576:../uvc.c      ****                         	break;*/
3577:../uvc.c      ****                     dmaInfo.count -= 2;
3578:../uvc.c      ****                 }
3579:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3580:../uvc.c      ****                 else
3581:../uvc.c      ****                 {
3582:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3583:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3584:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3585:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3586:../uvc.c      ****                 }
3587:../uvc.c      **** 
3588:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3589:../uvc.c      ****                 dmaInfo.size   = 1024;
3590:../uvc.c      ****                 dmaInfo.status = 0;
3591:../uvc.c      **** 
3592:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3593:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3594:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3595:../uvc.c      ****                 {
3596:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3597:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3598:../uvc.c      ****                 }
3599:../uvc.c      **** 
3600:../uvc.c      ****                 /* Wait until the response has gone out. */
3601:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3602:../uvc.c      **** 
3603:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3604:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3605:../uvc.c      ****                 {
3606:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3607:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3608:../uvc.c      ****                 }
3609:../uvc.c      ****             }
3610:../uvc.c      **** #endif
3611:../uvc.c      ****         }
3612:../uvc.c      ****         /* Allow other ready threads to run. */
3613:../uvc.c      ****         CyU3PThreadRelinquish ();
3614:../uvc.c      ****     }
3615:../uvc.c      **** }
3616:../uvc.c      **** 
3617:../uvc.c      **** /*
3618:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3619:../uvc.c      ****  * added 10/2013
3620:../uvc.c      ****  */
3621:../uvc.c      **** /*
3622:../uvc.c      **** static uint8_t timeDelay[64] = {
3623:../uvc.c      **** 
3624:../uvc.c      **** };
3625:../uvc.c      **** */
3626:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 3626 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
3627:../uvc.c      **** 
3628:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3629:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3630:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3631:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3632:../uvc.c      **** 	VdstateDes *lcStaDes;
3633:../uvc.c      **** 	uint32_t flag = 0;
3634:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3635:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3636:../uvc.c      **** 	uint8_t i;
3637:../uvc.c      **** 	uint16_t delaytime;
3638:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3639:../uvc.c      **** 
3640:../uvc.c      **** #if 0 //for test the command queue
3641:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3642:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3643:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3644:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3645:../uvc.c      **** 		lcCmdDes += 1;
3646:../uvc.c      **** 	}
3647:../uvc.c      **** #endif
3648:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3649:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 3649 0
  36 0004 10229FE5 		ldr	r2, .L22
3633:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 3633 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
3626:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 3626 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 3649 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 F8019FE5 		ldr	r0, .L22+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
3633:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 3633 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 3649 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
3650:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 3650 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 DC119FE5 		ldr	r1, .L22+8
  71 0044 DC519FE5 		ldr	r5, .L22+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
3651:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 3651 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
3652:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 3652 0
  79 005c BC019FE5 		ldr	r0, .L22+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
3653:../uvc.c      **** 
3654:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 3654 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
3655:../uvc.c      ****         /* Allow other ready threads to run. */
3656:../uvc.c      **** 
3657:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 3657 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
3654:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 3654 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
3658:../uvc.c      **** 	}
3659:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 3659 0
  92 0078 A8019FE5 		ldr	r0, .L22+12
  93 007c A8119FE5 		ldr	r1, .L22+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 98719FE5 		ldr	r7, .L22+20
  99 0094 98B19FE5 		ldr	fp, .L22+24
3660:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3661:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3662:../uvc.c      **** 	//CyU3PThreadSleep(100);
3663:../uvc.c      **** 	//SetCurCmd();
3664:../uvc.c      **** 	/*********** the loop of the thread ***********/
3665:../uvc.c      **** 	for(;;){
3666:../uvc.c      **** 
3667:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 3667 0
 101 0098 0060E0E3 		mvn	r6, #0
3668:../uvc.c      **** /*  // for test GPIO output
3669:../uvc.c      **** 		if(trigger)
3670:../uvc.c      **** 		{
3671:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3672:../uvc.c      **** 			{
3673:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3674:../uvc.c      **** 			}
3675:../uvc.c      **** 
3676:../uvc.c      **** 		}else{
3677:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3678:../uvc.c      **** 			{
3679:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3680:../uvc.c      **** 			}
3681:../uvc.c      **** 
3682:../uvc.c      **** 		}
3683:../uvc.c      **** */
3684:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3685:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3686:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
3687:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
3688:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
3689:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
3690:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
3691:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
3692:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3693:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
3694:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
3695:../uvc.c      **** #endif
3696:../uvc.c      **** 				}
3697:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
3698:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
3699:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
3700:../uvc.c      **** 			}
3701:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
3702:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
3703:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3704:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
3705:../uvc.c      **** 
3706:../uvc.c      **** 				/*
3707:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3708:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3709:../uvc.c      **** 				*/
3710:../uvc.c      **** 
3711:../uvc.c      **** 				/* find a available command */
3712:../uvc.c      **** 				i = 0;
3713:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 3713 0
 103 009c 0090A0E3 		mov	r9, #0
3714:../uvc.c      **** 					i++;
3715:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
3716:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
3717:../uvc.c      **** 				}
3718:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
3719:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
3720:../uvc.c      **** 					i = lcCmdDes->curNum;
3721:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
3722:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
3723:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
3724:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
3725:../uvc.c      **** #if 1
3726:../uvc.c      **** 					switch(lcCmdDes->CmdID){
3727:../uvc.c      **** 						case 20:
3728:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
3729:../uvc.c      **** 							delaytime = 500;
3730:../uvc.c      **** 							break;
3731:../uvc.c      **** 						case 21:
3732:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3733:../uvc.c      **** 							delaytime = 500;
3734:../uvc.c      **** 							break;
3735:../uvc.c      **** 						case 22:
3736:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3737:../uvc.c      **** 							delaytime = 300;
3738:../uvc.c      **** 							break;
3739:../uvc.c      **** 						case 23:
3740:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3741:../uvc.c      **** 							delaytime = 300;
3742:../uvc.c      **** 							break;
3743:../uvc.c      **** 						default:
3744:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
3745:../uvc.c      **** 							break;
3746:../uvc.c      **** 					}
3747:../uvc.c      **** #endif
3748:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
3749:../uvc.c      **** 					/** timer's ticket modify **/
3750:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
3751:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
3752:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
3753:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
3754:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
3755:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3756:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
3757:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
3758:../uvc.c      **** #endif
3759:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
3760:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
3761:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
3762:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
3763:../uvc.c      **** 						}else{
3764:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
3765:../uvc.c      **** 						}
3766:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
3767:../uvc.c      **** 					}else{
3768:../uvc.c      **** 						lcCmdDes->curNum ++;
3769:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 3769 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L18:
3667:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 3667 0
 108 00a4 0320A0E3 		mov	r2, #3
 109 00a8 14308DE2 		add	r3, sp, #20
 110 00ac 2010A0E3 		mov	r1, #32
 111 00b0 80019FE5 		ldr	r0, .L22+28
 112 00b4 00608DE5 		str	r6, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
3684:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 3684 0
 115 00bc 0610A0E1 		mov	r1, r6
 116 00c0 1C0097E5 		ldr	r0, [r7, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
3701:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 119              		.loc 1 3701 0
 120 00c8 1C0097E5 		ldr	r0, [r7, #28]
 121 00cc FEFFFFEB 		bl	_txe_mutex_put
 122              	.LVL4:
3703:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 123              		.loc 1 3703 0
 124 00d0 1C0095E5 		ldr	r0, [r5, #28]
 125 00d4 0610A0E1 		mov	r1, r6
 126 00d8 FEFFFFEB 		bl	_txe_mutex_get
3704:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 127              		.loc 1 3704 0
 128 00dc 104095E5 		ldr	r4, [r5, #16]
 129              	.LVL5:
3713:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 3713 0
 131 00e0 3C2094E5 		ldr	r2, [r4, #60]
 132 00e4 000052E3 		cmp	r2, #0
 133 00e8 0800001A 		bne	.L4
 134 00ec 0030A0E3 		mov	r3, #0
 135              	.LVL6:
 136              	.L5:
3715:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 137              		.loc 1 3715 0
 138 00f0 344094E5 		ldr	r4, [r4, #52]
 139              	.LVL7:
3714:../uvc.c      **** 					i++;
 140              		.loc 1 3714 0
 141 00f4 011083E2 		add	r1, r3, #1
3713:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 142              		.loc 1 3713 0
 143 00f8 3C2094E5 		ldr	r2, [r4, #60]
3714:../uvc.c      **** 					i++;
 144              		.loc 1 3714 0
 145 00fc FF3001E2 		and	r3, r1, #255
 146              	.LVL8:
3713:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 147              		.loc 1 3713 0
 148 0100 3F0053E3 		cmp	r3, #63
 149 0104 00005293 		cmpls	r2, #0
 150 0108 F8FFFF0A 		beq	.L5
 151 010c 104085E5 		str	r4, [r5, #16]
 152              	.LVL9:
 153              	.L4:
3719:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
 154              		.loc 1 3719 0
 155 0110 000052E3 		cmp	r2, #0
 156 0114 2D00000A 		beq	.L6
 157              	.LVL10:
3721:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 158              		.loc 1 3721 0
 159 0118 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
3726:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 160              		.loc 1 3726 0
 161 011c 0020D4E5 		ldrb	r2, [r4, #0]	@ zero_extendqisi2
3721:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 162              		.loc 1 3721 0
 163 0120 83E083E0 		add	lr, r3, r3, asl #1
 164 0124 8EA084E0 		add	sl, r4, lr, asl #1
3726:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 165              		.loc 1 3726 0
 166 0128 14C042E2 		sub	ip, r2, #20
3721:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 167              		.loc 1 3721 0
 168 012c 0400DAE5 		ldrb	r0, [sl, #4]	@ zero_extendqisi2
 169              	.LVL11:
3722:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 170              		.loc 1 3722 0
 171 0130 0510DAE5 		ldrb	r1, [sl, #5]	@ zero_extendqisi2
 172              	.LVL12:
3723:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 173              		.loc 1 3723 0
 174 0134 0620DAE5 		ldrb	r2, [sl, #6]	@ zero_extendqisi2
 175              	.LVL13:
3724:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 176              		.loc 1 3724 0
 177 0138 B8A0DAE1 		ldrh	sl, [sl, #8]
 178              	.LVL14:
3726:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 179              		.loc 1 3726 0
 180 013c 03005CE3 		cmp	ip, #3
 181 0140 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 182 0144 1A0000EA 		b	.L7
 183              	.L12:
 184 0148 C0010000 		.word	.L8
 185 014c A4010000 		.word	.L9
 186 0150 58010000 		.word	.L11
 187 0154 58010000 		.word	.L11
 188              	.L11:
3740:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 189              		.loc 1 3740 0
 190 0158 8230A0E3 		mov	r3, #130
 191 015c FEFFFFEB 		bl	SensorSetIrisControl
 192              	.LVL15:
3742:../uvc.c      **** 							break;
 193              		.loc 1 3742 0
 194 0160 4B1FA0E3 		mov	r1, #300
 195              	.LVL16:
 196              	.L13:
3751:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 197              		.loc 1 3751 0
 198 0164 0020A0E3 		mov	r2, #0
 199 0168 B0009FE5 		ldr	r0, .L22+4
 200 016c FEFFFFEB 		bl	_txe_timer_change
3752:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 201              		.loc 1 3752 0
 202 0170 A8009FE5 		ldr	r0, .L22+4
 203 0174 FEFFFFEB 		bl	_txe_timer_activate
 204              	.LVL17:
3759:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 205              		.loc 1 3759 0
 206 0178 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 207 017c 0210D4E5 		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 208 0180 000051E1 		cmp	r1, r0
3768:../uvc.c      **** 						lcCmdDes->curNum ++;
 209              		.loc 1 3768 0
 210 0184 01008012 		addne	r0, r0, #1
 211 0188 0100C415 		strneb	r0, [r4, #1]
 212              		.loc 1 3769 0
 213 018c 3C808415 		strne	r8, [r4, #60]
3759:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 214              		.loc 1 3759 0
 215 0190 1400000A 		beq	.L21
 216              	.LVL18:
 217              	.L17:
3770:../uvc.c      **** 					}
3771:../uvc.c      **** 				}else{
3772:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
3773:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
3774:../uvc.c      **** 				}
3775:../uvc.c      **** 			}
3776:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 218              		.loc 1 3776 0
 219 0194 1C0095E5 		ldr	r0, [r5, #28]
 220 0198 FEFFFFEB 		bl	_txe_mutex_put
 221              	.LVL19:
3777:../uvc.c      **** /*
3778:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3779:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3780:../uvc.c      **** */
3781:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3782:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
3783:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
3784:../uvc.c      **** #endif
3785:../uvc.c      **** 
3786:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
3787:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
3788:../uvc.c      **** #if 0
3789:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
3790:../uvc.c      **** 
3791:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
3792:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
3793:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
3794:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
3795:../uvc.c      **** 			    i = 0;
3796:../uvc.c      **** 				 switch(cmdCopyIdx)
3797:../uvc.c      **** 				 {
3798:../uvc.c      **** 					 case BrgtCtlID1:
3799:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
3800:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3801:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
3802:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3803:../uvc.c      **** 							 i++;
3804:../uvc.c      **** 						 }
3805:../uvc.c      **** 						 else{
3806:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3807:../uvc.c      **** 						 }
3808:../uvc.c      **** 
3809:../uvc.c      **** 						 CyU3PBusyWait(500);
3810:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
3811:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3812:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3813:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3814:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3815:../uvc.c      **** 						 }
3816:../uvc.c      **** 						 else{
3817:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3818:../uvc.c      **** 						 }
3819:../uvc.c      **** 						 break;
3820:../uvc.c      **** 					 case HueCtlID5:
3821:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3822:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3823:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3824:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3825:../uvc.c      **** 						 }
3826:../uvc.c      **** 						 else{
3827:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3828:../uvc.c      **** 						 }
3829:../uvc.c      **** 						 break;
3830:../uvc.c      **** 					 case SaturCtlID6:
3831:../uvc.c      **** 					 case WBTLevCtlID10:
3832:../uvc.c      **** 					 default:
3833:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
3834:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3835:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3836:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3837:../uvc.c      **** 						 }
3838:../uvc.c      **** 						 else{
3839:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3840:../uvc.c      **** 						 }
3841:../uvc.c      **** 						 break;
3842:../uvc.c      **** 				 }
3843:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
3844:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
3845:../uvc.c      **** 			}
3846:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
3847:../uvc.c      **** #endif
3848:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
3849:../uvc.c      **** 		/* Allow other ready threads to run. */
3850:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3851:../uvc.c      **** 			CyU3PThreadRelinquish ();
 222              		.loc 1 3851 0
 223 019c FEFFFFEB 		bl	_txe_thread_relinquish
3852:../uvc.c      **** 		}
 224              		.loc 1 3852 0
 225 01a0 BFFFFFEA 		b	.L18
 226              	.LVL20:
 227              	.L9:
3732:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 228              		.loc 1 3732 0
 229 01a4 5230A0E3 		mov	r3, #82
 230 01a8 FEFFFFEB 		bl	SensorSetIrisControl
 231              	.LVL21:
3734:../uvc.c      **** 							break;
 232              		.loc 1 3734 0
 233 01ac 7D1FA0E3 		mov	r1, #500
 234 01b0 EBFFFFEA 		b	.L13
 235              	.LVL22:
 236              	.L7:
3744:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 237              		.loc 1 3744 0
 238 01b4 FEFFFFEB 		bl	SensorSetControl
 239              	.LVL23:
 240 01b8 0A10A0E1 		mov	r1, sl
3745:../uvc.c      **** 							break;
 241              		.loc 1 3745 0
 242 01bc E8FFFFEA 		b	.L13
 243              	.LVL24:
 244              	.L8:
3728:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
 245              		.loc 1 3728 0
 246 01c0 8230A0E3 		mov	r3, #130
 247 01c4 FEFFFFEB 		bl	SensorSetIrisControl
 248              	.LVL25:
3730:../uvc.c      **** 							break;
 249              		.loc 1 3730 0
 250 01c8 7D1FA0E3 		mov	r1, #500
 251 01cc E4FFFFEA 		b	.L13
 252              	.LVL26:
 253              	.L6:
3772:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 254              		.loc 1 3772 0
 255 01d0 FA1FA0E3 		mov	r1, #1000
 256 01d4 44009FE5 		ldr	r0, .L22+4
 257 01d8 FEFFFFEB 		bl	_txe_timer_change
3773:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 258              		.loc 1 3773 0
 259 01dc 3C009FE5 		ldr	r0, .L22+4
 260 01e0 FEFFFFEB 		bl	_txe_timer_activate
 261 01e4 EAFFFFEA 		b	.L17
 262              	.LVL27:
 263              	.L21:
3761:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 264              		.loc 1 3761 0
 265 01e8 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
3760:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 266              		.loc 1 3760 0
 267 01ec 3C9084E5 		str	r9, [r4, #60]
3761:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 268              		.loc 1 3761 0
 269 01f0 1F005CE3 		cmp	ip, #31
3762:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 270              		.loc 1 3762 0
 271 01f4 20C04C82 		subhi	ip, ip, #32
 272 01f8 8CC08C80 		addhi	ip, ip, ip, asl #1
3764:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 273              		.loc 1 3764 0
 274 01fc 8CC08C90 		addls	ip, ip, ip, asl #1
3762:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 275              		.loc 1 3762 0
 276 0200 8CC18B80 		addhi	ip, fp, ip, asl #3
3764:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 277              		.loc 1 3764 0
 278 0204 8CC18B90 		addls	ip, fp, ip, asl #3
3762:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 279              		.loc 1 3762 0
 280 0208 1090CC85 		strhib	r9, [ip, #16]
3764:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 281              		.loc 1 3764 0
 282 020c 9091CC95 		strlsb	r9, [ip, #400]
3766:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 283              		.loc 1 3766 0
 284 0210 344094E5 		ldr	r4, [r4, #52]
 285              	.LVL28:
 286 0214 104085E5 		str	r4, [r5, #16]
 287 0218 DDFFFFEA 		b	.L17
 288              	.L23:
 289              		.align	2
 290              	.L22:
 291 021c 00000000 		.word	I2CCmdCb
 292 0220 00000000 		.word	I2CCmdTimer
 293 0224 00000000 		.word	.LC0
 294 0228 00000000 		.word	cmdQu
 295 022c 14000000 		.word	.LC1
 296 0230 00000000 		.word	statQu
 297 0234 00000000 		.word	.LANCHOR1
 298 0238 00000000 		.word	.LANCHOR0
 299              		.cfi_endproc
 300              	.LFE25:
 302              		.align	2
 303              		.global	I2CCmdCb
 305              	I2CCmdCb:
 306              	.LFB17:
2286:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 307              		.loc 1 2286 0
 308              		.cfi_startproc
 309              		@ args = 0, pretend = 0, frame = 0
 310              		@ frame_needed = 0, uses_anonymous_args = 0
 311              		@ link register save eliminated.
 312              	.LVL29:
2288:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 313              		.loc 1 2288 0
 314 023c 08009FE5 		ldr	r0, .L25
 315              	.LVL30:
 316 0240 2010A0E3 		mov	r1, #32
 317 0244 0020A0E3 		mov	r2, #0
2289:../uvc.c      **** }
 318              		.loc 1 2289 0
2288:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 319              		.loc 1 2288 0
 320 0248 FEFFFFEA 		b	_txe_event_flags_set
 321              	.L26:
 322              		.align	2
 323              	.L25:
 324 024c 00000000 		.word	.LANCHOR0
 325              		.cfi_endproc
 326              	.LFE17:
 328              		.align	2
 330              	CyFxUVCApplnUSBEventCB:
 331              	.LFB8:
1347:../uvc.c      **** {
 332              		.loc 1 1347 0
 333              		.cfi_startproc
 334              		@ args = 0, pretend = 0, frame = 8
 335              		@ frame_needed = 0, uses_anonymous_args = 0
 336              	.LVL31:
1348:../uvc.c      ****     switch (evtype)
 337              		.loc 1 1348 0
 338 0250 020050E3 		cmp	r0, #2
1347:../uvc.c      **** {
 339              		.loc 1 1347 0
 340 0254 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 341              	.LCFI2:
 342              		.cfi_def_cfa_offset 16
 343 0258 0130A0E1 		mov	r3, r1
 344 025c 10D04DE2 		sub	sp, sp, #16
 345              	.LCFI3:
 346              		.cfi_def_cfa_offset 32
1347:../uvc.c      **** {
 347              		.loc 1 1347 0
 348 0260 0040A0E1 		mov	r4, r0
 349              		.cfi_offset 14, -4
 350              		.cfi_offset 6, -8
 351              		.cfi_offset 5, -12
 352              		.cfi_offset 4, -16
1348:../uvc.c      ****     switch (evtype)
 353              		.loc 1 1348 0
 354 0264 3600000A 		beq	.L30
 355 0268 040050E3 		cmp	r0, #4
 356 026c 1F00000A 		beq	.L31
 357 0270 010050E3 		cmp	r0, #1
 358 0274 0100000A 		beq	.L33
 359              	.LVL32:
 360              	.L27:
1384:../uvc.c      **** }
 361              		.loc 1 1384 0
 362 0278 10D08DE2 		add	sp, sp, #16
 363 027c 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 364              	.LVL33:
 365              	.L33:
1369:../uvc.c      ****             gpif_initialized = 0;
 366              		.loc 1 1369 0
 367 0280 28519FE5 		ldr	r5, .L34
1367:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 368              		.loc 1 1367 0
 369 0284 0020A0E1 		mov	r2, r0
 370 0288 24119FE5 		ldr	r1, .L34+4
 371              	.LVL34:
 372 028c 0400A0E3 		mov	r0, #4
 373              	.LVL35:
 374 0290 FEFFFFEB 		bl	CyU3PDebugPrint
1368:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 375              		.loc 1 1368 0
 376 0294 0400A0E1 		mov	r0, r4
 377 0298 FEFFFFEB 		bl	CyU3PGpifDisable
1369:../uvc.c      ****             gpif_initialized = 0;
 378              		.loc 1 1369 0
 379 029c 00C0A0E3 		mov	ip, #0
 380              	.LBB16:
 381              	.LBB17:
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 382              		.loc 1 1331 0
 383 02a0 0410A0E1 		mov	r1, r4
 384 02a4 0500A0E1 		mov	r0, r5
 385 02a8 0220A0E3 		mov	r2, #2
 386 02ac 0C308DE2 		add	r3, sp, #12
 387              	.LBE17:
 388              	.LBE16:
1369:../uvc.c      ****             gpif_initialized = 0;
 389              		.loc 1 1369 0
 390 02b0 28C085E5 		str	ip, [r5, #40]
1370:../uvc.c      ****             isUsbConnected = CyFalse;
 391              		.loc 1 1370 0
 392 02b4 30C085E5 		str	ip, [r5, #48]
1371:../uvc.c      ****             streamingStarted = CyFalse;
 393              		.loc 1 1371 0
 394 02b8 2CC085E5 		str	ip, [r5, #44]
 395              	.LBB19:
 396              	.LBB18:
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 397              		.loc 1 1331 0
 398 02bc 00C08DE5 		str	ip, [sp, #0]
 399 02c0 FEFFFFEB 		bl	_txe_event_flags_get
 400 02c4 004050E2 		subs	r4, r0, #0
 401 02c8 EAFFFF1A 		bne	.L27
1334:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 402              		.loc 1 1334 0
 403 02cc 0110E0E3 		mvn	r1, #1
 404 02d0 0220A0E3 		mov	r2, #2
 405 02d4 0500A0E1 		mov	r0, r5
 406              	.L32:
 407 02d8 FEFFFFEB 		bl	_txe_event_flags_set
1337:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 408              		.loc 1 1337 0
 409 02dc 0500A0E1 		mov	r0, r5
 410 02e0 0210A0E3 		mov	r1, #2
 411 02e4 0420A0E1 		mov	r2, r4
 412 02e8 FEFFFFEB 		bl	_txe_event_flags_set
 413 02ec E1FFFFEA 		b	.L27
 414              	.LVL36:
 415              	.L31:
 416              	.LBE18:
 417              	.LBE19:
1353:../uvc.c      ****             gpif_initialized = 0;
 418              		.loc 1 1353 0
 419 02f0 B8509FE5 		ldr	r5, .L34
1351:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 420              		.loc 1 1351 0
 421 02f4 BC109FE5 		ldr	r1, .L34+8
 422              	.LVL37:
 423 02f8 0020A0E1 		mov	r2, r0
 424 02fc FEFFFFEB 		bl	CyU3PDebugPrint
 425              	.LVL38:
1352:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 426              		.loc 1 1352 0
 427 0300 0100A0E3 		mov	r0, #1
 428 0304 FEFFFFEB 		bl	CyU3PGpifDisable
1353:../uvc.c      ****             gpif_initialized = 0;
 429              		.loc 1 1353 0
 430 0308 00C0A0E3 		mov	ip, #0
 431              	.LBB20:
 432              	.LBB21:
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 433              		.loc 1 1331 0
 434 030c 0110A0E3 		mov	r1, #1
 435 0310 0220A0E3 		mov	r2, #2
 436 0314 0500A0E1 		mov	r0, r5
 437 0318 0C308DE2 		add	r3, sp, #12
 438              	.LBE21:
 439              	.LBE20:
1353:../uvc.c      ****             gpif_initialized = 0;
 440              		.loc 1 1353 0
 441 031c 28C085E5 		str	ip, [r5, #40]
1354:../uvc.c      ****             streamingStarted = CyFalse;
 442              		.loc 1 1354 0
 443 0320 2CC085E5 		str	ip, [r5, #44]
 444              	.LBB23:
 445              	.LBB22:
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 446              		.loc 1 1331 0
 447 0324 00C08DE5 		str	ip, [sp, #0]
 448 0328 FEFFFFEB 		bl	_txe_event_flags_get
 449 032c 004050E2 		subs	r4, r0, #0
1334:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 450              		.loc 1 1334 0
 451 0330 0500A001 		moveq	r0, r5
 452 0334 0110E003 		mvneq	r1, #1
 453 0338 0220A003 		moveq	r2, #2
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 454              		.loc 1 1331 0
 455 033c CDFFFF1A 		bne	.L27
 456 0340 E4FFFFEA 		b	.L32
 457              	.LVL39:
 458              	.L30:
 459              	.LBE22:
 460              	.LBE23:
1361:../uvc.c      ****             gpif_initialized = 0;
 461              		.loc 1 1361 0
 462 0344 64509FE5 		ldr	r5, .L34
1359:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 463              		.loc 1 1359 0
 464 0348 0020A0E1 		mov	r2, r0
 465 034c 68109FE5 		ldr	r1, .L34+12
 466              	.LVL40:
 467 0350 0400A0E3 		mov	r0, #4
 468              	.LVL41:
 469 0354 FEFFFFEB 		bl	CyU3PDebugPrint
1360:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 470              		.loc 1 1360 0
 471 0358 0100A0E3 		mov	r0, #1
 472 035c FEFFFFEB 		bl	CyU3PGpifDisable
1361:../uvc.c      ****             gpif_initialized = 0;
 473              		.loc 1 1361 0
 474 0360 0060A0E3 		mov	r6, #0
 475              	.LBB24:
 476              	.LBB25:
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 477              		.loc 1 1331 0
 478 0364 0500A0E1 		mov	r0, r5
 479 0368 0110A0E3 		mov	r1, #1
 480 036c 0420A0E1 		mov	r2, r4
 481 0370 0C308DE2 		add	r3, sp, #12
 482              	.LBE25:
 483              	.LBE24:
1361:../uvc.c      ****             gpif_initialized = 0;
 484              		.loc 1 1361 0
 485 0374 286085E5 		str	r6, [r5, #40]
1362:../uvc.c      ****             streamingStarted = CyFalse;
 486              		.loc 1 1362 0
 487 0378 2C6085E5 		str	r6, [r5, #44]
 488              	.LBB27:
 489              	.LBB26:
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 490              		.loc 1 1331 0
 491 037c 00608DE5 		str	r6, [sp, #0]
 492 0380 FEFFFFEB 		bl	_txe_event_flags_get
 493 0384 006050E2 		subs	r6, r0, #0
 494 0388 BAFFFF1A 		bne	.L27
1334:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 495              		.loc 1 1334 0
 496 038c 0420A0E1 		mov	r2, r4
 497 0390 0500A0E1 		mov	r0, r5
 498 0394 0110E0E3 		mvn	r1, #1
 499 0398 FEFFFFEB 		bl	_txe_event_flags_set
1337:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 500              		.loc 1 1337 0
 501 039c 0500A0E1 		mov	r0, r5
 502 03a0 0410A0E1 		mov	r1, r4
 503 03a4 0620A0E1 		mov	r2, r6
 504 03a8 FEFFFFEB 		bl	_txe_event_flags_set
 505 03ac B1FFFFEA 		b	.L27
 506              	.L35:
 507              		.align	2
 508              	.L34:
 509 03b0 00000000 		.word	.LANCHOR0
 510 03b4 7C000000 		.word	.LC4
 511 03b8 38000000 		.word	.LC2
 512 03bc 58000000 		.word	.LC3
 513              	.LBE26:
 514              	.LBE27:
 515              		.cfi_endproc
 516              	.LFE8:
 518              		.align	2
 519              		.global	CyFxUvcApplnDmaCallback
 521              	CyFxUvcApplnDmaCallback:
 522              	.LFB10:
1544:../uvc.c      **** {
 523              		.loc 1 1544 0
 524              		.cfi_startproc
 525              		@ args = 0, pretend = 0, frame = 0
 526              		@ frame_needed = 0, uses_anonymous_args = 0
 527              	.LVL42:
1551:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 528              		.loc 1 1551 0
 529 03c0 080051E3 		cmp	r1, #8
1544:../uvc.c      **** {
 530              		.loc 1 1544 0
 531 03c4 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 532              	.LCFI4:
 533              		.cfi_def_cfa_offset 20
 534 03c8 0250A0E1 		mov	r5, r2
 535              		.cfi_offset 14, -4
 536              		.cfi_offset 7, -8
 537              		.cfi_offset 6, -12
 538              		.cfi_offset 5, -16
 539              		.cfi_offset 4, -20
 540 03cc 0CD04DE2 		sub	sp, sp, #12
 541              	.LCFI5:
 542              		.cfi_def_cfa_offset 32
1551:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 543              		.loc 1 1551 0
 544 03d0 0B00000A 		beq	.L42
1603:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 545              		.loc 1 1603 0
 546 03d4 100051E3 		cmp	r1, #16
 547 03d8 0700001A 		bne	.L36
1605:../uvc.c      ****         consCount++;
 548              		.loc 1 1605 0
 549 03dc 7C319FE5 		ldr	r3, .L45
1606:../uvc.c      ****         streamingStarted = CyTrue;
 550              		.loc 1 1606 0
 551 03e0 0120A0E3 		mov	r2, #1
 552              	.LVL43:
1605:../uvc.c      ****         consCount++;
 553              		.loc 1 1605 0
 554 03e4 B204D3E1 		ldrh	r0, [r3, #66]
 555              	.LVL44:
1606:../uvc.c      ****         streamingStarted = CyTrue;
 556              		.loc 1 1606 0
 557 03e8 2C2083E5 		str	r2, [r3, #44]
1605:../uvc.c      ****         consCount++;
 558              		.loc 1 1605 0
 559 03ec 02C080E0 		add	ip, r0, r2
 560 03f0 0C18A0E1 		mov	r1, ip, asl #16
 561              	.LVL45:
 562 03f4 2128A0E1 		mov	r2, r1, lsr #16
 563 03f8 B224C3E1 		strh	r2, [r3, #66]	@ movhi
 564              	.L36:
1608:../uvc.c      **** }
 565              		.loc 1 1608 0
 566 03fc 0CD08DE2 		add	sp, sp, #12
 567 0400 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 568              	.LVL46:
 569              	.L42:
1553:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 570              		.loc 1 1553 0
 571 0404 B420D2E1 		ldrh	r2, [r2, #4]
 572 0408 54319FE5 		ldr	r3, .L45+4
 573 040c 030052E1 		cmp	r2, r3
 574 0410 3500000A 		beq	.L43
1573:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 575              		.loc 1 1573 0
 576 0414 006095E5 		ldr	r6, [r5, #0]
 577              	.LBB32:
 578              	.LBB34:
1292:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 579              		.loc 1 1292 0
 580 0418 48719FE5 		ldr	r7, .L45+8
1291:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 581              		.loc 1 1291 0
 582 041c 0010E0E3 		mvn	r1, #0
 583              	.LVL47:
 584              	.LBE34:
 585              	.LBE32:
1573:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 586              		.loc 1 1573 0
 587 0420 0C4046E2 		sub	r4, r6, #12
 588              	.LVL48:
 589              	.LBB36:
 590              	.LBB33:
1291:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 591              		.loc 1 1291 0
 592 0424 40019FE5 		ldr	r0, .L45+12
 593              	.LVL49:
 594 0428 FEFFFFEB 		bl	_txe_mutex_get
1292:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 595              		.loc 1 1292 0
 596 042c 0400A0E1 		mov	r0, r4
 597 0430 121D87E2 		add	r1, r7, #1152
 598 0434 0C20A0E3 		mov	r2, #12
 599 0438 FEFFFFEB 		bl	CyU3PMemCopy
1293:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 600              		.loc 1 1293 0
 601 043c 28019FE5 		ldr	r0, .L45+12
 602 0440 FEFFFFEB 		bl	_txe_mutex_put
1298:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 603              		.loc 1 1298 0
 604 0444 0BC056E5 		ldrb	ip, [r6, #-11]	@ zero_extendqisi2
 605              	.LBE33:
 606              	.LBE36:
1574:../uvc.c      ****                 pb++;
 607              		.loc 1 1574 0
 608 0448 10419FE5 		ldr	r4, .L45
 609              	.LVL50:
 610              	.LBB37:
 611              	.LBB35:
1298:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 612              		.loc 1 1298 0
 613 044c 02108CE3 		orr	r1, ip, #2
 614 0450 0B1046E5 		strb	r1, [r6, #-11]
 615              	.LBE35:
 616              	.LBE37:
1574:../uvc.c      ****                 pb++;
 617              		.loc 1 1574 0
 618 0454 B603D4E1 		ldrh	r0, [r4, #54]
1580:../uvc.c      ****                 if(stiflag == 0x0F){
 619              		.loc 1 1580 0
 620 0458 3A20D4E5 		ldrb	r2, [r4, #58]	@ zero_extendqisi2
1575:../uvc.c      ****                 pbc = input->buffer_p.count;
 621              		.loc 1 1575 0
 622 045c B410D5E1 		ldrh	r1, [r5, #4]
1574:../uvc.c      ****                 pb++;
 623              		.loc 1 1574 0
 624 0460 013080E2 		add	r3, r0, #1
1580:../uvc.c      ****                 if(stiflag == 0x0F){
 625              		.loc 1 1580 0
 626 0464 0F0052E3 		cmp	r2, #15
1574:../uvc.c      ****                 pb++;
 627              		.loc 1 1574 0
 628 0468 B633C4E1 		strh	r3, [r4, #54]	@ movhi
1575:../uvc.c      ****                 pbc = input->buffer_p.count;
 629              		.loc 1 1575 0
 630 046c B813C4E1 		strh	r1, [r4, #56]	@ movhi
1580:../uvc.c      ****                 if(stiflag == 0x0F){
 631              		.loc 1 1580 0
 632 0470 2E00000A 		beq	.L44
 633              	.L40:
1587:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
 634              		.loc 1 1587 0
 635 0474 01E0A0E3 		mov	lr, #1
 636 0478 3CE084E5 		str	lr, [r4, #60]
 637              	.LVL51:
 638              	.L39:
1591:../uvc.c      ****             prodCount++;
 639              		.loc 1 1591 0
 640 047c B0E4D4E1 		ldrh	lr, [r4, #64]
1592:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 641              		.loc 1 1592 0
 642 0480 0C1081E2 		add	r1, r1, #12
1591:../uvc.c      ****             prodCount++;
 643              		.loc 1 1591 0
 644 0484 01308EE2 		add	r3, lr, #1
 645 0488 0308A0E1 		mov	r0, r3, asl #16
 646 048c 20C8A0E1 		mov	ip, r0, lsr #16
1592:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 647              		.loc 1 1592 0
 648 0490 0128A0E1 		mov	r2, r1, asl #16
 649 0494 2218A0E1 		mov	r1, r2, lsr #16
 650 0498 D0009FE5 		ldr	r0, .L45+16
 651 049c 0020A0E3 		mov	r2, #0
1591:../uvc.c      ****             prodCount++;
 652              		.loc 1 1591 0
 653 04a0 B0C4C4E1 		strh	ip, [r4, #64]	@ movhi
1592:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 654              		.loc 1 1592 0
 655 04a4 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 656              	.LVL52:
1591:../uvc.c      ****             prodCount++;
 657              		.loc 1 1591 0
 658 04a8 B0109FE5 		ldr	r1, .L45
1595:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
 659              		.loc 1 1595 0
 660 04ac 002050E2 		subs	r2, r0, #0
 661 04b0 D1FFFF0A 		beq	.L36
1597:../uvc.c      ****                 prodCount--;
 662              		.loc 1 1597 0
 663 04b4 B004D1E1 		ldrh	r0, [r1, #64]
 664              	.LVL53:
1598:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 665              		.loc 1 1598 0
 666 04b8 B430D5E1 		ldrh	r3, [r5, #4]
1597:../uvc.c      ****                 prodCount--;
 667              		.loc 1 1597 0
 668 04bc 01E040E2 		sub	lr, r0, #1
 669 04c0 0EC8A0E1 		mov	ip, lr, asl #16
 670 04c4 2C08A0E1 		mov	r0, ip, lsr #16
 671 04c8 B004C1E1 		strh	r0, [r1, #64]	@ movhi
1598:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 672              		.loc 1 1598 0
 673 04cc B0E4D1E1 		ldrh	lr, [r1, #64]
 674 04d0 B2C4D1E1 		ldrh	ip, [r1, #66]
 675 04d4 0400A0E3 		mov	r0, #4
 676 04d8 94109FE5 		ldr	r1, .L45+20
 677 04dc 00E08DE5 		str	lr, [sp, #0]
 678 04e0 04C08DE5 		str	ip, [sp, #4]
 679 04e4 FEFFFFEB 		bl	CyU3PDebugPrint
 680              	.LVL54:
 681 04e8 C3FFFFEA 		b	.L36
 682              	.LVL55:
 683              	.L43:
1567:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 684              		.loc 1 1567 0
 685 04ec 006095E5 		ldr	r6, [r5, #0]
 686              	.LBB38:
 687              	.LBB39:
1291:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 688              		.loc 1 1291 0
 689 04f0 0010E0E3 		mvn	r1, #0
 690              	.LVL56:
 691              	.LBE39:
 692              	.LBE38:
1568:../uvc.c      ****                 fb++;
 693              		.loc 1 1568 0
 694 04f4 64409FE5 		ldr	r4, .L45
1567:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 695              		.loc 1 1567 0
 696 04f8 0C6046E2 		sub	r6, r6, #12
 697              	.LVL57:
 698              	.LBB41:
 699              	.LBB40:
1291:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 700              		.loc 1 1291 0
 701 04fc 68009FE5 		ldr	r0, .L45+12
 702              	.LVL58:
 703 0500 FEFFFFEB 		bl	_txe_mutex_get
1292:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 704              		.loc 1 1292 0
 705 0504 6C109FE5 		ldr	r1, .L45+24
 706 0508 0600A0E1 		mov	r0, r6
 707 050c 0C20A0E3 		mov	r2, #12
 708 0510 FEFFFFEB 		bl	CyU3PMemCopy
1293:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 709              		.loc 1 1293 0
 710 0514 50009FE5 		ldr	r0, .L45+12
 711 0518 FEFFFFEB 		bl	_txe_mutex_put
 712              	.LBE40:
 713              	.LBE41:
1568:../uvc.c      ****                 fb++;
 714              		.loc 1 1568 0
 715 051c B4C3D4E1 		ldrh	ip, [r4, #52]
 716 0520 B410D5E1 		ldrh	r1, [r5, #4]
 717 0524 01008CE2 		add	r0, ip, #1
 718 0528 B403C4E1 		strh	r0, [r4, #52]	@ movhi
 719 052c D2FFFFEA 		b	.L39
 720              	.LVL59:
 721              	.L44:
1581:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 722              		.loc 1 1581 0
 723 0530 0010E0E3 		mvn	r1, #0
 724 0534 30009FE5 		ldr	r0, .L45+12
 725 0538 FEFFFFEB 		bl	_txe_mutex_get
1582:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 726              		.loc 1 1582 0
 727 053c 8114D7E5 		ldrb	r1, [r7, #1153]	@ zero_extendqisi2
1583:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 728              		.loc 1 1583 0
 729 0540 24009FE5 		ldr	r0, .L45+12
1582:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 730              		.loc 1 1582 0
 731 0544 DF2001E2 		and	r2, r1, #223
 732 0548 8124C7E5 		strb	r2, [r7, #1153]
1583:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 733              		.loc 1 1583 0
 734 054c FEFFFFEB 		bl	_txe_mutex_put
1584:../uvc.c      ****                 	stiflag = 0xAA;
 735              		.loc 1 1584 0
 736 0550 5530E0E3 		mvn	r3, #85
 737 0554 3A30C4E5 		strb	r3, [r4, #58]
 738 0558 B410D5E1 		ldrh	r1, [r5, #4]
 739 055c C4FFFFEA 		b	.L40
 740              	.L46:
 741              		.align	2
 742              	.L45:
 743 0560 00000000 		.word	.LANCHOR0
 744 0564 F03F0000 		.word	16368
 745 0568 00000000 		.word	.LANCHOR1
 746 056c 00000000 		.word	imgHdMux
 747 0570 00000000 		.word	glChHandleUVCStream
 748 0574 9C000000 		.word	.LC5
 749 0578 80040000 		.word	.LANCHOR1+1152
 750              		.cfi_endproc
 751              	.LFE10:
 753              		.align	2
 755              	CyFxUVCApplnUSBSetupCB:
 756              	.LFB9:
1392:../uvc.c      **** {
 757              		.loc 1 1392 0
 758              		.cfi_startproc
 759              		@ args = 0, pretend = 0, frame = 8
 760              		@ frame_needed = 0, uses_anonymous_args = 0
 761              	.LVL60:
1397:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 762              		.loc 1 1397 0
 763 057c C0329FE5 		ldr	r3, .L72
1392:../uvc.c      **** {
 764              		.loc 1 1392 0
 765 0580 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 766              	.LCFI6:
 767              		.cfi_def_cfa_offset 24
1398:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 768              		.loc 1 1398 0
 769 0584 BCC29FE5 		ldr	ip, .L72+4
1397:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 770              		.loc 1 1397 0
 771 0588 FF4000E2 		and	r4, r0, #255
 772              		.cfi_offset 14, -4
 773              		.cfi_offset 8, -8
 774              		.cfi_offset 7, -12
 775              		.cfi_offset 6, -16
 776              		.cfi_offset 5, -20
 777              		.cfi_offset 4, -24
1398:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 778              		.loc 1 1398 0
 779 058c FF8C00E2 		and	r8, r0, #65280
1399:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 780              		.loc 1 1399 0
 781 0590 2078A0E1 		mov	r7, r0, lsr #16
1397:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 782              		.loc 1 1397 0
 783 0594 0040C3E5 		strb	r4, [r3, #0]
1399:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 784              		.loc 1 1399 0
 785 0598 AC229FE5 		ldr	r2, .L72+8
1400:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 786              		.loc 1 1400 0
 787 059c AC029FE5 		ldr	r0, .L72+12
 788              	.LVL61:
1401:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 789              		.loc 1 1401 0
 790 05a0 AC329FE5 		ldr	r3, .L72+16
1400:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 791              		.loc 1 1400 0
 792 05a4 0158A0E1 		mov	r5, r1, asl #16
1398:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 793              		.loc 1 1398 0
 794 05a8 2884A0E1 		mov	r8, r8, lsr #8
1400:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 795              		.loc 1 1400 0
 796 05ac 2558A0E1 		mov	r5, r5, lsr #16
1401:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 797              		.loc 1 1401 0
 798 05b0 2118A0E1 		mov	r1, r1, lsr #16
 799              	.LVL62:
1404:../uvc.c      ****     switch (bmReqType)
 800              		.loc 1 1404 0
 801 05b4 020054E3 		cmp	r4, #2
1392:../uvc.c      **** {
 802              		.loc 1 1392 0
 803 05b8 10D04DE2 		sub	sp, sp, #16
 804              	.LCFI7:
 805              		.cfi_def_cfa_offset 40
1398:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 806              		.loc 1 1398 0
 807 05bc 0080CCE5 		strb	r8, [ip, #0]
1399:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 808              		.loc 1 1399 0
 809 05c0 B070C2E1 		strh	r7, [r2, #0]	@ movhi
1400:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 810              		.loc 1 1400 0
 811 05c4 B050C0E1 		strh	r5, [r0, #0]	@ movhi
1401:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 812              		.loc 1 1401 0
 813 05c8 B010C3E1 		strh	r1, [r3, #0]	@ movhi
1404:../uvc.c      ****     switch (bmReqType)
 814              		.loc 1 1404 0
 815 05cc 4F00000A 		beq	.L50
 816 05d0 0600009A 		bls	.L68
 817 05d4 210054E3 		cmp	r4, #33
 818 05d8 3A00000A 		beq	.L51
 819 05dc A10054E3 		cmp	r4, #161
 820 05e0 3800000A 		beq	.L51
 821              	.L65:
1393:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 822              		.loc 1 1393 0
 823 05e4 0000A0E3 		mov	r0, #0
 824              	.LVL63:
 825              	.L48:
1531:../uvc.c      **** }
 826              		.loc 1 1531 0
 827 05e8 10D08DE2 		add	sp, sp, #16
 828 05ec F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 829              	.LVL64:
 830              	.L68:
1404:../uvc.c      ****     switch (bmReqType)
 831              		.loc 1 1404 0
 832 05f0 010054E3 		cmp	r4, #1
 833 05f4 FAFFFF1A 		bne	.L65
1444:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 834              		.loc 1 1444 0
 835 05f8 0B0058E3 		cmp	r8, #11
 836 05fc F8FFFF1A 		bne	.L65
1448:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 837              		.loc 1 1448 0
 838 0600 010055E3 		cmp	r5, #1
 839 0604 F6FFFF1A 		bne	.L65
1448:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 840              		.loc 1 1448 0 is_stmt 0 discriminator 1
 841 0608 000057E3 		cmp	r7, #0
 842 060c F4FFFF1A 		bne	.L65
1453:../uvc.c      ****                     gpif_initialized = 0;
 843              		.loc 1 1453 0 is_stmt 1
 844 0610 40429FE5 		ldr	r4, .L72+20
1451:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 845              		.loc 1 1451 0
 846 0614 40129FE5 		ldr	r1, .L72+24
 847 0618 0400A0E3 		mov	r0, #4
 848 061c FEFFFFEB 		bl	CyU3PDebugPrint
1452:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 849              		.loc 1 1452 0
 850 0620 0500A0E1 		mov	r0, r5
 851 0624 FEFFFFEB 		bl	CyU3PGpifDisable
1456:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 852              		.loc 1 1456 0
 853 0628 0510A0E1 		mov	r1, r5
 854 062c 8300A0E3 		mov	r0, #131
1453:../uvc.c      ****                     gpif_initialized = 0;
 855              		.loc 1 1453 0
 856 0630 287084E5 		str	r7, [r4, #40]
1454:../uvc.c      ****                     streamingStarted = CyFalse;
 857              		.loc 1 1454 0
 858 0634 2C7084E5 		str	r7, [r4, #44]
1456:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 859              		.loc 1 1456 0
 860 0638 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1457:../uvc.c      ****                     CyU3PBusyWait (100);
 861              		.loc 1 1457 0
 862 063c 6400A0E3 		mov	r0, #100
 863 0640 FEFFFFEB 		bl	CyU3PBusyWait
1460:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 864              		.loc 1 1460 0
 865 0644 14029FE5 		ldr	r0, .L72+28
 866 0648 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1461:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 867              		.loc 1 1461 0
 868 064c 8300A0E3 		mov	r0, #131
 869 0650 FEFFFFEB 		bl	CyU3PUsbFlushEp
1462:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 870              		.loc 1 1462 0
 871 0654 0710A0E1 		mov	r1, r7
 872 0658 8300A0E3 		mov	r0, #131
 873 065c FEFFFFEB 		bl	CyU3PUsbSetEpNak
1463:../uvc.c      ****                     CyU3PBusyWait (100);
 874              		.loc 1 1463 0
 875 0660 6400A0E3 		mov	r0, #100
 876 0664 FEFFFFEB 		bl	CyU3PBusyWait
1466:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 877              		.loc 1 1466 0
 878 0668 0710A0E1 		mov	r1, r7
 879 066c 0520A0E1 		mov	r2, r5
 880 0670 8300A0E3 		mov	r0, #131
 881 0674 FEFFFFEB 		bl	CyU3PUsbStall
 882              	.LVL65:
1469:../uvc.c      ****                     CyU3PUsbAckSetup ();
 883              		.loc 1 1469 0
 884 0678 FEFFFFEB 		bl	CyU3PUsbAckSetup
1471:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 885              		.loc 1 1471 0
 886 067c 445084E5 		str	r5, [r4, #68]
 887              	.LBB46:
 888              	.LBB47:
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 889              		.loc 1 1331 0
 890 0680 0400A0E1 		mov	r0, r4
 891 0684 0510A0E1 		mov	r1, r5
 892 0688 0220A0E3 		mov	r2, #2
 893 068c 0C308DE2 		add	r3, sp, #12
 894 0690 00708DE5 		str	r7, [sp, #0]
 895 0694 FEFFFFEB 		bl	_txe_event_flags_get
 896 0698 006050E2 		subs	r6, r0, #0
 897 069c 2E00001A 		bne	.L63
1334:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 898              		.loc 1 1334 0
 899 06a0 0110E0E3 		mvn	r1, #1
 900 06a4 0220A0E3 		mov	r2, #2
 901 06a8 0400A0E1 		mov	r0, r4
 902 06ac FEFFFFEB 		bl	_txe_event_flags_set
1337:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 903              		.loc 1 1337 0
 904 06b0 0400A0E1 		mov	r0, r4
 905 06b4 0210A0E3 		mov	r1, #2
 906 06b8 0620A0E1 		mov	r2, r6
 907 06bc FEFFFFEB 		bl	_txe_event_flags_set
1467:../uvc.c      ****                     uvcHandleReq = CyTrue;
 908              		.loc 1 1467 0
 909 06c0 0500A0E1 		mov	r0, r5
 910 06c4 C7FFFFEA 		b	.L48
 911              	.LVL66:
 912              	.L51:
 913              	.LBE47:
 914              	.LBE46:
1409:../uvc.c      ****             switch (wIndex & 0xFF)
 915              		.loc 1 1409 0
 916 06c8 FF5015E2 		ands	r5, r5, #255
 917 06cc 1A00001A 		bne	.L69
 918              	.LVL67:
1414:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 919              		.loc 1 1414 0
 920 06d0 0520A0E1 		mov	r2, r5
 921 06d4 7C019FE5 		ldr	r0, .L72+20
 922 06d8 0410A0E3 		mov	r1, #4
 923 06dc FEFFFFEB 		bl	_txe_event_flags_set
 924              	.LVL68:
1416:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 925              		.loc 1 1416 0
 926 06e0 002050E2 		subs	r2, r0, #0
1413:../uvc.c      ****                         uvcHandleReq = CyTrue;
 927              		.loc 1 1413 0
 928 06e4 0100A003 		moveq	r0, #1
 929              	.LVL69:
1416:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 930              		.loc 1 1416 0
 931 06e8 BEFFFF0A 		beq	.L48
1418:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 932              		.loc 1 1418 0
 933 06ec 70119FE5 		ldr	r1, .L72+32
 934 06f0 0400A0E3 		mov	r0, #4
 935 06f4 FEFFFFEB 		bl	CyU3PDebugPrint
 936              	.LVL70:
1419:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 937              		.loc 1 1419 0
 938 06f8 0500A0E1 		mov	r0, r5
 939 06fc 0110A0E3 		mov	r1, #1
 940 0700 0520A0E1 		mov	r2, r5
 941 0704 FEFFFFEB 		bl	CyU3PUsbStall
1413:../uvc.c      ****                         uvcHandleReq = CyTrue;
 942              		.loc 1 1413 0
 943 0708 0100A0E3 		mov	r0, #1
 944 070c B5FFFFEA 		b	.L48
 945              	.LVL71:
 946              	.L50:
1479:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 947              		.loc 1 1479 0
 948 0710 010058E3 		cmp	r8, #1
 949 0714 B2FFFF1A 		bne	.L65
1481:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 950              		.loc 1 1481 0
 951 0718 830055E3 		cmp	r5, #131
 952 071c B0FFFF1A 		bne	.L65
1487:../uvc.c      ****                     if (streamingStarted == CyTrue)
 953              		.loc 1 1487 0
 954 0720 30719FE5 		ldr	r7, .L72+20
 955 0724 2C6097E5 		ldr	r6, [r7, #44]
 956 0728 010056E3 		cmp	r6, #1
 957 072c 1500000A 		beq	.L70
 958              	.LVL72:
1519:../uvc.c      ****                         CyU3PUsbAckSetup ();
 959              		.loc 1 1519 0
 960 0730 FEFFFFEB 		bl	CyU3PUsbAckSetup
1518:../uvc.c      ****                         uvcHandleReq = CyTrue;
 961              		.loc 1 1518 0
 962 0734 0800A0E1 		mov	r0, r8
 963 0738 AAFFFFEA 		b	.L48
 964              	.LVL73:
 965              	.L69:
1409:../uvc.c      ****             switch (wIndex & 0xFF)
 966              		.loc 1 1409 0
 967 073c 010055E3 		cmp	r5, #1
 968 0740 A7FFFF1A 		bne	.L65
 969              	.LVL74:
1427:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 970              		.loc 1 1427 0
 971 0744 0020A0E3 		mov	r2, #0
 972 0748 08019FE5 		ldr	r0, .L72+20
 973 074c 0810A0E3 		mov	r1, #8
 974 0750 FEFFFFEB 		bl	_txe_event_flags_set
 975              	.LVL75:
1429:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 976              		.loc 1 1429 0
 977 0754 002050E2 		subs	r2, r0, #0
 978 0758 0100001A 		bne	.L71
 979              	.LVL76:
 980              	.L63:
 981              	.LBB49:
 982              	.LBB48:
1467:../uvc.c      ****                     uvcHandleReq = CyTrue;
 983              		.loc 1 1467 0
 984 075c 0500A0E1 		mov	r0, r5
 985 0760 A0FFFFEA 		b	.L48
 986              	.LVL77:
 987              	.L71:
 988              	.LBE48:
 989              	.LBE49:
1432:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 990              		.loc 1 1432 0
 991 0764 FC109FE5 		ldr	r1, .L72+36
 992 0768 0400A0E3 		mov	r0, #4
 993              	.LVL78:
 994 076c FEFFFFEB 		bl	CyU3PDebugPrint
 995              	.LVL79:
1433:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 996              		.loc 1 1433 0
 997 0770 0000A0E3 		mov	r0, #0
 998 0774 0510A0E1 		mov	r1, r5
 999 0778 0020A0E1 		mov	r2, r0
 1000 077c FEFFFFEB 		bl	CyU3PUsbStall
1426:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1001              		.loc 1 1426 0
 1002 0780 0500A0E1 		mov	r0, r5
 1003 0784 97FFFFEA 		b	.L48
 1004              	.LVL80:
 1005              	.L70:
1489:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 1006              		.loc 1 1489 0
 1007 0788 DC109FE5 		ldr	r1, .L72+40
 1008 078c 0400A0E3 		mov	r0, #4
 1009 0790 FEFFFFEB 		bl	CyU3PDebugPrint
1493:../uvc.c      ****                         gpif_initialized = 0;
 1010              		.loc 1 1493 0
 1011 0794 0080A0E3 		mov	r8, #0
1492:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 1012              		.loc 1 1492 0
 1013 0798 0600A0E1 		mov	r0, r6
 1014 079c FEFFFFEB 		bl	CyU3PGpifDisable
1497:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1015              		.loc 1 1497 0
 1016 07a0 0610A0E1 		mov	r1, r6
 1017 07a4 0500A0E1 		mov	r0, r5
1493:../uvc.c      ****                         gpif_initialized = 0;
 1018              		.loc 1 1493 0
 1019 07a8 288087E5 		str	r8, [r7, #40]
1494:../uvc.c      ****                         streamingStarted = CyFalse;
 1020              		.loc 1 1494 0
 1021 07ac 2C8087E5 		str	r8, [r7, #44]
1497:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1022              		.loc 1 1497 0
 1023 07b0 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1498:../uvc.c      ****                         CyU3PBusyWait (100);
 1024              		.loc 1 1498 0
 1025 07b4 6400A0E3 		mov	r0, #100
 1026 07b8 FEFFFFEB 		bl	CyU3PBusyWait
1501:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 1027              		.loc 1 1501 0
 1028 07bc 9C009FE5 		ldr	r0, .L72+28
 1029 07c0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1502:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1030              		.loc 1 1502 0
 1031 07c4 0500A0E1 		mov	r0, r5
 1032 07c8 FEFFFFEB 		bl	CyU3PUsbFlushEp
1503:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1033              		.loc 1 1503 0
 1034 07cc 0810A0E1 		mov	r1, r8
 1035 07d0 0500A0E1 		mov	r0, r5
 1036 07d4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1504:../uvc.c      ****                         CyU3PBusyWait (100);
 1037              		.loc 1 1504 0
 1038 07d8 6400A0E3 		mov	r0, #100
 1039 07dc FEFFFFEB 		bl	CyU3PBusyWait
1507:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 1040              		.loc 1 1507 0
 1041 07e0 0810A0E1 		mov	r1, r8
 1042 07e4 0620A0E1 		mov	r2, r6
 1043 07e8 0500A0E1 		mov	r0, r5
 1044 07ec FEFFFFEB 		bl	CyU3PUsbStall
 1045              	.LVL81:
1511:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1046              		.loc 1 1511 0
 1047 07f0 FEFFFFEB 		bl	CyU3PUsbAckSetup
1513:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 1048              		.loc 1 1513 0
 1049 07f4 446087E5 		str	r6, [r7, #68]
 1050              	.LBB50:
 1051              	.LBB51:
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1052              		.loc 1 1331 0
 1053 07f8 0700A0E1 		mov	r0, r7
 1054 07fc 0610A0E1 		mov	r1, r6
 1055 0800 0420A0E1 		mov	r2, r4
 1056 0804 0C308DE2 		add	r3, sp, #12
 1057 0808 00808DE5 		str	r8, [sp, #0]
 1058 080c FEFFFFEB 		bl	_txe_event_flags_get
 1059 0810 005050E2 		subs	r5, r0, #0
1509:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1060              		.loc 1 1509 0
 1061 0814 0600A011 		movne	r0, r6
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1062              		.loc 1 1331 0
 1063 0818 72FFFF1A 		bne	.L48
1334:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1064              		.loc 1 1334 0
 1065 081c 0110E0E3 		mvn	r1, #1
 1066 0820 0420A0E1 		mov	r2, r4
 1067 0824 0700A0E1 		mov	r0, r7
 1068 0828 FEFFFFEB 		bl	_txe_event_flags_set
1337:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1069              		.loc 1 1337 0
 1070 082c 0700A0E1 		mov	r0, r7
 1071 0830 0410A0E1 		mov	r1, r4
 1072 0834 0520A0E1 		mov	r2, r5
 1073 0838 FEFFFFEB 		bl	_txe_event_flags_set
1509:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1074              		.loc 1 1509 0
 1075 083c 0600A0E1 		mov	r0, r6
 1076 0840 68FFFFEA 		b	.L48
 1077              	.L73:
 1078              		.align	2
 1079              	.L72:
 1080 0844 00000000 		.word	bmReqType
 1081 0848 00000000 		.word	bRequest
 1082 084c 00000000 		.word	wValue
 1083 0850 00000000 		.word	wIndex
 1084 0854 00000000 		.word	wLength
 1085 0858 00000000 		.word	.LANCHOR0
 1086 085c 54010000 		.word	.LC8
 1087 0860 00000000 		.word	glChHandleUVCStream
 1088 0864 E8000000 		.word	.LC6
 1089 0868 20010000 		.word	.LC7
 1090 086c 6C010000 		.word	.LC9
 1091              	.LBE51:
 1092              	.LBE50:
 1093              		.cfi_endproc
 1094              	.LFE9:
 1096              		.align	2
 1097              		.global	CyFxGpifCB
 1099              	CyFxGpifCB:
 1100              	.LFB12:
1730:../uvc.c      **** {
 1101              		.loc 1 1730 0
 1102              		.cfi_startproc
 1103              		@ args = 0, pretend = 0, frame = 0
 1104              		@ frame_needed = 0, uses_anonymous_args = 0
 1105              	.LVL82:
1731:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1106              		.loc 1 1731 0
 1107 0870 010050E3 		cmp	r0, #1
1730:../uvc.c      **** {
 1108              		.loc 1 1730 0
 1109 0874 10402DE9 		stmfd	sp!, {r4, lr}
 1110              	.LCFI8:
 1111              		.cfi_def_cfa_offset 8
1730:../uvc.c      **** {
 1112              		.loc 1 1730 0
 1113 0878 0120A0E1 		mov	r2, r1
1731:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1114              		.loc 1 1731 0
 1115 087c 1080BD18 		ldmnefd	sp!, {r4, pc}
 1116              		.cfi_offset 14, -4
 1117              		.cfi_offset 4, -8
 1118              	.LVL83:
 1119              	.LBB56:
 1120              	.LBB57:
1628:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1121              		.loc 1 1628 0
 1122 0880 CC309FE5 		ldr	r3, .L89
 1123 0884 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 1124 0888 030053E3 		cmp	r3, #3
 1125 088c 2100000A 		beq	.L88
1654:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1126              		.loc 1 1654 0
 1127 0890 020053E3 		cmp	r3, #2
 1128 0894 1080BD18 		ldmnefd	sp!, {r4, pc}
1656:../uvc.c      ****         switch (stateId)
 1129              		.loc 1 1656 0
 1130 0898 080041E2 		sub	r0, r1, #8
 1131              	.LVL84:
 1132 089c 0A0050E3 		cmp	r0, #10
 1133 08a0 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1134 08a4 230000EA 		b	.L81
 1135              	.L83:
 1136 08a8 D8080000 		.word	.L78
 1137 08ac 38090000 		.word	.L81
 1138 08b0 38090000 		.word	.L81
 1139 08b4 D4080000 		.word	.L74
 1140 08b8 38090000 		.word	.L81
 1141 08bc 38090000 		.word	.L81
 1142 08c0 38090000 		.word	.L81
 1143 08c4 10090000 		.word	.L87
 1144 08c8 38090000 		.word	.L81
 1145 08cc 38090000 		.word	.L81
 1146 08d0 D4080000 		.word	.L74
 1147              	.LVL85:
 1148              	.L74:
 1149 08d4 1080BDE8 		ldmfd	sp!, {r4, pc}
 1150              	.LVL86:
 1151              	.L78:
1639:../uvc.c      ****                 socket = 0;
 1152              		.loc 1 1639 0
 1153 08d8 0010A0E3 		mov	r1, #0
 1154              	.LVL87:
 1155              	.L79:
1713:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1156              		.loc 1 1713 0
 1157 08dc 74009FE5 		ldr	r0, .L89+4
 1158 08e0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1159              	.LVL88:
1714:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1160              		.loc 1 1714 0
 1161 08e4 002050E2 		subs	r2, r0, #0
 1162 08e8 F9FFFF0A 		beq	.L74
1716:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1163              		.loc 1 1716 0
 1164 08ec 0400A0E3 		mov	r0, #4
 1165              	.LVL89:
 1166 08f0 64109FE5 		ldr	r1, .L89+8
 1167 08f4 FEFFFFEB 		bl	CyU3PDebugPrint
 1168              	.LVL90:
 1169              	.L84:
 1170              	.LBB58:
 1171              	.LBB59:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1172              		.loc 1 1318 0
 1173 08f8 60109FE5 		ldr	r1, .L89+12
 1174 08fc 0400A0E3 		mov	r0, #4
 1175 0900 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 1176              		.loc 1 1319 0
 1177 0904 FA0FA0E3 		mov	r0, #1000
 1178 0908 FEFFFFEB 		bl	_tx_thread_sleep
 1179 090c F9FFFFEA 		b	.L84
 1180              	.LVL91:
 1181              	.L87:
 1182              	.LBE59:
 1183              	.LBE58:
1683:../uvc.c      ****                 socket = 1;
 1184              		.loc 1 1683 0
 1185 0910 0110A0E3 		mov	r1, #1
 1186              	.LVL92:
 1187 0914 F0FFFFEA 		b	.L79
 1188              	.LVL93:
 1189              	.L88:
1630:../uvc.c      ****         switch (stateId)
 1190              		.loc 1 1630 0
 1191 0918 0B2041E2 		sub	r2, r1, #11
 1192 091c 030052E3 		cmp	r2, #3
 1193 0920 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 1194 0924 060000EA 		b	.L77
 1195              	.L80:
 1196 0928 D8080000 		.word	.L78
 1197 092c 10090000 		.word	.L87
 1198 0930 D4080000 		.word	.L74
 1199 0934 D4080000 		.word	.L74
 1200              	.LVL94:
 1201              	.L81:
1702:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1202              		.loc 1 1702 0
 1203 0938 24109FE5 		ldr	r1, .L89+16
 1204              	.LVL95:
 1205 093c 0100A0E3 		mov	r0, #1
 1206 0940 FEFFFFEB 		bl	CyU3PDebugPrint
 1207              	.LVL96:
 1208              	.L77:
 1209              	.LBE57:
 1210              	.LBE56:
1737:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1211              		.loc 1 1737 0
 1212 0944 1C109FE5 		ldr	r1, .L89+20
 1213 0948 0400A0E3 		mov	r0, #4
1740:../uvc.c      **** }
 1214              		.loc 1 1740 0
 1215 094c 1040BDE8 		ldmfd	sp!, {r4, lr}
1737:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1216              		.loc 1 1737 0
 1217 0950 FEFFFFEA 		b	CyU3PDebugPrint
 1218              	.L90:
 1219              		.align	2
 1220              	.L89:
 1221 0954 00000000 		.word	.LANCHOR0
 1222 0958 00000000 		.word	glChHandleUVCStream
 1223 095c A8010000 		.word	.LC11
 1224 0960 D8010000 		.word	.LC12
 1225 0964 90010000 		.word	.LC10
 1226 0968 EC010000 		.word	.LC13
 1227              		.cfi_endproc
 1228              	.LFE12:
 1230              		.align	2
 1231              		.global	I2CCmdHandler
 1233              	I2CCmdHandler:
 1234              	.LFB0:
 336:../uvc.c      **** void I2CCmdHandler(){
 1235              		.loc 1 336 0
 1236              		.cfi_startproc
 1237              		@ args = 0, pretend = 0, frame = 8
 1238              		@ frame_needed = 0, uses_anonymous_args = 0
 1239 096c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1240              	.LCFI9:
 1241              		.cfi_def_cfa_offset 36
 339:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1242              		.loc 1 339 0
 1243 0970 FC419FE5 		ldr	r4, .L104
 1244              		.cfi_offset 14, -4
 1245              		.cfi_offset 11, -8
 1246              		.cfi_offset 10, -12
 1247              		.cfi_offset 9, -16
 1248              		.cfi_offset 8, -20
 1249              		.cfi_offset 7, -24
 1250              		.cfi_offset 6, -28
 1251              		.cfi_offset 5, -32
 1252              		.cfi_offset 4, -36
 336:../uvc.c      **** void I2CCmdHandler(){
 1253              		.loc 1 336 0
 1254 0974 34D04DE2 		sub	sp, sp, #52
 1255              	.LCFI10:
 1256              		.cfi_def_cfa_offset 88
 344:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1257              		.loc 1 344 0
 1258 0978 5410D4E5 		ldrb	r1, [r4, #84]	@ zero_extendqisi2
 339:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1259              		.loc 1 339 0
 1260 097c 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1261              	.LVL97:
 340:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1262              		.loc 1 340 0
 1263 0980 4D60D4E5 		ldrb	r6, [r4, #77]	@ zero_extendqisi2
 1264              	.LVL98:
 344:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1265              		.loc 1 344 0
 1266 0984 4E70D4E5 		ldrb	r7, [r4, #78]	@ zero_extendqisi2
 1267 0988 4FE0D4E5 		ldrb	lr, [r4, #79]	@ zero_extendqisi2
 1268 098c 5080D4E5 		ldrb	r8, [r4, #80]	@ zero_extendqisi2
 1269 0990 51A0D4E5 		ldrb	sl, [r4, #81]	@ zero_extendqisi2
 1270 0994 5290D4E5 		ldrb	r9, [r4, #82]	@ zero_extendqisi2
 1271 0998 53B0D4E5 		ldrb	fp, [r4, #83]	@ zero_extendqisi2
 1272 099c 18108DE5 		str	r1, [sp, #24]
 1273 09a0 5530D4E5 		ldrb	r3, [r4, #85]	@ zero_extendqisi2
 1274 09a4 0400A0E3 		mov	r0, #4
 1275 09a8 1C308DE5 		str	r3, [sp, #28]
 1276 09ac 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1277 09b0 0630A0E1 		mov	r3, r6
 1278 09b4 BC119FE5 		ldr	r1, .L104+4
 1279 09b8 0520A0E1 		mov	r2, r5
 1280 09bc 80408DE8 		stmia	sp, {r7, lr}	@ phole stm
 1281 09c0 08808DE5 		str	r8, [sp, #8]
 1282 09c4 0CA08DE5 		str	sl, [sp, #12]
 1283 09c8 10908DE5 		str	r9, [sp, #16]
 1284 09cc 14B08DE5 		str	fp, [sp, #20]
 1285 09d0 20C08DE5 		str	ip, [sp, #32]
 1286 09d4 FEFFFFEB 		bl	CyU3PDebugPrint
 1287              	.LVL99:
 347:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1288              		.loc 1 347 0
 1289 09d8 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 1290 09dc 520053E3 		cmp	r3, #82
 1291 09e0 1A00000A 		beq	.L101
 1292              	.L92:
 357:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1293              		.loc 1 357 0
 1294 09e4 000055E3 		cmp	r5, #0
 384:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1295              		.loc 1 384 0
 1296 09e8 0030E003 		mvneq	r3, #0
 1297 09ec 5730C405 		streqb	r3, [r4, #87]
 357:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1298              		.loc 1 357 0
 1299 09f0 0100000A 		beq	.L91
 388:../uvc.c      **** 	}else if(CmdType == 1){
 1300              		.loc 1 388 0
 1301 09f4 010055E3 		cmp	r5, #1
 1302 09f8 0100000A 		beq	.L102
 1303              	.LVL100:
 1304              	.L91:
 407:../uvc.c      **** }
 1305              		.loc 1 407 0
 1306 09fc 34D08DE2 		add	sp, sp, #52
 1307 0a00 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1308              	.LVL101:
 1309              	.L102:
 390:../uvc.c      **** 			if(CmdRegLen == 2){
 1310              		.loc 1 390 0
 1311 0a04 020056E3 		cmp	r6, #2
 1312 0a08 2300000A 		beq	.L103
 395:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1313              		.loc 1 395 0
 1314 0a0c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1315 0a10 5C319FE5 		ldr	r3, .L104
 1316 0a14 FE1001E2 		and	r1, r1, #254
 1317 0a18 820051E3 		cmp	r1, #130
 398:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1318              		.loc 1 398 0
 1319 0a1c 5050D315 		ldrneb	r5, [r3, #80]	@ zero_extendqisi2
 1320              	.LVL102:
 395:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1321              		.loc 1 395 0
 1322 0a20 0200001A 		bne	.L100
 395:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1323              		.loc 1 395 0 is_stmt 0 discriminator 1
 1324 0a24 5050D3E5 		ldrb	r5, [r3, #80]	@ zero_extendqisi2
 1325 0a28 300055E3 		cmp	r5, #48
 1326 0a2c 3B00000A 		beq	.L98
 1327              	.L100:
 398:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1328              		.loc 1 398 0 is_stmt 1
 1329 0a30 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1330              	.L99:
 400:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 1331              		.loc 1 400 0
 1332 0a34 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1333 0a38 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1334 0a3c FE0002E2 		and	r0, r2, #254
 1335 0a40 0520A0E1 		mov	r2, r5
 1336 0a44 00E08DE5 		str	lr, [sp, #0]
 1337 0a48 FEFFFFEB 		bl	SensorWrite2B
 1338 0a4c EAFFFFEA 		b	.L91
 1339              	.LVL103:
 1340              	.L101:
 347:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1341              		.loc 1 347 0 discriminator 1
 1342 0a50 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1343 0a54 300053E3 		cmp	r3, #48
 1344 0a58 E1FFFF1A 		bne	.L92
 1345 0a5c 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1346 0a60 010053E3 		cmp	r3, #1
 1347 0a64 DEFFFF1A 		bne	.L92
 349:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 1348              		.loc 1 349 0
 1349 0a68 5520D4E5 		ldrb	r2, [r4, #85]	@ zero_extendqisi2
 1350 0a6c 08019FE5 		ldr	r0, .L104+8
 1351 0a70 03E002E2 		and	lr, r2, #3
 1352 0a74 8CE4C0E5 		strb	lr, [r0, #1164]
 350:../uvc.c      **** 		if(is60Hz==CyFalse)
 1353              		.loc 1 350 0
 1354 0a78 58C094E5 		ldr	ip, [r4, #88]
 354:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1355              		.loc 1 354 0
 1356 0a7c FC109FE5 		ldr	r1, .L104+12
 350:../uvc.c      **** 		if(is60Hz==CyFalse)
 1357              		.loc 1 350 0
 1358 0a80 00005CE3 		cmp	ip, #0
 352:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 1359              		.loc 1 352 0
 1360 0a84 80208203 		orreq	r2, r2, #128
 354:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1361              		.loc 1 354 0
 1362 0a88 8C34D0E5 		ldrb	r3, [r0, #1164]	@ zero_extendqisi2
 352:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 1363              		.loc 1 352 0
 1364 0a8c 5520C405 		streqb	r2, [r4, #85]
 354:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1365              		.loc 1 354 0
 1366 0a90 0400A0E3 		mov	r0, #4
 1367 0a94 FEFFFFEB 		bl	CyU3PDebugPrint
 1368 0a98 D1FFFFEA 		b	.L92
 1369              	.L103:
 392:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 1370              		.loc 1 392 0
 1371 0a9c 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1372 0aa0 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1373 0aa4 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1374 0aa8 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1375 0aac 0020A0E3 		mov	r2, #0
 1376 0ab0 FE0000E2 		and	r0, r0, #254
 1377 0ab4 00E08DE5 		str	lr, [sp, #0]
 1378 0ab8 FEFFFFEB 		bl	SensorWrite2B2
 1379 0abc 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1380 0ac0 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1381 0ac4 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1382 0ac8 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1383 0acc FE0002E2 		and	r0, r2, #254
 1384 0ad0 0020A0E3 		mov	r2, #0
 1385 0ad4 00C08DE5 		str	ip, [sp, #0]
 1386 0ad8 FEFFFFEB 		bl	SensorWrite2B2
 1387              	.LVL104:
 1388 0adc 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1389 0ae0 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1390 0ae4 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1391 0ae8 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1392 0aec 0020A0E3 		mov	r2, #0
 1393 0af0 FE0000E2 		and	r0, r0, #254
 1394 0af4 00C08DE5 		str	ip, [sp, #0]
 1395 0af8 FEFFFFEB 		bl	SensorWrite2B2
 1396 0afc 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1397 0b00 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1398 0b04 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1399 0b08 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1400 0b0c FE0002E2 		and	r0, r2, #254
 1401 0b10 0020A0E3 		mov	r2, #0
 1402 0b14 00C08DE5 		str	ip, [sp, #0]
 1403 0b18 FEFFFFEB 		bl	SensorWrite2B2
 1404 0b1c B6FFFFEA 		b	.L91
 1405              	.LVL105:
 1406              	.L98:
 395:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1407              		.loc 1 395 0 discriminator 1
 1408 0b20 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1409 0b24 100053E3 		cmp	r3, #16
 1410 0b28 C1FFFF1A 		bne	.L99
 396:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 1411              		.loc 1 396 0
 1412 0b2c 50409FE5 		ldr	r4, .L104+16
 1413 0b30 0010E0E3 		mvn	r1, #0
 1414 0b34 1C0094E5 		ldr	r0, [r4, #28]
 1415 0b38 2C308DE5 		str	r3, [sp, #44]
 1416 0b3c FEFFFFEB 		bl	_txe_mutex_get
 397:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 1417              		.loc 1 397 0
 1418 0b40 2C309DE5 		ldr	r3, [sp, #44]
 1419 0b44 00C0A0E3 		mov	ip, #0
 1420 0b48 0320A0E1 		mov	r2, r3
 1421 0b4c 0400A0E1 		mov	r0, r4
 1422 0b50 1710A0E3 		mov	r1, #23
 1423 0b54 0530A0E1 		mov	r3, r5
 1424 0b58 00C08DE5 		str	ip, [sp, #0]
 1425 0b5c 04C08DE5 		str	ip, [sp, #4]
 1426 0b60 FEFFFFEB 		bl	cmdSet
 398:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1427              		.loc 1 398 0
 1428 0b64 1C0094E5 		ldr	r0, [r4, #28]
 407:../uvc.c      **** }
 1429              		.loc 1 407 0
 1430 0b68 34D08DE2 		add	sp, sp, #52
 1431 0b6c F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 398:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1432              		.loc 1 398 0
 1433 0b70 FEFFFFEA 		b	_txe_mutex_put
 1434              	.L105:
 1435              		.align	2
 1436              	.L104:
 1437 0b74 00000000 		.word	.LANCHOR0
 1438 0b78 04020000 		.word	.LC14
 1439 0b7c 00000000 		.word	.LANCHOR1
 1440 0b80 50020000 		.word	.LC15
 1441 0b84 00000000 		.word	cmdQu
 1442              		.cfi_endproc
 1443              	.LFE0:
 1445              		.align	2
 1446              		.global	setIrisauto
 1448              	setIrisauto:
 1449              	.LFB1:
 413:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1450              		.loc 1 413 0
 1451              		.cfi_startproc
 1452              		@ args = 0, pretend = 0, frame = 0
 1453              		@ frame_needed = 0, uses_anonymous_args = 0
 1454              	.LVL106:
 1455 0b88 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1456              	.LCFI11:
 1457              		.cfi_def_cfa_offset 16
 1458 0b8c 0160A0E1 		mov	r6, r1
 1459              		.cfi_offset 14, -4
 1460              		.cfi_offset 6, -8
 1461              		.cfi_offset 5, -12
 1462              		.cfi_offset 4, -16
 1463 0b90 08D04DE2 		sub	sp, sp, #8
 1464              	.LCFI12:
 1465              		.cfi_def_cfa_offset 24
 417:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1466              		.loc 1 417 0
 1467 0b94 0050A0E3 		mov	r5, #0
 413:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1468              		.loc 1 413 0
 1469 0b98 0040A0E1 		mov	r4, r0
 416:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1470              		.loc 1 416 0
 1471 0b9c 0010E0E3 		mvn	r1, #0
 1472              	.LVL107:
 1473 0ba0 1C0090E5 		ldr	r0, [r0, #28]
 1474              	.LVL108:
 1475 0ba4 FEFFFFEB 		bl	_txe_mutex_get
 417:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1476              		.loc 1 417 0
 1477 0ba8 060065E0 		rsb	r0, r5, r6
 1478 0bac 00C070E2 		rsbs	ip, r0, #0
 1479 0bb0 00C0ACE0 		adc	ip, ip, r0
 1480 0bb4 1410A0E3 		mov	r1, #20
 1481 0bb8 2720A0E3 		mov	r2, #39
 1482 0bbc 3030A0E3 		mov	r3, #48
 1483 0bc0 0400A0E1 		mov	r0, r4
 1484 0bc4 00C08DE5 		str	ip, [sp, #0]
 1485 0bc8 04508DE5 		str	r5, [sp, #4]
 1486 0bcc FEFFFFEB 		bl	cmdSet
 418:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 1487              		.loc 1 418 0
 1488 0bd0 050056E1 		cmp	r6, r5
 1489 0bd4 0260A003 		moveq	r6, #2
 1490 0bd8 0560A011 		movne	r6, r5
 1491 0bdc 0400A0E1 		mov	r0, r4
 1492 0be0 1510A0E3 		mov	r1, #21
 1493 0be4 2520A0E3 		mov	r2, #37
 1494 0be8 3030A0E3 		mov	r3, #48
 1495 0bec 00608DE5 		str	r6, [sp, #0]
 1496 0bf0 04508DE5 		str	r5, [sp, #4]
 1497 0bf4 FEFFFFEB 		bl	cmdSet
 419:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1498              		.loc 1 419 0
 1499 0bf8 1C0094E5 		ldr	r0, [r4, #28]
 420:../uvc.c      **** }
 1500              		.loc 1 420 0
 1501 0bfc 08D08DE2 		add	sp, sp, #8
 1502 0c00 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 419:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1503              		.loc 1 419 0
 1504 0c04 FEFFFFEA 		b	_txe_mutex_put
 1505              		.cfi_endproc
 1506              	.LFE1:
 1508              		.align	2
 1509              		.global	ControlHandle
 1511              	ControlHandle:
 1512              	.LFB2:
 422:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1513              		.loc 1 422 0
 1514              		.cfi_startproc
 1515              		@ args = 0, pretend = 0, frame = 24
 1516              		@ frame_needed = 0, uses_anonymous_args = 0
 1517              	.LVL109:
 1518 0c08 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1519              	.LCFI13:
 1520              		.cfi_def_cfa_offset 36
 429:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1521              		.loc 1 429 0
 1522 0c0c 1F0050E3 		cmp	r0, #31
 428:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1523              		.loc 1 428 0
 1524 0c10 207040E2 		sub	r7, r0, #32
 1525              		.cfi_offset 14, -4
 1526              		.cfi_offset 11, -8
 1527              		.cfi_offset 10, -12
 1528              		.cfi_offset 9, -16
 1529              		.cfi_offset 8, -20
 1530              		.cfi_offset 7, -24
 1531              		.cfi_offset 6, -28
 1532              		.cfi_offset 5, -32
 1533              		.cfi_offset 4, -36
 422:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1534              		.loc 1 422 0
 1535 0c14 2CD04DE2 		sub	sp, sp, #44
 1536              	.LCFI14:
 1537              		.cfi_def_cfa_offset 80
 422:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1538              		.loc 1 422 0
 1539 0c18 0040A0E1 		mov	r4, r0
 428:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1540              		.loc 1 428 0
 1541 0c1c FF7007E2 		and	r7, r7, #255
 1542              	.LVL110:
 429:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1543              		.loc 1 429 0
 1544 0c20 2300009A 		bls	.L110
 430:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1545              		.loc 1 430 0
 1546 0c24 E46E9FE5 		ldr	r6, .L228
 1547 0c28 872087E0 		add	r2, r7, r7, asl #1
 1548 0c2c 8221A0E1 		mov	r2, r2, asl #3
 1549 0c30 023086E0 		add	r3, r6, r2
 431:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1550              		.loc 1 431 0
 1551 0c34 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 432:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1552              		.loc 1 432 0
 1553 0c38 0FA0D3E5 		ldrb	sl, [r3, #15]	@ zero_extendqisi2
 433:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1554              		.loc 1 433 0
 1555 0c3c 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 444:../uvc.c      ****     reqData = bRequest;
 1556              		.loc 1 444 0
 1557 0c40 CC3E9FE5 		ldr	r3, .L228+4
 430:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1558              		.loc 1 430 0
 1559 0c44 0290D6E7 		ldrb	r9, [r6, r2]	@ zero_extendqisi2
 1560              	.LVL111:
 444:../uvc.c      ****     reqData = bRequest;
 1561              		.loc 1 444 0
 1562 0c48 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1563              	.LVL112:
 452:../uvc.c      ****     switch (bRequest)
 1564              		.loc 1 452 0
 1565 0c4c 830055E3 		cmp	r5, #131
 1566 0c50 2200000A 		beq	.L116
 1567              	.LVL113:
 1568              	.L222:
 1569 0c54 2B00009A 		bls	.L220
 1570 0c58 850055E3 		cmp	r5, #133
 1571 0c5c 8400000A 		beq	.L118
 1572 0c60 7200003A 		bcc	.L117
 1573 0c64 860055E3 		cmp	r5, #134
 1574 0c68 BD00000A 		beq	.L119
 1575 0c6c 870055E3 		cmp	r5, #135
 1576 0c70 B100000A 		beq	.L221
 1577              	.L112:
 966:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1578              		.loc 1 966 0
 1579 0c74 0000A0E3 		mov	r0, #0
 1580 0c78 0110A0E3 		mov	r1, #1
 1581 0c7c 0020A0E1 		mov	r2, r0
 1582 0c80 FEFFFFEB 		bl	CyU3PUsbStall
 967:../uvc.c      **** 			  break;
 1583              		.loc 1 967 0
 1584 0c84 FFE0A0E3 		mov	lr, #255
 1585 0c88 0E40A0E1 		mov	r4, lr
 1586 0c8c 0EC0A0E1 		mov	ip, lr
 1587 0c90 0E30A0E1 		mov	r3, lr
 1588              	.LVL114:
 1589              	.L122:
 969:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1590              		.loc 1 969 0
 1591 0c94 7C1E9FE5 		ldr	r1, .L228+8
 1592 0c98 0520A0E1 		mov	r2, r5
 1593 0c9c 0400A0E3 		mov	r0, #4
 1594 0ca0 00C08DE5 		str	ip, [sp, #0]
 1595 0ca4 10408DE9 		stmib	sp, {r4, lr}	@ phole stm
 1596 0ca8 FEFFFFEB 		bl	CyU3PDebugPrint
 970:../uvc.c      **** }
 1597              		.loc 1 970 0
 1598 0cac 2CD08DE2 		add	sp, sp, #44
 1599 0cb0 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1600              	.LVL115:
 1601              	.L110:
 435:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1602              		.loc 1 435 0
 1603 0cb4 546E9FE5 		ldr	r6, .L228
 444:../uvc.c      ****     reqData = bRequest;
 1604              		.loc 1 444 0
 1605 0cb8 543E9FE5 		ldr	r3, .L228+4
 435:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1606              		.loc 1 435 0
 1607 0cbc 805080E0 		add	r5, r0, r0, asl #1
 1608 0cc0 850186E0 		add	r0, r6, r5, asl #3
 1609              	.LVL116:
 444:../uvc.c      ****     reqData = bRequest;
 1610              		.loc 1 444 0
 1611 0cc4 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 435:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1612              		.loc 1 435 0
 1613 0cc8 8091D0E5 		ldrb	r9, [r0, #384]	@ zero_extendqisi2
 1614              	.LVL117:
 452:../uvc.c      ****     switch (bRequest)
 1615              		.loc 1 452 0
 1616 0ccc 830055E3 		cmp	r5, #131
 436:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1617              		.loc 1 436 0
 1618 0cd0 81B1D0E5 		ldrb	fp, [r0, #385]	@ zero_extendqisi2
 1619              	.LVL118:
 437:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1620              		.loc 1 437 0
 1621 0cd4 8FA1D0E5 		ldrb	sl, [r0, #399]	@ zero_extendqisi2
 1622              	.LVL119:
 438:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1623              		.loc 1 438 0
 1624 0cd8 8281D0E5 		ldrb	r8, [r0, #386]	@ zero_extendqisi2
 1625              	.LVL120:
 452:../uvc.c      ****     switch (bRequest)
 1626              		.loc 1 452 0
 1627 0cdc DCFFFF1A 		bne	.L222
 1628              	.LVL121:
 1629              	.L116:
 586:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1630              		.loc 1 586 0
 1631 0ce0 1F0054E3 		cmp	r4, #31
 1632 0ce4 BC00009A 		bls	.L147
 587:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1633              		.loc 1 587 0
 1634 0ce8 877087E0 		add	r7, r7, r7, asl #1
 1635              	.LVL122:
 1636 0cec 876186E0 		add	r6, r6, r7, asl #3
 1637 0cf0 24AE9FE5 		ldr	sl, .L228+12
 1638 0cf4 0500D6E5 		ldrb	r0, [r6, #5]	@ zero_extendqisi2
 588:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1639              		.loc 1 588 0
 1640 0cf8 06C0D6E5 		ldrb	ip, [r6, #6]	@ zero_extendqisi2
 587:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1641              		.loc 1 587 0
 1642 0cfc 5C00CAE5 		strb	r0, [sl, #92]
 588:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1643              		.loc 1 588 0
 1644 0d00 5DC0CAE5 		strb	ip, [sl, #93]
 1645 0d04 0B0000EA 		b	.L155
 1646              	.LVL123:
 1647              	.L220:
 452:../uvc.c      ****     switch (bRequest)
 1648              		.loc 1 452 0
 1649 0d08 810055E3 		cmp	r5, #129
 1650 0d0c 6400000A 		beq	.L114
 1651 0d10 1000009A 		bls	.L223
 567:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1652              		.loc 1 567 0
 1653 0d14 1F0054E3 		cmp	r4, #31
 1654 0d18 A300009A 		bls	.L144
 568:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1655              		.loc 1 568 0
 1656 0d1c 877087E0 		add	r7, r7, r7, asl #1
 1657              	.LVL124:
 1658 0d20 876186E0 		add	r6, r6, r7, asl #3
 1659 0d24 F0AD9FE5 		ldr	sl, .L228+12
 1660 0d28 0320D6E5 		ldrb	r2, [r6, #3]	@ zero_extendqisi2
 569:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1661              		.loc 1 569 0
 1662 0d2c 04E0D6E5 		ldrb	lr, [r6, #4]	@ zero_extendqisi2
 568:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1663              		.loc 1 568 0
 1664 0d30 5C20CAE5 		strb	r2, [sl, #92]
 569:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1665              		.loc 1 569 0
 1666 0d34 5DE0CAE5 		strb	lr, [sl, #93]
 1667              	.L155:
 645:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1668              		.loc 1 645 0
 1669 0d38 0800A0E1 		mov	r0, r8
 1670 0d3c DC1D9FE5 		ldr	r1, .L228+16
 1671 0d40 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1672              	.LVL125:
 647:../uvc.c      **** 			  break;
 1673              		.loc 1 647 0
 1674 0d44 FFE0A0E3 		mov	lr, #255
 645:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1675              		.loc 1 645 0
 1676 0d48 5C40DAE5 		ldrb	r4, [sl, #92]	@ zero_extendqisi2
 647:../uvc.c      **** 			  break;
 1677              		.loc 1 647 0
 1678 0d4c 0EC0A0E1 		mov	ip, lr
 1679 0d50 0E30A0E1 		mov	r3, lr
 1680 0d54 CEFFFFEA 		b	.L122
 1681              	.LVL126:
 1682              	.L223:
 452:../uvc.c      ****     switch (bRequest)
 1683              		.loc 1 452 0
 1684 0d58 010055E3 		cmp	r5, #1
 1685 0d5c C4FFFF1A 		bne	.L112
 649:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1686              		.loc 1 649 0
 1687 0d60 B41D9FE5 		ldr	r1, .L228+12
 1688 0d64 26208DE2 		add	r2, sp, #38
 1689 0d68 2000A0E3 		mov	r0, #32
 1690 0d6c 5C1081E2 		add	r1, r1, #92
 1691 0d70 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1692              	.LVL127:
 651:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1693              		.loc 1 651 0
 1694 0d74 002050E2 		subs	r2, r0, #0
 1695 0d78 0103001A 		bne	.L157
 653:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1696              		.loc 1 653 0
 1697 0d7c 98ED9FE5 		ldr	lr, .L228+12
 1698 0d80 5C30DEE5 		ldrb	r3, [lr, #92]	@ zero_extendqisi2
 654:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1699              		.loc 1 654 0
 1700 0d84 90ED9FE5 		ldr	lr, .L228+12
 653:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1701              		.loc 1 653 0
 1702 0d88 18308DE5 		str	r3, [sp, #24]
 1703              	.LVL128:
 656:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1704              		.loc 1 656 0
 1705 0d8c 5E00DEE5 		ldrb	r0, [lr, #94]	@ zero_extendqisi2
 1706              	.LVL129:
 654:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1707              		.loc 1 654 0
 1708 0d90 5DC0DEE5 		ldrb	ip, [lr, #93]	@ zero_extendqisi2
 1709              	.LVL130:
 656:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1710              		.loc 1 656 0
 1711 0d94 1C008DE5 		str	r0, [sp, #28]
 1712              	.LVL131:
 660:../uvc.c      **** 				  switch(CtrlID)
 1713              		.loc 1 660 0
 1714 0d98 220054E3 		cmp	r4, #34
 1715 0d9c 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1716 0da0 C90200EA 		b	.L158
 1717              	.L173:
 1718 0da4 34190000 		.word	.L159
 1719 0da8 64180000 		.word	.L160
 1720 0dac CC180000 		.word	.L158
 1721 0db0 CC180000 		.word	.L158
 1722 0db4 14180000 		.word	.L161
 1723 0db8 D0160000 		.word	.L162
 1724 0dbc 54160000 		.word	.L163
 1725 0dc0 CC180000 		.word	.L158
 1726 0dc4 CC180000 		.word	.L158
 1727 0dc8 CC180000 		.word	.L158
 1728 0dcc CC180000 		.word	.L158
 1729 0dd0 CC150000 		.word	.L164
 1730 0dd4 CC180000 		.word	.L158
 1731 0dd8 CC180000 		.word	.L158
 1732 0ddc CC180000 		.word	.L158
 1733 0de0 CC180000 		.word	.L158
 1734 0de4 D4140000 		.word	.L165
 1735 0de8 CC180000 		.word	.L158
 1736 0dec CC180000 		.word	.L158
 1737 0df0 CC180000 		.word	.L158
 1738 0df4 CC180000 		.word	.L158
 1739 0df8 CC180000 		.word	.L158
 1740 0dfc CC180000 		.word	.L158
 1741 0e00 CC180000 		.word	.L158
 1742 0e04 CC180000 		.word	.L158
 1743 0e08 18140000 		.word	.L166
 1744 0e0c CC180000 		.word	.L158
 1745 0e10 CC180000 		.word	.L158
 1746 0e14 5C150000 		.word	.L167
 1747 0e18 CC180000 		.word	.L158
 1748 0e1c BC130000 		.word	.L168
 1749 0e20 38130000 		.word	.L169
 1750 0e24 A0120000 		.word	.L170
 1751 0e28 88120000 		.word	.L171
 1752 0e2c 24120000 		.word	.L172
 1753              	.LVL132:
 1754              	.L117:
 604:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1755              		.loc 1 604 0
 1756 0e30 1F0054E3 		cmp	r4, #31
 605:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1757              		.loc 1 605 0
 1758 0e34 87708780 		addhi	r7, r7, r7, asl #1
 1759              	.LVL133:
 611:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1760              		.loc 1 611 0
 1761 0e38 84408490 		addls	r4, r4, r4, asl #1
 605:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1762              		.loc 1 605 0
 1763 0e3c 87618680 		addhi	r6, r6, r7, asl #3
 611:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1764              		.loc 1 611 0
 1765 0e40 84618690 		addls	r6, r6, r4, asl #3
 605:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1766              		.loc 1 605 0
 1767 0e44 D0AC9F85 		ldrhi	sl, .L228+12
 611:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1768              		.loc 1 611 0
 1769 0e48 CCAC9F95 		ldrls	sl, .L228+12
 605:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1770              		.loc 1 605 0
 1771 0e4c 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 606:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1772              		.loc 1 606 0
 1773 0e50 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 611:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1774              		.loc 1 611 0
 1775 0e54 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 612:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1776              		.loc 1 612 0
 1777 0e58 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 613:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1778              		.loc 1 613 0
 1779 0e5c 0030A0E3 		mov	r3, #0
 611:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1780              		.loc 1 611 0
 1781 0e60 5C10CAE5 		strb	r1, [sl, #92]
 612:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1782              		.loc 1 612 0
 1783 0e64 5D20CAE5 		strb	r2, [sl, #93]
 613:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1784              		.loc 1 613 0
 1785 0e68 5E30CAE5 		strb	r3, [sl, #94]
 614:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1786              		.loc 1 614 0
 1787 0e6c 5F30CAE5 		strb	r3, [sl, #95]
 1788 0e70 B0FFFFEA 		b	.L155
 1789              	.LVL134:
 1790              	.L118:
 456:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1791              		.loc 1 456 0
 1792 0e74 A04C9FE5 		ldr	r4, .L228+12
 457:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1793              		.loc 1 457 0
 1794 0e78 00C0A0E3 		mov	ip, #0
 1795 0e7c 5DC0C4E5 		strb	ip, [r4, #93]
 458:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1796              		.loc 1 458 0
 1797 0e80 5C1084E2 		add	r1, r4, #92
 456:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1798              		.loc 1 456 0
 1799 0e84 5C80C4E5 		strb	r8, [r4, #92]
 458:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1800              		.loc 1 458 0
 1801 0e88 0200A0E3 		mov	r0, #2
 1802 0e8c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1803              	.LVL135:
 460:../uvc.c      **** 			  break;
 1804              		.loc 1 460 0
 1805 0e90 FFE0A0E3 		mov	lr, #255
 458:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1806              		.loc 1 458 0
 1807 0e94 5C40D4E5 		ldrb	r4, [r4, #92]	@ zero_extendqisi2
 460:../uvc.c      **** 			  break;
 1808              		.loc 1 460 0
 1809 0e98 0EC0A0E1 		mov	ip, lr
 1810 0e9c 0E30A0E1 		mov	r3, lr
 1811 0ea0 7BFFFFEA 		b	.L122
 1812              	.LVL136:
 1813              	.L114:
 463:../uvc.c      **** 			 switch(CtrlID)
 1814              		.loc 1 463 0
 1815 0ea4 011044E2 		sub	r1, r4, #1
 1816 0ea8 210051E3 		cmp	r1, #33
 1817 0eac 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 1818 0eb0 D20000EA 		b	.L123
 1819              	.L131:
 1820 0eb4 D4110000 		.word	.L124
 1821 0eb8 00120000 		.word	.L123
 1822 0ebc 00120000 		.word	.L123
 1823 0ec0 00120000 		.word	.L123
 1824 0ec4 B4110000 		.word	.L125
 1825 0ec8 00120000 		.word	.L123
 1826 0ecc 00120000 		.word	.L123
 1827 0ed0 00120000 		.word	.L123
 1828 0ed4 00120000 		.word	.L123
 1829 0ed8 00120000 		.word	.L123
 1830 0edc 90110000 		.word	.L126
 1831 0ee0 00120000 		.word	.L123
 1832 0ee4 00120000 		.word	.L123
 1833 0ee8 00120000 		.word	.L123
 1834 0eec 00120000 		.word	.L123
 1835 0ef0 00120000 		.word	.L123
 1836 0ef4 00120000 		.word	.L123
 1837 0ef8 00120000 		.word	.L123
 1838 0efc 00120000 		.word	.L123
 1839 0f00 00120000 		.word	.L123
 1840 0f04 00120000 		.word	.L123
 1841 0f08 00120000 		.word	.L123
 1842 0f0c 00120000 		.word	.L123
 1843 0f10 00120000 		.word	.L123
 1844 0f14 54110000 		.word	.L127
 1845 0f18 00120000 		.word	.L123
 1846 0f1c 00120000 		.word	.L123
 1847 0f20 2C110000 		.word	.L128
 1848 0f24 00120000 		.word	.L123
 1849 0f28 00120000 		.word	.L123
 1850 0f2c 90100000 		.word	.L129
 1851 0f30 58100000 		.word	.L130
 1852 0f34 58100000 		.word	.L130
 1853 0f38 58100000 		.word	.L130
 1854              	.L221:
 631:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1855              		.loc 1 631 0
 1856 0f3c 1F0054E3 		cmp	r4, #31
 1857 0f40 3100009A 		bls	.L154
 632:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1858              		.loc 1 632 0
 1859 0f44 877087E0 		add	r7, r7, r7, asl #1
 1860              	.LVL137:
 1861 0f48 876186E0 		add	r6, r6, r7, asl #3
 1862 0f4c C8AB9FE5 		ldr	sl, .L228+12
 1863 0f50 0B10D6E5 		ldrb	r1, [r6, #11]	@ zero_extendqisi2
 633:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1864              		.loc 1 633 0
 1865 0f54 0C40D6E5 		ldrb	r4, [r6, #12]	@ zero_extendqisi2
 632:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1866              		.loc 1 632 0
 1867 0f58 5C10CAE5 		strb	r1, [sl, #92]
 633:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1868              		.loc 1 633 0
 1869 0f5c 5D40CAE5 		strb	r4, [sl, #93]
 1870 0f60 74FFFFEA 		b	.L155
 1871              	.LVL138:
 1872              	.L119:
 620:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1873              		.loc 1 620 0
 1874 0f64 1F0054E3 		cmp	r4, #31
 624:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1875              		.loc 1 624 0
 1876 0f68 84408490 		addls	r4, r4, r4, asl #1
 621:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1877              		.loc 1 621 0
 1878 0f6c 87708780 		addhi	r7, r7, r7, asl #1
 1879              	.LVL139:
 624:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1880              		.loc 1 624 0
 1881 0f70 84618690 		addls	r6, r6, r4, asl #3
 621:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1882              		.loc 1 621 0
 1883 0f74 87618680 		addhi	r6, r6, r7, asl #3
 1884 0f78 9C8B9F85 		ldrhi	r8, .L228+12
 1885 0f7c 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 624:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1886              		.loc 1 624 0
 1887 0f80 948B9F95 		ldrls	r8, .L228+12
 1888 0f84 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 626:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1889              		.loc 1 626 0
 1890 0f88 0100A0E3 		mov	r0, #1
 624:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1891              		.loc 1 624 0
 1892 0f8c 5C30C8E5 		strb	r3, [r8, #92]
 626:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1893              		.loc 1 626 0
 1894 0f90 881B9FE5 		ldr	r1, .L228+16
 1895 0f94 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1896              	.LVL140:
 629:../uvc.c      **** 			  break;
 1897              		.loc 1 629 0
 1898 0f98 FFE0A0E3 		mov	lr, #255
 626:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1899              		.loc 1 626 0
 1900 0f9c 5C40D8E5 		ldrb	r4, [r8, #92]	@ zero_extendqisi2
 629:../uvc.c      **** 			  break;
 1901              		.loc 1 629 0
 1902 0fa0 0EC0A0E1 		mov	ip, lr
 1903 0fa4 0E30A0E1 		mov	r3, lr
 1904 0fa8 39FFFFEA 		b	.L122
 1905              	.LVL141:
 1906              	.L144:
 572:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1907              		.loc 1 572 0
 1908 0fac 0B0054E3 		cmp	r4, #11
 579:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1909              		.loc 1 579 0
 1910 0fb0 84408410 		addne	r4, r4, r4, asl #1
 1911 0fb4 84618610 		addne	r6, r6, r4, asl #3
 1912 0fb8 5CAB9F15 		ldrne	sl, .L228+12
 573:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1913              		.loc 1 573 0
 1914 0fbc 58AB9F05 		ldreq	sl, .L228+12
 1915 0fc0 5C3B9F05 		ldreq	r3, .L228+20
 579:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1916              		.loc 1 579 0
 1917 0fc4 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 580:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1918              		.loc 1 580 0
 1919 0fc8 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 573:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1920              		.loc 1 573 0
 1921 0fcc 5C308A05 		streq	r3, [sl, #92]
 579:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1922              		.loc 1 579 0
 1923 0fd0 5C20CA15 		strneb	r2, [sl, #92]
 580:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1924              		.loc 1 580 0
 1925 0fd4 5D30CA15 		strneb	r3, [sl, #93]
 1926 0fd8 56FFFFEA 		b	.L155
 1927              	.L147:
 590:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1928              		.loc 1 590 0
 1929 0fdc 0B0054E3 		cmp	r4, #11
 597:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1930              		.loc 1 597 0
 1931 0fe0 84408410 		addne	r4, r4, r4, asl #1
 1932 0fe4 84618610 		addne	r6, r6, r4, asl #3
 1933 0fe8 2CAB9F15 		ldrne	sl, .L228+12
 591:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1934              		.loc 1 591 0
 1935 0fec 28AB9F05 		ldreq	sl, .L228+12
 1936 0ff0 303B9F05 		ldreq	r3, .L228+24
 597:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1937              		.loc 1 597 0
 1938 0ff4 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 598:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1939              		.loc 1 598 0
 1940 0ff8 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 591:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1941              		.loc 1 591 0
 1942 0ffc 5C308A05 		streq	r3, [sl, #92]
 597:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1943              		.loc 1 597 0
 1944 1000 5C20CA15 		strneb	r2, [sl, #92]
 598:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1945              		.loc 1 598 0
 1946 1004 5D30CA15 		strneb	r3, [sl, #93]
 1947 1008 4AFFFFEA 		b	.L155
 1948              	.L154:
 636:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1949              		.loc 1 636 0
 1950 100c 0B0054E3 		cmp	r4, #11
 1951 1010 0700000A 		beq	.L224
 642:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1952              		.loc 1 642 0
 1953 1014 84A084E0 		add	sl, r4, r4, asl #1
 1954 1018 8A6186E0 		add	r6, r6, sl, asl #3
 1955 101c 8B31D6E5 		ldrb	r3, [r6, #395]	@ zero_extendqisi2
 1956 1020 F4AA9FE5 		ldr	sl, .L228+12
 643:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1957              		.loc 1 643 0
 1958 1024 8C01D6E5 		ldrb	r0, [r6, #396]	@ zero_extendqisi2
 642:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1959              		.loc 1 642 0
 1960 1028 5C30CAE5 		strb	r3, [sl, #92]
 643:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1961              		.loc 1 643 0
 1962 102c 5D00CAE5 		strb	r0, [sl, #93]
 1963 1030 40FFFFEA 		b	.L155
 1964              	.L224:
 637:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1965              		.loc 1 637 0
 1966 1034 E0AA9FE5 		ldr	sl, .L228+12
 1967 1038 93C2D6E5 		ldrb	ip, [r6, #659]	@ zero_extendqisi2
 639:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1968              		.loc 1 639 0
 1969 103c 9422D6E5 		ldrb	r2, [r6, #660]	@ zero_extendqisi2
 638:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1970              		.loc 1 638 0
 1971 1040 00E0A0E3 		mov	lr, #0
 637:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1972              		.loc 1 637 0
 1973 1044 5CC0CAE5 		strb	ip, [sl, #92]
 638:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1974              		.loc 1 638 0
 1975 1048 5DE0CAE5 		strb	lr, [sl, #93]
 639:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1976              		.loc 1 639 0
 1977 104c 5E20CAE5 		strb	r2, [sl, #94]
 640:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 1978              		.loc 1 640 0
 1979 1050 5FE0CAE5 		strb	lr, [sl, #95]
 1980 1054 37FFFFEA 		b	.L155
 1981              	.L130:
 469:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1982              		.loc 1 469 0
 1983 1058 877087E0 		add	r7, r7, r7, asl #1
 1984              	.LVL142:
 1985 105c 876186E0 		add	r6, r6, r7, asl #3
 1986 1060 B4EA9FE5 		ldr	lr, .L228+12
 1987 1064 0D40D6E5 		ldrb	r4, [r6, #13]	@ zero_extendqisi2
 470:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1988              		.loc 1 470 0
 1989 1068 0E60D6E5 		ldrb	r6, [r6, #14]	@ zero_extendqisi2
 469:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1990              		.loc 1 469 0
 1991 106c 5C40CEE5 		strb	r4, [lr, #92]
 470:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1992              		.loc 1 470 0
 1993 1070 5D60CEE5 		strb	r6, [lr, #93]
 1994              	.LVL143:
 1995              	.L134:
 560:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1996              		.loc 1 560 0
 1997 1074 0800A0E1 		mov	r0, r8
 1998 1078 A01A9FE5 		ldr	r1, .L228+16
 1999 107c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 565:../uvc.c      **** 			  break;
 2000              		.loc 1 565 0
 2001 1080 FFC0A0E3 		mov	ip, #255
 560:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2002              		.loc 1 560 0
 2003 1084 06E0A0E1 		mov	lr, r6
 565:../uvc.c      **** 			  break;
 2004              		.loc 1 565 0
 2005 1088 0C30A0E1 		mov	r3, ip
 2006 108c 00FFFFEA 		b	.L122
 2007              	.LVL144:
 2008              	.L129:
 490:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2009              		.loc 1 490 0 discriminator 1
 2010 1090 000058E3 		cmp	r8, #0
 2011 1094 8002000A 		beq	.L216
 488:../uvc.c      **** 					 break;
 2012              		.loc 1 488 0
 2013 1098 28E1A0E1 		mov	lr, r8, lsr #2
 2014 109c 00005EE3 		cmp	lr, #0
 2015 10a0 03005813 		cmpne	r8, #3
 2016 10a4 0020A083 		movhi	r2, #0
 2017 10a8 0120A093 		movls	r2, #1
 422:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2018              		.loc 1 422 0
 2019 10ac 0E31A0E1 		mov	r3, lr, asl #2
 488:../uvc.c      **** 					 break;
 2020              		.loc 1 488 0
 2021 10b0 9302009A 		bls	.L201
 2022 10b4 641A9FE5 		ldr	r1, .L228+16
 2023 10b8 100041E2 		sub	r0, r1, #16
 2024              	.LVL145:
 2025              	.L139:
 491:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2026              		.loc 1 491 0 discriminator 2
 2027 10bc 044090E4 		ldr	r4, [r0], #4
 2028 10c0 01C082E2 		add	ip, r2, #1
 2029 10c4 FF200CE2 		and	r2, ip, #255
 2030 10c8 02005EE1 		cmp	lr, r2
 2031 10cc 044081E4 		str	r4, [r1], #4
 2032 10d0 F9FFFF8A 		bhi	.L139
 491:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2033              		.loc 1 491 0 is_stmt 0
 2034 10d4 030058E1 		cmp	r8, r3
 2035 10d8 3C0A9F15 		ldrne	r0, .L228+12
 2036 10dc 6E02000A 		beq	.L216
 2037              	.L208:
 2038 10e0 03E080E0 		add	lr, r0, r3
 2039 10e4 4C10DEE5 		ldrb	r1, [lr, #76]	@ zero_extendqisi2
 490:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2040              		.loc 1 490 0 is_stmt 1
 2041 10e8 016083E2 		add	r6, r3, #1
 2042 10ec FF3006E2 		and	r3, r6, #255
 2043              	.LVL146:
 2044 10f0 030058E1 		cmp	r8, r3
 491:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2045              		.loc 1 491 0
 2046 10f4 5C10CEE5 		strb	r1, [lr, #92]
 490:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2047              		.loc 1 490 0
 2048 10f8 F8FFFF8A 		bhi	.L208
 2049              	.LVL147:
 2050              	.L133:
 500:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2051              		.loc 1 500 0
 2052 10fc 5720D0E5 		ldrb	r2, [r0, #87]	@ zero_extendqisi2
 493:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2053              		.loc 1 493 0
 2054 1100 143A9FE5 		ldr	r3, .L228+12
 500:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2055              		.loc 1 500 0
 2056 1104 FF0052E3 		cmp	r2, #255
 493:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2057              		.loc 1 493 0
 2058 1108 6540D0E5 		ldrb	r4, [r0, #101]	@ zero_extendqisi2
 2059              	.LVL148:
 494:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 2060              		.loc 1 494 0
 2061 110c 6660D0E5 		ldrb	r6, [r0, #102]	@ zero_extendqisi2
 2062              	.LVL149:
 500:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2063              		.loc 1 500 0
 2064 1110 D7FFFF0A 		beq	.L134
 502:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 2065              		.loc 1 502 0
 2066 1114 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 2067 1118 0C1A9FE5 		ldr	r1, .L228+28
 2068 111c 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 2069 1120 0400A0E3 		mov	r0, #4
 2070 1124 FEFFFFEB 		bl	CyU3PDebugPrint
 2071 1128 D1FFFFEA 		b	.L134
 2072              	.LVL150:
 2073              	.L128:
 477:../uvc.c      **** 					 if(CamMode == 1){//720p
 2074              		.loc 1 477 0
 2075 112c E8799FE5 		ldr	r7, .L228+12
 2076              	.LVL151:
 476:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 2077              		.loc 1 476 0
 2078 1130 2D44D6E5 		ldrb	r4, [r6, #1069]	@ zero_extendqisi2
 2079              	.LVL152:
 477:../uvc.c      **** 					 if(CamMode == 1){//720p
 2080              		.loc 1 477 0
 2081 1134 7C20D7E5 		ldrb	r2, [r7, #124]	@ zero_extendqisi2
 2082 1138 010052E3 		cmp	r2, #1
 2083 113c 1802000A 		beq	.L225
 2084              	.LVL153:
 2085              	.L135:
 487:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2086              		.loc 1 487 0
 2087 1140 0000A0E3 		mov	r0, #0
 486:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 2088              		.loc 1 486 0
 2089 1144 5C40C7E5 		strb	r4, [r7, #92]
 487:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2090              		.loc 1 487 0
 2091 1148 5D00C7E5 		strb	r0, [r7, #93]
 440:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2092              		.loc 1 440 0
 2093 114c FF60A0E3 		mov	r6, #255
 488:../uvc.c      **** 					 break;
 2094              		.loc 1 488 0
 2095 1150 C7FFFFEA 		b	.L134
 2096              	.LVL154:
 2097              	.L127:
 506:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 2098              		.loc 1 506 0
 2099 1154 E543D6E5 		ldrb	r4, [r6, #997]	@ zero_extendqisi2
 2100 1158 BCC99FE5 		ldr	ip, .L228+12
 508:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 2101              		.loc 1 508 0
 2102 115c E663D6E5 		ldrb	r6, [r6, #998]	@ zero_extendqisi2
 507:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2103              		.loc 1 507 0
 2104 1160 00E0A0E3 		mov	lr, #0
 506:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 2105              		.loc 1 506 0
 2106 1164 5C40CCE5 		strb	r4, [ip, #92]
 507:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2107              		.loc 1 507 0
 2108 1168 5DE0CCE5 		strb	lr, [ip, #93]
 508:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 2109              		.loc 1 508 0
 2110 116c 5E60CCE5 		strb	r6, [ip, #94]
 509:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2111              		.loc 1 509 0
 2112 1170 5FE0CCE5 		strb	lr, [ip, #95]
 2113              	.LVL155:
 512:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 2114              		.loc 1 512 0
 2115 1174 B4199FE5 		ldr	r1, .L228+32
 2116 1178 0420A0E1 		mov	r2, r4
 2117 117c 0E30A0E1 		mov	r3, lr
 2118 1180 0400A0E3 		mov	r0, #4
 2119 1184 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 2120 1188 FEFFFFEB 		bl	CyU3PDebugPrint
 513:../uvc.c      **** 					 break;
 2121              		.loc 1 513 0
 2122 118c B8FFFFEA 		b	.L134
 2123              	.LVL156:
 2124              	.L126:
 545:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2125              		.loc 1 545 0
 2126 1190 84C99FE5 		ldr	ip, .L228+12
 2127 1194 9044D6E5 		ldrb	r4, [r6, #1168]	@ zero_extendqisi2
 547:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2128              		.loc 1 547 0
 2129 1198 9264D6E5 		ldrb	r6, [r6, #1170]	@ zero_extendqisi2
 546:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2130              		.loc 1 546 0
 2131 119c 00E0A0E3 		mov	lr, #0
 545:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2132              		.loc 1 545 0
 2133 11a0 5C40CCE5 		strb	r4, [ip, #92]
 546:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2134              		.loc 1 546 0
 2135 11a4 5DE0CCE5 		strb	lr, [ip, #93]
 547:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2136              		.loc 1 547 0
 2137 11a8 5E60CCE5 		strb	r6, [ip, #94]
 548:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2138              		.loc 1 548 0
 2139 11ac 5FE0CCE5 		strb	lr, [ip, #95]
 2140              	.LVL157:
 551:../uvc.c      **** 					 break;
 2141              		.loc 1 551 0
 2142 11b0 AFFFFFEA 		b	.L134
 2143              	.LVL158:
 2144              	.L125:
 540:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2145              		.loc 1 540 0
 2146 11b4 0522D6E5 		ldrb	r2, [r6, #517]	@ zero_extendqisi2
 2147 11b8 5C699FE5 		ldr	r6, .L228+12
 2148 11bc 804022E2 		eor	r4, r2, #128
 541:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2149              		.loc 1 541 0
 2150 11c0 0010A0E3 		mov	r1, #0
 540:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2151              		.loc 1 540 0
 2152 11c4 5C40C6E5 		strb	r4, [r6, #92]
 541:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2153              		.loc 1 541 0
 2154 11c8 5D10C6E5 		strb	r1, [r6, #93]
 2155              	.LVL159:
 440:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2156              		.loc 1 440 0
 2157 11cc FF60A0E3 		mov	r6, #255
 543:../uvc.c      **** 					 break;
 2158              		.loc 1 543 0
 2159 11d0 A7FFFFEA 		b	.L134
 2160              	.LVL160:
 2161              	.L124:
 528:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 2162              		.loc 1 528 0
 2163 11d4 A541D6E5 		ldrb	r4, [r6, #421]	@ zero_extendqisi2
 2164              	.LVL161:
 534:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 2165              		.loc 1 534 0
 2166 11d8 3C399FE5 		ldr	r3, .L228+12
 529:../uvc.c      **** 					  if(Data0&0x80){
 2167              		.loc 1 529 0
 2168 11dc 800014E3 		tst	r4, #128
 530:../uvc.c      **** 						  Data0 = ~Data0;
 2169              		.loc 1 530 0
 2170 11e0 0440E011 		mvnne	r4, r4
 2171              	.LVL162:
 532:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 2172              		.loc 1 532 0
 2173 11e4 80404402 		subeq	r4, r4, #128
 2174 11e8 FF4004E2 		and	r4, r4, #255
 2175              	.LVL163:
 535:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2176              		.loc 1 535 0
 2177 11ec 0000A0E3 		mov	r0, #0
 534:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 2178              		.loc 1 534 0
 2179 11f0 5C40C3E5 		strb	r4, [r3, #92]
 535:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2180              		.loc 1 535 0
 2181 11f4 5D00C3E5 		strb	r0, [r3, #93]
 2182              	.LVL164:
 440:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2183              		.loc 1 440 0
 2184 11f8 FF60A0E3 		mov	r6, #255
 537:../uvc.c      **** 			 		 break;
 2185              		.loc 1 537 0
 2186 11fc 9CFFFFEA 		b	.L134
 2187              	.LVL165:
 2188              	.L123:
 554:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2189              		.loc 1 554 0
 2190 1200 841084E0 		add	r1, r4, r4, asl #1
 2191 1204 814186E0 		add	r4, r6, r1, asl #3
 2192 1208 0C399FE5 		ldr	r3, .L228+12
 2193 120c 8D41D4E5 		ldrb	r4, [r4, #397]	@ zero_extendqisi2
 555:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2194              		.loc 1 555 0
 2195 1210 0000A0E3 		mov	r0, #0
 440:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2196              		.loc 1 440 0
 2197 1214 FF60A0E3 		mov	r6, #255
 554:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2198              		.loc 1 554 0
 2199 1218 5C40C3E5 		strb	r4, [r3, #92]
 555:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2200              		.loc 1 555 0
 2201 121c 5D00C3E5 		strb	r0, [r3, #93]
 2202              	.LVL166:
 557:../uvc.c      **** 					 break;
 2203              		.loc 1 557 0
 2204 1220 93FFFFEA 		b	.L134
 2205              	.LVL167:
 2206              	.L172:
 791:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2207              		.loc 1 791 0
 2208 1224 08499FE5 		ldr	r4, .L228+36
 2209 1228 0010E0E3 		mvn	r1, #0
 2210 122c 1C0094E5 		ldr	r0, [r4, #28]
 2211 1230 FEFFFFEB 		bl	_txe_mutex_get
 2212              	.LVL168:
 792:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2213              		.loc 1 792 0
 2214 1234 2210A0E3 		mov	r1, #34
 2215              	.L219:
 2216 1238 18C09DE5 		ldr	ip, [sp, #24]
 2217 123c 00E0A0E3 		mov	lr, #0
 2218 1240 0A30A0E1 		mov	r3, sl
 2219 1244 0920A0E1 		mov	r2, r9
 2220 1248 0400A0E1 		mov	r0, r4
 2221 124c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2222 1250 FEFFFFEB 		bl	cmdSet
 793:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2223              		.loc 1 793 0
 2224 1254 1C0094E5 		ldr	r0, [r4, #28]
 2225 1258 FEFFFFEB 		bl	_txe_mutex_put
 794:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2226              		.loc 1 794 0
 2227 125c 18109DE5 		ldr	r1, [sp, #24]
 2228 1260 877087E0 		add	r7, r7, r7, asl #1
 2229              	.LVL169:
 2230 1264 876186E0 		add	r6, r6, r7, asl #3
 795:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2231              		.loc 1 795 0
 2232 1268 0130A0E3 		mov	r3, #1
 796:../uvc.c      **** 							 break;
 2233              		.loc 1 796 0
 2234 126c FFE0A0E3 		mov	lr, #255
 795:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2235              		.loc 1 795 0
 2236 1270 1030C6E5 		strb	r3, [r6, #16]
 794:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2237              		.loc 1 794 0
 2238 1274 0D10C6E5 		strb	r1, [r6, #13]
 795:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2239              		.loc 1 795 0
 2240 1278 0130A0E1 		mov	r3, r1
 2241 127c 1CC09DE5 		ldr	ip, [sp, #28]
 796:../uvc.c      **** 							 break;
 2242              		.loc 1 796 0
 2243 1280 0E40A0E1 		mov	r4, lr
 2244 1284 82FEFFEA 		b	.L122
 2245              	.LVL170:
 2246              	.L171:
 783:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2247              		.loc 1 783 0
 2248 1288 A4489FE5 		ldr	r4, .L228+36
 2249 128c 0010E0E3 		mvn	r1, #0
 2250 1290 1C0094E5 		ldr	r0, [r4, #28]
 2251 1294 FEFFFFEB 		bl	_txe_mutex_get
 2252              	.LVL171:
 784:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2253              		.loc 1 784 0
 2254 1298 2110A0E3 		mov	r1, #33
 2255 129c E5FFFFEA 		b	.L219
 2256              	.LVL172:
 2257              	.L170:
 769:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2258              		.loc 1 769 0
 2259 12a0 8C489FE5 		ldr	r4, .L228+36
 2260 12a4 0010E0E3 		mvn	r1, #0
 2261 12a8 1C0094E5 		ldr	r0, [r4, #28]
 2262 12ac 14C08DE5 		str	ip, [sp, #20]
 2263 12b0 FEFFFFEB 		bl	_txe_mutex_get
 2264              	.LVL173:
 768:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2265              		.loc 1 768 0
 2266 12b4 18209DE5 		ldr	r2, [sp, #24]
 771:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2267              		.loc 1 771 0
 2268 12b8 00E0A0E3 		mov	lr, #0
 768:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2269              		.loc 1 768 0
 2270 12bc 7F8002E2 		and	r8, r2, #127
 2271 12c0 1C808DE5 		str	r8, [sp, #28]
 2272              	.LVL174:
 771:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2273              		.loc 1 771 0
 2274 12c4 1CC09DE5 		ldr	ip, [sp, #28]
 2275 12c8 2010A0E3 		mov	r1, #32
 2276 12cc 0920A0E1 		mov	r2, r9
 2277 12d0 0A30A0E1 		mov	r3, sl
 2278 12d4 0400A0E1 		mov	r0, r4
 2279 12d8 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2280 12dc FEFFFFEB 		bl	cmdSet
 2281              	.LVL175:
 773:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2282              		.loc 1 773 0
 2283 12e0 14C09DE5 		ldr	ip, [sp, #20]
 2284 12e4 0A30A0E1 		mov	r3, sl
 2285 12e8 0180A0E3 		mov	r8, #1
 2286 12ec 2010A0E3 		mov	r1, #32
 2287 12f0 0B20A0E1 		mov	r2, fp
 2288 12f4 0400A0E1 		mov	r0, r4
 2289 12f8 00C08DE5 		str	ip, [sp, #0]
 2290 12fc 04808DE5 		str	r8, [sp, #4]
 2291 1300 FEFFFFEB 		bl	cmdSet
 774:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2292              		.loc 1 774 0
 2293 1304 1C0094E5 		ldr	r0, [r4, #28]
 2294 1308 FEFFFFEB 		bl	_txe_mutex_put
 2295              	.LVL176:
 777:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2296              		.loc 1 777 0
 2297 130c 1C009DE5 		ldr	r0, [sp, #28]
 2298 1310 877087E0 		add	r7, r7, r7, asl #1
 2299              	.LVL177:
 2300 1314 876186E0 		add	r6, r6, r7, asl #3
 2301 1318 0D00C6E5 		strb	r0, [r6, #13]
 778:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2302              		.loc 1 778 0
 2303 131c 14C09DE5 		ldr	ip, [sp, #20]
 780:../uvc.c      **** 							 break;
 2304              		.loc 1 780 0
 2305 1320 FFE0A0E3 		mov	lr, #255
 778:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2306              		.loc 1 778 0
 2307 1324 0EC0C6E5 		strb	ip, [r6, #14]
 779:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2308              		.loc 1 779 0
 2309 1328 1080C6E5 		strb	r8, [r6, #16]
 2310 132c 18309DE5 		ldr	r3, [sp, #24]
 780:../uvc.c      **** 							 break;
 2311              		.loc 1 780 0
 2312 1330 0E40A0E1 		mov	r4, lr
 2313 1334 56FEFFEA 		b	.L122
 2314              	.LVL178:
 2315              	.L169:
 740:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2316              		.loc 1 740 0 discriminator 1
 2317 1338 000058E3 		cmp	r8, #0
 2318 133c 1800000A 		beq	.L175
 738:../uvc.c      **** 							 break;
 2319              		.loc 1 738 0
 2320 1340 28E1A0E1 		mov	lr, r8, lsr #2
 2321 1344 00005EE3 		cmp	lr, #0
 2322 1348 03005813 		cmpne	r8, #3
 2323 134c 0020A083 		movhi	r2, #0
 2324 1350 0120A093 		movls	r2, #1
 2325              	.LVL179:
 422:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2326              		.loc 1 422 0
 2327 1354 0E31A0E1 		mov	r3, lr, asl #2
 738:../uvc.c      **** 							 break;
 2328              		.loc 1 738 0
 2329 1358 E701009A 		bls	.L202
 2330 135c D4179FE5 		ldr	r1, .L228+40
 2331 1360 100081E2 		add	r0, r1, #16
 2332              	.LVL180:
 2333              	.L186:
 741:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2334              		.loc 1 741 0 discriminator 2
 2335 1364 044090E4 		ldr	r4, [r0], #4
 2336 1368 012082E2 		add	r2, r2, #1
 2337 136c FF2002E2 		and	r2, r2, #255
 2338 1370 02005EE1 		cmp	lr, r2
 2339 1374 044081E4 		str	r4, [r1], #4
 2340 1378 F9FFFF8A 		bhi	.L186
 741:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2341              		.loc 1 741 0 is_stmt 0
 2342 137c 030058E1 		cmp	r8, r3
 2343 1380 0700000A 		beq	.L175
 2344              	.LVL181:
 2345              	.L209:
 2346 1384 90C79FE5 		ldr	ip, .L228+12
 2347 1388 03E08CE0 		add	lr, ip, r3
 2348 138c 5C10DEE5 		ldrb	r1, [lr, #92]	@ zero_extendqisi2
 740:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2349              		.loc 1 740 0 is_stmt 1
 2350 1390 013083E2 		add	r3, r3, #1
 2351 1394 FF3003E2 		and	r3, r3, #255
 2352              	.LVL182:
 2353 1398 030058E1 		cmp	r8, r3
 741:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2354              		.loc 1 741 0
 2355 139c 4C10CEE5 		strb	r1, [lr, #76]
 740:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2356              		.loc 1 740 0
 2357 13a0 F7FFFF8A 		bhi	.L209
 2358              	.LVL183:
 2359              	.L175:
 743:../uvc.c      **** 					 		I2CCmdHandler();
 2360              		.loc 1 743 0
 2361 13a4 FEFFFFEB 		bl	I2CCmdHandler
 744:../uvc.c      **** 							 break;
 2362              		.loc 1 744 0
 2363 13a8 FFE0A0E3 		mov	lr, #255
 743:../uvc.c      **** 					 		I2CCmdHandler();
 2364              		.loc 1 743 0
 2365 13ac 18309DE5 		ldr	r3, [sp, #24]
 2366 13b0 1CC09DE5 		ldr	ip, [sp, #28]
 744:../uvc.c      **** 							 break;
 2367              		.loc 1 744 0
 2368 13b4 0E40A0E1 		mov	r4, lr
 2369 13b8 35FEFFEA 		b	.L122
 2370              	.LVL184:
 2371              	.L168:
 734:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2372              		.loc 1 734 0
 2373 13bc 70479FE5 		ldr	r4, .L228+36
 2374 13c0 0010E0E3 		mvn	r1, #0
 2375 13c4 1C0094E5 		ldr	r0, [r4, #28]
 2376 13c8 FEFFFFEB 		bl	_txe_mutex_get
 2377              	.LVL185:
 735:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2378              		.loc 1 735 0
 2379 13cc 18009DE5 		ldr	r0, [sp, #24]
 2380 13d0 00E0A0E3 		mov	lr, #0
 2381 13d4 01C070E2 		rsbs	ip, r0, #1
 2382 13d8 00C0A033 		movcc	ip, #0
 2383 13dc 0A30A0E1 		mov	r3, sl
 2384 13e0 1E10A0E3 		mov	r1, #30
 2385 13e4 0920A0E1 		mov	r2, r9
 2386 13e8 0400A0E1 		mov	r0, r4
 2387 13ec 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2388 13f0 FEFFFFEB 		bl	cmdSet
 736:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2389              		.loc 1 736 0
 2390 13f4 1C0094E5 		ldr	r0, [r4, #28]
 2391 13f8 FEFFFFEB 		bl	_txe_mutex_put
 737:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2392              		.loc 1 737 0
 2393 13fc 0130A0E3 		mov	r3, #1
 738:../uvc.c      **** 							 break;
 2394              		.loc 1 738 0
 2395 1400 FFE0A0E3 		mov	lr, #255
 737:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2396              		.loc 1 737 0
 2397 1404 6034C6E5 		strb	r3, [r6, #1120]
 2398 1408 1CC09DE5 		ldr	ip, [sp, #28]
 2399 140c 18309DE5 		ldr	r3, [sp, #24]
 738:../uvc.c      **** 							 break;
 2400              		.loc 1 738 0
 2401 1410 0E40A0E1 		mov	r4, lr
 2402 1414 1EFEFFEA 		b	.L122
 2403              	.LVL186:
 2404              	.L166:
 701:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2405              		.loc 1 701 0
 2406 1418 14479FE5 		ldr	r4, .L228+36
 697:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 2407              		.loc 1 697 0
 2408 141c E533C6E5 		strb	r3, [r6, #997]
 698:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2409              		.loc 1 698 0
 2410 1420 1C309DE5 		ldr	r3, [sp, #28]
 699:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2411              		.loc 1 699 0
 2412 1424 0170A0E3 		mov	r7, #1
 2413              	.LVL187:
 701:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2414              		.loc 1 701 0
 2415 1428 0010E0E3 		mvn	r1, #0
 698:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2416              		.loc 1 698 0
 2417 142c E633C6E5 		strb	r3, [r6, #998]
 701:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2418              		.loc 1 701 0
 2419 1430 1C0094E5 		ldr	r0, [r4, #28]
 699:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2420              		.loc 1 699 0
 2421 1434 E873C6E5 		strb	r7, [r6, #1000]
 2422              	.LVL188:
 701:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2423              		.loc 1 701 0
 2424 1438 FEFFFFEB 		bl	_txe_mutex_get
 2425              	.LVL189:
 702:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2426              		.loc 1 702 0
 2427 143c 18C09DE5 		ldr	ip, [sp, #24]
 2428 1440 0400A0E1 		mov	r0, r4
 2429 1444 00C08DE5 		str	ip, [sp, #0]
 2430 1448 1910A0E3 		mov	r1, #25
 2431 144c 00C0A0E3 		mov	ip, #0
 2432 1450 0920A0E1 		mov	r2, r9
 2433 1454 0A30A0E1 		mov	r3, sl
 2434 1458 04C08DE5 		str	ip, [sp, #4]
 2435 145c FEFFFFEB 		bl	cmdSet
 703:../uvc.c      **** 							 if(getData != 0){
 2436              		.loc 1 703 0
 2437 1460 18009DE5 		ldr	r0, [sp, #24]
 2438 1464 000050E3 		cmp	r0, #0
 2439 1468 0700000A 		beq	.L182
 2440              	.LVL190:
 705:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 2441              		.loc 1 705 0
 2442 146c 1CE09DE5 		ldr	lr, [sp, #28]
 2443 1470 0400A0E1 		mov	r0, r4
 2444 1474 1910A0E3 		mov	r1, #25
 2445 1478 0B20A0E1 		mov	r2, fp
 2446 147c 0A30A0E1 		mov	r3, sl
 2447 1480 00E08DE5 		str	lr, [sp, #0]
 2448 1484 04708DE5 		str	r7, [sp, #4]
 2449 1488 FEFFFFEB 		bl	cmdSet
 2450              	.LVL191:
 2451              	.L182:
 707:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2452              		.loc 1 707 0
 2453 148c 1C0094E5 		ldr	r0, [r4, #28]
 2454 1490 FEFFFFEB 		bl	_txe_mutex_put
 708:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2455              		.loc 1 708 0
 2456 1494 80069FE5 		ldr	r0, .L228+12
 2457 1498 7C169FE5 		ldr	r1, .L228+12
 2458 149c 5EC0D0E5 		ldrb	ip, [r0, #94]	@ zero_extendqisi2
 2459 14a0 5F40D1E5 		ldrb	r4, [r1, #95]	@ zero_extendqisi2
 2460 14a4 5D30D0E5 		ldrb	r3, [r0, #93]	@ zero_extendqisi2
 2461 14a8 5C20D0E5 		ldrb	r2, [r0, #92]	@ zero_extendqisi2
 2462 14ac 88169FE5 		ldr	r1, .L228+44
 2463 14b0 0400A0E3 		mov	r0, #4
 2464 14b4 00C08DE5 		str	ip, [sp, #0]
 2465 14b8 04408DE5 		str	r4, [sp, #4]
 2466 14bc FEFFFFEB 		bl	CyU3PDebugPrint
 709:../uvc.c      **** 							 break;
 2467              		.loc 1 709 0
 2468 14c0 FFE0A0E3 		mov	lr, #255
 708:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2469              		.loc 1 708 0
 2470 14c4 18309DE5 		ldr	r3, [sp, #24]
 2471 14c8 1CC09DE5 		ldr	ip, [sp, #28]
 709:../uvc.c      **** 							 break;
 2472              		.loc 1 709 0
 2473 14cc 0E40A0E1 		mov	r4, lr
 2474 14d0 EFFDFFEA 		b	.L122
 2475              	.LVL192:
 2476              	.L165:
 664:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2477              		.loc 1 664 0
 2478 14d4 001053E2 		subs	r1, r3, #0
 663:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2479              		.loc 1 663 0
 2480 14d8 0D13C6E5 		strb	r1, [r6, #781]
 2481 14dc 2C369FE5 		ldr	r3, .L228
 664:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2482              		.loc 1 664 0
 2483 14e0 3C01001A 		bne	.L176
 665:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2484              		.loc 1 665 0
 2485 14e4 B924D3E5 		ldrb	r2, [r3, #1209]	@ zero_extendqisi2
 2486              	.LVL193:
 2487 14e8 020052E3 		cmp	r2, #2
 2488 14ec 08005213 		cmpne	r2, #8
 2489 14f0 0300000A 		beq	.L177
 666:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2490              		.loc 1 666 0
 2491 14f4 010052E3 		cmp	r2, #1
 667:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 2492              		.loc 1 667 0
 2493 14f8 07208202 		addeq	r2, r2, #7
 669:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 2494              		.loc 1 669 0
 2495 14fc 0220A013 		movne	r2, #2
 2496 1500 B924C3E5 		strb	r2, [r3, #1209]
 2497              	.LVL194:
 2498              	.L177:
 691:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2499              		.loc 1 691 0
 2500 1504 28469FE5 		ldr	r4, .L228+36
 689:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2501              		.loc 1 689 0
 2502 1508 0120A0E3 		mov	r2, #1
 691:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2503              		.loc 1 691 0
 2504 150c 0010E0E3 		mvn	r1, #0
 689:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2505              		.loc 1 689 0
 2506 1510 1023C6E5 		strb	r2, [r6, #784]
 2507              	.LVL195:
 691:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2508              		.loc 1 691 0
 2509 1514 1C0094E5 		ldr	r0, [r4, #28]
 2510 1518 FEFFFFEB 		bl	_txe_mutex_get
 692:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2511              		.loc 1 692 0
 2512 151c 18C09DE5 		ldr	ip, [sp, #24]
 2513 1520 1010A0E3 		mov	r1, #16
 2514 1524 00C08DE5 		str	ip, [sp, #0]
 2515 1528 0920A0E1 		mov	r2, r9
 2516 152c 0A30A0E1 		mov	r3, sl
 2517 1530 0400A0E1 		mov	r0, r4
 2518 1534 00C0A0E3 		mov	ip, #0
 2519              	.LVL196:
 2520              	.L218:
 942:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2521              		.loc 1 942 0
 2522 1538 04C08DE5 		str	ip, [sp, #4]
 2523 153c FEFFFFEB 		bl	cmdSet
 943:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2524              		.loc 1 943 0
 2525 1540 1C0094E5 		ldr	r0, [r4, #28]
 2526 1544 FEFFFFEB 		bl	_txe_mutex_put
 945:../uvc.c      **** 					 		 break;
 2527              		.loc 1 945 0
 2528 1548 FFE0A0E3 		mov	lr, #255
 943:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2529              		.loc 1 943 0
 2530 154c 18309DE5 		ldr	r3, [sp, #24]
 2531 1550 1CC09DE5 		ldr	ip, [sp, #28]
 945:../uvc.c      **** 					 		 break;
 2532              		.loc 1 945 0
 2533 1554 0E40A0E1 		mov	r4, lr
 2534 1558 CDFDFFEA 		b	.L122
 2535              	.LVL197:
 2536              	.L167:
 712:../uvc.c      **** 							 if(Data0 <= 3){
 2537              		.loc 1 712 0
 2538 155c 030053E3 		cmp	r3, #3
 713:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2539              		.loc 1 713 0
 2540 1560 B4259F95 		ldrls	r2, .L228+12
 2541              	.LVL198:
 716:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2542              		.loc 1 716 0
 2543 1564 B0E59F85 		ldrhi	lr, .L228+12
 2544 1568 0340A0E1 		mov	r4, r3
 2545              	.LVL199:
 713:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2546              		.loc 1 713 0
 2547 156c 0030A093 		movls	r3, #0
 2548 1570 7C30C295 		strlsb	r3, [r2, #124]
 2549              	.LVL200:
 716:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2550              		.loc 1 716 0
 2551 1574 0120A083 		movhi	r2, #1
 2552 1578 18209D95 		ldrls	r2, [sp, #24]
 713:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2553              		.loc 1 713 0
 2554 157c 0430A091 		movls	r3, r4
 716:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2555              		.loc 1 716 0
 2556 1580 7C20CE85 		strhib	r2, [lr, #124]
 2557 1584 0420A081 		movhi	r2, r4
 722:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2558              		.loc 1 722 0
 2559 1588 A4459FE5 		ldr	r4, .L228+36
 717:../uvc.c      **** 								 Data1 = Data0-4;
 2560              		.loc 1 717 0
 2561 158c 04304382 		subhi	r3, r3, #4
 2562              	.LVL201:
 719:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2563              		.loc 1 719 0
 2564 1590 2D24C6E5 		strb	r2, [r6, #1069]
 721:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2565              		.loc 1 721 0
 2566 1594 0120A0E3 		mov	r2, #1
 722:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2567              		.loc 1 722 0
 2568 1598 0010E0E3 		mvn	r1, #0
 720:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 2569              		.loc 1 720 0
 2570 159c 8D31C6E5 		strb	r3, [r6, #397]
 721:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2571              		.loc 1 721 0
 2572 15a0 3024C6E5 		strb	r2, [r6, #1072]
 722:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2573              		.loc 1 722 0
 2574 15a4 1C0094E5 		ldr	r0, [r4, #28]
 2575 15a8 FEFFFFEB 		bl	_txe_mutex_get
 2576              	.LVL202:
 723:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2577              		.loc 1 723 0
 2578 15ac 18C09DE5 		ldr	ip, [sp, #24]
 2579 15b0 1C10A0E3 		mov	r1, #28
 2580 15b4 00C08DE5 		str	ip, [sp, #0]
 2581 15b8 0920A0E1 		mov	r2, r9
 2582 15bc 0A30A0E1 		mov	r3, sl
 2583 15c0 0400A0E1 		mov	r0, r4
 2584 15c4 00C0A0E3 		mov	ip, #0
 2585 15c8 DAFFFFEA 		b	.L218
 2586              	.LVL203:
 2587              	.L164:
 873:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2588              		.loc 1 873 0
 2589 15cc 60459FE5 		ldr	r4, .L228+36
 2590 15d0 0010E0E3 		mvn	r1, #0
 2591 15d4 1C0094E5 		ldr	r0, [r4, #28]
 2592 15d8 FEFFFFEB 		bl	_txe_mutex_get
 2593              	.LVL204:
 874:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2594              		.loc 1 874 0
 2595 15dc 18C09DE5 		ldr	ip, [sp, #24]
 2596 15e0 0B10A0E3 		mov	r1, #11
 2597 15e4 0920A0E1 		mov	r2, r9
 2598 15e8 0A30A0E1 		mov	r3, sl
 2599 15ec 0400A0E1 		mov	r0, r4
 2600 15f0 00C08DE5 		str	ip, [sp, #0]
 2601 15f4 00C0A0E3 		mov	ip, #0
 2602 15f8 04C08DE5 		str	ip, [sp, #4]
 2603 15fc FEFFFFEB 		bl	cmdSet
 2604              	.LVL205:
 876:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 2605              		.loc 1 876 0
 2606 1600 1CE09DE5 		ldr	lr, [sp, #28]
 2607 1604 0B10A0E3 		mov	r1, #11
 2608 1608 0B20A0E1 		mov	r2, fp
 2609 160c 0A30A0E1 		mov	r3, sl
 2610 1610 0170A0E3 		mov	r7, #1
 2611              	.LVL206:
 2612 1614 0400A0E1 		mov	r0, r4
 2613 1618 00E08DE5 		str	lr, [sp, #0]
 2614 161c 04708DE5 		str	r7, [sp, #4]
 2615 1620 FEFFFFEB 		bl	cmdSet
 877:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2616              		.loc 1 877 0
 2617 1624 1C0094E5 		ldr	r0, [r4, #28]
 2618 1628 FEFFFFEB 		bl	_txe_mutex_put
 879:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2619              		.loc 1 879 0
 2620 162c 18109DE5 		ldr	r1, [sp, #24]
 880:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2621              		.loc 1 880 0
 2622 1630 1C209DE5 		ldr	r2, [sp, #28]
 882:../uvc.c      **** 							 break;
 2623              		.loc 1 882 0
 2624 1634 FFE0A0E3 		mov	lr, #255
 879:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2625              		.loc 1 879 0
 2626 1638 9014C6E5 		strb	r1, [r6, #1168]
 880:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2627              		.loc 1 880 0
 2628 163c 9224C6E5 		strb	r2, [r6, #1170]
 881:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2629              		.loc 1 881 0
 2630 1640 9872C6E5 		strb	r7, [r6, #664]
 2631 1644 0130A0E1 		mov	r3, r1
 2632 1648 02C0A0E1 		mov	ip, r2
 882:../uvc.c      **** 							 break;
 2633              		.loc 1 882 0
 2634 164c 0E40A0E1 		mov	r4, lr
 2635 1650 8FFDFFEA 		b	.L122
 2636              	.LVL207:
 2637              	.L163:
 859:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2638              		.loc 1 859 0
 2639 1654 D8449FE5 		ldr	r4, .L228+36
 2640 1658 0010E0E3 		mvn	r1, #0
 2641 165c 1C0094E5 		ldr	r0, [r4, #28]
 2642 1660 FEFFFFEB 		bl	_txe_mutex_get
 2643              	.LVL208:
 860:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2644              		.loc 1 860 0
 2645 1664 18C09DE5 		ldr	ip, [sp, #24]
 2646 1668 00E0A0E3 		mov	lr, #0
 2647 166c 0610A0E3 		mov	r1, #6
 2648 1670 0920A0E1 		mov	r2, r9
 2649 1674 0A30A0E1 		mov	r3, sl
 2650 1678 0400A0E1 		mov	r0, r4
 2651 167c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2652 1680 FEFFFFEB 		bl	cmdSet
 2653              	.LVL209:
 862:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 2654              		.loc 1 862 0
 2655 1684 18C09DE5 		ldr	ip, [sp, #24]
 2656 1688 0A30A0E1 		mov	r3, sl
 2657 168c 0170A0E3 		mov	r7, #1
 2658              	.LVL210:
 2659 1690 0610A0E3 		mov	r1, #6
 2660 1694 0B20A0E1 		mov	r2, fp
 2661 1698 0400A0E1 		mov	r0, r4
 2662 169c 00C08DE5 		str	ip, [sp, #0]
 2663 16a0 04708DE5 		str	r7, [sp, #4]
 2664 16a4 FEFFFFEB 		bl	cmdSet
 863:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2665              		.loc 1 863 0
 2666 16a8 1C0094E5 		ldr	r0, [r4, #28]
 2667 16ac FEFFFFEB 		bl	_txe_mutex_put
 864:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2668              		.loc 1 864 0
 2669 16b0 18409DE5 		ldr	r4, [sp, #24]
 866:../uvc.c      **** 							 break;
 2670              		.loc 1 866 0
 2671 16b4 FFE0A0E3 		mov	lr, #255
 864:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2672              		.loc 1 864 0
 2673 16b8 1D42C6E5 		strb	r4, [r6, #541]
 865:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2674              		.loc 1 865 0
 2675 16bc 0430A0E1 		mov	r3, r4
 2676 16c0 2072C6E5 		strb	r7, [r6, #544]
 2677 16c4 1CC09DE5 		ldr	ip, [sp, #28]
 866:../uvc.c      **** 							 break;
 2678              		.loc 1 866 0
 2679 16c8 0E40A0E1 		mov	r4, lr
 2680 16cc 70FDFFEA 		b	.L122
 2681              	.LVL211:
 2682              	.L162:
 839:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2683              		.loc 1 839 0
 2684 16d0 5C449FE5 		ldr	r4, .L228+36
 2685 16d4 0010E0E3 		mvn	r1, #0
 2686 16d8 1C0094E5 		ldr	r0, [r4, #28]
 2687 16dc FEFFFFEB 		bl	_txe_mutex_get
 2688              	.LVL212:
 840:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2689              		.loc 1 840 0
 2690 16e0 18009DE5 		ldr	r0, [sp, #24]
 2691 16e4 00C0A0E3 		mov	ip, #0
 2692 16e8 803040E2 		sub	r3, r0, #128
 2693 16ec FF7003E2 		and	r7, r3, #255
 2694              	.LVL213:
 2695 16f0 0510A0E3 		mov	r1, #5
 2696 16f4 0920A0E1 		mov	r2, r9
 2697 16f8 0A30A0E1 		mov	r3, sl
 2698 16fc 0400A0E1 		mov	r0, r4
 2699 1700 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2700 1704 FEFFFFEB 		bl	cmdSet
 2701              	.LVL214:
 842:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 2702              		.loc 1 842 0
 2703 1708 18109DE5 		ldr	r1, [sp, #24]
 2704 170c DC20A0E3 		mov	r2, #220
 2705 1710 767041E2 		sub	r7, r1, #118
 2706 1714 FFE007E2 		and	lr, r7, #255
 2707 1718 0510A0E3 		mov	r1, #5
 2708 171c 0170A0E3 		mov	r7, #1
 2709 1720 0A30A0E1 		mov	r3, sl
 2710 1724 0400A0E1 		mov	r0, r4
 2711 1728 00E08DE5 		str	lr, [sp, #0]
 2712 172c 04708DE5 		str	r7, [sp, #4]
 2713 1730 FEFFFFEB 		bl	cmdSet
 2714              	.LVL215:
 844:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 2715              		.loc 1 844 0
 2716 1734 18209DE5 		ldr	r2, [sp, #24]
 2717 1738 0510A0E3 		mov	r1, #5
 2718 173c 7E0082E2 		add	r0, r2, #126
 2719 1740 FFC000E2 		and	ip, r0, #255
 2720 1744 DE20A0E3 		mov	r2, #222
 2721 1748 0A30A0E1 		mov	r3, sl
 2722 174c 0400A0E1 		mov	r0, r4
 2723 1750 00C08DE5 		str	ip, [sp, #0]
 2724 1754 02C0A0E3 		mov	ip, #2
 2725 1758 04C08DE5 		str	ip, [sp, #4]
 2726 175c FEFFFFEB 		bl	cmdSet
 2727              	.LVL216:
 846:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 2728              		.loc 1 846 0
 2729 1760 18309DE5 		ldr	r3, [sp, #24]
 2730 1764 E020A0E3 		mov	r2, #224
 2731 1768 721083E2 		add	r1, r3, #114
 2732 176c FFC001E2 		and	ip, r1, #255
 2733 1770 0A30A0E1 		mov	r3, sl
 2734 1774 0510A0E3 		mov	r1, #5
 2735 1778 0400A0E1 		mov	r0, r4
 2736 177c 00C08DE5 		str	ip, [sp, #0]
 2737 1780 03C0A0E3 		mov	ip, #3
 2738 1784 04C08DE5 		str	ip, [sp, #4]
 2739 1788 FEFFFFEB 		bl	cmdSet
 2740              	.LVL217:
 848:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 2741              		.loc 1 848 0
 2742 178c 18209DE5 		ldr	r2, [sp, #24]
 2743 1790 0510A0E3 		mov	r1, #5
 2744 1794 6F0042E2 		sub	r0, r2, #111
 2745 1798 FFC000E2 		and	ip, r0, #255
 2746 179c DD20A0E3 		mov	r2, #221
 2747 17a0 0A30A0E1 		mov	r3, sl
 2748 17a4 0400A0E1 		mov	r0, r4
 2749 17a8 00C08DE5 		str	ip, [sp, #0]
 2750 17ac 04C0A0E3 		mov	ip, #4
 2751 17b0 04C08DE5 		str	ip, [sp, #4]
 2752 17b4 FEFFFFEB 		bl	cmdSet
 2753              	.LVL218:
 850:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 2754              		.loc 1 850 0
 2755 17b8 5C339FE5 		ldr	r3, .L228+12
 2756 17bc 05E0A0E3 		mov	lr, #5
 2757 17c0 5C10D3E5 		ldrb	r1, [r3, #92]	@ zero_extendqisi2
 2758 17c4 0400A0E1 		mov	r0, r4
 2759 17c8 7F2081E2 		add	r2, r1, #127
 2760 17cc FFC002E2 		and	ip, r2, #255
 2761 17d0 0E10A0E1 		mov	r1, lr
 2762 17d4 0A30A0E1 		mov	r3, sl
 2763 17d8 0B20A0E1 		mov	r2, fp
 2764 17dc 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2765 17e0 FEFFFFEB 		bl	cmdSet
 851:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2766              		.loc 1 851 0
 2767 17e4 1C0094E5 		ldr	r0, [r4, #28]
 2768 17e8 FEFFFFEB 		bl	_txe_mutex_put
 853:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2769              		.loc 1 853 0
 2770 17ec 28039FE5 		ldr	r0, .L228+12
 855:../uvc.c      **** 							 break;
 2771              		.loc 1 855 0
 2772 17f0 FFE0A0E3 		mov	lr, #255
 853:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2773              		.loc 1 853 0
 2774 17f4 5C30D0E5 		ldrb	r3, [r0, #92]	@ zero_extendqisi2
 854:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2775              		.loc 1 854 0
 2776 17f8 0872C6E5 		strb	r7, [r6, #520]
 853:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2777              		.loc 1 853 0
 2778 17fc 801043E2 		sub	r1, r3, #128
 2779 1800 0512C6E5 		strb	r1, [r6, #517]
 854:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2780              		.loc 1 854 0
 2781 1804 18309DE5 		ldr	r3, [sp, #24]
 2782 1808 1CC09DE5 		ldr	ip, [sp, #28]
 855:../uvc.c      **** 							 break;
 2783              		.loc 1 855 0
 2784 180c 0E40A0E1 		mov	r4, lr
 2785 1810 1FFDFFEA 		b	.L122
 2786              	.LVL219:
 2787              	.L161:
 886:../uvc.c      **** 							 Data0 = Data0 - 1;
 2788              		.loc 1 886 0
 2789 1814 011043E2 		sub	r1, r3, #1
 2790 1818 0300A0E1 		mov	r0, r3
 2791              	.LVL220:
 887:../uvc.c      **** 							 is60Hz = Data0;
 2792              		.loc 1 887 0
 2793 181c F8229FE5 		ldr	r2, .L228+12
 2794              	.LVL221:
 886:../uvc.c      **** 							 Data0 = Data0 - 1;
 2795              		.loc 1 886 0
 2796 1820 FF3001E2 		and	r3, r1, #255
 2797              	.LVL222:
 899:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 2798              		.loc 1 899 0
 2799 1824 F0E29FE5 		ldr	lr, .L228+12
 893:../uvc.c      **** 							 else if(Data0 >2)
 2800              		.loc 1 893 0
 2801 1828 020053E3 		cmp	r3, #2
 885:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2802              		.loc 1 885 0
 2803 182c ED01C6E5 		strb	r0, [r6, #493]
 896:../uvc.c      **** 								 is60Hz = CyTrue;
 2804              		.loc 1 896 0
 2805 1830 0100A083 		movhi	r0, #1
 887:../uvc.c      **** 							 is60Hz = Data0;
 2806              		.loc 1 887 0
 2807 1834 583082E5 		str	r3, [r2, #88]
 2808              	.LVL223:
 896:../uvc.c      **** 								 is60Hz = CyTrue;
 2809              		.loc 1 896 0
 2810 1838 58008285 		strhi	r0, [r2, #88]
 899:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 2811              		.loc 1 899 0
 2812 183c 28009EE5 		ldr	r0, [lr, #40]
 2813 1840 010050E3 		cmp	r0, #1
 2814 1844 8200000A 		beq	.L226
 2815              	.LVL224:
 2816              	.L192:
 925:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2817              		.loc 1 925 0
 2818 1848 01C0A0E3 		mov	ip, #1
 926:../uvc.c      **** 							 break;
 2819              		.loc 1 926 0
 2820 184c FFE0A0E3 		mov	lr, #255
 925:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2821              		.loc 1 925 0
 2822 1850 F0C1C6E5 		strb	ip, [r6, #496]
 2823 1854 18309DE5 		ldr	r3, [sp, #24]
 2824 1858 1CC09DE5 		ldr	ip, [sp, #28]
 926:../uvc.c      **** 							 break;
 2825              		.loc 1 926 0
 2826 185c 0E40A0E1 		mov	r4, lr
 2827 1860 0BFDFFEA 		b	.L122
 2828              	.LVL225:
 2829              	.L160:
 821:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2830              		.loc 1 821 0
 2831 1864 C8429FE5 		ldr	r4, .L228+36
 2832 1868 0010E0E3 		mvn	r1, #0
 2833 186c 1C0094E5 		ldr	r0, [r4, #28]
 2834 1870 FEFFFFEB 		bl	_txe_mutex_get
 2835              	.LVL226:
 823:../uvc.c      **** 							  if(Data0&0x80){
 2836              		.loc 1 823 0
 2837 1874 18209DE5 		ldr	r2, [sp, #24]
 828:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2838              		.loc 1 828 0
 2839 1878 00C0A0E3 		mov	ip, #0
 823:../uvc.c      **** 							  if(Data0&0x80){
 2840              		.loc 1 823 0
 2841 187c 800012E3 		tst	r2, #128
 824:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 2842              		.loc 1 824 0
 2843 1880 80704212 		subne	r7, r2, #128
 2844              	.LVL227:
 826:../uvc.c      **** 								  Data0 = ~Data0;
 2845              		.loc 1 826 0
 2846 1884 0270E001 		mvneq	r7, r2
 828:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2847              		.loc 1 828 0
 2848 1888 0A30A0E1 		mov	r3, sl
 826:../uvc.c      **** 								  Data0 = ~Data0;
 2849              		.loc 1 826 0
 2850 188c FF7007E2 		and	r7, r7, #255
 2851              	.LVL228:
 828:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2852              		.loc 1 828 0
 2853 1890 0110A0E3 		mov	r1, #1
 2854 1894 0B20A0E1 		mov	r2, fp
 2855 1898 94029FE5 		ldr	r0, .L228+36
 2856 189c 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2857 18a0 FEFFFFEB 		bl	cmdSet
 829:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2858              		.loc 1 829 0
 2859 18a4 1C0094E5 		ldr	r0, [r4, #28]
 2860 18a8 FEFFFFEB 		bl	_txe_mutex_put
 835:../uvc.c      **** 							 break;
 2861              		.loc 1 835 0
 2862 18ac FFE0A0E3 		mov	lr, #255
 832:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2863              		.loc 1 832 0
 2864 18b0 0100A0E3 		mov	r0, #1
 831:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2865              		.loc 1 831 0
 2866 18b4 A571C6E5 		strb	r7, [r6, #421]
 832:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2867              		.loc 1 832 0
 2868 18b8 A801C6E5 		strb	r0, [r6, #424]
 2869 18bc 18309DE5 		ldr	r3, [sp, #24]
 2870 18c0 1CC09DE5 		ldr	ip, [sp, #28]
 835:../uvc.c      **** 							 break;
 2871              		.loc 1 835 0
 2872 18c4 0E40A0E1 		mov	r4, lr
 2873 18c8 F1FCFFEA 		b	.L122
 2874              	.LVL229:
 2875              	.L158:
 949:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2876              		.loc 1 949 0
 2877 18cc 60729FE5 		ldr	r7, .L228+36
 2878              	.LVL230:
 2879 18d0 0010E0E3 		mvn	r1, #0
 2880 18d4 1C0097E5 		ldr	r0, [r7, #28]
 2881 18d8 FEFFFFEB 		bl	_txe_mutex_get
 2882              	.LVL231:
 950:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2883              		.loc 1 950 0
 2884 18dc 18C09DE5 		ldr	ip, [sp, #24]
 2885 18e0 0410A0E1 		mov	r1, r4
 2886 18e4 0A30A0E1 		mov	r3, sl
 2887 18e8 0920A0E1 		mov	r2, r9
 2888 18ec 00C08DE5 		str	ip, [sp, #0]
 2889 18f0 0700A0E1 		mov	r0, r7
 2890 18f4 00C0A0E3 		mov	ip, #0
 2891 18f8 04C08DE5 		str	ip, [sp, #4]
 2892 18fc FEFFFFEB 		bl	cmdSet
 951:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2893              		.loc 1 951 0
 2894 1900 1C0097E5 		ldr	r0, [r7, #28]
 2895 1904 FEFFFFEB 		bl	_txe_mutex_put
 953:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2896              		.loc 1 953 0
 2897 1908 18109DE5 		ldr	r1, [sp, #24]
 2898 190c 844084E0 		add	r4, r4, r4, asl #1
 2899 1910 846186E0 		add	r6, r6, r4, asl #3
 954:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2900              		.loc 1 954 0
 2901 1914 0130A0E3 		mov	r3, #1
 955:../uvc.c      **** 							 break;
 2902              		.loc 1 955 0
 2903 1918 FFE0A0E3 		mov	lr, #255
 954:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2904              		.loc 1 954 0
 2905 191c 9031C6E5 		strb	r3, [r6, #400]
 953:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2906              		.loc 1 953 0
 2907 1920 8D11C6E5 		strb	r1, [r6, #397]
 954:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2908              		.loc 1 954 0
 2909 1924 0130A0E1 		mov	r3, r1
 2910 1928 1CC09DE5 		ldr	ip, [sp, #28]
 955:../uvc.c      **** 							 break;
 2911              		.loc 1 955 0
 2912 192c 0E40A0E1 		mov	r4, lr
 2913 1930 D7FCFFEA 		b	.L122
 2914              	.LVL232:
 2915              	.L159:
 930:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2916              		.loc 1 930 0
 2917 1934 E0219FE5 		ldr	r2, .L228+12
 2918              	.LVL233:
 929:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2919              		.loc 1 929 0
 2920 1938 0100A0E3 		mov	r0, #1
 930:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2921              		.loc 1 930 0
 2922 193c 7C20D2E5 		ldrb	r2, [r2, #124]	@ zero_extendqisi2
 928:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2923              		.loc 1 928 0
 2924 1940 8D31C6E5 		strb	r3, [r6, #397]
 930:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2925              		.loc 1 930 0
 2926 1944 010052E3 		cmp	r2, #1
 929:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2927              		.loc 1 929 0
 2928 1948 9001C6E5 		strb	r0, [r6, #400]
 2929 194c 0370A011 		movne	r7, r3
 2930              	.LVL234:
 930:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2931              		.loc 1 930 0
 2932 1950 3500000A 		beq	.L227
 2933              	.LVL235:
 2934              	.L199:
 941:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2935              		.loc 1 941 0
 2936 1954 D8419FE5 		ldr	r4, .L228+36
 2937 1958 0010E0E3 		mvn	r1, #0
 2938 195c 1C0094E5 		ldr	r0, [r4, #28]
 939:../uvc.c      **** 							 CtrlParArry[CamModeIndex][13] = Data0;
 2939              		.loc 1 939 0
 2940 1960 2D74C6E5 		strb	r7, [r6, #1069]
 2941              	.LVL236:
 941:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2942              		.loc 1 941 0
 2943 1964 FEFFFFEB 		bl	_txe_mutex_get
 942:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2944              		.loc 1 942 0
 2945 1968 00C0A0E3 		mov	ip, #0
 2946 196c 0C10A0E1 		mov	r1, ip
 2947 1970 0920A0E1 		mov	r2, r9
 2948 1974 0A30A0E1 		mov	r3, sl
 2949 1978 0400A0E1 		mov	r0, r4
 2950 197c 00708DE5 		str	r7, [sp, #0]
 2951 1980 ECFEFFEA 		b	.L218
 2952              	.LVL237:
 2953              	.L157:
 958:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 2954              		.loc 1 958 0
 2955 1984 0400A0E3 		mov	r0, #4
 2956              	.LVL238:
 2957 1988 B0119FE5 		ldr	r1, .L228+48
 2958 198c FEFFFFEB 		bl	CyU3PDebugPrint
 2959              	.LVL239:
 2960 1990 FFE0A0E3 		mov	lr, #255
 2961 1994 0E40A0E1 		mov	r4, lr
 2962 1998 0EC0A0E1 		mov	ip, lr
 2963 199c 0E30A0E1 		mov	r3, lr
 2964 19a0 BBFCFFEA 		b	.L122
 2965              	.LVL240:
 2966              	.L225:
 478:../uvc.c      **** 						if(sendData >= 3){
 2967              		.loc 1 478 0
 2968 19a4 020054E3 		cmp	r4, #2
 2969 19a8 04408492 		addls	r4, r4, #4
 2970              	.LVL241:
 2971 19ac FF400492 		andls	r4, r4, #255
 2972 19b0 E2FDFF9A 		bls	.L135
 479:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 2973              		.loc 1 479 0
 2974 19b4 0430A0E1 		mov	r3, r4
 2975 19b8 0400A0E3 		mov	r0, #4
 2976 19bc 80119FE5 		ldr	r1, .L228+52
 2977 19c0 FEFFFFEB 		bl	CyU3PDebugPrint
 2978              	.LVL242:
 481:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 2979              		.loc 1 481 0
 2980 19c4 44319FE5 		ldr	r3, .L228
 2981 19c8 0020A0E3 		mov	r2, #0
 2982 19cc 0440A0E3 		mov	r4, #4
 2983 19d0 2D24C3E5 		strb	r2, [r3, #1069]
 2984              	.LVL243:
 2985 19d4 D9FDFFEA 		b	.L135
 2986              	.LVL244:
 2987              	.L176:
 674:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2988              		.loc 1 674 0
 2989 19d8 B924D3E5 		ldrb	r2, [r3, #1209]	@ zero_extendqisi2
 2990              	.LVL245:
 673:../uvc.c      **** 								 Data1 = Data0 - 1;
 2991              		.loc 1 673 0
 2992 19dc 014041E2 		sub	r4, r1, #1
 674:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2993              		.loc 1 674 0
 2994 19e0 040052E3 		cmp	r2, #4
 2995 19e4 01005213 		cmpne	r2, #1
 673:../uvc.c      **** 								 Data1 = Data0 - 1;
 2996              		.loc 1 673 0
 2997 19e8 FF1004E2 		and	r1, r4, #255
 2998              	.LVL246:
 674:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2999              		.loc 1 674 0
 3000 19ec 0300000A 		beq	.L179
 675:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 3001              		.loc 1 675 0
 3002 19f0 080052E3 		cmp	r2, #8
 676:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 3003              		.loc 1 676 0
 3004 19f4 0120A003 		moveq	r2, #1
 678:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 3005              		.loc 1 678 0
 3006 19f8 0420A013 		movne	r2, #4
 3007 19fc B924C3E5 		strb	r2, [r3, #1209]
 3008              	.L179:
 681:../uvc.c      **** 								 if(Data1 < 8){
 3009              		.loc 1 681 0
 3010 1a00 070051E3 		cmp	r1, #7
 682:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 3011              		.loc 1 682 0
 3012 1a04 3C319F95 		ldrls	r3, .L228+56
 685:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 3013              		.loc 1 685 0
 3014 1a08 0130A083 		movhi	r3, #1
 683:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 3015              		.loc 1 683 0
 3016 1a0c 81008390 		addls	r0, r3, r1, asl #1
 682:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 3017              		.loc 1 682 0
 3018 1a10 8120D397 		ldrlsb	r2, [r3, r1, asl #1]	@ zero_extendqisi2
 683:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 3019              		.loc 1 683 0
 3020 1a14 0130D095 		ldrlsb	r3, [r0, #1]	@ zero_extendqisi2
 685:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 3021              		.loc 1 685 0
 3022 1a18 E934C685 		strhib	r3, [r6, #1257]
 686:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 3023              		.loc 1 686 0
 3024 1a1c 0030A083 		movhi	r3, #0
 682:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 3025              		.loc 1 682 0
 3026 1a20 E924C695 		strlsb	r2, [r6, #1257]
 686:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 3027              		.loc 1 686 0
 3028 1a24 EA34C6E5 		strb	r3, [r6, #1258]
 3029 1a28 B5FEFFEA 		b	.L177
 3030              	.LVL247:
 3031              	.L227:
 932:../uvc.c      **** 								 if(Data0 < 3){
 3032              		.loc 1 932 0
 3033 1a2c 020053E3 		cmp	r3, #2
 933:../uvc.c      **** 					 				 Data0 += 4;
 3034              		.loc 1 933 0
 3035 1a30 04708392 		addls	r7, r3, #4
 3036 1a34 FF700792 		andls	r7, r7, #255
 932:../uvc.c      **** 								 if(Data0 < 3){
 3037              		.loc 1 932 0
 3038 1a38 C5FFFF9A 		bls	.L199
 935:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 3039              		.loc 1 935 0
 3040 1a3c 0400A0E3 		mov	r0, #4
 3041 1a40 FC109FE5 		ldr	r1, .L228+52
 3042 1a44 18309DE5 		ldr	r3, [sp, #24]
 3043 1a48 FEFFFFEB 		bl	CyU3PDebugPrint
 3044              	.LVL248:
 936:../uvc.c      **** 									Data0 = 4; //set to default.
 3045              		.loc 1 936 0
 3046 1a4c 0470A0E3 		mov	r7, #4
 3047 1a50 BFFFFFEA 		b	.L199
 3048              	.LVL249:
 3049              	.L226:
 902:../uvc.c      **** 			                       switch (setRes)
 3050              		.loc 1 902 0
 3051 1a54 7D10DEE5 		ldrb	r1, [lr, #125]	@ zero_extendqisi2
 3052 1a58 020051E3 		cmp	r1, #2
 3053 1a5c 1C00000A 		beq	.L194
 3054 1a60 030051E3 		cmp	r1, #3
 3055 1a64 0E00000A 		beq	.L195
 3056 1a68 010051E3 		cmp	r1, #1
 3057 1a6c 75FFFF1A 		bne	.L192
 905:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 3058              		.loc 1 905 0
 3059 1a70 58209EE5 		ldr	r2, [lr, #88]
 3060 1a74 0100A0E1 		mov	r0, r1
 3061 1a78 000052E3 		cmp	r2, #0
 3062 1a7c 2F1081E2 		add	r1, r1, #47
 3063 1a80 E420A003 		moveq	r2, #228
 3064 1a84 6420A013 		movne	r2, #100
 3065 1a88 5230A0E3 		mov	r3, #82
 3066 1a8c FEFFFFEB 		bl	SensorSetIrisControl
 3067              	.LVL250:
 906:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3068              		.loc 1 906 0
 3069 1a90 7D0FA0E3 		mov	r0, #500
 3070 1a94 FEFFFFEB 		bl	_tx_thread_sleep
 908:../uvc.c      **** 			                         		break;
 3071              		.loc 1 908 0
 3072 1a98 6AFFFFEA 		b	.L192
 3073              	.LVL251:
 3074              	.L216:
 3075 1a9c 78009FE5 		ldr	r0, .L228+12
 3076 1aa0 95FDFFEA 		b	.L133
 3077              	.LVL252:
 3078              	.L195:
 915:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
 3079              		.loc 1 915 0
 3080 1aa4 58409EE5 		ldr	r4, [lr, #88]
 3081 1aa8 8CE4D6E5 		ldrb	lr, [r6, #1164]	@ zero_extendqisi2
 3082 1aac 000054E3 		cmp	r4, #0
 3083 1ab0 C440A003 		moveq	r4, #196
 3084 1ab4 4440A013 		movne	r4, #68
 3085 1ab8 3010A0E3 		mov	r1, #48
 3086 1abc 0E2084E1 		orr	r2, r4, lr
 3087 1ac0 5230A0E3 		mov	r3, #82
 3088 1ac4 FEFFFFEB 		bl	SensorSetIrisControl
 3089              	.LVL253:
 916:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3090              		.loc 1 916 0
 3091 1ac8 7D0FA0E3 		mov	r0, #500
 3092 1acc FEFFFFEB 		bl	_tx_thread_sleep
 918:../uvc.c      **** 			                         		break;
 3093              		.loc 1 918 0
 3094 1ad0 5CFFFFEA 		b	.L192
 3095              	.LVL254:
 3096              	.L194:
 910:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 3097              		.loc 1 910 0
 3098 1ad4 58209EE5 		ldr	r2, [lr, #88]
 3099 1ad8 3010A0E3 		mov	r1, #48
 3100 1adc 000052E3 		cmp	r2, #0
 3101 1ae0 D420A003 		moveq	r2, #212
 3102 1ae4 5420A013 		movne	r2, #84
 3103 1ae8 5230A0E3 		mov	r3, #82
 3104 1aec FEFFFFEB 		bl	SensorSetIrisControl
 3105              	.LVL255:
 911:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3106              		.loc 1 911 0
 3107 1af0 7D0FA0E3 		mov	r0, #500
 3108 1af4 FEFFFFEB 		bl	_tx_thread_sleep
 913:../uvc.c      **** 			                         		break;
 3109              		.loc 1 913 0
 3110 1af8 52FFFFEA 		b	.L192
 3111              	.LVL256:
 3112              	.L202:
 422:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 3113              		.loc 1 422 0
 3114 1afc 0030A0E3 		mov	r3, #0
 3115 1b00 1FFEFFEA 		b	.L209
 3116              	.LVL257:
 3117              	.L201:
 3118 1b04 10009FE5 		ldr	r0, .L228+12
 3119 1b08 0030A0E3 		mov	r3, #0
 3120 1b0c 73FDFFEA 		b	.L208
 3121              	.L229:
 3122              		.align	2
 3123              	.L228:
 3124 1b10 00000000 		.word	.LANCHOR1
 3125 1b14 00000000 		.word	bRequest
 3126 1b18 70030000 		.word	.LC21
 3127 1b1c 00000000 		.word	.LANCHOR0
 3128 1b20 5C000000 		.word	.LANCHOR0+92
 3129 1b24 01000100 		.word	65537
 3130 1b28 FF00FF00 		.word	16711935
 3131 1b2c B0020000 		.word	.LC17
 3132 1b30 EC020000 		.word	.LC18
 3133 1b34 00000000 		.word	cmdQu
 3134 1b38 4C000000 		.word	.LANCHOR0+76
 3135 1b3c 14030000 		.word	.LC19
 3136 1b40 40030000 		.word	.LC20
 3137 1b44 78020000 		.word	.LC16
 3138 1b48 00000000 		.word	.LANCHOR2
 3139              		.cfi_endproc
 3140              	.LFE2:
 3142              		.align	2
 3143              		.global	CTControlHandle
 3145              	CTControlHandle:
 3146              	.LFB3:
 974:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3147              		.loc 1 974 0
 3148              		.cfi_startproc
 3149              		@ args = 0, pretend = 0, frame = 64
 3150              		@ frame_needed = 0, uses_anonymous_args = 0
 3151              	.LVL258:
 3152 1b4c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3153              	.LCFI15:
 3154              		.cfi_def_cfa_offset 36
 993:../uvc.c      ****     reqData = bRequest;
 3155              		.loc 1 993 0
 3156 1b50 60A99FE5 		ldr	sl, .L315
 3157              		.cfi_offset 14, -4
 3158              		.cfi_offset 11, -8
 3159              		.cfi_offset 10, -12
 3160              		.cfi_offset 9, -16
 3161              		.cfi_offset 8, -20
 3162              		.cfi_offset 7, -24
 3163              		.cfi_offset 6, -28
 3164              		.cfi_offset 5, -32
 3165              		.cfi_offset 4, -36
 985:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3166              		.loc 1 985 0
 3167 1b54 60899FE5 		ldr	r8, .L315+4
 993:../uvc.c      ****     reqData = bRequest;
 3168              		.loc 1 993 0
 3169 1b58 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
 985:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3170              		.loc 1 985 0
 3171 1b5c 8090A0E1 		mov	r9, r0, asl #1
 3172 1b60 002089E0 		add	r2, r9, r0
 3173 1b64 822188E0 		add	r2, r8, r2, asl #3
 995:../uvc.c      ****     switch (bRequest)
 3174              		.loc 1 995 0
 3175 1b68 830055E3 		cmp	r5, #131
 974:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3176              		.loc 1 974 0
 3177 1b6c 5CD04DE2 		sub	sp, sp, #92
 3178              	.LCFI16:
 3179              		.cfi_def_cfa_offset 128
 974:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3180              		.loc 1 974 0
 3181 1b70 0060A0E1 		mov	r6, r0
 985:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3182              		.loc 1 985 0
 3183 1b74 A334D2E5 		ldrb	r3, [r2, #1187]	@ zero_extendqisi2
 3184              	.LVL259:
 986:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3185              		.loc 1 986 0
 3186 1b78 94B4D2E5 		ldrb	fp, [r2, #1172]	@ zero_extendqisi2
 3187              	.LVL260:
 988:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 3188              		.loc 1 988 0
 3189 1b7c 9674D2E5 		ldrb	r7, [r2, #1174]	@ zero_extendqisi2
 3190              	.LVL261:
 995:../uvc.c      ****     switch (bRequest)
 3191              		.loc 1 995 0
 3192 1b80 7600000A 		beq	.L235
 3193 1b84 2100009A 		bls	.L310
 3194 1b88 850055E3 		cmp	r5, #133
 3195 1b8c 5900000A 		beq	.L237
 3196 1b90 4E00003A 		bcc	.L236
 3197 1b94 860055E3 		cmp	r5, #134
 3198 1b98 8000000A 		beq	.L238
 3199 1b9c 870055E3 		cmp	r5, #135
 3200 1ba0 7600000A 		beq	.L311
 3201              	.L231:
1202:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 3202              		.loc 1 1202 0
 3203 1ba4 0000A0E3 		mov	r0, #0
 3204              	.LVL262:
 3205 1ba8 0110A0E3 		mov	r1, #1
 3206 1bac 0020A0E1 		mov	r2, r0
 3207 1bb0 FEFFFFEB 		bl	CyU3PUsbStall
 3208              	.LVL263:
 3209 1bb4 04499FE5 		ldr	r4, .L315+8
1203:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3210              		.loc 1 1203 0
 3211 1bb8 0620A0E1 		mov	r2, r6
 3212 1bbc 0400A0E3 		mov	r0, #4
 3213 1bc0 FC189FE5 		ldr	r1, .L315+12
 3214 1bc4 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 3215 1bc8 FEFFFFEB 		bl	CyU3PDebugPrint
1204:../uvc.c      **** 			  break;
 3216              		.loc 1 1204 0
 3217 1bcc FFC0A0E3 		mov	ip, #255
 3218 1bd0 0C60A0E1 		mov	r6, ip
 3219 1bd4 0C80A0E1 		mov	r8, ip
 3220              	.LVL264:
 3221              	.L241:
1208:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 3222              		.loc 1 1208 0
 3223 1bd8 5EE0D4E5 		ldrb	lr, [r4, #94]	@ zero_extendqisi2
 3224 1bdc 08C08DE5 		str	ip, [sp, #8]
 3225 1be0 E0189FE5 		ldr	r1, .L315+16
 3226 1be4 FFC0A0E3 		mov	ip, #255
 3227 1be8 0520A0E1 		mov	r2, r5
 3228 1bec 0830A0E1 		mov	r3, r8
 3229 1bf0 0400A0E3 		mov	r0, #4
 3230 1bf4 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 3231 1bf8 0CC08DE5 		str	ip, [sp, #12]
 3232 1bfc 10E08DE5 		str	lr, [sp, #16]
 3233 1c00 14708DE5 		str	r7, [sp, #20]
 3234 1c04 FEFFFFEB 		bl	CyU3PDebugPrint
1209:../uvc.c      **** }
 3235              		.loc 1 1209 0
 3236 1c08 5CD08DE2 		add	sp, sp, #92
 3237 1c0c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3238              	.LVL265:
 3239              	.L310:
 995:../uvc.c      ****     switch (bRequest)
 3240              		.loc 1 995 0
 3241 1c10 810055E3 		cmp	r5, #129
 3242 1c14 4200000A 		beq	.L233
 3243 1c18 1100009A 		bls	.L312
1024:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3244              		.loc 1 1024 0
 3245 1c1c 9C489FE5 		ldr	r4, .L315+8
 3246 1c20 9714D2E5 		ldrb	r1, [r2, #1175]	@ zero_extendqisi2
1025:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3247              		.loc 1 1025 0
 3248 1c24 9864D2E5 		ldrb	r6, [r2, #1176]	@ zero_extendqisi2
1026:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3249              		.loc 1 1026 0
 3250 1c28 0A0050E3 		cmp	r0, #10
1024:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3251              		.loc 1 1024 0
 3252 1c2c 5C10C4E5 		strb	r1, [r4, #92]
1025:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3253              		.loc 1 1025 0
 3254 1c30 5D60C4E5 		strb	r6, [r4, #93]
1026:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3255              		.loc 1 1026 0
 3256 1c34 2C00000A 		beq	.L309
 3257              	.LVL266:
 3258              	.L248:
1060:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3259              		.loc 1 1060 0
 3260 1c38 00E0A0E3 		mov	lr, #0
 3261 1c3c 5EE0C4E5 		strb	lr, [r4, #94]
 3262              	.L249:
1061:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3263              		.loc 1 1061 0
 3264 1c40 0030A0E3 		mov	r3, #0
1062:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3265              		.loc 1 1062 0
 3266 1c44 0700A0E1 		mov	r0, r7
 3267              	.LVL267:
 3268 1c48 7C189FE5 		ldr	r1, .L315+20
1064:../uvc.c      **** 			  break;
 3269              		.loc 1 1064 0
 3270 1c4c FF60A0E3 		mov	r6, #255
1061:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3271              		.loc 1 1061 0
 3272 1c50 5F30C4E5 		strb	r3, [r4, #95]
1064:../uvc.c      **** 			  break;
 3273              		.loc 1 1064 0
 3274 1c54 0680A0E1 		mov	r8, r6
1062:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3275              		.loc 1 1062 0
 3276 1c58 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3277              	.LVL268:
 3278 1c5c 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1064:../uvc.c      **** 			  break;
 3279              		.loc 1 1064 0
 3280 1c60 DCFFFFEA 		b	.L241
 3281              	.LVL269:
 3282              	.L312:
 995:../uvc.c      ****     switch (bRequest)
 3283              		.loc 1 995 0
 3284 1c64 010055E3 		cmp	r5, #1
 3285 1c68 CDFFFF1A 		bne	.L231
1066:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 3286              		.loc 1 1066 0
 3287 1c6c 4C489FE5 		ldr	r4, .L315+8
 3288 1c70 56208DE2 		add	r2, sp, #86
 3289 1c74 2000A0E3 		mov	r0, #32
 3290              	.LVL270:
 3291 1c78 5C1084E2 		add	r1, r4, #92
 3292 1c7c 2C308DE5 		str	r3, [sp, #44]
 3293 1c80 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3294              	.LVL271:
1068:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3295              		.loc 1 1068 0
 3296 1c84 5C00D4E5 		ldrb	r0, [r4, #92]	@ zero_extendqisi2
1069:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3297              		.loc 1 1069 0
 3298 1c88 5DC0D4E5 		ldrb	ip, [r4, #93]	@ zero_extendqisi2
1072:../uvc.c      **** 			  switch(CtrlID)
 3299              		.loc 1 1072 0
 3300 1c8c 012046E2 		sub	r2, r6, #1
1068:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3301              		.loc 1 1068 0
 3302 1c90 30008DE5 		str	r0, [sp, #48]
 3303              	.LVL272:
1069:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3304              		.loc 1 1069 0
 3305 1c94 34C08DE5 		str	ip, [sp, #52]
 3306              	.LVL273:
1072:../uvc.c      **** 			  switch(CtrlID)
 3307              		.loc 1 1072 0
 3308 1c98 2C309DE5 		ldr	r3, [sp, #44]
 3309 1c9c 090052E3 		cmp	r2, #9
 3310 1ca0 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3311 1ca4 550100EA 		b	.L250
 3312              	.L255:
 3313 1ca8 BC210000 		.word	.L251
 3314 1cac 00220000 		.word	.L250
 3315 1cb0 CC1E0000 		.word	.L252
 3316 1cb4 00220000 		.word	.L250
 3317 1cb8 00220000 		.word	.L250
 3318 1cbc 00220000 		.word	.L250
 3319 1cc0 481E0000 		.word	.L253
 3320 1cc4 00220000 		.word	.L250
 3321 1cc8 00220000 		.word	.L250
 3322 1ccc CC1D0000 		.word	.L254
 3323              	.LVL274:
 3324              	.L236:
1042:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3325              		.loc 1 1042 0
 3326 1cd0 E8479FE5 		ldr	r4, .L315+8
 3327 1cd4 9B84D2E5 		ldrb	r8, [r2, #1179]	@ zero_extendqisi2
1043:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3328              		.loc 1 1043 0
 3329 1cd8 9C24D2E5 		ldrb	r2, [r2, #1180]	@ zero_extendqisi2
1044:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3330              		.loc 1 1044 0
 3331 1cdc 0A0050E3 		cmp	r0, #10
1042:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3332              		.loc 1 1042 0
 3333 1ce0 5C80C4E5 		strb	r8, [r4, #92]
1043:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3334              		.loc 1 1043 0
 3335 1ce4 5D20C4E5 		strb	r2, [r4, #93]
1044:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3336              		.loc 1 1044 0
 3337 1ce8 D2FFFF1A 		bne	.L248
 3338              	.LVL275:
 3339              	.L309:
1059:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3340              		.loc 1 1059 0 discriminator 1
 3341 1cec 0110A0E3 		mov	r1, #1
 3342 1cf0 5E10C4E5 		strb	r1, [r4, #94]
 3343 1cf4 D1FFFFEA 		b	.L249
 3344              	.LVL276:
 3345              	.L237:
 999:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3346              		.loc 1 999 0
 3347 1cf8 C0479FE5 		ldr	r4, .L315+8
1000:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3348              		.loc 1 1000 0
 3349 1cfc 0030A0E3 		mov	r3, #0
 3350              	.LVL277:
1001:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3351              		.loc 1 1001 0
 3352 1d00 0200A0E3 		mov	r0, #2
 3353              	.LVL278:
 3354 1d04 5C1084E2 		add	r1, r4, #92
1003:../uvc.c      **** 			  break;
 3355              		.loc 1 1003 0
 3356 1d08 FF60A0E3 		mov	r6, #255
 999:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3357              		.loc 1 999 0
 3358 1d0c 5C70C4E5 		strb	r7, [r4, #92]
1000:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3359              		.loc 1 1000 0
 3360 1d10 5D30C4E5 		strb	r3, [r4, #93]
1003:../uvc.c      **** 			  break;
 3361              		.loc 1 1003 0
 3362 1d14 0680A0E1 		mov	r8, r6
1001:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3363              		.loc 1 1001 0
 3364 1d18 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3365              	.LVL279:
 3366 1d1c 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1003:../uvc.c      **** 			  break;
 3367              		.loc 1 1003 0
 3368 1d20 ACFFFFEA 		b	.L241
 3369              	.LVL280:
 3370              	.L233:
1009:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3371              		.loc 1 1009 0
 3372 1d24 94479FE5 		ldr	r4, .L315+8
 3373 1d28 A1A4D2E5 		ldrb	sl, [r2, #1185]	@ zero_extendqisi2
1010:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3374              		.loc 1 1010 0
 3375 1d2c A2C4D2E5 		ldrb	ip, [r2, #1186]	@ zero_extendqisi2
1011:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3376              		.loc 1 1011 0
 3377 1d30 0080A0E3 		mov	r8, #0
1017:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3378              		.loc 1 1017 0
 3379 1d34 0700A0E1 		mov	r0, r7
 3380              	.LVL281:
 3381 1d38 5C1084E2 		add	r1, r4, #92
1022:../uvc.c      **** 			  break;
 3382              		.loc 1 1022 0
 3383 1d3c FF60A0E3 		mov	r6, #255
1010:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3384              		.loc 1 1010 0
 3385 1d40 5DC0C4E5 		strb	ip, [r4, #93]
1011:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3386              		.loc 1 1011 0
 3387 1d44 5E80C4E5 		strb	r8, [r4, #94]
1012:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3388              		.loc 1 1012 0
 3389 1d48 5F80C4E5 		strb	r8, [r4, #95]
 3390              	.LVL282:
1009:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3391              		.loc 1 1009 0
 3392 1d4c 5CA0C4E5 		strb	sl, [r4, #92]
1022:../uvc.c      **** 			  break;
 3393              		.loc 1 1022 0
 3394 1d50 0680A0E1 		mov	r8, r6
1017:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3395              		.loc 1 1017 0
 3396 1d54 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3397              	.LVL283:
 3398 1d58 0AC0A0E1 		mov	ip, sl
1022:../uvc.c      **** 			  break;
 3399              		.loc 1 1022 0
 3400 1d5c 9DFFFFEA 		b	.L241
 3401              	.LVL284:
 3402              	.L235:
1033:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3403              		.loc 1 1033 0
 3404 1d60 58479FE5 		ldr	r4, .L315+8
 3405 1d64 9934D2E5 		ldrb	r3, [r2, #1177]	@ zero_extendqisi2
 3406              	.LVL285:
1034:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3407              		.loc 1 1034 0
 3408 1d68 9AE4D2E5 		ldrb	lr, [r2, #1178]	@ zero_extendqisi2
1035:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3409              		.loc 1 1035 0
 3410 1d6c 0A0050E3 		cmp	r0, #10
1033:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3411              		.loc 1 1033 0
 3412 1d70 5C30C4E5 		strb	r3, [r4, #92]
1034:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3413              		.loc 1 1034 0
 3414 1d74 5DE0C4E5 		strb	lr, [r4, #93]
1035:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3415              		.loc 1 1035 0
 3416 1d78 AEFFFF1A 		bne	.L248
 3417 1d7c DAFFFFEA 		b	.L309
 3418              	.LVL286:
 3419              	.L311:
1057:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3420              		.loc 1 1057 0
 3421 1d80 38479FE5 		ldr	r4, .L315+8
 3422 1d84 9F64D2E5 		ldrb	r6, [r2, #1183]	@ zero_extendqisi2
1058:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3423              		.loc 1 1058 0
 3424 1d88 A0C4D2E5 		ldrb	ip, [r2, #1184]	@ zero_extendqisi2
1059:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3425              		.loc 1 1059 0
 3426 1d8c 0A0050E3 		cmp	r0, #10
1057:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3427              		.loc 1 1057 0
 3428 1d90 5C60C4E5 		strb	r6, [r4, #92]
1058:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3429              		.loc 1 1058 0
 3430 1d94 5DC0C4E5 		strb	ip, [r4, #93]
1059:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3431              		.loc 1 1059 0
 3432 1d98 A6FFFF1A 		bne	.L248
 3433 1d9c D2FFFFEA 		b	.L309
 3434              	.L238:
1051:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 3435              		.loc 1 1051 0
 3436 1da0 18479FE5 		ldr	r4, .L315+8
 3437 1da4 9D04D2E5 		ldrb	r0, [r2, #1181]	@ zero_extendqisi2
 3438              	.LVL287:
 3439 1da8 0410A0E1 		mov	r1, r4
 3440 1dac 5C00E1E5 		strb	r0, [r1, #92]!
1055:../uvc.c      **** 			  break;
 3441              		.loc 1 1055 0
 3442 1db0 FF60A0E3 		mov	r6, #255
1052:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3443              		.loc 1 1052 0
 3444 1db4 0100A0E3 		mov	r0, #1
 3445 1db8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3446              	.LVL288:
1055:../uvc.c      **** 			  break;
 3447              		.loc 1 1055 0
 3448 1dbc 0680A0E1 		mov	r8, r6
1052:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3449              		.loc 1 1052 0
 3450 1dc0 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1055:../uvc.c      **** 			  break;
 3451              		.loc 1 1055 0
 3452 1dc4 0170A0E3 		mov	r7, #1
 3453 1dc8 82FFFFEA 		b	.L241
 3454              	.LVL289:
 3455              	.L254:
1181:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3456              		.loc 1 1181 0
 3457 1dcc FC669FE5 		ldr	r6, .L315+24
 3458 1dd0 0010E0E3 		mvn	r1, #0
 3459 1dd4 1C0096E5 		ldr	r0, [r6, #28]
 3460 1dd8 2C308DE5 		str	r3, [sp, #44]
 3461 1ddc FEFFFFEB 		bl	_txe_mutex_get
1182:../uvc.c      **** 					  if(getData == 1)
 3462              		.loc 1 1182 0
 3463 1de0 30E09DE5 		ldr	lr, [sp, #48]
 3464 1de4 2C309DE5 		ldr	r3, [sp, #44]
 3465 1de8 01005EE3 		cmp	lr, #1
 3466 1dec A901000A 		beq	.L313
1184:../uvc.c      **** 					  else if(getData == 0xff)
 3467              		.loc 1 1184 0
 3468 1df0 FF005EE3 		cmp	lr, #255
 3469 1df4 9E01000A 		beq	.L314
1187:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
 3470              		.loc 1 1187 0
 3471 1df8 0080A0E3 		mov	r8, #0
 3472 1dfc 0600A0E1 		mov	r0, r6
 3473 1e00 1710A0E3 		mov	r1, #23
 3474 1e04 0B20A0E1 		mov	r2, fp
 3475 1e08 00808DE5 		str	r8, [sp, #0]
 3476 1e0c 04808DE5 		str	r8, [sp, #4]
 3477 1e10 FEFFFFEB 		bl	cmdSet
 3478              	.L307:
1190:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3479              		.loc 1 1190 0
 3480 1e14 1C0096E5 		ldr	r0, [r6, #28]
 3481 1e18 FEFFFFEB 		bl	_txe_mutex_put
1192:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 3482              		.loc 1 1192 0
 3483 1e1c 30809DE5 		ldr	r8, [sp, #48]
 3484 1e20 34609DE5 		ldr	r6, [sp, #52]
 3485 1e24 5EC0D4E5 		ldrb	ip, [r4, #94]	@ zero_extendqisi2
 3486 1e28 0400A0E3 		mov	r0, #4
 3487 1e2c A0169FE5 		ldr	r1, .L315+28
 3488 1e30 0820A0E1 		mov	r2, r8
 3489 1e34 0630A0E1 		mov	r3, r6
 3490 1e38 00C08DE5 		str	ip, [sp, #0]
 3491 1e3c FEFFFFEB 		bl	CyU3PDebugPrint
1193:../uvc.c      **** 					  break;
 3492              		.loc 1 1193 0
 3493 1e40 FFC0A0E3 		mov	ip, #255
 3494 1e44 63FFFFEA 		b	.L241
 3495              	.LVL290:
 3496              	.L253:
1158:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 3497              		.loc 1 1158 0
 3498 1e48 B984D8E5 		ldrb	r8, [r8, #1209]	@ zero_extendqisi2
 3499 1e4c 010058E3 		cmp	r8, #1
 3500 1e50 08005813 		cmpne	r8, #8
 3501 1e54 0000A013 		movne	r0, #0
 3502 1e58 0100A003 		moveq	r0, #1
 3503 1e5c 8001001A 		bne	.L304
 3504              	.LVL291:
1161:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3505              		.loc 1 1161 0
 3506 1e60 68869FE5 		ldr	r8, .L315+24
 3507 1e64 0010E0E3 		mvn	r1, #0
 3508 1e68 1C0098E5 		ldr	r0, [r8, #28]
 3509 1e6c 2C308DE5 		str	r3, [sp, #44]
 3510 1e70 FEFFFFEB 		bl	_txe_mutex_get
1162:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
 3511              		.loc 1 1162 0
 3512 1e74 30A09DE5 		ldr	sl, [sp, #48]
 3513 1e78 1610A0E3 		mov	r1, #22
 3514 1e7c 0B20A0E1 		mov	r2, fp
 3515 1e80 2C309DE5 		ldr	r3, [sp, #44]
 3516 1e84 00C0A0E3 		mov	ip, #0
 3517 1e88 0800A0E1 		mov	r0, r8
 3518 1e8c 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 3519 1e90 FEFFFFEB 		bl	cmdSet
1163:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3520              		.loc 1 1163 0
 3521 1e94 1C0098E5 		ldr	r0, [r8, #28]
 3522 1e98 FEFFFFEB 		bl	_txe_mutex_put
1166:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3523              		.loc 1 1166 0
 3524 1e9c 18069FE5 		ldr	r0, .L315+4
1167:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3525              		.loc 1 1167 0
 3526 1ea0 34209DE5 		ldr	r2, [sp, #52]
1166:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3527              		.loc 1 1166 0
 3528 1ea4 061089E0 		add	r1, r9, r6
 3529 1ea8 813180E0 		add	r3, r0, r1, asl #3
1168:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3530              		.loc 1 1168 0
 3531 1eac 0160A0E3 		mov	r6, #1
1166:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3532              		.loc 1 1166 0
 3533 1eb0 A1A4C3E5 		strb	sl, [r3, #1185]
1167:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3534              		.loc 1 1167 0
 3535 1eb4 A224C3E5 		strb	r2, [r3, #1186]
1168:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3536              		.loc 1 1168 0
 3537 1eb8 A464C3E5 		strb	r6, [r3, #1188]
 3538              	.LVL292:
 3539              	.L305:
1170:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3540              		.loc 1 1170 0
 3541 1ebc 5C80D4E5 		ldrb	r8, [r4, #92]	@ zero_extendqisi2
 3542 1ec0 5D60D4E5 		ldrb	r6, [r4, #93]	@ zero_extendqisi2
1175:../uvc.c      **** 					  break;
 3543              		.loc 1 1175 0
 3544 1ec4 FFC0A0E3 		mov	ip, #255
 3545 1ec8 42FFFFEA 		b	.L241
 3546              	.LVL293:
 3547              	.L252:
1124:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 3548              		.loc 1 1124 0
 3549 1ecc B904D8E5 		ldrb	r0, [r8, #1209]	@ zero_extendqisi2
 3550 1ed0 010050E3 		cmp	r0, #1
 3551 1ed4 04005013 		cmpne	r0, #4
 3552 1ed8 5C01001A 		bne	.L262
1123:../uvc.c      **** 					  value = (value << 8)|Data0;
 3553              		.loc 1 1123 0
 3554 1edc 30109DE5 		ldr	r1, [sp, #48]
 3555 1ee0 34E09DE5 		ldr	lr, [sp, #52]
 3556 1ee4 0E2481E1 		orr	r2, r1, lr, asl #8
1125:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 3557              		.loc 1 1125 0
 3558 1ee8 F90052E3 		cmp	r2, #249
 3559 1eec 5701008A 		bhi	.L262
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3560              		.loc 1 1130 0
 3561 1ef0 C8A042E2 		sub	sl, r2, #200
 3562 1ef4 0AC8A0E1 		mov	ip, sl, asl #16
 3563 1ef8 3CC08DE5 		str	ip, [sp, #60]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3564              		.loc 1 1132 0
 3565 1efc 27A062E2 		rsb	sl, r2, #39
 3566 1f00 38A08DE5 		str	sl, [sp, #56]
 3567 1f04 3CA09DE5 		ldr	sl, [sp, #60]
 3568 1f08 C81062E2 		rsb	r1, r2, #200
 3569 1f0c C80052E3 		cmp	r2, #200
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3570              		.loc 1 1130 0
 3571 1f10 640042E2 		sub	r0, r2, #100
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3572              		.loc 1 1132 0
 3573 1f14 0118A0E1 		mov	r1, r1, asl #16
 3574 1f18 64E062E2 		rsb	lr, r2, #100
 3575 1f1c 2A18A081 		movhi	r1, sl, lsr #16
 3576 1f20 2118A091 		movls	r1, r1, lsr #16
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3577              		.loc 1 1130 0
 3578 1f24 00C8A0E1 		mov	ip, r0, asl #16
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3579              		.loc 1 1132 0
 3580 1f28 640052E3 		cmp	r2, #100
 3581 1f2c 0E08A0E1 		mov	r0, lr, asl #16
 3582 1f30 2C08A081 		movhi	r0, ip, lsr #16
 3583 1f34 38C09DE5 		ldr	ip, [sp, #56]
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3584              		.loc 1 1130 0
 3585 1f38 14A042E2 		sub	sl, r2, #20
 3586 1f3c 38A08DE5 		str	sl, [sp, #56]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3587              		.loc 1 1132 0
 3588 1f40 2008A091 		movls	r0, r0, lsr #16
 3589 1f44 14A062E2 		rsb	sl, r2, #20
 3590 1f48 3CA08DE5 		str	sl, [sp, #60]
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3591              		.loc 1 1130 0
 3592 1f4c 27E042E2 		sub	lr, r2, #39
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3593              		.loc 1 1132 0
 3594 1f50 000051E1 		cmp	r1, r0
 3595 1f54 01A0A031 		movcc	sl, r1
 3596 1f58 00A0A021 		movcs	sl, r0
 3597 1f5c 0CC8A0E1 		mov	ip, ip, asl #16
 3598 1f60 270052E3 		cmp	r2, #39
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3599              		.loc 1 1130 0
 3600 1f64 0EE8A0E1 		mov	lr, lr, asl #16
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3601              		.loc 1 1132 0
 3602 1f68 2CE8A091 		movls	lr, ip, lsr #16
 3603 1f6c 64C59FE5 		ldr	ip, .L315+32
 3604 1f70 20A08DE5 		str	sl, [sp, #32]
 3605 1f74 01A06CE0 		rsb	sl, ip, r1
 3606 1f78 2EE8A081 		movhi	lr, lr, lsr #16
 3607 1f7c 00C07AE2 		rsbs	ip, sl, #0
 3608 1f80 0AC0ACE0 		adc	ip, ip, sl
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3609              		.loc 1 1130 0
 3610 1f84 38A09DE5 		ldr	sl, [sp, #56]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3611              		.loc 1 1132 0
 3612 1f88 44C08DE5 		str	ip, [sp, #68]
 3613              	.LVL294:
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3614              		.loc 1 1130 0
 3615 1f8c 0AC8A0E1 		mov	ip, sl, asl #16
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3616              		.loc 1 1132 0
 3617 1f90 3CA09DE5 		ldr	sl, [sp, #60]
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3618              		.loc 1 1130 0
 3619 1f94 4CC08DE5 		str	ip, [sp, #76]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3620              		.loc 1 1132 0
 3621 1f98 0AC8A0E1 		mov	ip, sl, asl #16
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3622              		.loc 1 1130 0
 3623 1f9c 0AA042E2 		sub	sl, r2, #10
 3624 1fa0 48A08DE5 		str	sl, [sp, #72]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3625              		.loc 1 1132 0
 3626 1fa4 20A09DE5 		ldr	sl, [sp, #32]
 3627 1fa8 3CC08DE5 		str	ip, [sp, #60]
 3628 1fac 0A005EE1 		cmp	lr, sl
 3629 1fb0 0EA0A031 		movcc	sl, lr
 3630 1fb4 0AC062E2 		rsb	ip, r2, #10
 3631 1fb8 40C08DE5 		str	ip, [sp, #64]
 3632 1fbc 38A08DE5 		str	sl, [sp, #56]
 3633 1fc0 3CC09DE5 		ldr	ip, [sp, #60]
 3634 1fc4 4CA09DE5 		ldr	sl, [sp, #76]
 3635 1fc8 140052E3 		cmp	r2, #20
 3636 1fcc 2CA8A091 		movls	sl, ip, lsr #16
 3637 1fd0 2AA8A081 		movhi	sl, sl, lsr #16
 3638 1fd4 44C09DE5 		ldr	ip, [sp, #68]
 3639 1fd8 010050E1 		cmp	r0, r1
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3640              		.loc 1 1130 0
 3641 1fdc 48109DE5 		ldr	r1, [sp, #72]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3642              		.loc 1 1132 0
 3643 1fe0 01C0A033 		movcc	ip, #1
 3644 1fe4 3CA08DE5 		str	sl, [sp, #60]
 3645 1fe8 24C08DE5 		str	ip, [sp, #36]
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3646              		.loc 1 1130 0
 3647 1fec 01A8A0E1 		mov	sl, r1, asl #16
 3648 1ff0 05C042E2 		sub	ip, r2, #5
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3649              		.loc 1 1132 0
 3650 1ff4 051062E2 		rsb	r1, r2, #5
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3651              		.loc 1 1130 0
 3652 1ff8 48A08DE5 		str	sl, [sp, #72]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3653              		.loc 1 1132 0
 3654 1ffc 40009DE5 		ldr	r0, [sp, #64]
 3655 2000 38A09DE5 		ldr	sl, [sp, #56]
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3656              		.loc 1 1130 0
 3657 2004 40C08DE5 		str	ip, [sp, #64]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3658              		.loc 1 1132 0
 3659 2008 3CC09DE5 		ldr	ip, [sp, #60]
 3660 200c 4C108DE5 		str	r1, [sp, #76]
 3661 2010 48109DE5 		ldr	r1, [sp, #72]
 3662 2014 0008A0E1 		mov	r0, r0, asl #16
 3663 2018 0A005CE1 		cmp	ip, sl
 3664 201c 0AC0A021 		movcs	ip, sl
 3665 2020 0A0052E3 		cmp	r2, #10
 3666 2024 20A09DE5 		ldr	sl, [sp, #32]
 3667 2028 2108A081 		movhi	r0, r1, lsr #16
 3668 202c 2008A091 		movls	r0, r0, lsr #16
 3669 2030 48008DE5 		str	r0, [sp, #72]
 3670 2034 24009DE5 		ldr	r0, [sp, #36]
 3671 2038 0A005EE1 		cmp	lr, sl
 3672 203c 0200A033 		movcc	r0, #2
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3673              		.loc 1 1130 0
 3674 2040 02E042E2 		sub	lr, r2, #2
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3675              		.loc 1 1132 0
 3676 2044 44C08DE5 		str	ip, [sp, #68]
 3677 2048 24008DE5 		str	r0, [sp, #36]
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3678              		.loc 1 1130 0
 3679 204c 40C09DE5 		ldr	ip, [sp, #64]
 3680 2050 1CE08DE5 		str	lr, [sp, #28]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3681              		.loc 1 1132 0
 3682 2054 44009DE5 		ldr	r0, [sp, #68]
 3683 2058 48E09DE5 		ldr	lr, [sp, #72]
 3684 205c 4C109DE5 		ldr	r1, [sp, #76]
 3685 2060 02A062E2 		rsb	sl, r2, #2
 3686 2064 00005EE1 		cmp	lr, r0
 3687 2068 00E0A021 		movcs	lr, r0
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3688              		.loc 1 1130 0
 3689 206c 0CC8A0E1 		mov	ip, ip, asl #16
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3690              		.loc 1 1132 0
 3691 2070 050052E3 		cmp	r2, #5
 3692 2074 40A08DE5 		str	sl, [sp, #64]
 3693 2078 0118A0E1 		mov	r1, r1, asl #16
 3694 207c 3CA09DE5 		ldr	sl, [sp, #60]
 3695 2080 2C18A081 		movhi	r1, ip, lsr #16
 3696 2084 38C09DE5 		ldr	ip, [sp, #56]
 3697 2088 4CE08DE5 		str	lr, [sp, #76]
 3698 208c 24009DE5 		ldr	r0, [sp, #36]
 3699 2090 40E09DE5 		ldr	lr, [sp, #64]
 3700 2094 2118A091 		movls	r1, r1, lsr #16
 3701 2098 0C005AE1 		cmp	sl, ip
 3702 209c 20108DE5 		str	r1, [sp, #32]
 3703 20a0 0300A033 		movcc	r0, #3
 3704 20a4 38008DE5 		str	r0, [sp, #56]
 3705 20a8 4CA09DE5 		ldr	sl, [sp, #76]
 3706 20ac 0E08A0E1 		mov	r0, lr, asl #16
 3707 20b0 20E09DE5 		ldr	lr, [sp, #32]
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3708              		.loc 1 1130 0
 3709 20b4 1C109DE5 		ldr	r1, [sp, #28]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3710              		.loc 1 1132 0
 3711 20b8 0A005EE1 		cmp	lr, sl
 3712 20bc 0AE0A021 		movcs	lr, sl
 3713 20c0 44C09DE5 		ldr	ip, [sp, #68]
 3714 20c4 48A09DE5 		ldr	sl, [sp, #72]
 3715 20c8 020052E3 		cmp	r2, #2
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3716              		.loc 1 1130 0
 3717 20cc 0118A0E1 		mov	r1, r1, asl #16
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3718              		.loc 1 1132 0
 3719 20d0 2018A091 		movls	r1, r0, lsr #16
 3720 20d4 38009DE5 		ldr	r0, [sp, #56]
 3721 20d8 2118A081 		movhi	r1, r1, lsr #16
 3722 20dc 0C005AE1 		cmp	sl, ip
 3723 20e0 0400A033 		movcc	r0, #4
 3724 20e4 40008DE5 		str	r0, [sp, #64]
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3725              		.loc 1 1130 0
 3726 20e8 010042E2 		sub	r0, r2, #1
 3727 20ec 38008DE5 		str	r0, [sp, #56]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3728              		.loc 1 1132 0
 3729 20f0 4CA09DE5 		ldr	sl, [sp, #76]
 3730 20f4 20009DE5 		ldr	r0, [sp, #32]
 3731 20f8 01C062E2 		rsb	ip, r2, #1
 3732 20fc 3CC08DE5 		str	ip, [sp, #60]
 3733 2100 0A0050E1 		cmp	r0, sl
1139:../uvc.c      **** 						  shutter = shutter+index;
 3734              		.loc 1 1139 0
 3735 2104 38A09DE5 		ldr	sl, [sp, #56]
 3736 2108 3C009DE5 		ldr	r0, [sp, #60]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3737              		.loc 1 1132 0
 3738 210c 40C09DE5 		ldr	ip, [sp, #64]
 3739 2110 05C0A033 		movcc	ip, #5
1139:../uvc.c      **** 						  shutter = shutter+index;
 3740              		.loc 1 1139 0
 3741 2114 010052E3 		cmp	r2, #1
 3742 2118 0028A091 		movls	r2, r0, asl #16
 3743 211c 0A28A081 		movhi	r2, sl, asl #16
 3744 2120 0E0051E1 		cmp	r1, lr
 3745 2124 01A0A031 		movcc	sl, r1
 3746 2128 0EA0A021 		movcs	sl, lr
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3747              		.loc 1 1132 0
 3748 212c 0E0051E1 		cmp	r1, lr
 3749 2130 0C10A021 		movcs	r1, ip
 3750 2134 0610A033 		movcc	r1, #6
1139:../uvc.c      **** 						  shutter = shutter+index;
 3751              		.loc 1 1139 0
 3752 2138 22085AE1 		cmp	sl, r2, lsr #16
1142:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3753              		.loc 1 1142 0
 3754 213c 8CA39FE5 		ldr	sl, .L315+24
1139:../uvc.c      **** 						  shutter = shutter+index;
 3755              		.loc 1 1139 0
 3756 2140 0120A091 		movls	r2, r1
 3757 2144 0720A083 		movhi	r2, #7
 3758 2148 012082E2 		add	r2, r2, #1
 3759 214c FFE002E2 		and	lr, r2, #255
1142:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3760              		.loc 1 1142 0
 3761 2150 0010E0E3 		mvn	r1, #0
 3762 2154 1C009AE5 		ldr	r0, [sl, #28]
1139:../uvc.c      **** 						  shutter = shutter+index;
 3763              		.loc 1 1139 0
 3764 2158 38E08DE5 		str	lr, [sp, #56]
 3765              	.LVL295:
1142:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3766              		.loc 1 1142 0
 3767 215c 2C308DE5 		str	r3, [sp, #44]
 3768 2160 FEFFFFEB 		bl	_txe_mutex_get
1143:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 3769              		.loc 1 1143 0
 3770 2164 38C09DE5 		ldr	ip, [sp, #56]
 3771 2168 0310A0E3 		mov	r1, #3
 3772 216c 0B20A0E1 		mov	r2, fp
 3773 2170 2C309DE5 		ldr	r3, [sp, #44]
 3774 2174 00C08DE5 		str	ip, [sp, #0]
 3775 2178 0A00A0E1 		mov	r0, sl
 3776 217c 00C0A0E3 		mov	ip, #0
 3777 2180 04C08DE5 		str	ip, [sp, #4]
 3778 2184 FEFFFFEB 		bl	cmdSet
1144:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3779              		.loc 1 1144 0
 3780 2188 1C009AE5 		ldr	r0, [sl, #28]
 3781 218c FEFFFFEB 		bl	_txe_mutex_put
1147:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3782              		.loc 1 1147 0
 3783 2190 30009DE5 		ldr	r0, [sp, #48]
1148:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3784              		.loc 1 1148 0
 3785 2194 34C09DE5 		ldr	ip, [sp, #52]
1150:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3786              		.loc 1 1150 0
 3787 2198 38309DE5 		ldr	r3, [sp, #56]
1147:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3788              		.loc 1 1147 0
 3789 219c 061089E0 		add	r1, r9, r6
 3790 21a0 816188E0 		add	r6, r8, r1, asl #3
1149:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3791              		.loc 1 1149 0
 3792 21a4 0120A0E3 		mov	r2, #1
1147:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3793              		.loc 1 1147 0
 3794 21a8 A104C6E5 		strb	r0, [r6, #1185]
1148:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3795              		.loc 1 1148 0
 3796 21ac A2C4C6E5 		strb	ip, [r6, #1186]
1149:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3797              		.loc 1 1149 0
 3798 21b0 A424C6E5 		strb	r2, [r6, #1188]
1150:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3799              		.loc 1 1150 0
 3800 21b4 0D33C8E5 		strb	r3, [r8, #781]
 3801 21b8 3FFFFFEA 		b	.L305
 3802              	.LVL296:
 3803              	.L251:
1077:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3804              		.loc 1 1077 0
 3805 21bc 062089E0 		add	r2, r9, r6
 3806 21c0 826188E0 		add	r6, r8, r2, asl #3
1078:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3807              		.loc 1 1078 0
 3808 21c4 0110A0E3 		mov	r1, #1
1081:../uvc.c      **** 		  		    switch (getData){
 3809              		.loc 1 1081 0
 3810 21c8 01E040E2 		sub	lr, r0, #1
1077:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3811              		.loc 1 1077 0
 3812 21cc A104C6E5 		strb	r0, [r6, #1185]
1078:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3813              		.loc 1 1078 0
 3814 21d0 A414C6E5 		strb	r1, [r6, #1188]
 3815              	.LVL297:
1081:../uvc.c      **** 		  		    switch (getData){
 3816              		.loc 1 1081 0
 3817 21d4 07005EE3 		cmp	lr, #7
 3818 21d8 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 3819 21dc 970000EA 		b	.L256
 3820              	.L261:
 3821 21e0 D4230000 		.word	.L257
 3822 21e4 38230000 		.word	.L258
 3823 21e8 40240000 		.word	.L256
 3824 21ec D4220000 		.word	.L259
 3825 21f0 40240000 		.word	.L256
 3826 21f4 40240000 		.word	.L256
 3827 21f8 40240000 		.word	.L256
 3828 21fc 34220000 		.word	.L260
 3829              	.LVL298:
 3830              	.L250:
1197:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3831              		.loc 1 1197 0
 3832 2200 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1196:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3833              		.loc 1 1196 0
 3834 2204 30A09DE5 		ldr	sl, [sp, #48]
 3835 2208 069089E0 		add	r9, r9, r6
 3836 220c 89E188E0 		add	lr, r8, r9, asl #3
1197:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3837              		.loc 1 1197 0
 3838 2210 0620A0E1 		mov	r2, r6
 3839 2214 0400A0E3 		mov	r0, #4
 3840 2218 BC129FE5 		ldr	r1, .L315+36
1196:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3841              		.loc 1 1196 0
 3842 221c A1A4CEE5 		strb	sl, [lr, #1185]
1197:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3843              		.loc 1 1197 0
 3844 2220 FEFFFFEB 		bl	CyU3PDebugPrint
1198:../uvc.c      **** 			  		 break;
 3845              		.loc 1 1198 0
 3846 2224 FFC0A0E3 		mov	ip, #255
 3847 2228 0C60A0E1 		mov	r6, ip
 3848 222c 0C80A0E1 		mov	r8, ip
 3849 2230 68FEFFEA 		b	.L241
 3850              	.LVL299:
 3851              	.L260:
1100:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3852              		.loc 1 1100 0
 3853 2234 94629FE5 		ldr	r6, .L315+24
1098:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3854              		.loc 1 1098 0
 3855 2238 00A0A0E3 		mov	sl, #0
1100:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3856              		.loc 1 1100 0
 3857 223c 1C0096E5 		ldr	r0, [r6, #28]
1098:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3858              		.loc 1 1098 0
 3859 2240 0DA3C8E5 		strb	sl, [r8, #781]
 3860              	.LVL300:
1100:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3861              		.loc 1 1100 0
 3862 2244 0010E0E3 		mvn	r1, #0
 3863 2248 2C308DE5 		str	r3, [sp, #44]
 3864 224c FEFFFFEB 		bl	_txe_mutex_get
1101:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3865              		.loc 1 1101 0
 3866 2250 0B20A0E1 		mov	r2, fp
 3867 2254 2C309DE5 		ldr	r3, [sp, #44]
 3868 2258 1010A0E3 		mov	r1, #16
 3869 225c 0600A0E1 		mov	r0, r6
 3870 2260 00A08DE5 		str	sl, [sp, #0]
 3871 2264 04A08DE5 		str	sl, [sp, #4]
 3872 2268 FEFFFFEB 		bl	cmdSet
1102:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3873              		.loc 1 1102 0
 3874 226c 1C0096E5 		ldr	r0, [r6, #28]
 3875 2270 FEFFFFEB 		bl	_txe_mutex_put
 3876              	.LVL301:
 3877              	.LBB68:
 3878              	.LBB69:
 416:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3879              		.loc 1 416 0
 3880 2274 0010E0E3 		mvn	r1, #0
 3881 2278 1C0096E5 		ldr	r0, [r6, #28]
 3882 227c FEFFFFEB 		bl	_txe_mutex_get
 417:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3883              		.loc 1 417 0
 3884 2280 0180A0E3 		mov	r8, #1
 3885 2284 1410A0E3 		mov	r1, #20
 3886 2288 2720A0E3 		mov	r2, #39
 3887 228c 3030A0E3 		mov	r3, #48
 3888 2290 0600A0E1 		mov	r0, r6
 3889 2294 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3890 2298 FEFFFFEB 		bl	cmdSet
 418:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3891              		.loc 1 418 0
 3892 229c 02C0A0E3 		mov	ip, #2
 3893 22a0 1510A0E3 		mov	r1, #21
 3894 22a4 2520A0E3 		mov	r2, #37
 3895 22a8 3030A0E3 		mov	r3, #48
 3896 22ac 0600A0E1 		mov	r0, r6
 3897 22b0 00C08DE5 		str	ip, [sp, #0]
 3898 22b4 04A08DE5 		str	sl, [sp, #4]
 3899 22b8 FEFFFFEB 		bl	cmdSet
 419:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3900              		.loc 1 419 0
 3901 22bc 1C0096E5 		ldr	r0, [r6, #28]
 3902 22c0 FEFFFFEB 		bl	_txe_mutex_put
 3903              	.LBE69:
 3904              	.LBE68:
1104:../uvc.c      **** 							break;
 3905              		.loc 1 1104 0
 3906 22c4 FFC0A0E3 		mov	ip, #255
 3907 22c8 0C60A0E1 		mov	r6, ip
 3908 22cc 0880A0E3 		mov	r8, #8
 3909 22d0 40FEFFEA 		b	.L241
 3910              	.LVL302:
 3911              	.L259:
 3912              	.LBB70:
 3913              	.LBB71:
 416:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3914              		.loc 1 416 0
 3915 22d4 F4819FE5 		ldr	r8, .L315+24
 3916 22d8 0010E0E3 		mvn	r1, #0
 3917 22dc 1C0098E5 		ldr	r0, [r8, #28]
 3918 22e0 FEFFFFEB 		bl	_txe_mutex_get
 417:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3919              		.loc 1 417 0
 3920 22e4 0060A0E3 		mov	r6, #0
 3921 22e8 1410A0E3 		mov	r1, #20
 3922 22ec 2720A0E3 		mov	r2, #39
 3923 22f0 3030A0E3 		mov	r3, #48
 3924 22f4 0800A0E1 		mov	r0, r8
 3925 22f8 00608DE5 		str	r6, [sp, #0]
 3926 22fc 04608DE5 		str	r6, [sp, #4]
 3927 2300 FEFFFFEB 		bl	cmdSet
 418:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3928              		.loc 1 418 0
 3929 2304 1510A0E3 		mov	r1, #21
 3930 2308 2520A0E3 		mov	r2, #37
 3931 230c 3030A0E3 		mov	r3, #48
 3932 2310 0800A0E1 		mov	r0, r8
 3933 2314 00608DE5 		str	r6, [sp, #0]
 3934 2318 04608DE5 		str	r6, [sp, #4]
 3935 231c FEFFFFEB 		bl	cmdSet
 419:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3936              		.loc 1 419 0
 3937 2320 1C0098E5 		ldr	r0, [r8, #28]
 3938 2324 FEFFFFEB 		bl	_txe_mutex_put
 3939 2328 FFC0A0E3 		mov	ip, #255
 3940 232c 0C60A0E1 		mov	r6, ip
 3941 2330 0480A0E3 		mov	r8, #4
 3942 2334 27FEFFEA 		b	.L241
 3943              	.LVL303:
 3944              	.L258:
 3945              	.LBE71:
 3946              	.LBE70:
1088:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3947              		.loc 1 1088 0
 3948 2338 90A19FE5 		ldr	sl, .L315+24
1086:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3949              		.loc 1 1086 0
 3950 233c 0060A0E3 		mov	r6, #0
 3951 2340 0D63C8E5 		strb	r6, [r8, #781]
 3952              	.LVL304:
1088:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3953              		.loc 1 1088 0
 3954 2344 0010E0E3 		mvn	r1, #0
 3955 2348 1C009AE5 		ldr	r0, [sl, #28]
 3956 234c 2C308DE5 		str	r3, [sp, #44]
 3957 2350 FEFFFFEB 		bl	_txe_mutex_get
1089:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3958              		.loc 1 1089 0
 3959 2354 0B20A0E1 		mov	r2, fp
 3960 2358 2C309DE5 		ldr	r3, [sp, #44]
 3961 235c 1010A0E3 		mov	r1, #16
 3962 2360 0A00A0E1 		mov	r0, sl
 3963 2364 00608DE5 		str	r6, [sp, #0]
 3964 2368 04608DE5 		str	r6, [sp, #4]
 3965 236c FEFFFFEB 		bl	cmdSet
1090:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3966              		.loc 1 1090 0
 3967 2370 1C009AE5 		ldr	r0, [sl, #28]
 3968 2374 FEFFFFEB 		bl	_txe_mutex_put
 3969              	.LVL305:
 3970              	.LBB72:
 3971              	.LBB73:
 416:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3972              		.loc 1 416 0
 3973 2378 0010E0E3 		mvn	r1, #0
 3974 237c 1C009AE5 		ldr	r0, [sl, #28]
 3975 2380 FEFFFFEB 		bl	_txe_mutex_get
 417:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3976              		.loc 1 417 0
 3977 2384 1410A0E3 		mov	r1, #20
 3978 2388 2720A0E3 		mov	r2, #39
 3979 238c 3030A0E3 		mov	r3, #48
 3980 2390 0A00A0E1 		mov	r0, sl
 3981 2394 00608DE5 		str	r6, [sp, #0]
 3982 2398 04608DE5 		str	r6, [sp, #4]
 3983 239c FEFFFFEB 		bl	cmdSet
 418:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3984              		.loc 1 418 0
 3985 23a0 1510A0E3 		mov	r1, #21
 3986 23a4 2520A0E3 		mov	r2, #37
 3987 23a8 3030A0E3 		mov	r3, #48
 3988 23ac 0A00A0E1 		mov	r0, sl
 3989 23b0 00608DE5 		str	r6, [sp, #0]
 3990 23b4 04608DE5 		str	r6, [sp, #4]
 3991 23b8 FEFFFFEB 		bl	cmdSet
 419:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3992              		.loc 1 419 0
 3993 23bc 1C009AE5 		ldr	r0, [sl, #28]
 3994 23c0 FEFFFFEB 		bl	_txe_mutex_put
 3995 23c4 FFC0A0E3 		mov	ip, #255
 3996 23c8 0C60A0E1 		mov	r6, ip
 3997 23cc 0280A0E3 		mov	r8, #2
 3998 23d0 00FEFFEA 		b	.L241
 3999              	.LVL306:
 4000              	.L257:
 4001              	.LBE73:
 4002              	.LBE72:
 4003              	.LBB74:
 4004              	.LBB75:
 416:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4005              		.loc 1 416 0
 4006 23d4 F4609FE5 		ldr	r6, .L315+24
 4007 23d8 0010E0E3 		mvn	r1, #0
 4008 23dc 1C0096E5 		ldr	r0, [r6, #28]
 4009 23e0 FEFFFFEB 		bl	_txe_mutex_get
 417:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 4010              		.loc 1 417 0
 4011 23e4 0080A0E3 		mov	r8, #0
 4012 23e8 01A0A0E3 		mov	sl, #1
 4013 23ec 1410A0E3 		mov	r1, #20
 4014 23f0 2720A0E3 		mov	r2, #39
 4015 23f4 3030A0E3 		mov	r3, #48
 4016 23f8 0600A0E1 		mov	r0, r6
 4017 23fc 04808DE5 		str	r8, [sp, #4]
 4018 2400 00A08DE5 		str	sl, [sp, #0]
 4019 2404 FEFFFFEB 		bl	cmdSet
 418:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 4020              		.loc 1 418 0
 4021 2408 02C0A0E3 		mov	ip, #2
 4022 240c 1510A0E3 		mov	r1, #21
 4023 2410 2520A0E3 		mov	r2, #37
 4024 2414 3030A0E3 		mov	r3, #48
 4025 2418 0600A0E1 		mov	r0, r6
 4026 241c 00C08DE5 		str	ip, [sp, #0]
 4027 2420 04808DE5 		str	r8, [sp, #4]
 4028 2424 FEFFFFEB 		bl	cmdSet
 419:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4029              		.loc 1 419 0
 4030 2428 1C0096E5 		ldr	r0, [r6, #28]
 4031 242c FEFFFFEB 		bl	_txe_mutex_put
 4032              	.LBE75:
 4033              	.LBE74:
1084:../uvc.c      **** 							break;
 4034              		.loc 1 1084 0
 4035 2430 FFC0A0E3 		mov	ip, #255
 4036 2434 0C60A0E1 		mov	r6, ip
 4037 2438 0A80A0E1 		mov	r8, sl
 4038 243c E5FDFFEA 		b	.L241
 4039              	.LVL307:
 4040              	.L256:
1081:../uvc.c      **** 		  		    switch (getData){
 4041              		.loc 1 1081 0
 4042 2440 FFC0A0E3 		mov	ip, #255
 4043 2444 0080A0E1 		mov	r8, r0
 4044 2448 0C60A0E1 		mov	r6, ip
 4045 244c E1FDFFEA 		b	.L241
 4046              	.LVL308:
 4047              	.L262:
1152:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4048              		.loc 1 1152 0
 4049 2450 0000A0E3 		mov	r0, #0
 4050 2454 0110A0E3 		mov	r1, #1
 4051 2458 0020A0E1 		mov	r2, r0
 4052 245c FEFFFFEB 		bl	CyU3PUsbStall
 4053              	.LVL309:
 4054 2460 95FEFFEA 		b	.L305
 4055              	.LVL310:
 4056              	.L304:
1170:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4057              		.loc 1 1170 0
 4058 2464 0110A0E3 		mov	r1, #1
 4059 2468 0020A0E1 		mov	r2, r0
 4060 246c FEFFFFEB 		bl	CyU3PUsbStall
 4061 2470 91FEFFEA 		b	.L305
 4062              	.LVL311:
 4063              	.L314:
1185:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 4064              		.loc 1 1185 0
 4065 2474 08E0A0E3 		mov	lr, #8
 4066 2478 00C0A0E3 		mov	ip, #0
 4067 247c 0600A0E1 		mov	r0, r6
 4068 2480 1710A0E3 		mov	r1, #23
 4069 2484 0B20A0E1 		mov	r2, fp
 4070 2488 00E08DE5 		str	lr, [sp, #0]
 4071 248c 04C08DE5 		str	ip, [sp, #4]
 4072 2490 FEFFFFEB 		bl	cmdSet
 4073 2494 5EFEFFEA 		b	.L307
 4074              	.L313:
1183:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 4075              		.loc 1 1183 0
 4076 2498 0480A0E3 		mov	r8, #4
 4077 249c 00E0A0E3 		mov	lr, #0
 4078 24a0 0600A0E1 		mov	r0, r6
 4079 24a4 1710A0E3 		mov	r1, #23
 4080 24a8 0B20A0E1 		mov	r2, fp
 4081 24ac 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 4082 24b0 FEFFFFEB 		bl	cmdSet
 4083 24b4 56FEFFEA 		b	.L307
 4084              	.L316:
 4085              		.align	2
 4086              	.L315:
 4087 24b8 00000000 		.word	bRequest
 4088 24bc 00000000 		.word	.LANCHOR1
 4089 24c0 00000000 		.word	.LANCHOR0
 4090 24c4 0C040000 		.word	.LC24
 4091 24c8 30040000 		.word	.LC25
 4092 24cc 5C000000 		.word	.LANCHOR0+92
 4093 24d0 00000000 		.word	cmdQu
 4094 24d4 C0030000 		.word	.LC22
 4095 24d8 FFFF0000 		.word	65535
 4096 24dc E8030000 		.word	.LC23
 4097              		.cfi_endproc
 4098              	.LFE3:
 4100              		.align	2
 4101              		.global	UVCAppEP0Thread_Entry
 4103              	UVCAppEP0Thread_Entry:
 4104              	.LFB24:
3315:../uvc.c      **** {
 4105              		.loc 1 3315 0
 4106              		.cfi_startproc
 4107              		@ args = 0, pretend = 0, frame = 24
 4108              		@ frame_needed = 0, uses_anonymous_args = 0
 4109              	.LVL312:
 4110 24e0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4111              	.LCFI17:
 4112              		.cfi_def_cfa_offset 36
 4113 24e4 344B9FE5 		ldr	r4, .L477
 4114              		.cfi_offset 14, -4
 4115              		.cfi_offset 11, -8
 4116              		.cfi_offset 10, -12
 4117              		.cfi_offset 9, -16
 4118              		.cfi_offset 8, -20
 4119              		.cfi_offset 7, -24
 4120              		.cfi_offset 6, -28
 4121              		.cfi_offset 5, -32
 4122              		.cfi_offset 4, -36
 4123 24e8 346B9FE5 		ldr	r6, .L477+4
 4124 24ec 348B9FE5 		ldr	r8, .L477+8
 4125 24f0 349B9FE5 		ldr	r9, .L477+12
 4126 24f4 34BB9FE5 		ldr	fp, .L477+16
 4127 24f8 347B9FE5 		ldr	r7, .L477+20
 4128 24fc 34D04DE2 		sub	sp, sp, #52
 4129              	.LCFI18:
 4130              		.cfi_def_cfa_offset 88
 4131              	.LVL313:
3337:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 4132              		.loc 1 3337 0
 4133 2500 0450A0E1 		mov	r5, r4
 4134              	.LVL314:
 4135              	.L450:
 4136 2504 00C0E0E3 		mvn	ip, #0
 4137 2508 100B9FE5 		ldr	r0, .L477
 4138 250c 4C10A0E3 		mov	r1, #76
 4139 2510 0120A0E3 		mov	r2, #1
 4140 2514 28308DE2 		add	r3, sp, #40
 4141 2518 00C08DE5 		str	ip, [sp, #0]
 4142 251c FEFFFFEB 		bl	_txe_event_flags_get
 4143 2520 000050E3 		cmp	r0, #0
 4144 2524 3000001A 		bne	.L318
3341:../uvc.c      ****             if (!isUsbConnected)
 4145              		.loc 1 3341 0
 4146 2528 303095E5 		ldr	r3, [r5, #48]
 4147 252c 000053E3 		cmp	r3, #0
 4148 2530 8C00000A 		beq	.L466
 4149              	.L319:
3350:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 4150              		.loc 1 3350 0
 4151 2534 28309DE5 		ldr	r3, [sp, #40]
 4152 2538 0C0013E3 		tst	r3, #12
 4153 253c 7500001A 		bne	.L467
 4154              	.L320:
3357:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 4155              		.loc 1 3357 0
 4156 2540 040013E3 		tst	r3, #4
 4157 2544 1C00000A 		beq	.L321
3359:../uvc.c      ****             	switch ((wIndex >> 8))
 4158              		.loc 1 3359 0
 4159 2548 B0E0DBE1 		ldrh	lr, [fp, #0]
 4160 254c 2E24A0E1 		mov	r2, lr, lsr #8
 4161 2550 030052E3 		cmp	r2, #3
 4162 2554 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4163 2558 120000EA 		b	.L322
 4164              	.L327:
 4165 255c A8250000 		.word	.L322
 4166 2560 98260000 		.word	.L324
 4167 2564 6C250000 		.word	.L325
 4168 2568 D4260000 		.word	.L326
 4169              	.L325:
 4170              	.LBB90:
 4171              	.LBB93:
2604:../uvc.c      ****     switch (wValue)
 4172              		.loc 1 2604 0
 4173 256c B020D9E1 		ldrh	r2, [r9, #0]
 4174 2570 060C52E3 		cmp	r2, #1536
 4175 2574 8602000A 		beq	.L333
 4176 2578 D900008A 		bhi	.L339
 4177 257c 030C52E3 		cmp	r2, #768
 4178 2580 7F02000A 		beq	.L331
 4179 2584 BC01008A 		bhi	.L340
 4180 2588 010C52E3 		cmp	r2, #256
 4181 258c 7802000A 		beq	.L329
 4182 2590 020C52E3 		cmp	r2, #512
 4183 2594 7202000A 		beq	.L468
 4184              	.L342:
 4185              	.LBE93:
 4186              	.LBE90:
 4187              	.LBB97:
 4188              	.LBB102:
2736:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 4189              		.loc 1 2736 0
 4190 2598 981A9FE5 		ldr	r1, .L477+24
 4191 259c 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4192 25a0 0400A0E3 		mov	r0, #4
 4193 25a4 FEFFFFEB 		bl	CyU3PDebugPrint
 4194              	.L322:
 4195              	.LBE102:
 4196              	.LBE97:
3380:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4197              		.loc 1 3380 0
 4198 25a8 0000A0E3 		mov	r0, #0
 4199 25ac 0110A0E3 		mov	r1, #1
 4200 25b0 0020A0E1 		mov	r2, r0
 4201 25b4 FEFFFFEB 		bl	CyU3PUsbStall
 4202 25b8 28309DE5 		ldr	r3, [sp, #40]
 4203              	.L321:
3385:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 4204              		.loc 1 3385 0
 4205 25bc 080013E3 		tst	r3, #8
 4206 25c0 0700000A 		beq	.L383
3389:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 4207              		.loc 1 3389 0
 4208 25c4 B030DBE1 		ldrh	r3, [fp, #0]
 4209 25c8 010053E3 		cmp	r3, #1
 4210 25cc 6B00000A 		beq	.L384
 4211              	.L385:
 4212              	.LBB107:
 4213              	.LBB112:
3304:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4214              		.loc 1 3304 0
 4215 25d0 0000A0E3 		mov	r0, #0
 4216 25d4 0110A0E3 		mov	r1, #1
 4217 25d8 0020A0E1 		mov	r2, r0
 4218 25dc FEFFFFEB 		bl	CyU3PUsbStall
 4219              	.L456:
 4220 25e0 28309DE5 		ldr	r3, [sp, #40]
 4221              	.L383:
 4222              	.LBE112:
 4223              	.LBE107:
3400:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 4224              		.loc 1 3400 0
 4225 25e4 400013E3 		tst	r3, #64
 4226 25e8 0100001A 		bne	.L469
 4227              	.L318:
3613:../uvc.c      ****         CyU3PThreadRelinquish ();
 4228              		.loc 1 3613 0
 4229 25ec FEFFFFEB 		bl	_txe_thread_relinquish
3614:../uvc.c      ****     }
 4230              		.loc 1 3614 0
 4231 25f0 C3FFFFEA 		b	.L450
 4232              	.L469:
3405:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 4233              		.loc 1 3405 0
 4234 25f4 1800A0E3 		mov	r0, #24
 4235 25f8 24108DE2 		add	r1, sp, #36
 4236 25fc FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
3462:../uvc.c      **** 				if(snapButFlag == 0x0f){
 4237              		.loc 1 3462 0
 4238 2600 7F36D6E5 		ldrb	r3, [r6, #1663]	@ zero_extendqisi2
 4239 2604 0F0053E3 		cmp	r3, #15
 4240 2608 9400000A 		beq	.L470
3489:../uvc.c      **** 				}else if(!snapButFlag){
 4241              		.loc 1 3489 0
 4242 260c 000053E3 		cmp	r3, #0
 4243 2610 F5FFFF1A 		bne	.L318
3491:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4244              		.loc 1 3491 0
 4245 2614 002097E5 		ldr	r2, [r7, #0]
 4246 2618 02A0A0E3 		mov	sl, #2
 4247 261c 00A0C2E5 		strb	sl, [r2, #0]
3492:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4248              		.loc 1 3492 0
 4249 2620 001097E5 		ldr	r1, [r7, #0]
 4250 2624 01A0A0E3 		mov	sl, #1
 4251 2628 01A0C1E5 		strb	sl, [r1, #1]
3493:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4252              		.loc 1 3493 0
 4253 262c 000097E5 		ldr	r0, [r7, #0]
3497:../uvc.c      **** 					interStabuf.size   = 1024;
 4254              		.loc 1 3497 0
 4255 2630 01CBA0E3 		mov	ip, #1024	@ movhi
3493:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4256              		.loc 1 3493 0
 4257 2634 0230C0E5 		strb	r3, [r0, #2]
3494:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4258              		.loc 1 3494 0
 4259 2638 00E097E5 		ldr	lr, [r7, #0]
3503:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4260              		.loc 1 3503 0
 4261 263c 0010E0E3 		mvn	r1, #0
3494:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4262              		.loc 1 3494 0
 4263 2640 03A0CEE5 		strb	sl, [lr, #3]
3496:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4264              		.loc 1 3496 0
 4265 2644 002097E5 		ldr	r2, [r7, #0]
3500:../uvc.c      **** 					interStabuf.count = 4;
 4266              		.loc 1 3500 0
 4267 2648 04E0A0E3 		mov	lr, #4	@ movhi
3503:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4268              		.loc 1 3503 0
 4269 264c E8099FE5 		ldr	r0, .L477+28
3496:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4270              		.loc 1 3496 0
 4271 2650 18208DE5 		str	r2, [sp, #24]
3497:../uvc.c      **** 					interStabuf.size   = 1024;
 4272              		.loc 1 3497 0
 4273 2654 BEC1CDE1 		strh	ip, [sp, #30]	@ movhi
3498:../uvc.c      **** 					interStabuf.status = 0;
 4274              		.loc 1 3498 0
 4275 2658 B032CDE1 		strh	r3, [sp, #32]	@ movhi
3500:../uvc.c      **** 					interStabuf.count = 4;
 4276              		.loc 1 3500 0
 4277 265c BCE1CDE1 		strh	lr, [sp, #28]	@ movhi
3503:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4278              		.loc 1 3503 0
 4279 2660 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3506:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4280              		.loc 1 3506 0
 4281 2664 D0099FE5 		ldr	r0, .L477+28
 4282 2668 18108DE2 		add	r1, sp, #24
 4283 266c FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4284              	.LVL315:
3508:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4285              		.loc 1 3508 0
 4286 2670 002050E2 		subs	r2, r0, #0
 4287 2674 6001001A 		bne	.L471
3514:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
 4288              		.loc 1 3514 0
 4289 2678 3010A0E3 		mov	r1, #48
 4290 267c 0A20A0E1 		mov	r2, sl
 4291 2680 0500A0E3 		mov	r0, #5
 4292              	.LVL316:
 4293 2684 FEFFFFEB 		bl	SensorSetControl
3515:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 4294              		.loc 1 3515 0
 4295 2688 94399FE5 		ldr	r3, .L477+4
 4296 268c 7FA6C3E5 		strb	sl, [r3, #1663]
3613:../uvc.c      ****         CyU3PThreadRelinquish ();
 4297              		.loc 1 3613 0
 4298 2690 FEFFFFEB 		bl	_txe_thread_relinquish
 4299 2694 9AFFFFEA 		b	.L450
 4300              	.L324:
 4301              	.LBB117:
 4302              	.LBB101:
2679:../uvc.c      ****     switch (wValue)
 4303              		.loc 1 2679 0
 4304 2698 B020D9E1 		ldrh	r2, [r9, #0]
 4305 269c 060C52E3 		cmp	r2, #1536
 4306 26a0 2B02000A 		beq	.L348
 4307 26a4 9900008A 		bhi	.L354
 4308 26a8 030C52E3 		cmp	r2, #768
 4309 26ac 2402000A 		beq	.L345
 4310 26b0 5F01008A 		bhi	.L355
 4311 26b4 010C52E3 		cmp	r2, #256
 4312 26b8 1D02000A 		beq	.L343
 4313 26bc 020C52E3 		cmp	r2, #512
 4314 26c0 B4FFFF1A 		bne	.L342
 4315              	.LVL317:
2687:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 4316              		.loc 1 2687 0
 4317 26c4 0100A0E3 		mov	r0, #1
 4318 26c8 FEFFFFEB 		bl	CTControlHandle
 4319              	.LVL318:
 4320 26cc 28309DE5 		ldr	r3, [sp, #40]
 4321 26d0 B9FFFFEA 		b	.L321
 4322              	.L326:
 4323              	.LBE101:
 4324              	.LBE117:
 4325              	.LBB118:
 4326              	.LBB124:
2904:../uvc.c      ****     switch (wValue)
 4327              		.loc 1 2904 0
 4328 26d4 B030D9E1 		ldrh	r3, [r9, #0]
 4329 26d8 090C53E3 		cmp	r3, #2304
 4330 26dc 1002000A 		beq	.L369
 4331 26e0 9200008A 		bhi	.L378
 4332 26e4 010B53E3 		cmp	r3, #1024
 4333 26e8 0902000A 		beq	.L364
 4334 26ec 7301008A 		bhi	.L379
 4335 26f0 020C53E3 		cmp	r3, #512
 4336 26f4 0202000A 		beq	.L362
 4337 26f8 030C53E3 		cmp	r3, #768
 4338 26fc FC01000A 		beq	.L363
 4339 2700 010C53E3 		cmp	r3, #256
 4340 2704 A7FFFF1A 		bne	.L322
 4341              	.LVL319:
2908:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 4342              		.loc 1 2908 0
 4343 2708 1000A0E3 		mov	r0, #16
 4344 270c FEFFFFEB 		bl	ControlHandle
 4345              	.LVL320:
 4346 2710 28309DE5 		ldr	r3, [sp, #40]
 4347 2714 A8FFFFEA 		b	.L321
 4348              	.L467:
 4349              	.LBE124:
 4350              	.LBE118:
3351:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 4351              		.loc 1 3351 0
 4352 2718 B0C0D9E1 		ldrh	ip, [r9, #0]
 4353 271c 1CA99FE5 		ldr	sl, .L477+32
 4354 2720 1C199FE5 		ldr	r1, .L477+36
 4355 2724 00E0DAE5 		ldrb	lr, [sl, #0]	@ zero_extendqisi2
 4356 2728 08C08DE5 		str	ip, [sp, #8]
 4357 272c B000DBE1 		ldrh	r0, [fp, #0]
 4358 2730 00A0D8E5 		ldrb	sl, [r8, #0]	@ zero_extendqisi2
 4359 2734 0C008DE5 		str	r0, [sp, #12]
 4360 2738 B0C0D1E1 		ldrh	ip, [r1, #0]
 4361 273c 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
 4362 2740 04A08DE5 		str	sl, [sp, #4]
 4363 2744 0400A0E3 		mov	r0, #4
 4364 2748 F8189FE5 		ldr	r1, .L477+40
 4365 274c 00A0A0E3 		mov	sl, #0
 4366 2750 00E08DE5 		str	lr, [sp, #0]
 4367 2754 10C08DE5 		str	ip, [sp, #16]
 4368 2758 14A08DE5 		str	sl, [sp, #20]
 4369 275c FEFFFFEB 		bl	CyU3PDebugPrint
 4370 2760 28309DE5 		ldr	r3, [sp, #40]
 4371 2764 75FFFFEA 		b	.L320
 4372              	.L466:
3343:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4373              		.loc 1 3343 0
 4374 2768 FEFFFFEB 		bl	CyU3PUsbGetSpeed
3344:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4375              		.loc 1 3344 0
 4376 276c 000050E3 		cmp	r0, #0
3343:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4377              		.loc 1 3343 0
 4378 2770 4800C5E5 		strb	r0, [r5, #72]
3346:../uvc.c      ****                     isUsbConnected = CyTrue;
 4379              		.loc 1 3346 0
 4380 2774 0100A013 		movne	r0, #1
 4381 2778 30008515 		strne	r0, [r5, #48]
 4382 277c 6CFFFFEA 		b	.L319
 4383              	.L384:
 4384              	.LVL321:
 4385              	.LBB130:
 4386              	.LBB111:
2999:../uvc.c      ****     switch (wValue)
 4387              		.loc 1 2999 0
 4388 2780 B020D9E1 		ldrh	r2, [r9, #0]
 4389 2784 030C52E3 		cmp	r2, #768
 4390 2788 9200000A 		beq	.L388
 4391 278c 0F00008A 		bhi	.L391
 4392 2790 010C52E3 		cmp	r2, #256
 4393 2794 9C00000A 		beq	.L386
 4394 2798 020C52E3 		cmp	r2, #512
 4395 279c 8BFFFF1A 		bne	.L385
3064:../uvc.c      ****             switch (bRequest)
 4396              		.loc 1 3064 0
 4397 27a0 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4398 27a4 810053E3 		cmp	r3, #129
 4399 27a8 C901000A 		beq	.L437
 4400 27ac DC00008A 		bhi	.L406
 4401 27b0 010053E3 		cmp	r3, #1
 4402 27b4 8B01000A 		beq	.L472
 4403              	.L426:
3242:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4404              		.loc 1 3242 0
 4405 27b8 0000A0E3 		mov	r0, #0
 4406 27bc 0110A0E3 		mov	r1, #1
 4407 27c0 0020A0E1 		mov	r2, r0
 4408 27c4 FEFFFFEB 		bl	CyU3PUsbStall
 4409 27c8 28309DE5 		ldr	r3, [sp, #40]
 4410 27cc 84FFFFEA 		b	.L383
 4411              	.L391:
2999:../uvc.c      ****     switch (wValue)
 4412              		.loc 1 2999 0
 4413 27d0 010B52E3 		cmp	r2, #1024
 4414 27d4 6200000A 		beq	.L389
 4415 27d8 050C52E3 		cmp	r2, #1280
 4416 27dc 7BFFFF1A 		bne	.L385
3249:../uvc.c      ****             	switch (bRequest)
 4417              		.loc 1 3249 0
 4418 27e0 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4419 27e4 810052E3 		cmp	r2, #129
 4420 27e8 B901000A 		beq	.L437
 4421 27ec 0B01008A 		bhi	.L440
 4422 27f0 010052E3 		cmp	r2, #1
 4423 27f4 75FFFF1A 		bne	.L385
3274:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4424              		.loc 1 3274 0
 4425 27f8 2000A0E3 		mov	r0, #32
 4426 27fc 48189FE5 		ldr	r1, .L477+44
 4427 2800 2E208DE2 		add	r2, sp, #46
 4428 2804 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4429              	.LVL322:
3276:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4430              		.loc 1 3276 0
 4431 2808 000050E3 		cmp	r0, #0
 4432 280c 6F01001A 		bne	.L442
3280:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 4433              		.loc 1 3280 0
 4434 2810 0020A0E3 		mov	r2, #0
 4435 2814 04089FE5 		ldr	r0, .L477
 4436              	.LVL323:
 4437 2818 8010A0E3 		mov	r1, #128
 4438 281c FEFFFFEB 		bl	_txe_event_flags_set
 4439              	.LVL324:
3281:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4440              		.loc 1 3281 0
 4441 2820 002050E2 		subs	r2, r0, #0
3287:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
 4442              		.loc 1 3287 0
 4443 2824 0F00E003 		mvneq	r0, #15
 4444              	.LVL325:
 4445 2828 3A00C505 		streqb	r0, [r5, #58]
3281:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4446              		.loc 1 3281 0
 4447 282c 0200000A 		beq	.L444
3283:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
 4448              		.loc 1 3283 0
 4449 2830 18189FE5 		ldr	r1, .L477+48
 4450 2834 0400A0E3 		mov	r0, #4
 4451 2838 FEFFFFEB 		bl	CyU3PDebugPrint
 4452              	.LVL326:
 4453              	.L444:
3290:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
 4454              		.loc 1 3290 0
 4455 283c 81E0D4E5 		ldrb	lr, [r4, #129]	@ zero_extendqisi2
 4456 2840 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 4457 2844 BE22DDE1 		ldrh	r2, [sp, #46]
 4458              	.LVL327:
 4459 2848 0400A0E3 		mov	r0, #4
 4460 284c 00189FE5 		ldr	r1, .L477+52
 4461 2850 00E08DE5 		str	lr, [sp, #0]
 4462 2854 FEFFFFEB 		bl	CyU3PDebugPrint
 4463 2858 28309DE5 		ldr	r3, [sp, #40]
 4464 285c 60FFFFEA 		b	.L383
 4465              	.LVL328:
 4466              	.L470:
 4467              	.LBE111:
 4468              	.LBE130:
3464:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4469              		.loc 1 3464 0
 4470 2860 00C097E5 		ldr	ip, [r7, #0]
 4471 2864 02A0A0E3 		mov	sl, #2
 4472 2868 00A0CCE5 		strb	sl, [ip, #0]
3465:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4473              		.loc 1 3465 0
 4474 286c 002097E5 		ldr	r2, [r7, #0]
 4475 2870 01A0A0E3 		mov	sl, #1
 4476 2874 01A0C2E5 		strb	sl, [r2, #1]
3466:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4477              		.loc 1 3466 0
 4478 2878 001097E5 		ldr	r1, [r7, #0]
 4479 287c 00C0A0E3 		mov	ip, #0
 4480 2880 02C0C1E5 		strb	ip, [r1, #2]
3467:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4481              		.loc 1 3467 0
 4482 2884 000097E5 		ldr	r0, [r7, #0]
3473:../uvc.c      **** 					interStabuf.count = 4;
 4483              		.loc 1 3473 0
 4484 2888 0420A0E3 		mov	r2, #4	@ movhi
3467:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4485              		.loc 1 3467 0
 4486 288c 03C0C0E5 		strb	ip, [r0, #3]
3469:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4487              		.loc 1 3469 0
 4488 2890 00E097E5 		ldr	lr, [r7, #0]
3470:../uvc.c      **** 					interStabuf.size   = 1024;
 4489              		.loc 1 3470 0
 4490 2894 013BA0E3 		mov	r3, #1024	@ movhi
3476:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4491              		.loc 1 3476 0
 4492 2898 0010E0E3 		mvn	r1, #0
 4493 289c 98079FE5 		ldr	r0, .L477+28
3473:../uvc.c      **** 					interStabuf.count = 4;
 4494              		.loc 1 3473 0
 4495 28a0 BC21CDE1 		strh	r2, [sp, #28]	@ movhi
3469:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4496              		.loc 1 3469 0
 4497 28a4 18E08DE5 		str	lr, [sp, #24]
3470:../uvc.c      **** 					interStabuf.size   = 1024;
 4498              		.loc 1 3470 0
 4499 28a8 BE31CDE1 		strh	r3, [sp, #30]	@ movhi
3471:../uvc.c      **** 					interStabuf.status = 0;
 4500              		.loc 1 3471 0
 4501 28ac B0C2CDE1 		strh	ip, [sp, #32]	@ movhi
3476:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4502              		.loc 1 3476 0
 4503 28b0 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3479:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4504              		.loc 1 3479 0
 4505 28b4 80079FE5 		ldr	r0, .L477+28
 4506 28b8 18108DE2 		add	r1, sp, #24
 4507 28bc FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4508              	.LVL329:
3481:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4509              		.loc 1 3481 0
 4510 28c0 002050E2 		subs	r2, r0, #0
 4511 28c4 F400001A 		bne	.L473
3486:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
 4512              		.loc 1 3486 0
 4513 28c8 3010A0E3 		mov	r1, #48
 4514 28cc 0500A0E3 		mov	r0, #5
 4515              	.LVL330:
 4516 28d0 FEFFFFEB 		bl	SensorSetControl
 4517              	.LVL331:
3488:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
 4518              		.loc 1 3488 0
 4519 28d4 48379FE5 		ldr	r3, .L477+4
 4520 28d8 7FA6C3E5 		strb	sl, [r3, #1663]
3613:../uvc.c      ****         CyU3PThreadRelinquish ();
 4521              		.loc 1 3613 0
 4522 28dc FEFFFFEB 		bl	_txe_thread_relinquish
 4523 28e0 07FFFFEA 		b	.L450
 4524              	.L339:
 4525              	.LBB131:
 4526              	.LBB94:
2604:../uvc.c      ****     switch (wValue)
 4527              		.loc 1 2604 0
 4528 28e4 0A0C52E3 		cmp	r2, #2560
 4529 28e8 3401000A 		beq	.L336
 4530 28ec D800008A 		bhi	.L341
 4531 28f0 070C52E3 		cmp	r2, #1792
 4532 28f4 2D01000A 		beq	.L334
 4533 28f8 020B52E3 		cmp	r2, #2048
 4534 28fc 25FFFF1A 		bne	.L342
 4535              	.LVL332:
2635:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 4536              		.loc 1 2635 0
 4537 2900 0700A0E3 		mov	r0, #7
 4538 2904 FEFFFFEB 		bl	ControlHandle
 4539              	.LVL333:
 4540 2908 28309DE5 		ldr	r3, [sp, #40]
 4541 290c 2AFFFFEA 		b	.L321
 4542              	.L354:
 4543              	.LBE94:
 4544              	.LBE131:
 4545              	.LBB132:
 4546              	.LBB103:
2679:../uvc.c      ****     switch (wValue)
 4547              		.loc 1 2679 0
 4548 2910 090C52E3 		cmp	r2, #2304
 4549 2914 2101000A 		beq	.L350
 4550 2918 F100008A 		bhi	.L356
 4551 291c 070C52E3 		cmp	r2, #1792
 4552 2920 1A01000A 		beq	.L349
 4553 2924 020B52E3 		cmp	r2, #2048
 4554 2928 1AFFFF1A 		bne	.L342
 4555 292c 22FFFFEA 		b	.L321
 4556              	.L378:
 4557              	.LBE103:
 4558              	.LBE132:
 4559              	.LBB133:
 4560              	.LBB123:
2904:../uvc.c      ****     switch (wValue)
 4561              		.loc 1 2904 0
 4562 2930 0F0C53E3 		cmp	r3, #3840
 4563 2934 1101000A 		beq	.L373
 4564 2938 4000008A 		bhi	.L381
 4565 293c 0B0C53E3 		cmp	r3, #2816
 4566 2940 0A01000A 		beq	.L371
 4567 2944 0D0C53E3 		cmp	r3, #3328
 4568 2948 0401000A 		beq	.L372
 4569 294c 0A0C53E3 		cmp	r3, #2560
 4570 2950 14FFFF1A 		bne	.L322
 4571              	.LVL334:
2945:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 4572              		.loc 1 2945 0
 4573 2954 1900A0E3 		mov	r0, #25
 4574 2958 FEFFFFEB 		bl	ControlHandle
 4575              	.LVL335:
 4576 295c 28309DE5 		ldr	r3, [sp, #40]
 4577 2960 15FFFFEA 		b	.L321
 4578              	.LVL336:
 4579              	.L389:
 4580              	.LBE123:
 4581              	.LBE133:
 4582              	.LBB134:
 4583              	.LBB113:
3191:../uvc.c      ****                 switch (bRequest)
 4584              		.loc 1 3191 0
 4585 2964 00A0D8E5 		ldrb	sl, [r8, #0]	@ zero_extendqisi2
 4586 2968 81005AE3 		cmp	sl, #129
 4587 296c 1E00000A 		beq	.L428
 4588 2970 7100008A 		bhi	.L431
 4589 2974 01005AE3 		cmp	sl, #1
 4590 2978 8EFFFF1A 		bne	.L426
3216:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4591              		.loc 1 3216 0
 4592 297c 2E208DE2 		add	r2, sp, #46
 4593 2980 2000A0E3 		mov	r0, #32
 4594 2984 C0169FE5 		ldr	r1, .L477+44
 4595 2988 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4596              	.LVL337:
3218:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4597              		.loc 1 3218 0
 4598 298c 002050E2 		subs	r2, r0, #0
 4599 2990 12FFFF1A 		bne	.L456
3231:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
 4600              		.loc 1 3231 0
 4601 2994 84069FE5 		ldr	r0, .L477
 4602              	.LVL338:
 4603 2998 0A10A0E1 		mov	r1, sl
 4604 299c FEFFFFEB 		bl	_txe_event_flags_set
 4605              	.LVL339:
3232:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4606              		.loc 1 3232 0
 4607 29a0 002050E2 		subs	r2, r0, #0
 4608 29a4 0200000A 		beq	.L434
3234:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
 4609              		.loc 1 3234 0
 4610 29a8 0400A0E3 		mov	r0, #4
 4611              	.LVL340:
 4612 29ac 9C169FE5 		ldr	r1, .L477+48
 4613 29b0 FEFFFFEB 		bl	CyU3PDebugPrint
 4614              	.LVL341:
 4615              	.L434:
3236:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 4616              		.loc 1 3236 0
 4617 29b4 81C0D4E5 		ldrb	ip, [r4, #129]	@ zero_extendqisi2
 4618 29b8 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 4619 29bc BE22DDE1 		ldrh	r2, [sp, #46]
 4620              	.LVL342:
 4621 29c0 0400A0E3 		mov	r0, #4
 4622 29c4 8C169FE5 		ldr	r1, .L477+56
 4623 29c8 00C08DE5 		str	ip, [sp, #0]
 4624 29cc FEFFFFEB 		bl	CyU3PDebugPrint
 4625 29d0 28309DE5 		ldr	r3, [sp, #40]
 4626 29d4 02FFFFEA 		b	.L383
 4627              	.LVL343:
 4628              	.L388:
3141:../uvc.c      ****                 switch (bRequest)
 4629              		.loc 1 3141 0
 4630 29d8 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4631 29dc 830052E3 		cmp	r2, #131
 4632 29e0 8000008A 		bhi	.L422
 4633 29e4 810052E3 		cmp	r2, #129
 4634 29e8 5E00003A 		bcc	.L474
 4635              	.L428:
3203:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4636              		.loc 1 3203 0
 4637 29ec 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
3205:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4638              		.loc 1 3205 0
 4639 29f0 0B00A0E3 		mov	r0, #11
3203:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4640              		.loc 1 3203 0
 4641 29f4 030052E3 		cmp	r2, #3
3205:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4642              		.loc 1 3205 0
 4643 29f8 5C169F05 		ldreq	r1, .L477+60
3209:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4644              		.loc 1 3209 0
 4645 29fc 5C169F15 		ldrne	r1, .L477+64
 4646 2a00 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4647 2a04 28309DE5 		ldr	r3, [sp, #40]
 4648 2a08 F5FEFFEA 		b	.L383
 4649              	.L386:
3002:../uvc.c      ****             switch (bRequest)
 4650              		.loc 1 3002 0
 4651 2a0c 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4652 2a10 830052E3 		cmp	r2, #131
 4653 2a14 2B00008A 		bhi	.L397
 4654 2a18 810052E3 		cmp	r2, #129
 4655 2a1c 1000003A 		bcc	.L475
 4656              	.L394:
3017:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
 4657              		.loc 1 3017 0
 4658 2a20 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 4659 2a24 030053E3 		cmp	r3, #3
 4660 2a28 C300000A 		beq	.L476
 4661              	.L441:
3267:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4662              		.loc 1 3267 0
 4663 2a2c 1A00A0E3 		mov	r0, #26
 4664 2a30 2C169FE5 		ldr	r1, .L477+68
 4665 2a34 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4666 2a38 28309DE5 		ldr	r3, [sp, #40]
 4667 2a3c E8FEFFEA 		b	.L383
 4668              	.LVL344:
 4669              	.L381:
 4670              	.LBE113:
 4671              	.LBE134:
 4672              	.LBB135:
 4673              	.LBB125:
2904:../uvc.c      ****     switch (wValue)
 4674              		.loc 1 2904 0
 4675 2a40 110C53E3 		cmp	r3, #4352
 4676 2a44 B800000A 		beq	.L375
 4677 2a48 2D00008A 		bhi	.L382
 4678 2a4c 010A53E3 		cmp	r3, #4096
 4679 2a50 D4FEFF1A 		bne	.L322
 4680              	.LVL345:
2967:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 4681              		.loc 1 2967 0
 4682 2a54 1F00A0E3 		mov	r0, #31
 4683 2a58 FEFFFFEB 		bl	ControlHandle
 4684              	.LVL346:
 4685 2a5c 28309DE5 		ldr	r3, [sp, #40]
 4686 2a60 D5FEFFEA 		b	.L321
 4687              	.LVL347:
 4688              	.L475:
 4689              	.LBE125:
 4690              	.LBE135:
 4691              	.LBB136:
 4692              	.LBB110:
3002:../uvc.c      ****             switch (bRequest)
 4693              		.loc 1 3002 0
 4694 2a64 010052E3 		cmp	r2, #1
 4695 2a68 52FFFF1A 		bne	.L426
3029:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4696              		.loc 1 3029 0
 4697 2a6c 2000A0E3 		mov	r0, #32
 4698 2a70 D4159FE5 		ldr	r1, .L477+44
 4699 2a74 2E208DE2 		add	r2, sp, #46
 4700 2a78 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4701              	.LVL348:
3031:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 4702              		.loc 1 3031 0
 4703 2a7c 000050E3 		cmp	r0, #0
 4704 2a80 D6FEFF1A 		bne	.L456
3033:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4705              		.loc 1 3033 0
 4706 2a84 4810D5E5 		ldrb	r1, [r5, #72]	@ zero_extendqisi2
 4707 2a88 030051E3 		cmp	r1, #3
 4708 2a8c D3FEFF1A 		bne	.L456
3040:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 4709              		.loc 1 3040 0
 4710 2a90 8530D4E5 		ldrb	r3, [r4, #133]	@ zero_extendqisi2
3037:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 4711              		.loc 1 3037 0
 4712 2a94 82E0D4E5 		ldrb	lr, [r4, #130]	@ zero_extendqisi2
3038:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 4713              		.loc 1 3038 0
 4714 2a98 83C0D4E5 		ldrb	ip, [r4, #131]	@ zero_extendqisi2
3039:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 4715              		.loc 1 3039 0
 4716 2a9c 8400D4E5 		ldrb	r0, [r4, #132]	@ zero_extendqisi2
 4717              	.LVL349:
3041:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 4718              		.loc 1 3041 0
 4719 2aa0 8620D4E5 		ldrb	r2, [r4, #134]	@ zero_extendqisi2
3042:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 4720              		.loc 1 3042 0
 4721 2aa4 87A0D4E5 		ldrb	sl, [r4, #135]	@ zero_extendqisi2
3040:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 4722              		.loc 1 3040 0
 4723 2aa8 1936C6E5 		strb	r3, [r6, #1561]
3037:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 4724              		.loc 1 3037 0
 4725 2aac 16E6C6E5 		strb	lr, [r6, #1558]
3038:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 4726              		.loc 1 3038 0
 4727 2ab0 17C6C6E5 		strb	ip, [r6, #1559]
3039:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 4728              		.loc 1 3039 0
 4729 2ab4 1806C6E5 		strb	r0, [r6, #1560]
3041:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 4730              		.loc 1 3041 0
 4731 2ab8 1A26C6E5 		strb	r2, [r6, #1562]
3042:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 4732              		.loc 1 3042 0
 4733 2abc 1BA6C6E5 		strb	sl, [r6, #1563]
 4734 2ac0 28309DE5 		ldr	r3, [sp, #40]
 4735 2ac4 C6FEFFEA 		b	.L383
 4736              	.LVL350:
 4737              	.L397:
3002:../uvc.c      ****             switch (bRequest)
 4738              		.loc 1 3002 0
 4739 2ac8 860052E3 		cmp	r2, #134
 4740 2acc 1E00000A 		beq	.L460
 4741 2ad0 870052E3 		cmp	r2, #135
 4742 2ad4 D1FFFF0A 		beq	.L394
 4743              	.L465:
3141:../uvc.c      ****                 switch (bRequest)
 4744              		.loc 1 3141 0
 4745 2ad8 850052E3 		cmp	r2, #133
 4746 2adc 35FFFF1A 		bne	.L426
 4747              	.L429:
3200:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4748              		.loc 1 3200 0
 4749 2ae0 80159FE5 		ldr	r1, .L477+72
 4750 2ae4 0200A0E3 		mov	r0, #2
3198:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 4751              		.loc 1 3198 0
 4752 2ae8 1A30A0E3 		mov	r3, #26
 4753              	.L457:
3256:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 4754              		.loc 1 3256 0
 4755 2aec 5C30C4E5 		strb	r3, [r4, #92]
3257:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4756              		.loc 1 3257 0
 4757 2af0 0030A0E3 		mov	r3, #0
 4758 2af4 5D30C4E5 		strb	r3, [r4, #93]
3258:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4759              		.loc 1 3258 0
 4760 2af8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4761 2afc 28309DE5 		ldr	r3, [sp, #40]
 4762 2b00 B7FEFFEA 		b	.L383
 4763              	.LVL351:
 4764              	.L382:
 4765              	.LBE110:
 4766              	.LBE136:
 4767              	.LBB137:
 4768              	.LBB122:
2904:../uvc.c      ****     switch (wValue)
 4769              		.loc 1 2904 0
 4770 2b04 120C53E3 		cmp	r3, #4608
 4771 2b08 4001000A 		beq	.L376
 4772 2b0c 130C53E3 		cmp	r3, #4864
 4773 2b10 A4FEFF1A 		bne	.L322
 4774              	.LVL352:
2979:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
 4775              		.loc 1 2979 0
 4776 2b14 2200A0E3 		mov	r0, #34
 4777 2b18 FEFFFFEB 		bl	ControlHandle
 4778              	.LVL353:
 4779 2b1c 28309DE5 		ldr	r3, [sp, #40]
 4780 2b20 A5FEFFEA 		b	.L321
 4781              	.LVL354:
 4782              	.L406:
 4783              	.LBE122:
 4784              	.LBE137:
 4785              	.LBB138:
 4786              	.LBB114:
3064:../uvc.c      ****             switch (bRequest)
 4787              		.loc 1 3064 0
 4788 2b24 850053E3 		cmp	r3, #133
 4789 2b28 ECFFFF0A 		beq	.L429
 4790 2b2c 860053E3 		cmp	r3, #134
 4791 2b30 20FFFF1A 		bne	.L426
 4792              	.L461:
3068:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4793              		.loc 1 3068 0
 4794 2b34 0100A0E3 		mov	r0, #1
 4795 2b38 040000EA 		b	.L455
 4796              	.L431:
3191:../uvc.c      ****                 switch (bRequest)
 4797              		.loc 1 3191 0
 4798 2b3c 85005AE3 		cmp	sl, #133
 4799 2b40 E6FFFF0A 		beq	.L429
 4800 2b44 86005AE3 		cmp	sl, #134
 4801 2b48 1AFFFF1A 		bne	.L426
 4802              	.L460:
3195:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4803              		.loc 1 3195 0
 4804 2b4c 0300A0E1 		mov	r0, r3
 4805              	.L455:
3068:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4806              		.loc 1 3068 0
 4807 2b50 10159FE5 		ldr	r1, .L477+72
3067:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4808              		.loc 1 3067 0
 4809 2b54 03A0A0E3 		mov	sl, #3
 4810 2b58 5CA0C4E5 		strb	sl, [r4, #92]
3068:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4811              		.loc 1 3068 0
 4812 2b5c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4813 2b60 28309DE5 		ldr	r3, [sp, #40]
 4814 2b64 9EFEFFEA 		b	.L383
 4815              	.L474:
3141:../uvc.c      ****                 switch (bRequest)
 4816              		.loc 1 3141 0
 4817 2b68 010052E3 		cmp	r2, #1
 4818 2b6c 11FFFF1A 		bne	.L426
3166:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4819              		.loc 1 3166 0
 4820 2b70 2000A0E3 		mov	r0, #32
 4821 2b74 D0149FE5 		ldr	r1, .L477+44
 4822 2b78 2E208DE2 		add	r2, sp, #46
 4823 2b7c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4824              	.LVL355:
3168:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4825              		.loc 1 3168 0
 4826 2b80 000050E3 		cmp	r0, #0
 4827 2b84 95FEFF1A 		bne	.L456
3170:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 4828              		.loc 1 3170 0
 4829 2b88 4810D5E5 		ldrb	r1, [r5, #72]	@ zero_extendqisi2
 4830 2b8c 030051E3 		cmp	r1, #3
 4831 2b90 0B00001A 		bne	.L425
3174:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4832              		.loc 1 3174 0
 4833 2b94 81E0D5E5 		ldrb	lr, [r5, #129]	@ zero_extendqisi2
3175:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4834              		.loc 1 3175 0
 4835 2b98 82C0D5E5 		ldrb	ip, [r5, #130]	@ zero_extendqisi2
3176:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4836              		.loc 1 3176 0
 4837 2b9c 8300D5E5 		ldrb	r0, [r5, #131]	@ zero_extendqisi2
 4838              	.LVL356:
3177:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4839              		.loc 1 3177 0
 4840 2ba0 8430D5E5 		ldrb	r3, [r5, #132]	@ zero_extendqisi2
3178:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4841              		.loc 1 3178 0
 4842 2ba4 8520D5E5 		ldrb	r2, [r5, #133]	@ zero_extendqisi2
3179:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4843              		.loc 1 3179 0
 4844 2ba8 86A0D5E5 		ldrb	sl, [r5, #134]	@ zero_extendqisi2
3174:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4845              		.loc 1 3174 0
 4846 2bac 69E6C6E5 		strb	lr, [r6, #1641]
3175:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4847              		.loc 1 3175 0
 4848 2bb0 6AC6C6E5 		strb	ip, [r6, #1642]
3176:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4849              		.loc 1 3176 0
 4850 2bb4 6B06C6E5 		strb	r0, [r6, #1643]
3177:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4851              		.loc 1 3177 0
 4852 2bb8 6C36C6E5 		strb	r3, [r6, #1644]
3178:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4853              		.loc 1 3178 0
 4854 2bbc 6D26C6E5 		strb	r2, [r6, #1645]
3179:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4855              		.loc 1 3179 0
 4856 2bc0 6EA6C6E5 		strb	sl, [r6, #1646]
 4857              	.L425:
3181:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
 4858              		.loc 1 3181 0
 4859 2bc4 81A0D4E5 		ldrb	sl, [r4, #129]	@ zero_extendqisi2
 4860 2bc8 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 4861 2bcc BE22DDE1 		ldrh	r2, [sp, #46]
 4862              	.LVL357:
 4863 2bd0 0400A0E3 		mov	r0, #4
 4864 2bd4 90149FE5 		ldr	r1, .L477+76
 4865 2bd8 00A08DE5 		str	sl, [sp, #0]
 4866 2bdc FEFFFFEB 		bl	CyU3PDebugPrint
 4867 2be0 28309DE5 		ldr	r3, [sp, #40]
 4868 2be4 7EFEFFEA 		b	.L383
 4869              	.LVL358:
 4870              	.L422:
3141:../uvc.c      ****                 switch (bRequest)
 4871              		.loc 1 3141 0
 4872 2be8 860052E3 		cmp	r2, #134
 4873 2bec D6FFFF0A 		beq	.L460
 4874 2bf0 870052E3 		cmp	r2, #135
 4875 2bf4 B7FFFF1A 		bne	.L465
 4876 2bf8 7BFFFFEA 		b	.L428
 4877              	.LVL359:
 4878              	.L471:
 4879              	.LBE114:
 4880              	.LBE138:
3510:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4881              		.loc 1 3510 0
 4882 2bfc 0400A0E3 		mov	r0, #4
 4883              	.LVL360:
 4884 2c00 68149FE5 		ldr	r1, .L477+80
 4885 2c04 FEFFFFEB 		bl	CyU3PDebugPrint
 4886              	.LVL361:
 4887              	.L449:
 4888              	.LBB139:
 4889              	.LBB140:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4890              		.loc 1 1318 0
 4891 2c08 64149FE5 		ldr	r1, .L477+84
 4892 2c0c 0400A0E3 		mov	r0, #4
 4893 2c10 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 4894              		.loc 1 1319 0
 4895 2c14 FA0FA0E3 		mov	r0, #1000
 4896 2c18 FEFFFFEB 		bl	_tx_thread_sleep
 4897 2c1c F9FFFFEA 		b	.L449
 4898              	.LVL362:
 4899              	.L440:
 4900              	.LBE140:
 4901              	.LBE139:
 4902              	.LBB141:
 4903              	.LBB109:
3249:../uvc.c      ****             	switch (bRequest)
 4904              		.loc 1 3249 0
 4905 2c20 850052E3 		cmp	r2, #133
 4906 2c24 F600000A 		beq	.L438
 4907 2c28 860052E3 		cmp	r2, #134
 4908 2c2c 67FEFF1A 		bne	.L385
 4909 2c30 BFFFFFEA 		b	.L461
 4910              	.LVL363:
 4911              	.L355:
 4912              	.LBE109:
 4913              	.LBE141:
 4914              	.LBB142:
 4915              	.LBB100:
2679:../uvc.c      ****     switch (wValue)
 4916              		.loc 1 2679 0
 4917 2c34 010B52E3 		cmp	r2, #1024
 4918 2c38 ED00000A 		beq	.L346
 4919 2c3c 050C52E3 		cmp	r2, #1280
 4920 2c40 54FEFF1A 		bne	.L342
 4921              	.LVL364:
2701:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 4922              		.loc 1 2701 0
 4923 2c44 0400A0E3 		mov	r0, #4
 4924 2c48 FEFFFFEB 		bl	CTControlHandle
 4925              	.LVL365:
 4926 2c4c 28309DE5 		ldr	r3, [sp, #40]
 4927 2c50 59FEFFEA 		b	.L321
 4928              	.L341:
 4929              	.LBE100:
 4930              	.LBE142:
 4931              	.LBB143:
 4932              	.LBB92:
2604:../uvc.c      ****     switch (wValue)
 4933              		.loc 1 2604 0
 4934 2c54 0D0C52E3 		cmp	r2, #3328
 4935 2c58 5800000A 		beq	.L336
 4936 2c5c 0E0C52E3 		cmp	r2, #3584
 4937 2c60 DF00000A 		beq	.L338
 4938 2c64 030B52E3 		cmp	r2, #3072
 4939 2c68 4AFEFF1A 		bne	.L342
 4940              	.LVL366:
2645:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 4941              		.loc 1 2645 0
 4942 2c6c 0B00A0E3 		mov	r0, #11
 4943 2c70 FEFFFFEB 		bl	ControlHandle
 4944              	.LVL367:
 4945 2c74 28309DE5 		ldr	r3, [sp, #40]
 4946 2c78 4FFEFFEA 		b	.L321
 4947              	.L340:
2604:../uvc.c      ****     switch (wValue)
 4948              		.loc 1 2604 0
 4949 2c7c 010B52E3 		cmp	r2, #1024
 4950 2c80 4DFEFF0A 		beq	.L321
 4951 2c84 050C52E3 		cmp	r2, #1280
 4952 2c88 42FEFF1A 		bne	.L342
 4953              	.LVL368:
2623:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 4954              		.loc 1 2623 0
 4955 2c8c 0400A0E3 		mov	r0, #4
 4956 2c90 FEFFFFEB 		bl	ControlHandle
 4957              	.LVL369:
 4958 2c94 28309DE5 		ldr	r3, [sp, #40]
 4959 2c98 47FEFFEA 		b	.L321
 4960              	.LVL370:
 4961              	.L473:
 4962              	.LBE92:
 4963              	.LBE143:
3483:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4964              		.loc 1 3483 0
 4965 2c9c 0400A0E3 		mov	r0, #4
 4966              	.LVL371:
 4967 2ca0 C8139FE5 		ldr	r1, .L477+80
 4968 2ca4 FEFFFFEB 		bl	CyU3PDebugPrint
 4969              	.LVL372:
 4970              	.L447:
 4971              	.LBB144:
 4972              	.LBB145:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4973              		.loc 1 1318 0
 4974 2ca8 C4139FE5 		ldr	r1, .L477+84
 4975 2cac 0400A0E3 		mov	r0, #4
 4976 2cb0 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 4977              		.loc 1 1319 0
 4978 2cb4 FA0FA0E3 		mov	r0, #1000
 4979 2cb8 FEFFFFEB 		bl	_tx_thread_sleep
 4980 2cbc F9FFFFEA 		b	.L447
 4981              	.L379:
 4982              	.LBE145:
 4983              	.LBE144:
 4984              	.LBB146:
 4985              	.LBB126:
2904:../uvc.c      ****     switch (wValue)
 4986              		.loc 1 2904 0
 4987 2cc0 060C53E3 		cmp	r3, #1536
 4988 2cc4 C200000A 		beq	.L366
 4989 2cc8 0F00008A 		bhi	.L380
 4990 2ccc 050C53E3 		cmp	r3, #1280
 4991 2cd0 34FEFF1A 		bne	.L322
 4992              	.LVL373:
2924:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 4993              		.loc 1 2924 0
 4994 2cd4 1400A0E3 		mov	r0, #20
 4995 2cd8 FEFFFFEB 		bl	ControlHandle
 4996              	.LVL374:
 4997 2cdc 28309DE5 		ldr	r3, [sp, #40]
 4998 2ce0 35FEFFEA 		b	.L321
 4999              	.L356:
 5000              	.LBE126:
 5001              	.LBE146:
 5002              	.LBB147:
 5003              	.LBB104:
2679:../uvc.c      ****     switch (wValue)
 5004              		.loc 1 2679 0
 5005 2ce4 0B0C52E3 		cmp	r2, #2816
 5006 2ce8 B500000A 		beq	.L352
 5007 2cec 030B52E3 		cmp	r2, #3072
 5008 2cf0 AF00000A 		beq	.L353
 5009 2cf4 0A0C52E3 		cmp	r2, #2560
 5010 2cf8 26FEFF1A 		bne	.L342
 5011              	.LVL375:
2720:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 5012              		.loc 1 2720 0
 5013 2cfc 0800A0E3 		mov	r0, #8
 5014 2d00 FEFFFFEB 		bl	CTControlHandle
 5015              	.LVL376:
 5016 2d04 28309DE5 		ldr	r3, [sp, #40]
 5017 2d08 2BFEFFEA 		b	.L321
 5018              	.L380:
 5019              	.LBE104:
 5020              	.LBE147:
 5021              	.LBB148:
 5022              	.LBB121:
2904:../uvc.c      ****     switch (wValue)
 5023              		.loc 1 2904 0
 5024 2d0c 070C53E3 		cmp	r3, #1792
 5025 2d10 A300000A 		beq	.L367
 5026 2d14 020B53E3 		cmp	r3, #2048
 5027 2d18 22FEFF1A 		bne	.L322
 5028              	.LVL377:
2936:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 5029              		.loc 1 2936 0
 5030 2d1c 1700A0E3 		mov	r0, #23
 5031 2d20 FEFFFFEB 		bl	ControlHandle
 5032              	.LVL378:
 5033 2d24 28309DE5 		ldr	r3, [sp, #40]
 5034 2d28 23FEFFEA 		b	.L321
 5035              	.L375:
 5036              	.LVL379:
2971:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
 5037              		.loc 1 2971 0
 5038 2d2c 2000A0E3 		mov	r0, #32
 5039 2d30 FEFFFFEB 		bl	ControlHandle
 5040              	.LVL380:
 5041 2d34 28309DE5 		ldr	r3, [sp, #40]
 5042 2d38 1FFEFFEA 		b	.L321
 5043              	.LVL381:
 5044              	.L476:
 5045              	.LBE121:
 5046              	.LBE148:
 5047              	.LBB149:
 5048              	.LBB115:
3019:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
 5049              		.loc 1 3019 0
 5050 2d3c 34139FE5 		ldr	r1, .L477+88
 5051 2d40 1A00A0E3 		mov	r0, #26
 5052 2d44 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
3020:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 5053              		.loc 1 3020 0
 5054 2d48 0400A0E3 		mov	r0, #4
 5055 2d4c 28139FE5 		ldr	r1, .L477+92
 5056 2d50 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5057 2d54 FEFFFFEB 		bl	CyU3PDebugPrint
 5058 2d58 28309DE5 		ldr	r3, [sp, #40]
 5059 2d5c 20FEFFEA 		b	.L383
 5060              	.LVL382:
 5061              	.L372:
 5062              	.LBE115:
 5063              	.LBE149:
 5064              	.LBB150:
 5065              	.LBB127:
2955:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 5066              		.loc 1 2955 0
 5067 2d60 1C00A0E3 		mov	r0, #28
 5068 2d64 FEFFFFEB 		bl	ControlHandle
 5069              	.LVL383:
 5070 2d68 28309DE5 		ldr	r3, [sp, #40]
 5071 2d6c 12FEFFEA 		b	.L321
 5072              	.L371:
 5073              	.LVL384:
2951:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 5074              		.loc 1 2951 0
 5075 2d70 1A00A0E3 		mov	r0, #26
 5076 2d74 FEFFFFEB 		bl	ControlHandle
 5077              	.LVL385:
 5078 2d78 28309DE5 		ldr	r3, [sp, #40]
 5079 2d7c 0EFEFFEA 		b	.L321
 5080              	.L373:
 5081              	.LVL386:
2963:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 5082              		.loc 1 2963 0
 5083 2d80 1E00A0E3 		mov	r0, #30
 5084 2d84 FEFFFFEB 		bl	ControlHandle
 5085              	.LVL387:
 5086 2d88 28309DE5 		ldr	r3, [sp, #40]
 5087 2d8c 0AFEFFEA 		b	.L321
 5088              	.L349:
 5089              	.LVL388:
 5090              	.LBE127:
 5091              	.LBE150:
 5092              	.LBB151:
 5093              	.LBB99:
2709:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 5094              		.loc 1 2709 0
 5095 2d90 0600A0E3 		mov	r0, #6
 5096 2d94 FEFFFFEB 		bl	CTControlHandle
 5097              	.LVL389:
 5098 2d98 28309DE5 		ldr	r3, [sp, #40]
 5099 2d9c 06FEFFEA 		b	.L321
 5100              	.L350:
 5101              	.LVL390:
2715:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 5102              		.loc 1 2715 0
 5103 2da0 0700A0E3 		mov	r0, #7
 5104 2da4 FEFFFFEB 		bl	CTControlHandle
 5105              	.LVL391:
 5106 2da8 28309DE5 		ldr	r3, [sp, #40]
 5107 2dac 02FEFFEA 		b	.L321
 5108              	.L334:
 5109              	.LVL392:
 5110              	.LBE99:
 5111              	.LBE151:
 5112              	.LBB152:
 5113              	.LBB95:
2631:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 5114              		.loc 1 2631 0
 5115 2db0 0600A0E3 		mov	r0, #6
 5116 2db4 FEFFFFEB 		bl	ControlHandle
 5117              	.LVL393:
 5118 2db8 28309DE5 		ldr	r3, [sp, #40]
 5119 2dbc FEFDFFEA 		b	.L321
 5120              	.L336:
 5121              	.LVL394:
2641:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 5122              		.loc 1 2641 0
 5123 2dc0 0900A0E3 		mov	r0, #9
 5124 2dc4 FEFFFFEB 		bl	ControlHandle
 5125              	.LVL395:
 5126 2dc8 28309DE5 		ldr	r3, [sp, #40]
 5127 2dcc FAFDFFEA 		b	.L321
 5128              	.LVL396:
 5129              	.L442:
 5130              	.LBE95:
 5131              	.LBE152:
 5132              	.LBB153:
 5133              	.LBB108:
3292:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 5134              		.loc 1 3292 0
 5135 2dd0 A8129FE5 		ldr	r1, .L477+96
 5136 2dd4 BE22DDE1 		ldrh	r2, [sp, #46]
 5137 2dd8 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 5138 2ddc 0400A0E3 		mov	r0, #4
 5139              	.LVL397:
 5140 2de0 FEFFFFEB 		bl	CyU3PDebugPrint
 5141 2de4 F9FDFFEA 		b	.L385
 5142              	.LVL398:
 5143              	.L472:
3089:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5144              		.loc 1 3089 0
 5145 2de8 2000A0E3 		mov	r0, #32
 5146 2dec 58129FE5 		ldr	r1, .L477+44
 5147 2df0 2E208DE2 		add	r2, sp, #46
 5148 2df4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5149              	.LVL399:
3091:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5150              		.loc 1 3091 0
 5151 2df8 000050E3 		cmp	r0, #0
 5152 2dfc F7FDFF1A 		bne	.L456
3093:../uvc.c      ****                         switch (glCommitCtrl[3])
 5153              		.loc 1 3093 0
 5154 2e00 8300D4E5 		ldrb	r0, [r4, #131]	@ zero_extendqisi2
 5155              	.LVL400:
 5156 2e04 020050E3 		cmp	r0, #2
 5157 2e08 2600000A 		beq	.L411
 5158 2e0c 030050E3 		cmp	r0, #3
 5159 2e10 1700000A 		beq	.L412
 5160 2e14 010050E3 		cmp	r0, #1
 5161 2e18 0800001A 		bne	.L409
3096:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
 5162              		.loc 1 3096 0
 5163 2e1c 582095E5 		ldr	r2, [r5, #88]
 5164 2e20 3010A0E3 		mov	r1, #48
 5165 2e24 000052E3 		cmp	r2, #0
 5166 2e28 E420A003 		moveq	r2, #228
 5167 2e2c 6420A013 		movne	r2, #100
 5168 2e30 5230A0E3 		mov	r3, #82
 5169 2e34 FEFFFFEB 		bl	SensorSetIrisControl
3097:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5170              		.loc 1 3097 0
 5171 2e38 7D0FA0E3 		mov	r0, #500
 5172 2e3c FEFFFFEB 		bl	_tx_thread_sleep
 5173              	.L409:
3113:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5174              		.loc 1 3113 0
 5175 2e40 83C0D4E5 		ldrb	ip, [r4, #131]	@ zero_extendqisi2
3125:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5176              		.loc 1 3125 0
 5177 2e44 0020A0E3 		mov	r2, #0
 5178 2e48 D0019FE5 		ldr	r0, .L477
 5179 2e4c 0110A0E3 		mov	r1, #1
3113:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5180              		.loc 1 3113 0
 5181 2e50 7DC0C4E5 		strb	ip, [r4, #125]
3125:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5182              		.loc 1 3125 0
 5183 2e54 FEFFFFEB 		bl	_txe_event_flags_set
 5184              	.LVL401:
3126:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5185              		.loc 1 3126 0
 5186 2e58 002050E2 		subs	r2, r0, #0
 5187 2e5c DFFDFF0A 		beq	.L456
3128:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
 5188              		.loc 1 3128 0
 5189 2e60 0400A0E3 		mov	r0, #4
 5190              	.LVL402:
 5191 2e64 E4119FE5 		ldr	r1, .L477+48
 5192 2e68 FEFFFFEB 		bl	CyU3PDebugPrint
 5193              	.LVL403:
 5194 2e6c 28309DE5 		ldr	r3, [sp, #40]
 5195 2e70 DBFDFFEA 		b	.L383
 5196              	.L412:
3106:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
 5197              		.loc 1 3106 0
 5198 2e74 582095E5 		ldr	r2, [r5, #88]
 5199 2e78 8C34D6E5 		ldrb	r3, [r6, #1164]	@ zero_extendqisi2
 5200 2e7c 000052E3 		cmp	r2, #0
 5201 2e80 C420A003 		moveq	r2, #196
 5202 2e84 4420A013 		movne	r2, #68
 5203 2e88 032082E1 		orr	r2, r2, r3
 5204 2e8c 3010A0E3 		mov	r1, #48
 5205 2e90 5230A0E3 		mov	r3, #82
 5206 2e94 0100A0E3 		mov	r0, #1
 5207 2e98 FEFFFFEB 		bl	SensorSetIrisControl
3107:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5208              		.loc 1 3107 0
 5209 2e9c 7D0FA0E3 		mov	r0, #500
 5210 2ea0 FEFFFFEB 		bl	_tx_thread_sleep
 5211 2ea4 E5FFFFEA 		b	.L409
 5212              	.L411:
3101:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
 5213              		.loc 1 3101 0
 5214 2ea8 582095E5 		ldr	r2, [r5, #88]
 5215 2eac 3010A0E3 		mov	r1, #48
 5216 2eb0 000052E3 		cmp	r2, #0
 5217 2eb4 D420A003 		moveq	r2, #212
 5218 2eb8 5420A013 		movne	r2, #84
 5219 2ebc 5230A0E3 		mov	r3, #82
 5220 2ec0 0100A0E3 		mov	r0, #1
 5221 2ec4 FEFFFFEB 		bl	SensorSetIrisControl
3102:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5222              		.loc 1 3102 0
 5223 2ec8 7D0FA0E3 		mov	r0, #500
 5224 2ecc FEFFFFEB 		bl	_tx_thread_sleep
 5225 2ed0 DAFFFFEA 		b	.L409
 5226              	.LVL404:
 5227              	.L437:
3261:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5228              		.loc 1 3261 0
 5229 2ed4 4810D4E5 		ldrb	r1, [r4, #72]	@ zero_extendqisi2
 5230 2ed8 030051E3 		cmp	r1, #3
 5231 2edc D2FEFF1A 		bne	.L441
3263:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 5232              		.loc 1 3263 0
 5233 2ee0 1A00A0E3 		mov	r0, #26
 5234 2ee4 98119FE5 		ldr	r1, .L477+100
 5235 2ee8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5236 2eec 28309DE5 		ldr	r3, [sp, #40]
 5237 2ef0 BBFDFFEA 		b	.L383
 5238              	.LVL405:
 5239              	.L363:
 5240              	.LBE108:
 5241              	.LBE153:
 5242              	.LBB154:
 5243              	.LBB120:
2916:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 5244              		.loc 1 2916 0
 5245 2ef4 1200A0E3 		mov	r0, #18
 5246 2ef8 FEFFFFEB 		bl	ControlHandle
 5247              	.LVL406:
 5248 2efc 28309DE5 		ldr	r3, [sp, #40]
 5249 2f00 ADFDFFEA 		b	.L321
 5250              	.L362:
 5251              	.LVL407:
2912:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 5252              		.loc 1 2912 0
 5253 2f04 1100A0E3 		mov	r0, #17
 5254 2f08 FEFFFFEB 		bl	ControlHandle
 5255              	.LVL408:
 5256 2f0c 28309DE5 		ldr	r3, [sp, #40]
 5257 2f10 A9FDFFEA 		b	.L321
 5258              	.L364:
 5259              	.LVL409:
2920:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 5260              		.loc 1 2920 0
 5261 2f14 1300A0E3 		mov	r0, #19
 5262 2f18 FEFFFFEB 		bl	ControlHandle
 5263              	.LVL410:
 5264 2f1c 28309DE5 		ldr	r3, [sp, #40]
 5265 2f20 A5FDFFEA 		b	.L321
 5266              	.L369:
 5267              	.LVL411:
2940:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 5268              		.loc 1 2940 0
 5269 2f24 1800A0E3 		mov	r0, #24
 5270 2f28 FEFFFFEB 		bl	ControlHandle
 5271              	.LVL412:
 5272 2f2c 28309DE5 		ldr	r3, [sp, #40]
 5273 2f30 A1FDFFEA 		b	.L321
 5274              	.L343:
 5275              	.LVL413:
 5276              	.LBE120:
 5277              	.LBE154:
 5278              	.LBB155:
 5279              	.LBB105:
2683:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 5280              		.loc 1 2683 0
 5281 2f34 0000A0E3 		mov	r0, #0
 5282 2f38 FEFFFFEB 		bl	CTControlHandle
 5283              	.LVL414:
 5284 2f3c 28309DE5 		ldr	r3, [sp, #40]
 5285 2f40 9DFDFFEA 		b	.L321
 5286              	.L345:
 5287              	.LVL415:
2691:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 5288              		.loc 1 2691 0
 5289 2f44 0200A0E3 		mov	r0, #2
 5290 2f48 FEFFFFEB 		bl	CTControlHandle
 5291              	.LVL416:
 5292 2f4c 28309DE5 		ldr	r3, [sp, #40]
 5293 2f50 99FDFFEA 		b	.L321
 5294              	.L348:
 5295              	.LVL417:
2705:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 5296              		.loc 1 2705 0
 5297 2f54 0500A0E3 		mov	r0, #5
 5298 2f58 FEFFFFEB 		bl	CTControlHandle
 5299              	.LVL418:
 5300 2f5c 28309DE5 		ldr	r3, [sp, #40]
 5301 2f60 95FDFFEA 		b	.L321
 5302              	.L468:
 5303              	.LVL419:
 5304              	.LBE105:
 5305              	.LBE155:
 5306              	.LBB156:
 5307              	.LBB91:
2612:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 5308              		.loc 1 2612 0
 5309 2f64 0100A0E3 		mov	r0, #1
 5310 2f68 FEFFFFEB 		bl	ControlHandle
 5311              	.LVL420:
 5312 2f6c 28309DE5 		ldr	r3, [sp, #40]
 5313 2f70 91FDFFEA 		b	.L321
 5314              	.L329:
 5315              	.LVL421:
2608:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 5316              		.loc 1 2608 0
 5317 2f74 0000A0E3 		mov	r0, #0
 5318 2f78 FEFFFFEB 		bl	ControlHandle
 5319              	.LVL422:
 5320 2f7c 28309DE5 		ldr	r3, [sp, #40]
 5321 2f80 8DFDFFEA 		b	.L321
 5322              	.L331:
 5323              	.LVL423:
2616:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 5324              		.loc 1 2616 0
 5325 2f84 0200A0E3 		mov	r0, #2
 5326 2f88 FEFFFFEB 		bl	ControlHandle
 5327              	.LVL424:
 5328 2f8c 28309DE5 		ldr	r3, [sp, #40]
 5329 2f90 89FDFFEA 		b	.L321
 5330              	.L333:
 5331              	.LVL425:
2627:../uvc.c      ****      		ControlHandle(HueCtlID5);
 5332              		.loc 1 2627 0
 5333 2f94 0500A0E3 		mov	r0, #5
 5334 2f98 FEFFFFEB 		bl	ControlHandle
 5335              	.LVL426:
 5336 2f9c 28309DE5 		ldr	r3, [sp, #40]
 5337 2fa0 85FDFFEA 		b	.L321
 5338              	.L367:
 5339              	.LVL427:
 5340              	.LBE91:
 5341              	.LBE156:
 5342              	.LBB157:
 5343              	.LBB128:
2932:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 5344              		.loc 1 2932 0
 5345 2fa4 1600A0E3 		mov	r0, #22
 5346 2fa8 FEFFFFEB 		bl	ControlHandle
 5347              	.LVL428:
 5348 2fac 28309DE5 		ldr	r3, [sp, #40]
 5349 2fb0 81FDFFEA 		b	.L321
 5350              	.L353:
 5351              	.LVL429:
 5352              	.LBE128:
 5353              	.LBE157:
 5354              	.LBB158:
 5355              	.LBB98:
2728:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 5356              		.loc 1 2728 0
 5357 2fb4 0A00A0E3 		mov	r0, #10
 5358 2fb8 FEFFFFEB 		bl	CTControlHandle
 5359              	.LVL430:
 5360 2fbc 28309DE5 		ldr	r3, [sp, #40]
 5361 2fc0 7DFDFFEA 		b	.L321
 5362              	.L352:
 5363              	.LVL431:
2724:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 5364              		.loc 1 2724 0
 5365 2fc4 0900A0E3 		mov	r0, #9
 5366 2fc8 FEFFFFEB 		bl	CTControlHandle
 5367              	.LVL432:
 5368 2fcc 28309DE5 		ldr	r3, [sp, #40]
 5369 2fd0 79FDFFEA 		b	.L321
 5370              	.L366:
 5371              	.LVL433:
 5372              	.LBE98:
 5373              	.LBE158:
 5374              	.LBB159:
 5375              	.LBB119:
2928:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 5376              		.loc 1 2928 0
 5377 2fd4 1500A0E3 		mov	r0, #21
 5378 2fd8 FEFFFFEB 		bl	ControlHandle
 5379              	.LVL434:
 5380 2fdc 28309DE5 		ldr	r3, [sp, #40]
 5381 2fe0 75FDFFEA 		b	.L321
 5382              	.L338:
 5383              	.LVL435:
 5384              	.LBE119:
 5385              	.LBE159:
 5386              	.LBB160:
 5387              	.LBB96:
2649:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 5388              		.loc 1 2649 0
 5389 2fe4 0E00A0E3 		mov	r0, #14
 5390 2fe8 FEFFFFEB 		bl	ControlHandle
 5391              	.LVL436:
 5392 2fec 28309DE5 		ldr	r3, [sp, #40]
 5393 2ff0 71FDFFEA 		b	.L321
 5394              	.L346:
 5395              	.LVL437:
 5396              	.LBE96:
 5397              	.LBE160:
 5398              	.LBB161:
 5399              	.LBB106:
2696:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 5400              		.loc 1 2696 0
 5401 2ff4 0300A0E3 		mov	r0, #3
 5402 2ff8 FEFFFFEB 		bl	CTControlHandle
 5403              	.LVL438:
 5404 2ffc 28309DE5 		ldr	r3, [sp, #40]
 5405 3000 6DFDFFEA 		b	.L321
 5406              	.LVL439:
 5407              	.L438:
 5408              	.LBE106:
 5409              	.LBE161:
 5410              	.LBB162:
 5411              	.LBB116:
3258:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5412              		.loc 1 3258 0
 5413 3004 0200A0E3 		mov	r0, #2
 5414 3008 58109FE5 		ldr	r1, .L477+72
 5415 300c B6FEFFEA 		b	.L457
 5416              	.LVL440:
 5417              	.L376:
 5418              	.LBE116:
 5419              	.LBE162:
 5420              	.LBB163:
 5421              	.LBB129:
2975:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
 5422              		.loc 1 2975 0
 5423 3010 2100A0E3 		mov	r0, #33
 5424 3014 FEFFFFEB 		bl	ControlHandle
 5425              	.LVL441:
 5426 3018 28309DE5 		ldr	r3, [sp, #40]
 5427 301c 66FDFFEA 		b	.L321
 5428              	.L478:
 5429              		.align	2
 5430              	.L477:
 5431 3020 00000000 		.word	.LANCHOR0
 5432 3024 00000000 		.word	.LANCHOR1
 5433 3028 00000000 		.word	bRequest
 5434 302c 00000000 		.word	wValue
 5435 3030 00000000 		.word	wIndex
 5436 3034 00000000 		.word	glInterStaBuffer
 5437 3038 10050000 		.word	.LC27
 5438 303c 00000000 		.word	glChHandleInterStat
 5439 3040 00000000 		.word	bmReqType
 5440 3044 00000000 		.word	wLength
 5441 3048 94040000 		.word	.LC26
 5442 304c 80000000 		.word	.LANCHOR0+128
 5443 3050 64050000 		.word	.LC29
 5444 3054 E0050000 		.word	.LC32
 5445 3058 B8050000 		.word	.LC31
 5446 305c 68060000 		.word	.LANCHOR1+1640
 5447 3060 74060000 		.word	.LANCHOR1+1652
 5448 3064 30060000 		.word	.LANCHOR1+1584
 5449 3068 5C000000 		.word	.LANCHOR0+92
 5450 306c 8C050000 		.word	.LC30
 5451 3070 34060000 		.word	.LC34
 5452 3074 D8010000 		.word	.LC12
 5453 3078 14060000 		.word	.LANCHOR1+1556
 5454 307c 3C050000 		.word	.LC28
 5455 3080 0C060000 		.word	.LC33
 5456 3084 4C060000 		.word	.LANCHOR1+1612
 5457              	.LBE129:
 5458              	.LBE163:
 5459              		.cfi_endproc
 5460              	.LFE24:
 5462              		.align	2
 5463              		.global	CamDefSet
 5465              	CamDefSet:
 5466              	.LFB4:
1213:../uvc.c      **** {
 5467              		.loc 1 1213 0
 5468              		.cfi_startproc
 5469              		@ args = 0, pretend = 0, frame = 24
 5470              		@ frame_needed = 0, uses_anonymous_args = 0
 5471              	.LVL442:
 5472 3088 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5473              	.LCFI19:
 5474              		.cfi_def_cfa_offset 36
1219:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5475              		.loc 1 1219 0
 5476 308c AC429FE5 		ldr	r4, .L482
 5477              		.cfi_offset 14, -4
 5478              		.cfi_offset 11, -8
 5479              		.cfi_offset 10, -12
 5480              		.cfi_offset 9, -16
 5481              		.cfi_offset 8, -20
 5482              		.cfi_offset 7, -24
 5483              		.cfi_offset 6, -28
 5484              		.cfi_offset 5, -32
 5485              		.cfi_offset 4, -36
1224:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5486              		.loc 1 1224 0
 5487 3090 AC229FE5 		ldr	r2, .L482+4
1221:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5488              		.loc 1 1221 0
 5489 3094 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1213:../uvc.c      **** {
 5490              		.loc 1 1213 0
 5491 3098 2CD04DE2 		sub	sp, sp, #44
 5492              	.LCFI20:
 5493              		.cfi_def_cfa_offset 80
1224:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5494              		.loc 1 1224 0
 5495 309c 1C0092E5 		ldr	r0, [r2, #28]
 5496 30a0 0010E0E3 		mvn	r1, #0
1226:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5497              		.loc 1 1226 0
 5498 30a4 2963A0E1 		mov	r6, r9, lsr #6
1220:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5499              		.loc 1 1220 0
 5500 30a8 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1219:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5501              		.loc 1 1219 0
 5502 30ac 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 5503              	.LVL443:
1224:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5504              		.loc 1 1224 0
 5505 30b0 FEFFFFEB 		bl	_txe_mutex_get
1225:../uvc.c      ****     if(Data1&0x80){
 5506              		.loc 1 1225 0
 5507 30b4 800019E3 		tst	r9, #128
1226:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5508              		.loc 1 1226 0
 5509 30b8 01600612 		andne	r6, r6, #1
 5510 30bc 0660E011 		mvnne	r6, r6
 5511 30c0 3B600612 		andne	r6, r6, #59
 5512 30c4 0660E011 		mvnne	r6, r6
 5513 30c8 FF600612 		andne	r6, r6, #255
 5514              	.LVL444:
1228:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 5515              		.loc 1 1228 0
 5516 30cc C6608603 		orreq	r6, r6, #198
 5517              	.LVL445:
1232:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5518              		.loc 1 1232 0
 5519 30d0 0080A0E3 		mov	r8, #0
 5520 30d4 0A20A0E1 		mov	r2, sl
 5521 30d8 0730A0E1 		mov	r3, r7
 5522 30dc 0110A0E3 		mov	r1, #1
1230:../uvc.c      ****     Data0 = (Data0 << 2);
 5523              		.loc 1 1230 0
 5524 30e0 0951A0E1 		mov	r5, r9, asl #2
1232:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5525              		.loc 1 1232 0
 5526 30e4 58029FE5 		ldr	r0, .L482+4
1235:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5527              		.loc 1 1235 0
 5528 30e8 0190A0E3 		mov	r9, #1
 5529              	.LVL446:
1230:../uvc.c      ****     Data0 = (Data0 << 2);
 5530              		.loc 1 1230 0
 5531 30ec FF5005E2 		and	r5, r5, #255
 5532              	.LVL447:
1232:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5533              		.loc 1 1232 0
 5534 30f0 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5535 30f4 FEFFFFEB 		bl	cmdSet
 5536              	.LVL448:
1235:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5537              		.loc 1 1235 0
 5538 30f8 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 5539 30fc 0910A0E1 		mov	r1, r9
 5540 3100 0730A0E1 		mov	r3, r7
 5541 3104 38029FE5 		ldr	r0, .L482+4
 5542 3108 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 5543 310c FEFFFFEB 		bl	cmdSet
 5544              	.LVL449:
1238:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5545              		.loc 1 1238 0
 5546 3110 0620A0E1 		mov	r2, r6
 5547 3114 0530A0E1 		mov	r3, r5
 5548 3118 28129FE5 		ldr	r1, .L482+8
 5549 311c 0400A0E3 		mov	r0, #4
1237:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5550              		.loc 1 1237 0
 5551 3120 A661C4E5 		strb	r6, [r4, #422]
1236:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5552              		.loc 1 1236 0
 5553 3124 A551C4E5 		strb	r5, [r4, #421]
1238:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5554              		.loc 1 1238 0
 5555 3128 FEFFFFEB 		bl	CyU3PDebugPrint
 5556              	.LVL450:
1243:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5557              		.loc 1 1243 0
 5558 312c BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 5559              	.LVL451:
1244:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5560              		.loc 1 1244 0
 5561 3130 B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 5562 3134 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 5563 3138 0210A0E3 		mov	r1, #2
 5564 313c 00029FE5 		ldr	r0, .L482+4
 5565 3140 00B08DE5 		str	fp, [sp, #0]
 5566 3144 04808DE5 		str	r8, [sp, #4]
 5567 3148 FEFFFFEB 		bl	cmdSet
 5568              	.LVL452:
1246:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5569              		.loc 1 1246 0
 5570 314c 0B20A0E1 		mov	r2, fp
 5571 3150 0530A0E1 		mov	r3, r5
 5572 3154 EC119FE5 		ldr	r1, .L482+8
 5573 3158 0400A0E3 		mov	r0, #4
1245:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5574              		.loc 1 1245 0
 5575 315c BD51C4E5 		strb	r5, [r4, #445]
1246:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5576              		.loc 1 1246 0
 5577 3160 FEFFFFEB 		bl	CyU3PDebugPrint
 5578              	.LVL453:
1251:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5579              		.loc 1 1251 0
 5580 3164 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1250:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5581              		.loc 1 1250 0
 5582 3168 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 5583              	.LVL454:
1252:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5584              		.loc 1 1252 0
 5585 316c 80B047E2 		sub	fp, r7, #128
 5586 3170 FF100BE2 		and	r1, fp, #255
 5587 3174 14108DE5 		str	r1, [sp, #20]
 5588 3178 14C09DE5 		ldr	ip, [sp, #20]
1253:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5589              		.loc 1 1253 0
 5590 317c 760047E2 		sub	r0, r7, #118
1254:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5591              		.loc 1 1254 0
 5592 3180 7EE087E2 		add	lr, r7, #126
1252:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5593              		.loc 1 1252 0
 5594 3184 0630A0E1 		mov	r3, r6
1253:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5595              		.loc 1 1253 0
 5596 3188 18008DE5 		str	r0, [sp, #24]
1252:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5597              		.loc 1 1252 0
 5598 318c 0510A0E3 		mov	r1, #5
 5599 3190 DF20A0E3 		mov	r2, #223
 5600 3194 A8019FE5 		ldr	r0, .L482+4
1254:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5601              		.loc 1 1254 0
 5602 3198 1CE08DE5 		str	lr, [sp, #28]
1252:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5603              		.loc 1 1252 0
 5604 319c 00C08DE5 		str	ip, [sp, #0]
 5605 31a0 04808DE5 		str	r8, [sp, #4]
 5606 31a4 FEFFFFEB 		bl	cmdSet
 5607              	.LVL455:
1253:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5608              		.loc 1 1253 0
 5609 31a8 18A09DE5 		ldr	sl, [sp, #24]
1255:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5610              		.loc 1 1255 0
 5611 31ac 72E087E2 		add	lr, r7, #114
1253:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5612              		.loc 1 1253 0
 5613 31b0 FFC00AE2 		and	ip, sl, #255
 5614 31b4 0630A0E1 		mov	r3, r6
 5615 31b8 0510A0E3 		mov	r1, #5
 5616 31bc DC20A0E3 		mov	r2, #220
 5617 31c0 7C019FE5 		ldr	r0, .L482+4
1255:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5618              		.loc 1 1255 0
 5619 31c4 20E08DE5 		str	lr, [sp, #32]
1253:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5620              		.loc 1 1253 0
 5621 31c8 00C08DE5 		str	ip, [sp, #0]
 5622 31cc 04908DE5 		str	r9, [sp, #4]
 5623 31d0 FEFFFFEB 		bl	cmdSet
1254:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5624              		.loc 1 1254 0
 5625 31d4 1C009DE5 		ldr	r0, [sp, #28]
 5626 31d8 02E0A0E3 		mov	lr, #2
 5627 31dc FFC000E2 		and	ip, r0, #255
 5628 31e0 0630A0E1 		mov	r3, r6
1256:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5629              		.loc 1 1256 0
 5630 31e4 6FA047E2 		sub	sl, r7, #111
1254:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5631              		.loc 1 1254 0
 5632 31e8 0510A0E3 		mov	r1, #5
 5633 31ec DE20A0E3 		mov	r2, #222
 5634 31f0 4C019FE5 		ldr	r0, .L482+4
 5635 31f4 04E08DE5 		str	lr, [sp, #4]
1256:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5636              		.loc 1 1256 0
 5637 31f8 24A08DE5 		str	sl, [sp, #36]
1254:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5638              		.loc 1 1254 0
 5639 31fc 00C08DE5 		str	ip, [sp, #0]
 5640 3200 FEFFFFEB 		bl	cmdSet
1255:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5641              		.loc 1 1255 0
 5642 3204 20A09DE5 		ldr	sl, [sp, #32]
 5643 3208 0630A0E1 		mov	r3, r6
 5644 320c FFC00AE2 		and	ip, sl, #255
 5645 3210 00C08DE5 		str	ip, [sp, #0]
 5646 3214 0510A0E3 		mov	r1, #5
 5647 3218 03C0A0E3 		mov	ip, #3
 5648 321c E020A0E3 		mov	r2, #224
 5649 3220 1C019FE5 		ldr	r0, .L482+4
 5650 3224 04C08DE5 		str	ip, [sp, #4]
 5651 3228 FEFFFFEB 		bl	cmdSet
1256:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5652              		.loc 1 1256 0
 5653 322c 24009DE5 		ldr	r0, [sp, #36]
 5654 3230 04A0A0E3 		mov	sl, #4
 5655 3234 FFC000E2 		and	ip, r0, #255
 5656 3238 0630A0E1 		mov	r3, r6
 5657 323c 0510A0E3 		mov	r1, #5
 5658 3240 DD20A0E3 		mov	r2, #221
 5659 3244 F8009FE5 		ldr	r0, .L482+4
 5660 3248 00C08DE5 		str	ip, [sp, #0]
1257:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5661              		.loc 1 1257 0
 5662 324c 7F7087E2 		add	r7, r7, #127
 5663              	.LVL456:
1256:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5664              		.loc 1 1256 0
 5665 3250 04A08DE5 		str	sl, [sp, #4]
 5666 3254 FEFFFFEB 		bl	cmdSet
1257:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5667              		.loc 1 1257 0
 5668 3258 05E0A0E3 		mov	lr, #5
 5669 325c 0E10A0E1 		mov	r1, lr
 5670 3260 0630A0E1 		mov	r3, r6
 5671 3264 E120A0E3 		mov	r2, #225
 5672 3268 FF6007E2 		and	r6, r7, #255
 5673              	.LVL457:
 5674 326c D0009FE5 		ldr	r0, .L482+4
 5675 3270 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 5676 3274 FEFFFFEB 		bl	cmdSet
 5677              	.LVL458:
1258:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5678              		.loc 1 1258 0
 5679 3278 14C09DE5 		ldr	ip, [sp, #20]
1259:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5680              		.loc 1 1259 0
 5681 327c 24E09DE5 		ldr	lr, [sp, #36]
 5682 3280 1C609DE5 		ldr	r6, [sp, #28]
1258:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5683              		.loc 1 1258 0
 5684 3284 05C2C4E5 		strb	ip, [r4, #517]
1259:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5685              		.loc 1 1259 0
 5686 3288 20C09DE5 		ldr	ip, [sp, #32]
 5687 328c 0B20A0E1 		mov	r2, fp
 5688 3290 18309DE5 		ldr	r3, [sp, #24]
 5689 3294 B0109FE5 		ldr	r1, .L482+12
 5690 3298 0A00A0E1 		mov	r0, sl
 5691 329c 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 5692 32a0 0C708DE5 		str	r7, [sp, #12]
 5693 32a4 FEFFFFEB 		bl	CyU3PDebugPrint
 5694              	.LVL459:
1263:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5695              		.loc 1 1263 0
 5696 32a8 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 5697              	.LVL460:
1264:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5698              		.loc 1 1264 0
 5699 32ac 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 5700              	.LVL461:
1265:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5701              		.loc 1 1265 0
 5702 32b0 0730A0E1 		mov	r3, r7
 5703 32b4 0610A0E3 		mov	r1, #6
 5704 32b8 8520A0E3 		mov	r2, #133
 5705 32bc 80009FE5 		ldr	r0, .L482+4
 5706 32c0 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5707 32c4 FEFFFFEB 		bl	cmdSet
1266:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5708              		.loc 1 1266 0
 5709 32c8 0730A0E1 		mov	r3, r7
 5710 32cc 0610A0E3 		mov	r1, #6
 5711 32d0 8620A0E3 		mov	r2, #134
 5712 32d4 68009FE5 		ldr	r0, .L482+4
 5713 32d8 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 5714 32dc FEFFFFEB 		bl	cmdSet
1268:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5715              		.loc 1 1268 0
 5716 32e0 0620A0E1 		mov	r2, r6
 5717 32e4 0530A0E1 		mov	r3, r5
 5718 32e8 58109FE5 		ldr	r1, .L482+8
 5719 32ec 0A00A0E1 		mov	r0, sl
1267:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5720              		.loc 1 1267 0
 5721 32f0 1D62C4E5 		strb	r6, [r4, #541]
1268:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5722              		.loc 1 1268 0
 5723 32f4 FEFFFFEB 		bl	CyU3PDebugPrint
 5724              	.LVL462:
1273:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5725              		.loc 1 1273 0
 5726 32f8 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 5727              	.LVL463:
1274:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5728              		.loc 1 1274 0
 5729 32fc 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 5730 3300 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 5731 3304 0710A0E3 		mov	r1, #7
 5732 3308 34009FE5 		ldr	r0, .L482+4
 5733 330c 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5734 3310 FEFFFFEB 		bl	cmdSet
 5735              	.LVL464:
1276:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5736              		.loc 1 1276 0
 5737 3314 0530A0E1 		mov	r3, r5
 5738 3318 0A00A0E1 		mov	r0, sl
 5739 331c 24109FE5 		ldr	r1, .L482+8
 5740 3320 0620A0E1 		mov	r2, r6
1275:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5741              		.loc 1 1275 0
 5742 3324 3552C4E5 		strb	r5, [r4, #565]
1276:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5743              		.loc 1 1276 0
 5744 3328 FEFFFFEB 		bl	CyU3PDebugPrint
1278:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5745              		.loc 1 1278 0
 5746 332c 10309FE5 		ldr	r3, .L482+4
 5747 3330 1C0093E5 		ldr	r0, [r3, #28]
1281:../uvc.c      **** }
 5748              		.loc 1 1281 0
 5749 3334 2CD08DE2 		add	sp, sp, #44
 5750 3338 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1278:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5751              		.loc 1 1278 0
 5752 333c FEFFFFEA 		b	_txe_mutex_put
 5753              	.L483:
 5754              		.align	2
 5755              	.L482:
 5756 3340 00000000 		.word	.LANCHOR1
 5757 3344 00000000 		.word	cmdQu
 5758 3348 68060000 		.word	.LC35
 5759 334c 88060000 		.word	.LC36
 5760              		.cfi_endproc
 5761              	.LFE4:
 5763              		.align	2
 5764              		.global	CyFxUVCAddHeader
 5766              	CyFxUVCAddHeader:
 5767              	.LFB5:
1289:../uvc.c      **** {
 5768              		.loc 1 1289 0
 5769              		.cfi_startproc
 5770              		@ args = 0, pretend = 0, frame = 0
 5771              		@ frame_needed = 0, uses_anonymous_args = 0
 5772              	.LVL465:
 5773 3350 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5774              	.LCFI21:
 5775              		.cfi_def_cfa_offset 16
1289:../uvc.c      **** {
 5776              		.loc 1 1289 0
 5777 3354 0040A0E1 		mov	r4, r0
 5778              		.cfi_offset 14, -4
 5779              		.cfi_offset 5, -8
 5780              		.cfi_offset 4, -12
 5781              		.cfi_offset 3, -16
 5782 3358 0150A0E1 		mov	r5, r1
1291:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 5783              		.loc 1 1291 0
 5784 335c 30009FE5 		ldr	r0, .L486
 5785              	.LVL466:
 5786 3360 0010E0E3 		mvn	r1, #0
 5787              	.LVL467:
 5788 3364 FEFFFFEB 		bl	_txe_mutex_get
1292:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5789              		.loc 1 1292 0
 5790 3368 0400A0E1 		mov	r0, r4
 5791 336c 24109FE5 		ldr	r1, .L486+4
 5792 3370 0C20A0E3 		mov	r2, #12
 5793 3374 FEFFFFEB 		bl	CyU3PMemCopy
1293:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 5794              		.loc 1 1293 0
 5795 3378 14009FE5 		ldr	r0, .L486
 5796 337c FEFFFFEB 		bl	_txe_mutex_put
1296:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 5797              		.loc 1 1296 0
 5798 3380 020015E3 		tst	r5, #2
1298:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 5799              		.loc 1 1298 0
 5800 3384 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5801 3388 02308313 		orrne	r3, r3, #2
 5802 338c 0130C415 		strneb	r3, [r4, #1]
 5803 3390 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 5804              	.L487:
 5805              		.align	2
 5806              	.L486:
 5807 3394 00000000 		.word	imgHdMux
 5808 3398 80040000 		.word	.LANCHOR1+1152
 5809              		.cfi_endproc
 5810              	.LFE5:
 5812              		.align	2
 5813              		.global	CyFxAppErrorHandler
 5815              	CyFxAppErrorHandler:
 5816              	.LFB6:
1308:../uvc.c      **** {
 5817              		.loc 1 1308 0
 5818              		.cfi_startproc
 5819              		@ args = 0, pretend = 0, frame = 0
 5820              		@ frame_needed = 0, uses_anonymous_args = 0
 5821              	.LVL468:
 5822 339c 08402DE9 		stmfd	sp!, {r3, lr}
 5823              	.LCFI22:
 5824              		.cfi_def_cfa_offset 8
 5825              	.LVL469:
 5826              	.L489:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5827              		.loc 1 1318 0 discriminator 1
 5828 33a0 10109FE5 		ldr	r1, .L490
 5829 33a4 0400A0E3 		mov	r0, #4
 5830              		.cfi_offset 14, -4
 5831              		.cfi_offset 3, -8
 5832 33a8 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 5833              		.loc 1 1319 0 discriminator 1
 5834 33ac FA0FA0E3 		mov	r0, #1000
 5835 33b0 FEFFFFEB 		bl	_tx_thread_sleep
 5836 33b4 F9FFFFEA 		b	.L489
 5837              	.L491:
 5838              		.align	2
 5839              	.L490:
 5840 33b8 D8010000 		.word	.LC12
 5841              		.cfi_endproc
 5842              	.LFE6:
 5844              		.align	2
 5845              		.global	UVCAppThread_Entry
 5847              	UVCAppThread_Entry:
 5848              	.LFB18:
2295:../uvc.c      **** {
 5849              		.loc 1 2295 0
 5850              		.cfi_startproc
 5851              		@ args = 0, pretend = 0, frame = 176
 5852              		@ frame_needed = 0, uses_anonymous_args = 0
 5853              	.LVL470:
 5854 33bc F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 5855              	.LCFI23:
 5856              		.cfi_def_cfa_offset 28
 5857 33c0 BCD04DE2 		sub	sp, sp, #188
 5858              	.LCFI24:
 5859              		.cfi_def_cfa_offset 216
 5860              	.LBB216:
 5861              	.LBB217:
1751:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 5862              		.loc 1 1751 0
 5863              		.cfi_offset 14, -4
 5864              		.cfi_offset 10, -8
 5865              		.cfi_offset 8, -12
 5866              		.cfi_offset 7, -16
 5867              		.cfi_offset 6, -20
 5868              		.cfi_offset 5, -24
 5869              		.cfi_offset 4, -28
 5870 33c4 FEFFFFEB 		bl	CyU3PUartInit
 5871              	.LVL471:
1752:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5872              		.loc 1 1752 0
 5873 33c8 004050E2 		subs	r4, r0, #0
 5874 33cc 0400000A 		beq	.L493
1754:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 5875              		.loc 1 1754 0
 5876 33d0 0400A0E3 		mov	r0, #4
 5877              	.LVL472:
 5878 33d4 501B9FE5 		ldr	r1, .L599
 5879 33d8 FEFFFFEB 		bl	CyU3PDebugPrint
1755:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5880              		.loc 1 1755 0
 5881 33dc 0400A0E1 		mov	r0, r4
 5882 33e0 FEFFFFEB 		bl	CyFxAppErrorHandler
 5883              	.L493:
1759:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5884              		.loc 1 1759 0
 5885 33e4 44CB9FE5 		ldr	ip, .L599+4
1761:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5886              		.loc 1 1761 0
 5887 33e8 0030A0E3 		mov	r3, #0
1760:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5888              		.loc 1 1760 0
 5889 33ec 0120A0E3 		mov	r2, #1
1768:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5890              		.loc 1 1768 0
 5891 33f0 50008DE2 		add	r0, sp, #80
 5892 33f4 0310A0E1 		mov	r1, r3
1759:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5893              		.loc 1 1759 0
 5894 33f8 60C08DE5 		str	ip, [sp, #96]
1760:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5895              		.loc 1 1760 0
 5896 33fc 6420CDE5 		strb	r2, [sp, #100]
1761:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5897              		.loc 1 1761 0
 5898 3400 6530CDE5 		strb	r3, [sp, #101]
1762:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 5899              		.loc 1 1762 0
 5900 3404 50208DE5 		str	r2, [sp, #80]
1763:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 5901              		.loc 1 1763 0
 5902 3408 54308DE5 		str	r3, [sp, #84]
1764:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 5903              		.loc 1 1764 0
 5904 340c 58308DE5 		str	r3, [sp, #88]
1765:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 5905              		.loc 1 1765 0
 5906 3410 5C208DE5 		str	r2, [sp, #92]
1768:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5907              		.loc 1 1768 0
 5908 3414 FEFFFFEB 		bl	CyU3PUartSetConfig
 5909              	.LVL473:
1769:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5910              		.loc 1 1769 0
 5911 3418 000050E3 		cmp	r0, #0
 5912 341c 0000000A 		beq	.L494
1771:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5913              		.loc 1 1771 0
 5914 3420 FEFFFFEB 		bl	CyFxAppErrorHandler
 5915              	.LVL474:
 5916              	.L494:
1775:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 5917              		.loc 1 1775 0
 5918 3424 0000E0E3 		mvn	r0, #0
 5919 3428 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 5920              	.LVL475:
1776:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5921              		.loc 1 1776 0
 5922 342c 000050E3 		cmp	r0, #0
 5923 3430 0000000A 		beq	.L495
1778:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5924              		.loc 1 1778 0
 5925 3434 FEFFFFEB 		bl	CyFxAppErrorHandler
 5926              	.LVL476:
 5927              	.L495:
1782:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 5928              		.loc 1 1782 0
 5929 3438 0300A0E3 		mov	r0, #3
 5930 343c 0410A0E3 		mov	r1, #4
 5931 3440 FEFFFFEB 		bl	CyU3PDebugInit
 5932              	.LVL477:
1783:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5933              		.loc 1 1783 0
 5934 3444 000050E3 		cmp	r0, #0
 5935 3448 0000000A 		beq	.L496
1785:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5936              		.loc 1 1785 0
 5937 344c FEFFFFEB 		bl	CyFxAppErrorHandler
 5938              	.LVL478:
 5939              	.L496:
1789:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 5940              		.loc 1 1789 0
 5941 3450 0000A0E3 		mov	r0, #0
 5942 3454 FEFFFFEB 		bl	CyU3PDebugPreamble
 5943              	.LVL479:
 5944              	.LBE217:
 5945              	.LBE216:
2311:../uvc.c      **** 		CyU3PThreadSleep(500);
 5946              		.loc 1 2311 0
 5947 3458 7D0FA0E3 		mov	r0, #500
 5948 345c FEFFFFEB 		bl	_tx_thread_sleep
 5949              	.LVL480:
 5950 3460 7D0FA0E3 		mov	r0, #500
 5951 3464 FEFFFFEB 		bl	_tx_thread_sleep
 5952 3468 7D0FA0E3 		mov	r0, #500
 5953 346c FEFFFFEB 		bl	_tx_thread_sleep
 5954 3470 7D0FA0E3 		mov	r0, #500
 5955 3474 FEFFFFEB 		bl	_tx_thread_sleep
 5956 3478 7D0FA0E3 		mov	r0, #500
 5957 347c FEFFFFEB 		bl	_tx_thread_sleep
 5958 3480 7D0FA0E3 		mov	r0, #500
 5959 3484 FEFFFFEB 		bl	_tx_thread_sleep
 5960              	.LBB218:
 5961              	.LBB219:
1799:../uvc.c      ****     status = CyU3PI2cInit ();
 5962              		.loc 1 1799 0
 5963 3488 FEFFFFEB 		bl	CyU3PI2cInit
 5964              	.LVL481:
1800:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 5965              		.loc 1 1800 0
 5966 348c 004050E2 		subs	r4, r0, #0
 5967 3490 0400000A 		beq	.L497
1802:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 5968              		.loc 1 1802 0
 5969 3494 0400A0E3 		mov	r0, #4
 5970              	.LVL482:
 5971 3498 941A9FE5 		ldr	r1, .L599+8
 5972 349c FEFFFFEB 		bl	CyU3PDebugPrint
1803:../uvc.c      ****         CyFxAppErrorHandler (status);
 5973              		.loc 1 1803 0
 5974 34a0 0400A0E1 		mov	r0, r4
 5975 34a4 FEFFFFEB 		bl	CyFxAppErrorHandler
 5976              	.L497:
1807:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5977              		.loc 1 1807 0
 5978 34a8 886A9FE5 		ldr	r6, .L599+12
1808:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5979              		.loc 1 1808 0
 5980 34ac 0050A0E3 		mov	r5, #0
1809:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5981              		.loc 1 1809 0
 5982 34b0 0040E0E3 		mvn	r4, #0
 5983              	.LVL483:
1812:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5984              		.loc 1 1812 0
 5985 34b4 8C008DE2 		add	r0, sp, #140
 5986 34b8 0510A0E1 		mov	r1, r5
1809:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5987              		.loc 1 1809 0
 5988 34bc 94408DE5 		str	r4, [sp, #148]
1810:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 5989              		.loc 1 1810 0
 5990 34c0 B849CDE1 		strh	r4, [sp, #152]	@ movhi
1807:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5991              		.loc 1 1807 0
 5992 34c4 8C608DE5 		str	r6, [sp, #140]
1808:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5993              		.loc 1 1808 0
 5994 34c8 90508DE5 		str	r5, [sp, #144]
1812:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5995              		.loc 1 1812 0
 5996 34cc FEFFFFEB 		bl	CyU3PI2cSetConfig
 5997              	.LVL484:
1813:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 5998              		.loc 1 1813 0
 5999 34d0 004050E2 		subs	r4, r0, #0
 6000 34d4 0400000A 		beq	.L498
1815:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 6001              		.loc 1 1815 0
 6002 34d8 0400A0E3 		mov	r0, #4
 6003              	.LVL485:
 6004 34dc 581A9FE5 		ldr	r1, .L599+16
 6005 34e0 FEFFFFEB 		bl	CyU3PDebugPrint
1816:../uvc.c      ****         CyFxAppErrorHandler (status);
 6006              		.loc 1 1816 0
 6007 34e4 0400A0E1 		mov	r0, r4
 6008 34e8 FEFFFFEB 		bl	CyFxAppErrorHandler
 6009              	.L498:
 6010              	.LBE219:
 6011              	.LBE218:
 6012              	.LBB220:
 6013              	.LBB223:
1886:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 6014              		.loc 1 1886 0
 6015 34ec 4C4A9FE5 		ldr	r4, .L599+20
 6016              	.LVL486:
 6017 34f0 2820A0E3 		mov	r2, #40
 6018 34f4 0010A0E3 		mov	r1, #0
 6019 34f8 0400A0E1 		mov	r0, r4
 6020 34fc FEFFFFEB 		bl	_txe_event_flags_create
 6021              	.LVL487:
1887:../uvc.c      ****     if (apiRetStatus != 0)
 6022              		.loc 1 1887 0
 6023 3500 002050E2 		subs	r2, r0, #0
 6024 3504 F800001A 		bne	.L573
1901:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 6025              		.loc 1 1901 0
 6026 3508 0260A0E3 		mov	r6, #2
1908:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6027              		.loc 1 1908 0
 6028 350c 0210A0E1 		mov	r1, r2
1897:../uvc.c      ****     isUsbConnected = CyFalse;
 6029              		.loc 1 1897 0
 6030 3510 302084E5 		str	r2, [r4, #48]
1898:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 6031              		.loc 1 1898 0
 6032 3514 442084E5 		str	r2, [r4, #68]
1904:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6033              		.loc 1 1904 0
 6034 3518 0370A0E3 		mov	r7, #3
1908:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6035              		.loc 1 1908 0
 6036 351c 9C008DE2 		add	r0, sp, #156
 6037              	.LVL488:
1903:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 6038              		.loc 1 1903 0
 6039 3520 A420CDE5 		strb	r2, [sp, #164]
1905:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6040              		.loc 1 1905 0
 6041 3524 A0208DE5 		str	r2, [sp, #160]
1901:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 6042              		.loc 1 1901 0
 6043 3528 9C60CDE5 		strb	r6, [sp, #156]
1902:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6044              		.loc 1 1902 0
 6045 352c 9D60CDE5 		strb	r6, [sp, #157]
1904:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6046              		.loc 1 1904 0
 6047 3530 A570CDE5 		strb	r7, [sp, #165]
1908:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6048              		.loc 1 1908 0
 6049 3534 FEFFFFEB 		bl	CyU3PGpioInit
 6050              	.LVL489:
1909:../uvc.c      ****     if (apiRetStatus != 0)
 6051              		.loc 1 1909 0
 6052 3538 002050E2 		subs	r2, r0, #0
 6053 353c FC00001A 		bne	.L574
1917:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 6054              		.loc 1 1917 0
 6055 3540 1600A0E3 		mov	r0, #22
 6056              	.LVL490:
 6057 3544 0110A0E3 		mov	r1, #1
 6058 3548 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6059              	.LVL491:
1918:../uvc.c      ****     if (apiRetStatus != 0)
 6060              		.loc 1 1918 0
 6061 354c 002050E2 		subs	r2, r0, #0
 6062 3550 EE00001A 		bne	.L575
1923:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 6063              		.loc 1 1923 0
 6064 3554 1400A0E3 		mov	r0, #20
 6065              	.LVL492:
 6066 3558 0110A0E3 		mov	r1, #1
 6067 355c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6068              	.LVL493:
1924:../uvc.c      ****     if (apiRetStatus != 0)
 6069              		.loc 1 1924 0
 6070 3560 002050E2 		subs	r2, r0, #0
 6071 3564 FB00001A 		bne	.L576
1929:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 6072              		.loc 1 1929 0
 6073 3568 1800A0E3 		mov	r0, #24
 6074              	.LVL494:
 6075 356c 0110A0E3 		mov	r1, #1
 6076 3570 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6077              	.LVL495:
1930:../uvc.c      ****     if (apiRetStatus != 0)
 6078              		.loc 1 1930 0
 6079 3574 002050E2 		subs	r2, r0, #0
 6080 3578 D601001A 		bne	.L577
1937:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6081              		.loc 1 1937 0
 6082 357c 0150A0E3 		mov	r5, #1
1942:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6083              		.loc 1 1942 0
 6084 3580 1600A0E3 		mov	r0, #22
 6085              	.LVL496:
 6086 3584 68108DE2 		add	r1, sp, #104
1940:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6087              		.loc 1 1940 0
 6088 3588 74208DE5 		str	r2, [sp, #116]
1941:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6089              		.loc 1 1941 0
 6090 358c 7820CDE5 		strb	r2, [sp, #120]
1937:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6091              		.loc 1 1937 0
 6092 3590 68508DE5 		str	r5, [sp, #104]
1938:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6093              		.loc 1 1938 0
 6094 3594 6C508DE5 		str	r5, [sp, #108]
1939:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6095              		.loc 1 1939 0
 6096 3598 70508DE5 		str	r5, [sp, #112]
1942:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6097              		.loc 1 1942 0
 6098 359c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6099              	.LVL497:
1943:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6100              		.loc 1 1943 0
 6101 35a0 002050E2 		subs	r2, r0, #0
 6102 35a4 C201001A 		bne	.L578
1956:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6103              		.loc 1 1956 0
 6104 35a8 1400A0E3 		mov	r0, #20
 6105              	.LVL498:
 6106 35ac 68108DE2 		add	r1, sp, #104
1954:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6107              		.loc 1 1954 0
 6108 35b0 74208DE5 		str	r2, [sp, #116]
1955:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6109              		.loc 1 1955 0
 6110 35b4 7820CDE5 		strb	r2, [sp, #120]
1951:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6111              		.loc 1 1951 0
 6112 35b8 68508DE5 		str	r5, [sp, #104]
1952:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6113              		.loc 1 1952 0
 6114 35bc 6C508DE5 		str	r5, [sp, #108]
1953:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6115              		.loc 1 1953 0
 6116 35c0 70508DE5 		str	r5, [sp, #112]
1956:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6117              		.loc 1 1956 0
 6118 35c4 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6119              	.LVL499:
1957:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6120              		.loc 1 1957 0
 6121 35c8 002050E2 		subs	r2, r0, #0
 6122 35cc CA01001A 		bne	.L579
1970:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6123              		.loc 1 1970 0
 6124 35d0 1800A0E3 		mov	r0, #24
 6125              	.LVL500:
 6126 35d4 68108DE2 		add	r1, sp, #104
1965:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 6127              		.loc 1 1965 0
 6128 35d8 68208DE5 		str	r2, [sp, #104]
1966:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6129              		.loc 1 1966 0
 6130 35dc 6C208DE5 		str	r2, [sp, #108]
1967:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 6131              		.loc 1 1967 0
 6132 35e0 70208DE5 		str	r2, [sp, #112]
1969:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6133              		.loc 1 1969 0
 6134 35e4 7820CDE5 		strb	r2, [sp, #120]
1968:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 6135              		.loc 1 1968 0
 6136 35e8 74508DE5 		str	r5, [sp, #116]
1970:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6137              		.loc 1 1970 0
 6138 35ec FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6139              	.LVL501:
1971:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6140              		.loc 1 1971 0
 6141 35f0 002050E2 		subs	r2, r0, #0
 6142 35f4 A501001A 		bne	.L580
1983:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 6143              		.loc 1 1983 0
 6144 35f8 0500A0E1 		mov	r0, r5
 6145              	.LVL502:
 6146 35fc 7C108DE2 		add	r1, sp, #124
1980:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6147              		.loc 1 1980 0
 6148 3600 84208DE5 		str	r2, [sp, #132]
1981:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 6149              		.loc 1 1981 0
 6150 3604 80208DE5 		str	r2, [sp, #128]
1978:../uvc.c      ****     pibclock.clkDiv      = 2;
 6151              		.loc 1 1978 0
 6152 3608 BC67CDE1 		strh	r6, [sp, #124]	@ movhi
1979:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6153              		.loc 1 1979 0
 6154 360c 8870CDE5 		strb	r7, [sp, #136]
1983:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 6155              		.loc 1 1983 0
 6156 3610 FEFFFFEB 		bl	CyU3PPibInit
 6157              	.LVL503:
1984:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6158              		.loc 1 1984 0
 6159 3614 002050E2 		subs	r2, r0, #0
 6160 3618 9301001A 		bne	.L581
1991:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 6161              		.loc 1 1991 0
 6162 361c 20099FE5 		ldr	r0, .L599+24
 6163              	.LVL504:
 6164 3620 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 6165              	.LVL505:
1999:../uvc.c      ****     SensorReset ();
 6166              		.loc 1 1999 0
 6167 3624 FEFFFFEB 		bl	SensorReset
2000:../uvc.c      ****     CyU3PThreadSleep(5000);
 6168              		.loc 1 2000 0
 6169 3628 18099FE5 		ldr	r0, .L599+28
 6170 362c FEFFFFEB 		bl	_tx_thread_sleep
2004:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 6171              		.loc 1 2004 0
 6172 3630 FEFFFFEB 		bl	CyU3PUsbStart
 6173              	.LVL506:
2005:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6174              		.loc 1 2005 0
 6175 3634 002050E2 		subs	r2, r0, #0
 6176 3638 8201001A 		bne	.L582
2011:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 6177              		.loc 1 2011 0
 6178 363c 0010A0E3 		mov	r1, #0
 6179 3640 04099FE5 		ldr	r0, .L599+32
 6180              	.LVL507:
 6181 3644 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 6182              	.LVL508:
2014:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 6183              		.loc 1 2014 0
 6184 3648 00099FE5 		ldr	r0, .L599+36
 6185 364c FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
2020:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 6186              		.loc 1 2020 0
 6187 3650 0010A0E3 		mov	r1, #0
 6188 3654 F8289FE5 		ldr	r2, .L599+40
 6189 3658 0100A0E3 		mov	r0, #1
 6190 365c FEFFFFEB 		bl	CyU3PUsbSetDesc
2021:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 6191              		.loc 1 2021 0
 6192 3660 0000A0E3 		mov	r0, #0
 6193 3664 0010A0E1 		mov	r1, r0
 6194 3668 E8289FE5 		ldr	r2, .L599+44
 6195 366c FEFFFFEB 		bl	CyU3PUsbSetDesc
2024:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 6196              		.loc 1 2024 0
 6197 3670 0010A0E3 		mov	r1, #0
 6198 3674 E0289FE5 		ldr	r2, .L599+48
 6199 3678 0200A0E3 		mov	r0, #2
 6200 367c FEFFFFEB 		bl	CyU3PUsbSetDesc
2025:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 6201              		.loc 1 2025 0
 6202 3680 0010A0E3 		mov	r1, #0
 6203 3684 D4289FE5 		ldr	r2, .L599+52
 6204 3688 0700A0E3 		mov	r0, #7
 6205 368c FEFFFFEB 		bl	CyU3PUsbSetDesc
2028:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 6206              		.loc 1 2028 0
 6207 3690 0010A0E3 		mov	r1, #0
 6208 3694 C8289FE5 		ldr	r2, .L599+56
 6209 3698 0400A0E3 		mov	r0, #4
 6210 369c FEFFFFEB 		bl	CyU3PUsbSetDesc
2029:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 6211              		.loc 1 2029 0
 6212 36a0 0010A0E3 		mov	r1, #0
 6213 36a4 BC289FE5 		ldr	r2, .L599+60
 6214 36a8 0300A0E3 		mov	r0, #3
 6215 36ac FEFFFFEB 		bl	CyU3PUsbSetDesc
2030:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 6216              		.loc 1 2030 0
 6217 36b0 0010A0E3 		mov	r1, #0
 6218 36b4 B0289FE5 		ldr	r2, .L599+64
 6219 36b8 0600A0E3 		mov	r0, #6
 6220 36bc FEFFFFEB 		bl	CyU3PUsbSetDesc
2033:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 6221              		.loc 1 2033 0
 6222 36c0 0010A0E3 		mov	r1, #0
 6223 36c4 A4289FE5 		ldr	r2, .L599+68
 6224 36c8 0500A0E3 		mov	r0, #5
 6225 36cc FEFFFFEB 		bl	CyU3PUsbSetDesc
2034:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 6226              		.loc 1 2034 0
 6227 36d0 0110A0E3 		mov	r1, #1
 6228 36d4 98289FE5 		ldr	r2, .L599+72
 6229 36d8 0500A0E3 		mov	r0, #5
 6230 36dc FEFFFFEB 		bl	CyU3PUsbSetDesc
2035:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 6231              		.loc 1 2035 0
 6232 36e0 0210A0E3 		mov	r1, #2
 6233 36e4 8C289FE5 		ldr	r2, .L599+76
 6234 36e8 0500A0E3 		mov	r0, #5
 6235 36ec FEFFFFEB 		bl	CyU3PUsbSetDesc
2045:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6236              		.loc 1 2045 0
 6237 36f0 0080A0E3 		mov	r8, #0
2042:../uvc.c      ****     endPointConfig.enable   = 1;
 6238              		.loc 1 2042 0
 6239 36f4 0150A0E3 		mov	r5, #1
2044:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6240              		.loc 1 2044 0
 6241 36f8 4070A0E3 		mov	r7, #64	@ movhi
2048:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6242              		.loc 1 2048 0
 6243 36fc 8200A0E3 		mov	r0, #130
 6244 3700 A8108DE2 		add	r1, sp, #168
2043:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6245              		.loc 1 2043 0
 6246 3704 03A0A0E3 		mov	sl, #3
2044:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6247              		.loc 1 2044 0
 6248 3708 B07BCDE1 		strh	r7, [sp, #176]	@ movhi
2042:../uvc.c      ****     endPointConfig.enable   = 1;
 6249              		.loc 1 2042 0
 6250 370c A8508DE5 		str	r5, [sp, #168]
2043:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6251              		.loc 1 2043 0
 6252 3710 ACA0CDE5 		strb	sl, [sp, #172]
2045:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6253              		.loc 1 2045 0
 6254 3714 B380CDE5 		strb	r8, [sp, #179]
2046:../uvc.c      ****     endPointConfig.streams  = 0;
 6255              		.loc 1 2046 0
 6256 3718 BE8ACDE1 		strh	r8, [sp, #174]	@ movhi
2047:../uvc.c      ****     endPointConfig.burstLen = 1;
 6257              		.loc 1 2047 0
 6258 371c B250CDE5 		strb	r5, [sp, #178]
2048:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6259              		.loc 1 2048 0
 6260 3720 FEFFFFEB 		bl	CyU3PSetEpConfig
 6261              	.LVL509:
2046:../uvc.c      ****     endPointConfig.streams  = 0;
 6262              		.loc 1 2046 0
 6263 3724 0870A0E1 		mov	r7, r8	@ movhi
2049:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6264              		.loc 1 2049 0
 6265 3728 003050E2 		subs	r3, r0, #0
 6266 372c 3B01001A 		bne	.L583
2059:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6267              		.loc 1 2059 0
 6268 3730 44C89FE5 		ldr	ip, .L599+80
2060:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6269              		.loc 1 2060 0
 6270 3734 44E89FE5 		ldr	lr, .L599+84
2057:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6271              		.loc 1 2057 0
 6272 3738 016BA0E3 		mov	r6, #1024	@ movhi
2066:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6273              		.loc 1 2066 0
 6274 373c 1080A0E3 		mov	r8, #16
2068:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6275              		.loc 1 2068 0
 6276 3740 3C089FE5 		ldr	r0, .L599+88
 6277              	.LVL510:
 6278 3744 0410A0E3 		mov	r1, #4
 6279 3748 34208DE2 		add	r2, sp, #52
2057:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6280              		.loc 1 2057 0
 6281 374c B463CDE1 		strh	r6, [sp, #52]	@ movhi
2058:../uvc.c      ****     dmaInterConfig.count          = 1;
 6282              		.loc 1 2058 0
 6283 3750 B653CDE1 		strh	r5, [sp, #54]	@ movhi
2059:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6284              		.loc 1 2059 0
 6285 3754 B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
2060:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6286              		.loc 1 2060 0
 6287 3758 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
2061:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 6288              		.loc 1 2061 0
 6289 375c BC33CDE1 		strh	r3, [sp, #60]	@ movhi
2062:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 6290              		.loc 1 2062 0
 6291 3760 BE33CDE1 		strh	r3, [sp, #62]	@ movhi
2063:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 6292              		.loc 1 2063 0
 6293 3764 B034CDE1 		strh	r3, [sp, #64]	@ movhi
2064:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 6294              		.loc 1 2064 0
 6295 3768 B234CDE1 		strh	r3, [sp, #66]	@ movhi
2065:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6296              		.loc 1 2065 0
 6297 376c 4470CDE5 		strb	r7, [sp, #68]
2066:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6298              		.loc 1 2066 0
 6299 3770 48808DE5 		str	r8, [sp, #72]
2067:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6300              		.loc 1 2067 0
 6301 3774 4C308DE5 		str	r3, [sp, #76]
2068:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6302              		.loc 1 2068 0
 6303 3778 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6304              	.LVL511:
2070:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6305              		.loc 1 2070 0
 6306 377c 006050E2 		subs	r6, r0, #0
 6307 3780 DF00001A 		bne	.L584
2077:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6308              		.loc 1 2077 0
 6309 3784 010BA0E3 		mov	r0, #1024
 6310              	.LVL512:
 6311 3788 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6312 378c F4179FE5 		ldr	r1, .L599+92
2078:../uvc.c      ****     if (glInterStaBuffer == 0)
 6313              		.loc 1 2078 0
 6314 3790 000050E3 		cmp	r0, #0
2077:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6315              		.loc 1 2077 0
 6316 3794 000081E5 		str	r0, [r1, #0]
2078:../uvc.c      ****     if (glInterStaBuffer == 0)
 6317              		.loc 1 2078 0
 6318 3798 D000000A 		beq	.L585
2085:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
 6319              		.loc 1 2085 0
 6320 379c 0610A0E1 		mov	r1, r6
 6321 37a0 0620A0E1 		mov	r2, r6
 6322 37a4 3830A0E3 		mov	r3, #56
 6323 37a8 DC079FE5 		ldr	r0, .L599+96
 6324 37ac FEFFFFEB 		bl	_txe_mutex_create
2087:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6325              		.loc 1 2087 0
 6326 37b0 0430A0E3 		mov	r3, #4	@ movhi
 6327 37b4 BE30CDE1 		strh	r3, [sp, #14]	@ movhi
2090:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6328              		.loc 1 2090 0
 6329 37b8 D0379FE5 		ldr	r3, .L599+100
2086:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6330              		.loc 1 2086 0
 6331 37bc 01C9A0E3 		mov	ip, #16384	@ movhi
 6332 37c0 BCC0CDE1 		strh	ip, [sp, #12]	@ movhi
2089:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6333              		.loc 1 2089 0
 6334 37c4 01CCA0E3 		mov	ip, #256	@ movhi
 6335 37c8 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
2090:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6336              		.loc 1 2090 0
 6337 37cc B431CDE1 		strh	r3, [sp, #20]	@ movhi
2091:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6338              		.loc 1 2091 0
 6339 37d0 BCC79FE5 		ldr	ip, .L599+104
2093:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6340              		.loc 1 2093 0
 6341 37d4 0C30A0E3 		mov	r3, #12	@ movhi
 6342 37d8 B432CDE1 		strh	r3, [sp, #36]	@ movhi
2098:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6343              		.loc 1 2098 0
 6344 37dc B4379FE5 		ldr	r3, .L599+108
2099:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6345              		.loc 1 2099 0
 6346 37e0 0C208DE2 		add	r2, sp, #12
2091:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6347              		.loc 1 2091 0
 6348 37e4 BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
2096:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6349              		.loc 1 2096 0
 6350 37e8 2A70CDE5 		strb	r7, [sp, #42]
2094:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6351              		.loc 1 2094 0
 6352 37ec 04C0A0E3 		mov	ip, #4	@ movhi
2088:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6353              		.loc 1 2088 0
 6354 37f0 02A0A0E3 		mov	sl, #2	@ movhi
2099:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6355              		.loc 1 2099 0
 6356 37f4 A0079FE5 		ldr	r0, .L599+112
 6357 37f8 0710A0E3 		mov	r1, #7
2097:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6358              		.loc 1 2097 0
 6359 37fc 1870A0E3 		mov	r7, #24
2088:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6360              		.loc 1 2088 0
 6361 3800 B0A1CDE1 		strh	sl, [sp, #16]	@ movhi
2092:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6362              		.loc 1 2092 0
 6363 3804 B262CDE1 		strh	r6, [sp, #34]	@ movhi
2094:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6364              		.loc 1 2094 0
 6365 3808 B6C2CDE1 		strh	ip, [sp, #38]	@ movhi
2095:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6366              		.loc 1 2095 0
 6367 380c B862CDE1 		strh	r6, [sp, #40]	@ movhi
2097:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6368              		.loc 1 2097 0
 6369 3810 2C708DE5 		str	r7, [sp, #44]
2098:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6370              		.loc 1 2098 0
 6371 3814 30308DE5 		str	r3, [sp, #48]
2099:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6372              		.loc 1 2099 0
 6373 3818 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6374              	.LVL513:
2101:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6375              		.loc 1 2101 0
 6376 381c 002050E2 		subs	r2, r0, #0
 6377 3820 A500001A 		bne	.L586
2192:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 6378              		.loc 1 2192 0
 6379 3824 0500A0E1 		mov	r0, r5
 6380              	.LVL514:
 6381 3828 0510A0E1 		mov	r1, r5
 6382 382c FEFFFFEB 		bl	CyU3PConnectState
 6383              	.LVL515:
2193:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6384              		.loc 1 2193 0
 6385 3830 002050E2 		subs	r2, r0, #0
 6386 3834 9700001A 		bne	.L587
2199:../uvc.c      ****     CyU3PBusyWait(100);
 6387              		.loc 1 2199 0
 6388 3838 6400A0E3 		mov	r0, #100
 6389              	.LVL516:
 6390 383c FEFFFFEB 		bl	CyU3PBusyWait
 6391              	.LVL517:
2201:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6392              		.loc 1 2201 0
 6393 3840 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2215:../uvc.c      ****     endPointConfig.streams  = 0;
 6394              		.loc 1 2215 0
 6395 3844 0020A0E3 		mov	r2, #0	@ movhi
2204:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6396              		.loc 1 2204 0
 6397 3848 ACA0CDE5 		strb	sl, [sp, #172]
2216:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6398              		.loc 1 2216 0
 6399 384c A8108DE2 		add	r1, sp, #168
2215:../uvc.c      ****     endPointConfig.streams  = 0;
 6400              		.loc 1 2215 0
 6401 3850 BE2ACDE1 		strh	r2, [sp, #174]	@ movhi
2203:../uvc.c      ****     endPointConfig.enable   = 1;
 6402              		.loc 1 2203 0
 6403 3854 A8508DE5 		str	r5, [sp, #168]
2205:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6404              		.loc 1 2205 0
 6405 3858 030050E3 		cmp	r0, #3
2201:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6406              		.loc 1 2201 0
 6407 385c 4800C4E5 		strb	r0, [r4, #72]
2212:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6408              		.loc 1 2212 0
 6409 3860 020CA013 		movne	r0, #512	@ movhi
2207:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6410              		.loc 1 2207 0
 6411 3864 01ABA003 		moveq	sl, #1024	@ movhi
2212:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6412              		.loc 1 2212 0
 6413 3868 B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2216:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6414              		.loc 1 2216 0
 6415 386c 8300A0E3 		mov	r0, #131
2207:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6416              		.loc 1 2207 0
 6417 3870 B0ABCD01 		streqh	sl, [sp, #176]	@ movhi
2208:../uvc.c      ****     	endPointConfig.burstLen = 16;
 6418              		.loc 1 2208 0
 6419 3874 B280CD05 		streqb	r8, [sp, #178]
2213:../uvc.c      ****     	endPointConfig.burstLen = 1;
 6420              		.loc 1 2213 0
 6421 3878 B250CD15 		strneb	r5, [sp, #178]
2216:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6422              		.loc 1 2216 0
 6423 387c FEFFFFEB 		bl	CyU3PSetEpConfig
 6424              	.LVL518:
2217:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6425              		.loc 1 2217 0
 6426 3880 002050E2 		subs	r2, r0, #0
 6427 3884 4F00001A 		bne	.L570
 6428 3888 10779FE5 		ldr	r7, .L599+116
 6429              	.LBE223:
 6430              	.LBE220:
2340:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6431              		.loc 1 2340 0
 6432 388c AC569FE5 		ldr	r5, .L599+20
 6433 3890 0260A0E1 		mov	r6, r2
2524:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 6434              		.loc 1 2524 0
 6435 3894 0080E0E3 		mvn	r8, #0
 6436              	.LVL519:
 6437              	.L531:
2340:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6438              		.loc 1 2340 0
 6439 3898 A0069FE5 		ldr	r0, .L599+20
 6440 389c 0110A0E3 		mov	r1, #1
 6441 38a0 0220A0E3 		mov	r2, #2
 6442 38a4 B4308DE2 		add	r3, sp, #180
 6443 38a8 00608DE5 		str	r6, [sp, #0]
 6444 38ac FEFFFFEB 		bl	_txe_event_flags_get
 6445 38b0 000050E3 		cmp	r0, #0
 6446 38b4 3000001A 		bne	.L533
2386:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6447              		.loc 1 2386 0
 6448 38b8 3CE095E5 		ldr	lr, [r5, #60]
 6449 38bc 00005EE3 		cmp	lr, #0
 6450 38c0 0300000A 		beq	.L534
2386:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6451              		.loc 1 2386 0 is_stmt 0 discriminator 1
 6452 38c4 B014D5E1 		ldrh	r1, [r5, #64]
 6453 38c8 B234D5E1 		ldrh	r3, [r5, #66]
 6454 38cc 030051E1 		cmp	r1, r3
 6455 38d0 1201000A 		beq	.L588
 6456              	.L534:
2585:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 6457              		.loc 1 2585 0 is_stmt 1
 6458 38d4 4010A0E3 		mov	r1, #64
 6459 38d8 0020A0E3 		mov	r2, #0
 6460 38dc 5C069FE5 		ldr	r0, .L599+20
 6461 38e0 FEFFFFEB 		bl	_txe_event_flags_set
2588:../uvc.c      ****         CyU3PThreadRelinquish ();
 6462              		.loc 1 2588 0
 6463 38e4 FEFFFFEB 		bl	_txe_thread_relinquish
2589:../uvc.c      ****     }
 6464              		.loc 1 2589 0
 6465 38e8 EAFFFFEA 		b	.L531
 6466              	.LVL520:
 6467              	.L573:
 6468              	.LBB258:
 6469              	.LBB222:
1889:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 6470              		.loc 1 1889 0
 6471 38ec 0400A0E3 		mov	r0, #4
 6472              	.LVL521:
 6473 38f0 AC169FE5 		ldr	r1, .L599+120
 6474 38f4 FEFFFFEB 		bl	CyU3PDebugPrint
 6475              	.LVL522:
 6476              	.L500:
 6477              	.LBB238:
 6478              	.LBB239:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6479              		.loc 1 1318 0
 6480 38f8 A8169FE5 		ldr	r1, .L599+124
 6481 38fc 0400A0E3 		mov	r0, #4
 6482 3900 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6483              		.loc 1 1319 0
 6484 3904 FA0FA0E3 		mov	r0, #1000
 6485 3908 FEFFFFEB 		bl	_tx_thread_sleep
 6486 390c F9FFFFEA 		b	.L500
 6487              	.LVL523:
 6488              	.L575:
 6489              	.LBE239:
 6490              	.LBE238:
1920:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 6491              		.loc 1 1920 0
 6492 3910 0400A0E3 		mov	r0, #4
 6493              	.LVL524:
 6494 3914 90169FE5 		ldr	r1, .L599+128
 6495 3918 FEFFFFEB 		bl	CyU3PDebugPrint
 6496              	.LVL525:
 6497              	.L504:
 6498              	.LBB236:
 6499              	.LBB237:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6500              		.loc 1 1318 0
 6501 391c 84169FE5 		ldr	r1, .L599+124
 6502 3920 0400A0E3 		mov	r0, #4
 6503 3924 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6504              		.loc 1 1319 0
 6505 3928 FA0FA0E3 		mov	r0, #1000
 6506 392c FEFFFFEB 		bl	_tx_thread_sleep
 6507 3930 F9FFFFEA 		b	.L504
 6508              	.LVL526:
 6509              	.L574:
 6510              	.LBE237:
 6511              	.LBE236:
1911:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 6512              		.loc 1 1911 0
 6513 3934 0400A0E3 		mov	r0, #4
 6514              	.LVL527:
 6515 3938 70169FE5 		ldr	r1, .L599+132
 6516 393c FEFFFFEB 		bl	CyU3PDebugPrint
 6517              	.LVL528:
 6518              	.L502:
 6519              	.LBB234:
 6520              	.LBB235:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6521              		.loc 1 1318 0
 6522 3940 60169FE5 		ldr	r1, .L599+124
 6523 3944 0400A0E3 		mov	r0, #4
 6524 3948 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6525              		.loc 1 1319 0
 6526 394c FA0FA0E3 		mov	r0, #1000
 6527 3950 FEFFFFEB 		bl	_tx_thread_sleep
 6528 3954 F9FFFFEA 		b	.L502
 6529              	.LVL529:
 6530              	.L576:
 6531              	.LBE235:
 6532              	.LBE234:
1926:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 6533              		.loc 1 1926 0
 6534 3958 0400A0E3 		mov	r0, #4
 6535              	.LVL530:
 6536 395c 50169FE5 		ldr	r1, .L599+136
 6537 3960 FEFFFFEB 		bl	CyU3PDebugPrint
 6538              	.LVL531:
 6539              	.L506:
 6540              	.LBB232:
 6541              	.LBB233:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6542              		.loc 1 1318 0
 6543 3964 3C169FE5 		ldr	r1, .L599+124
 6544 3968 0400A0E3 		mov	r0, #4
 6545 396c FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6546              		.loc 1 1319 0
 6547 3970 FA0FA0E3 		mov	r0, #1000
 6548 3974 FEFFFFEB 		bl	_tx_thread_sleep
 6549 3978 F9FFFFEA 		b	.L506
 6550              	.LVL532:
 6551              	.L533:
 6552              	.LBE233:
 6553              	.LBE232:
 6554              	.LBE222:
 6555              	.LBE258:
2492:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 6556              		.loc 1 2492 0
 6557 397c BC059FE5 		ldr	r0, .L599+20
 6558 3980 0210A0E3 		mov	r1, #2
 6559 3984 0320A0E3 		mov	r2, #3
 6560 3988 B4308DE2 		add	r3, sp, #180
 6561 398c 00608DE5 		str	r6, [sp, #0]
 6562 3990 FEFFFFEB 		bl	_txe_event_flags_get
 6563 3994 000050E3 		cmp	r0, #0
 6564 3998 2500001A 		bne	.L550
2507:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6565              		.loc 1 2507 0
 6566 399c 441095E5 		ldr	r1, [r5, #68]
2495:../uvc.c      ****                 hitFV     = CyFalse;
 6567              		.loc 1 2495 0
 6568 39a0 3C6085E5 		str	r6, [r5, #60]
2507:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6569              		.loc 1 2507 0
 6570 39a4 000051E3 		cmp	r1, #0
2496:../uvc.c      ****                 prodCount = 0;
 6571              		.loc 1 2496 0
 6572 39a8 B064C5E1 		strh	r6, [r5, #64]	@ movhi
2503:../uvc.c      ****                 fb=0;
 6573              		.loc 1 2503 0
 6574 39ac B463C5E1 		strh	r6, [r5, #52]	@ movhi
2497:../uvc.c      ****                 consCount = 0;
 6575              		.loc 1 2497 0
 6576 39b0 B264C5E1 		strh	r6, [r5, #66]	@ movhi
2504:../uvc.c      ****                 pb=0;
 6577              		.loc 1 2504 0
 6578 39b4 B663C5E1 		strh	r6, [r5, #54]	@ movhi
2505:../uvc.c      ****                 pbc=0;
 6579              		.loc 1 2505 0
 6580 39b8 B863C5E1 		strh	r6, [r5, #56]	@ movhi
2507:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6581              		.loc 1 2507 0
 6582 39bc 0A00000A 		beq	.L589
 6583              	.L551:
2519:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 6584              		.loc 1 2519 0
 6585 39c0 446084E5 		str	r6, [r4, #68]
 6586 39c4 C2FFFFEA 		b	.L534
 6587              	.LVL533:
 6588              	.L570:
 6589              	.LBB259:
 6590              	.LBB256:
2220:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6591              		.loc 1 2220 0
 6592 39c8 0400A0E3 		mov	r0, #4
 6593              	.LVL534:
 6594 39cc E4159FE5 		ldr	r1, .L599+140
 6595 39d0 FEFFFFEB 		bl	CyU3PDebugPrint
 6596              	.LVL535:
 6597              	.L532:
 6598              	.LBB240:
 6599              	.LBB241:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6600              		.loc 1 1318 0
 6601 39d4 CC159FE5 		ldr	r1, .L599+124
 6602 39d8 0400A0E3 		mov	r0, #4
 6603 39dc FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6604              		.loc 1 1319 0
 6605 39e0 FA0FA0E3 		mov	r0, #1000
 6606 39e4 FEFFFFEB 		bl	_tx_thread_sleep
 6607 39e8 F9FFFFEA 		b	.L532
 6608              	.LVL536:
 6609              	.L589:
 6610              	.LBE241:
 6611              	.LBE240:
 6612              	.LBE256:
 6613              	.LBE259:
2509:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6614              		.loc 1 2509 0
 6615 39ec A8059FE5 		ldr	r0, .L599+112
 6616 39f0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6617              	.LVL537:
2510:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6618              		.loc 1 2510 0
 6619 39f4 000050E3 		cmp	r0, #0
 6620 39f8 0200001A 		bne	.L571
2516:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 6621              		.loc 1 2516 0
 6622 39fc 8300A0E3 		mov	r0, #131
 6623              	.LVL538:
 6624 3a00 FEFFFFEB 		bl	CyU3PUsbFlushEp
 6625 3a04 EDFFFFEA 		b	.L551
 6626              	.L571:
 6627              	.LBB260:
 6628              	.LBB261:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6629              		.loc 1 1318 0
 6630 3a08 98159FE5 		ldr	r1, .L599+124
 6631 3a0c 0400A0E3 		mov	r0, #4
 6632 3a10 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6633              		.loc 1 1319 0
 6634 3a14 FA0FA0E3 		mov	r0, #1000
 6635 3a18 FEFFFFEB 		bl	_tx_thread_sleep
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6636              		.loc 1 1318 0
 6637 3a1c 84159FE5 		ldr	r1, .L599+124
 6638 3a20 0400A0E3 		mov	r0, #4
 6639 3a24 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6640              		.loc 1 1319 0
 6641 3a28 FA0FA0E3 		mov	r0, #1000
 6642 3a2c FEFFFFEB 		bl	_tx_thread_sleep
 6643 3a30 F4FFFFEA 		b	.L571
 6644              	.L550:
 6645              	.LBE261:
 6646              	.LBE260:
2524:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 6647              		.loc 1 2524 0
 6648 3a34 0110A0E3 		mov	r1, #1
 6649 3a38 0220A0E3 		mov	r2, #2
 6650 3a3c B4308DE2 		add	r3, sp, #180
 6651 3a40 F8049FE5 		ldr	r0, .L599+20
 6652 3a44 00808DE5 		str	r8, [sp, #0]
 6653 3a48 FEFFFFEB 		bl	_txe_event_flags_get
2528:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6654              		.loc 1 2528 0
 6655 3a4c 0620A0E1 		mov	r2, r6
 6656 3a50 44059FE5 		ldr	r0, .L599+112
 6657 3a54 0610A0E1 		mov	r1, r6
 6658 3a58 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6659              	.LVL539:
2529:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6660              		.loc 1 2529 0
 6661 3a5c 002050E2 		subs	r2, r0, #0
 6662 3a60 6500001A 		bne	.L590
2537:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 6663              		.loc 1 2537 0
 6664 3a64 282095E5 		ldr	r2, [r5, #40]
 6665 3a68 000052E3 		cmp	r2, #0
 6666 3a6c 5A00001A 		bne	.L556
 6667              	.LVL540:
 6668              	.LBB262:
 6669              	.LBB263:
2245:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6670              		.loc 1 2245 0
 6671 3a70 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 6672 3a74 030053E3 		cmp	r3, #3
 6673 3a78 4700000A 		beq	.L591
2250:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 6674              		.loc 1 2250 0
 6675 3a7c 020053E3 		cmp	r3, #2
 6676 3a80 2900000A 		beq	.L592
 6677              	.LVL541:
 6678              	.L559:
 6679              	.LBE263:
 6680              	.LBE262:
2573:../uvc.c      ****                     gpif_initialized = CyTrue;
 6681              		.loc 1 2573 0
 6682 3a84 01E0A0E3 		mov	lr, #1
 6683 3a88 28E084E5 		str	lr, [r4, #40]
2574:../uvc.c      ****                     CyU3PThreadSleep(200);
 6684              		.loc 1 2574 0
 6685 3a8c C800A0E3 		mov	r0, #200
 6686 3a90 FEFFFFEB 		bl	_tx_thread_sleep
 6687 3a94 8EFFFFEA 		b	.L534
 6688              	.LVL542:
 6689              	.L587:
 6690              	.LBB269:
 6691              	.LBB221:
2195:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 6692              		.loc 1 2195 0
 6693 3a98 0400A0E3 		mov	r0, #4
 6694              	.LVL543:
 6695 3a9c 18159FE5 		ldr	r1, .L599+144
 6696 3aa0 FEFFFFEB 		bl	CyU3PDebugPrint
 6697              	.LVL544:
 6698              	.L528:
 6699              	.LBB230:
 6700              	.LBB231:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6701              		.loc 1 1318 0
 6702 3aa4 FC149FE5 		ldr	r1, .L599+124
 6703 3aa8 0400A0E3 		mov	r0, #4
 6704 3aac FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6705              		.loc 1 1319 0
 6706 3ab0 FA0FA0E3 		mov	r0, #1000
 6707 3ab4 FEFFFFEB 		bl	_tx_thread_sleep
 6708 3ab8 F9FFFFEA 		b	.L528
 6709              	.LVL545:
 6710              	.L586:
 6711              	.LBE231:
 6712              	.LBE230:
2104:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 6713              		.loc 1 2104 0
 6714 3abc 0400A0E3 		mov	r0, #4
 6715              	.LVL546:
 6716 3ac0 F8149FE5 		ldr	r1, .L599+148
 6717 3ac4 FEFFFFEB 		bl	CyU3PDebugPrint
 6718              	.LVL547:
 6719              	.L526:
 6720              	.LBB228:
 6721              	.LBB229:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6722              		.loc 1 1318 0
 6723 3ac8 D8149FE5 		ldr	r1, .L599+124
 6724 3acc 0400A0E3 		mov	r0, #4
 6725 3ad0 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6726              		.loc 1 1319 0
 6727 3ad4 FA0FA0E3 		mov	r0, #1000
 6728 3ad8 FEFFFFEB 		bl	_tx_thread_sleep
 6729 3adc F9FFFFEA 		b	.L526
 6730              	.LVL548:
 6731              	.L585:
 6732              	.LBE229:
 6733              	.LBE228:
2080:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 6734              		.loc 1 2080 0
 6735 3ae0 040080E2 		add	r0, r0, #4
 6736 3ae4 D8149FE5 		ldr	r1, .L599+152
 6737 3ae8 FEFFFFEB 		bl	CyU3PDebugPrint
 6738              	.LVL549:
 6739              	.L524:
 6740              	.LBB226:
 6741              	.LBB227:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6742              		.loc 1 1318 0
 6743 3aec B4149FE5 		ldr	r1, .L599+124
 6744 3af0 0400A0E3 		mov	r0, #4
 6745 3af4 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6746              		.loc 1 1319 0
 6747 3af8 FA0FA0E3 		mov	r0, #1000
 6748 3afc FEFFFFEB 		bl	_tx_thread_sleep
 6749 3b00 F9FFFFEA 		b	.L524
 6750              	.LVL550:
 6751              	.L584:
 6752              	.LBE227:
 6753              	.LBE226:
2073:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 6754              		.loc 1 2073 0
 6755 3b04 0400A0E3 		mov	r0, #4
 6756 3b08 B8149FE5 		ldr	r1, .L599+156
 6757 3b0c 0620A0E1 		mov	r2, r6
 6758 3b10 FEFFFFEB 		bl	CyU3PDebugPrint
 6759              	.L522:
 6760              	.LBB224:
 6761              	.LBB225:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6762              		.loc 1 1318 0
 6763 3b14 8C149FE5 		ldr	r1, .L599+124
 6764 3b18 0400A0E3 		mov	r0, #4
 6765 3b1c FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6766              		.loc 1 1319 0
 6767 3b20 FA0FA0E3 		mov	r0, #1000
 6768 3b24 FEFFFFEB 		bl	_tx_thread_sleep
 6769 3b28 F9FFFFEA 		b	.L522
 6770              	.LVL551:
 6771              	.L592:
 6772              	.LBE225:
 6773              	.LBE224:
 6774              	.LBE221:
 6775              	.LBE269:
 6776              	.LBB270:
 6777              	.LBB268:
2252:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 6778              		.loc 1 2252 0
 6779 3b2c 98149FE5 		ldr	r1, .L599+160
 6780 3b30 0100A0E3 		mov	r0, #1
 6781              	.LVL552:
 6782 3b34 FEFFFFEB 		bl	CyU3PDebugPrint
2253:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 6783              		.loc 1 2253 0
 6784 3b38 90049FE5 		ldr	r0, .L599+164
 6785 3b3c FEFFFFEB 		bl	CyU3PGpifLoad
 6786 3b40 0020A0E1 		mov	r2, r0
 6787              	.LVL553:
 6788              	.L558:
2255:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6789              		.loc 1 2255 0
 6790 3b44 000052E3 		cmp	r2, #0
 6791 3b48 1A00001A 		bne	.L593
2263:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6792              		.loc 1 2263 0
 6793 3b4c 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 6794 3b50 030053E3 		cmp	r3, #3
 6795 3b54 0100000A 		beq	.L572
2267:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 6796              		.loc 1 2267 0
 6797 3b58 020053E3 		cmp	r3, #2
 6798 3b5c C8FFFF1A 		bne	.L559
 6799              	.L572:
2269:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6800              		.loc 1 2269 0
 6801 3b60 0200A0E1 		mov	r0, r2
 6802              	.LVL554:
 6803 3b64 0210A0E1 		mov	r1, r2
 6804 3b68 FEFFFFEB 		bl	CyU3PGpifSMStart
 6805              	.LVL555:
2271:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6806              		.loc 1 2271 0
 6807 3b6c 000050E3 		cmp	r0, #0
2269:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6808              		.loc 1 2269 0
 6809 3b70 0020A0E1 		mov	r2, r0
 6810              	.LVL556:
2271:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6811              		.loc 1 2271 0
 6812 3b74 C2FFFF0A 		beq	.L559
2274:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 6813              		.loc 1 2274 0
 6814 3b78 0400A0E3 		mov	r0, #4
 6815              	.LVL557:
 6816 3b7c 50149FE5 		ldr	r1, .L599+168
 6817 3b80 FEFFFFEB 		bl	CyU3PDebugPrint
 6818              	.LVL558:
 6819              	.L564:
 6820              	.LBB264:
 6821              	.LBB265:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6822              		.loc 1 1318 0
 6823 3b84 1C149FE5 		ldr	r1, .L599+124
 6824 3b88 0400A0E3 		mov	r0, #4
 6825 3b8c FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6826              		.loc 1 1319 0
 6827 3b90 FA0FA0E3 		mov	r0, #1000
 6828 3b94 FEFFFFEB 		bl	_tx_thread_sleep
 6829 3b98 F9FFFFEA 		b	.L564
 6830              	.LVL559:
 6831              	.L591:
 6832              	.LBE265:
 6833              	.LBE264:
2247:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 6834              		.loc 1 2247 0
 6835 3b9c 34149FE5 		ldr	r1, .L599+172
 6836 3ba0 0100A0E3 		mov	r0, #1
 6837              	.LVL560:
 6838 3ba4 FEFFFFEB 		bl	CyU3PDebugPrint
2248:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 6839              		.loc 1 2248 0
 6840 3ba8 2C049FE5 		ldr	r0, .L599+176
 6841 3bac FEFFFFEB 		bl	CyU3PGpifLoad
 6842 3bb0 0020A0E1 		mov	r2, r0
 6843              	.LVL561:
 6844 3bb4 E2FFFFEA 		b	.L558
 6845              	.L593:
2258:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 6846              		.loc 1 2258 0
 6847 3bb8 0400A0E3 		mov	r0, #4
 6848              	.LVL562:
 6849 3bbc 1C149FE5 		ldr	r1, .L599+180
 6850 3bc0 FEFFFFEB 		bl	CyU3PDebugPrint
 6851              	.LVL563:
 6852              	.L561:
 6853              	.LBB266:
 6854              	.LBB267:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6855              		.loc 1 1318 0
 6856 3bc4 DC139FE5 		ldr	r1, .L599+124
 6857 3bc8 0400A0E3 		mov	r0, #4
 6858 3bcc FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6859              		.loc 1 1319 0
 6860 3bd0 FA0FA0E3 		mov	r0, #1000
 6861 3bd4 FEFFFFEB 		bl	_tx_thread_sleep
 6862 3bd8 F9FFFFEA 		b	.L561
 6863              	.LVL564:
 6864              	.L556:
 6865              	.LBE267:
 6866              	.LBE266:
 6867              	.LBE268:
 6868              	.LBE270:
2581:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6869              		.loc 1 2581 0
 6870 3bdc AC039FE5 		ldr	r0, .L599+100
 6871              	.LVL565:
 6872 3be0 02C0A0E3 		mov	ip, #2
 6873 3be4 0610A0E1 		mov	r1, r6
 6874 3be8 0020A0E1 		mov	r2, r0
 6875 3bec 0630A0E1 		mov	r3, r6
 6876 3bf0 00C08DE5 		str	ip, [sp, #0]
 6877 3bf4 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6878 3bf8 35FFFFEA 		b	.L534
 6879              	.LVL566:
 6880              	.L590:
2532:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 6881              		.loc 1 2532 0
 6882 3bfc 0400A0E3 		mov	r0, #4
 6883              	.LVL567:
 6884 3c00 DC139FE5 		ldr	r1, .L599+184
 6885 3c04 FEFFFFEB 		bl	CyU3PDebugPrint
 6886              	.LVL568:
 6887              	.L555:
 6888              	.LBB271:
 6889              	.LBB272:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6890              		.loc 1 1318 0
 6891 3c08 98139FE5 		ldr	r1, .L599+124
 6892 3c0c 0400A0E3 		mov	r0, #4
 6893 3c10 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6894              		.loc 1 1319 0
 6895 3c14 FA0FA0E3 		mov	r0, #1000
 6896 3c18 FEFFFFEB 		bl	_tx_thread_sleep
 6897 3c1c F9FFFFEA 		b	.L555
 6898              	.LVL569:
 6899              	.L583:
 6900              	.LBE272:
 6901              	.LBE271:
 6902              	.LBB273:
 6903              	.LBB257:
2052:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6904              		.loc 1 2052 0
 6905 3c20 0400A0E3 		mov	r0, #4
 6906              	.LVL570:
 6907 3c24 8C139FE5 		ldr	r1, .L599+140
 6908 3c28 0320A0E1 		mov	r2, r3
 6909 3c2c FEFFFFEB 		bl	CyU3PDebugPrint
 6910              	.LVL571:
 6911              	.L520:
 6912              	.LBB242:
 6913              	.LBB243:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6914              		.loc 1 1318 0
 6915 3c30 70139FE5 		ldr	r1, .L599+124
 6916 3c34 0400A0E3 		mov	r0, #4
 6917 3c38 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6918              		.loc 1 1319 0
 6919 3c3c FA0FA0E3 		mov	r0, #1000
 6920 3c40 FEFFFFEB 		bl	_tx_thread_sleep
 6921 3c44 F9FFFFEA 		b	.L520
 6922              	.LVL572:
 6923              	.L582:
 6924              	.LBE243:
 6925              	.LBE242:
2007:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6926              		.loc 1 2007 0
 6927 3c48 0400A0E3 		mov	r0, #4
 6928              	.LVL573:
 6929 3c4c 94139FE5 		ldr	r1, .L599+188
 6930 3c50 FEFFFFEB 		bl	CyU3PDebugPrint
 6931              	.LVL574:
 6932              	.L518:
 6933              	.LBB244:
 6934              	.LBB245:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6935              		.loc 1 1318 0
 6936 3c54 4C139FE5 		ldr	r1, .L599+124
 6937 3c58 0400A0E3 		mov	r0, #4
 6938 3c5c FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6939              		.loc 1 1319 0
 6940 3c60 FA0FA0E3 		mov	r0, #1000
 6941 3c64 FEFFFFEB 		bl	_tx_thread_sleep
 6942 3c68 F9FFFFEA 		b	.L518
 6943              	.LVL575:
 6944              	.L581:
 6945              	.LBE245:
 6946              	.LBE244:
1986:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6947              		.loc 1 1986 0
 6948 3c6c 0400A0E3 		mov	r0, #4
 6949              	.LVL576:
 6950 3c70 74139FE5 		ldr	r1, .L599+192
 6951 3c74 FEFFFFEB 		bl	CyU3PDebugPrint
 6952              	.LVL577:
 6953              	.L516:
 6954              	.LBB246:
 6955              	.LBB247:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6956              		.loc 1 1318 0
 6957 3c78 28139FE5 		ldr	r1, .L599+124
 6958 3c7c 0400A0E3 		mov	r0, #4
 6959 3c80 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6960              		.loc 1 1319 0
 6961 3c84 FA0FA0E3 		mov	r0, #1000
 6962 3c88 FEFFFFEB 		bl	_tx_thread_sleep
 6963 3c8c F9FFFFEA 		b	.L516
 6964              	.LVL578:
 6965              	.L580:
 6966              	.LBE247:
 6967              	.LBE246:
1973:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 6968              		.loc 1 1973 0
 6969 3c90 0400A0E3 		mov	r0, #4
 6970              	.LVL579:
 6971 3c94 54139FE5 		ldr	r1, .L599+196
 6972 3c98 FEFFFFEB 		bl	CyU3PDebugPrint
 6973              	.LVL580:
 6974              	.L514:
 6975              	.LBB248:
 6976              	.LBB249:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6977              		.loc 1 1318 0
 6978 3c9c 04139FE5 		ldr	r1, .L599+124
 6979 3ca0 0400A0E3 		mov	r0, #4
 6980 3ca4 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6981              		.loc 1 1319 0
 6982 3ca8 FA0FA0E3 		mov	r0, #1000
 6983 3cac FEFFFFEB 		bl	_tx_thread_sleep
 6984 3cb0 F9FFFFEA 		b	.L514
 6985              	.LVL581:
 6986              	.L578:
 6987              	.LBE249:
 6988              	.LBE248:
1945:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 6989              		.loc 1 1945 0
 6990 3cb4 0400A0E3 		mov	r0, #4
 6991              	.LVL582:
 6992 3cb8 34139FE5 		ldr	r1, .L599+200
 6993 3cbc FEFFFFEB 		bl	CyU3PDebugPrint
 6994              	.LVL583:
 6995              	.L510:
 6996              	.LBB250:
 6997              	.LBB251:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6998              		.loc 1 1318 0
 6999 3cc0 E0129FE5 		ldr	r1, .L599+124
 7000 3cc4 0400A0E3 		mov	r0, #4
 7001 3cc8 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 7002              		.loc 1 1319 0
 7003 3ccc FA0FA0E3 		mov	r0, #1000
 7004 3cd0 FEFFFFEB 		bl	_tx_thread_sleep
 7005 3cd4 F9FFFFEA 		b	.L510
 7006              	.LVL584:
 7007              	.L577:
 7008              	.LBE251:
 7009              	.LBE250:
1932:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 7010              		.loc 1 1932 0
 7011 3cd8 0400A0E3 		mov	r0, #4
 7012              	.LVL585:
 7013 3cdc 14139FE5 		ldr	r1, .L599+204
 7014 3ce0 FEFFFFEB 		bl	CyU3PDebugPrint
 7015              	.LVL586:
 7016              	.L508:
 7017              	.LBB252:
 7018              	.LBB253:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7019              		.loc 1 1318 0
 7020 3ce4 BC129FE5 		ldr	r1, .L599+124
 7021 3ce8 0400A0E3 		mov	r0, #4
 7022 3cec FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 7023              		.loc 1 1319 0
 7024 3cf0 FA0FA0E3 		mov	r0, #1000
 7025 3cf4 FEFFFFEB 		bl	_tx_thread_sleep
 7026 3cf8 F9FFFFEA 		b	.L508
 7027              	.LVL587:
 7028              	.L579:
 7029              	.LBE253:
 7030              	.LBE252:
1959:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 7031              		.loc 1 1959 0
 7032 3cfc 0400A0E3 		mov	r0, #4
 7033              	.LVL588:
 7034 3d00 F4129FE5 		ldr	r1, .L599+208
 7035 3d04 FEFFFFEB 		bl	CyU3PDebugPrint
 7036              	.LVL589:
 7037              	.L512:
 7038              	.LBB254:
 7039              	.LBB255:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7040              		.loc 1 1318 0
 7041 3d08 98129FE5 		ldr	r1, .L599+124
 7042 3d0c 0400A0E3 		mov	r0, #4
 7043 3d10 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 7044              		.loc 1 1319 0
 7045 3d14 FA0FA0E3 		mov	r0, #1000
 7046 3d18 FEFFFFEB 		bl	_tx_thread_sleep
 7047 3d1c F9FFFFEA 		b	.L512
 7048              	.LVL590:
 7049              	.L588:
 7050              	.LBE255:
 7051              	.LBE254:
 7052              	.LBE257:
 7053              	.LBE273:
2396:../uvc.c      ****                 prodCount = 0;
 7054              		.loc 1 2396 0
 7055 3d20 B064C5E1 		strh	r6, [r5, #64]	@ movhi
2411:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7056              		.loc 1 2411 0
 7057 3d24 60029FE5 		ldr	r0, .L599+96
2397:../uvc.c      ****                 consCount = 0;
 7058              		.loc 1 2397 0
 7059 3d28 B264C5E1 		strh	r6, [r5, #66]	@ movhi
2411:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7060              		.loc 1 2411 0
 7061 3d2c 0010E0E3 		mvn	r1, #0
2393:../uvc.c      ****             	fb=0;
 7062              		.loc 1 2393 0
 7063 3d30 B463C5E1 		strh	r6, [r5, #52]	@ movhi
2394:../uvc.c      ****             	pb=0;
 7064              		.loc 1 2394 0
 7065 3d34 B663C5E1 		strh	r6, [r5, #54]	@ movhi
2395:../uvc.c      ****             	pbc=0;
 7066              		.loc 1 2395 0
 7067 3d38 B863C5E1 		strh	r6, [r5, #56]	@ movhi
2398:../uvc.c      ****                 hitFV     = CyFalse;
 7068              		.loc 1 2398 0
 7069 3d3c 3C6085E5 		str	r6, [r5, #60]
2411:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7070              		.loc 1 2411 0
 7071 3d40 FEFFFFEB 		bl	_txe_mutex_get
2412:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 7072              		.loc 1 2412 0
 7073 3d44 8104D7E5 		ldrb	r0, [r7, #1153]	@ zero_extendqisi2
 7074 3d48 012020E2 		eor	r2, r0, #1
 7075 3d4c 8124C7E5 		strb	r2, [r7, #1153]
2414:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 7076              		.loc 1 2414 0
 7077 3d50 3AC0D5E5 		ldrb	ip, [r5, #58]	@ zero_extendqisi2
 7078 3d54 F0005CE3 		cmp	ip, #240
 7079 3d58 1800000A 		beq	.L594
 7080              	.L535:
2422:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
 7081              		.loc 1 2422 0
 7082 3d5c 3AA0D4E5 		ldrb	sl, [r4, #58]	@ zero_extendqisi2
 7083 3d60 FF005AE3 		cmp	sl, #255
 7084 3d64 6400000A 		beq	.L595
2434:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
 7085              		.loc 1 2434 0
 7086 3d68 3A00D5E5 		ldrb	r0, [r5, #58]	@ zero_extendqisi2
 7087 3d6c AA0050E3 		cmp	r0, #170
 7088 3d70 3700000A 		beq	.L596
 7089              	.L537:
2467:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
 7090              		.loc 1 2467 0
 7091 3d74 10029FE5 		ldr	r0, .L599+96
 7092 3d78 FEFFFFEB 		bl	_txe_mutex_put
2469:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 7093              		.loc 1 2469 0
 7094 3d7c 18029FE5 		ldr	r0, .L599+112
 7095 3d80 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 7096              	.LVL591:
2470:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7097              		.loc 1 2470 0
 7098 3d84 002050E2 		subs	r2, r0, #0
 7099 3d88 2800001A 		bne	.L597
2477:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 7100              		.loc 1 2477 0
 7101 3d8c 0210A0E1 		mov	r1, r2
 7102 3d90 04029FE5 		ldr	r0, .L599+112
 7103              	.LVL592:
 7104 3d94 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 7105              	.LVL593:
2478:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7106              		.loc 1 2478 0
 7107 3d98 002050E2 		subs	r2, r0, #0
 7108 3d9c 1A00001A 		bne	.L598
2486:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 7109              		.loc 1 2486 0
 7110 3da0 E8019FE5 		ldr	r0, .L599+100
 7111              	.LVL594:
 7112 3da4 0210A0E1 		mov	r1, r2
 7113 3da8 02A0A0E3 		mov	sl, #2
 7114 3dac 0020A0E1 		mov	r2, r0
 7115              	.LVL595:
 7116 3db0 0130A0E1 		mov	r3, r1
 7117 3db4 00A08DE5 		str	sl, [sp, #0]
 7118 3db8 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 7119              	.LVL596:
 7120 3dbc C4FEFFEA 		b	.L534
 7121              	.L594:
2414:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 7122              		.loc 1 2414 0 discriminator 1
 7123 3dc0 78019FE5 		ldr	r0, .L599+20
 7124 3dc4 8010A0E3 		mov	r1, #128
 7125 3dc8 0320A0E3 		mov	r2, #3
 7126 3dcc B4308DE2 		add	r3, sp, #180
 7127 3dd0 00608DE5 		str	r6, [sp, #0]
 7128 3dd4 FEFFFFEB 		bl	_txe_event_flags_get
 7129 3dd8 000050E3 		cmp	r0, #0
 7130 3ddc DEFFFF1A 		bne	.L535
2417:../uvc.c      ****                        	SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*bo
 7131              		.loc 1 2417 0
 7132 3de0 582095E5 		ldr	r2, [r5, #88]
 7133 3de4 010080E2 		add	r0, r0, #1
 7134 3de8 000052E3 		cmp	r2, #0
 7135 3dec 3010A0E3 		mov	r1, #48
 7136 3df0 E420A003 		moveq	r2, #228
 7137 3df4 6420A013 		movne	r2, #100
 7138 3df8 5230A0E3 		mov	r3, #82
 7139 3dfc FEFFFFEB 		bl	SensorSetIrisControl
2419:../uvc.c      ****                 		stiflag = 0xFF;
 7140              		.loc 1 2419 0
 7141 3e00 3A80C4E5 		strb	r8, [r4, #58]
2420:../uvc.c      ****                 		IMcount = 0;
 7142              		.loc 1 2420 0
 7143 3e04 A060C4E5 		strb	r6, [r4, #160]
 7144 3e08 D9FFFFEA 		b	.L537
 7145              	.LVL597:
 7146              	.L598:
2480:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 7147              		.loc 1 2480 0
 7148 3e0c 0400A0E3 		mov	r0, #4
 7149              	.LVL598:
 7150 3e10 E8119FE5 		ldr	r1, .L599+212
 7151 3e14 FEFFFFEB 		bl	CyU3PDebugPrint
 7152              	.LVL599:
 7153              	.L549:
 7154              	.LBB274:
 7155              	.LBB275:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7156              		.loc 1 1318 0
 7157 3e18 88119FE5 		ldr	r1, .L599+124
 7158 3e1c 0400A0E3 		mov	r0, #4
 7159 3e20 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 7160              		.loc 1 1319 0
 7161 3e24 FA0FA0E3 		mov	r0, #1000
 7162 3e28 FEFFFFEB 		bl	_tx_thread_sleep
 7163 3e2c F9FFFFEA 		b	.L549
 7164              	.LVL600:
 7165              	.L597:
 7166              	.LBE275:
 7167              	.LBE274:
2472:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 7168              		.loc 1 2472 0
 7169 3e30 0400A0E3 		mov	r0, #4
 7170              	.LVL601:
 7171 3e34 C8119FE5 		ldr	r1, .L599+216
 7172 3e38 FEFFFFEB 		bl	CyU3PDebugPrint
 7173              	.LVL602:
 7174              	.L547:
 7175              	.LBB276:
 7176              	.LBB277:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7177              		.loc 1 1318 0
 7178 3e3c 64119FE5 		ldr	r1, .L599+124
 7179 3e40 0400A0E3 		mov	r0, #4
 7180 3e44 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 7181              		.loc 1 1319 0
 7182 3e48 FA0FA0E3 		mov	r0, #1000
 7183 3e4c FEFFFFEB 		bl	_tx_thread_sleep
 7184 3e50 F9FFFFEA 		b	.L547
 7185              	.L596:
 7186              	.LBE277:
 7187              	.LBE276:
2440:../uvc.c      ****                 	if(IMcount++ >= 0x4)
 7188              		.loc 1 2440 0
 7189 3e54 A0E0D5E5 		ldrb	lr, [r5, #160]	@ zero_extendqisi2
 7190 3e58 01A08EE2 		add	sl, lr, #1
 7191 3e5c 03005EE3 		cmp	lr, #3
 7192 3e60 A0A0C5E5 		strb	sl, [r5, #160]
 7193 3e64 C2FFFF9A 		bls	.L537
2442:../uvc.c      ****                     switch (setRes)
 7194              		.loc 1 2442 0
 7195 3e68 7D00D5E5 		ldrb	r0, [r5, #125]	@ zero_extendqisi2
 7196 3e6c 020050E3 		cmp	r0, #2
 7197 3e70 1800000A 		beq	.L541
 7198 3e74 030050E3 		cmp	r0, #3
 7199 3e78 0B00000A 		beq	.L542
 7200 3e7c 010050E3 		cmp	r0, #1
 7201 3e80 0600001A 		bne	.L539
2445:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
 7202              		.loc 1 2445 0
 7203 3e84 582095E5 		ldr	r2, [r5, #88]
 7204 3e88 3010A0E3 		mov	r1, #48
 7205 3e8c 000052E3 		cmp	r2, #0
 7206 3e90 E420A003 		moveq	r2, #228
 7207 3e94 6420A013 		movne	r2, #100
 7208 3e98 5230A0E3 		mov	r3, #82
 7209 3e9c FEFFFFEB 		bl	SensorSetIrisControl
 7210              	.L539:
2462:../uvc.c      ****                     IMcount = 0;
 7211              		.loc 1 2462 0
 7212 3ea0 A060C4E5 		strb	r6, [r4, #160]
2464:../uvc.c      ****                 	stiflag = 0x0;
 7213              		.loc 1 2464 0
 7214 3ea4 3A60C4E5 		strb	r6, [r4, #58]
 7215 3ea8 B1FFFFEA 		b	.L537
 7216              	.L542:
2455:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
 7217              		.loc 1 2455 0
 7218 3eac 58C095E5 		ldr	ip, [r5, #88]
 7219 3eb0 8C34D7E5 		ldrb	r3, [r7, #1164]	@ zero_extendqisi2
 7220 3eb4 00005CE3 		cmp	ip, #0
 7221 3eb8 C4C0A003 		moveq	ip, #196
 7222 3ebc 44C0A013 		movne	ip, #68
 7223 3ec0 03208CE1 		orr	r2, ip, r3
 7224 3ec4 3010A0E3 		mov	r1, #48
 7225 3ec8 5230A0E3 		mov	r3, #82
 7226 3ecc 0100A0E3 		mov	r0, #1
 7227 3ed0 FEFFFFEB 		bl	SensorSetIrisControl
2458:../uvc.c      ****                  		break;
 7228              		.loc 1 2458 0
 7229 3ed4 F1FFFFEA 		b	.L539
 7230              	.L541:
2450:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
 7231              		.loc 1 2450 0
 7232 3ed8 582095E5 		ldr	r2, [r5, #88]
 7233 3edc 3010A0E3 		mov	r1, #48
 7234 3ee0 000052E3 		cmp	r2, #0
 7235 3ee4 D420A003 		moveq	r2, #212
 7236 3ee8 5420A013 		movne	r2, #84
 7237 3eec 5230A0E3 		mov	r3, #82
 7238 3ef0 0100A0E3 		mov	r0, #1
 7239 3ef4 FEFFFFEB 		bl	SensorSetIrisControl
2453:../uvc.c      ****                  		break;
 7240              		.loc 1 2453 0
 7241 3ef8 E8FFFFEA 		b	.L539
 7242              	.L595:
2424:../uvc.c      ****                  		if(IMcount++ >= 0x3){
 7243              		.loc 1 2424 0
 7244 3efc A010D5E5 		ldrb	r1, [r5, #160]	@ zero_extendqisi2
 7245 3f00 01E081E2 		add	lr, r1, #1
 7246 3f04 020051E3 		cmp	r1, #2
 7247 3f08 A0E0C5E5 		strb	lr, [r5, #160]
 7248 3f0c 98FFFF9A 		bls	.L537
2425:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 7249              		.loc 1 2425 0
 7250 3f10 8124D7E5 		ldrb	r2, [r7, #1153]	@ zero_extendqisi2
2426:../uvc.c      ****                 		stiflag = 0x0F;
 7251              		.loc 1 2426 0
 7252 3f14 0F30A0E3 		mov	r3, #15
2425:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 7253              		.loc 1 2425 0
 7254 3f18 20C082E3 		orr	ip, r2, #32
 7255 3f1c 81C4C7E5 		strb	ip, [r7, #1153]
2427:../uvc.c      ****                 		IMcount = 0;
 7256              		.loc 1 2427 0
 7257 3f20 A060C5E5 		strb	r6, [r5, #160]
2426:../uvc.c      ****                 		stiflag = 0x0F;
 7258              		.loc 1 2426 0
 7259 3f24 3A30C5E5 		strb	r3, [r5, #58]
 7260 3f28 91FFFFEA 		b	.L537
 7261              	.L600:
 7262              		.align	2
 7263              	.L599:
 7264 3f2c C0060000 		.word	.LC37
 7265 3f30 00C20100 		.word	115200
 7266 3f34 E0060000 		.word	.LC38
 7267 3f38 A0860100 		.word	100000
 7268 3f3c FC060000 		.word	.LC39
 7269 3f40 00000000 		.word	.LANCHOR0
 7270 3f44 00000000 		.word	CyFxGpifCB
 7271 3f48 88130000 		.word	5000
 7272 3f4c 00000000 		.word	CyFxUVCApplnUSBSetupCB
 7273 3f50 00000000 		.word	CyFxUVCApplnUSBEventCB
 7274 3f54 00000000 		.word	CyFxUSBDeviceDscr
 7275 3f58 00000000 		.word	CyFxUSBDeviceDscrSS
 7276 3f5c 00000000 		.word	CyFxUSBDeviceQualDscr
 7277 3f60 00000000 		.word	CyFxUSBBOSDscr
 7278 3f64 00000000 		.word	CyFxUSBHSConfigDscr
 7279 3f68 00000000 		.word	CyFxUSBFSConfigDscr
 7280 3f6c 00000000 		.word	CyFxUSBSSConfigDscr
 7281 3f70 00000000 		.word	CyFxUSBStringLangIDDscr
 7282 3f74 00000000 		.word	CyFxUSBManufactureDscr
 7283 3f78 00000000 		.word	CyFxUSBProductDscr
 7284 3f7c 013F0000 		.word	16129
 7285 3f80 02030000 		.word	770
 7286 3f84 00000000 		.word	glChHandleInterStat
 7287 3f88 00000000 		.word	glInterStaBuffer
 7288 3f8c 00000000 		.word	imgHdMux
 7289 3f90 01010000 		.word	257
 7290 3f94 03030000 		.word	771
 7291 3f98 00000000 		.word	CyFxUvcApplnDmaCallback
 7292 3f9c 00000000 		.word	glChHandleUVCStream
 7293 3fa0 00000000 		.word	.LANCHOR1
 7294 3fa4 18070000 		.word	.LC40
 7295 3fa8 D8010000 		.word	.LC12
 7296 3fac 68070000 		.word	.LC42
 7297 3fb0 44070000 		.word	.LC41
 7298 3fb4 90070000 		.word	.LC43
 7299 3fb8 E8080000 		.word	.LC50
 7300 3fbc C4090000 		.word	.LC54
 7301 3fc0 94090000 		.word	.LC53
 7302 3fc4 5C090000 		.word	.LC52
 7303 3fc8 1C090000 		.word	.LC51
 7304 3fcc 900A0000 		.word	.LC59
 7305 3fd0 2C000000 		.word	.LANCHOR2+44
 7306 3fd4 D80A0000 		.word	.LC61
 7307 3fd8 800A0000 		.word	.LC58
 7308 3fdc 10000000 		.word	.LANCHOR2+16
 7309 3fe0 A00A0000 		.word	.LC60
 7310 3fe4 4C0A0000 		.word	.LC57
 7311 3fe8 B8080000 		.word	.LC49
 7312 3fec 88080000 		.word	.LC48
 7313 3ff0 50080000 		.word	.LC47
 7314 3ff4 E8070000 		.word	.LC45
 7315 3ff8 BC070000 		.word	.LC44
 7316 3ffc 1C080000 		.word	.LC46
 7317 4000 180A0000 		.word	.LC56
 7318 4004 EC090000 		.word	.LC55
 7319              		.cfi_endproc
 7320              	.LFE18:
 7322              		.align	2
 7323              		.global	CyFxApplicationDefine
 7325              	CyFxApplicationDefine:
 7326              	.LFB26:
3853:../uvc.c      **** }
3854:../uvc.c      **** 
3855:../uvc.c      **** 
3856:../uvc.c      **** /*
3857:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
3858:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
3859:../uvc.c      ****  */
3860:../uvc.c      **** void
3861:../uvc.c      **** CyFxApplicationDefine (
3862:../uvc.c      ****         void)
3863:../uvc.c      **** {
 7327              		.loc 1 3863 0
 7328              		.cfi_startproc
 7329              		@ args = 0, pretend = 0, frame = 40
 7330              		@ frame_needed = 0, uses_anonymous_args = 0
 7331              	.LVL603:
 7332 4008 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7333              	.LCFI25:
 7334              		.cfi_def_cfa_offset 36
3864:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
3865:../uvc.c      ****     uint32_t retThrdCreate;
3866:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3867:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3868:../uvc.c      **** 
3869:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
3870:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7335              		.loc 1 3870 0
 7336 400c 010AA0E3 		mov	r0, #4096
3863:../uvc.c      **** {
 7337              		.loc 1 3863 0
 7338 4010 4CD04DE2 		sub	sp, sp, #76
 7339              	.LCFI26:
 7340              		.cfi_def_cfa_offset 112
 7341              		.loc 1 3870 0
 7342              		.cfi_offset 14, -4
 7343              		.cfi_offset 11, -8
 7344              		.cfi_offset 10, -12
 7345              		.cfi_offset 9, -16
 7346              		.cfi_offset 8, -20
 7347              		.cfi_offset 7, -24
 7348              		.cfi_offset 6, -28
 7349              		.cfi_offset 5, -32
 7350              		.cfi_offset 4, -36
 7351 4014 FEFFFFEB 		bl	CyU3PMemAlloc
 7352 4018 00A0A0E1 		mov	sl, r0
 7353              	.LVL604:
3871:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7354              		.loc 1 3871 0
 7355 401c 010AA0E3 		mov	r0, #4096
 7356              	.LVL605:
 7357 4020 FEFFFFEB 		bl	CyU3PMemAlloc
 7358 4024 00B0A0E1 		mov	fp, r0
 7359              	.LVL606:
3872:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7360              		.loc 1 3872 0
 7361 4028 010AA0E3 		mov	r0, #4096
 7362              	.LVL607:
 7363 402c FEFFFFEB 		bl	CyU3PMemAlloc
3873:../uvc.c      **** 
3874:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 7364              		.loc 1 3874 0
 7365 4030 00005AE3 		cmp	sl, #0
 7366 4034 00005B13 		cmpne	fp, #0
 7367 4038 0090A013 		movne	r9, #0
 7368 403c 0190A003 		moveq	r9, #1
3872:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7369              		.loc 1 3872 0
 7370 4040 24008DE5 		str	r0, [sp, #36]
 7371              	.LVL608:
 7372              		.loc 1 3874 0
 7373 4044 0000001A 		bne	.L605
 7374              	.LVL609:
 7375              	.L602:
 7376              	.L604:
 7377 4048 FEFFFFEA 		b	.L604
 7378              	.L605:
 7379              		.loc 1 3874 0 is_stmt 0 discriminator 1
 7380 404c 000050E3 		cmp	r0, #0
 7381 4050 FCFFFF0A 		beq	.L602
3875:../uvc.c      ****         goto fatalErrorHandler;
3876:../uvc.c      **** 
3877:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
3878:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7382              		.loc 1 3878 0 is_stmt 1
 7383 4054 28408DE2 		add	r4, sp, #40
 7384 4058 0400A0E1 		mov	r0, r4
 7385 405c 4010A0E3 		mov	r1, #64
 7386 4060 18219FE5 		ldr	r2, .L606
 7387 4064 FEFFFFEB 		bl	cmdbufCreate
 7388 4068 0450A0E1 		mov	r5, r4
 7389 406c 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 7390 4070 0C719FE5 		ldr	r7, .L606+4
3879:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7391              		.loc 1 3879 0
 7392 4074 0C819FE5 		ldr	r8, .L606+8
3878:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7393              		.loc 1 3878 0
 7394 4078 07C0A0E1 		mov	ip, r7
 7395 407c 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7396 4080 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
3880:../uvc.c      **** 
3881:../uvc.c      **** 	/****** initialize command descriptor ***********/
3882:../uvc.c      **** 	cmdquInit(cmdQuptr);
3883:../uvc.c      **** 	cmdquInit(statQuptr);
3884:../uvc.c      **** 
3885:../uvc.c      ****     /* Create the UVC application thread. */
3886:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 7397              		.loc 1 3886 0
 7398 4084 0860A0E3 		mov	r6, #8
3878:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7399              		.loc 1 3878 0
 7400 4088 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3879:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7401              		.loc 1 3879 0
 7402 408c F8209FE5 		ldr	r2, .L606+12
 7403 4090 0400A0E1 		mov	r0, r4
 7404 4094 2010A0E3 		mov	r1, #32
 7405 4098 FEFFFFEB 		bl	cmdbufCreate
 7406 409c 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 7407 40a0 08C0A0E1 		mov	ip, r8
 7408 40a4 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7409 40a8 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 7410              		.loc 1 3886 0
 7411 40ac 0140A0E3 		mov	r4, #1
3879:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7412              		.loc 1 3879 0
 7413 40b0 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3882:../uvc.c      **** 	cmdquInit(cmdQuptr);
 7414              		.loc 1 3882 0
 7415 40b4 0700A0E1 		mov	r0, r7
 7416 40b8 FEFFFFEB 		bl	cmdquInit
3883:../uvc.c      **** 	cmdquInit(statQuptr);
 7417              		.loc 1 3883 0
 7418 40bc 0800A0E1 		mov	r0, r8
 7419 40c0 FEFFFFEB 		bl	cmdquInit
 7420              		.loc 1 3886 0
 7421 40c4 A850A0E3 		mov	r5, #168
 7422 40c8 01CAA0E3 		mov	ip, #4096
 7423 40cc BC009FE5 		ldr	r0, .L606+16
 7424 40d0 BC109FE5 		ldr	r1, .L606+20
 7425 40d4 BC209FE5 		ldr	r2, .L606+24
 7426 40d8 0930A0E1 		mov	r3, r9
 7427 40dc 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 7428 40e0 08608DE5 		str	r6, [sp, #8]
 7429 40e4 0C608DE5 		str	r6, [sp, #12]
 7430 40e8 10908DE5 		str	r9, [sp, #16]
 7431 40ec 14408DE5 		str	r4, [sp, #20]
 7432 40f0 18508DE5 		str	r5, [sp, #24]
 7433 40f4 FEFFFFEB 		bl	_txe_thread_create
 7434              	.LVL610:
3887:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
3888:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
3889:../uvc.c      ****             0,                                          /* No input parameter to thread */
3890:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
3891:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
3892:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3893:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
3894:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3895:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3896:../uvc.c      ****             );
3897:../uvc.c      ****     if (retThrdCreate != 0)
 7435              		.loc 1 3897 0
 7436 40f8 00C050E2 		subs	ip, r0, #0
 7437 40fc D1FFFF1A 		bne	.L602
3898:../uvc.c      ****     {
3899:../uvc.c      ****         goto fatalErrorHandler;
3900:../uvc.c      ****     }
3901:../uvc.c      **** 
3902:../uvc.c      ****     /* Create the control request handling thread. */
3903:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 7438              		.loc 1 3903 0
 7439 4100 0C30A0E1 		mov	r3, ip
 7440 4104 027BA0E3 		mov	r7, #2048
 7441 4108 8C009FE5 		ldr	r0, .L606+28
 7442              	.LVL611:
 7443 410c 8C109FE5 		ldr	r1, .L606+32
 7444 4110 8C209FE5 		ldr	r2, .L606+36
 7445 4114 10C08DE5 		str	ip, [sp, #16]
 7446 4118 00B08DE5 		str	fp, [sp, #0]
 7447 411c 04708DE5 		str	r7, [sp, #4]
 7448 4120 08608DE5 		str	r6, [sp, #8]
 7449 4124 0C608DE5 		str	r6, [sp, #12]
 7450 4128 14408DE5 		str	r4, [sp, #20]
 7451 412c 18508DE5 		str	r5, [sp, #24]
 7452 4130 FEFFFFEB 		bl	_txe_thread_create
 7453              	.LVL612:
3904:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
3905:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
3906:../uvc.c      ****             0,                                                  /* No input parameter to thread */
3907:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
3908:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
3909:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
3910:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
3911:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
3912:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
3913:../uvc.c      ****             );
3914:../uvc.c      ****     if (retThrdCreate != 0)
 7454              		.loc 1 3914 0
 7455 4134 00C050E2 		subs	ip, r0, #0
 7456 4138 C2FFFF1A 		bne	.L602
3915:../uvc.c      ****     {
3916:../uvc.c      ****         goto fatalErrorHandler;
3917:../uvc.c      ****     }
3918:../uvc.c      **** #if 1
3919:../uvc.c      ****     /* Create the I2C control command handling thread. */
3920:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 7457              		.loc 1 3920 0
 7458 413c 24E09DE5 		ldr	lr, [sp, #36]
 7459 4140 60009FE5 		ldr	r0, .L606+40
 7460              	.LVL613:
 7461 4144 60109FE5 		ldr	r1, .L606+44
 7462 4148 60209FE5 		ldr	r2, .L606+48
 7463 414c 0C30A0E1 		mov	r3, ip
 7464 4150 00E08DE5 		str	lr, [sp, #0]
 7465 4154 04708DE5 		str	r7, [sp, #4]
 7466 4158 08608DE5 		str	r6, [sp, #8]
 7467 415c 0C608DE5 		str	r6, [sp, #12]
 7468 4160 10C08DE5 		str	ip, [sp, #16]
 7469 4164 14408DE5 		str	r4, [sp, #20]
 7470 4168 18508DE5 		str	r5, [sp, #24]
 7471 416c FEFFFFEB 		bl	_txe_thread_create
 7472              	.LVL614:
3921:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
3922:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
3923:../uvc.c      ****             0,                                          /* No input parameter to thread */
3924:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
3925:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
3926:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3927:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
3928:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3929:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3930:../uvc.c      ****             );
3931:../uvc.c      ****     if (retThrdCreate != 0)
 7473              		.loc 1 3931 0
 7474 4170 000050E3 		cmp	r0, #0
 7475 4174 B3FFFF1A 		bne	.L602
3932:../uvc.c      ****     {
3933:../uvc.c      ****         goto fatalErrorHandler;
3934:../uvc.c      ****     }
3935:../uvc.c      **** #endif
3936:../uvc.c      **** 
3937:../uvc.c      ****     return;
3938:../uvc.c      **** 
3939:../uvc.c      **** fatalErrorHandler:
3940:../uvc.c      ****     /* Add custom recovery or debug actions here */
3941:../uvc.c      ****     /* Loop indefinitely */
3942:../uvc.c      ****     while (1);
3943:../uvc.c      **** }
 7476              		.loc 1 3943 0
 7477 4178 4CD08DE2 		add	sp, sp, #76
 7478 417c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 7479              	.L607:
 7480              		.align	2
 7481              	.L606:
 7482 4180 00000000 		.word	cmdQuMux
 7483 4184 00000000 		.word	cmdQu
 7484 4188 00000000 		.word	statQu
 7485 418c 00000000 		.word	staQuMux
 7486 4190 A4000000 		.word	.LANCHOR0+164
 7487 4194 100B0000 		.word	.LC62
 7488 4198 00000000 		.word	UVCAppThread_Entry
 7489 419c 4C010000 		.word	.LANCHOR0+332
 7490 41a0 240B0000 		.word	.LC63
 7491 41a4 00000000 		.word	UVCAppEP0Thread_Entry
 7492 41a8 F4010000 		.word	.LANCHOR0+500
 7493 41ac 3C0B0000 		.word	.LC64
 7494 41b0 00000000 		.word	I2cAppThread_Entry
 7495              		.cfi_endproc
 7496              	.LFE26:
 7498              		.align	2
 7499              		.global	main
 7501              	main:
 7502              	.LFB27:
3944:../uvc.c      **** 
3945:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
3946:../uvc.c      ****  * the ThreadX RTOS here.
3947:../uvc.c      ****  */
3948:../uvc.c      **** int
3949:../uvc.c      **** main (
3950:../uvc.c      ****         void)
3951:../uvc.c      **** {
 7503              		.loc 1 3951 0
 7504              		.cfi_startproc
 7505              		@ args = 0, pretend = 0, frame = 56
 7506              		@ frame_needed = 0, uses_anonymous_args = 0
 7507 41b4 30402DE9 		stmfd	sp!, {r4, r5, lr}
 7508              	.LCFI27:
 7509              		.cfi_def_cfa_offset 12
3952:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3953:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
3954:../uvc.c      **** 
3955:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
3956:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
3957:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
3958:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
3959:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
3960:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7510              		.loc 1 3960 0
 7511 41b8 0010A0E3 		mov	r1, #0
3951:../uvc.c      **** {
 7512              		.loc 1 3951 0
 7513 41bc 3CD04DE2 		sub	sp, sp, #60
 7514              	.LCFI28:
 7515              		.cfi_def_cfa_offset 72
3957:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7516              		.loc 1 3957 0
 7517 41c0 0220A0E3 		mov	r2, #2
3961:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7518              		.loc 1 3961 0
 7519 41c4 033081E2 		add	r3, r1, #3
3956:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7520              		.loc 1 3956 0
 7521 41c8 0150A0E3 		mov	r5, #1
 7522              		.cfi_offset 14, -4
 7523              		.cfi_offset 5, -8
 7524              		.cfi_offset 4, -12
3962:../uvc.c      **** 
3963:../uvc.c      ****     /* Initialize the device */
3964:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 7525              		.loc 1 3964 0
 7526 41cc 28008DE2 		add	r0, sp, #40
3956:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7527              		.loc 1 3956 0
 7528 41d0 28508DE5 		str	r5, [sp, #40]
3957:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7529              		.loc 1 3957 0
 7530 41d4 2C20CDE5 		strb	r2, [sp, #44]
3958:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 7531              		.loc 1 3958 0
 7532 41d8 2D20CDE5 		strb	r2, [sp, #45]
3959:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 7533              		.loc 1 3959 0
 7534 41dc 2E20CDE5 		strb	r2, [sp, #46]
3960:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7535              		.loc 1 3960 0
 7536 41e0 30108DE5 		str	r1, [sp, #48]
3961:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7537              		.loc 1 3961 0
 7538 41e4 3430CDE5 		strb	r3, [sp, #52]
 7539              		.loc 1 3964 0
 7540 41e8 FEFFFFEB 		bl	CyU3PDeviceInit
 7541              	.LVL615:
3965:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7542              		.loc 1 3965 0
 7543 41ec 004050E2 		subs	r4, r0, #0
 7544 41f0 0000000A 		beq	.L611
 7545              	.L609:
 7546              	.L610:
 7547 41f4 FEFFFFEA 		b	.L610
 7548              	.L611:
3966:../uvc.c      ****     {
3967:../uvc.c      ****         goto handle_fatal_error;
3968:../uvc.c      ****     }
3969:../uvc.c      **** 
3970:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
3971:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 7549              		.loc 1 3971 0
 7550 41f8 0410A0E1 		mov	r1, r4
 7551 41fc 0420A0E1 		mov	r2, r4
 7552 4200 0500A0E1 		mov	r0, r5
 7553              	.LVL616:
 7554 4204 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 7555              	.LVL617:
3972:../uvc.c      **** 
3973:../uvc.c      ****     /* Configure the IO matrix for the device. */
3974:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
3975:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
3976:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
3977:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
3978:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
3979:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
3980:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
3981:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
3982:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
3983:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
3984:../uvc.c      **** 
3985:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 7556              		.loc 1 3985 0
 7557 4208 0D00A0E1 		mov	r0, sp
3975:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 7558              		.loc 1 3975 0
 7559 420c 1640CDE5 		strb	r4, [sp, #22]
3976:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 7560              		.loc 1 3976 0
 7561 4210 18408DE5 		str	r4, [sp, #24]
3977:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 7562              		.loc 1 3977 0
 7563 4214 1C408DE5 		str	r4, [sp, #28]
3978:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 7564              		.loc 1 3978 0
 7565 4218 20408DE5 		str	r4, [sp, #32]
3979:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 7566              		.loc 1 3979 0
 7567 421c 24408DE5 		str	r4, [sp, #36]
3982:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 7568              		.loc 1 3982 0
 7569 4220 0C408DE5 		str	r4, [sp, #12]
3983:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 7570              		.loc 1 3983 0
 7571 4224 10408DE5 		str	r4, [sp, #16]
3974:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 7572              		.loc 1 3974 0
 7573 4228 00508DE5 		str	r5, [sp, #0]
3980:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 7574              		.loc 1 3980 0
 7575 422c 04508DE5 		str	r5, [sp, #4]
3981:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 7576              		.loc 1 3981 0
 7577 4230 08508DE5 		str	r5, [sp, #8]
 7578              		.loc 1 3985 0
 7579 4234 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 7580              	.LVL618:
3986:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7581              		.loc 1 3986 0
 7582 4238 004050E2 		subs	r4, r0, #0
 7583 423c ECFFFF1A 		bne	.L609
3987:../uvc.c      ****     {
3988:../uvc.c      ****         goto handle_fatal_error;
3989:../uvc.c      ****     }
3990:../uvc.c      **** 
3991:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
3992:../uvc.c      ****     CyU3PKernelEntry ();
 7584              		.loc 1 3992 0
 7585 4240 FEFFFFEB 		bl	_tx_initialize_kernel_enter
 7586              	.LVL619:
3993:../uvc.c      **** 
3994:../uvc.c      ****     /* Dummy return to make the compiler happy */
3995:../uvc.c      ****     return 0;
3996:../uvc.c      **** 
3997:../uvc.c      **** handle_fatal_error:
3998:../uvc.c      ****     /* Cannot recover from this error. */
3999:../uvc.c      ****     while (1);
4000:../uvc.c      **** }
 7587              		.loc 1 4000 0
 7588 4244 0400A0E1 		mov	r0, r4
 7589 4248 3CD08DE2 		add	sp, sp, #60
 7590 424c 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 7591              		.cfi_endproc
 7592              	.LFE27:
 7594              		.global	CyFxGpifTransition
 7595              		.global	CyFxGpifWavedata
 7596              		.global	CyFxGpifWavedataPosition
 7597              		.global	CyFxGpifRegValue
 7598              		.global	CyFxGpifConfig
 7599              		.global	CyFxGpifTransition_usb2
 7600              		.global	CyFxGpifWavedata_usb2
 7601              		.global	CyFxGpifWavedataPosition_usb2
 7602              		.global	CyFxGpifRegValue_usb2
 7603              		.global	CyFxGpifConfig_usb2
 7604              		.global	snapButFlag
 7605              		.global	testSnap
 7606              		.global	fb
 7607              		.global	pb
 7608              		.global	pbc
 7609              		.global	fbbak
 7610              		.global	pbbak
 7611              		.global	pbcbak
 7612              		.global	pbcpbak
 7613              		.global	isUsbConnected
 7614              		.global	usbSpeed
 7615              		.global	clearFeatureRqtReceived
 7616              		.global	streamingStarted
 7617              		.global	glProbeCtrl
 7618              		.global	glProbeCtrlFull
 7619              		.global	glProbeStilCtrl
 7620              		.global	glProbeCtrl20
 7621              		.global	glProbeStilCtrl20
 7622              		.global	glUVCHeader
 7623              		.comm	glChHandleUVCStream,220,4
 7624              		.comm	glChHandleStillStream,220,4
 7625              		.comm	glChHandleInterStat,160,4
 7626              		.comm	glInterStaBuffer,4,4
 7627              		.comm	cmdQu,32,4
 7628              		.comm	statQu,32,4
 7629              		.comm	cmdQuMux,56,4
 7630              		.comm	staQuMux,56,4
 7631              		.comm	timMux,56,4
 7632              		.comm	imgHdMux,56,4
 7633              		.comm	bmReqType,1,1
 7634              		.comm	bRequest,1,1
 7635              		.comm	wValue,2,2
 7636              		.comm	wIndex,2,2
 7637              		.comm	wLength,2,2
 7638              		.comm	posTick,4,4
 7639              		.comm	I2CCmdTimer,44,4
 7640              		.section	.rodata
 7641              		.align	2
 7642              		.set	.LANCHOR2,. + 0
 7645              	ExTime:
 7646 0000 9C       		.byte	-100
 7647 0001 00       		.byte	0
 7648 0002 4E       		.byte	78
 7649 0003 00       		.byte	0
 7650 0004 27       		.byte	39
 7651 0005 00       		.byte	0
 7652 0006 14       		.byte	20
 7653 0007 00       		.byte	0
 7654 0008 0A       		.byte	10
 7655 0009 00       		.byte	0
 7656 000a 05       		.byte	5
 7657 000b 00       		.byte	0
 7658 000c 02       		.byte	2
 7659 000d 00       		.byte	0
 7660 000e 01       		.byte	1
 7661 000f 00       		.byte	0
 7664              	CyFxGpifConfig:
 7665 0010 0F00     		.short	15
 7666 0012 0000     		.space	2
 7667 0014 00000000 		.word	CyFxGpifWavedata
 7668 0018 00000000 		.word	CyFxGpifWavedataPosition
 7669 001c 0500     		.short	5
 7670 001e 0000     		.space	2
 7671 0020 00000000 		.word	CyFxGpifTransition
 7672 0024 4C00     		.short	76
 7673 0026 0000     		.space	2
 7674 0028 00000000 		.word	CyFxGpifRegValue
 7677              	CyFxGpifConfig_usb2:
 7678 002c 9300     		.short	147
 7679 002e 0000     		.space	2
 7680 0030 00000000 		.word	CyFxGpifWavedata_usb2
 7681 0034 00000000 		.word	CyFxGpifWavedataPosition_usb2
 7682 0038 0800     		.short	8
 7683 003a 0000     		.space	2
 7684 003c 00000000 		.word	CyFxGpifTransition_usb2
 7685 0040 4C00     		.short	76
 7686 0042 0000     		.space	2
 7687 0044 00000000 		.word	CyFxGpifRegValue_usb2
 7688              		.data
 7689              		.align	2
 7690              		.set	.LANCHOR1,. + 0
 7693              	ExUCtrlParArry:
 7694 0000 13       		.byte	19
 7695 0001 14       		.byte	20
 7696 0002 02       		.byte	2
 7697 0003 01       		.byte	1
 7698 0004 00       		.byte	0
 7699 0005 03       		.byte	3
 7700 0006 00       		.byte	0
 7701 0007 01       		.byte	1
 7702 0008 00       		.byte	0
 7703 0009 03       		.byte	3
 7704 000a 00       		.byte	0
 7705 000b 23       		.byte	35
 7706 000c 37       		.byte	55
 7707 000d 23       		.byte	35
 7708 000e 37       		.byte	55
 7709 000f 30       		.byte	48
 7710 0010 01       		.byte	1
 7711 0011 00       		.byte	0
 7712 0012 00       		.byte	0
 7713 0013 00000000 		.space	5
 7713      00
 7714 0018 11       		.byte	17
 7715 0019 00       		.byte	0
 7716 001a 02       		.byte	2
 7717 001b 01       		.byte	1
 7718 001c 00       		.byte	0
 7719 001d 03       		.byte	3
 7720 001e 00       		.byte	0
 7721 001f 01       		.byte	1
 7722 0020 00       		.byte	0
 7723 0021 03       		.byte	3
 7724 0022 00       		.byte	0
 7725 0023 01       		.byte	1
 7726 0024 00       		.byte	0
 7727 0025 01       		.byte	1
 7728 0026 00       		.byte	0
 7729 0027 30       		.byte	48
 7730 0028 01       		.byte	1
 7731 0029 01       		.byte	1
 7732 002a 00       		.byte	0
 7733 002b 00000000 		.space	5
 7733      00
 7734 0030 17       		.byte	23
 7735 0031 00       		.byte	0
 7736 0032 01       		.byte	1
 7737 0033 01       		.byte	1
 7738 0034 00       		.byte	0
 7739 0035 02       		.byte	2
 7740 0036 00       		.byte	0
 7741 0037 01       		.byte	1
 7742 0038 00       		.byte	0
 7743 0039 03       		.byte	3
 7744 003a 00       		.byte	0
 7745 003b 00       		.byte	0
 7746 003c 00       		.byte	0
 7747 003d 00       		.byte	0
 7748 003e 00       		.byte	0
 7749 003f 30       		.byte	48
 7750 0040 01       		.byte	1
 7751 0041 01       		.byte	1
 7752 0042 00       		.byte	0
 7753 0043 00000000 		.space	5
 7753      00
 7754 0048 00       		.byte	0
 7755 0049 00       		.byte	0
 7756 004a 04       		.byte	4
 7757 004b 01       		.byte	1
 7758 004c 00       		.byte	0
 7759 004d 38       		.byte	56
 7760 004e 01       		.byte	1
 7761 004f 01       		.byte	1
 7762 0050 00       		.byte	0
 7763 0051 03       		.byte	3
 7764 0052 00       		.byte	0
 7765 0053 4E       		.byte	78
 7766 0054 00       		.byte	0
 7767 0055 4E       		.byte	78
 7768 0056 00       		.byte	0
 7769 0057 30       		.byte	48
 7770 0058 01       		.byte	1
 7771 0059 00       		.byte	0
 7772 005a 00       		.byte	0
 7773 005b 00000000 		.space	5
 7773      00
 7774 0060 00       		.byte	0
 7775 0061 00       		.byte	0
 7776 0062 01       		.byte	1
 7777 0063 00       		.byte	0
 7778 0064 00       		.byte	0
 7779 0065 00       		.byte	0
 7780 0066 00       		.byte	0
 7781 0067 01       		.byte	1
 7782 0068 00       		.byte	0
 7783 0069 03       		.byte	3
 7784 006a 00       		.byte	0
 7785 006b 00       		.byte	0
 7786 006c 00       		.byte	0
 7787 006d 00       		.byte	0
 7788 006e 00       		.byte	0
 7789 006f 30       		.byte	48
 7790 0070 01       		.byte	1
 7791 0071 00       		.byte	0
 7792 0072 00       		.byte	0
 7793 0073 00000000 		.space	5
 7793      00
 7794 0078 00       		.byte	0
 7795 0079 00       		.byte	0
 7796 007a 02       		.byte	2
 7797 007b 00       		.byte	0
 7798 007c 00       		.byte	0
 7799 007d FF       		.byte	-1
 7800 007e 00       		.byte	0
 7801 007f 01       		.byte	1
 7802 0080 00       		.byte	0
 7803 0081 03       		.byte	3
 7804 0082 00       		.byte	0
 7805 0083 01       		.byte	1
 7806 0084 00       		.byte	0
 7807 0085 00       		.byte	0
 7808 0086 00       		.byte	0
 7809 0087 30       		.byte	48
 7810 0088 01       		.byte	1
 7811 0089 01       		.byte	1
 7812 008a 00       		.byte	0
 7813 008b 00000000 		.space	5
 7813      00
 7814 0090 00       		.byte	0
 7815 0091 00       		.byte	0
 7816 0092 02       		.byte	2
 7817 0093 00       		.byte	0
 7818 0094 00       		.byte	0
 7819 0095 00       		.byte	0
 7820 0096 00       		.byte	0
 7821 0097 00       		.byte	0
 7822 0098 00       		.byte	0
 7823 0099 03       		.byte	3
 7824 009a 00       		.byte	0
 7825 009b 00       		.byte	0
 7826 009c 00       		.byte	0
 7827 009d 00       		.byte	0
 7828 009e 00       		.byte	0
 7829 009f 30       		.byte	48
 7830 00a0 01       		.byte	1
 7831 00a1 01       		.byte	1
 7832 00a2 00       		.byte	0
 7833 00a3 00000000 		.space	5
 7833      00
 7834 00a8 00       		.byte	0
 7835 00a9 00       		.byte	0
 7836 00aa 02       		.byte	2
 7837 00ab 00       		.byte	0
 7838 00ac 00       		.byte	0
 7839 00ad 30       		.byte	48
 7840 00ae 00       		.byte	0
 7841 00af 01       		.byte	1
 7842 00b0 00       		.byte	0
 7843 00b1 03       		.byte	3
 7844 00b2 0A       		.byte	10
 7845 00b3 00       		.byte	0
 7846 00b4 00       		.byte	0
 7847 00b5 0A       		.byte	10
 7848 00b6 00       		.byte	0
 7849 00b7 30       		.byte	48
 7850 00b8 01       		.byte	1
 7851 00b9 01       		.byte	1
 7852 00ba 00       		.byte	0
 7853 00bb 00000000 		.space	5
 7853      00
 7854 00c0 00       		.byte	0
 7855 00c1 00       		.byte	0
 7856 00c2 01       		.byte	1
 7857 00c3 00       		.byte	0
 7858 00c4 00       		.byte	0
 7859 00c5 7F       		.byte	127
 7860 00c6 00       		.byte	0
 7861 00c7 01       		.byte	1
 7862 00c8 00       		.byte	0
 7863 00c9 03       		.byte	3
 7864 00ca 00       		.byte	0
 7865 00cb 00       		.byte	0
 7866 00cc 00       		.byte	0
 7867 00cd 00       		.byte	0
 7868 00ce 00       		.byte	0
 7869 00cf 30       		.byte	48
 7870 00d0 01       		.byte	1
 7871 00d1 00       		.byte	0
 7872 00d2 00       		.byte	0
 7873 00d3 00000000 		.space	5
 7873      00
 7874 00d8 00       		.byte	0
 7875 00d9 00       		.byte	0
 7876 00da 02       		.byte	2
 7877 00db 00       		.byte	0
 7878 00dc 00       		.byte	0
 7879 00dd 05       		.byte	5
 7880 00de 00       		.byte	0
 7881 00df 01       		.byte	1
 7882 00e0 00       		.byte	0
 7883 00e1 03       		.byte	3
 7884 00e2 00       		.byte	0
 7885 00e3 00       		.byte	0
 7886 00e4 00       		.byte	0
 7887 00e5 00       		.byte	0
 7888 00e6 00       		.byte	0
 7889 00e7 30       		.byte	48
 7890 00e8 01       		.byte	1
 7891 00e9 00       		.byte	0
 7892 00ea 00       		.byte	0
 7893 00eb 00000000 		.space	5
 7893      00
 7894 00f0 00       		.byte	0
 7895 00f1 00       		.byte	0
 7896 00f2 03       		.byte	3
 7897 00f3 00       		.byte	0
 7898 00f4 00       		.byte	0
 7899 00f5 0A       		.byte	10
 7900 00f6 00       		.byte	0
 7901 00f7 01       		.byte	1
 7902 00f8 00       		.byte	0
 7903 00f9 03       		.byte	3
 7904 00fa 00       		.byte	0
 7905 00fb 00       		.byte	0
 7906 00fc 00       		.byte	0
 7907 00fd 00       		.byte	0
 7908 00fe 00       		.byte	0
 7909 00ff 30       		.byte	48
 7910 0100 01       		.byte	1
 7911 0101 00       		.byte	0
 7912 0102 00       		.byte	0
 7913 0103 00000000 		.space	5
 7913      00
 7914 0108 00       		.byte	0
 7915 0109 00       		.byte	0
 7916 010a 02       		.byte	2
 7917 010b 00       		.byte	0
 7918 010c 00       		.byte	0
 7919 010d 40       		.byte	64
 7920 010e 00       		.byte	0
 7921 010f 01       		.byte	1
 7922 0110 00       		.byte	0
 7923 0111 03       		.byte	3
 7924 0112 00       		.byte	0
 7925 0113 0F       		.byte	15
 7926 0114 11       		.byte	17
 7927 0115 00       		.byte	0
 7928 0116 00       		.byte	0
 7929 0117 30       		.byte	48
 7930 0118 01       		.byte	1
 7931 0119 00       		.byte	0
 7932 011a 00       		.byte	0
 7933 011b 00000000 		.space	5
 7933      00
 7934 0120 00       		.byte	0
 7935 0121 00       		.byte	0
 7936 0122 02       		.byte	2
 7937 0123 00       		.byte	0
 7938 0124 00       		.byte	0
 7939 0125 64       		.byte	100
 7940 0126 00       		.byte	0
 7941 0127 01       		.byte	1
 7942 0128 00       		.byte	0
 7943 0129 03       		.byte	3
 7944 012a 00       		.byte	0
 7945 012b 00       		.byte	0
 7946 012c 00       		.byte	0
 7947 012d 00       		.byte	0
 7948 012e 00       		.byte	0
 7949 012f 30       		.byte	48
 7950 0130 01       		.byte	1
 7951 0131 00       		.byte	0
 7952 0132 00       		.byte	0
 7953 0133 00000000 		.space	5
 7953      00
 7954 0138 00       		.byte	0
 7955 0139 00       		.byte	0
 7956 013a 02       		.byte	2
 7957 013b 00       		.byte	0
 7958 013c 00       		.byte	0
 7959 013d 64       		.byte	100
 7960 013e 00       		.byte	0
 7961 013f 01       		.byte	1
 7962 0140 00       		.byte	0
 7963 0141 03       		.byte	3
 7964 0142 00       		.byte	0
 7965 0143 00       		.byte	0
 7966 0144 00       		.byte	0
 7967 0145 00       		.byte	0
 7968 0146 00       		.byte	0
 7969 0147 30       		.byte	48
 7970 0148 01       		.byte	1
 7971 0149 00       		.byte	0
 7972 014a 00       		.byte	0
 7973 014b 00000000 		.space	5
 7973      00
 7974 0150 00       		.byte	0
 7975 0151 00       		.byte	0
 7976 0152 02       		.byte	2
 7977 0153 00       		.byte	0
 7978 0154 00       		.byte	0
 7979 0155 64       		.byte	100
 7980 0156 00       		.byte	0
 7981 0157 01       		.byte	1
 7982 0158 00       		.byte	0
 7983 0159 03       		.byte	3
 7984 015a 00       		.byte	0
 7985 015b 00       		.byte	0
 7986 015c 00       		.byte	0
 7987 015d 00       		.byte	0
 7988 015e 00       		.byte	0
 7989 015f 30       		.byte	48
 7990 0160 01       		.byte	1
 7991 0161 00       		.byte	0
 7992 0162 00       		.byte	0
 7993 0163 00000000 		.space	5
 7993      00
 7994 0168 00       		.byte	0
 7995 0169 00       		.byte	0
 7996 016a 02       		.byte	2
 7997 016b 00       		.byte	0
 7998 016c 00       		.byte	0
 7999 016d 64       		.byte	100
 8000 016e 00       		.byte	0
 8001 016f 01       		.byte	1
 8002 0170 00       		.byte	0
 8003 0171 03       		.byte	3
 8004 0172 00       		.byte	0
 8005 0173 00       		.byte	0
 8006 0174 00       		.byte	0
 8007 0175 00       		.byte	0
 8008 0176 00       		.byte	0
 8009 0177 30       		.byte	48
 8010 0178 01       		.byte	1
 8011 0179 00       		.byte	0
 8012 017a 00       		.byte	0
 8013 017b 00000000 		.space	5
 8013      00
 8016              	CtrlParArry:
 8017 0180 10       		.byte	16
 8018 0181 10       		.byte	16
 8019 0182 02       		.byte	2
 8020 0183 00       		.byte	0
 8021 0184 00       		.byte	0
 8022 0185 03       		.byte	3
 8023 0186 00       		.byte	0
 8024 0187 01       		.byte	1
 8025 0188 00       		.byte	0
 8026 0189 03       		.byte	3
 8027 018a 00       		.byte	0
 8028 018b 03       		.byte	3
 8029 018c 00       		.byte	0
 8030 018d 03       		.byte	3
 8031 018e 00       		.byte	0
 8032 018f 30       		.byte	48
 8033 0190 01       		.byte	1
 8034 0191 00       		.byte	0
 8035 0192 00       		.byte	0
 8036 0193 00000000 		.space	5
 8036      00
 8037 0198 15       		.byte	21
 8038 0199 15       		.byte	21
 8039 019a 02       		.byte	2
 8040 019b 00       		.byte	0
 8041 019c 00       		.byte	0
 8042 019d FF       		.byte	-1
 8043 019e 00       		.byte	0
 8044 019f 01       		.byte	1
 8045 01a0 00       		.byte	0
 8046 01a1 03       		.byte	3
 8047 01a2 00       		.byte	0
 8048 01a3 76       		.byte	118
 8049 01a4 00       		.byte	0
 8050 01a5 76       		.byte	118
 8051 01a6 C7       		.byte	-57
 8052 01a7 30       		.byte	48
 8053 01a8 01       		.byte	1
 8054 01a9 01       		.byte	1
 8055 01aa 00       		.byte	0
 8056 01ab 00000000 		.space	5
 8056      00
 8057 01b0 02       		.byte	2
 8058 01b1 02       		.byte	2
 8059 01b2 02       		.byte	2
 8060 01b3 00       		.byte	0
 8061 01b4 00       		.byte	0
 8062 01b5 FF       		.byte	-1
 8063 01b6 00       		.byte	0
 8064 01b7 01       		.byte	1
 8065 01b8 00       		.byte	0
 8066 01b9 03       		.byte	3
 8067 01ba 00       		.byte	0
 8068 01bb 70       		.byte	112
 8069 01bc 00       		.byte	0
 8070 01bd 70       		.byte	112
 8071 01be 00       		.byte	0
 8072 01bf C6       		.byte	-58
 8073 01c0 01       		.byte	1
 8074 01c1 01       		.byte	1
 8075 01c2 00       		.byte	0
 8076 01c3 00000000 		.space	5
 8076      00
 8077 01c8 00       		.byte	0
 8078 01c9 00       		.byte	0
 8079 01ca 02       		.byte	2
 8080 01cb 00       		.byte	0
 8081 01cc 00       		.byte	0
 8082 01cd 64       		.byte	100
 8083 01ce 00       		.byte	0
 8084 01cf 01       		.byte	1
 8085 01d0 00       		.byte	0
 8086 01d1 03       		.byte	3
 8087 01d2 00       		.byte	0
 8088 01d3 00       		.byte	0
 8089 01d4 00       		.byte	0
 8090 01d5 00       		.byte	0
 8091 01d6 00       		.byte	0
 8092 01d7 30       		.byte	48
 8093 01d8 01       		.byte	1
 8094 01d9 00       		.byte	0
 8095 01da 00       		.byte	0
 8096 01db 00000000 		.space	5
 8096      00
 8097 01e0 07       		.byte	7
 8098 01e1 07       		.byte	7
 8099 01e2 02       		.byte	2
 8100 01e3 00       		.byte	0
 8101 01e4 00       		.byte	0
 8102 01e5 01       		.byte	1
 8103 01e6 00       		.byte	0
 8104 01e7 01       		.byte	1
 8105 01e8 00       		.byte	0
 8106 01e9 03       		.byte	3
 8107 01ea 00       		.byte	0
 8108 01eb 01       		.byte	1
 8109 01ec 00       		.byte	0
 8110 01ed 01       		.byte	1
 8111 01ee 00       		.byte	0
 8112 01ef 30       		.byte	48
 8113 01f0 01       		.byte	1
 8114 01f1 00       		.byte	0
 8115 01f2 00       		.byte	0
 8116 01f3 00000000 		.space	5
 8116      00
 8117 01f8 DF       		.byte	-33
 8118 01f9 E1       		.byte	-31
 8119 01fa 02       		.byte	2
 8120 01fb 00       		.byte	0
 8121 01fc 00       		.byte	0
 8122 01fd FF       		.byte	-1
 8123 01fe 00       		.byte	0
 8124 01ff 01       		.byte	1
 8125 0200 00       		.byte	0
 8126 0201 03       		.byte	3
 8127 0202 00       		.byte	0
 8128 0203 80       		.byte	-128
 8129 0204 00       		.byte	0
 8130 0205 00       		.byte	0
 8131 0206 00       		.byte	0
 8132 0207 C6       		.byte	-58
 8133 0208 01       		.byte	1
 8134 0209 01       		.byte	1
 8135 020a 00       		.byte	0
 8136 020b 00000000 		.space	5
 8136      00
 8137 0210 85       		.byte	-123
 8138 0211 86       		.byte	-122
 8139 0212 02       		.byte	2
 8140 0213 00       		.byte	0
 8141 0214 00       		.byte	0
 8142 0215 64       		.byte	100
 8143 0216 00       		.byte	0
 8144 0217 01       		.byte	1
 8145 0218 00       		.byte	0
 8146 0219 03       		.byte	3
 8147 021a 00       		.byte	0
 8148 021b 32       		.byte	50
 8149 021c 00       		.byte	0
 8150 021d 32       		.byte	50
 8151 021e 00       		.byte	0
 8152 021f F2       		.byte	-14
 8153 0220 01       		.byte	1
 8154 0221 01       		.byte	1
 8155 0222 00       		.byte	0
 8156 0223 00000000 		.space	5
 8156      00
 8157 0228 06       		.byte	6
 8158 0229 06       		.byte	6
 8159 022a 02       		.byte	2
 8160 022b 00       		.byte	0
 8161 022c 00       		.byte	0
 8162 022d 40       		.byte	64
 8163 022e 00       		.byte	0
 8164 022f 01       		.byte	1
 8165 0230 00       		.byte	0
 8166 0231 03       		.byte	3
 8167 0232 00       		.byte	0
 8168 0233 20       		.byte	32
 8169 0234 00       		.byte	0
 8170 0235 20       		.byte	32
 8171 0236 00       		.byte	0
 8172 0237 30       		.byte	48
 8173 0238 01       		.byte	1
 8174 0239 01       		.byte	1
 8175 023a 00       		.byte	0
 8176 023b 00000000 		.space	5
 8176      00
 8177 0240 00       		.byte	0
 8178 0241 00       		.byte	0
 8179 0242 02       		.byte	2
 8180 0243 00       		.byte	0
 8181 0244 00       		.byte	0
 8182 0245 64       		.byte	100
 8183 0246 00       		.byte	0
 8184 0247 01       		.byte	1
 8185 0248 00       		.byte	0
 8186 0249 03       		.byte	3
 8187 024a 00       		.byte	0
 8188 024b 00       		.byte	0
 8189 024c 00       		.byte	0
 8190 024d 00       		.byte	0
 8191 024e 00       		.byte	0
 8192 024f 30       		.byte	48
 8193 0250 01       		.byte	1
 8194 0251 00       		.byte	0
 8195 0252 00       		.byte	0
 8196 0253 00000000 		.space	5
 8196      00
 8197 0258 08       		.byte	8
 8198 0259 08       		.byte	8
 8199 025a 02       		.byte	2
 8200 025b 00       		.byte	0
 8201 025c 00       		.byte	0
 8202 025d 05       		.byte	5
 8203 025e 00       		.byte	0
 8204 025f 01       		.byte	1
 8205 0260 00       		.byte	0
 8206 0261 03       		.byte	3
 8207 0262 00       		.byte	0
 8208 0263 00       		.byte	0
 8209 0264 00       		.byte	0
 8210 0265 00       		.byte	0
 8211 0266 00       		.byte	0
 8212 0267 30       		.byte	48
 8213 0268 01       		.byte	1
 8214 0269 00       		.byte	0
 8215 026a 00       		.byte	0
 8216 026b 00000000 		.space	5
 8216      00
 8217 0270 00       		.byte	0
 8218 0271 00       		.byte	0
 8219 0272 02       		.byte	2
 8220 0273 00       		.byte	0
 8221 0274 00       		.byte	0
 8222 0275 40       		.byte	64
 8223 0276 00       		.byte	0
 8224 0277 01       		.byte	1
 8225 0278 00       		.byte	0
 8226 0279 03       		.byte	3
 8227 027a 00       		.byte	0
 8228 027b 00       		.byte	0
 8229 027c 00       		.byte	0
 8230 027d 00       		.byte	0
 8231 027e 00       		.byte	0
 8232 027f 30       		.byte	48
 8233 0280 01       		.byte	1
 8234 0281 00       		.byte	0
 8235 0282 00       		.byte	0
 8236 0283 00000000 		.space	5
 8236      00
 8237 0288 09       		.byte	9
 8238 0289 0A       		.byte	10
 8239 028a 04       		.byte	4
 8240 028b 00       		.byte	0
 8241 028c 00       		.byte	0
 8242 028d 40       		.byte	64
 8243 028e 00       		.byte	0
 8244 028f 01       		.byte	1
 8245 0290 00       		.byte	0
 8246 0291 03       		.byte	3
 8247 0292 00       		.byte	0
 8248 0293 20       		.byte	32
 8249 0294 38       		.byte	56
 8250 0295 20       		.byte	32
 8251 0296 38       		.byte	56
 8252 0297 30       		.byte	48
 8253 0298 01       		.byte	1
 8254 0299 00       		.byte	0
 8255 029a 00       		.byte	0
 8256 029b 00000000 		.space	5
 8256      00
 8257 02a0 00       		.byte	0
 8258 02a1 00       		.byte	0
 8259 02a2 02       		.byte	2
 8260 02a3 00       		.byte	0
 8261 02a4 00       		.byte	0
 8262 02a5 64       		.byte	100
 8263 02a6 00       		.byte	0
 8264 02a7 01       		.byte	1
 8265 02a8 00       		.byte	0
 8266 02a9 03       		.byte	3
 8267 02aa 00       		.byte	0
 8268 02ab 00       		.byte	0
 8269 02ac 00       		.byte	0
 8270 02ad 00       		.byte	0
 8271 02ae 00       		.byte	0
 8272 02af 30       		.byte	48
 8273 02b0 01       		.byte	1
 8274 02b1 00       		.byte	0
 8275 02b2 00       		.byte	0
 8276 02b3 00000000 		.space	5
 8276      00
 8277 02b8 00       		.byte	0
 8278 02b9 00       		.byte	0
 8279 02ba 02       		.byte	2
 8280 02bb 00       		.byte	0
 8281 02bc 00       		.byte	0
 8282 02bd 64       		.byte	100
 8283 02be 00       		.byte	0
 8284 02bf 01       		.byte	1
 8285 02c0 00       		.byte	0
 8286 02c1 03       		.byte	3
 8287 02c2 00       		.byte	0
 8288 02c3 00       		.byte	0
 8289 02c4 00       		.byte	0
 8290 02c5 00       		.byte	0
 8291 02c6 00       		.byte	0
 8292 02c7 30       		.byte	48
 8293 02c8 01       		.byte	1
 8294 02c9 00       		.byte	0
 8295 02ca 00       		.byte	0
 8296 02cb 00000000 		.space	5
 8296      00
 8297 02d0 2A       		.byte	42
 8298 02d1 2A       		.byte	42
 8299 02d2 02       		.byte	2
 8300 02d3 00       		.byte	0
 8301 02d4 00       		.byte	0
 8302 02d5 1B       		.byte	27
 8303 02d6 00       		.byte	0
 8304 02d7 01       		.byte	1
 8305 02d8 00       		.byte	0
 8306 02d9 03       		.byte	3
 8307 02da 00       		.byte	0
 8308 02db 00       		.byte	0
 8309 02dc 00       		.byte	0
 8310 02dd 00       		.byte	0
 8311 02de 00       		.byte	0
 8312 02df 30       		.byte	48
 8313 02e0 01       		.byte	1
 8314 02e1 00       		.byte	0
 8315 02e2 00       		.byte	0
 8316 02e3 00000000 		.space	5
 8316      00
 8317 02e8 00       		.byte	0
 8318 02e9 00       		.byte	0
 8319 02ea 02       		.byte	2
 8320 02eb 00       		.byte	0
 8321 02ec 00       		.byte	0
 8322 02ed 64       		.byte	100
 8323 02ee 00       		.byte	0
 8324 02ef 01       		.byte	1
 8325 02f0 00       		.byte	0
 8326 02f1 03       		.byte	3
 8327 02f2 00       		.byte	0
 8328 02f3 00       		.byte	0
 8329 02f4 00       		.byte	0
 8330 02f5 00       		.byte	0
 8331 02f6 00       		.byte	0
 8332 02f7 30       		.byte	48
 8333 02f8 01       		.byte	1
 8334 02f9 00       		.byte	0
 8335 02fa 00       		.byte	0
 8336 02fb 00000000 		.space	5
 8336      00
 8337 0300 00       		.byte	0
 8338 0301 00       		.byte	0
 8339 0302 02       		.byte	2
 8340 0303 00       		.byte	0
 8341 0304 00       		.byte	0
 8342 0305 12       		.byte	18
 8343 0306 00       		.byte	0
 8344 0307 01       		.byte	1
 8345 0308 00       		.byte	0
 8346 0309 03       		.byte	3
 8347 030a 00       		.byte	0
 8348 030b 00       		.byte	0
 8349 030c 00       		.byte	0
 8350 030d 00       		.byte	0
 8351 030e 00       		.byte	0
 8352 030f 30       		.byte	48
 8353 0310 01       		.byte	1
 8354 0311 00       		.byte	0
 8355 0312 00       		.byte	0
 8356 0313 00000000 		.space	5
 8356      00
 8357 0318 01       		.byte	1
 8358 0319 01       		.byte	1
 8359 031a 02       		.byte	2
 8360 031b 00       		.byte	0
 8361 031c 00       		.byte	0
 8362 031d 09       		.byte	9
 8363 031e 00       		.byte	0
 8364 031f 01       		.byte	1
 8365 0320 00       		.byte	0
 8366 0321 03       		.byte	3
 8367 0322 00       		.byte	0
 8368 0323 00       		.byte	0
 8369 0324 00       		.byte	0
 8370 0325 01       		.byte	1
 8371 0326 00       		.byte	0
 8372 0327 30       		.byte	48
 8373 0328 01       		.byte	1
 8374 0329 00       		.byte	0
 8375 032a 00       		.byte	0
 8376 032b 00000000 		.space	5
 8376      00
 8377 0330 05       		.byte	5
 8378 0331 05       		.byte	5
 8379 0332 02       		.byte	2
 8380 0333 00       		.byte	0
 8381 0334 00       		.byte	0
 8382 0335 03       		.byte	3
 8383 0336 00       		.byte	0
 8384 0337 01       		.byte	1
 8385 0338 00       		.byte	0
 8386 0339 03       		.byte	3
 8387 033a 00       		.byte	0
 8388 033b 00       		.byte	0
 8389 033c 00       		.byte	0
 8390 033d 02       		.byte	2
 8391 033e 00       		.byte	0
 8392 033f 30       		.byte	48
 8393 0340 01       		.byte	1
 8394 0341 00       		.byte	0
 8395 0342 00       		.byte	0
 8396 0343 00000000 		.space	5
 8396      00
 8397 0348 18       		.byte	24
 8398 0349 18       		.byte	24
 8399 034a 02       		.byte	2
 8400 034b 00       		.byte	0
 8401 034c 00       		.byte	0
 8402 034d 01       		.byte	1
 8403 034e 00       		.byte	0
 8404 034f 01       		.byte	1
 8405 0350 00       		.byte	0
 8406 0351 03       		.byte	3
 8407 0352 00       		.byte	0
 8408 0353 00       		.byte	0
 8409 0354 00       		.byte	0
 8410 0355 00       		.byte	0
 8411 0356 00       		.byte	0
 8412 0357 30       		.byte	48
 8413 0358 01       		.byte	1
 8414 0359 00       		.byte	0
 8415 035a 00       		.byte	0
 8416 035b 00000000 		.space	5
 8416      00
 8417 0360 19       		.byte	25
 8418 0361 19       		.byte	25
 8419 0362 01       		.byte	1
 8420 0363 00       		.byte	0
 8421 0364 00       		.byte	0
 8422 0365 40       		.byte	64
 8423 0366 00       		.byte	0
 8424 0367 01       		.byte	1
 8425 0368 00       		.byte	0
 8426 0369 03       		.byte	3
 8427 036a 00       		.byte	0
 8428 036b 20       		.byte	32
 8429 036c 00       		.byte	0
 8430 036d 20       		.byte	32
 8431 036e 00       		.byte	0
 8432 036f 30       		.byte	48
 8433 0370 01       		.byte	1
 8434 0371 00       		.byte	0
 8435 0372 00       		.byte	0
 8436 0373 00000000 		.space	5
 8436      00
 8437 0378 20       		.byte	32
 8438 0379 20       		.byte	32
 8439 037a 02       		.byte	2
 8440 037b 00       		.byte	0
 8441 037c 00       		.byte	0
 8442 037d 02       		.byte	2
 8443 037e 00       		.byte	0
 8444 037f 01       		.byte	1
 8445 0380 00       		.byte	0
 8446 0381 03       		.byte	3
 8447 0382 00       		.byte	0
 8448 0383 00       		.byte	0
 8449 0384 00       		.byte	0
 8450 0385 00       		.byte	0
 8451 0386 00       		.byte	0
 8452 0387 30       		.byte	48
 8453 0388 01       		.byte	1
 8454 0389 00       		.byte	0
 8455 038a 00       		.byte	0
 8456 038b 00000000 		.space	5
 8456      00
 8457 0390 22       		.byte	34
 8458 0391 22       		.byte	34
 8459 0392 02       		.byte	2
 8460 0393 00       		.byte	0
 8461 0394 00       		.byte	0
 8462 0395 3F       		.byte	63
 8463 0396 00       		.byte	0
 8464 0397 01       		.byte	1
 8465 0398 00       		.byte	0
 8466 0399 03       		.byte	3
 8467 039a 00       		.byte	0
 8468 039b 00       		.byte	0
 8469 039c 00       		.byte	0
 8470 039d 00       		.byte	0
 8471 039e 00       		.byte	0
 8472 039f 30       		.byte	48
 8473 03a0 01       		.byte	1
 8474 03a1 00       		.byte	0
 8475 03a2 00       		.byte	0
 8476 03a3 00000000 		.space	5
 8476      00
 8477 03a8 23       		.byte	35
 8478 03a9 23       		.byte	35
 8479 03aa 02       		.byte	2
 8480 03ab 00       		.byte	0
 8481 03ac 00       		.byte	0
 8482 03ad 64       		.byte	100
 8483 03ae 00       		.byte	0
 8484 03af 01       		.byte	1
 8485 03b0 00       		.byte	0
 8486 03b1 03       		.byte	3
 8487 03b2 00       		.byte	0
 8488 03b3 10       		.byte	16
 8489 03b4 00       		.byte	0
 8490 03b5 10       		.byte	16
 8491 03b6 00       		.byte	0
 8492 03b7 30       		.byte	48
 8493 03b8 01       		.byte	1
 8494 03b9 00       		.byte	0
 8495 03ba 00       		.byte	0
 8496 03bb 00000000 		.space	5
 8496      00
 8497 03c0 24       		.byte	36
 8498 03c1 24       		.byte	36
 8499 03c2 02       		.byte	2
 8500 03c3 00       		.byte	0
 8501 03c4 00       		.byte	0
 8502 03c5 64       		.byte	100
 8503 03c6 00       		.byte	0
 8504 03c7 01       		.byte	1
 8505 03c8 00       		.byte	0
 8506 03c9 03       		.byte	3
 8507 03ca 00       		.byte	0
 8508 03cb 10       		.byte	16
 8509 03cc 00       		.byte	0
 8510 03cd 10       		.byte	16
 8511 03ce 00       		.byte	0
 8512 03cf 30       		.byte	48
 8513 03d0 01       		.byte	1
 8514 03d1 00       		.byte	0
 8515 03d2 00       		.byte	0
 8516 03d3 00000000 		.space	5
 8516      00
 8517 03d8 02       		.byte	2
 8518 03d9 03       		.byte	3
 8519 03da 04       		.byte	4
 8520 03db 00       		.byte	0
 8521 03dc 00       		.byte	0
 8522 03dd 7F       		.byte	127
 8523 03de 00       		.byte	0
 8524 03df 01       		.byte	1
 8525 03e0 00       		.byte	0
 8526 03e1 03       		.byte	3
 8527 03e2 00       		.byte	0
 8528 03e3 00       		.byte	0
 8529 03e4 20       		.byte	32
 8530 03e5 00       		.byte	0
 8531 03e6 20       		.byte	32
 8532 03e7 30       		.byte	48
 8533 03e8 01       		.byte	1
 8534 03e9 00       		.byte	0
 8535 03ea 00       		.byte	0
 8536 03eb 00000000 		.space	5
 8536      00
 8537 03f0 04       		.byte	4
 8538 03f1 04       		.byte	4
 8539 03f2 02       		.byte	2
 8540 03f3 00       		.byte	0
 8541 03f4 00       		.byte	0
 8542 03f5 40       		.byte	64
 8543 03f6 00       		.byte	0
 8544 03f7 01       		.byte	1
 8545 03f8 00       		.byte	0
 8546 03f9 03       		.byte	3
 8547 03fa 00       		.byte	0
 8548 03fb 20       		.byte	32
 8549 03fc 00       		.byte	0
 8550 03fd 20       		.byte	32
 8551 03fe 00       		.byte	0
 8552 03ff 30       		.byte	48
 8553 0400 01       		.byte	1
 8554 0401 00       		.byte	0
 8555 0402 00       		.byte	0
 8556 0403 00000000 		.space	5
 8556      00
 8557 0408 00       		.byte	0
 8558 0409 00       		.byte	0
 8559 040a 02       		.byte	2
 8560 040b 00       		.byte	0
 8561 040c 00       		.byte	0
 8562 040d 19       		.byte	25
 8563 040e 00       		.byte	0
 8564 040f 01       		.byte	1
 8565 0410 00       		.byte	0
 8566 0411 03       		.byte	3
 8567 0412 00       		.byte	0
 8568 0413 00       		.byte	0
 8569 0414 00       		.byte	0
 8570 0415 00       		.byte	0
 8571 0416 00       		.byte	0
 8572 0417 30       		.byte	48
 8573 0418 01       		.byte	1
 8574 0419 00       		.byte	0
 8575 041a 00       		.byte	0
 8576 041b 00000000 		.space	5
 8576      00
 8577 0420 10       		.byte	16
 8578 0421 10       		.byte	16
 8579 0422 02       		.byte	2
 8580 0423 00       		.byte	0
 8581 0424 00       		.byte	0
 8582 0425 06       		.byte	6
 8583 0426 00       		.byte	0
 8584 0427 01       		.byte	1
 8585 0428 00       		.byte	0
 8586 0429 03       		.byte	3
 8587 042a 00       		.byte	0
 8588 042b 03       		.byte	3
 8589 042c 00       		.byte	0
 8590 042d 03       		.byte	3
 8591 042e 00       		.byte	0
 8592 042f 30       		.byte	48
 8593 0430 01       		.byte	1
 8594 0431 00       		.byte	0
 8595 0432 00       		.byte	0
 8596 0433 00000000 		.space	5
 8596      00
 8597 0438 00       		.byte	0
 8598 0439 00       		.byte	0
 8599 043a 02       		.byte	2
 8600 043b 00       		.byte	0
 8601 043c 00       		.byte	0
 8602 043d 03       		.byte	3
 8603 043e 00       		.byte	0
 8604 043f 01       		.byte	1
 8605 0440 00       		.byte	0
 8606 0441 03       		.byte	3
 8607 0442 00       		.byte	0
 8608 0443 00       		.byte	0
 8609 0444 00       		.byte	0
 8610 0445 00       		.byte	0
 8611 0446 00       		.byte	0
 8612 0447 30       		.byte	48
 8613 0448 01       		.byte	1
 8614 0449 00       		.byte	0
 8615 044a 00       		.byte	0
 8616 044b 00000000 		.space	5
 8616      00
 8617 0450 50       		.byte	80
 8618 0451 50       		.byte	80
 8619 0452 01       		.byte	1
 8620 0453 00       		.byte	0
 8621 0454 00       		.byte	0
 8622 0455 03       		.byte	3
 8623 0456 00       		.byte	0
 8624 0457 01       		.byte	1
 8625 0458 00       		.byte	0
 8626 0459 03       		.byte	3
 8627 045a 00       		.byte	0
 8628 045b 00       		.byte	0
 8629 045c 00       		.byte	0
 8630 045d 00       		.byte	0
 8631 045e 00       		.byte	0
 8632 045f 30       		.byte	48
 8633 0460 01       		.byte	1
 8634 0461 00       		.byte	0
 8635 0462 00       		.byte	0
 8636 0463 00000000 		.space	5
 8636      00
 8637 0468 00       		.byte	0
 8638 0469 00       		.byte	0
 8639 046a 0B       		.byte	11
 8640 046b 00       		.byte	0
 8641 046c 00       		.byte	0
 8642 046d FF       		.byte	-1
 8643 046e FF       		.byte	-1
 8644 046f 01       		.byte	1
 8645 0470 00       		.byte	0
 8646 0471 03       		.byte	3
 8647 0472 00       		.byte	0
 8648 0473 00       		.byte	0
 8649 0474 00       		.byte	0
 8650 0475 00       		.byte	0
 8651 0476 00       		.byte	0
 8652 0477 00       		.byte	0
 8653 0478 01       		.byte	1
 8654 0479 00       		.byte	0
 8655 047a 00       		.byte	0
 8656 047b 00000000 		.space	5
 8656      00
 8659              	glUVCHeader:
 8660 0480 0C       		.byte	12
 8661 0481 8C       		.byte	-116
 8662 0482 00       		.byte	0
 8663 0483 00       		.byte	0
 8664 0484 00       		.byte	0
 8665 0485 00       		.byte	0
 8666 0486 00       		.byte	0
 8667 0487 00       		.byte	0
 8668 0488 00       		.byte	0
 8669 0489 00       		.byte	0
 8670 048a 00       		.byte	0
 8671 048b 00       		.byte	0
 8674              	ROIMode:
 8675 048c 01       		.byte	1
 8676 048d 000000   		.space	3
 8679              	WBMenuCmpArry:
 8680 0490 20       		.byte	32
 8681 0491 0F       		.byte	15
 8682 0492 38       		.byte	56
 8683 0493 F0       		.byte	-16
 8686              	CTCtrlParArry:
 8687 0494 00       		.byte	0
 8688 0495 00       		.byte	0
 8689 0496 01       		.byte	1
 8690 0497 00       		.byte	0
 8691 0498 00       		.byte	0
 8692 0499 03       		.byte	3
 8693 049a 00       		.byte	0
 8694 049b 01       		.byte	1
 8695 049c 00       		.byte	0
 8696 049d 03       		.byte	3
 8697 049e 00       		.byte	0
 8698 049f 03       		.byte	3
 8699 04a0 00       		.byte	0
 8700 04a1 03       		.byte	3
 8701 04a2 00       		.byte	0
 8702 04a3 30       		.byte	48
 8703 04a4 01       		.byte	1
 8704 04a5 00       		.byte	0
 8705 04a6 00       		.byte	0
 8706 04a7 00000000 		.space	5
 8706      00
 8707 04ac 00       		.byte	0
 8708 04ad 00       		.byte	0
 8709 04ae 01       		.byte	1
 8710 04af 01       		.byte	1
 8711 04b0 00       		.byte	0
 8712 04b1 0F       		.byte	15
 8713 04b2 00       		.byte	0
 8714 04b3 0F       		.byte	15
 8715 04b4 00       		.byte	0
 8716 04b5 03       		.byte	3
 8717 04b6 00       		.byte	0
 8718 04b7 02       		.byte	2
 8719 04b8 00       		.byte	0
 8720 04b9 02       		.byte	2
 8721 04ba 00       		.byte	0
 8722 04bb 30       		.byte	48
 8723 04bc 01       		.byte	1
 8724 04bd 01       		.byte	1
 8725 04be 00       		.byte	0
 8726 04bf 00000000 		.space	5
 8726      00
 8727 04c4 02       		.byte	2
 8728 04c5 00       		.byte	0
 8729 04c6 01       		.byte	1
 8730 04c7 00       		.byte	0
 8731 04c8 00       		.byte	0
 8732 04c9 01       		.byte	1
 8733 04ca 00       		.byte	0
 8734 04cb 01       		.byte	1
 8735 04cc 00       		.byte	0
 8736 04cd 03       		.byte	3
 8737 04ce 00       		.byte	0
 8738 04cf 00       		.byte	0
 8739 04d0 00       		.byte	0
 8740 04d1 00       		.byte	0
 8741 04d2 00       		.byte	0
 8742 04d3 30       		.byte	48
 8743 04d4 01       		.byte	1
 8744 04d5 01       		.byte	1
 8745 04d6 00       		.byte	0
 8746 04d7 00000000 		.space	5
 8746      00
 8747 04dc 00       		.byte	0
 8748 04dd 00       		.byte	0
 8749 04de 04       		.byte	4
 8750 04df 01       		.byte	1
 8751 04e0 00       		.byte	0
 8752 04e1 38       		.byte	56
 8753 04e2 01       		.byte	1
 8754 04e3 01       		.byte	1
 8755 04e4 00       		.byte	0
 8756 04e5 03       		.byte	3
 8757 04e6 00       		.byte	0
 8758 04e7 4E       		.byte	78
 8759 04e8 00       		.byte	0
 8760 04e9 4E       		.byte	78
 8761 04ea 00       		.byte	0
 8762 04eb 30       		.byte	48
 8763 04ec 01       		.byte	1
 8764 04ed 00       		.byte	0
 8765 04ee 00       		.byte	0
 8766 04ef 00000000 		.space	5
 8766      00
 8767 04f4 04       		.byte	4
 8768 04f5 00       		.byte	0
 8769 04f6 01       		.byte	1
 8770 04f7 00       		.byte	0
 8771 04f8 00       		.byte	0
 8772 04f9 00       		.byte	0
 8773 04fa 00       		.byte	0
 8774 04fb 01       		.byte	1
 8775 04fc 00       		.byte	0
 8776 04fd 03       		.byte	3
 8777 04fe 00       		.byte	0
 8778 04ff 00       		.byte	0
 8779 0500 00       		.byte	0
 8780 0501 00       		.byte	0
 8781 0502 00       		.byte	0
 8782 0503 30       		.byte	48
 8783 0504 01       		.byte	1
 8784 0505 00       		.byte	0
 8785 0506 00       		.byte	0
 8786 0507 00000000 		.space	5
 8786      00
 8787 050c 05       		.byte	5
 8788 050d 00       		.byte	0
 8789 050e 02       		.byte	2
 8790 050f 00       		.byte	0
 8791 0510 00       		.byte	0
 8792 0511 FF       		.byte	-1
 8793 0512 00       		.byte	0
 8794 0513 01       		.byte	1
 8795 0514 00       		.byte	0
 8796 0515 03       		.byte	3
 8797 0516 00       		.byte	0
 8798 0517 01       		.byte	1
 8799 0518 00       		.byte	0
 8800 0519 00       		.byte	0
 8801 051a 00       		.byte	0
 8802 051b 30       		.byte	48
 8803 051c 01       		.byte	1
 8804 051d 01       		.byte	1
 8805 051e 00       		.byte	0
 8806 051f 00000000 		.space	5
 8806      00
 8807 0524 06       		.byte	6
 8808 0525 00       		.byte	0
 8809 0526 02       		.byte	2
 8810 0527 00       		.byte	0
 8811 0528 00       		.byte	0
 8812 0529 00       		.byte	0
 8813 052a 00       		.byte	0
 8814 052b 00       		.byte	0
 8815 052c 00       		.byte	0
 8816 052d 03       		.byte	3
 8817 052e 00       		.byte	0
 8818 052f 00       		.byte	0
 8819 0530 00       		.byte	0
 8820 0531 00       		.byte	0
 8821 0532 00       		.byte	0
 8822 0533 30       		.byte	48
 8823 0534 01       		.byte	1
 8824 0535 01       		.byte	1
 8825 0536 00       		.byte	0
 8826 0537 00000000 		.space	5
 8826      00
 8827 053c 23       		.byte	35
 8828 053d 00       		.byte	0
 8829 053e 02       		.byte	2
 8830 053f 00       		.byte	0
 8831 0540 00       		.byte	0
 8832 0541 30       		.byte	48
 8833 0542 00       		.byte	0
 8834 0543 01       		.byte	1
 8835 0544 00       		.byte	0
 8836 0545 03       		.byte	3
 8837 0546 0A       		.byte	10
 8838 0547 00       		.byte	0
 8839 0548 00       		.byte	0
 8840 0549 0A       		.byte	10
 8841 054a 00       		.byte	0
 8842 054b 30       		.byte	48
 8843 054c 01       		.byte	1
 8844 054d 01       		.byte	1
 8845 054e 00       		.byte	0
 8846 054f 00000000 		.space	5
 8846      00
 8847 0554 08       		.byte	8
 8848 0555 00       		.byte	0
 8849 0556 01       		.byte	1
 8850 0557 00       		.byte	0
 8851 0558 00       		.byte	0
 8852 0559 7F       		.byte	127
 8853 055a 00       		.byte	0
 8854 055b 01       		.byte	1
 8855 055c 00       		.byte	0
 8856 055d 03       		.byte	3
 8857 055e 00       		.byte	0
 8858 055f 00       		.byte	0
 8859 0560 00       		.byte	0
 8860 0561 00       		.byte	0
 8861 0562 00       		.byte	0
 8862 0563 30       		.byte	48
 8863 0564 01       		.byte	1
 8864 0565 00       		.byte	0
 8865 0566 00       		.byte	0
 8866 0567 00000000 		.space	5
 8866      00
 8867 056c 09       		.byte	9
 8868 056d 00       		.byte	0
 8869 056e 02       		.byte	2
 8870 056f 00       		.byte	0
 8871 0570 00       		.byte	0
 8872 0571 05       		.byte	5
 8873 0572 00       		.byte	0
 8874 0573 01       		.byte	1
 8875 0574 00       		.byte	0
 8876 0575 03       		.byte	3
 8877 0576 00       		.byte	0
 8878 0577 00       		.byte	0
 8879 0578 00       		.byte	0
 8880 0579 00       		.byte	0
 8881 057a 00       		.byte	0
 8882 057b 30       		.byte	48
 8883 057c 01       		.byte	1
 8884 057d 00       		.byte	0
 8885 057e 00       		.byte	0
 8886 057f 00000000 		.space	5
 8886      00
 8887 0584 10       		.byte	16
 8888 0585 00       		.byte	0
 8889 0586 03       		.byte	3
 8890 0587 00       		.byte	0
 8891 0588 00       		.byte	0
 8892 0589 00       		.byte	0
 8893 058a 00       		.byte	0
 8894 058b 00       		.byte	0
 8895 058c 00       		.byte	0
 8896 058d 03       		.byte	3
 8897 058e 00       		.byte	0
 8898 058f 00       		.byte	0
 8899 0590 00       		.byte	0
 8900 0591 00       		.byte	0
 8901 0592 00       		.byte	0
 8902 0593 30       		.byte	48
 8903 0594 01       		.byte	1
 8904 0595 00       		.byte	0
 8905 0596 00       		.byte	0
 8906 0597 00000000 		.space	5
 8906      00
 8907 059c 00       		.byte	0
 8908 059d 00       		.byte	0
 8909 059e 02       		.byte	2
 8910 059f 00       		.byte	0
 8911 05a0 00       		.byte	0
 8912 05a1 40       		.byte	64
 8913 05a2 00       		.byte	0
 8914 05a3 01       		.byte	1
 8915 05a4 00       		.byte	0
 8916 05a5 03       		.byte	3
 8917 05a6 00       		.byte	0
 8918 05a7 0F       		.byte	15
 8919 05a8 11       		.byte	17
 8920 05a9 00       		.byte	0
 8921 05aa 00       		.byte	0
 8922 05ab 30       		.byte	48
 8923 05ac 01       		.byte	1
 8924 05ad 00       		.byte	0
 8925 05ae 00       		.byte	0
 8926 05af 00000000 		.space	5
 8926      00
 8927 05b4 00       		.byte	0
 8928 05b5 00       		.byte	0
 8929 05b6 02       		.byte	2
 8930 05b7 00       		.byte	0
 8931 05b8 00       		.byte	0
 8932 05b9 64       		.byte	100
 8933 05ba 00       		.byte	0
 8934 05bb 01       		.byte	1
 8935 05bc 00       		.byte	0
 8936 05bd 03       		.byte	3
 8937 05be 00       		.byte	0
 8938 05bf 00       		.byte	0
 8939 05c0 00       		.byte	0
 8940 05c1 00       		.byte	0
 8941 05c2 00       		.byte	0
 8942 05c3 30       		.byte	48
 8943 05c4 01       		.byte	1
 8944 05c5 00       		.byte	0
 8945 05c6 00       		.byte	0
 8946 05c7 00000000 		.space	5
 8946      00
 8947 05cc 00       		.byte	0
 8948 05cd 00       		.byte	0
 8949 05ce 02       		.byte	2
 8950 05cf 00       		.byte	0
 8951 05d0 00       		.byte	0
 8952 05d1 64       		.byte	100
 8953 05d2 00       		.byte	0
 8954 05d3 01       		.byte	1
 8955 05d4 00       		.byte	0
 8956 05d5 03       		.byte	3
 8957 05d6 00       		.byte	0
 8958 05d7 00       		.byte	0
 8959 05d8 00       		.byte	0
 8960 05d9 00       		.byte	0
 8961 05da 00       		.byte	0
 8962 05db 30       		.byte	48
 8963 05dc 01       		.byte	1
 8964 05dd 00       		.byte	0
 8965 05de 00       		.byte	0
 8966 05df 00000000 		.space	5
 8966      00
 8967 05e4 00       		.byte	0
 8968 05e5 00       		.byte	0
 8969 05e6 02       		.byte	2
 8970 05e7 00       		.byte	0
 8971 05e8 00       		.byte	0
 8972 05e9 64       		.byte	100
 8973 05ea 00       		.byte	0
 8974 05eb 01       		.byte	1
 8975 05ec 00       		.byte	0
 8976 05ed 03       		.byte	3
 8977 05ee 00       		.byte	0
 8978 05ef 00       		.byte	0
 8979 05f0 00       		.byte	0
 8980 05f1 00       		.byte	0
 8981 05f2 00       		.byte	0
 8982 05f3 30       		.byte	48
 8983 05f4 01       		.byte	1
 8984 05f5 00       		.byte	0
 8985 05f6 00       		.byte	0
 8986 05f7 00000000 		.space	5
 8986      00
 8987 05fc 00       		.byte	0
 8988 05fd 00       		.byte	0
 8989 05fe 02       		.byte	2
 8990 05ff 00       		.byte	0
 8991 0600 00       		.byte	0
 8992 0601 64       		.byte	100
 8993 0602 00       		.byte	0
 8994 0603 01       		.byte	1
 8995 0604 00       		.byte	0
 8996 0605 03       		.byte	3
 8997 0606 00       		.byte	0
 8998 0607 00       		.byte	0
 8999 0608 00       		.byte	0
 9000 0609 00       		.byte	0
 9001 060a 00       		.byte	0
 9002 060b 30       		.byte	48
 9003 060c 01       		.byte	1
 9004 060d 00       		.byte	0
 9005 060e 00       		.byte	0
 9006 060f 00000000 		.space	5
 9006      00
 9009              	glProbeCtrlFull:
 9010 0614 00       		.byte	0
 9011 0615 00       		.byte	0
 9012 0616 01       		.byte	1
 9013 0617 01       		.byte	1
 9014 0618 15       		.byte	21
 9015 0619 16       		.byte	22
 9016 061a 05       		.byte	5
 9017 061b 00       		.byte	0
 9018 061c 00       		.byte	0
 9019 061d 00       		.byte	0
 9020 061e 00       		.byte	0
 9021 061f 00       		.byte	0
 9022 0620 00       		.byte	0
 9023 0621 00       		.byte	0
 9024 0622 00       		.byte	0
 9025 0623 00       		.byte	0
 9026 0624 00       		.byte	0
 9027 0625 00       		.byte	0
 9028 0626 00       		.byte	0
 9029 0627 C6       		.byte	-58
 9030 0628 99       		.byte	-103
 9031 0629 00       		.byte	0
 9032 062a 00       		.byte	0
 9033 062b 40       		.byte	64
 9034 062c 00       		.byte	0
 9035 062d 00       		.byte	0
 9036 062e 0000     		.space	2
 9039              	glProbeCtrl20:
 9040 0630 00       		.byte	0
 9041 0631 00       		.byte	0
 9042 0632 01       		.byte	1
 9043 0633 01       		.byte	1
 9044 0634 80       		.byte	-128
 9045 0635 1A       		.byte	26
 9046 0636 06       		.byte	6
 9047 0637 00       		.byte	0
 9048 0638 00       		.byte	0
 9049 0639 00       		.byte	0
 9050 063a 00       		.byte	0
 9051 063b 00       		.byte	0
 9052 063c 00       		.byte	0
 9053 063d 00       		.byte	0
 9054 063e 00       		.byte	0
 9055 063f 00       		.byte	0
 9056 0640 00       		.byte	0
 9057 0641 00       		.byte	0
 9058 0642 00       		.byte	0
 9059 0643 D2       		.byte	-46
 9060 0644 0F       		.byte	15
 9061 0645 00       		.byte	0
 9062 0646 00       		.byte	0
 9063 0647 40       		.byte	64
 9064 0648 00       		.byte	0
 9065 0649 00       		.byte	0
 9066 064a 0000     		.space	2
 9069              	glProbeCtrl:
 9070 064c 00       		.byte	0
 9071 064d 00       		.byte	0
 9072 064e 01       		.byte	1
 9073 064f 01       		.byte	1
 9074 0650 15       		.byte	21
 9075 0651 16       		.byte	22
 9076 0652 05       		.byte	5
 9077 0653 00       		.byte	0
 9078 0654 00       		.byte	0
 9079 0655 00       		.byte	0
 9080 0656 00       		.byte	0
 9081 0657 00       		.byte	0
 9082 0658 00       		.byte	0
 9083 0659 00       		.byte	0
 9084 065a 00       		.byte	0
 9085 065b 00       		.byte	0
 9086 065c 00       		.byte	0
 9087 065d 00       		.byte	0
 9088 065e 00       		.byte	0
 9089 065f 48       		.byte	72
 9090 0660 3F       		.byte	63
 9091 0661 00       		.byte	0
 9092 0662 00       		.byte	0
 9093 0663 40       		.byte	64
 9094 0664 00       		.byte	0
 9095 0665 00       		.byte	0
 9096 0666 0000     		.space	2
 9099              	glProbeStilCtrl:
 9100 0668 01       		.byte	1
 9101 0669 02       		.byte	2
 9102 066a 00       		.byte	0
 9103 066b 00       		.byte	0
 9104 066c C6       		.byte	-58
 9105 066d 99       		.byte	-103
 9106 066e 00       		.byte	0
 9107 066f 00       		.byte	0
 9108 0670 40       		.byte	64
 9109 0671 00       		.byte	0
 9110 0672 00       		.byte	0
 9111 0673 00       		.space	1
 9114              	glProbeStilCtrl20:
 9115 0674 01       		.byte	1
 9116 0675 01       		.byte	1
 9117 0676 00       		.byte	0
 9118 0677 00       		.byte	0
 9119 0678 D2       		.byte	-46
 9120 0679 0F       		.byte	15
 9121 067a 00       		.byte	0
 9122 067b 00       		.byte	0
 9123 067c 40       		.byte	64
 9124 067d 00       		.byte	0
 9125 067e 00       		.byte	0
 9128              	snapButFlag:
 9129 067f 01       		.byte	1
 9132              	CyFxGpifTransition:
 9133 0680 0000     		.short	0
 9134 0682 5555     		.short	21845
 9135 0684 8888     		.short	-30584
 9136 0686 AAAA     		.short	-21846
 9137 0688 3333     		.short	13107
 9138 068a 0000     		.space	2
 9141              	CyFxGpifWavedata:
 9142 068c 0181731E 		.word	510886145
 9143 0690 00000000 		.word	0
 9144 0694 00000080 		.word	-2147483648
 9145 0698 00000000 		.word	0
 9146 069c 00000000 		.word	0
 9147 06a0 00000000 		.word	0
 9148 06a4 0201702E 		.word	779092226
 9149 06a8 00010000 		.word	256
 9150 06ac A0000080 		.word	-2147483488
 9151 06b0 00000000 		.word	0
 9152 06b4 00000000 		.word	0
 9153 06b8 00000000 		.word	0
 9154 06bc 0380722E 		.word	779255811
 9155 06c0 02010020 		.word	536871170
 9156 06c4 60000080 		.word	-2147483552
 9157 06c8 00000000 		.word	0
 9158 06cc 00000000 		.word	0
 9159 06d0 00000000 		.word	0
 9160 06d4 0460722E 		.word	779247620
 9161 06d8 02010024 		.word	603980034
 9162 06dc 90000080 		.word	-2147483504
 9163 06e0 0594731E 		.word	510891013
 9164 06e4 06000000 		.word	6
 9165 06e8 00000080 		.word	-2147483648
 9166 06ec 0380722E 		.word	779255811
 9167 06f0 02010020 		.word	536871170
 9168 06f4 60000080 		.word	-2147483552
 9169 06f8 0693731E 		.word	510890758
 9170 06fc 06000000 		.word	6
 9171 0700 00000080 		.word	-2147483648
 9172 0704 0720703E 		.word	1047535623
 9173 0708 08010000 		.word	264
 9174 070c 00000080 		.word	-2147483648
 9175 0710 0820703E 		.word	1047535624
 9176 0714 08010000 		.word	264
 9177 0718 00000080 		.word	-2147483648
 9178 071c 0920703E 		.word	1047535625
 9179 0720 08010000 		.word	264
 9180 0724 00000080 		.word	-2147483648
 9181 0728 0A20703E 		.word	1047535626
 9182 072c 08010000 		.word	264
 9183 0730 00000080 		.word	-2147483648
 9184 0734 0380722E 		.word	779255811
 9185 0738 02010020 		.word	536871170
 9186 073c 60000080 		.word	-2147483552
 9187 0740 0B000000 		.word	11
 9188 0744 00000000 		.word	0
 9189 0748 00010080 		.word	-2147483392
 9190 074c 0460722E 		.word	779247620
 9191 0750 02010024 		.word	603980034
 9192 0754 90000080 		.word	-2147483504
 9193 0758 0D000000 		.word	13
 9194 075c 00000000 		.word	0
 9195 0760 00010080 		.word	-2147483392
 9196 0764 0460722E 		.word	779247620
 9197 0768 02010024 		.word	603980034
 9198 076c 90000080 		.word	-2147483504
 9199 0770 0C000000 		.word	12
 9200 0774 00000000 		.word	0
 9201 0778 00010080 		.word	-2147483392
 9202 077c 0380722E 		.word	779255811
 9203 0780 02010020 		.word	536871170
 9204 0784 60000080 		.word	-2147483552
 9205 0788 0E000000 		.word	14
 9206 078c 00000000 		.word	0
 9207 0790 00010080 		.word	-2147483392
 9208 0794 00000000 		.word	0
 9209 0798 00000000 		.word	0
 9210 079c 00000000 		.word	0
 9211 07a0 00000000 		.word	0
 9212 07a4 00000000 		.word	0
 9213 07a8 00000000 		.word	0
 9216              	CyFxGpifWavedataPosition:
 9217 07ac 00       		.byte	0
 9218 07ad 01       		.byte	1
 9219 07ae 02       		.byte	2
 9220 07af 03       		.byte	3
 9221 07b0 04       		.byte	4
 9222 07b1 05       		.byte	5
 9223 07b2 06       		.byte	6
 9224 07b3 07       		.byte	7
 9225 07b4 08       		.byte	8
 9226 07b5 09       		.byte	9
 9227 07b6 0A       		.byte	10
 9228 07b7 0B       		.byte	11
 9229 07b8 0B       		.byte	11
 9230 07b9 0B       		.byte	11
 9231 07ba 0B       		.byte	11
 9232 07bb 00       		.space	1
 9235              	CyFxGpifRegValue:
 9236 07bc 08830080 		.word	-2147450104
 9237 07c0 67000000 		.word	103
 9238 07c4 00000000 		.word	0
 9239 07c8 46000000 		.word	70
 9240 07cc 00000000 		.word	0
 9241 07d0 00000000 		.word	0
 9242 07d4 02000000 		.word	2
 9243 07d8 82000000 		.word	130
 9244 07dc 82070000 		.word	1922
 9245 07e0 40040000 		.word	1088
 9246 07e4 FCFF0000 		.word	65532
 9247 07e8 28000000 		.word	40
 9248 07ec 00000000 		.word	0
 9249 07f0 00000000 		.word	0
 9250 07f4 00000000 		.word	0
 9251 07f8 00000000 		.word	0
 9252 07fc 01000000 		.word	1
 9253 0800 00000000 		.word	0
 9254 0804 00000000 		.word	0
 9255 0808 00000000 		.word	0
 9256 080c 00000000 		.word	0
 9257 0810 00000000 		.word	0
 9258 0814 00000000 		.word	0
 9259 0818 00000000 		.word	0
 9260 081c 00000000 		.word	0
 9261 0820 00000000 		.word	0
 9262 0824 00000000 		.word	0
 9263 0828 00000000 		.word	0
 9264 082c 00000000 		.word	0
 9265 0830 06000000 		.word	6
 9266 0834 00000000 		.word	0
 9267 0838 FFFF0000 		.word	65535
 9268 083c 09010000 		.word	265
 9269 0840 00000000 		.word	0
 9270 0844 F71F0000 		.word	8183
 9271 0848 00000000 		.word	0
 9272 084c FFFF0000 		.word	65535
 9273 0850 09010000 		.word	265
 9274 0854 00000000 		.word	0
 9275 0858 F71F0000 		.word	8183
 9276 085c 00000000 		.word	0
 9277 0860 00000000 		.word	0
 9278 0864 00000000 		.word	0
 9279 0868 00000000 		.word	0
 9280 086c 00000000 		.word	0
 9281 0870 00000000 		.word	0
 9282 0874 00000000 		.word	0
 9283 0878 00000000 		.word	0
 9284 087c 00000000 		.word	0
 9285 0880 00000000 		.word	0
 9286 0884 00000000 		.word	0
 9287 0888 00000000 		.word	0
 9288 088c 00000000 		.word	0
 9289 0890 00000000 		.word	0
 9290 0894 00000000 		.word	0
 9291 0898 00000000 		.word	0
 9292 089c 00000000 		.word	0
 9293 08a0 00000000 		.word	0
 9294 08a4 00000000 		.word	0
 9295 08a8 00000000 		.word	0
 9296 08ac 00000000 		.word	0
 9297 08b0 00000000 		.word	0
 9298 08b4 00000000 		.word	0
 9299 08b8 00040180 		.word	-2147417088
 9300 08bc 01040180 		.word	-2147417087
 9301 08c0 02040180 		.word	-2147417086
 9302 08c4 03040180 		.word	-2147417085
 9303 08c8 00000000 		.word	0
 9304 08cc 00000000 		.word	0
 9305 08d0 00000000 		.word	0
 9306 08d4 00000000 		.word	0
 9307 08d8 00000000 		.word	0
 9308 08dc 00000000 		.word	0
 9309 08e0 00000000 		.word	0
 9310 08e4 00000000 		.word	0
 9311 08e8 C1FFFFFF 		.word	-63
 9314              	CyFxGpifTransition_usb2:
 9315 08ec 0000     		.short	0
 9316 08ee 5555     		.short	21845
 9317 08f0 AAAA     		.short	-21846
 9318 08f2 8888     		.short	-30584
 9319 08f4 1111     		.short	4369
 9320 08f6 4444     		.short	17476
 9321 08f8 3333     		.short	13107
 9322 08fa CCCC     		.short	-13108
 9325              	CyFxGpifWavedata_usb2:
 9326 08fc 0181731E 		.word	510886145
 9327 0900 00000000 		.word	0
 9328 0904 00000080 		.word	-2147483648
 9329 0908 00000000 		.word	0
 9330 090c 00000000 		.word	0
 9331 0910 00000000 		.word	0
 9332 0914 0201703E 		.word	1047527682
 9333 0918 00010000 		.word	256
 9334 091c A00000C0 		.word	-1073741664
 9335 0920 00000000 		.word	0
 9336 0924 00000000 		.word	0
 9337 0928 00000000 		.word	0
 9338 092c 0394731E 		.word	510891011
 9339 0930 04000020 		.word	536870916
 9340 0934 60004080 		.word	-2143289248
 9341 0938 00000000 		.word	0
 9342 093c 00000000 		.word	0
 9343 0940 00000000 		.word	0
 9344 0944 0620702E 		.word	779100166
 9345 0948 0C000000 		.word	12
 9346 094c 00000080 		.word	-2147483648
 9347 0950 0620702E 		.word	779100166
 9348 0954 0C000000 		.word	12
 9349 0958 00000080 		.word	-2147483648
 9350 095c 0394731E 		.word	510891011
 9351 0960 04000020 		.word	536870916
 9352 0964 60004080 		.word	-2143289248
 9353 0968 0620702E 		.word	779100166
 9354 096c 0C000000 		.word	12
 9355 0970 00000080 		.word	-2147483648
 9356 0974 0C93731E 		.word	510890764
 9357 0978 04000024 		.word	603979780
 9358 097c 90004080 		.word	-2143289200
 9359 0980 0D20702E 		.word	779100173
 9360 0984 0C000000 		.word	12
 9361 0988 00000080 		.word	-2147483648
 9362 098c 0780724E 		.word	1316126727
 9363 0990 0A000000 		.word	10
 9364 0994 00000080 		.word	-2147483648
 9365 0998 08000000 		.word	8
 9366 099c 00000000 		.word	0
 9367 09a0 00010080 		.word	-2147483392
 9368 09a4 0920702E 		.word	779100169
 9369 09a8 0C010000 		.word	268
 9370 09ac 00000080 		.word	-2147483648
 9371 09b0 0A01701E 		.word	510656778
 9372 09b4 0E000100 		.word	65550
 9373 09b8 00000080 		.word	-2147483648
 9374 09bc 00000000 		.word	0
 9375 09c0 00000000 		.word	0
 9376 09c4 00000000 		.word	0
 9377 09c8 00000000 		.word	0
 9378 09cc 00000000 		.word	0
 9379 09d0 00000000 		.word	0
 9380 09d4 0394731E 		.word	510891011
 9381 09d8 04000020 		.word	536870916
 9382 09dc 60004080 		.word	-2143289248
 9383 09e0 08000000 		.word	8
 9384 09e4 00000000 		.word	0
 9385 09e8 00010080 		.word	-2147483392
 9386 09ec 0B000000 		.word	11
 9387 09f0 00000000 		.word	0
 9388 09f4 00010080 		.word	-2147483392
 9389 09f8 0C93731E 		.word	510890764
 9390 09fc 04000024 		.word	603979780
 9391 0a00 90004080 		.word	-2143289200
 9392 0a04 0D20702E 		.word	779100173
 9393 0a08 0C000000 		.word	12
 9394 0a0c 00000080 		.word	-2147483648
 9395 0a10 0D20702E 		.word	779100173
 9396 0a14 0C000000 		.word	12
 9397 0a18 00000080 		.word	-2147483648
 9398 0a1c 0E60724E 		.word	1316118542
 9399 0a20 0A000000 		.word	10
 9400 0a24 00000080 		.word	-2147483648
 9401 0a28 0F000000 		.word	15
 9402 0a2c 00000000 		.word	0
 9403 0a30 00010080 		.word	-2147483392
 9404 0a34 1020702E 		.word	779100176
 9405 0a38 0C010000 		.word	268
 9406 0a3c 00000080 		.word	-2147483648
 9407 0a40 1101701E 		.word	510656785
 9408 0a44 0E000100 		.word	65550
 9409 0a48 00000080 		.word	-2147483648
 9410 0a4c 0C93731E 		.word	510890764
 9411 0a50 04000024 		.word	603979780
 9412 0a54 90004080 		.word	-2143289200
 9413 0a58 0F000000 		.word	15
 9414 0a5c 00000000 		.word	0
 9415 0a60 00010080 		.word	-2147483392
 9416 0a64 12000000 		.word	18
 9417 0a68 00000000 		.word	0
 9418 0a6c 00010080 		.word	-2147483392
 9419 0a70 0394731E 		.word	510891011
 9420 0a74 04000020 		.word	536870916
 9421 0a78 60004080 		.word	-2143289248
 9422 0a7c 0480732E 		.word	779321348
 9423 0a80 02010000 		.word	258
 9424 0a84 0000C0C0 		.word	-1061158912
 9425 0a88 0580732E 		.word	779321349
 9426 0a8c 02010000 		.word	258
 9427 0a90 0000C0C0 		.word	-1061158912
 9428 0a94 0580732E 		.word	779321349
 9429 0a98 02010000 		.word	258
 9430 0a9c 0000C0C0 		.word	-1061158912
 9431 0aa0 0480732E 		.word	779321348
 9432 0aa4 02010000 		.word	258
 9433 0aa8 0000C0C0 		.word	-1061158912
 9436              	CyFxGpifWavedataPosition_usb2:
 9437 0aac 00       		.byte	0
 9438 0aad 01       		.byte	1
 9439 0aae 02       		.byte	2
 9440 0aaf 03       		.byte	3
 9441 0ab0 04       		.byte	4
 9442 0ab1 05       		.byte	5
 9443 0ab2 06       		.byte	6
 9444 0ab3 07       		.byte	7
 9445 0ab4 08       		.byte	8
 9446 0ab5 09       		.byte	9
 9447 0ab6 0A       		.byte	10
 9448 0ab7 08       		.byte	8
 9449 0ab8 0B       		.byte	11
 9450 0ab9 0C       		.byte	12
 9451 0aba 0D       		.byte	13
 9452 0abb 08       		.byte	8
 9453 0abc 0E       		.byte	14
 9454 0abd 0F       		.byte	15
 9455 0abe 08       		.byte	8
 9456 0abf 08       		.byte	8
 9457 0ac0 08       		.byte	8
 9458 0ac1 08       		.byte	8
 9459 0ac2 08       		.byte	8
 9460 0ac3 08       		.byte	8
 9461 0ac4 08       		.byte	8
 9462 0ac5 08       		.byte	8
 9463 0ac6 08       		.byte	8
 9464 0ac7 08       		.byte	8
 9465 0ac8 08       		.byte	8
 9466 0ac9 08       		.byte	8
 9467 0aca 08       		.byte	8
 9468 0acb 08       		.byte	8
 9469 0acc 08       		.byte	8
 9470 0acd 08       		.byte	8
 9471 0ace 08       		.byte	8
 9472 0acf 08       		.byte	8
 9473 0ad0 08       		.byte	8
 9474 0ad1 08       		.byte	8
 9475 0ad2 08       		.byte	8
 9476 0ad3 08       		.byte	8
 9477 0ad4 08       		.byte	8
 9478 0ad5 08       		.byte	8
 9479 0ad6 08       		.byte	8
 9480 0ad7 08       		.byte	8
 9481 0ad8 08       		.byte	8
 9482 0ad9 08       		.byte	8
 9483 0ada 08       		.byte	8
 9484 0adb 08       		.byte	8
 9485 0adc 08       		.byte	8
 9486 0add 08       		.byte	8
 9487 0ade 08       		.byte	8
 9488 0adf 08       		.byte	8
 9489 0ae0 08       		.byte	8
 9490 0ae1 08       		.byte	8
 9491 0ae2 08       		.byte	8
 9492 0ae3 08       		.byte	8
 9493 0ae4 08       		.byte	8
 9494 0ae5 08       		.byte	8
 9495 0ae6 08       		.byte	8
 9496 0ae7 08       		.byte	8
 9497 0ae8 08       		.byte	8
 9498 0ae9 08       		.byte	8
 9499 0aea 08       		.byte	8
 9500 0aeb 08       		.byte	8
 9501 0aec 08       		.byte	8
 9502 0aed 08       		.byte	8
 9503 0aee 08       		.byte	8
 9504 0aef 08       		.byte	8
 9505 0af0 08       		.byte	8
 9506 0af1 08       		.byte	8
 9507 0af2 08       		.byte	8
 9508 0af3 08       		.byte	8
 9509 0af4 08       		.byte	8
 9510 0af5 08       		.byte	8
 9511 0af6 08       		.byte	8
 9512 0af7 08       		.byte	8
 9513 0af8 08       		.byte	8
 9514 0af9 08       		.byte	8
 9515 0afa 08       		.byte	8
 9516 0afb 08       		.byte	8
 9517 0afc 08       		.byte	8
 9518 0afd 08       		.byte	8
 9519 0afe 08       		.byte	8
 9520 0aff 08       		.byte	8
 9521 0b00 08       		.byte	8
 9522 0b01 08       		.byte	8
 9523 0b02 08       		.byte	8
 9524 0b03 08       		.byte	8
 9525 0b04 08       		.byte	8
 9526 0b05 08       		.byte	8
 9527 0b06 08       		.byte	8
 9528 0b07 08       		.byte	8
 9529 0b08 08       		.byte	8
 9530 0b09 08       		.byte	8
 9531 0b0a 08       		.byte	8
 9532 0b0b 08       		.byte	8
 9533 0b0c 08       		.byte	8
 9534 0b0d 08       		.byte	8
 9535 0b0e 08       		.byte	8
 9536 0b0f 08       		.byte	8
 9537 0b10 08       		.byte	8
 9538 0b11 08       		.byte	8
 9539 0b12 08       		.byte	8
 9540 0b13 08       		.byte	8
 9541 0b14 08       		.byte	8
 9542 0b15 08       		.byte	8
 9543 0b16 08       		.byte	8
 9544 0b17 08       		.byte	8
 9545 0b18 08       		.byte	8
 9546 0b19 08       		.byte	8
 9547 0b1a 08       		.byte	8
 9548 0b1b 08       		.byte	8
 9549 0b1c 08       		.byte	8
 9550 0b1d 08       		.byte	8
 9551 0b1e 08       		.byte	8
 9552 0b1f 08       		.byte	8
 9553 0b20 08       		.byte	8
 9554 0b21 08       		.byte	8
 9555 0b22 08       		.byte	8
 9556 0b23 08       		.byte	8
 9557 0b24 08       		.byte	8
 9558 0b25 08       		.byte	8
 9559 0b26 08       		.byte	8
 9560 0b27 08       		.byte	8
 9561 0b28 08       		.byte	8
 9562 0b29 08       		.byte	8
 9563 0b2a 08       		.byte	8
 9564 0b2b 08       		.byte	8
 9565 0b2c 00       		.byte	0
 9566 0b2d 01       		.byte	1
 9567 0b2e 02       		.byte	2
 9568 0b2f 10       		.byte	16
 9569 0b30 04       		.byte	4
 9570 0b31 05       		.byte	5
 9571 0b32 06       		.byte	6
 9572 0b33 07       		.byte	7
 9573 0b34 08       		.byte	8
 9574 0b35 09       		.byte	9
 9575 0b36 0A       		.byte	10
 9576 0b37 08       		.byte	8
 9577 0b38 11       		.byte	17
 9578 0b39 0C       		.byte	12
 9579 0b3a 0D       		.byte	13
 9580 0b3b 08       		.byte	8
 9581 0b3c 0E       		.byte	14
 9582 0b3d 0F       		.byte	15
 9583 0b3e 08       		.byte	8
 9584 0b3f 00       		.space	1
 9587              	CyFxGpifRegValue_usb2:
 9588 0b40 08830080 		.word	-2147450104
 9589 0b44 67000000 		.word	103
 9590 0b48 01000000 		.word	1
 9591 0b4c 46000000 		.word	70
 9592 0b50 00000000 		.word	0
 9593 0b54 00000000 		.word	0
 9594 0b58 02000000 		.word	2
 9595 0b5c 82000000 		.word	130
 9596 0b60 82070000 		.word	1922
 9597 0b64 40040000 		.word	1088
 9598 0b68 FCFF0000 		.word	65532
 9599 0b6c 28000000 		.word	40
 9600 0b70 00000000 		.word	0
 9601 0b74 00000000 		.word	0
 9602 0b78 00000000 		.word	0
 9603 0b7c 00000000 		.word	0
 9604 0b80 01000000 		.word	1
 9605 0b84 00000000 		.word	0
 9606 0b88 00000000 		.word	0
 9607 0b8c 00000000 		.word	0
 9608 0b90 00000000 		.word	0
 9609 0b94 00000000 		.word	0
 9610 0b98 00000000 		.word	0
 9611 0b9c 00000000 		.word	0
 9612 0ba0 00000000 		.word	0
 9613 0ba4 00000000 		.word	0
 9614 0ba8 00000000 		.word	0
 9615 0bac 00000000 		.word	0
 9616 0bb0 00000000 		.word	0
 9617 0bb4 06000000 		.word	6
 9618 0bb8 00000000 		.word	0
 9619 0bbc FFFF0000 		.word	65535
 9620 0bc0 09010000 		.word	265
 9621 0bc4 00000000 		.word	0
 9622 0bc8 F71F0000 		.word	8183
 9623 0bcc 00000000 		.word	0
 9624 0bd0 FFFF0000 		.word	65535
 9625 0bd4 09010000 		.word	265
 9626 0bd8 00000000 		.word	0
 9627 0bdc F71F0000 		.word	8183
 9628 0be0 00000000 		.word	0
 9629 0be4 00000000 		.word	0
 9630 0be8 00000000 		.word	0
 9631 0bec 00000000 		.word	0
 9632 0bf0 00000000 		.word	0
 9633 0bf4 00000000 		.word	0
 9634 0bf8 00000000 		.word	0
 9635 0bfc 00000000 		.word	0
 9636 0c00 00000000 		.word	0
 9637 0c04 00000000 		.word	0
 9638 0c08 00000000 		.word	0
 9639 0c0c 00000000 		.word	0
 9640 0c10 00000000 		.word	0
 9641 0c14 00000000 		.word	0
 9642 0c18 00000000 		.word	0
 9643 0c1c 00000000 		.word	0
 9644 0c20 00000000 		.word	0
 9645 0c24 00000000 		.word	0
 9646 0c28 00000000 		.word	0
 9647 0c2c 00000000 		.word	0
 9648 0c30 00000000 		.word	0
 9649 0c34 00000000 		.word	0
 9650 0c38 00000000 		.word	0
 9651 0c3c 00040180 		.word	-2147417088
 9652 0c40 01040180 		.word	-2147417087
 9653 0c44 02040180 		.word	-2147417086
 9654 0c48 03040180 		.word	-2147417085
 9655 0c4c 00000000 		.word	0
 9656 0c50 00000000 		.word	0
 9657 0c54 00000000 		.word	0
 9658 0c58 00000000 		.word	0
 9659 0c5c 00000000 		.word	0
 9660 0c60 00000000 		.word	0
 9661 0c64 00000000 		.word	0
 9662 0c68 00000000 		.word	0
 9663 0c6c C1FFFFFF 		.word	-63
 9664              		.section	.rodata.str1.4,"aMS",%progbits,1
 9665              		.align	2
 9666              	.LC0:
 9667 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 9667      7065722D 
 9667      74696D65 
 9667      72202564 
 9667      0D0A00
 9668 0013 00       		.space	1
 9669              	.LC1:
 9670 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 9670      636F6D6D 
 9670      616E6420 
 9670      71756575 
 9670      65206973 
 9671 0037 00       		.space	1
 9672              	.LC2:
 9673 0038 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 9673      5420656E 
 9673      636F756E 
 9673      74657265 
 9673      642E2E2E 
 9674              	.LC3:
 9675 0058 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 9675      454E4420 
 9675      656E636F 
 9675      756E7465 
 9675      7265642E 
 9676 007a 0000     		.space	2
 9677              	.LC4:
 9678 007c 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 9678      64697363 
 9678      6F6E6E65 
 9678      63746564 
 9678      2E2E2E30 
 9679 009b 00       		.space	1
 9680              	.LC5:
 9681 009c 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 9681      7220696E 
 9681      206D756C 
 9681      74696368 
 9681      616E6E65 
 9682 00cf 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 9682      2025782C 
 9682      20646D61 
 9682      446F6E65 
 9682      20256420 
 9683              	.LC6:
 9684 00e8 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 9684      43595F46 
 9684      585F5556 
 9684      435F5649 
 9684      44454F5F 
 9685 011b 0A00     		.ascii	"\012\000"
 9686 011d 000000   		.space	3
 9687              	.LC7:
 9688 0120 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 9688      43595F46 
 9688      585F5556 
 9688      435F5649 
 9688      44454F5F 
 9689 0153 00       		.ascii	"\000"
 9690              	.LC8:
 9691 0154 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 9691      726E6174 
 9691      65207365 
 9691      7474696E 
 9691      6720302E 
 9692              	.LC9:
 9693 016c 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 9693      72206665 
 9693      61747572 
 9693      65207265 
 9693      71756573 
 9694 018f 00       		.space	1
 9695              	.LC10:
 9696 0190 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 9696      6F6D6D69 
 9696      74656F66 
 9696      20737461 
 9696      7465203D 
 9697              	.LC11:
 9698 01a8 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 9698      6E656C20 
 9698      53657420 
 9698      57726170 
 9698      55702066 
 9699 01d5 000000   		.space	3
 9700              	.LC12:
 9701 01d8 4572726F 		.ascii	"Error handler...\015\012\000"
 9701      72206861 
 9701      6E646C65 
 9701      722E2E2E 
 9701      0D0A00
 9702 01eb 00       		.space	1
 9703              	.LC13:
 9704 01ec 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 9704      69742045 
 9704      4F462066 
 9704      61696C65 
 9704      64210D0A 
 9705 0201 000000   		.space	3
 9706              	.LC14:
 9707 0204 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 9707      49324320 
 9707      636F6D6D 
 9707      616E6420 
 9707      69732030 
 9708 0237 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 9708      78257820 
 9708      30782578 
 9708      20307825 
 9708      78203078 
 9709              	.LC15:
 9710 0250 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 9710      49324320 
 9710      636F6D6D 
 9710      616E6420 
 9710      73657474 
 9711 0276 0000     		.space	2
 9712              	.LC16:
 9713 0278 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 9713      206C6967 
 9713      68742063 
 9713      6F6D7065 
 9713      6E736174 
 9714 02ab 25640D0A 		.ascii	"%d\015\012\000"
 9714      00
 9715              	.LC17:
 9716 02b0 54686520 		.ascii	"The I2C current data is not available. try again. %"
 9716      49324320 
 9716      63757272 
 9716      656E7420 
 9716      64617461 
 9717 02e3 64202564 		.ascii	"d %d\015\012\000"
 9717      0D0A00
 9718 02ea 0000     		.space	2
 9719              	.LC18:
 9720 02ec 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 9720      26414743 
 9720      2073656E 
 9720      7420746F 
 9720      20686F73 
 9721 0312 0000     		.space	2
 9722              	.LC19:
 9723 0314 4578704D 		.ascii	"ExpM&AGC gotten from host. %d %d; %d %d\015\012\000"
 9723      26414743 
 9723      20676F74 
 9723      74656E20 
 9723      66726F6D 
 9724 033e 0000     		.space	2
 9725              	.LC20:
 9726 0340 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 9726      67657420 
 9726      64617461 
 9726      2066726F 
 9726      6D20686F 
 9727 036d 000000   		.space	3
 9728              	.LC21:
 9729 0370 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 9729      52657175 
 9729      65737420 
 9729      30782578 
 9729      20706172 
 9730 03a3 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 9730      6E642074 
 9730      6F20686F 
 9730      73742030 
 9730      78257820 
 9731 03be 0000     		.space	2
 9732              	.LC22:
 9733 03c0 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 9733      204F7020 
 9733      72656365 
 9733      69766573 
 9733      20284354 
 9734 03e7 00       		.space	1
 9735              	.LC23:
 9736 03e8 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 9736      756C7420 
 9736      73656C65 
 9736      63746F72 
 9736      20284354 
 9737 040a 0000     		.space	2
 9738              	.LC24:
 9739 040c 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 9739      756C7420 
 9739      72657175 
 9739      65737420 
 9739      28435429 
 9740 042d 000000   		.space	3
 9741              	.LC25:
 9742 0430 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 9742      52657175 
 9742      65737420 
 9742      30782578 
 9742      20706172 
 9743 0463 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 9743      20307825 
 9743      78202F20 
 9743      73656E64 
 9743      20746F20 
 9744 0490 00       		.ascii	"\000"
 9745 0491 000000   		.space	3
 9746              	.LC26:
 9747 0494 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 9747      73706565 
 9747      64203D20 
 9747      25642065 
 9747      76656E66 
 9748 04c4 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 9748      71756573 
 9748      74203D20 
 9748      30782578 
 9748      20775661 
 9749 04f4 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 9749      203D2030 
 9749      78257820 
 9749      6973666C 
 9749      61672030 
 9750 050e 0000     		.space	2
 9751              	.LC27:
 9752 0510 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 9752      64656661 
 9752      756C7420 
 9752      73657475 
 9752      70207265 
 9753              	.LC28:
 9754 053c 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 9754      6F207374 
 9754      7265616D 
 9754      20474554 
 9754      20726571 
 9755 0561 000000   		.space	3
 9756              	.LC29:
 9757 0564 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 9757      43595F46 
 9757      585F5556 
 9757      435F5354 
 9757      5245414D 
 9758 058a 0000     		.space	2
 9759              	.LC30:
 9760 058c 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 9760      55564320 
 9760      7374696C 
 9760      6C205072 
 9760      6F622873 
 9761 05b7 00       		.space	1
 9762              	.LC31:
 9763 05b8 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 9763      7374696C 
 9763      6C20636F 
 9763      6D6D6974 
 9763      20636F6E 
 9764              	.LC32:
 9765 05e0 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 9765      55564320 
 9765      7374696C 
 9765      6C207472 
 9765      69676765 
 9766 0609 000000   		.space	3
 9767              	.LC33:
 9768 060c 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 9768      7374696C 
 9768      6C207472 
 9768      69676765 
 9768      7220636F 
 9769 0633 00       		.space	1
 9770              	.LC34:
 9771 0634 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 9771      65642074 
 9771      6F207365 
 9771      6E642069 
 9771      6E746572 
 9772 0665 0A00     		.ascii	"\012\000"
 9773 0667 00       		.space	1
 9774              	.LC35:
 9775 0668 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 9775      73657420 
 9775      64656620 
 9775      64617461 
 9775      20307825 
 9776 0687 00       		.space	1
 9777              	.LC36:
 9778 0688 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 9778      73657420 
 9778      64656620 
 9778      64617461 
 9778      20307825 
 9779 06bb 2E0D0A00 		.ascii	".\015\012\000"
 9780 06bf 00       		.space	1
 9781              	.LC37:
 9782 06c0 55415254 		.ascii	"UART initialization failed!\012\000"
 9782      20696E69 
 9782      7469616C 
 9782      697A6174 
 9782      696F6E20 
 9783 06dd 000000   		.space	3
 9784              	.LC38:
 9785 06e0 49324320 		.ascii	"I2C initialization failed!\012\000"
 9785      696E6974 
 9785      69616C69 
 9785      7A617469 
 9785      6F6E2066 
 9786              	.LC39:
 9787 06fc 49324320 		.ascii	"I2C configuration failed!\012\000"
 9787      636F6E66 
 9787      69677572 
 9787      6174696F 
 9787      6E206661 
 9788 0717 00       		.space	1
 9789              	.LC40:
 9790 0718 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 9790      43726561 
 9790      74652045 
 9790      76656E74 
 9790      20666169 
 9791 0742 0000     		.space	2
 9792              	.LC41:
 9793 0744 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 9793      20496E69 
 9793      74206661 
 9793      696C6564 
 9793      2C204572 
 9794 0767 00       		.space	1
 9795              	.LC42:
 9796 0768 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 9796      204F7665 
 9796      72726964 
 9796      65206661 
 9796      696C6564 
 9797 078f 00       		.space	1
 9798              	.LC43:
 9799 0790 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 9799      28323029 
 9799      204F7665 
 9799      72726964 
 9799      65206661 
 9800 07bb 00       		.space	1
 9801              	.LC44:
 9802 07bc 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 9802      28323429 
 9802      204F7665 
 9802      72726964 
 9802      65206661 
 9803 07e7 00       		.space	1
 9804              	.LC45:
 9805 07e8 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 9805      20536574 
 9805      20287265 
 9805      73657420 
 9805      32322920 
 9806 081a 00       		.ascii	"\000"
 9807 081b 00       		.space	1
 9808              	.LC46:
 9809 081c 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 9809      20536574 
 9809      2028706F 
 9809      77657220 
 9809      32302920 
 9810 084e 00       		.ascii	"\000"
 9811 084f 00       		.space	1
 9812              	.LC47:
 9813 0850 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 9813      20536574 
 9813      2028736E 
 9813      61702073 
 9813      686F7420 
 9814 0883 25640A00 		.ascii	"%d\012\000"
 9815 0887 00       		.space	1
 9816              	.LC48:
 9817 0888 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 9817      46756E63 
 9817      74696F6E 
 9817      20466169 
 9817      6C656420 
 9818 08b7 00       		.space	1
 9819              	.LC49:
 9820 08b8 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 9820      46756E63 
 9820      74696F6E 
 9820      20466169 
 9820      6C656420 
 9821 08e7 00       		.space	1
 9822              	.LC50:
 9823 08e8 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 9823      53657420 
 9823      456E6470 
 9823      6F696E74 
 9823      20636F6E 
 9824 0918 00       		.ascii	"\000"
 9825 0919 000000   		.space	3
 9826              	.LC51:
 9827 091c 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 9827      496E7465 
 9827      72727570 
 9827      74205374 
 9827      61747573 
 9828 094f 20436F64 		.ascii	" Code = %d\012\000"
 9828      65203D20 
 9828      25640A00 
 9829 095b 00       		.space	1
 9830              	.LC52:
 9831 095c 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 9831      65642074 
 9831      6F20616C 
 9831      6C6F6361 
 9831      7465206D 
 9832 098f 65720D0A 		.ascii	"er\015\012\000"
 9832      00
 9833              	.LC53:
 9834 0994 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 9834      4368616E 
 9834      6E656C20 
 9834      43726561 
 9834      74696F6E 
 9835 09c2 0000     		.space	2
 9836              	.LC54:
 9837 09c4 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 9837      436F6E6E 
 9837      65637420 
 9837      6661696C 
 9837      65642C20 
 9838 09e9 000000   		.space	3
 9839              	.LC55:
 9840 09ec 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 9840      4368616E 
 9840      6E656C20 
 9840      52657365 
 9840      74204661 
 9841 0a17 00       		.space	1
 9842              	.LC56:
 9843 0a18 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 9843      4368616E 
 9843      6E656C20 
 9843      53657420 
 9843      5472616E 
 9844 0a49 00       		.ascii	"\000"
 9845 0a4a 0000     		.space	2
 9846              	.LC57:
 9847 0a4c 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 9847      4368616E 
 9847      6E656C20 
 9847      53657420 
 9847      5472616E 
 9848 0a7d 0A00     		.ascii	"\012\000"
 9849 0a7f 00       		.space	1
 9850              	.LC58:
 9851 0a80 0D0A2073 		.ascii	"\015\012 super gpif\000"
 9851      75706572 
 9851      20677069 
 9851      6600
 9852 0a8e 0000     		.space	2
 9853              	.LC59:
 9854 0a90 0D0A2068 		.ascii	"\015\012 high gpif\000"
 9854      69676820 
 9854      67706966 
 9854      00
 9855 0a9d 000000   		.space	3
 9856              	.LC60:
 9857 0aa0 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 9857      696E6720 
 9857      47504946 
 9857      20436F6E 
 9857      66696775 
 9858 0ad3 0A00     		.ascii	"\012\000"
 9859 0ad5 000000   		.space	3
 9860              	.LC61:
 9861 0ad8 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 9861      74696E67 
 9861      20475049 
 9861      46207374 
 9861      61746520 
 9862 0b0b 0D0A00   		.ascii	"\015\012\000"
 9863 0b0e 0000     		.space	2
 9864              	.LC62:
 9865 0b10 33303A55 		.ascii	"30:UVC App Thread\000"
 9865      56432041 
 9865      70702054 
 9865      68726561 
 9865      6400
 9866 0b22 0000     		.space	2
 9867              	.LC63:
 9868 0b24 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 9868      56432041 
 9868      70702045 
 9868      50302054 
 9868      68726561 
 9869 0b3a 0000     		.space	2
 9870              	.LC64:
 9871 0b3c 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 9871      32432041 
 9871      70702043 
 9871      54524C20 
 9871      54687265 
 9872 0b53 00       		.bss
 9873              		.align	2
 9874              		.set	.LANCHOR0,. + 0
 9877              	glFxUVCEvent:
 9878 0000 00000000 		.space	40
 9878      00000000 
 9878      00000000 
 9878      00000000 
 9878      00000000 
 9881              	gpif_initialized:
 9882 0028 00000000 		.space	4
 9885              	streamingStarted:
 9886 002c 00000000 		.space	4
 9889              	isUsbConnected:
 9890 0030 00000000 		.space	4
 9893              	fb:
 9894 0034 0000     		.space	2
 9897              	pb:
 9898 0036 0000     		.space	2
 9901              	pbc:
 9902 0038 0000     		.space	2
 9905              	stiflag:
 9906 003a 00       		.space	1
 9907 003b 00       		.space	1
 9910              	hitFV:
 9911 003c 00000000 		.space	4
 9914              	prodCount:
 9915 0040 0000     		.space	2
 9918              	consCount:
 9919 0042 0000     		.space	2
 9922              	clearFeatureRqtReceived:
 9923 0044 00000000 		.space	4
 9926              	usbSpeed:
 9927 0048 00       		.space	1
 9928 0049 000000   		.space	3
 9931              	I2CCMDArry:
 9932 004c 00000000 		.space	12
 9932      00000000 
 9932      00000000 
 9935              	is60Hz:
 9936 0058 00000000 		.space	4
 9939              	glEp0Buffer:
 9940 005c 00000000 		.space	32
 9940      00000000 
 9940      00000000 
 9940      00000000 
 9940      00000000 
 9943              	CamMode:
 9944 007c 00       		.space	1
 9947              	setRes:
 9948 007d 00       		.space	1
 9949 007e 0000     		.space	2
 9952              	glCommitCtrl:
 9953 0080 00000000 		.space	32
 9953      00000000 
 9953      00000000 
 9953      00000000 
 9953      00000000 
 9956              	IMcount.7788:
 9957 00a0 00       		.space	1
 9958 00a1 000000   		.space	3
 9961              	uvcAppThread:
 9962 00a4 00000000 		.space	168
 9962      00000000 
 9962      00000000 
 9962      00000000 
 9962      00000000 
 9965              	uvcAppEP0Thread:
 9966 014c 00000000 		.space	168
 9966      00000000 
 9966      00000000 
 9966      00000000 
 9966      00000000 
 9969              	i2cAppThread:
 9970 01f4 00000000 		.space	168
 9970      00000000 
 9970      00000000 
 9970      00000000 
 9970      00000000 
 9973              	testSnap:
 9974 029c 00       		.space	1
 9975 029d 00       		.space	1
 9978              	fbbak:
 9979 029e 0000     		.space	2
 9982              	pbbak:
 9983 02a0 0000     		.space	2
 9986              	pbcbak:
 9987 02a2 0000     		.space	2
 9990              	pbcpbak:
 9991 02a4 0000     		.space	2
 9992 02a6 0000     		.text
 9993              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:184    .text:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:190    .text:00000158 $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:291    .text:0000021c $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:305    .text:0000023c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:302    .text:0000023c $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:324    .text:0000024c $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:328    .text:00000250 $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:330    .text:00000250 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:509    .text:000003b0 $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:518    .text:000003c0 $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:521    .text:000003c0 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:743    .text:00000560 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:753    .text:0000057c $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:755    .text:0000057c CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:1080   .text:00000844 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:1096   .text:00000870 $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:1099   .text:00000870 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:1136   .text:000008a8 $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:1149   .text:000008d4 $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:1196   .text:00000928 $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:1203   .text:00000938 $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:1221   .text:00000954 $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:1230   .text:0000096c $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:1233   .text:0000096c I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:1437   .text:00000b74 $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:1445   .text:00000b88 $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:1448   .text:00000b88 setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:1511   .text:00000c08 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:1718   .text:00000da4 $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:1756   .text:00000e30 $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:1820   .text:00000eb4 $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:1856   .text:00000f3c $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:3124   .text:00001b10 $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:3142   .text:00001b4c $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:3145   .text:00001b4c CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:3313   .text:00001ca8 $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:3326   .text:00001cd0 $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:3821   .text:000021e0 $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:3832   .text:00002200 $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:4087   .text:000024b8 $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:4100   .text:000024e0 $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:4103   .text:000024e0 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:4165   .text:0000255c $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:4173   .text:0000256c $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:5431   .text:00003020 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:5462   .text:00003088 $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:5465   .text:00003088 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:5756   .text:00003340 $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:5763   .text:00003350 $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:5766   .text:00003350 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:5807   .text:00003394 $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:5812   .text:0000339c $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:5815   .text:0000339c CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:5840   .text:000033b8 $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:5844   .text:000033bc $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:5847   .text:000033bc UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:7264   .text:00003f2c $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:7322   .text:00004008 $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:7325   .text:00004008 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:7482   .text:00004180 $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:7498   .text:000041b4 $a
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:7501   .text:000041b4 main
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9132   .data:00000680 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9141   .data:0000068c CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9216   .data:000007ac CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9235   .data:000007bc CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:7664   .rodata:00000010 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9314   .data:000008ec CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9325   .data:000008fc CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9436   .data:00000aac CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9587   .data:00000b40 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:7677   .rodata:0000002c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9128   .data:0000067f snapButFlag
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9973   .bss:0000029c testSnap
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9893   .bss:00000034 fb
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9897   .bss:00000036 pb
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9901   .bss:00000038 pbc
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9978   .bss:0000029e fbbak
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9982   .bss:000002a0 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9986   .bss:000002a2 pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9990   .bss:000002a4 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9889   .bss:00000030 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9926   .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9922   .bss:00000044 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9885   .bss:0000002c streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9069   .data:0000064c glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9009   .data:00000614 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9099   .data:00000668 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9039   .data:00000630 glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9114   .data:00000674 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:8659   .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:7641   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:7645   .rodata:00000000 ExTime
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:7689   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:7693   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:8016   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:8674   .data:0000048c ROIMode
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:8679   .data:00000490 WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:8686   .data:00000494 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9665   .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9873   .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9877   .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9881   .bss:00000028 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9905   .bss:0000003a stiflag
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9910   .bss:0000003c hitFV
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9914   .bss:00000040 prodCount
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9918   .bss:00000042 consCount
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9931   .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9935   .bss:00000058 is60Hz
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9939   .bss:0000005c glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9943   .bss:0000007c CamMode
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9947   .bss:0000007d setRes
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9952   .bss:00000080 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9956   .bss:000000a0 IMcount.7788
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9961   .bss:000000a4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9965   .bss:0000014c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccxNICVL.s:9969   .bss:000001f4 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PGpifDisable
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorWrite2B
SensorWrite2B2
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifLoad
CyU3PGpifSMStart
CyU3PGpifSMSwitch
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
