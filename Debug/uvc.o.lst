   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"uvc.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	I2CCmdCb
  19              	I2CCmdCb:
  20              	.LFB18:
  21              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      ****                                                            received. */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 214:../uvc.c      ****                                                            the current video frame. */
 215:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 216:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 217:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 218:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 219:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 220:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 221:../uvc.c      **** 
 222:../uvc.c      **** /************ control parameters array ***********
 223:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 224:../uvc.c      ****  *    e.g.
 225:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 226:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 227:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 228:../uvc.c      ****  **************************************************/
 229:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 230:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 231:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 232:../uvc.c      **** 		{/*0*/BLCModeRegAct       , BLCModeRegAct        , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,
 233:../uvc.c      **** 		{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 234:../uvc.c      **** 		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1, 
 235:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 236:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 237:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 238:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 239:../uvc.c      **** 		{/*7*/SharpnessReg1       , SharpnessReg1        , 2,    0,    0,  255,    0, 1, 0, 3, 0,  32, 0,
 240:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 241:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 242:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 243:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 244:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 245:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 246:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 247:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 248:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 253:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 254:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 255:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 256:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 257:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 258:../uvc.c      **** 		{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 259:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 260:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 261:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 262:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 263:../uvc.c      **** 		/**********************************
 264:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 265:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 266:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 267:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 268:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 269:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 270:../uvc.c      **** 		 *
 271:../uvc.c      **** 		 *********************************/
 272:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 273:../uvc.c      **** };
 274:../uvc.c      **** #if 1 // the new control structure
 275:../uvc.c      **** /* the processing unit control request */
 276:../uvc.c      **** //		{ 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,   0, I2C_EAGLESDP_ADDR,  CyTrue, CyFalse,
 277:../uvc.c      **** 
 278:../uvc.c      **** volatile static SensorCtrl PUCBLC =
 279:../uvc.c      **** 		{BLCModeRegAct,		//Reg1: the command register address1
 280:../uvc.c      **** 		 BLCModeRegGain,	//Reg2: the command register address2
 281:../uvc.c      **** 		 2,					//UVCLn: the command length
 282:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 283:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 284:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 285:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 286:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 287:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 288:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 289:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 290:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 291:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 292:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 293:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 294:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 295:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 296:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 297:../uvc.c      **** 		}; //
 298:../uvc.c      **** //volatile static SensorCtrl PUCBright;
 299:../uvc.c      **** //volatile static SensorCtrl PUCContrast;
 300:../uvc.c      **** //volatile static SensorCtrl PUCGain;
 301:../uvc.c      **** //volatile static SensorCtrl PUCPLFreq;
 302:../uvc.c      **** //volatile static SensorCtrl PUCHueC;
 303:../uvc.c      **** //volatile static SensorCtrl PUCSaturation;
 304:../uvc.c      **** volatile static SensorCtrl PUCSharp =
 305:../uvc.c      **** 		{SharpnessReg1,		//Reg1: the command register address1
 306:../uvc.c      **** 		 SharpnessReg2,		//Reg2: the command register address2
 307:../uvc.c      **** 		 2,					//UVCLn: the command length
 308:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 309:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 310:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 311:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 312:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 313:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 314:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 315:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 316:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 317:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 318:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 319:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 320:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 321:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 322:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 323:../uvc.c      **** 		}; //sharpness, Reg1: 0-disable & 1-enable; Reg2: 0x00~0xFF.
 324:../uvc.c      **** //volatile static SensorCtrl PUCWBLC; //?
 325:../uvc.c      **** //volatile static SensorCtrl PUCDZoom;
 326:../uvc.c      **** 
 327:../uvc.c      **** volatile static SensorCtrl *pPUCSenCtrl[0x10] = {
 328:../uvc.c      **** 	&PUCBLC,
 329:../uvc.c      **** 	0, //&PUCBright,
 330:../uvc.c      **** 	0, //&PUCContrast,
 331:../uvc.c      **** 	0, //&PUCGain (AGC?)
 332:../uvc.c      **** 	0, //&PUCPLFreq,
 333:../uvc.c      **** 	0, //&PUCHueC,
 334:../uvc.c      **** 	0, //&PUCSaturation,
 335:../uvc.c      **** 	&PUCSharp,
 336:../uvc.c      **** 	0, //&PUCGamGain,
 337:../uvc.c      **** 	0, //&PUCWBMd,
 338:../uvc.c      **** 	0, //UVCCtlID10,
 339:../uvc.c      **** 	0, //&PUCWBLC,
 340:../uvc.c      **** 	0, //UVCCtlID12,
 341:../uvc.c      **** 	0, //UVCCtlID13,
 342:../uvc.c      **** 	0, //&PUCDZoom,
 343:../uvc.c      **** 	0 //UVCCtlID15
 344:../uvc.c      **** };
 345:../uvc.c      **** 
 346:../uvc.c      **** /* the Camera terminal control request */
 347:../uvc.c      **** //volatile static SensorCtrl CTCAutoExMode;
 348:../uvc.c      **** //volatile static SensorCtrl CTCExposureTAbs;
 349:../uvc.c      **** //volatile static SensorCtrl CTCFocusRel;
 350:../uvc.c      **** //volatile static SensorCtrl CTCIrisAbs;
 351:../uvc.c      **** //volatile static SensorCtrl CTCOPZoomAbs;
 352:../uvc.c      **** 
 353:../uvc.c      **** /* the Extentsion control request */
 354:../uvc.c      **** volatile static SensorCtrl EXTShutter =
 355:../uvc.c      **** 		{ShutterReg,		//Reg1: the command register address1
 356:../uvc.c      **** 		 0x02/*ShutterReg*/,		//Reg2: the command register address2
 357:../uvc.c      **** 		 2,					//UVCLn: the command length
 358:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 359:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 360:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 361:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 362:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 363:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 364:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 365:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 366:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 367:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 368:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 369:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 370:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 371:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 372:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 373:../uvc.c      **** 		}; //shutter control 0 ~ 0x12
 374:../uvc.c      **** /*volatile static SensorCtrl EXTSensUp =
 375:../uvc.c      **** 		{SenseUpReg,		//Reg1: the command register address1
 376:../uvc.c      **** 		 SenseUpReg,		//Reg2: the command register address2
 377:../uvc.c      **** 		 2,					//UVCLn: the command length
 378:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 379:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 380:../uvc.c      **** 		 9,					//UVCMaxLo: the command maximum value low byte
 381:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 382:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 383:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 384:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 385:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 386:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 387:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 388:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 389:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 390:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 391:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 392:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 393:../uvc.c      **** 		};	// sense up control 0 ~ 0x09
 394:../uvc.c      **** */
 395:../uvc.c      **** /*volatile static SensorCtrl EXTMirror =
 396:../uvc.c      **** 		{MirrModeReg,		//Reg1: the command register address1
 397:../uvc.c      **** 		 MirrModeReg,		//Reg2: the command register address2
 398:../uvc.c      **** 		 2,					//UVCLn: the command length
 399:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 400:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 401:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 402:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 403:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 404:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 405:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 406:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 407:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 408:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 409:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 410:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 411:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 412:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 413:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 414:../uvc.c      **** 		};	// mirror mode control 0 ~ 0x03
 415:../uvc.c      **** */
 416:../uvc.c      **** //volatile static SensorCtrl EXT3DnoiseReduceMode;
 417:../uvc.c      **** //volatile static SensorCtrl EXT3DNoiseLev;
 418:../uvc.c      **** //volatile static SensorCtrl EXTDayNightMode;
 419:../uvc.c      **** //volatile static SensorCtrl EXTDayNightdely;
 420:../uvc.c      **** //volatile static SensorCtrl EXTDayNightlev;
 421:../uvc.c      **** //volatile static SensorCtrl EXTNightDaylev;
 422:../uvc.c      **** volatile static SensorCtrl EXTAexModGainlev =
 423:../uvc.c      **** 		{ShutterReg/*AExModeReg*/,		//Reg1: the command register address1
 424:../uvc.c      **** 		 0x03/*AExAGCReg*/,			//Reg2: the command register address2
 425:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 426:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 427:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 428:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 429:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 430:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 431:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 432:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 433:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 434:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 435:../uvc.c      **** 		 63, 				//UVCDefVHi: the command default data value high byte
 436:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 437:../uvc.c      **** 		 63,				//UVCCurVHi: the command current data value high byte
 438:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 439:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 440:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 441:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 442:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 443:../uvc.c      **** //volatile static SensorCtrl EXTExpReflev;
 444:../uvc.c      **** //volatile static SensorCtrl EXTCamMode;
 445:../uvc.c      **** //volatile static SensorCtrl EXTSnapshot;
 446:../uvc.c      **** //volatile static SensorCtrl EXTSensorPare;
 447:../uvc.c      **** //volatile static SensorCtrl EXTI2Ccmd;
 448:../uvc.c      **** volatile static SensorCtrl EXTBLCWinPos =
 449:../uvc.c      **** 		{BLCPosReg,			//Reg1: the command register address1
 450:../uvc.c      **** 		 BLCSizeReg,		//Reg2: the command register address2
 451:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 452:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 453:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 454:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 455:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 456:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 457:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 458:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 459:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 460:../uvc.c      **** 		 0x66,				//UVCDefVLo: the command default data value low byte
 461:../uvc.c      **** 		 0x66, 				//UVCDefVHi: the command default data value high byte
 462:../uvc.c      **** 		 0x66,				//UVCCurVLo: the command current data value low byte
 463:../uvc.c      **** 		 0x66,				//UVCCurVHi: the command current data value high byte
 464:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 465:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 466:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 467:../uvc.c      **** 		}; //BLC position: [7:4]:Top/bottom [3:0]:left/right; BLC size: [7:4]:height [3:0]:width.
 468:../uvc.c      **** //{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 469:../uvc.c      **** volatile static SensorCtrl EXTBLCWeight =
 470:../uvc.c      **** 		{BLCModeRegGain,			//Reg1: the command register address1
 471:../uvc.c      **** 		 BLCModeRegGain,			//Reg2: the command register address2
 472:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 473:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 474:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 475:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 476:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 477:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 478:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 479:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 480:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 481:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 482:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 483:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 484:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 485:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 486:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 487:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 488:../uvc.c      **** 		}; //
 489:../uvc.c      **** //volatile static SensorCtrl EXTBLCGrid;
 490:../uvc.c      **** //{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 491:../uvc.c      **** 
 492:../uvc.c      **** volatile static SensorCtrl EXTShutlev =
 493:../uvc.c      **** 		{0x02/*AExModeReg2*/,		//Reg1: the command register address1
 494:../uvc.c      **** 		 0x12/*ShutterFineReg*/,			//Reg2: the command register address2
 495:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 496:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 497:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 498:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 499:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 500:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 501:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 502:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 503:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 504:../uvc.c      **** 		 63,				//UVCDefVLo: the command default data value low byte
 505:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 506:../uvc.c      **** 		 63,					//UVCCurVLo: the command current data value low byte
 507:../uvc.c      **** 		 0,				//UVCCurVHi: the command current data value high byte
 508:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 509:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 510:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 511:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 512:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 513:../uvc.c      **** 
 514:../uvc.c      **** volatile static SensorCtrl EXTExHyster =
 515:../uvc.c      **** 		{ExHysterReg,			//Reg1: the command register address1
 516:../uvc.c      **** 		 ExHysterReg,			//Reg2: the command register address2
 517:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 518:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 519:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 520:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 521:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 522:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 523:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 524:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 525:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 526:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 527:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 528:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 529:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 530:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 531:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 532:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 533:../uvc.c      **** 		}; //
 534:../uvc.c      **** 
 535:../uvc.c      **** volatile static SensorCtrl EXTExCtrlSped =
 536:../uvc.c      **** 		{ExCtrlSpdReg,			//Reg1: the command register address1
 537:../uvc.c      **** 		 ExCtrlSpdReg,			//Reg2: the command register address2
 538:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 539:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 540:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 541:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 542:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 543:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 544:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 545:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 546:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 547:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 548:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 549:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 550:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 551:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 552:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 553:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 554:../uvc.c      **** 		}; //
 555:../uvc.c      **** 
 556:../uvc.c      **** volatile static SensorCtrl EXTEnhanceMode =
 557:../uvc.c      **** 		{ExEnhanceModeReg,			//Reg1: the command register address1
 558:../uvc.c      **** 		 ExEnhanceModeReg,			//Reg2: the command register address2
 559:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 560:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 561:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 562:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 563:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 564:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 565:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 566:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 567:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 568:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 569:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 570:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 571:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 572:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 573:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 574:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 575:../uvc.c      **** 		}; //
 576:../uvc.c      **** 
 577:../uvc.c      **** volatile static SensorCtrl EXTEnhanceGain =
 578:../uvc.c      **** 		{ExEnhanceGainReg,			//Reg1: the command register address1
 579:../uvc.c      **** 		 ExEnhanceGainReg,			//Reg2: the command register address2
 580:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 581:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 582:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 583:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 584:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 585:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 586:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 587:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 588:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 589:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 590:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 591:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 592:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 593:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 594:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 595:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 596:../uvc.c      **** 		}; //
 597:../uvc.c      **** 
 598:../uvc.c      **** volatile static SensorCtrl EXTEnhanceSTED =
 599:../uvc.c      **** 		{ExEnhanceStartReg,			//Reg1: the command register address1
 600:../uvc.c      **** 		 ExEnhanceEndReg,			//Reg2: the command register address2
 601:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 602:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 603:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 604:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 605:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 606:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 607:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 608:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 609:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 610:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 611:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 612:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 613:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 614:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 615:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 616:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 617:../uvc.c      **** 		}; //
 618:../uvc.c      **** 
 619:../uvc.c      **** volatile static SensorCtrl EXT2DNRGain =
 620:../uvc.c      **** 		{Ex2DNREnableReg,		//Reg1: the command register address1
 621:../uvc.c      **** 		 Ex2DNRGainReg,			//Reg2: the command register address2
 622:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 623:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 624:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 625:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 626:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 627:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 628:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 629:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 630:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 631:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 632:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 633:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 634:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 635:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 636:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 637:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 638:../uvc.c      **** 		}; //
 639:../uvc.c      **** 
 640:../uvc.c      **** volatile static SensorCtrl EXT2DNRSTED =
 641:../uvc.c      **** 		{Ex2DNRStartReg,			//Reg1: the command register address1
 642:../uvc.c      **** 		 Ex2DNREndReg,			//Reg2: the command register address2
 643:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 644:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 645:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 646:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 647:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 648:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 649:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 650:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 651:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 652:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 653:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 654:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 655:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 656:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 657:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 658:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 659:../uvc.c      **** 		}; //
 660:../uvc.c      **** 
 661:../uvc.c      **** volatile static SensorCtrl EXTGammaCor =
 662:../uvc.c      **** 		{ExGammaReg,			//Reg1: the command register address1
 663:../uvc.c      **** 		 ExGammaReg,			//Reg2: the command register address2
 664:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 665:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 666:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 667:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 668:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 669:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 670:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 671:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 672:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 673:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 674:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 675:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 676:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 677:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 678:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 679:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 680:../uvc.c      **** 		}; //
 681:../uvc.c      **** 
 682:../uvc.c      **** volatile static SensorCtrl *pEXTSenCtrl[0x40] = {//Extension control
 683:../uvc.c      **** 		&EXTShutter,
 684:../uvc.c      **** 		0, //&EXTSensUp,
 685:../uvc.c      **** 		0, //&EXTMirror,
 686:../uvc.c      **** 		0, //&EXT3DnoiseReduceMode,
 687:../uvc.c      **** 		0, //&EXT3DNoiseLev,
 688:../uvc.c      **** 		0, //&EXTDayNightMode,
 689:../uvc.c      **** 		0, //&EXTDayNightdely,
 690:../uvc.c      **** 		0, //&EXTDayNightlev,
 691:../uvc.c      **** 		0, //&EXTNightDaylev,
 692:../uvc.c      **** 		&EXTAexModGainlev,
 693:../uvc.c      **** 		0, //&EXTExpReflev,
 694:../uvc.c      **** 		&EXTShutlev,
 695:../uvc.c      **** 		0, //&EXTCamMode,
 696:../uvc.c      **** 		0, //&EXTSnapshot,
 697:../uvc.c      **** 		0, //&EXTSensorPare,
 698:../uvc.c      **** 		0, //&EXTI2Ccmd,
 699:../uvc.c      **** 		0, //&Ext1CtlID0 = 0x20,
 700:../uvc.c      **** 		0, //&Ext1CtlID1,
 701:../uvc.c      **** 		0, //&Ext1CtlID2,
 702:../uvc.c      **** 		0, //&Ext1CtlID3,
 703:../uvc.c      **** 		&EXTBLCWinPos,   		// back light compensation range
 704:../uvc.c      **** 		&EXTBLCWeight,  	    // back light compensation weight (gain) factor
 705:../uvc.c      **** 		0, //&EXTBLCGrid,    	// back light compensation grid state
 706:../uvc.c      **** 		&EXTExHyster,       // exposure hystereses level
 707:../uvc.c      **** 		&EXTExCtrlSped,     // exposure control speed level
 708:../uvc.c      **** 		&EXTEnhanceMode,    // edge enhancement mode
 709:../uvc.c      **** 		&EXTEnhanceGain,    // edge enhancement gain level
 710:../uvc.c      **** 		&EXTEnhanceSTED,    // edge enhancement start/end level
 711:../uvc.c      **** 		&EXT2DNRGain,       // 2D noise reduction Gain level
 712:../uvc.c      **** 		&EXT2DNRSTED,       // 2D noise reduction start/end level
 713:../uvc.c      **** 		&EXTGammaCor,		// Gamma correction
 714:../uvc.c      **** 		0, //&Ext1CtlID15,
 715:../uvc.c      **** 		0
 716:../uvc.c      **** };
 717:../uvc.c      **** 
 718:../uvc.c      **** #endif //end of the new control structure
 719:../uvc.c      **** 
 720:../uvc.c      **** #ifndef CAM720
 721:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 722:../uvc.c      **** #else
 723:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 724:../uvc.c      **** #endif
 725:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
 726:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
 727:../uvc.c      **** 
 728:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 729:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 730:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 731:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 732:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 733:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    0,    0,    0xff, 0xff, 1, 0, 3
 734:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   0x80,
 735:../uvc.c      **** 		{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 736:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 737:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 738:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 739:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 740:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 741:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 742:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 743:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 744:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 745:../uvc.c      **** };
 746:../uvc.c      **** 
 747:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 748:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 749:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 750:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 751:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 752:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 753:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 754:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 755:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 756:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 757:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 758:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 759:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 760:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 761:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 762:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 763:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 764:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 765:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 766:../uvc.c      **** };
 767:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 768:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 769:../uvc.c      **** static uint16_t ShutSp[16]={33333, 16667, 8333, 4000, 2000, 1000, 500, 200, 100, 10, 0}; // in micr
 770:../uvc.c      **** static uint8_t curFlag[64]={0}; //the curFlag for each controls current records available. 0: unabl
 771:../uvc.c      **** /*
 772:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 773:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 774:../uvc.c      ****  */
 775:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 776:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 777:../uvc.c      **** };
 778:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 779:../uvc.c      **** 		0
 780:../uvc.c      **** };
 781:../uvc.c      **** 
 782:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 783:../uvc.c      **** 
 784:../uvc.c      **** void I2CCmdHandler(){
 785:../uvc.c      **** 	uint8_t buf[2];
 786:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 787:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 788:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 789:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 790:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 791:../uvc.c      **** 	uint8_t i;
 792:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 793:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 794:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 795:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 796:../uvc.c      **** 	{
 797:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 798:../uvc.c      **** 		if(is60Hz==CyFalse)
 799:../uvc.c      **** 			{
 800:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 801:../uvc.c      **** 			}
 802:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 803:../uvc.c      **** 
 804:../uvc.c      **** 	}
 805:../uvc.c      **** 	if(CmdType == 0)//I2C read
 806:../uvc.c      **** 	{
 807:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 808:../uvc.c      **** #if 0 //for debugging
 809:../uvc.c      **** 		/* test still image operation */
 810:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 811:../uvc.c      **** 			snapButFlag = 0; //press
 812:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 813:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 814:../uvc.c      **** 			snapButFlag = 0xf; //release
 815:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 816:../uvc.c      **** 		}
 817:../uvc.c      **** 
 818:../uvc.c      **** 		/* end of the test */
 819:../uvc.c      **** #endif
 820:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 821:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 822:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 823:../uvc.c      **** 				if(CmdDataLen == 2){
 824:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 825:../uvc.c      **** 				}
 826:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 827:../uvc.c      **** 		}else{//not support currently
 828:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 829:../uvc.c      **** 		}
 830:../uvc.c      **** 	}else if(CmdType == 1){
 831:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 832:../uvc.c      **** 			if(CmdRegLen == 2){
 833:../uvc.c      **** 				for(i = 0; i<4; i++)
 834:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 835:../uvc.c      **** 			}
 836:../uvc.c      **** 			else{
 837:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 838:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 839:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 840:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 841:../uvc.c      **** 				}
 842:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 843:../uvc.c      **** 			}
 844:../uvc.c      **** 		}else{//not support currently
 845:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 846:../uvc.c      **** 		}
 847:../uvc.c      **** 
 848:../uvc.c      **** 	}
 849:../uvc.c      **** }
 850:../uvc.c      **** 
 851:../uvc.c      **** /************************************
 852:../uvc.c      ****  * set Iris mode
 853:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 854:../uvc.c      ****  */
 855:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 856:../uvc.c      **** 	uint8_t dataIdx = 0;
 857:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 858:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 859:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 860:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 861:../uvc.c      **** }
 862:../uvc.c      **** 
 863:../uvc.c      **** 
 864:../uvc.c      **** 
 865:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 866:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 867:../uvc.c      **** 	uint16_t NumLn;
 868:../uvc.c      **** 	uint16_t fRate, shutTm;
 869:../uvc.c      **** 	uint8_t LnVal;
 870:../uvc.c      **** 	switch (Data){
 871:../uvc.c      **** 	case 1:
 872:../uvc.c      **** 	case 2:
 873:../uvc.c      **** 	case 3:
 874:../uvc.c      **** 	case 4:
 875:../uvc.c      **** 	case 5:
 876:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 877:../uvc.c      **** 		fRate = 30;
 878:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 879:../uvc.c      **** 		if(NumLn > 1944)
 880:../uvc.c      **** 			NumLn =1944;
 881:../uvc.c      **** 		else if(NumLn < 8)
 882:../uvc.c      **** 			NumLn = 8;
 883:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 884:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 885:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 886:../uvc.c      **** 		break;
 887:../uvc.c      **** 	case 6:
 888:../uvc.c      **** 	case 7:
 889:../uvc.c      **** 	case 8:
 890:../uvc.c      **** 	case 9:
 891:../uvc.c      **** 	case 10:
 892:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 893:../uvc.c      **** 		fRate = 30;
 894:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 895:../uvc.c      **** 		if(NumLn > 1944)
 896:../uvc.c      **** 			NumLn =1944;
 897:../uvc.c      **** 		else if(NumLn < 8)
 898:../uvc.c      **** 			NumLn = 8;
 899:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 900:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 901:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 902:../uvc.c      **** 		break;
 903:../uvc.c      **** 	case 0: //auto
 904:../uvc.c      **** 	default:
 905:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 906:../uvc.c      **** 		LnVal = 1;
 907:../uvc.c      **** 		break;
 908:../uvc.c      **** 	}
 909:../uvc.c      **** 	return LnVal;
 910:../uvc.c      **** }
 911:../uvc.c      **** 
 912:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 913:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 914:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 915:../uvc.c      ****     uint16_t readCount;
 916:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID, AxMode;
 917:../uvc.c      ****     uint8_t devAdd;
 918:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 919:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 920:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 921:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 922:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 923:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 924:../uvc.c      ****     }else{
 925:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 926:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 927:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 928:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 929:../uvc.c      ****     }
 930:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 931:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 932:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 933:../uvc.c      **** #endif
 934:../uvc.c      ****     reqData = bRequest;
 935:../uvc.c      ****     /*
 936:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 937:../uvc.c      ****      */
 938:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 939:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 940:../uvc.c      ****     	goto EndofSet;
 941:../uvc.c      ****     }
 942:../uvc.c      ****     switch (bRequest)
 943:../uvc.c      **** 		 {
 944:../uvc.c      **** 
 945:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 946:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 947:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 948:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 949:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 950:../uvc.c      **** 			  break;
 951:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 952:../uvc.c      **** 
 953:../uvc.c      **** 			 switch(CtrlID)
 954:../uvc.c      **** 			 {
 955:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 956:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 957:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 958:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 959:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 960:../uvc.c      **** 			 	 		 }else{
 961:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 962:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 963:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 964:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 965:../uvc.c      **** 			 	 		 }
 966:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 967:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 968:../uvc.c      **** 						 break;
 969:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 970:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 971:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 972:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 973:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 974:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 975:../uvc.c      **** 			 	 		 }else{
 976:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 977:../uvc.c      **** 			 	 			glEp0Buffer[0] = Data0;
 978:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 979:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 980:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 981:../uvc.c      **** 			 	 		 }
 982:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 983:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 984:../uvc.c      **** 			 	 		 break;
 985:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 986:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[CtrlID][13];
 987:../uvc.c      **** 								 //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 988:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[CtrlID][14];
 989:../uvc.c      **** 								 //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 990:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 991:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 992:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 993:../uvc.c      **** 			 	 		 }else{
 994:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 995:../uvc.c      **** 			 	 			if(Data0&0x80)
 996:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 997:../uvc.c      **** 			 	 			else
 998:../uvc.c      **** 			 	 				glEp0Buffer[0] = 0;
 999:../uvc.c      **** 			 	 			ExUCtrlParArry[CtrlID-0x20][13] = glEp0Buffer[0];
1000:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
1001:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1002:../uvc.c      **** 			 	 		 }
1003:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1004:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1005:../uvc.c      **** 			 	 		 break;
1006:../uvc.c      **** 			 	 }
1007:../uvc.c      **** 			 	 case ExtShutCtlID0:
1008:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1009:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1010:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
1011:../uvc.c      **** 
1012:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
1013:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1014:../uvc.c      **** 					 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1015:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1016:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1017:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1018:../uvc.c      **** 		 	 		 }else{
1019:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1020:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
1021:../uvc.c      **** 		 	 			Data1 = (Data0&0x70)>>4;
1022:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
1023:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1024:../uvc.c      **** 		 	 			//curFlag[CtrlID] = CyTrue;
1025:../uvc.c      **** 						CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
1026:../uvc.c      **** 
1027:../uvc.c      **** 		 	 		 }
1028:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1029:../uvc.c      **** 					 sendData1 = Data1;//glEp0Buffer[1];
1030:../uvc.c      **** 					 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, send
1031:../uvc.c      **** 			 		 break;
1032:../uvc.c      **** 			 	 case ExtCtlShutlevCtlID11:
1033:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1034:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1035:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
1036:../uvc.c      **** 
1037:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
1038:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1039:../uvc.c      **** 					 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1040:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1041:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1042:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1043:../uvc.c      **** 		 	 		 }else{
1044:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1045:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1046:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1047:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1048:../uvc.c      **** 		 	 		 }
1049:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1050:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1051:../uvc.c      **** 			 		 break;
1052:../uvc.c      **** 			 	 case ExtCamMCtlID12:
1053:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
1054:../uvc.c      **** 
1055:../uvc.c      **** 					 if(CamMode == 1){//720p
1056:../uvc.c      **** 						if(sendData >= 3){
1057:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
1058:../uvc.c      **** 							sendData = 0; //set back to default
1059:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
1060:../uvc.c      **** 						}
1061:../uvc.c      **** 						sendData += 4;
1062:../uvc.c      **** 					 }
1063:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
1064:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
1065:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1066:../uvc.c      **** 					 break;
1067:../uvc.c      **** 			 	 case ExtI2CCtlID15:
1068:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
1069:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
1070:../uvc.c      **** 			 		 }
1071:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
1072:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
1073:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1074:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
1075:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
1076:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
1077:../uvc.c      **** #endif
1078:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
1079:../uvc.c      **** 			 		 {
1080:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
1081:../uvc.c      **** 			 		 }
1082:../uvc.c      **** 			 		 break;
1083:../uvc.c      **** 			 		 /* the exposure hysteresis to gamma correction */
1084:../uvc.c      **** 		 	 	 case Ext1ExHysterCtlID7:
1085:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1086:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1087:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1088:../uvc.c      **** 		 	 		 }else{
1089:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1090:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1091:../uvc.c      **** 		 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1092:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1093:../uvc.c      **** 		 	 		 }
1094:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1095:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1096:../uvc.c      **** 					 break;
1097:../uvc.c      **** 		 	 	 case Ext1ExCtrlSpeedCtlID8:
1098:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1099:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1100:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1101:../uvc.c      **** 		 	 		 }else{
1102:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1103:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1104:../uvc.c      **** 		 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1105:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1106:../uvc.c      **** 		 	 		 }
1107:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1108:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1109:../uvc.c      **** 					 break;
1110:../uvc.c      **** 		 	 	 case Ext1EnhanceModeCtlID9:
1111:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1112:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1113:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1114:../uvc.c      **** 		 	 		 }else{
1115:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1116:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1117:../uvc.c      **** 		 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1118:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1119:../uvc.c      **** 		 	 		 }
1120:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1121:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1122:../uvc.c      **** 					 break;
1123:../uvc.c      **** 		 	 	 case Ext1EnhanceGainCtlID10:
1124:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1125:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1126:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1127:../uvc.c      **** 		 	 		 }else{
1128:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1129:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1130:../uvc.c      **** 		 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1131:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1132:../uvc.c      **** 		 	 		 }
1133:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1134:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1135:../uvc.c      **** 					 break;
1136:../uvc.c      **** 		 	 	 case Ext1EnhanceStarEndCtlID11:
1137:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1138:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1139:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1140:../uvc.c      **** 		 	 		 }else{
1141:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1142:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1143:../uvc.c      **** 		 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1144:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1145:../uvc.c      **** 		 	 		 }
1146:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1147:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1148:../uvc.c      **** 					 break;
1149:../uvc.c      **** 		 	 	 case Ext12DNRGainEnblCtlID12:
1150:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1151:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1152:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1153:../uvc.c      **** 		 	 		 }else{
1154:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1155:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1156:../uvc.c      **** 		 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1157:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1158:../uvc.c      **** 		 	 		 }
1159:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1160:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1161:../uvc.c      **** 					 break;
1162:../uvc.c      **** 		 	 	 case Ext12DNRGainStarEndCtlID13:
1163:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1164:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1165:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1166:../uvc.c      **** 		 	 		 }else{
1167:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1168:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1169:../uvc.c      **** 		 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1170:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1171:../uvc.c      **** 		 	 		 }
1172:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1173:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1174:../uvc.c      **** 					 break;
1175:../uvc.c      **** 		 	 	 case Ext1GammaCorCtlID14:
1176:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1177:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1178:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1179:../uvc.c      **** 		 	 		 }else{
1180:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1181:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1182:../uvc.c      **** 		 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
1183:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1184:../uvc.c      **** 		 	 		 }
1185:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1186:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1187:../uvc.c      **** 					 break;
1188:../uvc.c      **** 
1189:../uvc.c      **** 					 case ExtAexModCtlID9:
1190:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1191:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1192:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
1193:../uvc.c      **** 
1194:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
1195:../uvc.c      **** 					 //glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1196:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1197:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1198:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1199:../uvc.c      **** 		 	 		 }else{
1200:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1201:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
1202:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1203:../uvc.c      **** 
1204:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
1205:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
1206:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1207:../uvc.c      **** 		 	 		 }
1208:../uvc.c      **** 					 //sendData = glEp0Buffer[0];
1209:../uvc.c      **** 					 //sendData1 = glEp0Buffer[1];
1210:../uvc.c      **** 
1211:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
1212:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1213:../uvc.c      **** 					 //glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
1214:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1215:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1216:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
1217:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
1218:../uvc.c      **** 					 break;
1219:../uvc.c      **** 
1220:../uvc.c      **** 			 	 case BrgtCtlID1:
1221:../uvc.c      **** 			 		 /* cancel for 5MP w/b camera
1222:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
1223:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
1224:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
1225:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
1226:../uvc.c      **** 					 }else{
1227:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
1228:../uvc.c      **** 					 }
1229:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
1230:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1231:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1232:../uvc.c      **** 					 */
1233:../uvc.c      **** 
1234:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1235:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
1236:../uvc.c      **** 		 	 		 }else{
1237:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1238:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
1239:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1240:../uvc.c      **** 		 	 		 }
1241:../uvc.c      **** 					 //Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode()
1242:../uvc.c      **** 					  if(Data0&0x80){
1243:../uvc.c      **** 						  Data0 = ~Data0;
1244:../uvc.c      **** 					  }else{
1245:../uvc.c      **** 						  Data0 = Data0 + 0x80;
1246:../uvc.c      **** 					  }
1247:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
1248:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1249:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1250:../uvc.c      **** 			 		 break;
1251:../uvc.c      **** 				 case HueCtlID5:
1252:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1253:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
1254:../uvc.c      **** 		 	 		 }else{
1255:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1256:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
1257:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1258:../uvc.c      **** 		 	 		 }
1259:../uvc.c      **** 
1260:../uvc.c      **** 					 glEp0Buffer[0] = Data0 + GREEN_BASE;
1261:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1262:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1263:../uvc.c      **** 					 break;
1264:../uvc.c      **** 				 case WBTLevCtlID11:
1265:../uvc.c      **** 					 //glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
1266:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1267:../uvc.c      **** 					 //glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
1268:../uvc.c      **** 					 //glEp0Buffer[3] = 0;
1269:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1270:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
1271:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
1272:../uvc.c      **** 		 	 		 }else{
1273:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1274:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
1275:../uvc.c      **** 						glEp0Buffer[0] = Data0;
1276:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
1277:../uvc.c      **** 						glEp0Buffer[2] = Data1;
1278:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
1279:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1280:../uvc.c      **** 		 	 		 }
1281:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1282:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1283:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1284:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
1285:../uvc.c      **** 					 break;
1286:../uvc.c      **** 				 case BLCCtlID0:
1287:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1288:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1289:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1290:../uvc.c      **** 		 	 		 }else{
1291:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1292:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x1;
1293:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1294:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1295:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1296:../uvc.c      **** 		 	 		 }
1297:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1298:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1299:../uvc.c      **** 					 break;
1300:../uvc.c      **** 				 case ShapCtlID7:
1301:../uvc.c      **** 					 //glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;
1302:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1303:../uvc.c      **** 					 //glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1304:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1305:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1306:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1307:../uvc.c      **** 		 	 		 }else{
1308:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1309:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1310:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1311:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1312:../uvc.c      **** 		 	 		 }
1313:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1314:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1315:../uvc.c      **** 					 break;
1316:../uvc.c      **** 				 case ExtExRefCtlID10:
1317:../uvc.c      **** 				 case ConsCtlID2:
1318:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[ExtExRefCtlID10][13];//SensorGetControl(RegAdd0, devAdd);
1319:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//SensorGetControl(RegAdd0, devAdd);
1320:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1321:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1322:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
1323:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1324:../uvc.c      **** 		 	 		 }else{
1325:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1326:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
1327:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1328:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1329:../uvc.c      **** 		 	 		 }
1330:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1331:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1332:../uvc.c      **** 					 break;
1333:../uvc.c      **** 				 case WBTMdCtlID9:
1334:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1335:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
1336:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1337:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1338:../uvc.c      **** 		 	 		 }else{
1339:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1340:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1341:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1342:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1343:../uvc.c      **** 
1344:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1345:../uvc.c      **** 		 	 		 }
1346:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1347:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1348:../uvc.c      **** 					 break;
1349:../uvc.c      **** 				 case MFreqCtlID4:
1350:../uvc.c      **** 
1351:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1352:../uvc.c      **** 
1353:../uvc.c      **** 		 	 			 if(is60Hz)
1354:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
1355:../uvc.c      **** 		 	 			 else
1356:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 1;
1357:../uvc.c      **** 
1358:../uvc.c      **** 						 //glEp0Buffer[0] = glEp0Buffer[0] & 0x80;    // get two least Bits
1359:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1360:../uvc.c      **** 		 	 		 }else{
1361:../uvc.c      **** 		 	 			Data0 = SensorGetControl(0x1, devAdd); //get resolution bit7 for main frequency information
1362:../uvc.c      **** 		 	 			glEp0Buffer[0] = (Data0&0x80)>>7;
1363:../uvc.c      **** 		 	 			glEp0Buffer[0]++;
1364:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1365:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1366:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1367:../uvc.c      **** 		 	 		 }
1368:../uvc.c      **** 
1369:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1370:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1371:../uvc.c      **** 					 break;
1372:../uvc.c      **** 				 case SaturCtlID6:
1373:../uvc.c      **** 				 default:
1374:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1375:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1376:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1377:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
1378:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1379:../uvc.c      **** 		 	 		 }else{
1380:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1381:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1382:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1383:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1384:../uvc.c      **** 		 	 		 }
1385:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1386:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1387:../uvc.c      **** 
1388:../uvc.c      **** 					 //sendData = glEp0Buffer[0];
1389:../uvc.c      **** 					 break;
1390:../uvc.c      **** 			 }
1391:../uvc.c      **** 
1392:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1393:../uvc.c      **** 
1394:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1395:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
1396:../uvc.c      **** #endif
1397:../uvc.c      **** 			  break;
1398:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
1399:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1400:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
1401:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
1402:../uvc.c      **** 		 	 }
1403:../uvc.c      **** 
1404:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1405:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
1406:../uvc.c      **** 				 glEp0Buffer[1] = 0;
1407:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
1408:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1409:../uvc.c      **** 			 }else
1410:../uvc.c      **** 			 {
1411:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
1412:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
1413:../uvc.c      **** 			 }
1414:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1415:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1416:../uvc.c      **** 			  break;
1417:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1418:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1419:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
1420:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
1421:../uvc.c      **** 		 	 }
1422:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1423:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
1424:../uvc.c      **** 				 glEp0Buffer[1] = 0;
1425:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
1426:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1427:../uvc.c      **** 			 }else
1428:../uvc.c      **** 			 {
1429:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
1430:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
1431:../uvc.c      **** 			 }
1432:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1433:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1434:../uvc.c      **** 			  break;
1435:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1436:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1437:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
1438:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
1439:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1440:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1441:../uvc.c      **** 		 	 }
1442:../uvc.c      **** 		 	 else{
1443:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
1444:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
1445:../uvc.c      **** 			  glEp0Buffer[2] = 0;
1446:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1447:../uvc.c      **** 		 	 }
1448:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1449:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1450:../uvc.c      **** 			  break;
1451:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1452:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1453:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
1454:../uvc.c      **** 		 	 }
1455:../uvc.c      **** 		 	 else{
1456:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
1457:../uvc.c      **** 		 	 }
1458:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1459:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1460:../uvc.c      **** 			  Len = 1;
1461:../uvc.c      **** 			  break;
1462:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1463:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1464:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
1465:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
1466:../uvc.c      **** 		 	 }
1467:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1468:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
1469:../uvc.c      **** 				  glEp0Buffer[1] = 0;
1470:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
1471:../uvc.c      **** 				  glEp0Buffer[3] = 0;
1472:../uvc.c      **** 			 }else{
1473:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
1474:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
1475:../uvc.c      **** 			 }
1476:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1477:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1478:../uvc.c      **** 			  break;
1479:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1480:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1481:../uvc.c      **** 				  glEp0Buffer, &readCount);
1482:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
1483:../uvc.c      **** 			   {
1484:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
1485:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
1486:../uvc.c      **** 				  getData = glEp0Buffer[0];
1487:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
1488:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1489:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
1490:../uvc.c      **** #endif
1491:../uvc.c      **** 				  switch(CtrlID)
1492:../uvc.c      **** 					 {
1493:../uvc.c      **** 						 case ExtShutCtlID0:
1494:../uvc.c      **** 						     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1495:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][0];
1496:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
1497:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
1498:../uvc.c      **** #if 1	// register setting directly
1499:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
1500:../uvc.c      **** 						     {
1501:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
1502:../uvc.c      **** 						    	 dataIdx = 0;
1503:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1504:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
1505:../uvc.c      **** 								 dataIdx++;
1506:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1507:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1508:../uvc.c      **** 						     }
1509:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
1510:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
1511:../uvc.c      **** 						     break;
1512:../uvc.c      **** #else	// old fashion
1513:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
1514:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
1515:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
1516:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
1517:../uvc.c      **** 									 }else{
1518:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
1519:../uvc.c      **** 									 }
1520:../uvc.c      **** 								 }
1521:../uvc.c      **** 							 }else{
1522:../uvc.c      **** 								 Data1 = Data0 - 1;
1523:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
1524:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
1525:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
1526:../uvc.c      **** 									 }else{
1527:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
1528:../uvc.c      **** 									 }
1529:../uvc.c      **** 								 }
1530:../uvc.c      **** 								 if(Data1 < 8){
1531:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
1532:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
1533:../uvc.c      **** 								 }else{
1534:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
1535:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
1536:../uvc.c      **** 								 }
1537:../uvc.c      **** 							 }
1538:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
1539:../uvc.c      **** 							 dataIdx = 0;
1540:../uvc.c      **** 							 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
1541:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1542:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
1543:../uvc.c      **** 							 if(AxMode){
1544:../uvc.c      **** 								 dataIdx++;
1545:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
1546:../uvc.c      **** 								 dataIdx++;
1547:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustme
1548:../uvc.c      **** 							 }
1549:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1550:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
1551:../uvc.c      **** 							 break;
1552:../uvc.c      **** #endif
1553:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
1554:../uvc.c      **** 						     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1555:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1556:../uvc.c      **** 						     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
1557:../uvc.c      **** 						     dataIdx = 0;
1558:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1559:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
1560:../uvc.c      **** 							 {
1561:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
1562:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1563:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1564:../uvc.c      **** 								 /*
1565:../uvc.c      **** 								 dataIdx++;
1566:../uvc.c      **** 								 if(getData == 1 || getData == 3){
1567:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x80, dataIdx);  //set AEX mode2 to 0x80 (fixed shu
1568:../uvc.c      **** 									 dataIdx++;
1569:../uvc.c      **** 								 }else{
1570:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x00, dataIdx);  //set AEX mode2 to 0x00
1571:../uvc.c      **** 									 dataIdx++;
1572:../uvc.c      **** 								 }
1573:../uvc.c      **** 								 */
1574:../uvc.c      **** 							 }
1575:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
1576:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
1577:../uvc.c      **** 								 if(getData == 2 || getData == 3){
1578:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
1579:../uvc.c      **** 								 }
1580:../uvc.c      **** 							 }
1581:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1582:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1583:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1584:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
1585:../uvc.c      **** 							 break;
1586:../uvc.c      **** 
1587:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level
1588:../uvc.c      **** 						     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1589:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1590:../uvc.c      **** 						     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
1591:../uvc.c      **** 						     dataIdx = 0;
1592:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1593:../uvc.c      **** 							 if(0&&pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
1594:../uvc.c      **** 							 {
1595:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC wi
1596:../uvc.c      **** 								 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1597:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1598:../uvc.c      **** 								 dataIdx++;
1599:../uvc.c      **** 							 }
1600:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData){
1601:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
1602:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
1603:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
1604:../uvc.c      **** 									 dataIdx++;
1605:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
1606:../uvc.c      **** 								 }
1607:../uvc.c      **** 							 }
1608:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1609:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1610:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1611:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
1612:../uvc.c      **** 							 break;
1613:../uvc.c      **** 
1614:../uvc.c      **** 							 /* the exposure hysteresis to gamma correction */
1615:../uvc.c      **** 						 case Ext1ExHysterCtlID7:    // exposure hysteresis level (5MP b/w)
1616:../uvc.c      **** 						 case Ext1ExCtrlSpeedCtlID8:    // exposure control speed level (5MP b/w)
1617:../uvc.c      **** 						 case Ext1EnhanceModeCtlID9:    // edge enhancement mode (5MP b/w)
1618:../uvc.c      **** 						 case Ext1EnhanceGainCtlID10:    // edge enhancement gain level (5MP b/w)
1619:../uvc.c      **** 						 case Ext1GammaCorCtlID14:   // Gamma correction (5MP b/w)
1620:../uvc.c      **** 
1621:../uvc.c      **** 						     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1622:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1623:../uvc.c      **** 						     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
1624:../uvc.c      **** 						     dataIdx = 0;
1625:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1626:../uvc.c      **** 							 if(0&&pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
1627:../uvc.c      **** 							 {
1628:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC wi
1629:../uvc.c      **** 								 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1630:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1631:../uvc.c      **** 								 dataIdx++;
1632:../uvc.c      **** 							 }
1633:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData){
1634:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
1635:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
1636:../uvc.c      **** 									 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
1637:../uvc.c      **** 									 //dataIdx++;
1638:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //shutter level
1639:../uvc.c      **** 								 }
1640:../uvc.c      **** 							 }
1641:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1642:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1643:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1644:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
1645:../uvc.c      **** 							 break;
1646:../uvc.c      **** 
1647:../uvc.c      **** 						 case Ext1EnhanceStarEndCtlID11: // edge enhancement start/end level (5MP b/w) 4bytes
1648:../uvc.c      **** 						 case Ext12DNRGainEnblCtlID12:  // 2D NR gain enable/gain level (5MP b/w) 4bytes
1649:../uvc.c      **** 						 case Ext12DNRGainStarEndCtlID13:  // 2D NR gain start/end level (5MP b/w) 4bytes
1650:../uvc.c      **** 						     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1651:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1652:../uvc.c      **** 						     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
1653:../uvc.c      **** 						     dataIdx = 0;
1654:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1655:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
1656:../uvc.c      **** 							 {
1657:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC wi
1658:../uvc.c      **** 								 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1659:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1660:../uvc.c      **** 								 /*
1661:../uvc.c      **** 								 dataIdx++;
1662:../uvc.c      **** 								 if(getData == 1 || getData == 3){
1663:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x80, dataIdx);  //set AEX mode2 to 0x80 (fixed shu
1664:../uvc.c      **** 									 dataIdx++;
1665:../uvc.c      **** 								 }else{
1666:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x00, dataIdx);  //set AEX mode2 to 0x00
1667:../uvc.c      **** 									 dataIdx++;
1668:../uvc.c      **** 								 }
1669:../uvc.c      **** 								 */
1670:../uvc.c      **** 							 }
1671:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi != getData1){
1672:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
1673:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
1674:../uvc.c      **** 							 }
1675:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1676:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1677:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1678:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
1679:../uvc.c      **** 							 break;
1680:../uvc.c      **** 
1681:../uvc.c      **** 						 case ExtCamMCtlID12:
1682:../uvc.c      **** 							 dataIdx = 0;
1683:../uvc.c      **** 							 if(Data0 <= 3){
1684:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
1685:../uvc.c      **** 								 Data1 = Data0;
1686:../uvc.c      **** 							 }else{
1687:../uvc.c      **** 								 CamMode = 1; //set 720p flag
1688:../uvc.c      **** 								 Data1 = Data0-4;
1689:../uvc.c      **** 							 }
1690:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1691:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
1692:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1693:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1694:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1695:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1696:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
1697:../uvc.c      **** 							 break;
1698:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
1699:../uvc.c      **** 							 dataIdx = 0;
1700:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
1701:../uvc.c      **** 								 Data0 = 1;
1702:../uvc.c      **** 							 }else{ //save current sensor parameters.
1703:../uvc.c      **** 								 Data0 = 0;
1704:../uvc.c      **** 							 }
1705:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1706:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1707:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1708:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1709:../uvc.c      **** 							 break;
1710:../uvc.c      **** 						 case ExtI2CCtlID15:
1711:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
1712:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
1713:../uvc.c      **** 					 		 }
1714:../uvc.c      **** 					 		I2CCmdHandler();
1715:../uvc.c      **** 							 break;
1716:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
1717:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
1718:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
1719:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
1720:../uvc.c      **** 
1721:../uvc.c      **** 							 dataIdx = 0;
1722:../uvc.c      **** #if 0 //seperate version
1723:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
1724:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
1725:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1726:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
1727:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
1728:../uvc.c      **** 							 }else{ //disable BLD window
1729:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
1730:../uvc.c      **** 							 }
1731:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
1732:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
1733:../uvc.c      **** 							 dataIdx++;
1734:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
1735:../uvc.c      **** 							 dataIdx++;
1736:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
1737:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
1738:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
1739:../uvc.c      **** 							 dataIdx++;
1740:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
1741:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1742:../uvc.c      **** #else //combination version
1743:../uvc.c      **** 							 //Data0 = Data0&0x7F; //mask window show flag bit.
1744:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1745:../uvc.c      **** 						     /* end test */
1746:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
1747:../uvc.c      **** 							 dataIdx++;
1748:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
1749:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1750:../uvc.c      **** 							 getData1 = Data1;
1751:../uvc.c      **** #endif
1752:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
1753:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
1754:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1755:../uvc.c      **** 							 break;
1756:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
1757:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
1758:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
1759:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
1760:../uvc.c      **** 
1761:../uvc.c      **** 							 dataIdx = 0;
1762:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1763:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
1764:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1765:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
1766:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
1767:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1768:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1769:../uvc.c      **** 							 break;
1770:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
1771:../uvc.c      **** 							 dataIdx = 0;
1772:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
1773:../uvc.c      **** 							 if(Data0 == 1){
1774:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
1775:../uvc.c      **** 							 }else{
1776:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
1777:../uvc.c      **** 							 }
1778:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1779:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
1780:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1781:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1782:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
1783:../uvc.c      **** 							 break;
1784:../uvc.c      **** 				  	  	 case BrgtCtlID1:
1785:../uvc.c      **** #if 0 //cancel for 5MP w/b camera
1786:../uvc.c      **** 							 dataIdx = 0;
1787:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1788:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1789:../uvc.c      **** 							  if(Data0&0x80){
1790:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
1791:../uvc.c      **** 							  }else{
1792:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
1793:../uvc.c      **** 							  }
1794:../uvc.c      **** 							 Data1 |= ~0x03;
1795:../uvc.c      **** 							 Data1 &= 0xC7;
1796:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
1797:../uvc.c      **** 						  	 dataIdx++;
1798:../uvc.c      **** 
1799:../uvc.c      **** 							 Data0 = (Data0 << 2);
1800:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
1801:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1802:../uvc.c      **** 
1803:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1804:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
1805:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1806:../uvc.c      **** #endif
1807:../uvc.c      **** 							 dataIdx = 0;
1808:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1809:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1810:../uvc.c      **** 							  if(Data0&0x80){
1811:../uvc.c      **** 								  Data0 = Data0 - 0x80;
1812:../uvc.c      **** 							  }else{
1813:../uvc.c      **** 								  Data0 = ~Data0;
1814:../uvc.c      **** 							  }
1815:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
1816:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1817:../uvc.c      **** 
1818:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1819:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1820:../uvc.c      **** 
1821:../uvc.c      **** 
1822:../uvc.c      **** 							 break;
1823:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
1824:../uvc.c      **** 							 dataIdx = 0;
1825:../uvc.c      **** 
1826:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1827:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
1828:../uvc.c      **** 							 dataIdx++;
1829:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
1830:../uvc.c      **** 							 dataIdx++;
1831:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
1832:../uvc.c      **** 							 dataIdx++;
1833:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
1834:../uvc.c      **** 							 dataIdx++;
1835:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
1836:../uvc.c      **** 							 dataIdx++;
1837:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
1838:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1839:../uvc.c      **** 
1840:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
1841:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1842:../uvc.c      **** 							 break;
1843:../uvc.c      **** 						 case SaturCtlID6:
1844:../uvc.c      **** 							 dataIdx = 0;
1845:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
1846:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1847:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1848:../uvc.c      **** 							 dataIdx++;
1849:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
1850:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1851:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1852:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1853:../uvc.c      **** 							 break;
1854:../uvc.c      **** 
1855:../uvc.c      **** 						 case WBTLevCtlID11:
1856:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
1857:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
1858:../uvc.c      **** 							 dataIdx = 0;
1859:../uvc.c      **** 
1860:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1861:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1862:../uvc.c      **** 							 dataIdx++;
1863:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
1864:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1865:../uvc.c      **** 
1866:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
1867:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
1868:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1869:../uvc.c      **** 							 break;
1870:../uvc.c      **** 						 case MFreqCtlID4:
1871:../uvc.c      **** 							 dataIdx = 0;
1872:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1873:../uvc.c      **** 							 Data0 = Data0 - 1;
1874:../uvc.c      **** 							 is60Hz = Data0;
1875:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
1876:../uvc.c      **** 							 {
1877:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
1878:../uvc.c      **** 								 is60Hz = CyFalse;
1879:../uvc.c      **** 							 }
1880:../uvc.c      **** 							 else if(Data0 >2)
1881:../uvc.c      **** 							 {
1882:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
1883:../uvc.c      **** 								 is60Hz = CyTrue;
1884:../uvc.c      **** 							 }
1885:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
1886:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
1887:../uvc.c      **** 							 {
1888:../uvc.c      **** 								 //CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1889:../uvc.c      **** 			                       switch (setRes)
1890:../uvc.c      **** 			                         {
1891:../uvc.c      **** 			                         	case 1: //1944
1892:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
1893:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1894:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1895:../uvc.c      **** 			                         		break;
1896:../uvc.c      **** 			                         	case 2: //1080
1897:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
1898:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1899:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1900:../uvc.c      **** 			                         		break;
1901:../uvc.c      **** 			                         	case 3: //720
1902:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
1903:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1904:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1905:../uvc.c      **** 			                         		break;
1906:../uvc.c      **** 			                         	case 4: //VGA
1907:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
1908:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1909:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1910:../uvc.c      **** 			                         	default:
1911:../uvc.c      **** 			                         		break;
1912:../uvc.c      **** 			                         }
1913:../uvc.c      **** 								 //CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1914:../uvc.c      **** 							 }
1915:../uvc.c      **** 
1916:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1917:../uvc.c      **** 							 break;
1918:../uvc.c      **** 					 	 case BLCCtlID0:
1919:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1920:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1921:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1922:../uvc.c      **** 						     dataIdx = 0;
1923:../uvc.c      **** 
1924:../uvc.c      **** 							 //CtrlParArry[CtrlID][13] = Data0;
1925:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1926:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1927:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1928:../uvc.c      **** 
1929:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
1930:../uvc.c      **** 							 {
1931:../uvc.c      **** 								 if(Data0 < 3){
1932:../uvc.c      **** 					 				 Data0 += 4;
1933:../uvc.c      **** 					 			 }else{
1934:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1935:../uvc.c      **** 									Data0 = 4; //set to default.
1936:../uvc.c      **** 					 			 }
1937:../uvc.c      **** 					 		 }
1938:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0;
1939:../uvc.c      **** 							 dataIdx = 0;
1940:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1941:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1942:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1943:../uvc.c      **** 
1944:../uvc.c      **** 					 		 break;
1945:../uvc.c      **** 					 	 case ShapCtlID7:
1946:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1947:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1948:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1949:../uvc.c      **** 						     dataIdx = 0;
1950:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1951:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1952:../uvc.c      **** 							 if(Data0 != 0){
1953:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1954:../uvc.c      **** #ifdef COLOR
1955:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Second: set enhancement valu
1956:../uvc.c      **** #else
1957:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
1958:../uvc.c      **** 								 dataIdx++;
1959:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
1960:../uvc.c      **** #endif
1961:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1962:../uvc.c      **** 							 }else{
1963:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1964:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
1965:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1966:../uvc.c      **** 
1967:../uvc.c      **** 							 }
1968:../uvc.c      **** 							 break;
1969:../uvc.c      **** 						 case ExtExRefCtlID10:
1970:../uvc.c      **** 						 case ConsCtlID2:
1971:../uvc.c      **** 							 dataIdx = 0;
1972:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1973:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1974:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1975:../uvc.c      **** 
1976:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
1977:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
1978:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][13] = Data0;  //it's canceled as the both is the same contro
1979:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][16] = CyTrue;
1980:../uvc.c      **** 
1981:../uvc.c      **** 							 break;
1982:../uvc.c      **** 						 default:
1983:../uvc.c      **** 							 dataIdx = 0;
1984:../uvc.c      **** 
1985:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1986:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1987:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1988:../uvc.c      **** 
1989:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1990:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1991:../uvc.c      **** 							 break;
1992:../uvc.c      **** 					 }
1993:../uvc.c      **** 			   }else{
1994:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
1995:../uvc.c      **** 			   }
1996:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1997:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
1998:../uvc.c      **** #endif
1999:../uvc.c      **** 
2000:../uvc.c      **** 			  break;
2001:../uvc.c      **** 		  default:
2002:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
2003:../uvc.c      **** 			  break;
2004:../uvc.c      **** 		 }
2005:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
2006:../uvc.c      **** }
2007:../uvc.c      **** /************** CT control requests handler *************************/
2008:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
2009:../uvc.c      **** 
2010:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
2011:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
2012:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
2013:../uvc.c      ****     uint16_t readCount;
2014:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
2015:../uvc.c      ****     uint16_t diff, value, diffRd;
2016:../uvc.c      ****     uint8_t i, shutter, index;
2017:../uvc.c      ****     diff = 0xffff;
2018:../uvc.c      ****     shutter = 1;
2019:../uvc.c      ****     index = 1;
2020:../uvc.c      **** 
2021:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
2022:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
2023:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
2024:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
2025:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
2026:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2027:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
2028:../uvc.c      **** #endif
2029:../uvc.c      ****     reqData = bRequest;
2030:../uvc.c      **** 
2031:../uvc.c      ****     switch (bRequest)
2032:../uvc.c      **** 		 {
2033:../uvc.c      **** 
2034:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
2035:../uvc.c      **** 			  glEp0Buffer[0] = Len;
2036:../uvc.c      **** 			  glEp0Buffer[1] = 0;
2037:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2038:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2039:../uvc.c      **** 			  break;
2040:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
2041:../uvc.c      **** 
2042:../uvc.c      **** 			 switch(CtrlID)
2043:../uvc.c      **** 			 {
2044:../uvc.c      **** 				 default:
2045:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
2046:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
2047:../uvc.c      **** 					 glEp0Buffer[2] = 0;
2048:../uvc.c      **** 					 glEp0Buffer[3] = 0;
2049:../uvc.c      **** 					 sendData = glEp0Buffer[0];
2050:../uvc.c      **** 					 break;
2051:../uvc.c      **** 			 }
2052:../uvc.c      **** 
2053:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2054:../uvc.c      **** 
2055:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2056:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
2057:../uvc.c      **** #endif
2058:../uvc.c      **** 			  break;
2059:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
2060:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
2061:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
2062:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
2063:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2064:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2065:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2066:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2067:../uvc.c      **** 			  break;
2068:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
2069:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
2070:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
2071:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
2072:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2073:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2074:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2075:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2076:../uvc.c      **** 			  break;
2077:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
2078:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
2079:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
2080:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
2081:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2082:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2083:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2084:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2085:../uvc.c      **** 			  break;
2086:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
2087:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
2088:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2089:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2090:../uvc.c      **** 			  Len = 1;
2091:../uvc.c      **** 			  break;
2092:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
2093:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
2094:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
2095:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
2096:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2097:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2098:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2099:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2100:../uvc.c      **** 			  break;
2101:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
2102:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2103:../uvc.c      **** 			  glEp0Buffer, &readCount);
2104:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
2105:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
2106:../uvc.c      **** 			  value = Data1;
2107:../uvc.c      **** 
2108:../uvc.c      **** 			  switch(CtrlID)
2109:../uvc.c      **** 			  {
2110:../uvc.c      **** 		  	      case AutoExMCtlID1:
2111:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
2112:../uvc.c      **** 
2113:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
2114:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
2115:../uvc.c      **** 				    getData = glEp0Buffer[0];
2116:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
2117:../uvc.c      **** 		  		    switch (getData){
2118:../uvc.c      **** 						case 1:
2119:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
2120:../uvc.c      **** 							break;
2121:../uvc.c      **** 						case 2:
2122:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
2123:../uvc.c      **** 							dataIdx = 0;
2124:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2125:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
2126:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2127:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
2128:../uvc.c      **** 
2129:../uvc.c      **** 							break;
2130:../uvc.c      **** 						case 4:
2131:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
2132:../uvc.c      **** 							break;
2133:../uvc.c      **** 						case 8:
2134:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
2135:../uvc.c      **** 			  		    	dataIdx = 0;
2136:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2137:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
2138:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2139:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
2140:../uvc.c      **** 							break;
2141:../uvc.c      **** 		  		    }
2142:../uvc.c      **** #if 0
2143:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
2144:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
2145:../uvc.c      **** 						  dataIdx = 0;
2146:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2147:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
2148:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2149:../uvc.c      **** 		  		    }
2150:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
2151:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
2152:../uvc.c      **** 		  		    }
2153:../uvc.c      **** #endif
2154:../uvc.c      **** 				    break;
2155:../uvc.c      **** 
2156:../uvc.c      **** 			  	  case ExTmACtlID3:
2157:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
2158:../uvc.c      **** 
2159:../uvc.c      **** 					  value = (value << 8)|Data0;
2160:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
2161:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
2162:../uvc.c      **** 					  {
2163:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
2164:../uvc.c      **** 						  {
2165:../uvc.c      **** 							if(value > ShutValueArry[i]){
2166:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
2167:../uvc.c      **** 							}else{
2168:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
2169:../uvc.c      **** 							}
2170:../uvc.c      **** 							  if(diff > diffRd){
2171:../uvc.c      **** 								  diff = diffRd;
2172:../uvc.c      **** 								  index = i;
2173:../uvc.c      **** 							  }
2174:../uvc.c      **** 						  }
2175:../uvc.c      **** 						  shutter = shutter+index;
2176:../uvc.c      **** 
2177:../uvc.c      **** 						  dataIdx = 0;
2178:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2179:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
2180:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2181:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
2182:../uvc.c      **** 
2183:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
2184:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
2185:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
2186:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
2187:../uvc.c      **** 					  }else{
2188:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
2189:../uvc.c      **** 					  }
2190:../uvc.c      **** 					  getData = glEp0Buffer[0];
2191:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
2192:../uvc.c      **** 					  break;
2193:../uvc.c      **** 			  	  case IriACtlID7:
2194:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
2195:../uvc.c      **** 					  {
2196:../uvc.c      **** 							 dataIdx = 0;
2197:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2198:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
2199:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2200:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
2201:../uvc.c      **** 
2202:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
2203:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
2204:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
2205:../uvc.c      **** 					  }else{
2206:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
2207:../uvc.c      **** 					  }
2208:../uvc.c      **** 					  getData = glEp0Buffer[0];
2209:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
2210:../uvc.c      **** 
2211:../uvc.c      **** 					  break;
2212:../uvc.c      **** 			  	  case ZmOpRCtlID10:
2213:../uvc.c      **** 					  getData = glEp0Buffer[0];
2214:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
2215:../uvc.c      **** #if 1
2216:../uvc.c      **** 					  dataIdx = 0;
2217:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2218:../uvc.c      **** 					  if(getData == 1)
2219:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
2220:../uvc.c      **** 					  else if(getData == 0xff)
2221:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
2222:../uvc.c      **** 					  else
2223:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
2224:../uvc.c      **** 					  //dataIdx++;
2225:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
2226:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2227:../uvc.c      **** #endif
2228:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
2229:../uvc.c      **** 					  break;
2230:../uvc.c      **** 
2231:../uvc.c      **** 			  	  default:
2232:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
2233:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
2234:../uvc.c      **** 			  		 break;
2235:../uvc.c      **** 			  }
2236:../uvc.c      **** 			  break;
2237:../uvc.c      **** 		  default:
2238:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
2239:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
2240:../uvc.c      **** 			  break;
2241:../uvc.c      **** 		 }
2242:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
2243:../uvc.c      **** 
2244:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
2245:../uvc.c      **** }
2246:../uvc.c      **** 
2247:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
2248:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
2249:../uvc.c      **** {
2250:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
2251:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
2252:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
2253:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
2254:../uvc.c      **** 
2255:../uvc.c      ****     CtrlID = BrgtCtlID1;
2256:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
2257:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2258:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
2259:../uvc.c      ****     Data1 = Data0;
2260:../uvc.c      **** 
2261:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2262:../uvc.c      ****     if(Data1&0x80){
2263:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
2264:../uvc.c      ****     }else{
2265:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
2266:../uvc.c      ****     }
2267:../uvc.c      ****     Data0 = (Data0 << 2);
2268:../uvc.c      **** 
2269:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
2270:../uvc.c      **** 
2271:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
2272:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
2273:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2274:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
2275:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
2276:../uvc.c      **** 
2277:../uvc.c      ****     CtrlID = ConsCtlID2;
2278:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2279:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2280:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2281:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
2282:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2283:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
2284:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2285:../uvc.c      **** 
2286:../uvc.c      ****     CtrlID = HueCtlID5;
2287:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2288:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2289:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2290:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
2291:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
2292:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
2293:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
2294:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
2295:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
2296:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
2297:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
2298:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
2299:../uvc.c      **** 
2300:../uvc.c      ****     CtrlID = SaturCtlID6;
2301:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2302:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2303:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
2304:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
2305:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
2306:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2307:../uvc.c      **** 
2308:../uvc.c      ****     CtrlID = ShapCtlID7;
2309:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2310:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2311:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2312:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
2313:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2314:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2315:../uvc.c      **** 
2316:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
2317:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
2318:../uvc.c      **** 	return;
2319:../uvc.c      **** }
2320:../uvc.c      **** 
2321:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
2322:../uvc.c      **** void
2323:../uvc.c      **** CyFxUVCAddHeader (
2324:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
2325:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
2326:../uvc.c      ****         )
2327:../uvc.c      **** {
2328:../uvc.c      ****     /* Copy header to buffer */
2329:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2330:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
2331:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
2332:../uvc.c      **** 
2333:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
2334:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
2335:../uvc.c      ****     {
2336:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
2337:../uvc.c      ****     }
2338:../uvc.c      **** }
2339:../uvc.c      **** 
2340:../uvc.c      **** 
2341:../uvc.c      **** /* Application Error Handler */
2342:../uvc.c      **** void
2343:../uvc.c      **** CyFxAppErrorHandler (
2344:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
2345:../uvc.c      ****         )
2346:../uvc.c      **** {
2347:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
2348:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
2349:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
2350:../uvc.c      **** 
2351:../uvc.c      ****        This function can be modified to take additional error handling actions such
2352:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
2353:../uvc.c      ****      */
2354:../uvc.c      ****     for (;;)
2355:../uvc.c      ****     {
2356:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
2357:../uvc.c      ****         CyU3PThreadSleep (1000);
2358:../uvc.c      ****     }
2359:../uvc.c      **** }
2360:../uvc.c      **** 
2361:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
2362:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
2363:../uvc.c      ****  */
2364:../uvc.c      **** static void
2365:../uvc.c      **** CyFxUVCApplnAbortHandler (
2366:../uvc.c      ****         void)
2367:../uvc.c      **** {
2368:../uvc.c      **** 	uint32_t flag;
2369:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
2370:../uvc.c      **** 	{
2371:../uvc.c      ****         /* Clear the Video Stream Request Event */
2372:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
2373:../uvc.c      **** 
2374:../uvc.c      ****         /* Set Video Stream Abort Event */
2375:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
2376:../uvc.c      **** 	}
2377:../uvc.c      **** }
2378:../uvc.c      **** 
2379:../uvc.c      **** /* This is the Callback function to handle the USB Events */
2380:../uvc.c      **** static void
2381:../uvc.c      **** CyFxUVCApplnUSBEventCB (
2382:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
2383:../uvc.c      ****         uint16_t             evdata  /* Event data */
2384:../uvc.c      ****         )
2385:../uvc.c      **** {
2386:../uvc.c      ****     switch (evtype)
2387:../uvc.c      ****     {
2388:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
2389:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
2390:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2391:../uvc.c      ****             gpif_initialized = 0;
2392:../uvc.c      ****             streamingStarted = CyFalse;
2393:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2394:../uvc.c      ****             break;
2395:../uvc.c      **** 
2396:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
2397:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
2398:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2399:../uvc.c      ****             gpif_initialized = 0;
2400:../uvc.c      ****             streamingStarted = CyFalse;
2401:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2402:../uvc.c      ****             break;
2403:../uvc.c      **** 
2404:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
2405:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
2406:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2407:../uvc.c      ****             gpif_initialized = 0;
2408:../uvc.c      ****             isUsbConnected = CyFalse;
2409:../uvc.c      ****             streamingStarted = CyFalse;
2410:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2411:../uvc.c      ****             break;
2412:../uvc.c      **** 
2413:../uvc.c      **** #ifdef BACKFLOW_DETECT
2414:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
2415:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
2416:../uvc.c      ****             break;
2417:../uvc.c      **** #endif
2418:../uvc.c      **** 
2419:../uvc.c      ****         default:
2420:../uvc.c      ****             break;
2421:../uvc.c      ****     }
2422:../uvc.c      **** }
2423:../uvc.c      **** 
2424:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
2425:../uvc.c      **** static CyBool_t
2426:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
2427:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
2428:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
2429:../uvc.c      ****         )
2430:../uvc.c      **** {
2431:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
2432:../uvc.c      ****     uint32_t status;
2433:../uvc.c      **** 
2434:../uvc.c      ****     /* Obtain Request Type and Request */
2435:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
2436:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
2437:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
2438:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
2439:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
2440:../uvc.c      **** 
2441:../uvc.c      ****     /* Check for UVC Class Requests */
2442:../uvc.c      ****     switch (bmReqType)
2443:../uvc.c      ****     {
2444:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
2445:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
2446:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
2447:../uvc.c      ****             switch (wIndex & 0xFF)
2448:../uvc.c      ****             {
2449:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
2450:../uvc.c      ****                     {
2451:../uvc.c      ****                         uvcHandleReq = CyTrue;
2452:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
2453:../uvc.c      ****                                 CYU3P_EVENT_OR);
2454:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2455:../uvc.c      ****                         {
2456:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
2457:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2458:../uvc.c      ****                         }
2459:../uvc.c      ****                     }
2460:../uvc.c      ****                     break;
2461:../uvc.c      **** 
2462:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
2463:../uvc.c      ****                     {
2464:../uvc.c      ****                         uvcHandleReq = CyTrue;
2465:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
2466:../uvc.c      ****                                 CYU3P_EVENT_OR);
2467:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2468:../uvc.c      ****                         {
2469:../uvc.c      ****                             /* Error handling */
2470:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
2471:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2472:../uvc.c      ****                         }
2473:../uvc.c      ****                     }
2474:../uvc.c      ****                     break;
2475:../uvc.c      **** 
2476:../uvc.c      ****                 default:
2477:../uvc.c      ****                     break;
2478:../uvc.c      ****             }
2479:../uvc.c      ****             break;
2480:../uvc.c      **** 
2481:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
2482:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
2483:../uvc.c      ****             {
2484:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
2485:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
2486:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
2487:../uvc.c      ****                 {
2488:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
2489:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
2490:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
2491:../uvc.c      ****                     gpif_initialized = 0;
2492:../uvc.c      ****                     streamingStarted = CyFalse;
2493:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
2494:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2495:../uvc.c      ****                     CyU3PBusyWait (100);
2496:../uvc.c      **** 
2497:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
2498:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2499:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2500:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2501:../uvc.c      ****                     CyU3PBusyWait (100);
2502:../uvc.c      **** 
2503:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
2504:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2505:../uvc.c      ****                     uvcHandleReq = CyTrue;
2506:../uvc.c      ****                     /* Complete Control request handshake */
2507:../uvc.c      ****                     CyU3PUsbAckSetup ();
2508:../uvc.c      ****                     /* Indicate stop streaming to main thread */
2509:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
2510:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
2511:../uvc.c      **** 
2512:../uvc.c      ****                 }
2513:../uvc.c      ****             }
2514:../uvc.c      ****             break;
2515:../uvc.c      **** 
2516:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
2517:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
2518:../uvc.c      ****             {
2519:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
2520:../uvc.c      ****                 {
2521:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
2522:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
2523:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
2524:../uvc.c      ****                 	 * has started. */
2525:../uvc.c      ****                     if (streamingStarted == CyTrue)
2526:../uvc.c      ****                     {
2527:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
2528:../uvc.c      **** 
2529:../uvc.c      ****                         /* Disable the GPIF state machine. */
2530:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
2531:../uvc.c      ****                         gpif_initialized = 0;
2532:../uvc.c      ****                         streamingStarted = CyFalse;
2533:../uvc.c      **** 
2534:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
2535:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2536:../uvc.c      ****                         CyU3PBusyWait (100);
2537:../uvc.c      **** 
2538:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
2539:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2540:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2541:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2542:../uvc.c      ****                         CyU3PBusyWait (100);
2543:../uvc.c      **** 
2544:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
2545:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2546:../uvc.c      **** 
2547:../uvc.c      ****                         uvcHandleReq = CyTrue;
2548:../uvc.c      ****                         /* Complete Control request handshake */
2549:../uvc.c      ****                         CyU3PUsbAckSetup ();
2550:../uvc.c      ****                         /* Indicate stop streaming to main thread */
2551:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
2552:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
2553:../uvc.c      ****                     }
2554:../uvc.c      ****                     else
2555:../uvc.c      ****                     {
2556:../uvc.c      ****                         uvcHandleReq = CyTrue;
2557:../uvc.c      ****                         CyU3PUsbAckSetup ();
2558:../uvc.c      ****                     }
2559:../uvc.c      ****                 }
2560:../uvc.c      ****             }
2561:../uvc.c      ****             break;
2562:../uvc.c      **** 
2563:../uvc.c      ****         default:
2564:../uvc.c      ****             break;
2565:../uvc.c      ****     }
2566:../uvc.c      **** 
2567:../uvc.c      ****     /* Return status of request handling to the USB driver */
2568:../uvc.c      ****     return uvcHandleReq;
2569:../uvc.c      **** }
2570:../uvc.c      **** 
2571:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
2572:../uvc.c      **** 
2573:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
2574:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
2575:../uvc.c      ****  */
2576:../uvc.c      **** void
2577:../uvc.c      **** CyFxUvcApplnDmaCallback (
2578:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
2579:../uvc.c      ****         CyU3PDmaCbType_t      type,
2580:../uvc.c      ****         CyU3PDmaCBInput_t    *input
2581:../uvc.c      ****         )
2582:../uvc.c      **** {
2583:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
2584:../uvc.c      **** #if 1
2585:../uvc.c      ****     CyU3PReturnStatus_t status;
2586:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
2587:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
2588:../uvc.c      **** 
2589:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2590:../uvc.c      ****     {
2591:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
2592:../uvc.c      ****             {
2593:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
2594:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
2595:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2596:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
2597:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2598:../uvc.c      ****                 	stiflag = 0x03;
2599:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
2600:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2601:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2602:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2603:../uvc.c      ****                 }
2604:../uvc.c      **** #endif
2605:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
2606:../uvc.c      ****                 fb++;
2607:../uvc.c      ****             }
2608:../uvc.c      ****             else
2609:../uvc.c      ****             {
2610:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
2611:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
2612:../uvc.c      ****                 pb++;
2613:../uvc.c      ****                 pbc = input->buffer_p.count;
2614:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
2615:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
2616:../uvc.c      ****                 //lineCount = 0; //res test
2617:../uvc.c      **** #if 1   //remove the still flag clearing here
2618:../uvc.c      ****                 if(stiflag == 0x0F){
2619:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2620:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2621:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2622:../uvc.c      ****                 	stiflag = 0xAA;
2623:../uvc.c      ****                 }
2624:../uvc.c      **** #endif
2625:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
2626:../uvc.c      ****             }
2627:../uvc.c      **** 
2628:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
2629:../uvc.c      ****             prodCount++;
2630:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2631:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
2632:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
2633:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
2634:../uvc.c      ****             {
2635:../uvc.c      ****                 prodCount--;
2636:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
2637:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
2638:../uvc.c      ****             }
2639:../uvc.c      ****     }
2640:../uvc.c      **** #endif
2641:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
2642:../uvc.c      ****     {
2643:../uvc.c      ****         consCount++;
2644:../uvc.c      ****         streamingStarted = CyTrue;
2645:../uvc.c      ****     }
2646:../uvc.c      **** }
2647:../uvc.c      **** 
2648:../uvc.c      **** /*
2649:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
2650:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
2651:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
2652:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
2653:../uvc.c      ****  * to commit the buffer.
2654:../uvc.c      ****  */
2655:../uvc.c      **** static uint8_t
2656:../uvc.c      **** CyFxUvcAppCommitEOF (
2657:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
2658:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
2659:../uvc.c      ****         )
2660:../uvc.c      **** {
2661:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2662:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
2663:../uvc.c      **** 
2664:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
2665:../uvc.c      **** 
2666:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2667:../uvc.c      ****     {
2668:../uvc.c      ****         switch (stateId)
2669:../uvc.c      ****         {
2670:../uvc.c      **** 
2671:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
2672:../uvc.c      ****             case FULL_BUF_IN_SCK1:
2673:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2674:../uvc.c      ****                 break;
2675:../uvc.c      **** 
2676:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
2677:../uvc.c      ****                 socket = 0;
2678:../uvc.c      ****                 break;
2679:../uvc.c      **** 
2680:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
2681:../uvc.c      ****                 socket = 1;
2682:../uvc.c      ****                 break;
2683:../uvc.c      **** 
2684:../uvc.c      ****             default:
2685:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2686:../uvc.c      ****                 /* Unexpected current state. Return error. */
2687:../uvc.c      ****             	//lineCount++;
2688:../uvc.c      ****             	return 1;
2689:../uvc.c      ****         }
2690:../uvc.c      ****     }
2691:../uvc.c      **** 
2692:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2693:../uvc.c      ****     {
2694:../uvc.c      ****         switch (stateId)
2695:../uvc.c      ****         {
2696:../uvc.c      **** #ifndef CAM720
2697:../uvc.c      **** #ifdef GPIFIIM
2698:../uvc.c      ****             case 13:
2699:../uvc.c      ****             case 24:
2700:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2701:../uvc.c      ****                 break;
2702:../uvc.c      **** 
2703:../uvc.c      ****             case 8:
2704:../uvc.c      ****                 socket = 0;
2705:../uvc.c      ****                 break;
2706:../uvc.c      **** 
2707:../uvc.c      ****             case 20:
2708:../uvc.c      ****                 socket = 1;
2709:../uvc.c      ****                 break;
2710:../uvc.c      **** #else
2711:../uvc.c      ****             case 11:
2712:../uvc.c      ****             case 18:
2713:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2714:../uvc.c      ****                 break;
2715:../uvc.c      **** 
2716:../uvc.c      ****             case 8:
2717:../uvc.c      ****                 socket = 0;
2718:../uvc.c      ****                 break;
2719:../uvc.c      **** 
2720:../uvc.c      ****             case 15:
2721:../uvc.c      ****                 socket = 1;
2722:../uvc.c      ****                 break;
2723:../uvc.c      **** #endif
2724:../uvc.c      **** #else
2725:../uvc.c      ****             case 11:
2726:../uvc.c      ****             case 18:
2727:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2728:../uvc.c      ****                 break;
2729:../uvc.c      **** 
2730:../uvc.c      ****             case 8:
2731:../uvc.c      ****                 socket = 0;
2732:../uvc.c      ****                 break;
2733:../uvc.c      **** 
2734:../uvc.c      ****             case 15:
2735:../uvc.c      ****                 socket = 1;
2736:../uvc.c      ****                 break;
2737:../uvc.c      **** 
2738:../uvc.c      **** #endif
2739:../uvc.c      ****              default:
2740:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2741:../uvc.c      ****                 /* Unexpected current state. Return error. */
2742:../uvc.c      ****                return 1;
2743:../uvc.c      ****         }
2744:../uvc.c      ****     }
2745:../uvc.c      **** 
2746:../uvc.c      ****     if (socket != 0xFF)
2747:../uvc.c      ****     {
2748:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
2749:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
2750:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
2751:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
2752:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
2753:../uvc.c      ****         {
2754:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
2755:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
2756:../uvc.c      ****         }
2757:../uvc.c      ****     }
2758:../uvc.c      **** 
2759:../uvc.c      ****     return 0;
2760:../uvc.c      **** }
2761:../uvc.c      **** 
2762:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
2763:../uvc.c      **** void
2764:../uvc.c      **** CyFxGpifCB (
2765:../uvc.c      ****         CyU3PGpifEventType event,
2766:../uvc.c      ****         uint8_t currentState
2767:../uvc.c      ****         )
2768:../uvc.c      **** {
2769:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
2770:../uvc.c      ****     {
2771:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
2772:../uvc.c      ****     	           in the UVC implementation. */
2773:../uvc.c      ****     	//hitFV = CyTrue;
2774:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
2775:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
2776:../uvc.c      ****     }
2777:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
2778:../uvc.c      **** }
2779:../uvc.c      **** 
2780:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
2781:../uvc.c      **** static void
2782:../uvc.c      **** CyFxUVCApplnDebugInit (
2783:../uvc.c      ****         void)
2784:../uvc.c      **** {
2785:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
2786:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
2787:../uvc.c      **** 
2788:../uvc.c      ****     /* Initialize the UART for printing debug messages */
2789:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
2790:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2791:../uvc.c      ****     {
2792:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
2793:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2794:../uvc.c      ****     }
2795:../uvc.c      **** 
2796:../uvc.c      ****     /* Set UART Configuration */
2797:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
2798:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
2799:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
2800:../uvc.c      ****     uartConfig.txEnable = CyTrue;
2801:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
2802:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
2803:../uvc.c      ****     uartConfig.isDma    = CyTrue;
2804:../uvc.c      **** 
2805:../uvc.c      ****     /* Set the UART configuration */
2806:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
2807:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2808:../uvc.c      ****     {
2809:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2810:../uvc.c      ****     }
2811:../uvc.c      **** 
2812:../uvc.c      ****     /* Set the UART transfer */
2813:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
2814:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2815:../uvc.c      ****     {
2816:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2817:../uvc.c      ****     }
2818:../uvc.c      **** 
2819:../uvc.c      ****     /* Initialize the Debug logger module. */
2820:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
2821:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2822:../uvc.c      ****     {
2823:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2824:../uvc.c      ****     }
2825:../uvc.c      **** 
2826:../uvc.c      ****     /* Disable log message headers. */
2827:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
2828:../uvc.c      **** }
2829:../uvc.c      **** 
2830:../uvc.c      **** /* I2C initialization. */
2831:../uvc.c      **** static void
2832:../uvc.c      **** CyFxUVCApplnI2CInit (void)
2833:../uvc.c      **** {
2834:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
2835:../uvc.c      ****     CyU3PReturnStatus_t status;
2836:../uvc.c      **** 
2837:../uvc.c      ****     status = CyU3PI2cInit ();
2838:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
2839:../uvc.c      ****     {
2840:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
2841:../uvc.c      ****         CyFxAppErrorHandler (status);
2842:../uvc.c      ****     }
2843:../uvc.c      **** 
2844:../uvc.c      ****     /*  Set I2C Configuration */
2845:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
2846:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
2847:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
2848:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
2849:../uvc.c      **** 
2850:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
2851:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
2852:../uvc.c      ****     {
2853:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
2854:../uvc.c      ****         CyFxAppErrorHandler (status);
2855:../uvc.c      ****     }
2856:../uvc.c      **** }
2857:../uvc.c      **** 
2858:../uvc.c      **** #ifdef BACKFLOW_DETECT
2859:../uvc.c      **** static void CyFxUvcAppPibCallback (
2860:../uvc.c      ****         CyU3PPibIntrType cbType,
2861:../uvc.c      ****         uint16_t cbArg)
2862:../uvc.c      **** {
2863:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
2864:../uvc.c      ****     {
2865:../uvc.c      ****         if (!back_flow_detected)
2866:../uvc.c      ****         {
2867:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
2868:../uvc.c      ****             back_flow_detected = 1;
2869:../uvc.c      ****         }
2870:../uvc.c      ****     }
2871:../uvc.c      **** }
2872:../uvc.c      **** #endif
2873:../uvc.c      **** 
2874:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2875:../uvc.c      **** static void
2876:../uvc.c      **** CyFxUvcAppDebugCallback (
2877:../uvc.c      ****         CyU3PDmaChannel   *handle,
2878:../uvc.c      ****         CyU3PDmaCbType_t   type,
2879:../uvc.c      ****         CyU3PDmaCBInput_t *input)
2880:../uvc.c      **** {
2881:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2882:../uvc.c      ****     {
2883:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
2884:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
2885:../uvc.c      ****     }
2886:../uvc.c      **** }
2887:../uvc.c      **** #endif
2888:../uvc.c      **** 
2889:../uvc.c      **** #if 0
2890:../uvc.c      **** static void CyFxAppIntEpCb(
2891:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
2892:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
2893:../uvc.c      **** 		uint8_t  ebNum)
2894:../uvc.c      **** 		{
2895:../uvc.c      **** 			//CyBool_t value;
2896:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
2897:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
2898:../uvc.c      **** 
2899:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
2900:../uvc.c      **** 		}
2901:../uvc.c      **** #endif
2902:../uvc.c      **** 
2903:../uvc.c      **** /* This function initializes the USB Module, creates event group,
2904:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
2905:../uvc.c      ****    configures the DMA module for the UVC Application */
2906:../uvc.c      **** static void
2907:../uvc.c      **** CyFxUVCApplnInit (void)
2908:../uvc.c      **** {
2909:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
2910:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
2911:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
2912:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
2913:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
2914:../uvc.c      ****     CyU3PPibClock_t              pibclock;
2915:../uvc.c      **** 
2916:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
2917:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
2918:../uvc.c      **** 
2919:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2920:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
2921:../uvc.c      **** #endif
2922:../uvc.c      **** 
2923:../uvc.c      ****     /* Create UVC event group */
2924:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
2925:../uvc.c      ****     if (apiRetStatus != 0)
2926:../uvc.c      ****     {
2927:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
2928:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2929:../uvc.c      ****     }
2930:../uvc.c      **** 
2931:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2932:../uvc.c      ****     CyFxUvcAppPTZInit ();
2933:../uvc.c      **** #endif
2934:../uvc.c      **** 
2935:../uvc.c      ****     isUsbConnected = CyFalse;
2936:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
2937:../uvc.c      **** 
2938:../uvc.c      ****     /* Init the GPIO module */
2939:../uvc.c      ****     gpioClock.fastClkDiv = 2;
2940:../uvc.c      ****     gpioClock.slowClkDiv = 2;
2941:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
2942:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
2943:../uvc.c      ****     gpioClock.halfDiv    = 0;
2944:../uvc.c      **** 
2945:../uvc.c      ****     /* Initialize Gpio interface */
2946:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
2947:../uvc.c      ****     if (apiRetStatus != 0)
2948:../uvc.c      ****     {
2949:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
2950:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2951:../uvc.c      ****     }
2952:../uvc.c      **** 
2953:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
2954:../uvc.c      ****      * must use GpioOverride to configure it */
2955:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
2956:../uvc.c      ****     if (apiRetStatus != 0)
2957:../uvc.c      ****     {
2958:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
2959:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2960:../uvc.c      ****     }
2961:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
2962:../uvc.c      ****     if (apiRetStatus != 0)
2963:../uvc.c      ****     {
2964:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
2965:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2966:../uvc.c      ****     }
2967:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
2968:../uvc.c      ****     if (apiRetStatus != 0)
2969:../uvc.c      ****     {
2970:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
2971:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2972:../uvc.c      ****     }
2973:../uvc.c      **** 
2974:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
2975:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2976:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2977:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2978:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2979:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2980:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
2981:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2982:../uvc.c      ****     {
2983:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
2984:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2985:../uvc.c      ****     }
2986:../uvc.c      **** 
2987:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
2988:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2989:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2990:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2991:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2992:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2993:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2994:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
2995:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2996:../uvc.c      ****     {
2997:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
2998:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2999:../uvc.c      ****     }
3000:../uvc.c      **** 
3001:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
3002:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
3003:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
3004:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
3005:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
3006:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
3007:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3008:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
3009:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3010:../uvc.c      ****     {
3011:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
3012:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3013:../uvc.c      ****     }
3014:../uvc.c      **** 
3015:../uvc.c      ****     /* Initialize the P-port. */
3016:../uvc.c      ****     pibclock.clkDiv      = 2;
3017:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
3018:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
3019:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
3020:../uvc.c      **** 
3021:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
3022:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3023:../uvc.c      ****     {
3024:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
3025:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3026:../uvc.c      ****     }
3027:../uvc.c      **** 
3028:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
3029:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
3030:../uvc.c      **** 
3031:../uvc.c      **** #ifdef BACKFLOW_DETECT
3032:../uvc.c      ****     back_flow_detected = 0;
3033:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
3034:../uvc.c      **** #endif
3035:../uvc.c      **** 
3036:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
3037:../uvc.c      ****     SensorReset ();
3038:../uvc.c      ****     CyU3PThreadSleep(5000);
3039:../uvc.c      ****     //SensorInit ();
3040:../uvc.c      **** 
3041:../uvc.c      ****     /* USB initialization. */
3042:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
3043:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3044:../uvc.c      ****     {
3045:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
3046:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3047:../uvc.c      ****     }
3048:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
3049:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
3050:../uvc.c      **** 
3051:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
3052:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
3053:../uvc.c      **** 
3054:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
3055:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
3056:../uvc.c      **** 
3057:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
3058:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
3059:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
3060:../uvc.c      **** 
3061:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
3062:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
3063:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
3064:../uvc.c      **** 
3065:../uvc.c      ****     /* Configuration descriptors. */
3066:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
3067:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
3068:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
3069:../uvc.c      **** 
3070:../uvc.c      ****     /* String Descriptors */
3071:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
3072:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
3073:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
3074:../uvc.c      **** 
3075:../uvc.c      ****     /* Configure the status interrupt endpoint.
3076:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
3077:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
3078:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
3079:../uvc.c      ****      */
3080:../uvc.c      ****     endPointConfig.enable   = 1;
3081:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
3082:../uvc.c      ****     endPointConfig.pcktSize = 64;
3083:../uvc.c      ****     endPointConfig.isoPkts  = 0;
3084:../uvc.c      ****     endPointConfig.streams  = 0;
3085:../uvc.c      ****     endPointConfig.burstLen = 1;
3086:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
3087:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3088:../uvc.c      ****     {
3089:../uvc.c      ****         /* Error Handling */
3090:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
3091:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3092:../uvc.c      ****     }
3093:../uvc.c      **** 
3094:../uvc.c      ****     /* create a DMA for interrupt endpoint */
3095:../uvc.c      ****     dmaInterConfig.size           = 1024;
3096:../uvc.c      ****     dmaInterConfig.count          = 1;
3097:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
3098:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
3099:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
3100:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
3101:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
3102:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
3103:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3104:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
3105:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
3106:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
3107:../uvc.c      ****             &dmaInterConfig);
3108:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3109:../uvc.c      ****     {
3110:../uvc.c      ****         /* Error handling */
3111:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
3112:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3113:../uvc.c      ****     }
3114:../uvc.c      **** 
3115:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
3116:../uvc.c      ****     if (glInterStaBuffer == 0)
3117:../uvc.c      ****     {
3118:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
3119:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
3120:../uvc.c      ****     }
3121:../uvc.c      **** 
3122:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
3123:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
3124:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
3125:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
3126:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
3127:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
3128:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
3129:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
3130:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
3131:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
3132:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
3133:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
3134:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3135:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
3136:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
3137:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
3138:../uvc.c      ****             &dmaMultiConfig);
3139:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3140:../uvc.c      ****     {
3141:../uvc.c      ****         /* Error handling */
3142:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
3143:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3144:../uvc.c      ****     }
3145:../uvc.c      **** 
3146:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3147:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
3148:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
3149:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
3150:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
3151:../uvc.c      ****      */
3152:../uvc.c      **** 
3153:../uvc.c      ****     endPointConfig.enable   = 1;
3154:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
3155:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
3156:../uvc.c      ****     endPointConfig.isoPkts  = 0;
3157:../uvc.c      ****     endPointConfig.streams  = 0;
3158:../uvc.c      ****     endPointConfig.burstLen = 1;
3159:../uvc.c      **** 
3160:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
3161:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3162:../uvc.c      ****     {
3163:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
3164:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3165:../uvc.c      ****     }
3166:../uvc.c      **** 
3167:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
3168:../uvc.c      **** 
3169:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
3170:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3171:../uvc.c      ****     {
3172:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
3173:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3174:../uvc.c      ****     }
3175:../uvc.c      **** 
3176:../uvc.c      ****     channelConfig.size           = 1024;
3177:../uvc.c      ****     channelConfig.count          = 1;
3178:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
3179:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
3180:../uvc.c      ****     channelConfig.prodAvailCount = 0;
3181:../uvc.c      ****     channelConfig.prodHeader     = 0;
3182:../uvc.c      ****     channelConfig.prodFooter     = 0;
3183:../uvc.c      ****     channelConfig.consHeader     = 0;
3184:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3185:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
3186:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
3187:../uvc.c      **** 
3188:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
3189:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3190:../uvc.c      ****     {
3191:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
3192:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3193:../uvc.c      ****     }
3194:../uvc.c      **** 
3195:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
3196:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3197:../uvc.c      ****     {
3198:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
3199:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3200:../uvc.c      ****     }
3201:../uvc.c      **** 
3202:../uvc.c      ****     channelConfig.size           = 1024;
3203:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
3204:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
3205:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
3206:../uvc.c      ****     channelConfig.prodAvailCount = 0;
3207:../uvc.c      ****     channelConfig.prodHeader     = 0;
3208:../uvc.c      ****     channelConfig.prodFooter     = 0;
3209:../uvc.c      ****     channelConfig.consHeader     = 0;
3210:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3211:../uvc.c      ****     channelConfig.notification   = 0;
3212:../uvc.c      ****     channelConfig.cb             = 0;
3213:../uvc.c      **** 
3214:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
3215:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3216:../uvc.c      ****     {
3217:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
3218:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3219:../uvc.c      ****     }
3220:../uvc.c      **** 
3221:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
3222:../uvc.c      ****     if (glDebugRspBuffer == 0)
3223:../uvc.c      ****     {
3224:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
3225:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
3226:../uvc.c      ****     }
3227:../uvc.c      **** #endif
3228:../uvc.c      **** 
3229:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
3230:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
3231:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3232:../uvc.c      ****     {
3233:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
3234:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3235:../uvc.c      ****     }
3236:../uvc.c      **** 
3237:../uvc.c      ****     CyU3PBusyWait(100);
3238:../uvc.c      **** 
3239:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
3240:../uvc.c      **** 
3241:../uvc.c      ****     endPointConfig.enable   = 1;
3242:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
3243:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
3244:../uvc.c      ****     {
3245:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
3246:../uvc.c      ****     	endPointConfig.burstLen = 16;
3247:../uvc.c      ****     }
3248:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
3249:../uvc.c      ****     {
3250:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
3251:../uvc.c      ****     	endPointConfig.burstLen = 1;
3252:../uvc.c      ****     }
3253:../uvc.c      ****     endPointConfig.streams  = 0;
3254:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
3255:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3256:../uvc.c      ****     {
3257:../uvc.c      ****         /* Error Handling */
3258:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
3259:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3260:../uvc.c      ****     }
3261:../uvc.c      **** #if 0    //for still image method 3 using
3262:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
3263:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3264:../uvc.c      ****     {
3265:../uvc.c      ****         /* Error Handling */
3266:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
3267:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3268:../uvc.c      ****     }
3269:../uvc.c      **** #endif
3270:../uvc.c      **** 
3271:../uvc.c      **** }
3272:../uvc.c      **** 
3273:../uvc.c      **** /*
3274:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
3275:../uvc.c      ****  * streaming session is started.
3276:../uvc.c      ****  */
3277:../uvc.c      **** static void
3278:../uvc.c      **** CyFxUvcAppGpifInit (
3279:../uvc.c      ****         void)
3280:../uvc.c      **** {
3281:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
3282:../uvc.c      **** 
3283:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3284:../uvc.c      ****     {
3285:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
3286:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
3287:../uvc.c      ****     }
3288:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
3289:../uvc.c      ****     {
3290:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
3291:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
3292:../uvc.c      ****     }
3293:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3294:../uvc.c      ****     {
3295:../uvc.c      ****         /* Error Handling */
3296:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
3297:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3298:../uvc.c      ****     }
3299:../uvc.c      **** 
3300:../uvc.c      ****     /* Start the state machine from the designated start state. */
3301:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3302:../uvc.c      ****     {
3303:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
3304:../uvc.c      ****     }
3305:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
3306:../uvc.c      ****     {
3307:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
3308:../uvc.c      ****     }
3309:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3310:../uvc.c      ****     {
3311:../uvc.c      ****         /* Error Handling */
3312:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
3313:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3314:../uvc.c      ****     }
3315:../uvc.c      **** }
3316:../uvc.c      **** 
3317:../uvc.c      **** /*
3318:../uvc.c      ****  * Entry function for the UVC Application Thread
3319:../uvc.c      ****  */
3320:../uvc.c      **** 
3321:../uvc.c      **** uint32_t posTick;
3322:../uvc.c      **** CyU3PTimer I2CCmdTimer;
3323:../uvc.c      **** 
3324:../uvc.c      **** void  I2CCmdCb(uint32_t input){
  22              		.loc 1 3324 0
  23              		.cfi_startproc
  24              		@ args = 0, pretend = 0, frame = 0
  25              		@ frame_needed = 0, uses_anonymous_args = 0
  26              	.LVL0:
3325:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  27              		.loc 1 3325 0
  28 0000 28209FE5 		ldr	r2, .L2
3324:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  29              		.loc 1 3324 0
  30 0004 08402DE9 		stmfd	sp!, {r3, lr}
  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 3, -8
  34              		.cfi_offset 14, -4
  35              		.loc 1 3325 0
  36 0008 002092E5 		ldr	r2, [r2]
3324:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  37              		.loc 1 3324 0
  38 000c 0030A0E1 		mov	r3, r0
  39              		.loc 1 3325 0
  40 0010 1C109FE5 		ldr	r1, .L2+4
  41 0014 0400A0E3 		mov	r0, #4
  42              	.LVL1:
  43 0018 FEFFFFEB 		bl	CyU3PDebugPrint
  44              	.LVL2:
3326:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  45              		.loc 1 3326 0
  46 001c 14009FE5 		ldr	r0, .L2+8
  47 0020 2010A0E3 		mov	r1, #32
  48 0024 0020A0E3 		mov	r2, #0
3327:../uvc.c      **** }
  49              		.loc 1 3327 0
  50 0028 0840BDE8 		ldmfd	sp!, {r3, lr}
3326:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  51              		.loc 1 3326 0
  52 002c FEFFFFEA 		b	_txe_event_flags_set
  53              	.LVL3:
  54              	.L3:
  55              		.align	2
  56              	.L2:
  57 0030 00000000 		.word	posTick
  58 0034 00000000 		.word	.LC0
  59 0038 00000000 		.word	.LANCHOR0
  60              		.cfi_endproc
  61              	.LFE18:
  63              		.align	2
  65              	UVCHandleVideoStreamingRqts:
  66              	.LFB24:
3328:../uvc.c      **** 
3329:../uvc.c      **** 
3330:../uvc.c      **** void
3331:../uvc.c      **** UVCAppThread_Entry (
3332:../uvc.c      ****         uint32_t input)
3333:../uvc.c      **** {
3334:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
3335:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
3336:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
3337:../uvc.c      ****     uint8_t i = 0;
3338:../uvc.c      ****     uint32_t flag;
3339:../uvc.c      ****     uint32_t prinflag = 0;
3340:../uvc.c      **** static uint8_t IMcount = 0;
3341:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
3342:../uvc.c      ****     uint32_t frameCnt = 0;
3343:../uvc.c      **** #endif
3344:../uvc.c      ****     /* Initialize the Uart Debug Module */
3345:../uvc.c      ****     CyFxUVCApplnDebugInit ();
3346:../uvc.c      **** 
3347:../uvc.c      ****     /* Initialize the I2C interface */
3348:../uvc.c      **** 	while (i++ < 6){
3349:../uvc.c      **** 		CyU3PThreadSleep(500);
3350:../uvc.c      **** 	}
3351:../uvc.c      **** 
3352:../uvc.c      ****     CyFxUVCApplnI2CInit ();
3353:../uvc.c      **** 
3354:../uvc.c      ****     /* Initialize the UVC Application */
3355:../uvc.c      ****     CyFxUVCApplnInit ();
3356:../uvc.c      ****     /*
3357:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
3358:../uvc.c      **** 
3359:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
3360:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
3361:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
3362:../uvc.c      **** 
3363:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
3364:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
3365:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
3366:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
3367:../uvc.c      **** 
3368:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
3369:../uvc.c      ****        of handling the abort request.
3370:../uvc.c      ****      */
3371:../uvc.c      **** 
3372:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
3373:../uvc.c      ****     //CyU3PThreadSleep(1000);
3374:../uvc.c      **** 
3375:../uvc.c      ****     for (;;)
3376:../uvc.c      ****     {
3377:../uvc.c      ****         /* Waiting for the Video Stream Event */
3378:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
3379:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3380:../uvc.c      ****         {
3381:../uvc.c      **** #if 0 //test for new firmware no video bring up
3382:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
3383:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
3384:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
3385:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
3386:../uvc.c      ****             {
3387:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
3388:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
3389:../uvc.c      ****                 {
3390:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3391:../uvc.c      **** #ifdef  USB_LOWRES_IMG
3392:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
3393:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
3394:../uvc.c      **** #endif
3395:../uvc.c      **** #endif
3396:../uvc.c      ****                     }
3397:../uvc.c      ****                 else
3398:../uvc.c      ****                 {
3399:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
3400:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3401:../uvc.c      **** #ifdef USB_LOWRES_IMG
3402:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
3403:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3404:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
3405:../uvc.c      **** #endif
3406:../uvc.c      **** #endif
3407:../uvc.c      ****                 }
3408:../uvc.c      **** 
3409:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
3410:../uvc.c      ****                 prodCount++;
3411:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
3412:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
3413:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
3414:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3415:../uvc.c      ****                 {
3416:../uvc.c      ****                     prodCount--;
3417:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
3418:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
3419:../uvc.c      ****                 }
3420:../uvc.c      ****             }
3421:../uvc.c      **** #endif
3422:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
3423:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
3424:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
3425:../uvc.c      ****             {
3426:../uvc.c      ****             	if(0&&(prinflag == 0)){
3427:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
3428:../uvc.c      ****             		prinflag = 1;
3429:../uvc.c      ****             	}
3430:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
3431:../uvc.c      ****             	fb=0;
3432:../uvc.c      ****             	pb=0;
3433:../uvc.c      ****             	pbc=0;
3434:../uvc.c      ****                 prodCount = 0;
3435:../uvc.c      ****                 consCount = 0;
3436:../uvc.c      ****                 hitFV     = CyFalse;
3437:../uvc.c      **** 
3438:../uvc.c      **** #ifdef BACKFLOW_DETECT
3439:../uvc.c      ****                 back_flow_detected = 0;
3440:../uvc.c      **** #endif
3441:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
3442:../uvc.c      ****                 frameCnt++;
3443:../uvc.c      **** #endif
3444:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
3445:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
3446:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
3447:../uvc.c      ****                 //}
3448:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
3449:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3450:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
3451:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
3452:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3453:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
3454:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
3455:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
3456:../uvc.c      ****                      	//CyU3PThreadSleep(100);
3457:../uvc.c      ****                 		stiflag = 0xFF;
3458:../uvc.c      ****                 		IMcount = 0;
3459:../uvc.c      ****                 	}
3460:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
3461:../uvc.c      **** 
3462:../uvc.c      ****                  		if(IMcount++ >= 0x3){
3463:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
3464:../uvc.c      ****                 		stiflag = 0x0F;
3465:../uvc.c      ****                 		IMcount = 0;
3466:../uvc.c      ****                 		}
3467:../uvc.c      ****                  		/*if(IMcount > 0x4){
3468:../uvc.c      ****                 			stiflag = 0x0F;
3469:../uvc.c      ****                 			IMcount = 0;
3470:../uvc.c      ****                 		}*/
3471:../uvc.c      **** 
3472:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
3473:../uvc.c      ****                     //CyU3PThreadSleep(400);
3474:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3475:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3476:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
3477:../uvc.c      **** 
3478:../uvc.c      ****                 	if(IMcount++ >= 0x3)
3479:../uvc.c      ****                 	{
3480:../uvc.c      ****                     switch (setRes)
3481:../uvc.c      ****                      {
3482:../uvc.c      ****                  	case 1: //1944
3483:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
3484:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3485:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
3486:../uvc.c      ****                  		break;
3487:../uvc.c      ****                  	case 2: //1080
3488:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
3489:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3490:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
3491:../uvc.c      ****                  		break;
3492:../uvc.c      ****                  	case 3: //720
3493:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
3494:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3495:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
3496:../uvc.c      ****                  		break;
3497:../uvc.c      ****                  	case 4: //VGA
3498:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
3499:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3500:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
3501:../uvc.c      ****                  		break;
3502:../uvc.c      ****                  	default:
3503:../uvc.c      ****                  		break;
3504:../uvc.c      ****                      }
3505:../uvc.c      ****                     IMcount = 0;
3506:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3507:../uvc.c      ****                 	stiflag = 0x0;
3508:../uvc.c      ****                 	}
3509:../uvc.c      ****                 }
3510:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
3511:../uvc.c      ****                 /* Reset the DMA channel. */
3512:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3513:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3514:../uvc.c      ****                 {
3515:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
3516:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3517:../uvc.c      ****                 }
3518:../uvc.c      **** 
3519:../uvc.c      ****                 /* Start Channel Immediately */
3520:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3521:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3522:../uvc.c      ****                 {
3523:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
3524:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3525:../uvc.c      ****                 }
3526:../uvc.c      **** 
3527:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
3528:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
3529:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3530:../uvc.c      ****                 }
3531:../uvc.c      ****         }
3532:../uvc.c      ****         else
3533:../uvc.c      ****         {
3534:../uvc.c      ****             /* If we have a stream abort request pending. */
3535:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
3536:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3537:../uvc.c      ****             {
3538:../uvc.c      ****                 hitFV     = CyFalse;
3539:../uvc.c      ****                 prodCount = 0;
3540:../uvc.c      ****                 consCount = 0;
3541:../uvc.c      ****                 if(0&&(prinflag == 0)){
3542:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
3543:../uvc.c      ****                 	prinflag = 1;
3544:../uvc.c      ****                 }
3545:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
3546:../uvc.c      ****                 fb=0;
3547:../uvc.c      ****                 pb=0;
3548:../uvc.c      ****                 pbc=0;
3549:../uvc.c      **** 
3550:../uvc.c      ****                 if (!clearFeatureRqtReceived)
3551:../uvc.c      ****                 {
3552:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3553:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
3554:../uvc.c      ****                     {
3555:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
3556:../uvc.c      ****                     }
3557:../uvc.c      **** 
3558:../uvc.c      ****                     /* Flush the Endpoint memory */
3559:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
3560:../uvc.c      ****                 }
3561:../uvc.c      **** 
3562:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
3563:../uvc.c      ****             }
3564:../uvc.c      ****             else
3565:../uvc.c      ****             {
3566:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
3567:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
3568:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
3569:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
3570:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
3571:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3572:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3573:../uvc.c      ****                 {
3574:../uvc.c      ****                     /* Error handling */
3575:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
3576:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3577:../uvc.c      ****                 }
3578:../uvc.c      **** 
3579:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
3580:../uvc.c      ****                 if (gpif_initialized == CyFalse)
3581:../uvc.c      ****                 {
3582:../uvc.c      **** #if 0
3583:../uvc.c      ****                 	//for start up of the AF Lens
3584:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3585:../uvc.c      ****                     CyU3PThreadSleep(500);
3586:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3587:../uvc.c      ****                     CyU3PThreadSleep(500);
3588:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
3589:../uvc.c      ****                    	CyU3PThreadSleep(300);
3590:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3591:../uvc.c      ****                     CyU3PThreadSleep(500);
3592:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3593:../uvc.c      ****                     CyU3PThreadSleep(500);
3594:../uvc.c      **** #endif
3595:../uvc.c      **** #if 0
3596:../uvc.c      ****                     switch (setRes)
3597:../uvc.c      ****                     {
3598:../uvc.c      ****                     	case 1: //1944
3599:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x64, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3600:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3601:../uvc.c      ****                     		break;
3602:../uvc.c      ****                     	case 2: //1080
3603:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x54, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3604:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3605:../uvc.c      ****                     		break;
3606:../uvc.c      ****                     	case 3: //720
3607:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x45, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3608:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3609:../uvc.c      ****                     		break;
3610:../uvc.c      ****                     	default:
3611:../uvc.c      ****                     		break;
3612:../uvc.c      ****                     }
3613:../uvc.c      **** #endif
3614:../uvc.c      ****                     CyFxUvcAppGpifInit ();
3615:../uvc.c      **** 
3616:../uvc.c      ****                     gpif_initialized = CyTrue;
3617:../uvc.c      ****                     CyU3PThreadSleep(200);
3618:../uvc.c      ****                     
3619:../uvc.c      ****                 }
3620:../uvc.c      ****                 else
3621:../uvc.c      ****                 {
3622:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
3623:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
3624:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3625:../uvc.c      ****                 }
3626:../uvc.c      ****             }
3627:../uvc.c      ****         }
3628:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
3629:../uvc.c      **** 
3630:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
3631:../uvc.c      ****         CyU3PThreadRelinquish ();
3632:../uvc.c      ****     }
3633:../uvc.c      **** }
3634:../uvc.c      **** 
3635:../uvc.c      **** /*
3636:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
3637:../uvc.c      ****  */
3638:../uvc.c      **** 
3639:../uvc.c      **** static void
3640:../uvc.c      **** UVCHandleProcessingUnitRqts (
3641:../uvc.c      ****         void)
3642:../uvc.c      **** {
3643:../uvc.c      ****     uint8_t CtrlAdd;
3644:../uvc.c      **** #ifdef DbgInfo
3645:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3646:../uvc.c      **** #endif
3647:../uvc.c      ****     switch (wValue)
3648:../uvc.c      ****     {
3649:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
3650:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
3651:../uvc.c      ****     		ControlHandle(BLCCtlID0);
3652:../uvc.c      ****     		break;
3653:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
3654:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
3655:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
3656:../uvc.c      ****     		break;
3657:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
3658:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
3659:../uvc.c      **** 			ControlHandle(ConsCtlID2);
3660:../uvc.c      **** 			break;
3661:../uvc.c      **** 
3662:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
3663:../uvc.c      **** 
3664:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
3665:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
3666:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
3667:../uvc.c      ****       		break;
3668:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
3669:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
3670:../uvc.c      ****      		ControlHandle(HueCtlID5);
3671:../uvc.c      ****      		break;
3672:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
3673:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
3674:../uvc.c      ****           		ControlHandle(SaturCtlID6);
3675:../uvc.c      ****           		break;
3676:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
3677:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
3678:../uvc.c      ****           		ControlHandle(ShapCtlID7);
3679:../uvc.c      ****           		break;
3680:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
3681:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
3682:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
3683:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
3684:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
3685:../uvc.c      ****     		break;
3686:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
3687:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
3688:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
3689:../uvc.c      ****     		break;
3690:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
3691:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
3692:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
3693:../uvc.c      ****     		break;
3694:../uvc.c      **** 
3695:../uvc.c      ****         default:
3696:../uvc.c      ****             /*
3697:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3698:../uvc.c      ****              * other controls.
3699:../uvc.c      ****              */
3700:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3701:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3702:../uvc.c      ****             break;
3703:../uvc.c      ****     }
3704:../uvc.c      **** }
3705:../uvc.c      **** 
3706:../uvc.c      **** /*
3707:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
3708:../uvc.c      ****  */
3709:../uvc.c      **** static void
3710:../uvc.c      **** UVCHandleCameraTerminalRqts (
3711:../uvc.c      ****         void)
3712:../uvc.c      **** {
3713:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3714:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3715:../uvc.c      ****     uint16_t readCount;
3716:../uvc.c      ****     uint16_t zoomVal;
3717:../uvc.c      ****     int32_t  panVal, tiltVal;
3718:../uvc.c      ****     CyBool_t sendData = CyFalse;
3719:../uvc.c      **** #endif
3720:../uvc.c      ****     uint8_t CtrlAdd;
3721:../uvc.c      **** 
3722:../uvc.c      ****     switch (wValue)
3723:../uvc.c      ****     {
3724:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
3725:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
3726:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
3727:../uvc.c      ****     		break;
3728:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
3729:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
3730:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
3731:../uvc.c      ****     		break;
3732:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
3733:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
3734:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
3735:../uvc.c      **** 			break;
3736:../uvc.c      **** 
3737:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
3738:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
3739:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
3740:../uvc.c      **** 			break;
3741:../uvc.c      **** 
3742:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
3743:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
3744:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
3745:../uvc.c      ****       		break;
3746:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
3747:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
3748:../uvc.c      ****      		CTControlHandle(FocACtlID5);
3749:../uvc.c      ****      		break;
3750:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
3751:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
3752:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
3753:../uvc.c      ****           		break;
3754:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
3755:../uvc.c      ****           		break;
3756:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
3757:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
3758:../uvc.c      ****      		CTControlHandle(IriACtlID7);
3759:../uvc.c      ****      		break;
3760:../uvc.c      **** 
3761:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
3762:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
3763:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
3764:../uvc.c      ****     		break;
3765:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3766:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
3767:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
3768:../uvc.c      ****     		break;
3769:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
3770:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
3771:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
3772:../uvc.c      ****     		break;
3773:../uvc.c      **** 
3774:../uvc.c      ****         default:
3775:../uvc.c      ****             /*
3776:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3777:../uvc.c      ****              * other controls.
3778:../uvc.c      ****              */
3779:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3780:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3781:../uvc.c      ****             break;
3782:../uvc.c      ****     }
3783:../uvc.c      **** 
3784:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3785:../uvc.c      ****     switch (wValue)
3786:../uvc.c      ****     {
3787:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3788:../uvc.c      ****             switch (bRequest)
3789:../uvc.c      ****             {
3790:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3791:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
3792:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3793:../uvc.c      ****                     break;
3794:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
3795:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
3796:../uvc.c      ****                     sendData = CyTrue;
3797:../uvc.c      ****                     break;
3798:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
3799:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
3800:../uvc.c      ****                     sendData = CyTrue;
3801:../uvc.c      ****                     break;
3802:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
3803:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
3804:../uvc.c      ****                     sendData = CyTrue;
3805:../uvc.c      ****                     break;
3806:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
3807:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
3808:../uvc.c      ****                     sendData = CyTrue;
3809:../uvc.c      ****                     break;
3810:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
3811:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
3812:../uvc.c      ****                     sendData = CyTrue;
3813:../uvc.c      ****                     break;
3814:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3815:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3816:../uvc.c      ****                             glEp0Buffer, &readCount);
3817:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3818:../uvc.c      ****                     {
3819:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
3820:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
3821:../uvc.c      ****                     }
3822:../uvc.c      ****                     break;
3823:../uvc.c      ****                 default:
3824:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3825:../uvc.c      ****                     break;
3826:../uvc.c      ****             }
3827:../uvc.c      **** 
3828:../uvc.c      ****             if (sendData)
3829:../uvc.c      ****             {
3830:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
3831:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
3832:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
3833:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3834:../uvc.c      ****             }
3835:../uvc.c      ****             break;
3836:../uvc.c      **** 
3837:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
3838:../uvc.c      ****             switch (bRequest)
3839:../uvc.c      ****             {
3840:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3841:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
3842:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3843:../uvc.c      ****                     break;
3844:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3845:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
3846:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
3847:../uvc.c      ****                     sendData = CyTrue;
3848:../uvc.c      ****                     break;
3849:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3850:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
3851:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
3852:../uvc.c      ****                     sendData = CyTrue;
3853:../uvc.c      ****                     break;
3854:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3855:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
3856:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
3857:../uvc.c      ****                     sendData = CyTrue;
3858:../uvc.c      ****                     break;
3859:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
3860:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
3861:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
3862:../uvc.c      ****                     sendData = CyTrue;
3863:../uvc.c      ****                     break;
3864:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
3865:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
3866:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
3867:../uvc.c      ****                     sendData = CyTrue;
3868:../uvc.c      ****                     break;
3869:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3870:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3871:../uvc.c      ****                             glEp0Buffer, &readCount);
3872:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3873:../uvc.c      ****                     {
3874:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
3875:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
3876:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
3877:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
3878:../uvc.c      **** 
3879:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
3880:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
3881:../uvc.c      ****                     }
3882:../uvc.c      ****                     break;
3883:../uvc.c      ****                 default:
3884:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3885:../uvc.c      ****                     break;
3886:../uvc.c      ****             }
3887:../uvc.c      **** 
3888:../uvc.c      ****             if (sendData)
3889:../uvc.c      ****             {
3890:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
3891:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
3892:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
3893:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
3894:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
3895:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
3896:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
3897:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
3898:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
3899:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3900:../uvc.c      ****             }
3901:../uvc.c      ****             break;
3902:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
3903:../uvc.c      ****         default:
3904:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
3905:../uvc.c      ****             break;
3906:../uvc.c      ****     }
3907:../uvc.c      **** #endif
3908:../uvc.c      **** }
3909:../uvc.c      **** 
3910:../uvc.c      **** /*
3911:../uvc.c      ****  * Handler for UVC Interface control requests.
3912:../uvc.c      ****  */
3913:../uvc.c      **** static void
3914:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
3915:../uvc.c      ****         void)
3916:../uvc.c      **** {
3917:../uvc.c      **** 
3918:../uvc.c      ****     switch (wValue)
3919:../uvc.c      ****     {
3920:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
3921:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3922:../uvc.c      ****     		break;
3923:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
3924:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
3925:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
3926:../uvc.c      ****     		break;
3927:../uvc.c      ****     	default:
3928:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
3929:../uvc.c      ****      		break;
3930:../uvc.c      ****     }
3931:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
3932:../uvc.c      **** 
3933:../uvc.c      **** }
3934:../uvc.c      **** 
3935:../uvc.c      **** /*
3936:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
3937:../uvc.c      ****  */
3938:../uvc.c      **** static void
3939:../uvc.c      **** UVCHandleExtensionUnitRqts (
3940:../uvc.c      ****         void)
3941:../uvc.c      **** {
3942:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
3943:../uvc.c      **** 
3944:../uvc.c      **** #ifdef DbgInfo
3945:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3946:../uvc.c      **** #endif
3947:../uvc.c      ****     switch (wValue)
3948:../uvc.c      ****     {
3949:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
3950:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
3951:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
3952:../uvc.c      ****     		break;
3953:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
3954:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
3955:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
3956:../uvc.c      ****     		break;
3957:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
3958:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
3959:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
3960:../uvc.c      ****      		break;
3961:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
3962:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
3963:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
3964:../uvc.c      ****     		break;
3965:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
3966:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
3967:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
3968:../uvc.c      ****     		break;
3969:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
3970:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
3971:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
3972:../uvc.c      ****      		break;
3973:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
3974:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
3975:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
3976:../uvc.c      ****     		break;
3977:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
3978:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
3979:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
3980:../uvc.c      ****     		break;
3981:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
3982:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
3983:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
3984:../uvc.c      ****      		break;
3985:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
3986:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
3987:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
3988:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
3989:../uvc.c      ****     		}else/* no support for 1080p camera */
3990:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
3991:../uvc.c      ****     		break;
3992:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
3993:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
3994:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
3995:../uvc.c      ****     		break;
3996:../uvc.c      **** 		case CY_FX_EXT_CONTROL_12: //AEx shutter level CONTROL12
3997:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCtlShutlevCtlID11][0];
3998:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
3999:../uvc.c      ****     		break;
4000:../uvc.c      **** 
4001:../uvc.c      ****     		//ExtCtlShutlevCtlID11
4002:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
4003:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
4004:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
4005:../uvc.c      ****     		break;
4006:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
4007:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
4008:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
4009:../uvc.c      ****     		//break;
4010:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
4011:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
4012:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
4013:../uvc.c      ****     		break;
4014:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
4015:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
4016:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
4017:../uvc.c      ****     		break;
4018:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
4019:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET][0];
4020:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
4021:../uvc.c      ****     		break;
4022:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
4023:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET][0];
4024:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
4025:../uvc.c      ****     		break;
4026:../uvc.c      **** 		case CY_FX_EXT_CONTROL_19BLC_GRID:   //BLD gain CONTROL19
4027:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET][0];
4028:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
4029:../uvc.c      ****     		break;
4030:../uvc.c      **** 		case CY_FX_EXT_CONTROL_20EXP_HYSTER: //exposure hysteresis CONTROL20
4031:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1ExHysterCtlID7-EXUAOFFSET][0];
4032:../uvc.c      ****       		ControlHandle(Ext1ExHysterCtlID7);
4033:../uvc.c      ****     		break;
4034:../uvc.c      **** 		case CY_FX_EXT_CONTROL_21EXP_CTRLSPD: //exposure control speed CONTROL21
4035:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1ExCtrlSpeedCtlID8-EXUAOFFSET][0];
4036:../uvc.c      ****       		ControlHandle(Ext1ExCtrlSpeedCtlID8);
4037:../uvc.c      ****     		break;
4038:../uvc.c      **** 		case CY_FX_EXT_CONTROL_22ENHANCE_MODE: //edge enhancement mode CONTROL22
4039:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceModeCtlID9-EXUAOFFSET][0];
4040:../uvc.c      ****       		ControlHandle(Ext1EnhanceModeCtlID9);
4041:../uvc.c      ****     		break;
4042:../uvc.c      **** 		case CY_FX_EXT_CONTROL_23ENHANCE_GAIN: //edge enhancement gain CONTROL23
4043:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceGainCtlID10-EXUAOFFSET][0];
4044:../uvc.c      ****       		ControlHandle(Ext1EnhanceGainCtlID10);
4045:../uvc.c      ****     		break;
4046:../uvc.c      **** 		case CY_FX_EXT_CONTROL_24ENHANCE_STED: //edge enhancement start/end CONTROL24
4047:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceStarEndCtlID11-EXUAOFFSET][0];
4048:../uvc.c      ****       		ControlHandle(Ext1EnhanceStarEndCtlID11);
4049:../uvc.c      ****     		break;
4050:../uvc.c      **** 		case CY_FX_EXT_CONTROL_262DNR_STED: //2D noise reduction start/end CONTROL26
4051:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext12DNRGainStarEndCtlID13-EXUAOFFSET][0];
4052:../uvc.c      ****       		ControlHandle(Ext12DNRGainStarEndCtlID13);
4053:../uvc.c      ****     		break;
4054:../uvc.c      **** 		case CY_FX_EXT_CONTROL_27GAMMA_MODE: //gamma correction CONTROL27
4055:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1GammaCorCtlID14-EXUAOFFSET][0];
4056:../uvc.c      ****       		ControlHandle(Ext1GammaCorCtlID14);
4057:../uvc.c      ****     		break;
4058:../uvc.c      **** 
4059:../uvc.c      ****    	default:
4060:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
4061:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
4062:../uvc.c      ****     		break;
4063:../uvc.c      ****     }
4064:../uvc.c      **** 
4065:../uvc.c      **** }
4066:../uvc.c      **** 
4067:../uvc.c      **** /*
4068:../uvc.c      ****  * Handler for the video streaming control requests.
4069:../uvc.c      ****  */
4070:../uvc.c      **** static void
4071:../uvc.c      **** UVCHandleVideoStreamingRqts (
4072:../uvc.c      ****         void)
4073:../uvc.c      **** {
  67              		.loc 1 4073 0
  68              		.cfi_startproc
  69              		@ args = 0, pretend = 0, frame = 8
  70              		@ frame_needed = 0, uses_anonymous_args = 0
  71              	.LVL4:
4074:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
4075:../uvc.c      ****     uint16_t readCount;
4076:../uvc.c      **** 
4077:../uvc.c      ****     switch (wValue)
  72              		.loc 1 4077 0
  73 003c A8369FE5 		ldr	r3, .L133
4073:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
  74              		.loc 1 4073 0
  75 0040 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
  76              	.LCFI1:
  77              		.cfi_def_cfa_offset 16
  78              		.cfi_offset 4, -16
  79              		.cfi_offset 5, -12
  80              		.cfi_offset 6, -8
  81              		.cfi_offset 14, -4
  82              		.loc 1 4077 0
  83 0044 B030D3E1 		ldrh	r3, [r3]
4073:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
  84              		.loc 1 4073 0
  85 0048 10D04DE2 		sub	sp, sp, #16
  86              	.LCFI2:
  87              		.cfi_def_cfa_offset 32
  88              		.loc 1 4077 0
  89 004c 030C53E3 		cmp	r3, #768
  90 0050 5200000A 		beq	.L6
  91 0054 1300008A 		bhi	.L7
  92 0058 010C53E3 		cmp	r3, #256
  93 005c 2400000A 		beq	.L8
  94 0060 020C53E3 		cmp	r3, #512
  95 0064 1C00001A 		bne	.L5
4078:../uvc.c      ****     {
4079:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
4080:../uvc.c      ****             switch (bRequest)
4081:../uvc.c      ****             {
4082:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4083:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
4084:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4085:../uvc.c      ****                     break;
4086:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
4087:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4088:../uvc.c      ****                     glEp0Buffer[1] = 0;
4089:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4090:../uvc.c      ****                     break;
4091:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
4092:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
4093:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
4094:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
4095:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
4096:../uvc.c      ****                     {
4097:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
4098:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
4099:../uvc.c      **** 
4100:../uvc.c      ****                     }
4101:../uvc.c      ****                     else
4102:../uvc.c      ****                     {
4103:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
4104:../uvc.c      ****                     }
4105:../uvc.c      ****                     break;
4106:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4107:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4108:../uvc.c      ****                             glCommitCtrl, &readCount);
4109:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4110:../uvc.c      ****                     {
4111:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4112:../uvc.c      ****                         {
4113:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
4114:../uvc.c      ****                                active data structure. */
4115:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
4116:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
4117:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
4118:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
4119:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
4120:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
4121:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
4122:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
4123:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
4124:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
4125:../uvc.c      **** #if 0
4126:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
4127:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
4128:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
4129:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
4130:../uvc.c      **** #endif
4131:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
4132:../uvc.c      ****                        }
4133:../uvc.c      ****                     }
4134:../uvc.c      ****                     break;
4135:../uvc.c      ****                 default:
4136:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4137:../uvc.c      ****                     break;
4138:../uvc.c      ****             }
4139:../uvc.c      ****             break;
4140:../uvc.c      **** 
4141:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
4142:../uvc.c      ****             switch (bRequest)
  96              		.loc 1 4142 0
  97 0068 80369FE5 		ldr	r3, .L133+4
  98 006c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
  99 0070 810053E3 		cmp	r3, #129
 100 0074 9000000A 		beq	.L23
 101 0078 AF00009A 		bls	.L127
 102              	.L53:
4143:../uvc.c      ****             {
4144:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4145:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
4146:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4147:../uvc.c      ****                     break;
4148:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
4149:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4150:../uvc.c      ****                     glEp0Buffer[1] = 0;
4151:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4152:../uvc.c      ****                     break;
4153:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
4154:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
4155:../uvc.c      ****                     {
4156:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
4157:../uvc.c      ****                     }
4158:../uvc.c      ****                     else
4159:../uvc.c      ****                     {
4160:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
4161:../uvc.c      ****                     }
4162:../uvc.c      ****                     break;
4163:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4164:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
4165:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
4166:../uvc.c      ****                        */
4167:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4168:../uvc.c      ****                             glCommitCtrl, &readCount);
4169:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4170:../uvc.c      ****                     {
4171:../uvc.c      ****                         switch (glCommitCtrl[3])
4172:../uvc.c      ****                          {
4173:../uvc.c      ****                          	case 1: //1944
4174:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
4175:../uvc.c      ****                          		CyU3PThreadSleep(500);
4176:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
4177:../uvc.c      ****                          		break;
4178:../uvc.c      ****                          	case 2: //1080
4179:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
4180:../uvc.c      ****                          		CyU3PThreadSleep(500);
4181:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
4182:../uvc.c      ****                          		break;
4183:../uvc.c      ****                          	case 3: //720
4184:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
4185:../uvc.c      ****                          		CyU3PThreadSleep(500);
4186:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
4187:../uvc.c      ****                          		break;
4188:../uvc.c      ****                          	case 4: //VGA
4189:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
4190:../uvc.c      ****                          		CyU3PThreadSleep(500);
4191:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
4192:../uvc.c      ****                          		break;
4193:../uvc.c      ****                          	default:
4194:../uvc.c      ****                          		break;
4195:../uvc.c      ****                          }
4196:../uvc.c      ****                         setRes = glCommitCtrl[3];
4197:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
4198:../uvc.c      **** 
4199:../uvc.c      **** #if 0
4200:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
4201:../uvc.c      ****                         {
4202:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
4203:../uvc.c      ****                         }
4204:../uvc.c      ****                         else
4205:../uvc.c      ****                         {
4206:../uvc.c      ****                             SensorScaling_VGA ();
4207:../uvc.c      ****                         }
4208:../uvc.c      **** #endif
4209:../uvc.c      ****                         /* We can start streaming video now. */
4210:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
4211:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
4212:../uvc.c      ****                         {
4213:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
4214:../uvc.c      ****                         }
4215:../uvc.c      ****                     }
4216:../uvc.c      ****                     break;
4217:../uvc.c      **** 
4218:../uvc.c      ****                 default:
4219:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4220:../uvc.c      ****                     break;
4221:../uvc.c      ****             }
4222:../uvc.c      ****             break;
4223:../uvc.c      **** 
4224:../uvc.c      **** /* still image streaming handler */
4225:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
4226:../uvc.c      ****                 switch (bRequest)
4227:../uvc.c      ****                 {
4228:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4229:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
4230:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4231:../uvc.c      ****                         break;
4232:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4233:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4234:../uvc.c      ****                         glEp0Buffer[1] = 0;
4235:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4236:../uvc.c      ****                         break;
4237:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
4238:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
4239:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
4240:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
4241:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4242:../uvc.c      ****                         {
4243:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4244:../uvc.c      ****                         }
4245:../uvc.c      ****                         else
4246:../uvc.c      ****                         {
4247:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4248:../uvc.c      ****                         }
4249:../uvc.c      ****                         break;
4250:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4251:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4252:../uvc.c      ****                                 glCommitCtrl, &readCount);
4253:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4254:../uvc.c      ****                         {
4255:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
4256:../uvc.c      ****                             {
4257:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
4258:../uvc.c      ****                                    active data structure. */
4259:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
4260:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
4261:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
4262:../uvc.c      ****                             	//glProbeStilCtrl[4] = glCommitCtrl[4];
4263:../uvc.c      ****                             	//glProbeStilCtrl[5] = glCommitCtrl[5];
4264:../uvc.c      ****                             	//glProbeStilCtrl[6] = glCommitCtrl[6];
4265:../uvc.c      ****                             }
4266:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
4267:../uvc.c      ****                         }
4268:../uvc.c      ****                         break;
4269:../uvc.c      ****                     default:
4270:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4271:../uvc.c      ****                         break;
4272:../uvc.c      ****                 }
4273:../uvc.c      ****                 break;
4274:../uvc.c      **** 
4275:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
4276:../uvc.c      ****                 switch (bRequest)
 103              		.loc 1 4276 0
 104 007c 850053E3 		cmp	r3, #133
 105 0080 2500000A 		beq	.L55
 106 0084 860053E3 		cmp	r3, #134
 107 0088 1300001A 		bne	.L5
 108              	.L120:
4277:../uvc.c      ****                 {
4278:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4279:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
4280:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4281:../uvc.c      ****                         break;
4282:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4283:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4284:../uvc.c      ****                         glEp0Buffer[1] = 0;
4285:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4286:../uvc.c      ****                         break;
4287:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
4288:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4289:../uvc.c      ****                         {
4290:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4291:../uvc.c      ****                         }
4292:../uvc.c      ****                         else
4293:../uvc.c      ****                         {
4294:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4295:../uvc.c      ****                         }
4296:../uvc.c      ****                         break;
4297:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4298:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4299:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4300:../uvc.c      ****                            */
4301:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4302:../uvc.c      ****                                 glCommitCtrl, &readCount);
4303:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4304:../uvc.c      ****                         {
4305:../uvc.c      ****     #if 0
4306:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
4307:../uvc.c      ****                             {
4308:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
4309:../uvc.c      ****                             }
4310:../uvc.c      ****                             else
4311:../uvc.c      ****                             {
4312:../uvc.c      ****                                 SensorScaling_VGA ();
4313:../uvc.c      ****                             }
4314:../uvc.c      ****                             /* We can start streaming video now. */
4315:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
4316:../uvc.c      **** 
4317:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4318:../uvc.c      ****                             {
4319:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
4320:../uvc.c      ****                             }
4321:../uvc.c      **** 	#endif
4322:../uvc.c      ****                            switch (glCommitCtrl[1])
4323:../uvc.c      ****                              {
4324:../uvc.c      ****                              	case 4: //1944
4325:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
4326:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4327:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4328:../uvc.c      ****                              		break;
4329:../uvc.c      ****                              	case 3: //1080
4330:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
4331:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4332:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4333:../uvc.c      ****                              		break;
4334:../uvc.c      ****                              	case 2: //720
4335:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
4336:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4337:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4338:../uvc.c      ****                              		break;
4339:../uvc.c      ****                             	case 1: //VGA
4340:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
4341:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4342:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4343:../uvc.c      ****                              		break;
4344:../uvc.c      ****                               	default:
4345:../uvc.c      ****                              		break;
4346:../uvc.c      ****                              }
4347:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
4348:../uvc.c      **** 
4349:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
4350:../uvc.c      **** 
4351:../uvc.c      ****                         }
4352:../uvc.c      ****                         break;
4353:../uvc.c      **** 
4354:../uvc.c      ****                     default:
4355:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4356:../uvc.c      ****                         break;
4357:../uvc.c      ****                 }
4358:../uvc.c      ****                 break;
4359:../uvc.c      **** 
4360:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
4361:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
4362:../uvc.c      ****             	switch (bRequest)
4363:../uvc.c      ****                 {
4364:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4365:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
 109              		.loc 1 4365 0
 110 008c 60169FE5 		ldr	r1, .L133+8
 111 0090 0330A0E3 		mov	r3, #3
 112 0094 2830E1E5 		strb	r3, [r1, #40]!
4366:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 113              		.loc 1 4366 0
 114 0098 0100A0E3 		mov	r0, #1
 115 009c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 116              	.LVL5:
4367:../uvc.c      ****                         break;
4368:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4369:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
4370:../uvc.c      ****                         glEp0Buffer[1] = 0;
4371:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4372:../uvc.c      ****                         break;
4373:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
4374:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4375:../uvc.c      ****                         {
4376:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4377:../uvc.c      ****                         }
4378:../uvc.c      ****                         else
4379:../uvc.c      ****                         {
4380:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4381:../uvc.c      ****                         }
4382:../uvc.c      ****                         break;
4383:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4384:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4385:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4386:../uvc.c      ****                            */
4387:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4388:../uvc.c      ****                                 glCommitCtrl, &readCount);
4389:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4390:../uvc.c      ****                         {
4391:../uvc.c      ****     #if 1
4392:../uvc.c      ****                             /* We can start still streaming video now. */
4393:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
4394:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4395:../uvc.c      ****                             {
4396:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
4397:../uvc.c      ****                             }
4398:../uvc.c      ****     #endif
4399:../uvc.c      ****                             else{
4400:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
4401:../uvc.c      ****                             //stillcont = 0;
4402:../uvc.c      ****                             }
4403:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
4404:../uvc.c      ****                         }else{
4405:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
4406:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
4407:../uvc.c      ****                         }
4408:../uvc.c      ****                         break;
4409:../uvc.c      **** 
4410:../uvc.c      ****                     default:
4411:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4412:../uvc.c      ****                         break;
4413:../uvc.c      ****                 }
4414:../uvc.c      ****                 break;
4415:../uvc.c      **** 
4416:../uvc.c      ****         default:
4417:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4418:../uvc.c      ****             break;
4419:../uvc.c      ****     }
4420:../uvc.c      **** }
 117              		.loc 1 4420 0
 118 00a0 10D08DE2 		add	sp, sp, #16
 119              		@ sp needed
 120 00a4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 121              	.L7:
4077:../uvc.c      ****     {
 122              		.loc 1 4077 0
 123 00a8 010B53E3 		cmp	r3, #1024
 124 00ac 2400000A 		beq	.L10
 125 00b0 050C53E3 		cmp	r3, #1280
 126 00b4 0800001A 		bne	.L5
4362:../uvc.c      ****                 {
 127              		.loc 1 4362 0
 128 00b8 30369FE5 		ldr	r3, .L133+4
 129 00bc 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
 130 00c0 810055E3 		cmp	r5, #129
 131 00c4 7C00000A 		beq	.L23
 132 00c8 8300009A 		bls	.L128
 133 00cc 850055E3 		cmp	r5, #133
 134 00d0 6601000A 		beq	.L76
 135 00d4 860055E3 		cmp	r5, #134
 136 00d8 EBFFFF0A 		beq	.L120
 137              	.L5:
4417:../uvc.c      ****             break;
 138              		.loc 1 4417 0
 139 00dc 0000A0E3 		mov	r0, #0
 140 00e0 0020A0E1 		mov	r2, r0
 141 00e4 0110A0E3 		mov	r1, #1
 142 00e8 FEFFFFEB 		bl	CyU3PUsbStall
 143              	.LVL6:
 144              	.L4:
 145              		.loc 1 4420 0
 146 00ec 10D08DE2 		add	sp, sp, #16
 147              		@ sp needed
 148 00f0 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 149              	.LVL7:
 150              	.L8:
4080:../uvc.c      ****             {
 151              		.loc 1 4080 0
 152 00f4 F4459FE5 		ldr	r4, .L133+4
 153 00f8 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 154 00fc 830053E3 		cmp	r3, #131
 155 0100 5100009A 		bls	.L129
 156 0104 860053E3 		cmp	r3, #134
 157 0108 DFFFFF0A 		beq	.L120
 158 010c 870053E3 		cmp	r3, #135
 159 0110 5901000A 		beq	.L14
 160              	.L125:
4226:../uvc.c      ****                 {
 161              		.loc 1 4226 0
 162 0114 850053E3 		cmp	r3, #133
 163 0118 EFFFFF1A 		bne	.L5
 164              	.L55:
4283:../uvc.c      ****                         glEp0Buffer[1] = 0;
 165              		.loc 1 4283 0
 166 011c D0359FE5 		ldr	r3, .L133+8
 167 0120 1AC0A0E3 		mov	ip, #26
 168              	.L121:
4370:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 169              		.loc 1 4370 0
 170 0124 0020A0E3 		mov	r2, #0
4371:../uvc.c      ****                         break;
 171              		.loc 1 4371 0
 172 0128 281083E2 		add	r1, r3, #40
 173 012c 0200A0E3 		mov	r0, #2
4369:../uvc.c      ****                         glEp0Buffer[1] = 0;
 174              		.loc 1 4369 0
 175 0130 28C0C3E5 		strb	ip, [r3, #40]
4370:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 176              		.loc 1 4370 0
 177 0134 2920C3E5 		strb	r2, [r3, #41]
4371:../uvc.c      ****                         break;
 178              		.loc 1 4371 0
 179 0138 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 180              	.LVL8:
 181              		.loc 1 4420 0
 182 013c 10D08DE2 		add	sp, sp, #16
 183              		@ sp needed
 184 0140 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 185              	.L10:
4276:../uvc.c      ****                 {
 186              		.loc 1 4276 0
 187 0144 A4359FE5 		ldr	r3, .L133+4
 188 0148 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 189 014c 810053E3 		cmp	r3, #129
 190 0150 1A00000A 		beq	.L44
 191 0154 C8FFFF8A 		bhi	.L53
 192 0158 010053E3 		cmp	r3, #1
 193 015c DEFFFF1A 		bne	.L5
4301:../uvc.c      ****                                 glCommitCtrl, &readCount);
 194              		.loc 1 4301 0
 195 0160 8C459FE5 		ldr	r4, .L133+8
 196 0164 2000A0E3 		mov	r0, #32
 197 0168 4C1084E2 		add	r1, r4, #76
 198 016c 08208DE2 		add	r2, sp, #8
 199 0170 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 200              	.LVL9:
4303:../uvc.c      ****                         {
 201              		.loc 1 4303 0
 202 0174 000050E3 		cmp	r0, #0
 203 0178 DBFFFF1A 		bne	.L4
4322:../uvc.c      ****                              {
 204              		.loc 1 4322 0
 205 017c 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
 206 0180 01304CE2 		sub	r3, ip, #1
 207 0184 030053E3 		cmp	r3, #3
 208 0188 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 209 018c B80000EA 		b	.L58
 210              	.L60:
 211 0190 F0040000 		.word	.L59
 212 0194 94040000 		.word	.L61
 213 0198 30040000 		.word	.L62
 214 019c 28060000 		.word	.L63
 215              	.LVL10:
 216              	.L6:
4226:../uvc.c      ****                 {
 217              		.loc 1 4226 0
 218 01a0 48359FE5 		ldr	r3, .L133+4
 219 01a4 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 220 01a8 830053E3 		cmp	r3, #131
 221 01ac 0B00009A 		bls	.L130
 222 01b0 860053E3 		cmp	r3, #134
 223 01b4 B4FFFF0A 		beq	.L120
 224 01b8 870053E3 		cmp	r3, #135
 225 01bc D4FFFF1A 		bne	.L125
 226              	.L44:
4241:../uvc.c      ****                         {
 227              		.loc 1 4241 0
 228 01c0 2C359FE5 		ldr	r3, .L133+8
4243:../uvc.c      ****                         }
 229              		.loc 1 4243 0
 230 01c4 0B00A0E3 		mov	r0, #11
4241:../uvc.c      ****                         {
 231              		.loc 1 4241 0
 232 01c8 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 233 01cc 030053E3 		cmp	r3, #3
4243:../uvc.c      ****                         }
 234              		.loc 1 4243 0
 235 01d0 20159F05 		ldreq	r1, .L133+12
4247:../uvc.c      ****                         }
 236              		.loc 1 4247 0
 237 01d4 20159F15 		ldrne	r1, .L133+16
 238 01d8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 239              	.LVL11:
 240 01dc C2FFFFEA 		b	.L4
 241              	.L130:
4226:../uvc.c      ****                 {
 242              		.loc 1 4226 0
 243 01e0 810053E3 		cmp	r3, #129
 244 01e4 F5FFFF2A 		bcs	.L44
 245 01e8 010053E3 		cmp	r3, #1
 246 01ec BAFFFF1A 		bne	.L5
4251:../uvc.c      ****                                 glCommitCtrl, &readCount);
 247              		.loc 1 4251 0
 248 01f0 FC449FE5 		ldr	r4, .L133+8
 249 01f4 2000A0E3 		mov	r0, #32
 250 01f8 4C1084E2 		add	r1, r4, #76
 251 01fc 08208DE2 		add	r2, sp, #8
 252 0200 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 253              	.LVL12:
4253:../uvc.c      ****                         {
 254              		.loc 1 4253 0
 255 0204 000050E3 		cmp	r0, #0
 256 0208 B7FFFF1A 		bne	.L4
4255:../uvc.c      ****                             {
 257              		.loc 1 4255 0
 258 020c 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 259 0210 030053E3 		cmp	r3, #3
4259:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 260              		.loc 1 4259 0
 261 0214 4D20D405 		ldreqb	r2, [r4, #77]	@ zero_extendqisi2
 262 0218 E0349F05 		ldreq	r3, .L133+20
4260:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
 263              		.loc 1 4260 0
 264 021c 4E00D405 		ldreqb	r0, [r4, #78]	@ zero_extendqisi2
 265              	.LVL13:
 266 0220 4D10D415 		ldrneb	r1, [r4, #77]	@ zero_extendqisi2
 267 0224 0210A001 		moveq	r1, r2
4259:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 268              		.loc 1 4259 0
 269 0228 5520C305 		streqb	r2, [r3, #85]
4260:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
 270              		.loc 1 4260 0
 271 022c 5600C305 		streqb	r0, [r3, #86]
4266:../uvc.c      ****                         }
 272              		.loc 1 4266 0
 273 0230 B820DDE1 		ldrh	r2, [sp, #8]
 274 0234 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 275 0238 0400A0E3 		mov	r0, #4
 276 023c 00108DE5 		str	r1, [sp]
 277 0240 BC149FE5 		ldr	r1, .L133+24
 278 0244 FEFFFFEB 		bl	CyU3PDebugPrint
 279              	.LVL14:
 280 0248 A7FFFFEA 		b	.L4
 281              	.LVL15:
 282              	.L129:
4080:../uvc.c      ****             {
 283              		.loc 1 4080 0
 284 024c 810053E3 		cmp	r3, #129
 285 0250 0901002A 		bcs	.L14
 286 0254 010053E3 		cmp	r3, #1
 287 0258 9FFFFF1A 		bne	.L5
4107:../uvc.c      ****                             glCommitCtrl, &readCount);
 288              		.loc 1 4107 0
 289 025c 90449FE5 		ldr	r4, .L133+8
 290 0260 2000A0E3 		mov	r0, #32
 291 0264 4C1084E2 		add	r1, r4, #76
 292 0268 08208DE2 		add	r2, sp, #8
 293 026c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 294              	.LVL16:
4109:../uvc.c      ****                     {
 295              		.loc 1 4109 0
 296 0270 000050E3 		cmp	r0, #0
 297 0274 9CFFFF1A 		bne	.L4
4111:../uvc.c      ****                         {
 298              		.loc 1 4111 0
 299 0278 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 300 027c 030053E3 		cmp	r3, #3
 301 0280 99FFFF1A 		bne	.L4
4115:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 302              		.loc 1 4115 0
 303 0284 74349FE5 		ldr	r3, .L133+20
 304 0288 4E60D4E5 		ldrb	r6, [r4, #78]	@ zero_extendqisi2
4116:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 305              		.loc 1 4116 0
 306 028c 4F50D4E5 		ldrb	r5, [r4, #79]	@ zero_extendqisi2
4117:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 307              		.loc 1 4117 0
 308 0290 50C0D4E5 		ldrb	ip, [r4, #80]	@ zero_extendqisi2
4118:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 309              		.loc 1 4118 0
 310 0294 5100D4E5 		ldrb	r0, [r4, #81]	@ zero_extendqisi2
 311              	.LVL17:
4119:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 312              		.loc 1 4119 0
 313 0298 5210D4E5 		ldrb	r1, [r4, #82]	@ zero_extendqisi2
4120:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
 314              		.loc 1 4120 0
 315 029c 5320D4E5 		ldrb	r2, [r4, #83]	@ zero_extendqisi2
4115:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 316              		.loc 1 4115 0
 317 02a0 0260C3E5 		strb	r6, [r3, #2]
4116:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 318              		.loc 1 4116 0
 319 02a4 0350C3E5 		strb	r5, [r3, #3]
4117:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 320              		.loc 1 4117 0
 321 02a8 04C0C3E5 		strb	ip, [r3, #4]
4118:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 322              		.loc 1 4118 0
 323 02ac 0500C3E5 		strb	r0, [r3, #5]
4119:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 324              		.loc 1 4119 0
 325 02b0 0610C3E5 		strb	r1, [r3, #6]
4120:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
 326              		.loc 1 4120 0
 327 02b4 0720C3E5 		strb	r2, [r3, #7]
 328 02b8 8BFFFFEA 		b	.L4
 329              	.LVL18:
 330              	.L23:
4154:../uvc.c      ****                     {
 331              		.loc 1 4154 0
 332 02bc 30349FE5 		ldr	r3, .L133+8
 333 02c0 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 334 02c4 030053E3 		cmp	r3, #3
 335 02c8 2D00000A 		beq	.L131
 336              	.L19:
4103:../uvc.c      ****                     }
 337              		.loc 1 4103 0
 338 02cc 34149FE5 		ldr	r1, .L133+28
 339 02d0 1A00A0E3 		mov	r0, #26
 340 02d4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 341              	.LVL19:
 342 02d8 83FFFFEA 		b	.L4
 343              	.L128:
4362:../uvc.c      ****                 {
 344              		.loc 1 4362 0
 345 02dc 010055E3 		cmp	r5, #1
 346 02e0 7DFFFF1A 		bne	.L5
4387:../uvc.c      ****                                 glCommitCtrl, &readCount);
 347              		.loc 1 4387 0
 348 02e4 08449FE5 		ldr	r4, .L133+8
 349 02e8 08208DE2 		add	r2, sp, #8
 350 02ec 2000A0E3 		mov	r0, #32
 351 02f0 4C1084E2 		add	r1, r4, #76
 352 02f4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 353              	.LVL20:
4389:../uvc.c      ****                         {
 354              		.loc 1 4389 0
 355 02f8 002050E2 		subs	r2, r0, #0
 356 02fc EA00001A 		bne	.L79
4393:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 357              		.loc 1 4393 0
 358 0300 0400A0E1 		mov	r0, r4
 359              	.LVL21:
 360 0304 8010A0E3 		mov	r1, #128
 361 0308 FEFFFFEB 		bl	_txe_event_flags_set
 362              	.LVL22:
4394:../uvc.c      ****                             {
 363              		.loc 1 4394 0
 364 030c 002050E2 		subs	r2, r0, #0
4400:../uvc.c      ****                             //stillcont = 0;
 365              		.loc 1 4400 0
 366 0310 0F30E003 		mvneq	r3, #15
 367 0314 7230C405 		streqb	r3, [r4, #114]
4394:../uvc.c      ****                             {
 368              		.loc 1 4394 0
 369 0318 ED00001A 		bne	.L132
 370              	.LVL23:
 371              	.L81:
4403:../uvc.c      ****                         }else{
 372              		.loc 1 4403 0 discriminator 1
 373 031c 4D10D4E5 		ldrb	r1, [r4, #77]	@ zero_extendqisi2
 374 0320 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 375 0324 B820DDE1 		ldrh	r2, [sp, #8]
 376 0328 00108DE5 		str	r1, [sp]
 377 032c 0400A0E3 		mov	r0, #4
 378 0330 D4139FE5 		ldr	r1, .L133+32
 379 0334 FEFFFFEB 		bl	CyU3PDebugPrint
 380              	.LVL24:
 381 0338 6BFFFFEA 		b	.L4
 382              	.LVL25:
 383              	.L127:
4142:../uvc.c      ****             {
 384              		.loc 1 4142 0
 385 033c 010053E3 		cmp	r3, #1
 386 0340 65FFFF1A 		bne	.L5
4167:../uvc.c      ****                             glCommitCtrl, &readCount);
 387              		.loc 1 4167 0
 388 0344 A8439FE5 		ldr	r4, .L133+8
 389 0348 2000A0E3 		mov	r0, #32
 390 034c 4C1084E2 		add	r1, r4, #76
 391 0350 08208DE2 		add	r2, sp, #8
 392 0354 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 393              	.LVL26:
4169:../uvc.c      ****                     {
 394              		.loc 1 4169 0
 395 0358 000050E3 		cmp	r0, #0
 396 035c 62FFFF1A 		bne	.L4
4171:../uvc.c      ****                          {
 397              		.loc 1 4171 0
 398 0360 4F20D4E5 		ldrb	r2, [r4, #79]	@ zero_extendqisi2
 399 0364 013042E2 		sub	r3, r2, #1
 400 0368 030053E3 		cmp	r3, #3
 401 036c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 402 0370 DB0000EA 		b	.L82
 403              	.L30:
 404 0374 D8050000 		.word	.L29
 405 0378 88050000 		.word	.L31
 406 037c 38050000 		.word	.L32
 407 0380 94030000 		.word	.L33
 408              	.LVL27:
 409              	.L131:
4156:../uvc.c      ****                     }
 410              		.loc 1 4156 0
 411 0384 84139FE5 		ldr	r1, .L133+36
 412 0388 1A00A0E3 		mov	r0, #26
 413 038c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 414              	.LVL28:
 415 0390 55FFFFEA 		b	.L4
 416              	.LVL29:
 417              	.L33:
4189:../uvc.c      ****                          		CyU3PThreadSleep(500);
 418              		.loc 1 4189 0
 419 0394 64539FE5 		ldr	r5, .L133+20
 420 0398 6C2094E5 		ldr	r2, [r4, #108]
 421 039c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 422 03a0 000052E3 		cmp	r2, #0
 423 03a4 F420A003 		moveq	r2, #244
 424 03a8 7420A013 		movne	r2, #116
 425 03ac 032082E1 		orr	r2, r2, r3
 426 03b0 3010A0E3 		mov	r1, #48
 427 03b4 5230A0E3 		mov	r3, #82
 428 03b8 0100A0E3 		mov	r0, #1
 429              	.LVL30:
 430 03bc FEFFFFEB 		bl	SensorSetIrisControl
 431              	.LVL31:
4190:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 432              		.loc 1 4190 0
 433 03c0 7D0FA0E3 		mov	r0, #500
 434 03c4 FEFFFFEB 		bl	_tx_thread_sleep
 435              	.LVL32:
4191:../uvc.c      ****                          		break;
 436              		.loc 1 4191 0
 437 03c8 6C1094E5 		ldr	r1, [r4, #108]
 438 03cc 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 439 03d0 6C3094E5 		ldr	r3, [r4, #108]
 440 03d4 000051E3 		cmp	r1, #0
 441 03d8 F410A003 		moveq	r1, #244
 442 03dc 7410A013 		movne	r1, #116
 443              	.L116:
 444 03e0 022081E1 		orr	r2, r1, r2
 445 03e4 0400A0E3 		mov	r0, #4
 446 03e8 24139FE5 		ldr	r1, .L133+40
 447 03ec FEFFFFEB 		bl	CyU3PDebugPrint
 448              	.LVL33:
 449 03f0 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 450              	.L28:
4197:../uvc.c      **** 
 451              		.loc 1 4197 0
 452 03f4 0320A0E1 		mov	r2, r3
 453 03f8 18139FE5 		ldr	r1, .L133+44
 454 03fc 0400A0E3 		mov	r0, #4
4196:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 455              		.loc 1 4196 0
 456 0400 7030C4E5 		strb	r3, [r4, #112]
4197:../uvc.c      **** 
 457              		.loc 1 4197 0
 458 0404 FEFFFFEB 		bl	CyU3PDebugPrint
 459              	.LVL34:
4210:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 460              		.loc 1 4210 0
 461 0408 0020A0E3 		mov	r2, #0
 462 040c E0029FE5 		ldr	r0, .L133+8
 463 0410 0110A0E3 		mov	r1, #1
 464 0414 FEFFFFEB 		bl	_txe_event_flags_set
 465              	.LVL35:
4211:../uvc.c      ****                         {
 466              		.loc 1 4211 0
 467 0418 002050E2 		subs	r2, r0, #0
 468 041c 32FFFF0A 		beq	.L4
4213:../uvc.c      ****                         }
 469              		.loc 1 4213 0
 470 0420 F4129FE5 		ldr	r1, .L133+48
 471 0424 0400A0E3 		mov	r0, #4
 472              	.LVL36:
 473 0428 FEFFFFEB 		bl	CyU3PDebugPrint
 474              	.LVL37:
 475 042c 2EFFFFEA 		b	.L4
 476              	.LVL38:
 477              	.L62:
4330:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 478              		.loc 1 4330 0
 479 0430 6C2094E5 		ldr	r2, [r4, #108]
 480 0434 3010A0E3 		mov	r1, #48
 481 0438 000052E3 		cmp	r2, #0
 482 043c D420A003 		moveq	r2, #212
 483 0440 5420A013 		movne	r2, #84
 484 0444 5230A0E3 		mov	r3, #82
 485 0448 0100A0E3 		mov	r0, #1
 486              	.LVL39:
 487 044c FEFFFFEB 		bl	SensorSetIrisControl
 488              	.LVL40:
4332:../uvc.c      ****                              		break;
 489              		.loc 1 4332 0
 490 0450 6C2094E5 		ldr	r2, [r4, #108]
 491 0454 0400A0E3 		mov	r0, #4
 492 0458 000052E3 		cmp	r2, #0
 493 045c 6C3094E5 		ldr	r3, [r4, #108]
 494 0460 D420A003 		moveq	r2, #212
 495 0464 5420A013 		movne	r2, #84
 496 0468 B0129FE5 		ldr	r1, .L133+52
 497 046c FEFFFFEB 		bl	CyU3PDebugPrint
 498              	.LVL41:
 499 0470 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
 500              	.L58:
4349:../uvc.c      **** 
 501              		.loc 1 4349 0
 502 0474 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 503 0478 B820DDE1 		ldrh	r2, [sp, #8]
 504 047c 00C08DE5 		str	ip, [sp]
 505 0480 9C129FE5 		ldr	r1, .L133+56
4347:../uvc.c      **** 
 506              		.loc 1 4347 0
 507 0484 71C0C4E5 		strb	ip, [r4, #113]
4349:../uvc.c      **** 
 508              		.loc 1 4349 0
 509 0488 0400A0E3 		mov	r0, #4
 510 048c FEFFFFEB 		bl	CyU3PDebugPrint
 511              	.LVL42:
 512 0490 15FFFFEA 		b	.L4
 513              	.LVL43:
 514              	.L61:
4335:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 515              		.loc 1 4335 0
 516 0494 64529FE5 		ldr	r5, .L133+20
 517 0498 6C2094E5 		ldr	r2, [r4, #108]
 518 049c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 519 04a0 000052E3 		cmp	r2, #0
 520 04a4 C420A003 		moveq	r2, #196
 521 04a8 4420A013 		movne	r2, #68
 522 04ac 032082E1 		orr	r2, r2, r3
 523 04b0 3010A0E3 		mov	r1, #48
 524 04b4 5230A0E3 		mov	r3, #82
 525 04b8 0100A0E3 		mov	r0, #1
 526              	.LVL44:
 527 04bc FEFFFFEB 		bl	SensorSetIrisControl
 528              	.LVL45:
4337:../uvc.c      ****                              		break;
 529              		.loc 1 4337 0
 530 04c0 6C1094E5 		ldr	r1, [r4, #108]
 531 04c4 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 532 04c8 6C3094E5 		ldr	r3, [r4, #108]
 533 04cc 000051E3 		cmp	r1, #0
 534 04d0 C410A003 		moveq	r1, #196
 535 04d4 4410A013 		movne	r1, #68
 536              	.L118:
4342:../uvc.c      ****                              		break;
 537              		.loc 1 4342 0
 538 04d8 022081E1 		orr	r2, r1, r2
 539 04dc 0400A0E3 		mov	r0, #4
 540 04e0 38129FE5 		ldr	r1, .L133+52
 541 04e4 FEFFFFEB 		bl	CyU3PDebugPrint
 542              	.LVL46:
 543 04e8 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
4343:../uvc.c      ****                               	default:
 544              		.loc 1 4343 0
 545 04ec E0FFFFEA 		b	.L58
 546              	.LVL47:
 547              	.L59:
4340:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 548              		.loc 1 4340 0
 549 04f0 08529FE5 		ldr	r5, .L133+20
 550 04f4 6C2094E5 		ldr	r2, [r4, #108]
 551 04f8 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 552 04fc 000052E3 		cmp	r2, #0
 553 0500 F420A003 		moveq	r2, #244
 554 0504 7420A013 		movne	r2, #116
 555 0508 032082E1 		orr	r2, r2, r3
 556 050c 3010A0E3 		mov	r1, #48
 557 0510 5230A0E3 		mov	r3, #82
 558 0514 0100A0E3 		mov	r0, #1
 559              	.LVL48:
 560 0518 FEFFFFEB 		bl	SensorSetIrisControl
 561              	.LVL49:
4342:../uvc.c      ****                              		break;
 562              		.loc 1 4342 0
 563 051c 6C1094E5 		ldr	r1, [r4, #108]
 564 0520 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 565 0524 000051E3 		cmp	r1, #0
 566 0528 6C3094E5 		ldr	r3, [r4, #108]
 567 052c F410A003 		moveq	r1, #244
 568 0530 7410A013 		movne	r1, #116
 569 0534 E7FFFFEA 		b	.L118
 570              	.LVL50:
 571              	.L32:
4184:../uvc.c      ****                          		CyU3PThreadSleep(500);
 572              		.loc 1 4184 0
 573 0538 C0519FE5 		ldr	r5, .L133+20
 574 053c 6C2094E5 		ldr	r2, [r4, #108]
 575 0540 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 576 0544 000052E3 		cmp	r2, #0
 577 0548 C420A003 		moveq	r2, #196
 578 054c 4420A013 		movne	r2, #68
 579 0550 032082E1 		orr	r2, r2, r3
 580 0554 3010A0E3 		mov	r1, #48
 581 0558 5230A0E3 		mov	r3, #82
 582 055c 0100A0E3 		mov	r0, #1
 583              	.LVL51:
 584 0560 FEFFFFEB 		bl	SensorSetIrisControl
 585              	.LVL52:
4185:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 586              		.loc 1 4185 0
 587 0564 7D0FA0E3 		mov	r0, #500
 588 0568 FEFFFFEB 		bl	_tx_thread_sleep
 589              	.LVL53:
4186:../uvc.c      ****                          		break;
 590              		.loc 1 4186 0
 591 056c 6C1094E5 		ldr	r1, [r4, #108]
 592 0570 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 593 0574 000051E3 		cmp	r1, #0
 594 0578 6C3094E5 		ldr	r3, [r4, #108]
 595 057c C410A003 		moveq	r1, #196
 596 0580 4410A013 		movne	r1, #68
 597 0584 95FFFFEA 		b	.L116
 598              	.LVL54:
 599              	.L31:
4179:../uvc.c      ****                          		CyU3PThreadSleep(500);
 600              		.loc 1 4179 0
 601 0588 6C2094E5 		ldr	r2, [r4, #108]
 602 058c 3010A0E3 		mov	r1, #48
 603 0590 000052E3 		cmp	r2, #0
 604 0594 D420A003 		moveq	r2, #212
 605 0598 5420A013 		movne	r2, #84
 606 059c 5230A0E3 		mov	r3, #82
 607 05a0 0100A0E3 		mov	r0, #1
 608              	.LVL55:
 609 05a4 FEFFFFEB 		bl	SensorSetIrisControl
 610              	.LVL56:
4180:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 611              		.loc 1 4180 0
 612 05a8 7D0FA0E3 		mov	r0, #500
 613 05ac FEFFFFEB 		bl	_tx_thread_sleep
 614              	.LVL57:
4181:../uvc.c      ****                          		break;
 615              		.loc 1 4181 0
 616 05b0 6C2094E5 		ldr	r2, [r4, #108]
 617 05b4 0400A0E3 		mov	r0, #4
 618 05b8 000052E3 		cmp	r2, #0
 619 05bc 6C3094E5 		ldr	r3, [r4, #108]
 620 05c0 D420A003 		moveq	r2, #212
 621 05c4 5420A013 		movne	r2, #84
 622 05c8 44119FE5 		ldr	r1, .L133+40
 623 05cc FEFFFFEB 		bl	CyU3PDebugPrint
 624              	.LVL58:
 625 05d0 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
4182:../uvc.c      ****                          	case 3: //720
 626              		.loc 1 4182 0
 627 05d4 86FFFFEA 		b	.L28
 628              	.LVL59:
 629              	.L29:
4174:../uvc.c      ****                          		CyU3PThreadSleep(500);
 630              		.loc 1 4174 0
 631 05d8 6C2094E5 		ldr	r2, [r4, #108]
 632 05dc 3010A0E3 		mov	r1, #48
 633 05e0 000052E3 		cmp	r2, #0
 634 05e4 E420A003 		moveq	r2, #228
 635 05e8 6420A013 		movne	r2, #100
 636 05ec 5230A0E3 		mov	r3, #82
 637 05f0 0100A0E3 		mov	r0, #1
 638              	.LVL60:
 639 05f4 FEFFFFEB 		bl	SensorSetIrisControl
 640              	.LVL61:
4175:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 641              		.loc 1 4175 0
 642 05f8 7D0FA0E3 		mov	r0, #500
 643 05fc FEFFFFEB 		bl	_tx_thread_sleep
 644              	.LVL62:
4176:../uvc.c      ****                          		break;
 645              		.loc 1 4176 0
 646 0600 6C2094E5 		ldr	r2, [r4, #108]
 647 0604 0400A0E3 		mov	r0, #4
 648 0608 000052E3 		cmp	r2, #0
 649 060c 6C3094E5 		ldr	r3, [r4, #108]
 650 0610 E420A003 		moveq	r2, #228
 651 0614 6420A013 		movne	r2, #100
 652 0618 F4109FE5 		ldr	r1, .L133+40
 653 061c FEFFFFEB 		bl	CyU3PDebugPrint
 654              	.LVL63:
 655 0620 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
4177:../uvc.c      ****                          	case 2: //1080
 656              		.loc 1 4177 0
 657 0624 72FFFFEA 		b	.L28
 658              	.LVL64:
 659              	.L63:
4325:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 660              		.loc 1 4325 0
 661 0628 6C2094E5 		ldr	r2, [r4, #108]
 662 062c 3010A0E3 		mov	r1, #48
 663 0630 000052E3 		cmp	r2, #0
 664 0634 E420A003 		moveq	r2, #228
 665 0638 6420A013 		movne	r2, #100
 666 063c 5230A0E3 		mov	r3, #82
 667 0640 0100A0E3 		mov	r0, #1
 668              	.LVL65:
 669 0644 FEFFFFEB 		bl	SensorSetIrisControl
 670              	.LVL66:
4327:../uvc.c      ****                              		break;
 671              		.loc 1 4327 0
 672 0648 6C2094E5 		ldr	r2, [r4, #108]
 673 064c 0400A0E3 		mov	r0, #4
 674 0650 000052E3 		cmp	r2, #0
 675 0654 6C3094E5 		ldr	r3, [r4, #108]
 676 0658 E420A003 		moveq	r2, #228
 677 065c 6420A013 		movne	r2, #100
 678 0660 B8109FE5 		ldr	r1, .L133+52
 679 0664 FEFFFFEB 		bl	CyU3PDebugPrint
 680              	.LVL67:
 681 0668 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
4328:../uvc.c      ****                              	case 3: //1080
 682              		.loc 1 4328 0
 683 066c 80FFFFEA 		b	.L58
 684              	.LVL68:
 685              	.L76:
4369:../uvc.c      ****                         glEp0Buffer[1] = 0;
 686              		.loc 1 4369 0
 687 0670 7C309FE5 		ldr	r3, .L133+8
 688 0674 01C0A0E3 		mov	ip, #1
 689 0678 A9FEFFEA 		b	.L121
 690              	.L14:
4095:../uvc.c      ****                     {
 691              		.loc 1 4095 0
 692 067c 70309FE5 		ldr	r3, .L133+8
 693 0680 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 694 0684 030053E3 		cmp	r3, #3
 695 0688 0FFFFF1A 		bne	.L19
4097:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 696              		.loc 1 4097 0
 697 068c 6C109FE5 		ldr	r1, .L133+20
 698 0690 1A00A0E3 		mov	r0, #26
 699 0694 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 700              	.LVL69:
4098:../uvc.c      **** 
 701              		.loc 1 4098 0
 702 0698 0020D4E5 		ldrb	r2, [r4]	@ zero_extendqisi2
 703 069c 84109FE5 		ldr	r1, .L133+60
 704 06a0 0400A0E3 		mov	r0, #4
 705 06a4 FEFFFFEB 		bl	CyU3PDebugPrint
 706              	.LVL70:
 707 06a8 8FFEFFEA 		b	.L4
 708              	.LVL71:
 709              	.L79:
4405:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
 710              		.loc 1 4405 0
 711 06ac B820DDE1 		ldrh	r2, [sp, #8]
 712 06b0 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 713 06b4 70109FE5 		ldr	r1, .L133+64
 714 06b8 0400A0E3 		mov	r0, #4
 715              	.LVL72:
 716 06bc FEFFFFEB 		bl	CyU3PDebugPrint
 717              	.LVL73:
4406:../uvc.c      ****                         }
 718              		.loc 1 4406 0
 719 06c0 0000A0E3 		mov	r0, #0
 720 06c4 0510A0E1 		mov	r1, r5
 721 06c8 0020A0E1 		mov	r2, r0
 722 06cc FEFFFFEB 		bl	CyU3PUsbStall
 723              	.LVL74:
 724 06d0 85FEFFEA 		b	.L4
 725              	.LVL75:
 726              	.L132:
4396:../uvc.c      ****                             }
 727              		.loc 1 4396 0
 728 06d4 54109FE5 		ldr	r1, .L133+68
 729 06d8 0400A0E3 		mov	r0, #4
 730              	.LVL76:
 731 06dc FEFFFFEB 		bl	CyU3PDebugPrint
 732              	.LVL77:
 733 06e0 0DFFFFEA 		b	.L81
 734              	.LVL78:
 735              	.L82:
4171:../uvc.c      ****                          {
 736              		.loc 1 4171 0
 737 06e4 0230A0E1 		mov	r3, r2
 738 06e8 41FFFFEA 		b	.L28
 739              	.L134:
 740              		.align	2
 741              	.L133:
 742 06ec 00000000 		.word	wValue
 743 06f0 00000000 		.word	bRequest
 744 06f4 00000000 		.word	.LANCHOR0
 745 06f8 54000000 		.word	.LANCHOR1+84
 746 06fc 60000000 		.word	.LANCHOR1+96
 747 0700 00000000 		.word	.LANCHOR1
 748 0704 B4000000 		.word	.LC5
 749 0708 1C000000 		.word	.LANCHOR1+28
 750 070c 50010000 		.word	.LC9
 751 0710 38000000 		.word	.LANCHOR1+56
 752 0714 40000000 		.word	.LC2
 753 0718 64000000 		.word	.LC3
 754 071c 8C000000 		.word	.LC4
 755 0720 E0000000 		.word	.LC6
 756 0724 04010000 		.word	.LC7
 757 0728 18000000 		.word	.LC1
 758 072c 7C010000 		.word	.LC10
 759 0730 2C010000 		.word	.LC8
 760              		.cfi_endproc
 761              	.LFE24:
 763              		.align	2
 764              		.global	I2cAppThread_Entry
 766              	I2cAppThread_Entry:
 767              	.LFB26:
4421:../uvc.c      **** 
4422:../uvc.c      **** /*
4423:../uvc.c      ****  * Entry function for the UVC control request processing thread.
4424:../uvc.c      ****  */
4425:../uvc.c      **** void
4426:../uvc.c      **** UVCAppEP0Thread_Entry (
4427:../uvc.c      ****         uint32_t input)
4428:../uvc.c      **** {
4429:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
4430:../uvc.c      ****     uint32_t eventFlag;
4431:../uvc.c      **** 	CyBool_t value;
4432:../uvc.c      **** 	CyBool_t *valueptr = &value;
4433:../uvc.c      **** 
4434:../uvc.c      **** 
4435:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4436:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4437:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
4438:../uvc.c      **** 
4439:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
4440:../uvc.c      **** #endif
4441:../uvc.c      **** 
4442:../uvc.c      ****     /* for interrupt status test */
4443:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4444:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
4445:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
4446:../uvc.c      **** 
4447:../uvc.c      ****     for (;;)
4448:../uvc.c      ****     {
4449:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
4450:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
4451:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
4452:../uvc.c      ****         {
4453:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
4454:../uvc.c      ****             if (!isUsbConnected)
4455:../uvc.c      ****             {
4456:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
4457:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
4458:../uvc.c      ****                 {
4459:../uvc.c      ****                     isUsbConnected = CyTrue;
4460:../uvc.c      ****                 }
4461:../uvc.c      ****             }
4462:../uvc.c      **** //#ifdef DbgInfo
4463:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
4464:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
4465:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
4466:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
4467:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
4468:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
4469:../uvc.c      **** //#endif
4470:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
4471:../uvc.c      ****             {
4472:../uvc.c      ****             	switch ((wIndex >> 8))
4473:../uvc.c      ****                 {
4474:../uvc.c      **** 
4475:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
4476:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
4477:../uvc.c      ****                         break;
4478:../uvc.c      **** 
4479:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
4480:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
4481:../uvc.c      ****                         break;
4482:../uvc.c      **** 
4483:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
4484:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
4485:../uvc.c      ****                         break;
4486:../uvc.c      **** 
4487:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
4488:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
4489:../uvc.c      ****                         break;
4490:../uvc.c      **** 
4491:../uvc.c      ****                     default:
4492:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
4493:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4494:../uvc.c      ****                         break;
4495:../uvc.c      ****                 }
4496:../uvc.c      ****             }
4497:../uvc.c      **** 
4498:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
4499:../uvc.c      ****             {
4500:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
4501:../uvc.c      **** 
4502:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
4503:../uvc.c      ****                 {
4504:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4505:../uvc.c      ****                 }
4506:../uvc.c      ****                 else
4507:../uvc.c      ****                 {
4508:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
4509:../uvc.c      ****                 }
4510:../uvc.c      ****             }
4511:../uvc.c      **** 
4512:../uvc.c      ****             /* handle interrupt status event */
4513:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
4514:../uvc.c      ****             {
4515:../uvc.c      **** 
4516:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
4517:../uvc.c      ****             	/** preparing interrupt status data **/
4518:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
4519:../uvc.c      **** 
4520:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4521:../uvc.c      **** 
4522:../uvc.c      **** #if 0 //for real button
4523:../uvc.c      **** 				if(value&&(!snapButFlag)){
4524:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4525:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4526:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4527:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4528:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4529:../uvc.c      **** 
4530:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4531:../uvc.c      **** 					interStabuf.size   = 1024;
4532:../uvc.c      **** 					interStabuf.status = 0;
4533:../uvc.c      **** 
4534:../uvc.c      **** 					interStabuf.count = 4;
4535:../uvc.c      **** 
4536:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4537:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4538:../uvc.c      **** 
4539:../uvc.c      **** 					/** send a interrupt status data **/
4540:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4541:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4542:../uvc.c      **** 					{
4543:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4544:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4545:../uvc.c      **** 					}
4546:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
4547:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
4548:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4549:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4550:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4551:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4552:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4553:../uvc.c      **** 
4554:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4555:../uvc.c      **** 					interStabuf.size   = 1024;
4556:../uvc.c      **** 					interStabuf.status = 0;
4557:../uvc.c      **** 
4558:../uvc.c      **** 					interStabuf.count = 4;
4559:../uvc.c      **** 
4560:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4561:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4562:../uvc.c      **** 
4563:../uvc.c      **** 					/** send a interrupt status data **/
4564:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4565:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4566:../uvc.c      **** 					{
4567:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4568:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4569:../uvc.c      **** 					}
4570:../uvc.c      **** 
4571:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
4572:../uvc.c      **** 					stiflag = 0xFF;
4573:../uvc.c      **** 				}
4574:../uvc.c      **** #else			//for botton simulation
4575:../uvc.c      **** 				if(snapButFlag == 0x0f){
4576:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4577:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4578:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4579:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4580:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4581:../uvc.c      **** 
4582:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4583:../uvc.c      **** 					interStabuf.size   = 1024;
4584:../uvc.c      **** 					interStabuf.status = 0;
4585:../uvc.c      **** 
4586:../uvc.c      **** 					interStabuf.count = 4;
4587:../uvc.c      **** 
4588:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4589:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4590:../uvc.c      **** 
4591:../uvc.c      **** 					/** send a interrupt status data **/
4592:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4593:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4594:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4595:../uvc.c      **** 					{
4596:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4597:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4598:../uvc.c      **** 					}
4599:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
4600:../uvc.c      **** 
4601:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
4602:../uvc.c      **** 				}else if(!snapButFlag){
4603:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4604:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4605:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4606:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4607:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4608:../uvc.c      **** 
4609:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4610:../uvc.c      **** 					interStabuf.size   = 1024;
4611:../uvc.c      **** 					interStabuf.status = 0;
4612:../uvc.c      **** 
4613:../uvc.c      **** 					interStabuf.count = 4;
4614:../uvc.c      **** 
4615:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4616:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4617:../uvc.c      **** 
4618:../uvc.c      **** 					/** send a interrupt status data **/
4619:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4620:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4621:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4622:../uvc.c      **** 					{
4623:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4624:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4625:../uvc.c      **** 					}
4626:../uvc.c      **** 
4627:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
4628:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
4629:../uvc.c      **** 				}
4630:../uvc.c      **** #endif
4631:../uvc.c      **** 
4632:../uvc.c      ****             }
4633:../uvc.c      **** 
4634:../uvc.c      **** 
4635:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4636:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
4637:../uvc.c      ****             {
4638:../uvc.c      ****                 /* Get the command buffer */
4639:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
4640:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4641:../uvc.c      ****                 {
4642:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
4643:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4644:../uvc.c      ****                 }
4645:../uvc.c      **** 
4646:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
4647:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
4648:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
4649:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
4650:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
4651:../uvc.c      ****                  * register value high byte and register value low byte.
4652:../uvc.c      ****                  */
4653:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
4654:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
4655:../uvc.c      ****                 {
4656:../uvc.c      ****                     if (dmaInfo.count == 3)
4657:../uvc.c      ****                     {
4658:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
4659:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
4660:../uvc.c      ****                         dmaInfo.count = 3;
4661:../uvc.c      ****                     }
4662:../uvc.c      ****                     else if (dmaInfo.count == 4)
4663:../uvc.c      ****                     {
4664:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
4665:../uvc.c      ****                         {
4666:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
4667:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
4668:../uvc.c      ****                         }
4669:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
4670:../uvc.c      ****                     }
4671:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
4672:../uvc.c      ****                 }
4673:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
4674:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
4675:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
4676:../uvc.c      ****                  */
4677:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
4678:../uvc.c      ****                 {
4679:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4680:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
4681:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4682:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
4683:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
4684:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4685:../uvc.c      ****                         	break;
4686:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
4687:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
4688:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4689:../uvc.c      ****                         	break;*/
4690:../uvc.c      ****                     dmaInfo.count -= 2;
4691:../uvc.c      ****                 }
4692:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
4693:../uvc.c      ****                 else
4694:../uvc.c      ****                 {
4695:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
4696:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
4697:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
4698:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
4699:../uvc.c      ****                 }
4700:../uvc.c      **** 
4701:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
4702:../uvc.c      ****                 dmaInfo.size   = 1024;
4703:../uvc.c      ****                 dmaInfo.status = 0;
4704:../uvc.c      **** 
4705:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
4706:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
4707:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4708:../uvc.c      ****                 {
4709:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
4710:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4711:../uvc.c      ****                 }
4712:../uvc.c      **** 
4713:../uvc.c      ****                 /* Wait until the response has gone out. */
4714:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
4715:../uvc.c      **** 
4716:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
4717:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4718:../uvc.c      ****                 {
4719:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
4720:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4721:../uvc.c      ****                 }
4722:../uvc.c      ****             }
4723:../uvc.c      **** #endif
4724:../uvc.c      ****         }
4725:../uvc.c      ****         /* Allow other ready threads to run. */
4726:../uvc.c      ****         CyU3PThreadRelinquish ();
4727:../uvc.c      ****     }
4728:../uvc.c      **** }
4729:../uvc.c      **** 
4730:../uvc.c      **** /*
4731:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
4732:../uvc.c      ****  * added 10/2013
4733:../uvc.c      ****  */
4734:../uvc.c      **** /*
4735:../uvc.c      **** static uint8_t timeDelay[64] = {
4736:../uvc.c      **** 
4737:../uvc.c      **** };
4738:../uvc.c      **** */
4739:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
 768              		.loc 1 4739 0
 769              		.cfi_startproc
 770              		@ args = 0, pretend = 0, frame = 8
 771              		@ frame_needed = 0, uses_anonymous_args = 0
 772              	.LVL79:
 773 0734 F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
 774              	.LCFI3:
 775              		.cfi_def_cfa_offset 28
 776              		.cfi_offset 4, -28
 777              		.cfi_offset 5, -24
 778              		.cfi_offset 6, -20
 779              		.cfi_offset 7, -16
 780              		.cfi_offset 8, -12
 781              		.cfi_offset 9, -8
 782              		.cfi_offset 14, -4
4740:../uvc.c      **** 
4741:../uvc.c      **** 	uint16_t count = 0, cmdCopyIdx = 0, count1 = 0, cmdQuIdx = 0; //
4742:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4743:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4744:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
4745:../uvc.c      **** 	VdcmdDes  *lcStaDes;
4746:../uvc.c      **** 	uint32_t flag = 0;
4747:../uvc.c      **** 	uint8_t  cmdFlag = 0;
4748:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
4749:../uvc.c      **** 	uint8_t i;
4750:../uvc.c      **** 	uint16_t delaytime;
4751:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
4752:../uvc.c      **** 
4753:../uvc.c      **** #if 0 //for test the command queue
4754:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
4755:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4756:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
4757:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4758:../uvc.c      **** 		lcCmdDes += 1;
4759:../uvc.c      **** 	}
4760:../uvc.c      **** 	lcCmdDes = statQuptr->startAdd;
4761:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4762:../uvc.c      **** 		CyU3PDebugPrint (4, "State Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n",
4763:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4764:../uvc.c      **** 		lcCmdDes += 1;
4765:../uvc.c      **** 	}
4766:../uvc.c      **** 
4767:../uvc.c      **** #endif
4768:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
4769:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
 783              		.loc 1 4769 0
 784 0738 34029FE5 		ldr	r0, .L161
 785              	.LVL80:
4739:../uvc.c      **** 
 786              		.loc 1 4739 0
 787 073c 1CD04DE2 		sub	sp, sp, #28
 788              	.LCFI4:
 789              		.cfi_def_cfa_offset 56
4746:../uvc.c      **** 	uint8_t  cmdFlag = 0;
 790              		.loc 1 4746 0
 791 0740 00C0A0E3 		mov	ip, #0
 792              		.loc 1 4769 0
 793 0744 FA2FA0E3 		mov	r2, #1000
 794 0748 2C30A0E3 		mov	r3, #44
 795 074c 0C10A0E1 		mov	r1, ip
 796 0750 04C08DE5 		str	ip, [sp, #4]
 797 0754 08C08DE5 		str	ip, [sp, #8]
 798 0758 00208DE5 		str	r2, [sp]
 799 075c 0C308DE5 		str	r3, [sp, #12]
 800 0760 10229FE5 		ldr	r2, .L161+4
 801 0764 0B30A0E3 		mov	r3, #11
4746:../uvc.c      **** 	uint8_t  cmdFlag = 0;
 802              		.loc 1 4746 0
 803 0768 14C08DE5 		str	ip, [sp, #20]
 804              	.LVL81:
 805              		.loc 1 4769 0
 806 076c FEFFFFEB 		bl	_txe_timer_create
 807              	.LVL82:
4770:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
 808              		.loc 1 4770 0
 809 0770 FEFFFFEB 		bl	_tx_time_get
 810              	.LVL83:
4771:../uvc.c      **** 	CyU3PThreadSleep(50);
4772:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
4773:../uvc.c      **** 
4774:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
 811              		.loc 1 4774 0
 812 0774 00529FE5 		ldr	r5, .L161+8
4770:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
 813              		.loc 1 4770 0
 814 0778 00129FE5 		ldr	r1, .L161+12
 815 077c 0020A0E1 		mov	r2, r0
 816 0780 0400A0E3 		mov	r0, #4
 817 0784 FEFFFFEB 		bl	CyU3PDebugPrint
 818              	.LVL84:
4771:../uvc.c      **** 	CyU3PThreadSleep(50);
 819              		.loc 1 4771 0
 820 0788 3200A0E3 		mov	r0, #50
 821 078c FEFFFFEB 		bl	_tx_thread_sleep
 822              	.LVL85:
4772:../uvc.c      **** 
 823              		.loc 1 4772 0
 824 0790 DC019FE5 		ldr	r0, .L161
 825 0794 FEFFFFEB 		bl	_txe_timer_activate
 826              	.LVL86:
 827              		.loc 1 4774 0
 828 0798 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 829 079c 000052E3 		cmp	r2, #0
 830 07a0 0300001A 		bne	.L136
 831              	.L137:
4775:../uvc.c      ****         /* Allow other ready threads to run. */
4776:../uvc.c      **** 
4777:../uvc.c      ****         CyU3PThreadRelinquish ();
 832              		.loc 1 4777 0
 833 07a4 FEFFFFEB 		bl	_txe_thread_relinquish
 834              	.LVL87:
4774:../uvc.c      ****         /* Allow other ready threads to run. */
 835              		.loc 1 4774 0
 836 07a8 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 837 07ac 000052E3 		cmp	r2, #0
 838 07b0 FBFFFF0A 		beq	.L137
 839              	.L136:
4778:../uvc.c      **** 	}
4779:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
 840              		.loc 1 4779 0
 841 07b4 103095E5 		ldr	r3, [r5, #16]
 842 07b8 0400A0E3 		mov	r0, #4
 843 07bc 3C3093E5 		ldr	r3, [r3, #60]
 844 07c0 BC119FE5 		ldr	r1, .L161+16
 845 07c4 FEFFFFEB 		bl	CyU3PDebugPrint
 846              	.LVL88:
 847 07c8 B8619FE5 		ldr	r6, .L161+20
 848 07cc B8819FE5 		ldr	r8, .L161+24
4780:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
4781:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
4782:../uvc.c      **** 	//CyU3PThreadSleep(100);
4783:../uvc.c      **** 	//SetCurCmd();
4784:../uvc.c      **** 	/*********** the loop of the thread ***********/
4785:../uvc.c      **** 	for(;;){
4786:../uvc.c      **** 
4787:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 849              		.loc 1 4787 0
 850 07d0 0070E0E3 		mvn	r7, #0
 851              	.L154:
 852 07d4 14308DE2 		add	r3, sp, #20
 853 07d8 2010A0E3 		mov	r1, #32
 854 07dc 0320A0E3 		mov	r2, #3
 855 07e0 00708DE5 		str	r7, [sp]
 856 07e4 A4019FE5 		ldr	r0, .L161+28
 857 07e8 FEFFFFEB 		bl	_txe_event_flags_get
 858              	.LVL89:
4788:../uvc.c      **** /*  // for test GPIO output
4789:../uvc.c      **** 		if(trigger)
4790:../uvc.c      **** 		{
4791:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
4792:../uvc.c      **** 			{
4793:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
4794:../uvc.c      **** 			}
4795:../uvc.c      **** 
4796:../uvc.c      **** 		}else{
4797:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
4798:../uvc.c      **** 			{
4799:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
4800:../uvc.c      **** 			}
4801:../uvc.c      **** 
4802:../uvc.c      **** 		}
4803:../uvc.c      **** */
4804:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 859              		.loc 1 4804 0
 860 07ec 1C0096E5 		ldr	r0, [r6, #28]
 861 07f0 0010E0E3 		mvn	r1, #0
 862 07f4 FEFFFFEB 		bl	_txe_mutex_get
 863              	.LVL90:
4805:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4806:../uvc.c      **** 			/* find an available reading I2C command in the state queue */
4807:../uvc.c      **** 			lcStaDes = (VdcmdDes*)statQuptr->readPtr;
4808:../uvc.c      **** 			//if(0 && (lcStaDes->cmdFlag == CyTrue)){ /* for state queue it's not used right now. */
4809:../uvc.c      **** 				i = 0;
4810:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 864              		.loc 1 4810 0
 865 07f8 103096E5 		ldr	r3, [r6, #16]
 866 07fc 3C3093E5 		ldr	r3, [r3, #60]
 867 0800 000053E3 		cmp	r3, #0
 868 0804 0300001A 		bne	.L138
 869 0808 4030A0E3 		mov	r3, #64
 870              	.LVL91:
 871              	.L139:
 872 080c 013043E2 		sub	r3, r3, #1
 873 0810 FF3013E2 		ands	r3, r3, #255
 874 0814 FCFFFF1A 		bne	.L139
 875              	.LVL92:
 876              	.L138:
4811:../uvc.c      **** 					i++;
4812:../uvc.c      **** 					lcCmdDes = lcStaDes->cmdDesNext;
4813:../uvc.c      **** 					statQuptr->readPtr = lcStaDes;
4814:../uvc.c      **** 				}
4815:../uvc.c      **** #if 0
4816:../uvc.c      **** 				if(lcStaDes->cmdFlag != deswait){
4817:../uvc.c      **** 				i = lcStaDes->curNum;
4818:../uvc.c      **** 				regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
4819:../uvc.c      **** 				devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
4820:../uvc.c      **** 				data = ((lcStaDes->CmdPar)+i)->Data;
4821:../uvc.c      **** 				//delaytime = ((lcStaDes->CmdPar)+i)->DelayT;
4822:../uvc.c      **** 
4823:../uvc.c      **** 				//for(i = 0; i < lcStaDes->NumPara; i++){
4824:../uvc.c      **** 					//regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
4825:../uvc.c      **** 					//devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
4826:../uvc.c      **** 					((lcStaDes->CmdPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
4827:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4828:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
4829:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
4830:../uvc.c      **** #endif
4831:../uvc.c      **** 				//}
4832:../uvc.c      **** 				lcStaDes->cmdFlag = CyFalse;
4833:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->cmdDesNext; //update command queue read pointer
4834:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
4835:../uvc.c      **** 				/* setting delay */
4836:../uvc.c      **** 				delaytime = 300;
4837:../uvc.c      **** 				CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
4838:../uvc.c      **** 				CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
4839:../uvc.c      **** 			} //end of the if condition statment
4840:../uvc.c      **** #endif
4841:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 877              		.loc 1 4841 0
 878 0818 1C0096E5 		ldr	r0, [r6, #28]
 879 081c FEFFFFEB 		bl	_txe_mutex_put
 880              	.LVL93:
4842:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
4843:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 881              		.loc 1 4843 0
 882 0820 1C0095E5 		ldr	r0, [r5, #28]
 883 0824 0010E0E3 		mvn	r1, #0
 884 0828 FEFFFFEB 		bl	_txe_mutex_get
 885              	.LVL94:
4844:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 886              		.loc 1 4844 0
 887 082c 104095E5 		ldr	r4, [r5, #16]
 888              	.LVL95:
4845:../uvc.c      **** 
4846:../uvc.c      **** 				/*
4847:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4848:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4849:../uvc.c      **** 				*/
4850:../uvc.c      **** 
4851:../uvc.c      **** 				/* find a available command */
4852:../uvc.c      **** 				i = 0;
4853:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 889              		.loc 1 4853 0
 890 0830 3C3094E5 		ldr	r3, [r4, #60]
 891 0834 000053E3 		cmp	r3, #0
 892 0838 0900001A 		bne	.L140
 893 083c 4020A0E3 		mov	r2, #64
 894 0840 010000EA 		b	.L143
 895              	.LVL96:
 896              	.L141:
 897              		.loc 1 4853 0 is_stmt 0 discriminator 2
 898 0844 FF2012E2 		ands	r2, r2, #255
 899 0848 3100000A 		beq	.L159
 900              	.L143:
4854:../uvc.c      **** 					i++;
4855:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 901              		.loc 1 4855 0 is_stmt 1
 902 084c 344094E5 		ldr	r4, [r4, #52]
 903              	.LVL97:
 904 0850 012042E2 		sub	r2, r2, #1
4853:../uvc.c      **** 					i++;
 905              		.loc 1 4853 0
 906 0854 3C3094E5 		ldr	r3, [r4, #60]
 907 0858 000053E3 		cmp	r3, #0
 908 085c F8FFFF0A 		beq	.L141
 909 0860 104085E5 		str	r4, [r5, #16]
 910              	.L140:
 911              	.LVL98:
 912 0864 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
4856:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
4857:../uvc.c      **** 				}
4858:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
4859:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
4860:../uvc.c      **** 					i = lcCmdDes->curNum;
4861:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
4862:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
4863:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
4864:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
4865:../uvc.c      **** #if 1
4866:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 913              		.loc 1 4866 0
 914 0868 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
 915 086c 833083E0 		add	r3, r3, r3, asl #1
 916 0870 833084E0 		add	r3, r4, r3, asl #1
 917 0874 20C04CE2 		sub	ip, ip, #32
4861:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 918              		.loc 1 4861 0
 919 0878 0400D3E5 		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 920              	.LVL99:
4862:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 921              		.loc 1 4862 0
 922 087c 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 923              	.LVL100:
4863:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 924              		.loc 1 4863 0
 925 0880 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 926              	.LVL101:
4864:../uvc.c      **** #if 1
 927              		.loc 1 4864 0
 928 0884 B890D3E1 		ldrh	r9, [r3, #8]
 929              	.LVL102:
 930              		.loc 1 4866 0
 931 0888 03005CE3 		cmp	ip, #3
 932 088c 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 933 0890 340000EA 		b	.L149
 934              	.L155:
 935 0894 04090000 		.word	.L144
 936 0898 F4080000 		.word	.L146
 937 089c A4080000 		.word	.L148
 938 08a0 A4080000 		.word	.L148
 939              	.L148:
4867:../uvc.c      **** 						case 0x20:
4868:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
4869:../uvc.c      **** 							delaytime = 500;
4870:../uvc.c      **** 							break;
4871:../uvc.c      **** 						case 0x21:
4872:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
4873:../uvc.c      **** 							delaytime = 500;
4874:../uvc.c      **** 							break;
4875:../uvc.c      **** 						case 0x22:
4876:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4877:../uvc.c      **** 							delaytime = 300;
4878:../uvc.c      **** 							break;
4879:../uvc.c      **** 						case 0x23:
4880:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 940              		.loc 1 4880 0
 941 08a4 8230A0E3 		mov	r3, #130
 942              	.LVL103:
 943 08a8 FEFFFFEB 		bl	SensorSetIrisControl
 944              	.LVL104:
4881:../uvc.c      **** 							delaytime = 300;
4882:../uvc.c      **** 							break;
 945              		.loc 1 4882 0
 946 08ac 4B1FA0E3 		mov	r1, #300
 947              	.LVL105:
 948              	.L145:
4883:../uvc.c      **** 						default:
4884:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
4885:../uvc.c      **** 							break;
4886:../uvc.c      **** 					}
4887:../uvc.c      **** #endif
4888:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
4889:../uvc.c      **** 					/** timer's ticket modify **/
4890:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
4891:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 949              		.loc 1 4891 0
 950 08b0 0020A0E3 		mov	r2, #0
 951 08b4 B8009FE5 		ldr	r0, .L161
 952 08b8 FEFFFFEB 		bl	_txe_timer_change
 953              	.LVL106:
4892:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 954              		.loc 1 4892 0
 955 08bc B0009FE5 		ldr	r0, .L161
 956 08c0 FEFFFFEB 		bl	_txe_timer_activate
 957              	.LVL107:
4893:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
4894:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
4895:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4896:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
4897:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
4898:../uvc.c      **** #endif
4899:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 958              		.loc 1 4899 0
 959 08c4 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 960 08c8 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 961 08cc 030052E1 		cmp	r2, r3
 962 08d0 1600000A 		beq	.L160
4900:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
4901:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
4902:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
4903:../uvc.c      **** 						}else{
4904:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
4905:../uvc.c      **** 						}
4906:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
4907:../uvc.c      **** 					}else{
4908:../uvc.c      **** 						lcCmdDes->curNum ++;
 963              		.loc 1 4908 0
 964 08d4 013083E2 		add	r3, r3, #1
4909:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 965              		.loc 1 4909 0
 966 08d8 0F20A0E3 		mov	r2, #15
4908:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 967              		.loc 1 4908 0
 968 08dc 0130C4E5 		strb	r3, [r4, #1]
 969              		.loc 1 4909 0
 970 08e0 3C2084E5 		str	r2, [r4, #60]
 971              	.LVL108:
 972              	.L153:
4910:../uvc.c      **** 					}
4911:../uvc.c      **** 				}else{
4912:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
4913:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
4914:../uvc.c      **** 				}
4915:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 973              		.loc 1 4915 0
 974 08e4 1C0095E5 		ldr	r0, [r5, #28]
 975 08e8 FEFFFFEB 		bl	_txe_mutex_put
 976              	.LVL109:
4916:../uvc.c      **** 			}
4917:../uvc.c      **** /*
4918:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4919:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4920:../uvc.c      **** */
4921:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4922:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
4923:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
4924:../uvc.c      **** #endif
4925:../uvc.c      **** 
4926:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
4927:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
4928:../uvc.c      **** #if 0
4929:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
4930:../uvc.c      **** 
4931:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
4932:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
4933:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
4934:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
4935:../uvc.c      **** 			    i = 0;
4936:../uvc.c      **** 				 switch(cmdCopyIdx)
4937:../uvc.c      **** 				 {
4938:../uvc.c      **** 					 case BrgtCtlID1:
4939:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
4940:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4941:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
4942:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4943:../uvc.c      **** 							 i++;
4944:../uvc.c      **** 						 }
4945:../uvc.c      **** 						 else{
4946:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4947:../uvc.c      **** 						 }
4948:../uvc.c      **** 
4949:../uvc.c      **** 						 CyU3PBusyWait(500);
4950:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
4951:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4952:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4953:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4954:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4955:../uvc.c      **** 						 }
4956:../uvc.c      **** 						 else{
4957:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4958:../uvc.c      **** 						 }
4959:../uvc.c      **** 						 break;
4960:../uvc.c      **** 					 case HueCtlID5:
4961:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4962:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4963:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4964:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4965:../uvc.c      **** 						 }
4966:../uvc.c      **** 						 else{
4967:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4968:../uvc.c      **** 						 }
4969:../uvc.c      **** 						 break;
4970:../uvc.c      **** 					 case SaturCtlID6:
4971:../uvc.c      **** 					 case WBTLevCtlID10:
4972:../uvc.c      **** 					 default:
4973:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
4974:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4975:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4976:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4977:../uvc.c      **** 						 }
4978:../uvc.c      **** 						 else{
4979:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4980:../uvc.c      **** 						 }
4981:../uvc.c      **** 						 break;
4982:../uvc.c      **** 				 }
4983:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
4984:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
4985:../uvc.c      **** 			}
4986:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
4987:../uvc.c      **** #endif
4988:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
4989:../uvc.c      **** 		/* Allow other ready threads to run. */
4990:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4991:../uvc.c      **** 			CyU3PThreadRelinquish ();
 977              		.loc 1 4991 0
 978 08ec FEFFFFEB 		bl	_txe_thread_relinquish
 979              	.LVL110:
4992:../uvc.c      **** 		}
 980              		.loc 1 4992 0
 981 08f0 B7FFFFEA 		b	.L154
 982              	.LVL111:
 983              	.L146:
4872:../uvc.c      **** 							delaytime = 500;
 984              		.loc 1 4872 0
 985 08f4 5230A0E3 		mov	r3, #82
 986              	.LVL112:
 987 08f8 FEFFFFEB 		bl	SensorSetIrisControl
 988              	.LVL113:
4874:../uvc.c      **** 						case 0x22:
 989              		.loc 1 4874 0
 990 08fc 7D1FA0E3 		mov	r1, #500
 991 0900 EAFFFFEA 		b	.L145
 992              	.LVL114:
 993              	.L144:
4868:../uvc.c      **** 							delaytime = 500;
 994              		.loc 1 4868 0
 995 0904 8230A0E3 		mov	r3, #130
 996              	.LVL115:
 997 0908 FEFFFFEB 		bl	SensorSetIrisControl
 998              	.LVL116:
4870:../uvc.c      **** 						case 0x21:
 999              		.loc 1 4870 0
 1000 090c 7D1FA0E3 		mov	r1, #500
 1001 0910 E6FFFFEA 		b	.L145
 1002              	.LVL117:
 1003              	.L159:
4912:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 1004              		.loc 1 4912 0
 1005 0914 FA1FA0E3 		mov	r1, #1000
 1006 0918 54009FE5 		ldr	r0, .L161
 1007 091c 104085E5 		str	r4, [r5, #16]
 1008 0920 FEFFFFEB 		bl	_txe_timer_change
 1009              	.LVL118:
4913:../uvc.c      **** 				}
 1010              		.loc 1 4913 0
 1011 0924 48009FE5 		ldr	r0, .L161
 1012 0928 FEFFFFEB 		bl	_txe_timer_activate
 1013              	.LVL119:
 1014 092c ECFFFFEA 		b	.L153
 1015              	.LVL120:
 1016              	.L160:
4901:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 1017              		.loc 1 4901 0
 1018 0930 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
4900:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 1019              		.loc 1 4900 0
 1020 0934 0020A0E3 		mov	r2, #0
4901:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 1021              		.loc 1 4901 0
 1022 0938 230053E3 		cmp	r3, #35
4902:../uvc.c      **** 						}else{
 1023              		.loc 1 4902 0
 1024 093c 24304382 		subhi	r3, r3, #36
 1025 0940 83308380 		addhi	r3, r3, r3, asl #1
4904:../uvc.c      **** 						}
 1026              		.loc 1 4904 0
 1027 0944 83308390 		addls	r3, r3, r3, asl #1
4902:../uvc.c      **** 						}else{
 1028              		.loc 1 4902 0
 1029 0948 83318880 		addhi	r3, r8, r3, asl #3
4904:../uvc.c      **** 						}
 1030              		.loc 1 4904 0
 1031 094c 83318890 		addls	r3, r8, r3, asl #3
4902:../uvc.c      **** 						}else{
 1032              		.loc 1 4902 0
 1033 0950 7C20C385 		strhib	r2, [r3, #124]
4904:../uvc.c      **** 						}
 1034              		.loc 1 4904 0
 1035 0954 FC21C395 		strlsb	r2, [r3, #508]
4906:../uvc.c      **** 					}else{
 1036              		.loc 1 4906 0
 1037 0958 343094E5 		ldr	r3, [r4, #52]
4900:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 1038              		.loc 1 4900 0
 1039 095c 3C2084E5 		str	r2, [r4, #60]
4906:../uvc.c      **** 					}else{
 1040              		.loc 1 4906 0
 1041 0960 103085E5 		str	r3, [r5, #16]
 1042 0964 DEFFFFEA 		b	.L153
 1043              	.LVL121:
 1044              	.L149:
4884:../uvc.c      **** 							break;
 1045              		.loc 1 4884 0
 1046 0968 FEFFFFEB 		bl	SensorSetControl
 1047              	.LVL122:
 1048 096c 0910A0E1 		mov	r1, r9
4885:../uvc.c      **** 					}
 1049              		.loc 1 4885 0
 1050 0970 CEFFFFEA 		b	.L145
 1051              	.L162:
 1052              		.align	2
 1053              	.L161:
 1054 0974 00000000 		.word	I2CCmdTimer
 1055 0978 00000000 		.word	I2CCmdCb
 1056 097c 00000000 		.word	cmdQu
 1057 0980 A4010000 		.word	.LC11
 1058 0984 B8010000 		.word	.LC12
 1059 0988 00000000 		.word	statQu
 1060 098c 00000000 		.word	.LANCHOR1
 1061 0990 00000000 		.word	.LANCHOR0
 1062              		.cfi_endproc
 1063              	.LFE26:
 1065              		.align	2
 1066              		.global	CyFxUvcApplnDmaCallback
 1068              	CyFxUvcApplnDmaCallback:
 1069              	.LFB11:
2582:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 1070              		.loc 1 2582 0
 1071              		.cfi_startproc
 1072              		@ args = 0, pretend = 0, frame = 0
 1073              		@ frame_needed = 0, uses_anonymous_args = 0
 1074              	.LVL123:
2589:../uvc.c      ****     {
 1075              		.loc 1 2589 0
 1076 0994 080051E3 		cmp	r1, #8
2582:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 1077              		.loc 1 2582 0
 1078 0998 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1079              	.LCFI5:
 1080              		.cfi_def_cfa_offset 16
 1081              		.cfi_offset 4, -16
 1082              		.cfi_offset 5, -12
 1083              		.cfi_offset 6, -8
 1084              		.cfi_offset 14, -4
 1085 099c 0250A0E1 		mov	r5, r2
 1086 09a0 08D04DE2 		sub	sp, sp, #8
 1087              	.LCFI6:
 1088              		.cfi_def_cfa_offset 24
2589:../uvc.c      ****     {
 1089              		.loc 1 2589 0
 1090 09a4 0B00000A 		beq	.L174
2641:../uvc.c      ****     {
 1091              		.loc 1 2641 0
 1092 09a8 100051E3 		cmp	r1, #16
 1093 09ac 0700001A 		bne	.L163
2643:../uvc.c      ****         streamingStarted = CyTrue;
 1094              		.loc 1 2643 0
 1095 09b0 6C319FE5 		ldr	r3, .L177
2644:../uvc.c      ****     }
 1096              		.loc 1 2644 0
 1097 09b4 0110A0E3 		mov	r1, #1
 1098              	.LVL124:
2643:../uvc.c      ****         streamingStarted = CyTrue;
 1099              		.loc 1 2643 0
 1100 09b8 B228D3E1 		ldrh	r2, [r3, #130]
 1101              	.LVL125:
2644:../uvc.c      ****     }
 1102              		.loc 1 2644 0
 1103 09bc 841083E5 		str	r1, [r3, #132]
2643:../uvc.c      ****         streamingStarted = CyTrue;
 1104              		.loc 1 2643 0
 1105 09c0 012082E0 		add	r2, r2, r1
 1106 09c4 0228A0E1 		mov	r2, r2, asl #16
 1107 09c8 2228A0E1 		mov	r2, r2, lsr #16
 1108 09cc B228C3E1 		strh	r2, [r3, #130]	@ movhi
 1109              	.LVL126:
 1110              	.L163:
2646:../uvc.c      **** 
 1111              		.loc 1 2646 0
 1112 09d0 08D08DE2 		add	sp, sp, #8
 1113              		@ sp needed
 1114 09d4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1115              	.LVL127:
 1116              	.L174:
2591:../uvc.c      ****             {
 1117              		.loc 1 2591 0
 1118 09d8 48319FE5 		ldr	r3, .L177+4
 1119 09dc B420D2E1 		ldrh	r2, [r2, #4]
 1120              	.LVL128:
2605:../uvc.c      ****                 fb++;
 1121              		.loc 1 2605 0
 1122 09e0 006095E5 		ldr	r6, [r5]
2591:../uvc.c      ****             {
 1123              		.loc 1 2591 0
 1124 09e4 030052E1 		cmp	r2, r3
 1125              	.LBB6:
 1126              	.LBB7:
2329:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1127              		.loc 1 2329 0
 1128 09e8 3C019FE5 		ldr	r0, .L177+8
 1129              	.LVL129:
 1130              	.LBE7:
 1131              	.LBE6:
2591:../uvc.c      ****             {
 1132              		.loc 1 2591 0
 1133 09ec 3100000A 		beq	.L175
 1134              	.LBB11:
 1135              	.LBB12:
2329:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1136              		.loc 1 2329 0
 1137 09f0 0010E0E3 		mvn	r1, #0
 1138              	.LVL130:
 1139 09f4 FEFFFFEB 		bl	_txe_mutex_get
 1140              	.LVL131:
2330:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1141              		.loc 1 2330 0
 1142 09f8 0C0046E2 		sub	r0, r6, #12
 1143 09fc 2C119FE5 		ldr	r1, .L177+12
 1144 0a00 0C20A0E3 		mov	r2, #12
 1145 0a04 FEFFFFEB 		bl	CyU3PMemCopy
 1146              	.LVL132:
2331:../uvc.c      **** 
 1147              		.loc 1 2331 0
 1148 0a08 1C019FE5 		ldr	r0, .L177+8
 1149 0a0c FEFFFFEB 		bl	_txe_mutex_put
 1150              	.LVL133:
2336:../uvc.c      ****     }
 1151              		.loc 1 2336 0
 1152 0a10 0B3056E5 		ldrb	r3, [r6, #-11]	@ zero_extendqisi2
 1153              	.LBE12:
 1154              	.LBE11:
2612:../uvc.c      ****                 pbc = input->buffer_p.count;
 1155              		.loc 1 2612 0
 1156 0a14 08419FE5 		ldr	r4, .L177
 1157              	.LBB15:
 1158              	.LBB13:
2336:../uvc.c      ****     }
 1159              		.loc 1 2336 0
 1160 0a18 023083E3 		orr	r3, r3, #2
 1161 0a1c 0B3046E5 		strb	r3, [r6, #-11]
 1162              	.LBE13:
 1163              	.LBE15:
2618:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1164              		.loc 1 2618 0
 1165 0a20 7210D4E5 		ldrb	r1, [r4, #114]	@ zero_extendqisi2
2612:../uvc.c      ****                 pbc = input->buffer_p.count;
 1166              		.loc 1 2612 0
 1167 0a24 B627D4E1 		ldrh	r2, [r4, #118]
2613:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
 1168              		.loc 1 2613 0
 1169 0a28 B430D5E1 		ldrh	r3, [r5, #4]
2612:../uvc.c      ****                 pbc = input->buffer_p.count;
 1170              		.loc 1 2612 0
 1171 0a2c 012082E2 		add	r2, r2, #1
2618:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1172              		.loc 1 2618 0
 1173 0a30 0F0051E3 		cmp	r1, #15
2612:../uvc.c      ****                 pbc = input->buffer_p.count;
 1174              		.loc 1 2612 0
 1175 0a34 B627C4E1 		strh	r2, [r4, #118]	@ movhi
2613:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
 1176              		.loc 1 2613 0
 1177 0a38 B837C4E1 		strh	r3, [r4, #120]	@ movhi
 1178              	.LBB16:
 1179              	.LBB14:
2330:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1180              		.loc 1 2330 0
 1181 0a3c F0609FE5 		ldr	r6, .L177+16
 1182              	.LBE14:
 1183              	.LBE16:
2618:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1184              		.loc 1 2618 0
 1185 0a40 2B00000A 		beq	.L176
 1186              	.L167:
2625:../uvc.c      ****             }
 1187              		.loc 1 2625 0
 1188 0a44 0120A0E3 		mov	r2, #1
 1189 0a48 7C2084E5 		str	r2, [r4, #124]
 1190              	.L166:
2629:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1191              		.loc 1 2629 0
 1192 0a4c B028D4E1 		ldrh	r2, [r4, #128]
2630:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1193              		.loc 1 2630 0
 1194 0a50 0C1083E2 		add	r1, r3, #12
2629:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1195              		.loc 1 2629 0
 1196 0a54 013082E2 		add	r3, r2, #1
2630:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1197              		.loc 1 2630 0
 1198 0a58 0118A0E1 		mov	r1, r1, asl #16
2629:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1199              		.loc 1 2629 0
 1200 0a5c 0338A0E1 		mov	r3, r3, asl #16
2630:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1201              		.loc 1 2630 0
 1202 0a60 2118A0E1 		mov	r1, r1, lsr #16
2629:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1203              		.loc 1 2629 0
 1204 0a64 2338A0E1 		mov	r3, r3, lsr #16
2630:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1205              		.loc 1 2630 0
 1206 0a68 0020A0E3 		mov	r2, #0
 1207 0a6c C4009FE5 		ldr	r0, .L177+20
2629:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1208              		.loc 1 2629 0
 1209 0a70 B038C4E1 		strh	r3, [r4, #128]	@ movhi
2630:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1210              		.loc 1 2630 0
 1211 0a74 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 1212              	.LVL134:
2629:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1213              		.loc 1 2629 0
 1214 0a78 A4109FE5 		ldr	r1, .L177
2633:../uvc.c      ****             {
 1215              		.loc 1 2633 0
 1216 0a7c 002050E2 		subs	r2, r0, #0
 1217 0a80 D2FFFF0A 		beq	.L163
2635:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 1218              		.loc 1 2635 0
 1219 0a84 B008D1E1 		ldrh	r0, [r1, #128]
 1220              	.LVL135:
2636:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
 1221              		.loc 1 2636 0
 1222 0a88 B430D5E1 		ldrh	r3, [r5, #4]
2635:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 1223              		.loc 1 2635 0
 1224 0a8c 010040E2 		sub	r0, r0, #1
 1225 0a90 0008A0E1 		mov	r0, r0, asl #16
 1226 0a94 2008A0E1 		mov	r0, r0, lsr #16
 1227 0a98 B008C1E1 		strh	r0, [r1, #128]	@ movhi
2636:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
 1228              		.loc 1 2636 0
 1229 0a9c B008D1E1 		ldrh	r0, [r1, #128]
 1230 0aa0 B218D1E1 		ldrh	r1, [r1, #130]
 1231 0aa4 03008DE8 		stmia	sp, {r0, r1}
 1232 0aa8 8C109FE5 		ldr	r1, .L177+24
 1233 0aac 0400A0E3 		mov	r0, #4
 1234 0ab0 FEFFFFEB 		bl	CyU3PDebugPrint
 1235              	.LVL136:
 1236 0ab4 C5FFFFEA 		b	.L163
 1237              	.LVL137:
 1238              	.L175:
 1239              	.LBB17:
 1240              	.LBB8:
2329:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1241              		.loc 1 2329 0
 1242 0ab8 0010E0E3 		mvn	r1, #0
 1243              	.LVL138:
 1244              	.LBE8:
 1245              	.LBE17:
2606:../uvc.c      ****             }
 1246              		.loc 1 2606 0
 1247 0abc 60409FE5 		ldr	r4, .L177
 1248              	.LBB18:
 1249              	.LBB9:
2329:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1250              		.loc 1 2329 0
 1251 0ac0 FEFFFFEB 		bl	_txe_mutex_get
 1252              	.LVL139:
 1253              	.LBE9:
 1254              	.LBE18:
2605:../uvc.c      ****                 fb++;
 1255              		.loc 1 2605 0
 1256 0ac4 0C6046E2 		sub	r6, r6, #12
 1257              	.LVL140:
 1258              	.LBB19:
 1259              	.LBB10:
2330:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1260              		.loc 1 2330 0
 1261 0ac8 0C20A0E3 		mov	r2, #12
 1262 0acc 0600A0E1 		mov	r0, r6
 1263 0ad0 58109FE5 		ldr	r1, .L177+12
 1264 0ad4 FEFFFFEB 		bl	CyU3PMemCopy
 1265              	.LVL141:
2331:../uvc.c      **** 
 1266              		.loc 1 2331 0
 1267 0ad8 4C009FE5 		ldr	r0, .L177+8
 1268 0adc FEFFFFEB 		bl	_txe_mutex_put
 1269              	.LVL142:
 1270              	.LBE10:
 1271              	.LBE19:
2606:../uvc.c      ****             }
 1272              		.loc 1 2606 0
 1273 0ae0 B427D4E1 		ldrh	r2, [r4, #116]
 1274 0ae4 B430D5E1 		ldrh	r3, [r5, #4]
 1275 0ae8 012082E2 		add	r2, r2, #1
 1276 0aec B427C4E1 		strh	r2, [r4, #116]	@ movhi
 1277 0af0 D5FFFFEA 		b	.L166
 1278              	.LVL143:
 1279              	.L176:
2619:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 1280              		.loc 1 2619 0
 1281 0af4 0010E0E3 		mvn	r1, #0
 1282 0af8 2C009FE5 		ldr	r0, .L177+8
 1283 0afc FEFFFFEB 		bl	_txe_mutex_get
 1284              	.LVL144:
2620:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 1285              		.loc 1 2620 0
 1286 0b00 ED34D6E5 		ldrb	r3, [r6, #1261]	@ zero_extendqisi2
2621:../uvc.c      ****                 	stiflag = 0xAA;
 1287              		.loc 1 2621 0
 1288 0b04 20009FE5 		ldr	r0, .L177+8
2620:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 1289              		.loc 1 2620 0
 1290 0b08 DF3003E2 		and	r3, r3, #223
 1291 0b0c ED34C6E5 		strb	r3, [r6, #1261]
2621:../uvc.c      ****                 	stiflag = 0xAA;
 1292              		.loc 1 2621 0
 1293 0b10 FEFFFFEB 		bl	_txe_mutex_put
 1294              	.LVL145:
2622:../uvc.c      ****                 }
 1295              		.loc 1 2622 0
 1296 0b14 5530E0E3 		mvn	r3, #85
 1297 0b18 7230C4E5 		strb	r3, [r4, #114]
 1298 0b1c B430D5E1 		ldrh	r3, [r5, #4]
 1299 0b20 C7FFFFEA 		b	.L167
 1300              	.L178:
 1301              		.align	2
 1302              	.L177:
 1303 0b24 00000000 		.word	.LANCHOR0
 1304 0b28 F03F0000 		.word	16368
 1305 0b2c 00000000 		.word	imgHdMux
 1306 0b30 EC040000 		.word	.LANCHOR1+1260
 1307 0b34 00000000 		.word	.LANCHOR1
 1308 0b38 00000000 		.word	glChHandleUVCStream
 1309 0b3c DC010000 		.word	.LC13
 1310              		.cfi_endproc
 1311              	.LFE11:
 1313              		.align	2
 1315              	CyFxUVCApplnUSBEventCB:
 1316              	.LFB9:
2385:../uvc.c      ****     switch (evtype)
 1317              		.loc 1 2385 0
 1318              		.cfi_startproc
 1319              		@ args = 0, pretend = 0, frame = 8
 1320              		@ frame_needed = 0, uses_anonymous_args = 0
 1321              	.LVL146:
2386:../uvc.c      ****     {
 1322              		.loc 1 2386 0
 1323 0b40 020050E3 		cmp	r0, #2
2385:../uvc.c      ****     switch (evtype)
 1324              		.loc 1 2385 0
 1325 0b44 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1326              	.LCFI7:
 1327              		.cfi_def_cfa_offset 16
 1328              		.cfi_offset 4, -16
 1329              		.cfi_offset 5, -12
 1330              		.cfi_offset 6, -8
 1331              		.cfi_offset 14, -4
 1332 0b48 0040A0E1 		mov	r4, r0
 1333 0b4c 10D04DE2 		sub	sp, sp, #16
 1334              	.LCFI8:
 1335              		.cfi_def_cfa_offset 32
2386:../uvc.c      ****     {
 1336              		.loc 1 2386 0
 1337 0b50 3D00000A 		beq	.L181
 1338 0b54 040050E3 		cmp	r0, #4
 1339 0b58 2000000A 		beq	.L182
 1340 0b5c 010050E3 		cmp	r0, #1
 1341 0b60 0100000A 		beq	.L187
 1342              	.LVL147:
 1343              	.L179:
2422:../uvc.c      **** 
 1344              		.loc 1 2422 0
 1345 0b64 10D08DE2 		add	sp, sp, #16
 1346              		@ sp needed
 1347 0b68 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1348              	.LVL148:
 1349              	.L187:
 1350              	.LBB34:
 1351              	.LBB35:
2405:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1352              		.loc 1 2405 0
 1353 0b6c 0130A0E1 		mov	r3, r1
 1354 0b70 0420A0E1 		mov	r2, r4
2407:../uvc.c      ****             isUsbConnected = CyFalse;
 1355              		.loc 1 2407 0
 1356 0b74 40519FE5 		ldr	r5, .L188
2405:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1357              		.loc 1 2405 0
 1358 0b78 40119FE5 		ldr	r1, .L188+4
 1359              	.LVL149:
 1360 0b7c 0400A0E3 		mov	r0, #4
 1361              	.LVL150:
 1362 0b80 FEFFFFEB 		bl	CyU3PDebugPrint
 1363              	.LVL151:
2406:../uvc.c      ****             gpif_initialized = 0;
 1364              		.loc 1 2406 0
 1365 0b84 0400A0E1 		mov	r0, r4
 1366 0b88 FEFFFFEB 		bl	CyU3PGpifDisable
 1367              	.LVL152:
2407:../uvc.c      ****             isUsbConnected = CyFalse;
 1368              		.loc 1 2407 0
 1369 0b8c 00C0A0E3 		mov	ip, #0
 1370              	.LBB36:
 1371              	.LBB37:
2369:../uvc.c      **** 	{
 1372              		.loc 1 2369 0
 1373 0b90 00C08DE5 		str	ip, [sp]
 1374 0b94 0410A0E1 		mov	r1, r4
 1375 0b98 0500A0E1 		mov	r0, r5
 1376 0b9c 0220A0E3 		mov	r2, #2
 1377 0ba0 0C308DE2 		add	r3, sp, #12
 1378              	.LBE37:
 1379              	.LBE36:
2407:../uvc.c      ****             isUsbConnected = CyFalse;
 1380              		.loc 1 2407 0
 1381 0ba4 88C085E5 		str	ip, [r5, #136]
2408:../uvc.c      ****             streamingStarted = CyFalse;
 1382              		.loc 1 2408 0
 1383 0ba8 8CC085E5 		str	ip, [r5, #140]
2409:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1384              		.loc 1 2409 0
 1385 0bac 84C085E5 		str	ip, [r5, #132]
 1386              	.LBB41:
 1387              	.LBB40:
2369:../uvc.c      **** 	{
 1388              		.loc 1 2369 0
 1389 0bb0 FEFFFFEB 		bl	_txe_event_flags_get
 1390              	.LVL153:
 1391 0bb4 004050E2 		subs	r4, r0, #0
 1392 0bb8 E9FFFF1A 		bne	.L179
 1393              	.LBB38:
 1394              	.LBB39:
2372:../uvc.c      **** 
 1395              		.loc 1 2372 0
 1396 0bbc 0500A0E1 		mov	r0, r5
 1397 0bc0 0110E0E3 		mvn	r1, #1
 1398 0bc4 0220A0E3 		mov	r2, #2
 1399 0bc8 FEFFFFEB 		bl	_txe_event_flags_set
 1400              	.LVL154:
2375:../uvc.c      **** 	}
 1401              		.loc 1 2375 0
 1402 0bcc 0500A0E1 		mov	r0, r5
 1403 0bd0 0420A0E1 		mov	r2, r4
 1404 0bd4 0210A0E3 		mov	r1, #2
 1405 0bd8 FEFFFFEB 		bl	_txe_event_flags_set
 1406              	.LVL155:
 1407 0bdc E0FFFFEA 		b	.L179
 1408              	.LVL156:
 1409              	.L182:
 1410              	.LBE39:
 1411              	.LBE38:
 1412              	.LBE40:
 1413              	.LBE41:
 1414              	.LBE35:
 1415              	.LBE34:
2389:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1416              		.loc 1 2389 0
 1417 0be0 0130A0E1 		mov	r3, r1
 1418 0be4 0020A0E1 		mov	r2, r0
 1419 0be8 D4109FE5 		ldr	r1, .L188+8
 1420              	.LVL157:
 1421 0bec FEFFFFEB 		bl	CyU3PDebugPrint
 1422              	.LVL158:
2391:../uvc.c      ****             streamingStarted = CyFalse;
 1423              		.loc 1 2391 0
 1424 0bf0 C4409FE5 		ldr	r4, .L188
2390:../uvc.c      ****             gpif_initialized = 0;
 1425              		.loc 1 2390 0
 1426 0bf4 0100A0E3 		mov	r0, #1
 1427 0bf8 FEFFFFEB 		bl	CyU3PGpifDisable
 1428              	.LVL159:
2391:../uvc.c      ****             streamingStarted = CyFalse;
 1429              		.loc 1 2391 0
 1430 0bfc 00C0A0E3 		mov	ip, #0
 1431              	.LBB42:
 1432              	.LBB43:
2369:../uvc.c      **** 	{
 1433              		.loc 1 2369 0
 1434 0c00 00C08DE5 		str	ip, [sp]
 1435 0c04 0400A0E1 		mov	r0, r4
 1436 0c08 0110A0E3 		mov	r1, #1
 1437 0c0c 0220A0E3 		mov	r2, #2
 1438 0c10 0C308DE2 		add	r3, sp, #12
 1439              	.LBE43:
 1440              	.LBE42:
2391:../uvc.c      ****             streamingStarted = CyFalse;
 1441              		.loc 1 2391 0
 1442 0c14 88C084E5 		str	ip, [r4, #136]
2392:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1443              		.loc 1 2392 0
 1444 0c18 84C084E5 		str	ip, [r4, #132]
 1445              	.LBB47:
 1446              	.LBB46:
2369:../uvc.c      **** 	{
 1447              		.loc 1 2369 0
 1448 0c1c FEFFFFEB 		bl	_txe_event_flags_get
 1449              	.LVL160:
 1450 0c20 005050E2 		subs	r5, r0, #0
 1451 0c24 CEFFFF1A 		bne	.L179
 1452              	.LBB44:
 1453              	.LBB45:
2372:../uvc.c      **** 
 1454              		.loc 1 2372 0
 1455 0c28 0400A0E1 		mov	r0, r4
 1456 0c2c 0110E0E3 		mvn	r1, #1
 1457 0c30 0220A0E3 		mov	r2, #2
 1458 0c34 FEFFFFEB 		bl	_txe_event_flags_set
 1459              	.LVL161:
2375:../uvc.c      **** 	}
 1460              		.loc 1 2375 0
 1461 0c38 0400A0E1 		mov	r0, r4
 1462 0c3c 0520A0E1 		mov	r2, r5
 1463 0c40 0210A0E3 		mov	r1, #2
 1464 0c44 FEFFFFEB 		bl	_txe_event_flags_set
 1465              	.LVL162:
 1466 0c48 C5FFFFEA 		b	.L179
 1467              	.LVL163:
 1468              	.L181:
 1469              	.LBE45:
 1470              	.LBE44:
 1471              	.LBE46:
 1472              	.LBE47:
2397:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1473              		.loc 1 2397 0
 1474 0c4c 0130A0E1 		mov	r3, r1
 1475 0c50 0420A0E1 		mov	r2, r4
 1476 0c54 6C109FE5 		ldr	r1, .L188+12
 1477              	.LVL164:
2399:../uvc.c      ****             streamingStarted = CyFalse;
 1478              		.loc 1 2399 0
 1479 0c58 5C509FE5 		ldr	r5, .L188
2397:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1480              		.loc 1 2397 0
 1481 0c5c 0400A0E3 		mov	r0, #4
 1482              	.LVL165:
 1483 0c60 FEFFFFEB 		bl	CyU3PDebugPrint
 1484              	.LVL166:
2398:../uvc.c      ****             gpif_initialized = 0;
 1485              		.loc 1 2398 0
 1486 0c64 0100A0E3 		mov	r0, #1
 1487 0c68 FEFFFFEB 		bl	CyU3PGpifDisable
 1488              	.LVL167:
2399:../uvc.c      ****             streamingStarted = CyFalse;
 1489              		.loc 1 2399 0
 1490 0c6c 00C0A0E3 		mov	ip, #0
 1491              	.LBB48:
 1492              	.LBB49:
2369:../uvc.c      **** 	{
 1493              		.loc 1 2369 0
 1494 0c70 00C08DE5 		str	ip, [sp]
 1495 0c74 0500A0E1 		mov	r0, r5
 1496 0c78 0110A0E3 		mov	r1, #1
 1497 0c7c 0420A0E1 		mov	r2, r4
 1498 0c80 0C308DE2 		add	r3, sp, #12
 1499              	.LBE49:
 1500              	.LBE48:
2399:../uvc.c      ****             streamingStarted = CyFalse;
 1501              		.loc 1 2399 0
 1502 0c84 88C085E5 		str	ip, [r5, #136]
2400:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1503              		.loc 1 2400 0
 1504 0c88 84C085E5 		str	ip, [r5, #132]
 1505              	.LBB53:
 1506              	.LBB52:
2369:../uvc.c      **** 	{
 1507              		.loc 1 2369 0
 1508 0c8c FEFFFFEB 		bl	_txe_event_flags_get
 1509              	.LVL168:
 1510 0c90 006050E2 		subs	r6, r0, #0
 1511 0c94 B2FFFF1A 		bne	.L179
 1512              	.LBB50:
 1513              	.LBB51:
2372:../uvc.c      **** 
 1514              		.loc 1 2372 0
 1515 0c98 0420A0E1 		mov	r2, r4
 1516 0c9c 0500A0E1 		mov	r0, r5
 1517 0ca0 0110E0E3 		mvn	r1, #1
 1518 0ca4 FEFFFFEB 		bl	_txe_event_flags_set
 1519              	.LVL169:
2375:../uvc.c      **** 	}
 1520              		.loc 1 2375 0
 1521 0ca8 0500A0E1 		mov	r0, r5
 1522 0cac 0410A0E1 		mov	r1, r4
 1523 0cb0 0620A0E1 		mov	r2, r6
 1524 0cb4 FEFFFFEB 		bl	_txe_event_flags_set
 1525              	.LVL170:
 1526 0cb8 A9FFFFEA 		b	.L179
 1527              	.L189:
 1528              		.align	2
 1529              	.L188:
 1530 0cbc 00000000 		.word	.LANCHOR0
 1531 0cc0 6C020000 		.word	.LC16
 1532 0cc4 28020000 		.word	.LC14
 1533 0cc8 48020000 		.word	.LC15
 1534              	.LBE51:
 1535              	.LBE50:
 1536              	.LBE52:
 1537              	.LBE53:
 1538              		.cfi_endproc
 1539              	.LFE9:
 1541              		.align	2
 1543              	CyFxUVCApplnUSBSetupCB:
 1544              	.LFB10:
2430:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1545              		.loc 1 2430 0
 1546              		.cfi_startproc
 1547              		@ args = 0, pretend = 0, frame = 8
 1548              		@ frame_needed = 0, uses_anonymous_args = 0
 1549              	.LVL171:
 1550 0ccc F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
 1551              	.LCFI9:
 1552              		.cfi_def_cfa_offset 28
 1553              		.cfi_offset 4, -28
 1554              		.cfi_offset 5, -24
 1555              		.cfi_offset 6, -20
 1556              		.cfi_offset 7, -16
 1557              		.cfi_offset 8, -12
 1558              		.cfi_offset 9, -8
 1559              		.cfi_offset 14, -4
2439:../uvc.c      **** 
 1560              		.loc 1 2439 0
 1561 0cd0 B0C29FE5 		ldr	ip, .L224
2436:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1562              		.loc 1 2436 0
 1563 0cd4 B0929FE5 		ldr	r9, .L224+4
2438:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1564              		.loc 1 2438 0
 1565 0cd8 B0829FE5 		ldr	r8, .L224+8
2435:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1566              		.loc 1 2435 0
 1567 0cdc B0229FE5 		ldr	r2, .L224+12
2437:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1568              		.loc 1 2437 0
 1569 0ce0 B0329FE5 		ldr	r3, .L224+16
2438:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1570              		.loc 1 2438 0
 1571 0ce4 0168A0E1 		mov	r6, r1, asl #16
2435:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1572              		.loc 1 2435 0
 1573 0ce8 FF4000E2 		and	r4, r0, #255
2436:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1574              		.loc 1 2436 0
 1575 0cec FF5C00E2 		and	r5, r0, #65280
 1576 0cf0 2554A0E1 		mov	r5, r5, lsr #8
2438:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1577              		.loc 1 2438 0
 1578 0cf4 2668A0E1 		mov	r6, r6, lsr #16
2439:../uvc.c      **** 
 1579              		.loc 1 2439 0
 1580 0cf8 2118A0E1 		mov	r1, r1, lsr #16
 1581              	.LVL172:
2437:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1582              		.loc 1 2437 0
 1583 0cfc 2078A0E1 		mov	r7, r0, lsr #16
2442:../uvc.c      ****     {
 1584              		.loc 1 2442 0
 1585 0d00 020054E3 		cmp	r4, #2
2430:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1586              		.loc 1 2430 0
 1587 0d04 14D04DE2 		sub	sp, sp, #20
 1588              	.LCFI10:
 1589              		.cfi_def_cfa_offset 48
2436:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1590              		.loc 1 2436 0
 1591 0d08 0050C9E5 		strb	r5, [r9]
2438:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1592              		.loc 1 2438 0
 1593 0d0c B060C8E1 		strh	r6, [r8]	@ movhi
2439:../uvc.c      **** 
 1594              		.loc 1 2439 0
 1595 0d10 B010CCE1 		strh	r1, [ip]	@ movhi
2435:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1596              		.loc 1 2435 0
 1597 0d14 0040C2E5 		strb	r4, [r2]
2437:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1598              		.loc 1 2437 0
 1599 0d18 B070C3E1 		strh	r7, [r3]	@ movhi
2442:../uvc.c      ****     {
 1600              		.loc 1 2442 0
 1601 0d1c 4A00000A 		beq	.L192
 1602 0d20 0600009A 		bls	.L221
 1603 0d24 210054E3 		cmp	r4, #33
 1604 0d28 3900000A 		beq	.L195
 1605 0d2c A10054E3 		cmp	r4, #161
 1606 0d30 3700000A 		beq	.L195
 1607              	.L209:
2431:../uvc.c      ****     uint32_t status;
 1608              		.loc 1 2431 0
 1609 0d34 0000A0E3 		mov	r0, #0
 1610              	.LVL173:
 1611              	.L191:
2569:../uvc.c      **** 
 1612              		.loc 1 2569 0
 1613 0d38 14D08DE2 		add	sp, sp, #20
 1614              		@ sp needed
 1615 0d3c F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1616              	.LVL174:
 1617              	.L221:
2442:../uvc.c      ****     {
 1618              		.loc 1 2442 0
 1619 0d40 010054E3 		cmp	r4, #1
 1620 0d44 FAFFFF1A 		bne	.L209
2482:../uvc.c      ****             {
 1621              		.loc 1 2482 0
 1622 0d48 0B0055E3 		cmp	r5, #11
 1623 0d4c F8FFFF1A 		bne	.L209
2486:../uvc.c      ****                 {
 1624              		.loc 1 2486 0
 1625 0d50 010056E3 		cmp	r6, #1
 1626 0d54 F6FFFF1A 		bne	.L209
2486:../uvc.c      ****                 {
 1627              		.loc 1 2486 0 is_stmt 0 discriminator 1
 1628 0d58 000057E3 		cmp	r7, #0
 1629 0d5c F4FFFF1A 		bne	.L209
2491:../uvc.c      ****                     streamingStarted = CyFalse;
 1630              		.loc 1 2491 0 is_stmt 1
 1631 0d60 34429FE5 		ldr	r4, .L224+20
2489:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 1632              		.loc 1 2489 0
 1633 0d64 34129FE5 		ldr	r1, .L224+24
 1634 0d68 0400A0E3 		mov	r0, #4
 1635              	.LVL175:
 1636 0d6c FEFFFFEB 		bl	CyU3PDebugPrint
 1637              	.LVL176:
2490:../uvc.c      ****                     gpif_initialized = 0;
 1638              		.loc 1 2490 0
 1639 0d70 0600A0E1 		mov	r0, r6
 1640 0d74 FEFFFFEB 		bl	CyU3PGpifDisable
 1641              	.LVL177:
2494:../uvc.c      ****                     CyU3PBusyWait (100);
 1642              		.loc 1 2494 0
 1643 0d78 0610A0E1 		mov	r1, r6
 1644 0d7c 8300A0E3 		mov	r0, #131
2491:../uvc.c      ****                     streamingStarted = CyFalse;
 1645              		.loc 1 2491 0
 1646 0d80 887084E5 		str	r7, [r4, #136]
2492:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
 1647              		.loc 1 2492 0
 1648 0d84 847084E5 		str	r7, [r4, #132]
2494:../uvc.c      ****                     CyU3PBusyWait (100);
 1649              		.loc 1 2494 0
 1650 0d88 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1651              	.LVL178:
2495:../uvc.c      **** 
 1652              		.loc 1 2495 0
 1653 0d8c 6400A0E3 		mov	r0, #100
 1654 0d90 FEFFFFEB 		bl	CyFx3BusyWait
 1655              	.LVL179:
2498:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1656              		.loc 1 2498 0
 1657 0d94 08029FE5 		ldr	r0, .L224+28
 1658 0d98 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1659              	.LVL180:
2499:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1660              		.loc 1 2499 0
 1661 0d9c 8300A0E3 		mov	r0, #131
 1662 0da0 FEFFFFEB 		bl	CyU3PUsbFlushEp
 1663              	.LVL181:
2500:../uvc.c      ****                     CyU3PBusyWait (100);
 1664              		.loc 1 2500 0
 1665 0da4 0710A0E1 		mov	r1, r7
 1666 0da8 8300A0E3 		mov	r0, #131
 1667 0dac FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1668              	.LVL182:
2501:../uvc.c      **** 
 1669              		.loc 1 2501 0
 1670 0db0 6400A0E3 		mov	r0, #100
 1671 0db4 FEFFFFEB 		bl	CyFx3BusyWait
 1672              	.LVL183:
2504:../uvc.c      ****                     uvcHandleReq = CyTrue;
 1673              		.loc 1 2504 0
 1674 0db8 0710A0E1 		mov	r1, r7
 1675 0dbc 0620A0E1 		mov	r2, r6
 1676 0dc0 8300A0E3 		mov	r0, #131
 1677 0dc4 FEFFFFEB 		bl	CyU3PUsbStall
 1678              	.LVL184:
2507:../uvc.c      ****                     /* Indicate stop streaming to main thread */
 1679              		.loc 1 2507 0
 1680 0dc8 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1681              	.LVL185:
 1682              	.LBB62:
 1683              	.LBB63:
2369:../uvc.c      **** 	{
 1684              		.loc 1 2369 0
 1685 0dcc 00708DE5 		str	r7, [sp]
 1686 0dd0 0610A0E1 		mov	r1, r6
 1687 0dd4 0400A0E1 		mov	r0, r4
 1688 0dd8 0220A0E3 		mov	r2, #2
 1689 0ddc 0C308DE2 		add	r3, sp, #12
 1690              	.LBE63:
 1691              	.LBE62:
2509:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
 1692              		.loc 1 2509 0
 1693 0de0 906084E5 		str	r6, [r4, #144]
 1694              	.LBB67:
 1695              	.LBB66:
2369:../uvc.c      **** 	{
 1696              		.loc 1 2369 0
 1697 0de4 FEFFFFEB 		bl	_txe_event_flags_get
 1698              	.LVL186:
 1699 0de8 005050E2 		subs	r5, r0, #0
 1700 0dec 1300001A 		bne	.L220
 1701              	.LBB64:
 1702              	.LBB65:
2372:../uvc.c      **** 
 1703              		.loc 1 2372 0
 1704 0df0 0400A0E1 		mov	r0, r4
 1705 0df4 0110E0E3 		mvn	r1, #1
 1706 0df8 0220A0E3 		mov	r2, #2
 1707 0dfc FEFFFFEB 		bl	_txe_event_flags_set
 1708              	.LVL187:
2375:../uvc.c      **** 	}
 1709              		.loc 1 2375 0
 1710 0e00 0400A0E1 		mov	r0, r4
 1711 0e04 0520A0E1 		mov	r2, r5
 1712 0e08 0210A0E3 		mov	r1, #2
 1713 0e0c FEFFFFEB 		bl	_txe_event_flags_set
 1714              	.LVL188:
 1715 0e10 0A0000EA 		b	.L220
 1716              	.LVL189:
 1717              	.L195:
 1718              	.LBE65:
 1719              	.LBE64:
 1720              	.LBE66:
 1721              	.LBE67:
2447:../uvc.c      ****             {
 1722              		.loc 1 2447 0
 1723 0e14 FF6006E2 		and	r6, r6, #255
 1724 0e18 000056E3 		cmp	r6, #0
 1725 0e1c 1500000A 		beq	.L196
 1726 0e20 010056E3 		cmp	r6, #1
 1727 0e24 C2FFFF1A 		bne	.L209
 1728              	.LVL190:
2465:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1729              		.loc 1 2465 0
 1730 0e28 0020A0E3 		mov	r2, #0
 1731 0e2c 68019FE5 		ldr	r0, .L224+20
 1732              	.LVL191:
 1733 0e30 0810A0E3 		mov	r1, #8
 1734 0e34 FEFFFFEB 		bl	_txe_event_flags_set
 1735              	.LVL192:
2467:../uvc.c      ****                         {
 1736              		.loc 1 2467 0
 1737 0e38 002050E2 		subs	r2, r0, #0
 1738 0e3c 1B00001A 		bne	.L222
 1739              	.LVL193:
 1740              	.L220:
2451:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 1741              		.loc 1 2451 0
 1742 0e40 0100A0E3 		mov	r0, #1
 1743              	.LVL194:
2569:../uvc.c      **** 
 1744              		.loc 1 2569 0
 1745 0e44 14D08DE2 		add	sp, sp, #20
 1746              		@ sp needed
 1747 0e48 F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1748              	.LVL195:
 1749              	.L192:
2517:../uvc.c      ****             {
 1750              		.loc 1 2517 0
 1751 0e4c 010055E3 		cmp	r5, #1
 1752 0e50 B7FFFF1A 		bne	.L209
2519:../uvc.c      ****                 {
 1753              		.loc 1 2519 0
 1754 0e54 830056E3 		cmp	r6, #131
 1755 0e58 B5FFFF1A 		bne	.L209
2525:../uvc.c      ****                     {
 1756              		.loc 1 2525 0
 1757 0e5c 38819FE5 		ldr	r8, .L224+20
 1758 0e60 847098E5 		ldr	r7, [r8, #132]
 1759 0e64 010057E3 		cmp	r7, #1
 1760 0e68 1900000A 		beq	.L223
 1761              	.LVL196:
2557:../uvc.c      ****                     }
 1762              		.loc 1 2557 0
 1763 0e6c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1764              	.LVL197:
2556:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1765              		.loc 1 2556 0
 1766 0e70 0500A0E1 		mov	r0, r5
 1767 0e74 AFFFFFEA 		b	.L191
 1768              	.LVL198:
 1769              	.L196:
2452:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1770              		.loc 1 2452 0
 1771 0e78 0620A0E1 		mov	r2, r6
 1772 0e7c 18019FE5 		ldr	r0, .L224+20
 1773              	.LVL199:
 1774 0e80 0410A0E3 		mov	r1, #4
 1775 0e84 FEFFFFEB 		bl	_txe_event_flags_set
 1776              	.LVL200:
2454:../uvc.c      ****                         {
 1777              		.loc 1 2454 0
 1778 0e88 002050E2 		subs	r2, r0, #0
 1779 0e8c EBFFFF0A 		beq	.L220
2456:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1780              		.loc 1 2456 0
 1781 0e90 10119FE5 		ldr	r1, .L224+32
 1782 0e94 0400A0E3 		mov	r0, #4
 1783              	.LVL201:
 1784 0e98 FEFFFFEB 		bl	CyU3PDebugPrint
 1785              	.LVL202:
2457:../uvc.c      ****                         }
 1786              		.loc 1 2457 0
 1787 0e9c 0600A0E1 		mov	r0, r6
 1788 0ea0 0620A0E1 		mov	r2, r6
 1789 0ea4 0110A0E3 		mov	r1, #1
 1790 0ea8 FEFFFFEB 		bl	CyU3PUsbStall
 1791              	.LVL203:
 1792 0eac E3FFFFEA 		b	.L220
 1793              	.LVL204:
 1794              	.L222:
2470:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1795              		.loc 1 2470 0
 1796 0eb0 F4109FE5 		ldr	r1, .L224+36
 1797 0eb4 0400A0E3 		mov	r0, #4
 1798              	.LVL205:
 1799 0eb8 FEFFFFEB 		bl	CyU3PDebugPrint
 1800              	.LVL206:
2471:../uvc.c      ****                         }
 1801              		.loc 1 2471 0
 1802 0ebc 0000A0E3 		mov	r0, #0
 1803 0ec0 0020A0E1 		mov	r2, r0
 1804 0ec4 0610A0E1 		mov	r1, r6
 1805 0ec8 FEFFFFEB 		bl	CyU3PUsbStall
 1806              	.LVL207:
2464:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 1807              		.loc 1 2464 0
 1808 0ecc 0600A0E1 		mov	r0, r6
 1809 0ed0 98FFFFEA 		b	.L191
 1810              	.LVL208:
 1811              	.L223:
2527:../uvc.c      **** 
 1812              		.loc 1 2527 0
 1813 0ed4 D4109FE5 		ldr	r1, .L224+40
 1814 0ed8 0400A0E3 		mov	r0, #4
 1815              	.LVL209:
 1816 0edc FEFFFFEB 		bl	CyU3PDebugPrint
 1817              	.LVL210:
2530:../uvc.c      ****                         gpif_initialized = 0;
 1818              		.loc 1 2530 0
 1819 0ee0 0700A0E1 		mov	r0, r7
 1820 0ee4 FEFFFFEB 		bl	CyU3PGpifDisable
 1821              	.LVL211:
2531:../uvc.c      ****                         streamingStarted = CyFalse;
 1822              		.loc 1 2531 0
 1823 0ee8 0050A0E3 		mov	r5, #0
2535:../uvc.c      ****                         CyU3PBusyWait (100);
 1824              		.loc 1 2535 0
 1825 0eec 0710A0E1 		mov	r1, r7
 1826 0ef0 0600A0E1 		mov	r0, r6
2531:../uvc.c      ****                         streamingStarted = CyFalse;
 1827              		.loc 1 2531 0
 1828 0ef4 885088E5 		str	r5, [r8, #136]
2532:../uvc.c      **** 
 1829              		.loc 1 2532 0
 1830 0ef8 845088E5 		str	r5, [r8, #132]
2535:../uvc.c      ****                         CyU3PBusyWait (100);
 1831              		.loc 1 2535 0
 1832 0efc FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1833              	.LVL212:
2536:../uvc.c      **** 
 1834              		.loc 1 2536 0
 1835 0f00 6400A0E3 		mov	r0, #100
 1836 0f04 FEFFFFEB 		bl	CyFx3BusyWait
 1837              	.LVL213:
2539:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1838              		.loc 1 2539 0
 1839 0f08 94009FE5 		ldr	r0, .L224+28
 1840 0f0c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1841              	.LVL214:
2540:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1842              		.loc 1 2540 0
 1843 0f10 0600A0E1 		mov	r0, r6
 1844 0f14 FEFFFFEB 		bl	CyU3PUsbFlushEp
 1845              	.LVL215:
2541:../uvc.c      ****                         CyU3PBusyWait (100);
 1846              		.loc 1 2541 0
 1847 0f18 0510A0E1 		mov	r1, r5
 1848 0f1c 0600A0E1 		mov	r0, r6
 1849 0f20 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1850              	.LVL216:
2542:../uvc.c      **** 
 1851              		.loc 1 2542 0
 1852 0f24 6400A0E3 		mov	r0, #100
 1853 0f28 FEFFFFEB 		bl	CyFx3BusyWait
 1854              	.LVL217:
2545:../uvc.c      **** 
 1855              		.loc 1 2545 0
 1856 0f2c 0510A0E1 		mov	r1, r5
 1857 0f30 0720A0E1 		mov	r2, r7
 1858 0f34 0600A0E1 		mov	r0, r6
 1859 0f38 FEFFFFEB 		bl	CyU3PUsbStall
 1860              	.LVL218:
2549:../uvc.c      ****                         /* Indicate stop streaming to main thread */
 1861              		.loc 1 2549 0
 1862 0f3c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1863              	.LVL219:
 1864              	.LBB68:
 1865              	.LBB69:
2369:../uvc.c      **** 	{
 1866              		.loc 1 2369 0
 1867 0f40 00508DE5 		str	r5, [sp]
 1868 0f44 0710A0E1 		mov	r1, r7
 1869 0f48 0800A0E1 		mov	r0, r8
 1870 0f4c 0420A0E1 		mov	r2, r4
 1871 0f50 0C308DE2 		add	r3, sp, #12
 1872              	.LBE69:
 1873              	.LBE68:
2551:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
 1874              		.loc 1 2551 0
 1875 0f54 907088E5 		str	r7, [r8, #144]
 1876              	.LBB73:
 1877              	.LBB72:
2369:../uvc.c      **** 	{
 1878              		.loc 1 2369 0
 1879 0f58 FEFFFFEB 		bl	_txe_event_flags_get
 1880              	.LVL220:
 1881 0f5c 005050E2 		subs	r5, r0, #0
 1882 0f60 B6FFFF1A 		bne	.L220
 1883              	.LBB70:
 1884              	.LBB71:
2372:../uvc.c      **** 
 1885              		.loc 1 2372 0
 1886 0f64 0420A0E1 		mov	r2, r4
 1887 0f68 0800A0E1 		mov	r0, r8
 1888 0f6c 0110E0E3 		mvn	r1, #1
 1889 0f70 FEFFFFEB 		bl	_txe_event_flags_set
 1890              	.LVL221:
2375:../uvc.c      **** 	}
 1891              		.loc 1 2375 0
 1892 0f74 0800A0E1 		mov	r0, r8
 1893 0f78 0410A0E1 		mov	r1, r4
 1894 0f7c 0520A0E1 		mov	r2, r5
 1895 0f80 FEFFFFEB 		bl	_txe_event_flags_set
 1896              	.LVL222:
 1897 0f84 ADFFFFEA 		b	.L220
 1898              	.L225:
 1899              		.align	2
 1900              	.L224:
 1901 0f88 00000000 		.word	wLength
 1902 0f8c 00000000 		.word	bRequest
 1903 0f90 00000000 		.word	wIndex
 1904 0f94 00000000 		.word	bmReqType
 1905 0f98 00000000 		.word	wValue
 1906 0f9c 00000000 		.word	.LANCHOR0
 1907 0fa0 F8020000 		.word	.LC19
 1908 0fa4 00000000 		.word	glChHandleUVCStream
 1909 0fa8 8C020000 		.word	.LC17
 1910 0fac C4020000 		.word	.LC18
 1911 0fb0 10030000 		.word	.LC20
 1912              	.LBE71:
 1913              	.LBE70:
 1914              	.LBE72:
 1915              	.LBE73:
 1916              		.cfi_endproc
 1917              	.LFE10:
 1919              		.align	2
 1920              		.global	I2CCmdHandler
 1922              	I2CCmdHandler:
 1923              	.LFB0:
 784:../uvc.c      **** 	uint8_t buf[2];
 1924              		.loc 1 784 0
 1925              		.cfi_startproc
 1926              		@ args = 0, pretend = 0, frame = 8
 1927              		@ frame_needed = 0, uses_anonymous_args = 0
 1928 0fb4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1929              	.LCFI11:
 1930              		.cfi_def_cfa_offset 36
 1931              		.cfi_offset 4, -36
 1932              		.cfi_offset 5, -32
 1933              		.cfi_offset 6, -28
 1934              		.cfi_offset 7, -24
 1935              		.cfi_offset 8, -20
 1936              		.cfi_offset 9, -16
 1937              		.cfi_offset 10, -12
 1938              		.cfi_offset 11, -8
 1939              		.cfi_offset 14, -4
 787:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1940              		.loc 1 787 0
 1941 0fb8 F8419FE5 		ldr	r4, .L248
 784:../uvc.c      **** 	uint8_t buf[2];
 1942              		.loc 1 784 0
 1943 0fbc 34D04DE2 		sub	sp, sp, #52
 1944              	.LCFI12:
 1945              		.cfi_def_cfa_offset 88
 792:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1946              		.loc 1 792 0
 1947 0fc0 9A30D4E5 		ldrb	r3, [r4, #154]	@ zero_extendqisi2
 787:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1948              		.loc 1 787 0
 1949 0fc4 9450D4E5 		ldrb	r5, [r4, #148]	@ zero_extendqisi2
 1950              	.LVL223:
 788:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1951              		.loc 1 788 0
 1952 0fc8 9570D4E5 		ldrb	r7, [r4, #149]	@ zero_extendqisi2
 1953              	.LVL224:
 789:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 1954              		.loc 1 789 0
 1955 0fcc 9C60D4E5 		ldrb	r6, [r4, #156]	@ zero_extendqisi2
 1956              	.LVL225:
 792:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1957              		.loc 1 792 0
 1958 0fd0 96B0D4E5 		ldrb	fp, [r4, #150]	@ zero_extendqisi2
 1959 0fd4 97A0D4E5 		ldrb	r10, [r4, #151]	@ zero_extendqisi2
 1960 0fd8 9890D4E5 		ldrb	r9, [r4, #152]	@ zero_extendqisi2
 1961 0fdc 9980D4E5 		ldrb	r8, [r4, #153]	@ zero_extendqisi2
 1962 0fe0 10308DE5 		str	r3, [sp, #16]
 1963 0fe4 9E10D4E5 		ldrb	r1, [r4, #158]	@ zero_extendqisi2
 1964 0fe8 9BE0D4E5 		ldrb	lr, [r4, #155]	@ zero_extendqisi2
 1965 0fec 9DC0D4E5 		ldrb	ip, [r4, #157]	@ zero_extendqisi2
 1966 0ff0 0730A0E1 		mov	r3, r7
 1967 0ff4 20108DE5 		str	r1, [sp, #32]
 1968 0ff8 0400A0E3 		mov	r0, #4
 1969 0ffc 0520A0E1 		mov	r2, r5
 1970 1000 18608DE5 		str	r6, [sp, #24]
 1971 1004 00B08DE5 		str	fp, [sp]
 1972 1008 04A08DE5 		str	r10, [sp, #4]
 1973 100c 08908DE5 		str	r9, [sp, #8]
 1974 1010 0C808DE5 		str	r8, [sp, #12]
 1975 1014 14E08DE5 		str	lr, [sp, #20]
 1976 1018 1CC08DE5 		str	ip, [sp, #28]
 1977 101c 98119FE5 		ldr	r1, .L248+4
 1978 1020 FEFFFFEB 		bl	CyU3PDebugPrint
 1979              	.LVL226:
 795:../uvc.c      **** 	{
 1980              		.loc 1 795 0
 1981 1024 9730D4E5 		ldrb	r3, [r4, #151]	@ zero_extendqisi2
 1982 1028 520053E3 		cmp	r3, #82
 1983 102c 2D00000A 		beq	.L243
 1984              	.L227:
 805:../uvc.c      **** 	{
 1985              		.loc 1 805 0
 1986 1030 000055E3 		cmp	r5, #0
 1987 1034 1600000A 		beq	.L244
 830:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 1988              		.loc 1 830 0
 1989 1038 010055E3 		cmp	r5, #1
 1990 103c 0100000A 		beq	.L245
 1991              	.LVL227:
 1992              	.L226:
 849:../uvc.c      **** 
 1993              		.loc 1 849 0
 1994 1040 34D08DE2 		add	sp, sp, #52
 1995              		@ sp needed
 1996 1044 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1997              	.LVL228:
 1998              	.L245:
 832:../uvc.c      **** 				for(i = 0; i<4; i++)
 1999              		.loc 1 832 0
 2000 1048 020057E3 		cmp	r7, #2
 2001 104c 3800000A 		beq	.L246
 837:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2002              		.loc 1 837 0
 2003 1050 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2004 1054 5C019FE5 		ldr	r0, .L248
 2005 1058 FE1001E2 		and	r1, r1, #254
 2006 105c 820051E3 		cmp	r1, #130
 2007 1060 0200001A 		bne	.L236
 837:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2008              		.loc 1 837 0 is_stmt 0 discriminator 1
 2009 1064 9850D0E5 		ldrb	r5, [r0, #152]	@ zero_extendqisi2
 2010              	.LVL229:
 2011 1068 300055E3 		cmp	r5, #48
 2012 106c 3D00000A 		beq	.L247
 2013              	.L236:
 2014 1070 9820D4E5 		ldrb	r2, [r4, #152]	@ zero_extendqisi2
 2015 1074 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2016              	.LVL230:
 2017              	.L237:
 842:../uvc.c      **** 			}
 2018              		.loc 1 842 0 is_stmt 1
 2019 1078 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2020 107c 9DC0D4E5 		ldrb	ip, [r4, #157]	@ zero_extendqisi2
 2021 1080 FE0000E2 		and	r0, r0, #254
 2022 1084 00C08DE5 		str	ip, [sp]
 2023 1088 FEFFFFEB 		bl	SensorWrite2B
 2024              	.LVL231:
 849:../uvc.c      **** 
 2025              		.loc 1 849 0
 2026 108c 34D08DE2 		add	sp, sp, #52
 2027              		@ sp needed
 2028 1090 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2029              	.LVL232:
 2030              	.L244:
 821:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2031              		.loc 1 821 0
 2032 1094 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2033 1098 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2034 109c 28C08DE2 		add	ip, sp, #40
 2035 10a0 9820D4E5 		ldrb	r2, [r4, #152]	@ zero_extendqisi2
 2036 10a4 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2037 10a8 00C08DE5 		str	ip, [sp]
 807:../uvc.c      **** #if 0 //for debugging
 2038              		.loc 1 807 0
 2039 10ac 0FC0A0E3 		mov	ip, #15
 821:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2040              		.loc 1 821 0
 2041 10b0 011081E3 		orr	r1, r1, #1
 807:../uvc.c      **** #if 0 //for debugging
 2042              		.loc 1 807 0
 2043 10b4 9FC0C4E5 		strb	ip, [r4, #159]
 821:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2044              		.loc 1 821 0
 2045 10b8 010080E3 		orr	r0, r0, #1
 2046 10bc FEFFFFEB 		bl	SensorRead2B
 2047              	.LVL233:
 822:../uvc.c      **** 				if(CmdDataLen == 2){
 2048              		.loc 1 822 0
 2049 10c0 2830DDE5 		ldrb	r3, [sp, #40]	@ zero_extendqisi2
 823:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 2050              		.loc 1 823 0
 2051 10c4 020056E3 		cmp	r6, #2
 822:../uvc.c      **** 				if(CmdDataLen == 2){
 2052              		.loc 1 822 0
 2053 10c8 9D30C4E5 		strb	r3, [r4, #157]
 824:../uvc.c      **** 				}
 2054              		.loc 1 824 0
 2055 10cc 2920DD05 		ldreqb	r2, [sp, #41]	@ zero_extendqisi2
 807:../uvc.c      **** #if 0 //for debugging
 2056              		.loc 1 807 0
 2057 10d0 E0309FE5 		ldr	r3, .L248
 824:../uvc.c      **** 				}
 2058              		.loc 1 824 0
 2059 10d4 9E20C305 		streqb	r2, [r3, #158]
 826:../uvc.c      **** 		}else{//not support currently
 2060              		.loc 1 826 0
 2061 10d8 0030E0E3 		mvn	r3, #0
 2062 10dc 9F30C4E5 		strb	r3, [r4, #159]
 849:../uvc.c      **** 
 2063              		.loc 1 849 0
 2064 10e0 34D08DE2 		add	sp, sp, #52
 2065              		@ sp needed
 2066 10e4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2067              	.LVL234:
 2068              	.L243:
 795:../uvc.c      **** 	{
 2069              		.loc 1 795 0 discriminator 1
 2070 10e8 9830D4E5 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 2071 10ec 300053E3 		cmp	r3, #48
 2072 10f0 CEFFFF1A 		bne	.L227
 2073 10f4 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2074 10f8 010053E3 		cmp	r3, #1
 2075 10fc CBFFFF1A 		bne	.L227
 797:../uvc.c      **** 		if(is60Hz==CyFalse)
 2076              		.loc 1 797 0
 2077 1100 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 2078 1104 B4309FE5 		ldr	r3, .L248+8
 2079 1108 031002E2 		and	r1, r2, #3
 2080 110c 5210C3E5 		strb	r1, [r3, #82]
 798:../uvc.c      **** 			{
 2081              		.loc 1 798 0
 2082 1110 6C1094E5 		ldr	r1, [r4, #108]
 802:../uvc.c      **** 
 2083              		.loc 1 802 0
 2084 1114 0400A0E3 		mov	r0, #4
 798:../uvc.c      **** 			{
 2085              		.loc 1 798 0
 2086 1118 000051E3 		cmp	r1, #0
 800:../uvc.c      **** 			}
 2087              		.loc 1 800 0
 2088 111c 80208203 		orreq	r2, r2, #128
 802:../uvc.c      **** 
 2089              		.loc 1 802 0
 2090 1120 5230D3E5 		ldrb	r3, [r3, #82]	@ zero_extendqisi2
 2091 1124 98109FE5 		ldr	r1, .L248+12
 800:../uvc.c      **** 			}
 2092              		.loc 1 800 0
 2093 1128 9D20C405 		streqb	r2, [r4, #157]
 802:../uvc.c      **** 
 2094              		.loc 1 802 0
 2095 112c FEFFFFEB 		bl	CyU3PDebugPrint
 2096              	.LVL235:
 2097 1130 BEFFFFEA 		b	.L227
 2098              	.L246:
 832:../uvc.c      **** 				for(i = 0; i<4; i++)
 2099              		.loc 1 832 0
 2100 1134 0450A0E3 		mov	r5, #4
 2101              	.LVL236:
 2102              	.L235:
 834:../uvc.c      **** 			}
 2103              		.loc 1 834 0 discriminator 2
 2104 1138 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2105 113c 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 2106 1140 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2107 1144 9830D4E5 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 2108 1148 FE0000E2 		and	r0, r0, #254
 2109 114c 00208DE5 		str	r2, [sp]
 2110 1150 015045E2 		sub	r5, r5, #1
 2111 1154 0020A0E3 		mov	r2, #0
 2112 1158 FEFFFFEB 		bl	SensorWrite2B2
 2113              	.LVL237:
 833:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 2114              		.loc 1 833 0 discriminator 2
 2115 115c FF5015E2 		ands	r5, r5, #255
 2116 1160 F4FFFF1A 		bne	.L235
 2117 1164 B5FFFFEA 		b	.L226
 2118              	.L247:
 837:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2119              		.loc 1 837 0 discriminator 1
 2120 1168 9960D0E5 		ldrb	r6, [r0, #153]	@ zero_extendqisi2
 2121              	.LVL238:
 2122 116c 100056E3 		cmp	r6, #16
 2123 1170 0630A011 		movne	r3, r6
 2124 1174 0520A011 		movne	r2, r5
 2125 1178 BEFFFF1A 		bne	.L237
 838:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 2126              		.loc 1 838 0
 2127 117c 44409FE5 		ldr	r4, .L248+16
 2128 1180 0010E0E3 		mvn	r1, #0
 2129 1184 1C0094E5 		ldr	r0, [r4, #28]
 2130 1188 FEFFFFEB 		bl	_txe_mutex_get
 2131              	.LVL239:
 839:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 2132              		.loc 1 839 0
 2133 118c 0010A0E3 		mov	r1, #0
 2134 1190 00108DE5 		str	r1, [sp]
 2135 1194 04108DE5 		str	r1, [sp, #4]
 2136 1198 0620A0E1 		mov	r2, r6
 2137 119c 0530A0E1 		mov	r3, r5
 2138 11a0 0400A0E1 		mov	r0, r4
 2139 11a4 1710A0E3 		mov	r1, #23
 2140 11a8 FEFFFFEB 		bl	cmdSet
 2141              	.LVL240:
 840:../uvc.c      **** 				}
 2142              		.loc 1 840 0
 2143 11ac 1C0094E5 		ldr	r0, [r4, #28]
 2144 11b0 FEFFFFEB 		bl	_txe_mutex_put
 2145              	.LVL241:
 2146 11b4 A1FFFFEA 		b	.L226
 2147              	.L249:
 2148              		.align	2
 2149              	.L248:
 2150 11b8 00000000 		.word	.LANCHOR0
 2151 11bc 34030000 		.word	.LC21
 2152 11c0 00000000 		.word	.LANCHOR1
 2153 11c4 80030000 		.word	.LC22
 2154 11c8 00000000 		.word	cmdQu
 2155              		.cfi_endproc
 2156              	.LFE0:
 2158              		.align	2
 2159              		.global	setIrisauto
 2161              	setIrisauto:
 2162              	.LFB1:
 855:../uvc.c      **** 	uint8_t dataIdx = 0;
 2163              		.loc 1 855 0
 2164              		.cfi_startproc
 2165              		@ args = 0, pretend = 0, frame = 0
 2166              		@ frame_needed = 0, uses_anonymous_args = 0
 2167              	.LVL242:
 2168 11cc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 2169              	.LCFI13:
 2170              		.cfi_def_cfa_offset 16
 2171              		.cfi_offset 4, -16
 2172              		.cfi_offset 5, -12
 2173              		.cfi_offset 6, -8
 2174              		.cfi_offset 14, -4
 2175 11d0 0150A0E1 		mov	r5, r1
 2176 11d4 08D04DE2 		sub	sp, sp, #8
 2177              	.LCFI14:
 2178              		.cfi_def_cfa_offset 24
 855:../uvc.c      **** 	uint8_t dataIdx = 0;
 2179              		.loc 1 855 0
 2180 11d8 0040A0E1 		mov	r4, r0
 858:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 2181              		.loc 1 858 0
 2182 11dc 0060A0E3 		mov	r6, #0
 857:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 2183              		.loc 1 857 0
 2184 11e0 0010E0E3 		mvn	r1, #0
 2185              	.LVL243:
 2186 11e4 1C0090E5 		ldr	r0, [r0, #28]
 2187              	.LVL244:
 2188 11e8 FEFFFFEB 		bl	_txe_mutex_get
 2189              	.LVL245:
 858:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 2190              		.loc 1 858 0
 2191 11ec 062055E0 		subs	r2, r5, r6
 2192 11f0 003072E2 		rsbs	r3, r2, #0
 2193 11f4 0230B3E0 		adcs	r3, r3, r2
 2194 11f8 00308DE5 		str	r3, [sp]
 2195 11fc 0400A0E1 		mov	r0, r4
 2196 1200 04608DE5 		str	r6, [sp, #4]
 2197 1204 2010A0E3 		mov	r1, #32
 2198 1208 2720A0E3 		mov	r2, #39
 2199 120c 3030A0E3 		mov	r3, #48
 2200 1210 FEFFFFEB 		bl	cmdSet
 2201              	.LVL246:
 859:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2202              		.loc 1 859 0
 2203 1214 060055E1 		cmp	r5, r6
 2204 1218 0250A003 		moveq	r5, #2
 2205 121c 0150A013 		movne	r5, #1
 2206 1220 60008DE8 		stmia	sp, {r5, r6}
 2207 1224 0400A0E1 		mov	r0, r4
 2208 1228 2110A0E3 		mov	r1, #33
 2209 122c 2520A0E3 		mov	r2, #37
 2210 1230 3030A0E3 		mov	r3, #48
 2211 1234 FEFFFFEB 		bl	cmdSet
 2212              	.LVL247:
 860:../uvc.c      **** }
 2213              		.loc 1 860 0
 2214 1238 1C0094E5 		ldr	r0, [r4, #28]
 861:../uvc.c      **** 
 2215              		.loc 1 861 0
 2216 123c 08D08DE2 		add	sp, sp, #8
 2217              		@ sp needed
 2218 1240 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 2219              	.LVL248:
 860:../uvc.c      **** }
 2220              		.loc 1 860 0
 2221 1244 FEFFFFEA 		b	_txe_mutex_put
 2222              	.LVL249:
 2223              		.cfi_endproc
 2224              	.LFE1:
 2226              		.align	2
 2227              		.global	getShutCtrl
 2229              	getShutCtrl:
 2230              	.LFB2:
 865:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 2231              		.loc 1 865 0
 2232              		.cfi_startproc
 2233              		@ args = 0, pretend = 0, frame = 0
 2234              		@ frame_needed = 0, uses_anonymous_args = 0
 2235              	.LVL250:
 870:../uvc.c      **** 	case 1:
 2236              		.loc 1 870 0
 2237 1248 013040E2 		sub	r3, r0, #1
 865:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 2238              		.loc 1 865 0
 2239 124c 30402DE9 		stmfd	sp!, {r4, r5, lr}
 2240              	.LCFI15:
 2241              		.cfi_def_cfa_offset 12
 2242              		.cfi_offset 4, -12
 2243              		.cfi_offset 5, -8
 2244              		.cfi_offset 14, -4
 2245 1250 0020A0E1 		mov	r2, r0
 2246 1254 0CD04DE2 		sub	sp, sp, #12
 2247              	.LCFI16:
 2248              		.cfi_def_cfa_offset 24
 870:../uvc.c      **** 	case 1:
 2249              		.loc 1 870 0
 2250 1258 090053E3 		cmp	r3, #9
 2251 125c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2252 1260 350000EA 		b	.L254
 2253              	.L256:
 2254 1264 00130000 		.word	.L255
 2255 1268 00130000 		.word	.L255
 2256 126c 00130000 		.word	.L255
 2257 1270 00130000 		.word	.L255
 2258 1274 00130000 		.word	.L255
 2259 1278 8C120000 		.word	.L257
 2260 127c 8C120000 		.word	.L257
 2261 1280 8C120000 		.word	.L257
 2262 1284 8C120000 		.word	.L257
 2263 1288 8C120000 		.word	.L257
 2264              	.L257:
 2265              	.LVL251:
 892:../uvc.c      **** 		fRate = 30;
 2266              		.loc 1 892 0
 2267 128c D0009FE5 		ldr	r0, .L269
 2268              	.LVL252:
 2269 1290 8330A0E1 		mov	r3, r3, asl #1
 894:../uvc.c      **** 		if(NumLn > 1944)
 2270              		.loc 1 894 0
 2271 1294 B33090E1 		ldrh	r3, [r0, r3]
 2272 1298 C8C09FE5 		ldr	ip, .L269+4
 2273 129c 030263E0 		rsb	r0, r3, r3, asl #4
 2274 12a0 8000A0E1 		mov	r0, r0, asl #1
 2275 12a4 90ECCCE0 		smull	lr, ip, r0, ip
 2276 12a8 C00FA0E1 		mov	r0, r0, asr #31
 2277 12ac 4C0460E0 		rsb	r0, r0, ip, asr #8
 895:../uvc.c      **** 			NumLn =1944;
 2278              		.loc 1 895 0
 2279 12b0 B4E09FE5 		ldr	lr, .L269+8
 894:../uvc.c      **** 		if(NumLn > 1944)
 2280              		.loc 1 894 0
 2281 12b4 0008A0E1 		mov	r0, r0, asl #16
 2282 12b8 20C8A0E1 		mov	ip, r0, lsr #16
 2283              	.LVL253:
 895:../uvc.c      **** 			NumLn =1944;
 2284              		.loc 1 895 0
 2285 12bc 0E005CE1 		cmp	ip, lr
 2286 12c0 1A00008A 		bhi	.L263
 2287              	.LVL254:
 2288              	.L267:
 897:../uvc.c      **** 			NumLn = 8;
 2289              		.loc 1 897 0
 2290 12c4 07005CE3 		cmp	ip, #7
 2291 12c8 2100008A 		bhi	.L268
 2292 12cc 0100A0E3 		mov	r0, #1
 2293 12d0 0040A0E1 		mov	r4, r0
 2294 12d4 08E0A0E3 		mov	lr, #8
 2295              	.L260:
 2296              	.LVL255:
 900:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 2297              		.loc 1 900 0
 2298 12d8 0150A0E3 		mov	r5, #1
 901:../uvc.c      **** 		break;
 2299              		.loc 1 901 0
 2300 12dc 04008DE5 		str	r0, [sp, #4]
 2301 12e0 00E08DE5 		str	lr, [sp]
 2302 12e4 0400A0E3 		mov	r0, #4
 900:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 2303              		.loc 1 900 0
 2304 12e8 0050C1E5 		strb	r5, [r1]
 901:../uvc.c      **** 		break;
 2305              		.loc 1 901 0
 2306 12ec 7C109FE5 		ldr	r1, .L269+12
 2307              	.LVL256:
 2308 12f0 FEFFFFEB 		bl	CyU3PDebugPrint
 2309              	.LVL257:
 910:../uvc.c      **** 
 2310              		.loc 1 910 0
 2311 12f4 0400A0E1 		mov	r0, r4
 2312 12f8 0CD08DE2 		add	sp, sp, #12
 2313              		@ sp needed
 2314 12fc 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 2315              	.LVL258:
 2316              	.L255:
 876:../uvc.c      **** 		fRate = 30;
 2317              		.loc 1 876 0
 2318 1300 5C009FE5 		ldr	r0, .L269
 2319              	.LVL259:
 2320 1304 8330A0E1 		mov	r3, r3, asl #1
 2321 1308 B33090E1 		ldrh	r3, [r0, r3]
 2322              	.LVL260:
 878:../uvc.c      **** 		if(NumLn > 1944)
 2323              		.loc 1 878 0
 2324 130c 60009FE5 		ldr	r0, .L269+16
 2325              	.LVL261:
 879:../uvc.c      **** 			NumLn =1944;
 2326              		.loc 1 879 0
 2327 1310 54E09FE5 		ldr	lr, .L269+8
 878:../uvc.c      **** 		if(NumLn > 1944)
 2328              		.loc 1 878 0
 2329 1314 93C080E0 		umull	ip, r0, r3, r0
 2330 1318 A004A0E1 		mov	r0, r0, lsr #9
 2331 131c 000260E0 		rsb	r0, r0, r0, asl #4
 2332 1320 8008A0E1 		mov	r0, r0, asl #17
 2333 1324 20C8A0E1 		mov	ip, r0, lsr #16
 2334              	.LVL262:
 879:../uvc.c      **** 			NumLn =1944;
 2335              		.loc 1 879 0
 2336 1328 0E005CE1 		cmp	ip, lr
 2337 132c E4FFFF9A 		bls	.L267
 2338              	.LVL263:
 2339              	.L263:
 2340 1330 F300A0E3 		mov	r0, #243
 2341 1334 0040A0E1 		mov	r4, r0
 2342 1338 E6FFFFEA 		b	.L260
 2343              	.LVL264:
 2344              	.L254:
 906:../uvc.c      **** 		break;
 2345              		.loc 1 906 0
 2346 133c 0140A0E3 		mov	r4, #1
 905:../uvc.c      **** 		LnVal = 1;
 2347              		.loc 1 905 0
 2348 1340 0030A0E3 		mov	r3, #0
 910:../uvc.c      **** 
 2349              		.loc 1 910 0
 2350 1344 0400A0E1 		mov	r0, r4
 2351              	.LVL265:
 905:../uvc.c      **** 		LnVal = 1;
 2352              		.loc 1 905 0
 2353 1348 0030C1E5 		strb	r3, [r1]
 2354              	.LVL266:
 910:../uvc.c      **** 
 2355              		.loc 1 910 0
 2356 134c 0CD08DE2 		add	sp, sp, #12
 2357              		@ sp needed
 2358 1350 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 2359              	.LVL267:
 2360              	.L268:
 2361 1354 A009A0E1 		mov	r0, r0, lsr #19
 2362 1358 FF4000E2 		and	r4, r0, #255
 2363 135c 0CE0A0E1 		mov	lr, ip
 2364 1360 DCFFFFEA 		b	.L260
 2365              	.L270:
 2366              		.align	2
 2367              	.L269:
 2368 1364 00000000 		.word	.LANCHOR2
 2369 1368 817F807F 		.word	2139127681
 2370 136c 98070000 		.word	1944
 2371 1370 A8030000 		.word	.LC23
 2372 1374 01FF00FF 		.word	-16711935
 2373              		.cfi_endproc
 2374              	.LFE2:
 2376              		.align	2
 2377              		.global	ControlHandle
 2379              	ControlHandle:
 2380              	.LFB3:
 912:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2381              		.loc 1 912 0
 2382              		.cfi_startproc
 2383              		@ args = 0, pretend = 0, frame = 24
 2384              		@ frame_needed = 0, uses_anonymous_args = 0
 2385              	.LVL268:
 2386 1378 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2387              	.LCFI17:
 2388              		.cfi_def_cfa_offset 36
 2389              		.cfi_offset 4, -36
 2390              		.cfi_offset 5, -32
 2391              		.cfi_offset 6, -28
 2392              		.cfi_offset 7, -24
 2393              		.cfi_offset 8, -20
 2394              		.cfi_offset 9, -16
 2395              		.cfi_offset 10, -12
 2396              		.cfi_offset 11, -8
 2397              		.cfi_offset 14, -4
 920:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 2398              		.loc 1 920 0
 2399 137c CC6F9FE5 		ldr	r6, .L474
 918:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 2400              		.loc 1 918 0
 2401 1380 208040E2 		sub	r8, r0, #32
 919:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 2402              		.loc 1 919 0
 2403 1384 230050E3 		cmp	r0, #35
 912:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2404              		.loc 1 912 0
 2405 1388 2CD04DE2 		sub	sp, sp, #44
 2406              	.LCFI18:
 2407              		.cfi_def_cfa_offset 80
 912:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2408              		.loc 1 912 0
 2409 138c 0040A0E1 		mov	r4, r0
 918:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 2410              		.loc 1 918 0
 2411 1390 FF8008E2 		and	r8, r8, #255
 2412              	.LVL269:
 919:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 2413              		.loc 1 919 0
 2414 1394 2A00009A 		bls	.L272
 920:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 2415              		.loc 1 920 0
 2416 1398 882088E0 		add	r2, r8, r8, asl #1
 2417 139c 822186E0 		add	r2, r6, r2, asl #3
 2418 13a0 6C30D2E5 		ldrb	r3, [r2, #108]	@ zero_extendqisi2
 2419              	.LVL270:
 921:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 2420              		.loc 1 921 0
 2421 13a4 6DC0D2E5 		ldrb	ip, [r2, #109]	@ zero_extendqisi2
 2422              	.LVL271:
 922:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 2423              		.loc 1 922 0
 2424 13a8 7BA0D2E5 		ldrb	r10, [r2, #123]	@ zero_extendqisi2
 2425              	.LVL272:
 923:../uvc.c      ****     }else{
 2426              		.loc 1 923 0
 2427 13ac 6E90D2E5 		ldrb	r9, [r2, #110]	@ zero_extendqisi2
 2428              	.LVL273:
 934:../uvc.c      ****     /*
 2429              		.loc 1 934 0
 2430 13b0 9C2F9FE5 		ldr	r2, .L474+4
 2431              	.LVL274:
 2432 13b4 0050D2E5 		ldrb	r5, [r2]	@ zero_extendqisi2
 2433              	.LVL275:
 942:../uvc.c      **** 		 {
 2434              		.loc 1 942 0
 2435 13b8 830055E3 		cmp	r5, #131
 2436 13bc 2A00000A 		beq	.L275
 2437              	.LVL276:
 2438              	.L467:
 2439 13c0 3300009A 		bls	.L466
 2440 13c4 850055E3 		cmp	r5, #133
 2441 13c8 CE00000A 		beq	.L280
 2442 13cc D900003A 		bcc	.L281
 2443 13d0 860055E3 		cmp	r5, #134
 2444 13d4 7F00000A 		beq	.L282
 2445 13d8 870055E3 		cmp	r5, #135
 2446 13dc C000001A 		bne	.L274
1463:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2447              		.loc 1 1463 0
 2448 13e0 230054E3 		cmp	r4, #35
 2449 13e4 E300009A 		bls	.L377
1464:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2450              		.loc 1 1464 0
 2451 13e8 888088E0 		add	r8, r8, r8, asl #1
 2452              	.LVL277:
 2453 13ec 886186E0 		add	r6, r6, r8, asl #3
 2454 13f0 987F9FE5 		ldr	r7, .L474+64
 2455 13f4 7720D6E5 		ldrb	r2, [r6, #119]	@ zero_extendqisi2
1465:../uvc.c      **** 		 	 }
 2456              		.loc 1 1465 0
 2457 13f8 7830D6E5 		ldrb	r3, [r6, #120]	@ zero_extendqisi2
1464:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2458              		.loc 1 1464 0
 2459 13fc 2820C7E5 		strb	r2, [r7, #40]
1465:../uvc.c      **** 		 	 }
 2460              		.loc 1 1465 0
 2461 1400 2930C7E5 		strb	r3, [r7, #41]
 2462              	.L378:
1476:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2463              		.loc 1 1476 0
 2464 1404 0900A0E1 		mov	r0, r9
 2465              	.LVL278:
1478:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 2466              		.loc 1 1478 0
 2467 1408 FF40A0E3 		mov	r4, #255
1476:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2468              		.loc 1 1476 0
 2469 140c 441F9FE5 		ldr	r1, .L474+8
 2470 1410 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2471              	.LVL279:
1478:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 2472              		.loc 1 1478 0
 2473 1414 0490A0E1 		mov	r9, r4
 2474 1418 28A0D7E5 		ldrb	r10, [r7, #40]	@ zero_extendqisi2
 2475 141c 0470A0E1 		mov	r7, r4
 2476              	.LVL280:
 2477              	.L284:
2005:../uvc.c      **** }
 2478              		.loc 1 2005 0
 2479 1420 00068DE8 		stmia	sp, {r9, r10}
 2480 1424 301F9FE5 		ldr	r1, .L474+12
 2481 1428 08408DE5 		str	r4, [sp, #8]
 2482 142c 0520A0E1 		mov	r2, r5
 2483 1430 0730A0E1 		mov	r3, r7
 2484 1434 0400A0E3 		mov	r0, #4
 2485 1438 FEFFFFEB 		bl	CyU3PDebugPrint
 2486              	.LVL281:
2006:../uvc.c      **** /************** CT control requests handler *************************/
 2487              		.loc 1 2006 0
 2488 143c 2CD08DE2 		add	sp, sp, #44
 2489              		@ sp needed
 2490 1440 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2491              	.LVL282:
 2492              	.L272:
 925:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2493              		.loc 1 925 0
 2494 1444 802080E0 		add	r2, r0, r0, asl #1
 2495 1448 822186E0 		add	r2, r6, r2, asl #3
 2496 144c EC31D2E5 		ldrb	r3, [r2, #492]	@ zero_extendqisi2
 2497              	.LVL283:
 926:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 2498              		.loc 1 926 0
 2499 1450 EDC1D2E5 		ldrb	ip, [r2, #493]	@ zero_extendqisi2
 2500              	.LVL284:
 927:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 2501              		.loc 1 927 0
 2502 1454 FBA1D2E5 		ldrb	r10, [r2, #507]	@ zero_extendqisi2
 2503              	.LVL285:
 928:../uvc.c      ****     }
 2504              		.loc 1 928 0
 2505 1458 EE91D2E5 		ldrb	r9, [r2, #494]	@ zero_extendqisi2
 2506              	.LVL286:
 934:../uvc.c      ****     /*
 2507              		.loc 1 934 0
 2508 145c F02E9FE5 		ldr	r2, .L474+4
 2509              	.LVL287:
 2510 1460 0050D2E5 		ldrb	r5, [r2]	@ zero_extendqisi2
 2511              	.LVL288:
 942:../uvc.c      **** 		 {
 2512              		.loc 1 942 0
 2513 1464 830055E3 		cmp	r5, #131
 2514 1468 D4FFFF1A 		bne	.L467
 2515              	.LVL289:
 2516              	.L275:
1418:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 2517              		.loc 1 1418 0
 2518 146c 230054E3 		cmp	r4, #35
 2519 1470 D600009A 		bls	.L370
1419:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 2520              		.loc 1 1419 0
 2521 1474 888088E0 		add	r8, r8, r8, asl #1
 2522              	.LVL290:
 2523 1478 886186E0 		add	r6, r6, r8, asl #3
 2524 147c 0C7F9FE5 		ldr	r7, .L474+64
 2525 1480 7120D6E5 		ldrb	r2, [r6, #113]	@ zero_extendqisi2
1420:../uvc.c      **** 		 	 }
 2526              		.loc 1 1420 0
 2527 1484 7230D6E5 		ldrb	r3, [r6, #114]	@ zero_extendqisi2
1419:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 2528              		.loc 1 1419 0
 2529 1488 2820C7E5 		strb	r2, [r7, #40]
1420:../uvc.c      **** 		 	 }
 2530              		.loc 1 1420 0
 2531 148c 2930C7E5 		strb	r3, [r7, #41]
 2532 1490 DBFFFFEA 		b	.L378
 2533              	.LVL291:
 2534              	.L466:
 942:../uvc.c      **** 		 {
 2535              		.loc 1 942 0
 2536 1494 810055E3 		cmp	r5, #129
 2537 1498 5F00000A 		beq	.L277
 2538 149c 4300008A 		bhi	.L278
 2539 14a0 010055E3 		cmp	r5, #1
 2540 14a4 8E00001A 		bne	.L274
1480:../uvc.c      **** 				  glEp0Buffer, &readCount);
 2541              		.loc 1 1480 0
 2542 14a8 E07E9FE5 		ldr	r7, .L474+64
 2543 14ac 26208DE2 		add	r2, sp, #38
 2544 14b0 2000A0E3 		mov	r0, #32
 2545              	.LVL292:
 2546 14b4 281087E2 		add	r1, r7, #40
 2547 14b8 14308DE5 		str	r3, [sp, #20]
 2548 14bc 10C08DE5 		str	ip, [sp, #16]
 2549 14c0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2550              	.LVL293:
1482:../uvc.c      **** 			   {
 2551              		.loc 1 1482 0
 2552 14c4 14309DE5 		ldr	r3, [sp, #20]
 2553 14c8 10C09DE5 		ldr	ip, [sp, #16]
 2554 14cc 002050E2 		subs	r2, r0, #0
 2555 14d0 F104001A 		bne	.L380
1485:../uvc.c      **** 				  getData = glEp0Buffer[0];
 2556              		.loc 1 1485 0
 2557 14d4 2910D7E5 		ldrb	r1, [r7, #41]	@ zero_extendqisi2
1487:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 2558              		.loc 1 1487 0
 2559 14d8 2A20D7E5 		ldrb	r2, [r7, #42]	@ zero_extendqisi2
1484:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 2560              		.loc 1 1484 0
 2561 14dc 28B0D7E5 		ldrb	fp, [r7, #40]	@ zero_extendqisi2
 2562              	.LVL294:
1485:../uvc.c      **** 				  getData = glEp0Buffer[0];
 2563              		.loc 1 1485 0
 2564 14e0 1C108DE5 		str	r1, [sp, #28]
 2565              	.LVL295:
1487:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 2566              		.loc 1 1487 0
 2567 14e4 18208DE5 		str	r2, [sp, #24]
 2568              	.LVL296:
1491:../uvc.c      **** 					 {
 2569              		.loc 1 1491 0
 2570 14e8 2E0054E3 		cmp	r4, #46
 2571 14ec 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2572 14f0 C30400EA 		b	.L381
 2573              	.L383:
 2574 14f4 98240000 		.word	.L382
 2575 14f8 28240000 		.word	.L384
 2576 14fc 0C270000 		.word	.L385
 2577 1500 04280000 		.word	.L381
 2578 1504 10250000 		.word	.L386
 2579 1508 D0250000 		.word	.L387
 2580 150c 0C200000 		.word	.L388
 2581 1510 BC220000 		.word	.L389
 2582 1514 04280000 		.word	.L381
 2583 1518 04280000 		.word	.L381
 2584 151c 04280000 		.word	.L381
 2585 1520 2C220000 		.word	.L390
 2586 1524 04280000 		.word	.L381
 2587 1528 04280000 		.word	.L381
 2588 152c 04280000 		.word	.L381
 2589 1530 04280000 		.word	.L381
 2590 1534 5C210000 		.word	.L391
 2591 1538 04280000 		.word	.L381
 2592 153c 04280000 		.word	.L381
 2593 1540 04280000 		.word	.L381
 2594 1544 04280000 		.word	.L381
 2595 1548 04280000 		.word	.L381
 2596 154c 04280000 		.word	.L381
 2597 1550 04280000 		.word	.L381
 2598 1554 04280000 		.word	.L381
 2599 1558 90200000 		.word	.L392
 2600 155c 0C270000 		.word	.L385
 2601 1560 6C270000 		.word	.L393
 2602 1564 A8230000 		.word	.L394
 2603 1568 04280000 		.word	.L381
 2604 156c 6C250000 		.word	.L395
 2605 1570 3C1B0000 		.word	.L396
 2606 1574 04280000 		.word	.L381
 2607 1578 04280000 		.word	.L381
 2608 157c 04280000 		.word	.L381
 2609 1580 04280000 		.word	.L381
 2610 1584 281E0000 		.word	.L397
 2611 1588 BC1D0000 		.word	.L398
 2612 158c 341D0000 		.word	.L399
 2613 1590 A01C0000 		.word	.L400
 2614 1594 A01C0000 		.word	.L400
 2615 1598 A01C0000 		.word	.L400
 2616 159c A01C0000 		.word	.L400
 2617 15a0 C81B0000 		.word	.L401
 2618 15a4 C81B0000 		.word	.L401
 2619 15a8 C81B0000 		.word	.L401
 2620 15ac A01C0000 		.word	.L400
 2621              	.LVL297:
 2622              	.L278:
1399:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 2623              		.loc 1 1399 0
 2624 15b0 230054E3 		cmp	r4, #35
 2625 15b4 7900009A 		bls	.L367
1400:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 2626              		.loc 1 1400 0
 2627 15b8 888088E0 		add	r8, r8, r8, asl #1
 2628              	.LVL298:
 2629 15bc 886186E0 		add	r6, r6, r8, asl #3
 2630 15c0 C87D9FE5 		ldr	r7, .L474+64
 2631 15c4 6F20D6E5 		ldrb	r2, [r6, #111]	@ zero_extendqisi2
1401:../uvc.c      **** 		 	 }
 2632              		.loc 1 1401 0
 2633 15c8 7030D6E5 		ldrb	r3, [r6, #112]	@ zero_extendqisi2
1400:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 2634              		.loc 1 1400 0
 2635 15cc 2820C7E5 		strb	r2, [r7, #40]
1401:../uvc.c      **** 		 	 }
 2636              		.loc 1 1401 0
 2637 15d0 2930C7E5 		strb	r3, [r7, #41]
 2638 15d4 8AFFFFEA 		b	.L378
 2639              	.LVL299:
 2640              	.L282:
1452:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2641              		.loc 1 1452 0
 2642 15d8 230054E3 		cmp	r4, #35
1456:../uvc.c      **** 		 	 }
 2643              		.loc 1 1456 0
 2644 15dc 84408490 		addls	r4, r4, r4, asl #1
1453:../uvc.c      **** 		 	 }
 2645              		.loc 1 1453 0
 2646 15e0 88808880 		addhi	r8, r8, r8, asl #1
 2647              	.LVL300:
1456:../uvc.c      **** 		 	 }
 2648              		.loc 1 1456 0
 2649 15e4 84618690 		addls	r6, r6, r4, asl #3
1453:../uvc.c      **** 		 	 }
 2650              		.loc 1 1453 0
 2651 15e8 88618680 		addhi	r6, r6, r8, asl #3
 2652 15ec 7530D685 		ldrhib	r3, [r6, #117]	@ zero_extendqisi2
1456:../uvc.c      **** 		 	 }
 2653              		.loc 1 1456 0
 2654 15f0 F531D695 		ldrlsb	r3, [r6, #501]	@ zero_extendqisi2
 2655 15f4 946D9FE5 		ldr	r6, .L474+64
1461:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 2656              		.loc 1 1461 0
 2657 15f8 FF40A0E3 		mov	r4, #255
 2658 15fc 0610A0E1 		mov	r1, r6
1458:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2659              		.loc 1 1458 0
 2660 1600 0100A0E3 		mov	r0, #1
 2661              	.LVL301:
 2662 1604 2830E1E5 		strb	r3, [r1, #40]!
 2663 1608 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2664              	.LVL302:
1461:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 2665              		.loc 1 1461 0
 2666 160c 0490A0E1 		mov	r9, r4
 2667 1610 28A0D6E5 		ldrb	r10, [r6, #40]	@ zero_extendqisi2
 2668 1614 0470A0E1 		mov	r7, r4
 2669 1618 80FFFFEA 		b	.L284
 2670              	.LVL303:
 2671              	.L277:
 953:../uvc.c      **** 			 {
 2672              		.loc 1 953 0
 2673 161c 2E0054E3 		cmp	r4, #46
 2674 1620 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2675 1624 900400EA 		b	.L285
 2676              	.L287:
 2677 1628 9C1B0000 		.word	.L286
 2678 162c 6C1B0000 		.word	.L288
 2679 1630 301F0000 		.word	.L289
 2680 1634 6C280000 		.word	.L285
 2681 1638 001F0000 		.word	.L290
 2682 163c E81E0000 		.word	.L291
 2683 1640 6C280000 		.word	.L285
 2684 1644 BC1E0000 		.word	.L292
 2685 1648 6C280000 		.word	.L285
 2686 164c E41F0000 		.word	.L293
 2687 1650 6C280000 		.word	.L285
 2688 1654 581F0000 		.word	.L294
 2689 1658 6C280000 		.word	.L285
 2690 165c 6C280000 		.word	.L285
 2691 1660 6C280000 		.word	.L285
 2692 1664 6C280000 		.word	.L285
 2693 1668 881F0000 		.word	.L295
 2694 166c 6C280000 		.word	.L285
 2695 1670 6C280000 		.word	.L285
 2696 1674 6C280000 		.word	.L285
 2697 1678 6C280000 		.word	.L285
 2698 167c 6C280000 		.word	.L285
 2699 1680 6C280000 		.word	.L285
 2700 1684 6C280000 		.word	.L285
 2701 1688 6C280000 		.word	.L285
 2702 168c CC1A0000 		.word	.L296
 2703 1690 301F0000 		.word	.L289
 2704 1694 5C1A0000 		.word	.L297
 2705 1698 B4190000 		.word	.L298
 2706 169c 6C280000 		.word	.L285
 2707 16a0 6C280000 		.word	.L285
 2708 16a4 24180000 		.word	.L299
 2709 16a8 6C280000 		.word	.L285
 2710 16ac 6C280000 		.word	.L285
 2711 16b0 6C280000 		.word	.L285
 2712 16b4 6C280000 		.word	.L285
 2713 16b8 80180000 		.word	.L300
 2714 16bc A01A0000 		.word	.L301
 2715 16c0 E0190000 		.word	.L302
 2716 16c4 301A0000 		.word	.L303
 2717 16c8 88190000 		.word	.L304
 2718 16cc 30190000 		.word	.L305
 2719 16d0 D8180000 		.word	.L306
 2720 16d4 04190000 		.word	.L307
 2721 16d8 AC180000 		.word	.L308
 2722 16dc 041A0000 		.word	.L309
 2723 16e0 5C190000 		.word	.L310
 2724              	.L274:
2002:../uvc.c      **** 			  break;
 2725              		.loc 1 2002 0
 2726 16e4 0000A0E3 		mov	r0, #0
 2727              	.LVL304:
2003:../uvc.c      **** 		 }
 2728              		.loc 1 2003 0
 2729 16e8 FF40A0E3 		mov	r4, #255
2002:../uvc.c      **** 			  break;
 2730              		.loc 1 2002 0
 2731 16ec 0020A0E1 		mov	r2, r0
 2732 16f0 0110A0E3 		mov	r1, #1
 2733 16f4 FEFFFFEB 		bl	CyU3PUsbStall
 2734              	.LVL305:
2003:../uvc.c      **** 		 }
 2735              		.loc 1 2003 0
 2736 16f8 04A0A0E1 		mov	r10, r4
 2737 16fc 0490A0E1 		mov	r9, r4
 2738 1700 0470A0E1 		mov	r7, r4
 2739 1704 45FFFFEA 		b	.L284
 2740              	.LVL306:
 2741              	.L280:
 946:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2742              		.loc 1 946 0
 2743 1708 806C9FE5 		ldr	r6, .L474+64
 947:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2744              		.loc 1 947 0
 2745 170c 0030A0E3 		mov	r3, #0
 950:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 2746              		.loc 1 950 0
 2747 1710 FF40A0E3 		mov	r4, #255
 948:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2748              		.loc 1 948 0
 2749 1714 281086E2 		add	r1, r6, #40
 2750 1718 0200A0E3 		mov	r0, #2
 2751              	.LVL307:
 946:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2752              		.loc 1 946 0
 2753 171c 2890C6E5 		strb	r9, [r6, #40]
 947:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2754              		.loc 1 947 0
 2755 1720 2930C6E5 		strb	r3, [r6, #41]
 950:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 2756              		.loc 1 950 0
 2757 1724 0490A0E1 		mov	r9, r4
 948:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2758              		.loc 1 948 0
 2759 1728 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2760              	.LVL308:
 950:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 2761              		.loc 1 950 0
 2762 172c 0470A0E1 		mov	r7, r4
 2763 1730 28A0D6E5 		ldrb	r10, [r6, #40]	@ zero_extendqisi2
 2764 1734 39FFFFEA 		b	.L284
 2765              	.LVL309:
 2766              	.L281:
1436:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 2767              		.loc 1 1436 0
 2768 1738 230054E3 		cmp	r4, #35
1437:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 2769              		.loc 1 1437 0
 2770 173c 88808880 		addhi	r8, r8, r8, asl #1
 2771              	.LVL310:
1443:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 2772              		.loc 1 1443 0
 2773 1740 84408490 		addls	r4, r4, r4, asl #1
1437:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 2774              		.loc 1 1437 0
 2775 1744 88618680 		addhi	r6, r6, r8, asl #3
1443:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 2776              		.loc 1 1443 0
 2777 1748 84618690 		addls	r6, r6, r4, asl #3
 2778 174c 3C7C9FE5 		ldr	r7, .L474+64
1437:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 2779              		.loc 1 1437 0
 2780 1750 7310D685 		ldrhib	r1, [r6, #115]	@ zero_extendqisi2
1438:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 2781              		.loc 1 1438 0
 2782 1754 7420D685 		ldrhib	r2, [r6, #116]	@ zero_extendqisi2
1443:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 2783              		.loc 1 1443 0
 2784 1758 F311D695 		ldrlsb	r1, [r6, #499]	@ zero_extendqisi2
1444:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 2785              		.loc 1 1444 0
 2786 175c F421D695 		ldrlsb	r2, [r6, #500]	@ zero_extendqisi2
1445:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 2787              		.loc 1 1445 0
 2788 1760 0030A0E3 		mov	r3, #0
1443:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 2789              		.loc 1 1443 0
 2790 1764 2810C7E5 		strb	r1, [r7, #40]
1444:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 2791              		.loc 1 1444 0
 2792 1768 2920C7E5 		strb	r2, [r7, #41]
1445:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 2793              		.loc 1 1445 0
 2794 176c 2A30C7E5 		strb	r3, [r7, #42]
1446:../uvc.c      **** 		 	 }
 2795              		.loc 1 1446 0
 2796 1770 2B30C7E5 		strb	r3, [r7, #43]
 2797 1774 22FFFFEA 		b	.L378
 2798              	.LVL311:
 2799              	.L377:
1467:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2800              		.loc 1 1467 0
 2801 1778 0B0054E3 		cmp	r4, #11
 2802 177c 1F00000A 		beq	.L468
1473:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2803              		.loc 1 1473 0
 2804 1780 844084E0 		add	r4, r4, r4, asl #1
 2805 1784 846186E0 		add	r6, r6, r4, asl #3
 2806 1788 007C9FE5 		ldr	r7, .L474+64
 2807 178c F721D6E5 		ldrb	r2, [r6, #503]	@ zero_extendqisi2
1474:../uvc.c      **** 			 }
 2808              		.loc 1 1474 0
 2809 1790 F831D6E5 		ldrb	r3, [r6, #504]	@ zero_extendqisi2
1473:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2810              		.loc 1 1473 0
 2811 1794 2820C7E5 		strb	r2, [r7, #40]
1474:../uvc.c      **** 			 }
 2812              		.loc 1 1474 0
 2813 1798 2930C7E5 		strb	r3, [r7, #41]
 2814 179c 18FFFFEA 		b	.L378
 2815              	.L367:
1404:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2816              		.loc 1 1404 0
 2817 17a0 0B0054E3 		cmp	r4, #11
1411:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2818              		.loc 1 1411 0
 2819 17a4 84408410 		addne	r4, r4, r4, asl #1
 2820 17a8 84618610 		addne	r6, r6, r4, asl #3
 2821 17ac DC7B9F15 		ldrne	r7, .L474+64
1405:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 2822              		.loc 1 1405 0
 2823 17b0 D87B9F05 		ldreq	r7, .L474+64
 2824 17b4 A43B9F05 		ldreq	r3, .L474+16
1411:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2825              		.loc 1 1411 0
 2826 17b8 EF21D615 		ldrneb	r2, [r6, #495]	@ zero_extendqisi2
1412:../uvc.c      **** 			 }
 2827              		.loc 1 1412 0
 2828 17bc F031D615 		ldrneb	r3, [r6, #496]	@ zero_extendqisi2
1405:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 2829              		.loc 1 1405 0
 2830 17c0 28308705 		streq	r3, [r7, #40]
1411:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2831              		.loc 1 1411 0
 2832 17c4 2820C715 		strneb	r2, [r7, #40]
1412:../uvc.c      **** 			 }
 2833              		.loc 1 1412 0
 2834 17c8 2930C715 		strneb	r3, [r7, #41]
 2835 17cc 0CFFFFEA 		b	.L378
 2836              	.L370:
1422:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2837              		.loc 1 1422 0
 2838 17d0 0B0054E3 		cmp	r4, #11
1429:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2839              		.loc 1 1429 0
 2840 17d4 84408410 		addne	r4, r4, r4, asl #1
 2841 17d8 84618610 		addne	r6, r6, r4, asl #3
 2842 17dc AC7B9F15 		ldrne	r7, .L474+64
1423:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 2843              		.loc 1 1423 0
 2844 17e0 A87B9F05 		ldreq	r7, .L474+64
 2845 17e4 783B9F05 		ldreq	r3, .L474+20
1429:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2846              		.loc 1 1429 0
 2847 17e8 F121D615 		ldrneb	r2, [r6, #497]	@ zero_extendqisi2
1430:../uvc.c      **** 			 }
 2848              		.loc 1 1430 0
 2849 17ec F231D615 		ldrneb	r3, [r6, #498]	@ zero_extendqisi2
1423:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 2850              		.loc 1 1423 0
 2851 17f0 28308705 		streq	r3, [r7, #40]
1429:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2852              		.loc 1 1429 0
 2853 17f4 2820C715 		strneb	r2, [r7, #40]
1430:../uvc.c      **** 			 }
 2854              		.loc 1 1430 0
 2855 17f8 2930C715 		strneb	r3, [r7, #41]
 2856 17fc 00FFFFEA 		b	.L378
 2857              	.L468:
1468:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2858              		.loc 1 1468 0
 2859 1800 887B9FE5 		ldr	r7, .L474+64
 2860 1804 FF12D6E5 		ldrb	r1, [r6, #767]	@ zero_extendqisi2
1470:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2861              		.loc 1 1470 0
 2862 1808 0023D6E5 		ldrb	r2, [r6, #768]	@ zero_extendqisi2
1469:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2863              		.loc 1 1469 0
 2864 180c 0030A0E3 		mov	r3, #0
1468:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2865              		.loc 1 1468 0
 2866 1810 2810C7E5 		strb	r1, [r7, #40]
1470:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2867              		.loc 1 1470 0
 2868 1814 2A20C7E5 		strb	r2, [r7, #42]
1469:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2869              		.loc 1 1469 0
 2870 1818 2930C7E5 		strb	r3, [r7, #41]
1471:../uvc.c      **** 			 }else{
 2871              		.loc 1 1471 0
 2872 181c 2B30C7E5 		strb	r3, [r7, #43]
 2873 1820 F7FEFFEA 		b	.L378
 2874              	.L299:
 2875              	.LVL312:
1068:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2876              		.loc 1 1068 0 discriminator 1
 2877 1824 000059E3 		cmp	r9, #0
 2878 1828 0300000A 		beq	.L327
 2879 182c 240B9FE5 		ldr	r0, .L474+8
 2880              	.LVL313:
 2881 1830 0920A0E1 		mov	r2, r9
 2882 1834 6C1080E2 		add	r1, r0, #108
 2883 1838 FEFFFFEB 		bl	memcpy
 2884              	.LVL314:
 2885              	.L327:
1071:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 2886              		.loc 1 1071 0
 2887 183c 4C3B9FE5 		ldr	r3, .L474+64
1078:../uvc.c      **** 			 		 {
 2888              		.loc 1 1078 0
 2889 1840 9F20D3E5 		ldrb	r2, [r3, #159]	@ zero_extendqisi2
1071:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 2890              		.loc 1 1071 0
 2891 1844 31A0D3E5 		ldrb	r10, [r3, #49]	@ zero_extendqisi2
 2892              	.LVL315:
1078:../uvc.c      **** 			 		 {
 2893              		.loc 1 1078 0
 2894 1848 FF0052E3 		cmp	r2, #255
1072:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 2895              		.loc 1 1072 0
 2896 184c 3240D3E5 		ldrb	r4, [r3, #50]	@ zero_extendqisi2
 2897              	.LVL316:
1078:../uvc.c      **** 			 		 {
 2898              		.loc 1 1078 0
 2899 1850 0400000A 		beq	.L316
1080:../uvc.c      **** 			 		 }
 2900              		.loc 1 1080 0
 2901 1854 9D20D3E5 		ldrb	r2, [r3, #157]	@ zero_extendqisi2
 2902 1858 0400A0E3 		mov	r0, #4
 2903 185c 041B9FE5 		ldr	r1, .L474+24
 2904 1860 9E30D3E5 		ldrb	r3, [r3, #158]	@ zero_extendqisi2
 2905 1864 FEFFFFEB 		bl	CyU3PDebugPrint
 2906              	.LVL317:
 2907              	.L316:
1392:../uvc.c      **** 
 2908              		.loc 1 1392 0
 2909 1868 0900A0E1 		mov	r0, r9
 2910 186c E41A9FE5 		ldr	r1, .L474+8
 2911 1870 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2912              	.LVL318:
1397:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 2913              		.loc 1 1397 0
 2914 1874 FF90A0E3 		mov	r9, #255
 2915 1878 0970A0E1 		mov	r7, r9
 2916 187c E7FEFFEA 		b	.L284
 2917              	.LVL319:
 2918              	.L300:
 957:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2919              		.loc 1 957 0
 2920 1880 087B9FE5 		ldr	r7, .L474+64
 2921 1884 C420D7E5 		ldrb	r2, [r7, #196]	@ zero_extendqisi2
 2922 1888 000052E3 		cmp	r2, #0
 2923 188c 1705000A 		beq	.L314
 958:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2924              		.loc 1 958 0
 2925 1890 05A5D6E5 		ldrb	r10, [r6, #1285]	@ zero_extendqisi2
 959:../uvc.c      **** 			 	 		 }else{
 2926              		.loc 1 959 0
 2927 1894 0645D6E5 		ldrb	r4, [r6, #1286]	@ zero_extendqisi2
 958:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2928              		.loc 1 958 0
 2929 1898 FFA00AE2 		and	r10, r10, #255
 959:../uvc.c      **** 			 	 		 }else{
 2930              		.loc 1 959 0
 2931 189c FF4004E2 		and	r4, r4, #255
 958:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2932              		.loc 1 958 0
 2933 18a0 28A0C7E5 		strb	r10, [r7, #40]
 959:../uvc.c      **** 			 	 		 }else{
 2934              		.loc 1 959 0
 2935 18a4 2940C7E5 		strb	r4, [r7, #41]
 2936 18a8 EEFFFFEA 		b	.L316
 2937              	.L308:
1150:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2938              		.loc 1 1150 0
 2939 18ac DC7A9FE5 		ldr	r7, .L474+64
 2940 18b0 CC20D7E5 		ldrb	r2, [r7, #204]	@ zero_extendqisi2
 2941 18b4 000052E3 		cmp	r2, #0
 2942 18b8 2E05000A 		beq	.L338
1151:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2943              		.loc 1 1151 0
 2944 18bc B9A5D6E5 		ldrb	r10, [r6, #1465]	@ zero_extendqisi2
1152:../uvc.c      **** 		 	 		 }else{
 2945              		.loc 1 1152 0
 2946 18c0 BA45D6E5 		ldrb	r4, [r6, #1466]	@ zero_extendqisi2
1151:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2947              		.loc 1 1151 0
 2948 18c4 FFA00AE2 		and	r10, r10, #255
1152:../uvc.c      **** 		 	 		 }else{
 2949              		.loc 1 1152 0
 2950 18c8 FF4004E2 		and	r4, r4, #255
1151:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2951              		.loc 1 1151 0
 2952 18cc 28A0C7E5 		strb	r10, [r7, #40]
1152:../uvc.c      **** 		 	 		 }else{
 2953              		.loc 1 1152 0
 2954 18d0 2940C7E5 		strb	r4, [r7, #41]
 2955 18d4 E3FFFFEA 		b	.L316
 2956              	.L306:
1124:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2957              		.loc 1 1124 0
 2958 18d8 B07A9FE5 		ldr	r7, .L474+64
 2959 18dc CA20D7E5 		ldrb	r2, [r7, #202]	@ zero_extendqisi2
 2960 18e0 000052E3 		cmp	r2, #0
 2961 18e4 1205000A 		beq	.L334
1125:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2962              		.loc 1 1125 0
 2963 18e8 91A5D6E5 		ldrb	r10, [r6, #1425]	@ zero_extendqisi2
1126:../uvc.c      **** 		 	 		 }else{
 2964              		.loc 1 1126 0
 2965 18ec 9245D6E5 		ldrb	r4, [r6, #1426]	@ zero_extendqisi2
1125:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2966              		.loc 1 1125 0
 2967 18f0 FFA00AE2 		and	r10, r10, #255
1126:../uvc.c      **** 		 	 		 }else{
 2968              		.loc 1 1126 0
 2969 18f4 FF4004E2 		and	r4, r4, #255
1125:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2970              		.loc 1 1125 0
 2971 18f8 28A0C7E5 		strb	r10, [r7, #40]
1126:../uvc.c      **** 		 	 		 }else{
 2972              		.loc 1 1126 0
 2973 18fc 2940C7E5 		strb	r4, [r7, #41]
 2974 1900 D8FFFFEA 		b	.L316
 2975              	.L307:
1137:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2976              		.loc 1 1137 0
 2977 1904 847A9FE5 		ldr	r7, .L474+64
 2978 1908 CB20D7E5 		ldrb	r2, [r7, #203]	@ zero_extendqisi2
 2979 190c 000052E3 		cmp	r2, #0
 2980 1910 2905000A 		beq	.L336
1138:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2981              		.loc 1 1138 0
 2982 1914 A5A5D6E5 		ldrb	r10, [r6, #1445]	@ zero_extendqisi2
1139:../uvc.c      **** 		 	 		 }else{
 2983              		.loc 1 1139 0
 2984 1918 A645D6E5 		ldrb	r4, [r6, #1446]	@ zero_extendqisi2
1138:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2985              		.loc 1 1138 0
 2986 191c FFA00AE2 		and	r10, r10, #255
1139:../uvc.c      **** 		 	 		 }else{
 2987              		.loc 1 1139 0
 2988 1920 FF4004E2 		and	r4, r4, #255
1138:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2989              		.loc 1 1138 0
 2990 1924 28A0C7E5 		strb	r10, [r7, #40]
1139:../uvc.c      **** 		 	 		 }else{
 2991              		.loc 1 1139 0
 2992 1928 2940C7E5 		strb	r4, [r7, #41]
 2993 192c CDFFFFEA 		b	.L316
 2994              	.L305:
1111:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2995              		.loc 1 1111 0
 2996 1930 587A9FE5 		ldr	r7, .L474+64
 2997 1934 C920D7E5 		ldrb	r2, [r7, #201]	@ zero_extendqisi2
 2998 1938 000052E3 		cmp	r2, #0
 2999 193c 2F05000A 		beq	.L332
1112:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3000              		.loc 1 1112 0
 3001 1940 7DA5D6E5 		ldrb	r10, [r6, #1405]	@ zero_extendqisi2
1113:../uvc.c      **** 		 	 		 }else{
 3002              		.loc 1 1113 0
 3003 1944 7E45D6E5 		ldrb	r4, [r6, #1406]	@ zero_extendqisi2
1112:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3004              		.loc 1 1112 0
 3005 1948 FFA00AE2 		and	r10, r10, #255
1113:../uvc.c      **** 		 	 		 }else{
 3006              		.loc 1 1113 0
 3007 194c FF4004E2 		and	r4, r4, #255
1112:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3008              		.loc 1 1112 0
 3009 1950 28A0C7E5 		strb	r10, [r7, #40]
1113:../uvc.c      **** 		 	 		 }else{
 3010              		.loc 1 1113 0
 3011 1954 2940C7E5 		strb	r4, [r7, #41]
 3012 1958 C2FFFFEA 		b	.L316
 3013              	.L310:
1176:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3014              		.loc 1 1176 0
 3015 195c 2C7A9FE5 		ldr	r7, .L474+64
 3016 1960 CE20D7E5 		ldrb	r2, [r7, #206]	@ zero_extendqisi2
 3017 1964 000052E3 		cmp	r2, #0
 3018 1968 6405000A 		beq	.L342
1177:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3019              		.loc 1 1177 0
 3020 196c E1A5D6E5 		ldrb	r10, [r6, #1505]	@ zero_extendqisi2
1178:../uvc.c      **** 		 	 		 }else{
 3021              		.loc 1 1178 0
 3022 1970 E245D6E5 		ldrb	r4, [r6, #1506]	@ zero_extendqisi2
1177:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3023              		.loc 1 1177 0
 3024 1974 FFA00AE2 		and	r10, r10, #255
1178:../uvc.c      **** 		 	 		 }else{
 3025              		.loc 1 1178 0
 3026 1978 FF4004E2 		and	r4, r4, #255
1177:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3027              		.loc 1 1177 0
 3028 197c 28A0C7E5 		strb	r10, [r7, #40]
1178:../uvc.c      **** 		 	 		 }else{
 3029              		.loc 1 1178 0
 3030 1980 2940C7E5 		strb	r4, [r7, #41]
 3031 1984 B7FFFFEA 		b	.L316
 3032              	.L304:
1098:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3033              		.loc 1 1098 0
 3034 1988 007A9FE5 		ldr	r7, .L474+64
 3035 198c C820D7E5 		ldrb	r2, [r7, #200]	@ zero_extendqisi2
 3036 1990 000052E3 		cmp	r2, #0
 3037 1994 3705000A 		beq	.L330
1099:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3038              		.loc 1 1099 0
 3039 1998 69A5D6E5 		ldrb	r10, [r6, #1385]	@ zero_extendqisi2
1100:../uvc.c      **** 		 	 		 }else{
 3040              		.loc 1 1100 0
 3041 199c 6A45D6E5 		ldrb	r4, [r6, #1386]	@ zero_extendqisi2
1099:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3042              		.loc 1 1099 0
 3043 19a0 FFA00AE2 		and	r10, r10, #255
1100:../uvc.c      **** 		 	 		 }else{
 3044              		.loc 1 1100 0
 3045 19a4 FF4004E2 		and	r4, r4, #255
1099:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3046              		.loc 1 1099 0
 3047 19a8 28A0C7E5 		strb	r10, [r7, #40]
1100:../uvc.c      **** 		 	 		 }else{
 3048              		.loc 1 1100 0
 3049 19ac 2940C7E5 		strb	r4, [r7, #41]
 3050 19b0 ACFFFFEA 		b	.L316
 3051              	.L298:
1055:../uvc.c      **** 						if(sendData >= 3){
 3052              		.loc 1 1055 0
 3053 19b4 D4799FE5 		ldr	r7, .L474+64
1053:../uvc.c      **** 
 3054              		.loc 1 1053 0
 3055 19b8 99A4D6E5 		ldrb	r10, [r6, #1177]	@ zero_extendqisi2
 3056              	.LVL320:
1055:../uvc.c      **** 						if(sendData >= 3){
 3057              		.loc 1 1055 0
 3058 19bc E020D7E5 		ldrb	r2, [r7, #224]	@ zero_extendqisi2
1053:../uvc.c      **** 
 3059              		.loc 1 1053 0
 3060 19c0 88499FE5 		ldr	r4, .L474
1055:../uvc.c      **** 						if(sendData >= 3){
 3061              		.loc 1 1055 0
 3062 19c4 010052E3 		cmp	r2, #1
 3063 19c8 7905000A 		beq	.L469
 3064              	.LVL321:
 3065              	.L349:
1248:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 3066              		.loc 1 1248 0
 3067 19cc 0030A0E3 		mov	r3, #0
1247:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 3068              		.loc 1 1247 0
 3069 19d0 28A0C7E5 		strb	r10, [r7, #40]
1248:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 3070              		.loc 1 1248 0
 3071 19d4 2930C7E5 		strb	r3, [r7, #41]
 3072              	.LVL322:
1250:../uvc.c      **** 				 case HueCtlID5:
 3073              		.loc 1 1250 0
 3074 19d8 FF40A0E3 		mov	r4, #255
 3075 19dc A1FFFFEA 		b	.L316
 3076              	.LVL323:
 3077              	.L302:
 990:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 3078              		.loc 1 990 0
 3079 19e0 A8799FE5 		ldr	r7, .L474+64
 3080 19e4 C620D7E5 		ldrb	r2, [r7, #198]	@ zero_extendqisi2
 3081 19e8 000052E3 		cmp	r2, #0
 3082 19ec 1405000A 		beq	.L319
 991:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 3083              		.loc 1 991 0
 3084 19f0 09A1D6E5 		ldrb	r10, [r6, #265]	@ zero_extendqisi2
 992:../uvc.c      **** 			 	 		 }else{
 3085              		.loc 1 992 0
 3086 19f4 0A41D6E5 		ldrb	r4, [r6, #266]	@ zero_extendqisi2
 991:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 3087              		.loc 1 991 0
 3088 19f8 28A0C7E5 		strb	r10, [r7, #40]
 992:../uvc.c      **** 			 	 		 }else{
 3089              		.loc 1 992 0
 3090 19fc 2940C7E5 		strb	r4, [r7, #41]
 3091 1a00 98FFFFEA 		b	.L316
 3092              	.L309:
1163:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3093              		.loc 1 1163 0
 3094 1a04 84799FE5 		ldr	r7, .L474+64
 3095 1a08 CD20D7E5 		ldrb	r2, [r7, #205]	@ zero_extendqisi2
 3096 1a0c 000052E3 		cmp	r2, #0
 3097 1a10 4B05000A 		beq	.L340
1164:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3098              		.loc 1 1164 0
 3099 1a14 CDA5D6E5 		ldrb	r10, [r6, #1485]	@ zero_extendqisi2
1165:../uvc.c      **** 		 	 		 }else{
 3100              		.loc 1 1165 0
 3101 1a18 CE45D6E5 		ldrb	r4, [r6, #1486]	@ zero_extendqisi2
1164:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3102              		.loc 1 1164 0
 3103 1a1c FFA00AE2 		and	r10, r10, #255
1165:../uvc.c      **** 		 	 		 }else{
 3104              		.loc 1 1165 0
 3105 1a20 FF4004E2 		and	r4, r4, #255
1164:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3106              		.loc 1 1164 0
 3107 1a24 28A0C7E5 		strb	r10, [r7, #40]
1165:../uvc.c      **** 		 	 		 }else{
 3108              		.loc 1 1165 0
 3109 1a28 2940C7E5 		strb	r4, [r7, #41]
 3110 1a2c 8DFFFFEA 		b	.L316
 3111              	.L303:
1085:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3112              		.loc 1 1085 0
 3113 1a30 58799FE5 		ldr	r7, .L474+64
 3114 1a34 C720D7E5 		ldrb	r2, [r7, #199]	@ zero_extendqisi2
 3115 1a38 000052E3 		cmp	r2, #0
 3116 1a3c 1E05000A 		beq	.L328
1086:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3117              		.loc 1 1086 0
 3118 1a40 55A5D6E5 		ldrb	r10, [r6, #1365]	@ zero_extendqisi2
1087:../uvc.c      **** 		 	 		 }else{
 3119              		.loc 1 1087 0
 3120 1a44 5645D6E5 		ldrb	r4, [r6, #1366]	@ zero_extendqisi2
1086:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3121              		.loc 1 1086 0
 3122 1a48 FFA00AE2 		and	r10, r10, #255
1087:../uvc.c      **** 		 	 		 }else{
 3123              		.loc 1 1087 0
 3124 1a4c FF4004E2 		and	r4, r4, #255
1086:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3125              		.loc 1 1086 0
 3126 1a50 28A0C7E5 		strb	r10, [r7, #40]
1087:../uvc.c      **** 		 	 		 }else{
 3127              		.loc 1 1087 0
 3128 1a54 2940C7E5 		strb	r4, [r7, #41]
 3129 1a58 82FFFFEA 		b	.L316
 3130              	.L297:
1040:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3131              		.loc 1 1040 0
 3132 1a5c 2C799FE5 		ldr	r7, .L474+64
1033:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3133              		.loc 1 1033 0
 3134 1a60 3435D6E5 		ldrb	r3, [r6, #1332]	@ zero_extendqisi2
1040:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3135              		.loc 1 1040 0
 3136 1a64 BB10D7E5 		ldrb	r1, [r7, #187]	@ zero_extendqisi2
1034:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 3137              		.loc 1 1034 0
 3138 1a68 3525D6E5 		ldrb	r2, [r6, #1333]	@ zero_extendqisi2
1035:../uvc.c      **** 
 3139              		.loc 1 1035 0
 3140 1a6c 4335D6E5 		ldrb	r3, [r6, #1347]	@ zero_extendqisi2
1040:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3141              		.loc 1 1040 0
 3142 1a70 000051E3 		cmp	r1, #0
1034:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 3143              		.loc 1 1034 0
 3144 1a74 FF0002E2 		and	r0, r2, #255
 3145              	.LVL324:
1035:../uvc.c      **** 
 3146              		.loc 1 1035 0
 3147 1a78 FF1003E2 		and	r1, r3, #255
 3148              	.LVL325:
1033:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3149              		.loc 1 1033 0
 3150 1a7c CC489FE5 		ldr	r4, .L474
1040:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3151              		.loc 1 1040 0
 3152 1a80 4005000A 		beq	.L323
1041:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3153              		.loc 1 1041 0
 3154 1a84 41A5D4E5 		ldrb	r10, [r4, #1345]	@ zero_extendqisi2
1042:../uvc.c      **** 		 	 		 }else{
 3155              		.loc 1 1042 0
 3156 1a88 4245D4E5 		ldrb	r4, [r4, #1346]	@ zero_extendqisi2
1041:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3157              		.loc 1 1041 0
 3158 1a8c FFA00AE2 		and	r10, r10, #255
1042:../uvc.c      **** 		 	 		 }else{
 3159              		.loc 1 1042 0
 3160 1a90 FF4004E2 		and	r4, r4, #255
1041:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3161              		.loc 1 1041 0
 3162 1a94 28A0C7E5 		strb	r10, [r7, #40]
1042:../uvc.c      **** 		 	 		 }else{
 3163              		.loc 1 1042 0
 3164 1a98 2940C7E5 		strb	r4, [r7, #41]
 3165 1a9c 71FFFFEA 		b	.L316
 3166              	.LVL326:
 3167              	.L301:
 972:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3168              		.loc 1 972 0
 3169 1aa0 E8789FE5 		ldr	r7, .L474+64
 3170 1aa4 C520D7E5 		ldrb	r2, [r7, #197]	@ zero_extendqisi2
 3171 1aa8 000052E3 		cmp	r2, #0
 3172 1aac 3104000A 		beq	.L317
 973:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3173              		.loc 1 973 0
 3174 1ab0 19A5D6E5 		ldrb	r10, [r6, #1305]	@ zero_extendqisi2
 974:../uvc.c      **** 			 	 		 }else{
 3175              		.loc 1 974 0
 3176 1ab4 1A45D6E5 		ldrb	r4, [r6, #1306]	@ zero_extendqisi2
 973:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3177              		.loc 1 973 0
 3178 1ab8 FFA00AE2 		and	r10, r10, #255
 974:../uvc.c      **** 			 	 		 }else{
 3179              		.loc 1 974 0
 3180 1abc FF4004E2 		and	r4, r4, #255
 973:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3181              		.loc 1 973 0
 3182 1ac0 28A0C7E5 		strb	r10, [r7, #40]
 974:../uvc.c      **** 			 	 		 }else{
 3183              		.loc 1 974 0
 3184 1ac4 2940C7E5 		strb	r4, [r7, #41]
 3185 1ac8 66FFFFEA 		b	.L316
 3186              	.L296:
1196:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3187              		.loc 1 1196 0
 3188 1acc BC789FE5 		ldr	r7, .L474+64
1190:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3189              		.loc 1 1190 0
 3190 1ad0 E815D6E5 		ldrb	r1, [r6, #1512]	@ zero_extendqisi2
1196:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3191              		.loc 1 1196 0
 3192 1ad4 B900D7E5 		ldrb	r0, [r7, #185]	@ zero_extendqisi2
 3193              	.LVL327:
1191:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 3194              		.loc 1 1191 0
 3195 1ad8 E925D6E5 		ldrb	r2, [r6, #1513]	@ zero_extendqisi2
1192:../uvc.c      **** 
 3196              		.loc 1 1192 0
 3197 1adc F735D6E5 		ldrb	r3, [r6, #1527]	@ zero_extendqisi2
1196:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3198              		.loc 1 1196 0
 3199 1ae0 000050E3 		cmp	r0, #0
1191:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 3200              		.loc 1 1191 0
 3201 1ae4 FF8002E2 		and	r8, r2, #255
 3202              	.LVL328:
1190:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3203              		.loc 1 1190 0
 3204 1ae8 FF0001E2 		and	r0, r1, #255
 3205              	.LVL329:
1192:../uvc.c      **** 
 3206              		.loc 1 1192 0
 3207 1aec FF4003E2 		and	r4, r3, #255
 3208              	.LVL330:
1190:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3209              		.loc 1 1190 0
 3210 1af0 58689FE5 		ldr	r6, .L474
1196:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3211              		.loc 1 1196 0
 3212 1af4 6E04000A 		beq	.L344
1197:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3213              		.loc 1 1197 0
 3214 1af8 F5A5D6E5 		ldrb	r10, [r6, #1525]	@ zero_extendqisi2
1198:../uvc.c      **** 		 	 		 }else{
 3215              		.loc 1 1198 0
 3216 1afc F645D6E5 		ldrb	r4, [r6, #1526]	@ zero_extendqisi2
 3217              	.LVL331:
1197:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3218              		.loc 1 1197 0
 3219 1b00 FFA00AE2 		and	r10, r10, #255
1198:../uvc.c      **** 		 	 		 }else{
 3220              		.loc 1 1198 0
 3221 1b04 FF4004E2 		and	r4, r4, #255
1197:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3222              		.loc 1 1197 0
 3223 1b08 28A0C7E5 		strb	r10, [r7, #40]
1198:../uvc.c      **** 		 	 		 }else{
 3224              		.loc 1 1198 0
 3225 1b0c 2A40C7E5 		strb	r4, [r7, #42]
 3226              	.LVL332:
 3227              	.L345:
1212:../uvc.c      **** 					 //glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 3228              		.loc 1 1212 0
 3229 1b10 00C0A0E3 		mov	ip, #0
1217:../uvc.c      **** 					 break;
 3230              		.loc 1 1217 0
 3231 1b14 00408DE5 		str	r4, [sp]
 3232 1b18 04C08DE5 		str	ip, [sp, #4]
 3233 1b1c 0A20A0E1 		mov	r2, r10
 3234 1b20 0C30A0E1 		mov	r3, ip
 3235 1b24 40189FE5 		ldr	r1, .L474+28
1212:../uvc.c      **** 					 //glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 3236              		.loc 1 1212 0
 3237 1b28 29C0C7E5 		strb	ip, [r7, #41]
1214:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 3238              		.loc 1 1214 0
 3239 1b2c 2BC0C7E5 		strb	ip, [r7, #43]
 3240              	.LVL333:
1217:../uvc.c      **** 					 break;
 3241              		.loc 1 1217 0
 3242 1b30 0400A0E3 		mov	r0, #4
 3243 1b34 FEFFFFEB 		bl	CyU3PDebugPrint
 3244              	.LVL334:
1218:../uvc.c      **** 
 3245              		.loc 1 1218 0
 3246 1b38 4AFFFFEA 		b	.L316
 3247              	.LVL335:
 3248              	.L396:
1711:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 3249              		.loc 1 1711 0 discriminator 1
 3250 1b3c 000059E3 		cmp	r9, #0
 3251 1b40 0300000A 		beq	.L420
 3252 1b44 24089FE5 		ldr	r0, .L474+32
 3253              	.LVL336:
 3254 1b48 0920A0E1 		mov	r2, r9
 3255 1b4c 6C1040E2 		sub	r1, r0, #108
 3256 1b50 FEFFFFEB 		bl	memcpy
 3257              	.LVL337:
 3258              	.L420:
1715:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 3259              		.loc 1 1715 0
 3260 1b54 FF40A0E3 		mov	r4, #255
1714:../uvc.c      **** 							 break;
 3261              		.loc 1 1714 0
 3262 1b58 FEFFFFEB 		bl	I2CCmdHandler
 3263              	.LVL338:
 3264 1b5c 0B70A0E1 		mov	r7, fp
 3265 1b60 18909DE5 		ldr	r9, [sp, #24]
1715:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 3266              		.loc 1 1715 0
 3267 1b64 04A0A0E1 		mov	r10, r4
 3268 1b68 2CFEFFEA 		b	.L284
 3269              	.LVL339:
 3270              	.L288:
1234:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 3271              		.loc 1 1234 0
 3272 1b6c 1C789FE5 		ldr	r7, .L474+64
 3273 1b70 A120D7E5 		ldrb	r2, [r7, #161]	@ zero_extendqisi2
 3274 1b74 000052E3 		cmp	r2, #0
 3275 1b78 4604000A 		beq	.L346
1235:../uvc.c      **** 		 	 		 }else{
 3276              		.loc 1 1235 0
 3277 1b7c 1102D6E5 		ldrb	r0, [r6, #529]	@ zero_extendqisi2
 3278              	.LVL340:
 3279              	.L347:
1242:../uvc.c      **** 						  Data0 = ~Data0;
 3280              		.loc 1 1242 0
 3281 1b80 800010E3 		tst	r0, #128
1243:../uvc.c      **** 					  }else{
 3282              		.loc 1 1243 0
 3283 1b84 0000E011 		mvnne	r0, r0
 3284              	.LVL341:
 3285 1b88 FFA00012 		andne	r10, r0, #255
1242:../uvc.c      **** 						  Data0 = ~Data0;
 3286              		.loc 1 1242 0
 3287 1b8c 8EFFFF1A 		bne	.L349
 3288              	.L348:
1245:../uvc.c      **** 					  }
 3289              		.loc 1 1245 0
 3290 1b90 800040E2 		sub	r0, r0, #128
 3291 1b94 FFA000E2 		and	r10, r0, #255
 3292              	.LVL342:
 3293 1b98 8BFFFFEA 		b	.L349
 3294              	.LVL343:
 3295              	.L286:
1287:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 3296              		.loc 1 1287 0
 3297 1b9c EC779FE5 		ldr	r7, .L474+64
 3298 1ba0 A020D7E5 		ldrb	r2, [r7, #160]	@ zero_extendqisi2
 3299 1ba4 000052E3 		cmp	r2, #0
 3300 1ba8 B303000A 		beq	.L354
1288:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3301              		.loc 1 1288 0
 3302 1bac 0DA6D6E5 		ldrb	r10, [r6, #1549]	@ zero_extendqisi2
1289:../uvc.c      **** 		 	 		 }else{
 3303              		.loc 1 1289 0
 3304 1bb0 0E46D6E5 		ldrb	r4, [r6, #1550]	@ zero_extendqisi2
1288:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3305              		.loc 1 1288 0
 3306 1bb4 FFA00AE2 		and	r10, r10, #255
1289:../uvc.c      **** 		 	 		 }else{
 3307              		.loc 1 1289 0
 3308 1bb8 FF4004E2 		and	r4, r4, #255
1288:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3309              		.loc 1 1288 0
 3310 1bbc 28A0C7E5 		strb	r10, [r7, #40]
1289:../uvc.c      **** 		 	 		 }else{
 3311              		.loc 1 1289 0
 3312 1bc0 2940C7E5 		strb	r4, [r7, #41]
 3313 1bc4 27FFFFEA 		b	.L316
 3314              	.LVL344:
 3315              	.L401:
1650:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3316              		.loc 1 1650 0
 3317 1bc8 A4379FE5 		ldr	r3, .L474+36
1654:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
 3318              		.loc 1 1654 0
 3319 1bcc CC779FE5 		ldr	r7, .L474+80
1650:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3320              		.loc 1 1650 0
 3321 1bd0 043183E0 		add	r3, r3, r4, asl #2
 3322 1bd4 20A013E5 		ldr	r10, [r3, #-32]
1654:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
 3323              		.loc 1 1654 0
 3324 1bd8 1C0097E5 		ldr	r0, [r7, #28]
 3325              	.LVL345:
1650:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3326              		.loc 1 1650 0
 3327 1bdc 0030DAE5 		ldrb	r3, [r10]	@ zero_extendqisi2
1654:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
 3328              		.loc 1 1654 0
 3329 1be0 0010E0E3 		mvn	r1, #0
1650:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3330              		.loc 1 1650 0
 3331 1be4 FF3003E2 		and	r3, r3, #255
1651:../uvc.c      **** 						     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 3332              		.loc 1 1651 0
 3333 1be8 0190DAE5 		ldrb	r9, [r10, #1]	@ zero_extendqisi2
1650:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3334              		.loc 1 1650 0
 3335 1bec 1C308DE5 		str	r3, [sp, #28]
 3336              	.LVL346:
1652:../uvc.c      **** 						     dataIdx = 0;
 3337              		.loc 1 1652 0
 3338 1bf0 0F80DAE5 		ldrb	r8, [r10, #15]	@ zero_extendqisi2
 3339              	.LVL347:
1654:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
 3340              		.loc 1 1654 0
 3341 1bf4 FEFFFFEB 		bl	_txe_mutex_get
 3342              	.LVL348:
1655:../uvc.c      **** 							 {
 3343              		.loc 1 1655 0
 3344 1bf8 0D30DAE5 		ldrb	r3, [r10, #13]	@ zero_extendqisi2
1651:../uvc.c      **** 						     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 3345              		.loc 1 1651 0
 3346 1bfc FF9009E2 		and	r9, r9, #255
 3347              	.LVL349:
1655:../uvc.c      **** 							 {
 3348              		.loc 1 1655 0
 3349 1c00 03005BE1 		cmp	fp, r3
1652:../uvc.c      **** 						     dataIdx = 0;
 3350              		.loc 1 1652 0
 3351 1c04 FF8008E2 		and	r8, r8, #255
 3352              	.LVL350:
1655:../uvc.c      **** 							 {
 3353              		.loc 1 1655 0
 3354 1c08 0800000A 		beq	.L417
1659:../uvc.c      **** 								 /*
 3355              		.loc 1 1659 0
 3356 1c0c 0030A0E3 		mov	r3, #0
1657:../uvc.c      **** 								 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 3357              		.loc 1 1657 0
 3358 1c10 0DB0CAE5 		strb	fp, [r10, #13]
1659:../uvc.c      **** 								 /*
 3359              		.loc 1 1659 0
 3360 1c14 1C209DE5 		ldr	r2, [sp, #28]
 3361 1c18 04308DE5 		str	r3, [sp, #4]
 3362 1c1c 00B08DE5 		str	fp, [sp]
 3363 1c20 0700A0E1 		mov	r0, r7
 3364 1c24 0410A0E1 		mov	r1, r4
 3365 1c28 0830A0E1 		mov	r3, r8
 3366 1c2c FEFFFFEB 		bl	cmdSet
 3367              	.LVL351:
 3368              	.L417:
1671:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 3369              		.loc 1 1671 0
 3370 1c30 0E30DAE5 		ldrb	r3, [r10, #14]	@ zero_extendqisi2
 3371 1c34 18109DE5 		ldr	r1, [sp, #24]
 3372 1c38 010053E1 		cmp	r3, r1
 3373 1c3c 0900000A 		beq	.L418
 3374 1c40 0120A0E1 		mov	r2, r1
1673:../uvc.c      **** 							 }
 3375              		.loc 1 1673 0
 3376 1c44 0000A0E3 		mov	r0, #0
1672:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 3377              		.loc 1 1672 0
 3378 1c48 0E10CAE5 		strb	r1, [r10, #14]
1673:../uvc.c      **** 							 }
 3379              		.loc 1 1673 0
 3380 1c4c 0830A0E1 		mov	r3, r8
 3381 1c50 00208DE5 		str	r2, [sp]
 3382 1c54 04008DE5 		str	r0, [sp, #4]
 3383 1c58 0410A0E1 		mov	r1, r4
 3384 1c5c 0920A0E1 		mov	r2, r9
 3385 1c60 38079FE5 		ldr	r0, .L474+80
 3386 1c64 FEFFFFEB 		bl	cmdSet
 3387              	.LVL352:
 3388              	.L418:
1676:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3389              		.loc 1 1676 0
 3390 1c68 1C0097E5 		ldr	r0, [r7, #28]
 3391 1c6c FEFFFFEB 		bl	_txe_mutex_put
 3392              	.LVL353:
1678:../uvc.c      **** 							 break;
 3393              		.loc 1 1678 0
 3394 1c70 F525D6E5 		ldrb	r2, [r6, #1525]	@ zero_extendqisi2
1677:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3395              		.loc 1 1677 0
 3396 1c74 18909DE5 		ldr	r9, [sp, #24]
 3397              	.LVL354:
1678:../uvc.c      **** 							 break;
 3398              		.loc 1 1678 0
 3399 1c78 F635D6E5 		ldrb	r3, [r6, #1526]	@ zero_extendqisi2
 3400 1c7c 2D15D6E5 		ldrb	r1, [r6, #1325]	@ zero_extendqisi2
1677:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3401              		.loc 1 1677 0
 3402 1c80 0B70A0E1 		mov	r7, fp
 3403 1c84 82028DE8 		stmia	sp, {r1, r7, r9}
 3404 1c88 E8169FE5 		ldr	r1, .L474+40
 3405 1c8c 0400A0E3 		mov	r0, #4
1679:../uvc.c      **** 
 3406              		.loc 1 1679 0
 3407 1c90 FF40A0E3 		mov	r4, #255
 3408              	.LVL355:
1677:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3409              		.loc 1 1677 0
 3410 1c94 FEFFFFEB 		bl	CyU3PDebugPrint
 3411              	.LVL356:
1679:../uvc.c      **** 
 3412              		.loc 1 1679 0
 3413 1c98 04A0A0E1 		mov	r10, r4
 3414 1c9c DFFDFFEA 		b	.L284
 3415              	.LVL357:
 3416              	.L400:
1621:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3417              		.loc 1 1621 0
 3418 1ca0 CC369FE5 		ldr	r3, .L474+36
1625:../uvc.c      **** 							 if(0&&pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
 3419              		.loc 1 1625 0
 3420 1ca4 F4769FE5 		ldr	r7, .L474+80
1621:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3421              		.loc 1 1621 0
 3422 1ca8 043183E0 		add	r3, r3, r4, asl #2
 3423 1cac 20A013E5 		ldr	r10, [r3, #-32]
1625:../uvc.c      **** 							 if(0&&pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
 3424              		.loc 1 1625 0
 3425 1cb0 1C0097E5 		ldr	r0, [r7, #28]
 3426              	.LVL358:
 3427 1cb4 0010E0E3 		mvn	r1, #0
1621:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3428              		.loc 1 1621 0
 3429 1cb8 0090DAE5 		ldrb	r9, [r10]	@ zero_extendqisi2
1622:../uvc.c      **** 						     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 3430              		.loc 1 1622 0
 3431 1cbc 0130DAE5 		ldrb	r3, [r10, #1]	@ zero_extendqisi2
1623:../uvc.c      **** 						     dataIdx = 0;
 3432              		.loc 1 1623 0
 3433 1cc0 0F80DAE5 		ldrb	r8, [r10, #15]	@ zero_extendqisi2
 3434              	.LVL359:
1625:../uvc.c      **** 							 if(0&&pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
 3435              		.loc 1 1625 0
 3436 1cc4 FEFFFFEB 		bl	_txe_mutex_get
 3437              	.LVL360:
1633:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 3438              		.loc 1 1633 0
 3439 1cc8 0D30DAE5 		ldrb	r3, [r10, #13]	@ zero_extendqisi2
1621:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3440              		.loc 1 1621 0
 3441 1ccc FF9009E2 		and	r9, r9, #255
 3442              	.LVL361:
1633:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 3443              		.loc 1 1633 0
 3444 1cd0 03005BE1 		cmp	fp, r3
1623:../uvc.c      **** 						     dataIdx = 0;
 3445              		.loc 1 1623 0
 3446 1cd4 FF8008E2 		and	r8, r8, #255
 3447              	.LVL362:
1633:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 3448              		.loc 1 1633 0
 3449 1cd8 0700000A 		beq	.L414
1634:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 3450              		.loc 1 1634 0
 3451 1cdc 0DB0CAE5 		strb	fp, [r10, #13]
1635:../uvc.c      **** 									 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 3452              		.loc 1 1635 0
 3453 1ce0 F525D6E5 		ldrb	r2, [r6, #1525]	@ zero_extendqisi2
 3454 1ce4 64369FE5 		ldr	r3, .L474
 3455 1ce8 010052E3 		cmp	r2, #1
 3456 1cec 5903000A 		beq	.L415
1635:../uvc.c      **** 									 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 3457              		.loc 1 1635 0 is_stmt 0 discriminator 1
 3458 1cf0 F535D3E5 		ldrb	r3, [r3, #1525]	@ zero_extendqisi2
 3459 1cf4 030053E3 		cmp	r3, #3
 3460 1cf8 5603000A 		beq	.L415
 3461              	.LVL363:
 3462              	.L414:
1642:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3463              		.loc 1 1642 0 is_stmt 1
 3464 1cfc 1C0097E5 		ldr	r0, [r7, #28]
 3465 1d00 FEFFFFEB 		bl	_txe_mutex_put
 3466              	.LVL364:
1644:../uvc.c      **** 							 break;
 3467              		.loc 1 1644 0
 3468 1d04 F525D6E5 		ldrb	r2, [r6, #1525]	@ zero_extendqisi2
1643:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3469              		.loc 1 1643 0
 3470 1d08 18909DE5 		ldr	r9, [sp, #24]
1644:../uvc.c      **** 							 break;
 3471              		.loc 1 1644 0
 3472 1d0c F635D6E5 		ldrb	r3, [r6, #1526]	@ zero_extendqisi2
 3473 1d10 4115D6E5 		ldrb	r1, [r6, #1345]	@ zero_extendqisi2
1643:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3474              		.loc 1 1643 0
 3475 1d14 0B70A0E1 		mov	r7, fp
 3476 1d18 82028DE8 		stmia	sp, {r1, r7, r9}
 3477 1d1c 58169FE5 		ldr	r1, .L474+44
 3478 1d20 0400A0E3 		mov	r0, #4
1645:../uvc.c      **** 
 3479              		.loc 1 1645 0
 3480 1d24 FF40A0E3 		mov	r4, #255
1643:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3481              		.loc 1 1643 0
 3482 1d28 FEFFFFEB 		bl	CyU3PDebugPrint
 3483              	.LVL365:
1645:../uvc.c      **** 
 3484              		.loc 1 1645 0
 3485 1d2c 04A0A0E1 		mov	r10, r4
 3486 1d30 BAFDFFEA 		b	.L284
 3487              	.LVL366:
 3488              	.L399:
1772:../uvc.c      **** 							 if(Data0 == 1){
 3489              		.loc 1 1772 0
 3490 1d34 8870A0E1 		mov	r7, r8, asl #1
 3491 1d38 082087E0 		add	r2, r7, r8
 3492 1d3c 822186E0 		add	r2, r6, r2, asl #3
 3493 1d40 79B0C2E5 		strb	fp, [r2, #121]
 3494 1d44 04269FE5 		ldr	r2, .L474
1778:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3495              		.loc 1 1778 0
 3496 1d48 50469FE5 		ldr	r4, .L474+80
1774:../uvc.c      **** 							 }else{
 3497              		.loc 1 1774 0
 3498 1d4c 0D96D2E5 		ldrb	r9, [r2, #1549]	@ zero_extendqisi2
1773:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3499              		.loc 1 1773 0
 3500 1d50 01005BE3 		cmp	fp, #1
1778:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3501              		.loc 1 1778 0
 3502 1d54 1C0094E5 		ldr	r0, [r4, #28]
 3503              	.LVL367:
 3504 1d58 0010E0E3 		mvn	r1, #0
1774:../uvc.c      **** 							 }else{
 3505              		.loc 1 1774 0
 3506 1d5c 80908903 		orreq	r9, r9, #128
 3507              	.LVL368:
1776:../uvc.c      **** 							 }
 3508              		.loc 1 1776 0
 3509 1d60 7F900912 		andne	r9, r9, #127
 3510              	.LVL369:
1778:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3511              		.loc 1 1778 0
 3512 1d64 14308DE5 		str	r3, [sp, #20]
 3513 1d68 FEFFFFEB 		bl	_txe_mutex_get
 3514              	.LVL370:
1779:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3515              		.loc 1 1779 0
 3516 1d6c 14309DE5 		ldr	r3, [sp, #20]
 3517 1d70 0010A0E3 		mov	r1, #0
 3518 1d74 0320A0E1 		mov	r2, r3
 3519 1d78 00908DE5 		str	r9, [sp]
 3520 1d7c 0A30A0E1 		mov	r3, r10
 3521 1d80 0400A0E1 		mov	r0, r4
 3522 1d84 04108DE5 		str	r1, [sp, #4]
 3523 1d88 2610A0E3 		mov	r1, #38
 3524 1d8c FEFFFFEB 		bl	cmdSet
 3525              	.LVL371:
1782:../uvc.c      **** 							 break;
 3526              		.loc 1 1782 0
 3527 1d90 087087E0 		add	r7, r7, r8
1780:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
 3528              		.loc 1 1780 0
 3529 1d94 1C0094E5 		ldr	r0, [r4, #28]
 3530 1d98 FEFFFFEB 		bl	_txe_mutex_put
 3531              	.LVL372:
1782:../uvc.c      **** 							 break;
 3532              		.loc 1 1782 0
 3533 1d9c 876186E0 		add	r6, r6, r7, asl #3
 3534 1da0 0130A0E3 		mov	r3, #1
1783:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 3535              		.loc 1 1783 0
 3536 1da4 FF40A0E3 		mov	r4, #255
 3537 1da8 0B70A0E1 		mov	r7, fp
 3538 1dac 18909DE5 		ldr	r9, [sp, #24]
 3539              	.LVL373:
1782:../uvc.c      **** 							 break;
 3540              		.loc 1 1782 0
 3541 1db0 7C30C6E5 		strb	r3, [r6, #124]
1783:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 3542              		.loc 1 1783 0
 3543 1db4 04A0A0E1 		mov	r10, r4
 3544 1db8 98FDFFEA 		b	.L284
 3545              	.LVL374:
 3546              	.L398:
1762:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 3547              		.loc 1 1762 0
 3548 1dbc DC459FE5 		ldr	r4, .L474+80
1757:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3549              		.loc 1 1757 0
 3550 1dc0 0C85D6E5 		ldrb	r8, [r6, #1292]	@ zero_extendqisi2
 3551              	.LVL375:
1758:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
 3552              		.loc 1 1758 0
 3553 1dc4 0D35D6E5 		ldrb	r3, [r6, #1293]	@ zero_extendqisi2
1759:../uvc.c      **** 
 3554              		.loc 1 1759 0
 3555 1dc8 1B75D6E5 		ldrb	r7, [r6, #1307]	@ zero_extendqisi2
1762:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 3556              		.loc 1 1762 0
 3557 1dcc 1C0094E5 		ldr	r0, [r4, #28]
 3558              	.LVL376:
 3559 1dd0 0010E0E3 		mvn	r1, #0
 3560 1dd4 FEFFFFEB 		bl	_txe_mutex_get
 3561              	.LVL377:
1759:../uvc.c      **** 
 3562              		.loc 1 1759 0
 3563 1dd8 FF7007E2 		and	r7, r7, #255
1763:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3564              		.loc 1 1763 0
 3565 1ddc 0010A0E3 		mov	r1, #0
1757:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3566              		.loc 1 1757 0
 3567 1de0 FF8008E2 		and	r8, r8, #255
 3568              	.LVL378:
1763:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3569              		.loc 1 1763 0
 3570 1de4 0730A0E1 		mov	r3, r7
 3571 1de8 0820A0E1 		mov	r2, r8
 3572 1dec 0400A0E1 		mov	r0, r4
 3573 1df0 04108DE5 		str	r1, [sp, #4]
 3574 1df4 00B08DE5 		str	fp, [sp]
 3575 1df8 2510A0E3 		mov	r1, #37
 3576 1dfc FEFFFFEB 		bl	cmdSet
 3577              	.LVL379:
1764:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
 3578              		.loc 1 1764 0
 3579 1e00 1C0094E5 		ldr	r0, [r4, #28]
 3580 1e04 FEFFFFEB 		bl	_txe_mutex_put
 3581              	.LVL380:
1769:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 3582              		.loc 1 1769 0
 3583 1e08 FF40A0E3 		mov	r4, #255
1766:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
 3584              		.loc 1 1766 0
 3585 1e0c 0130A0E3 		mov	r3, #1
1765:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 3586              		.loc 1 1765 0
 3587 1e10 19B5C6E5 		strb	fp, [r6, #1305]
 3588 1e14 18909DE5 		ldr	r9, [sp, #24]
 3589 1e18 0B70A0E1 		mov	r7, fp
 3590              	.LVL381:
1766:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
 3591              		.loc 1 1766 0
 3592 1e1c 1D35C6E5 		strb	r3, [r6, #1309]
1769:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 3593              		.loc 1 1769 0
 3594 1e20 04A0A0E1 		mov	r10, r4
 3595 1e24 7DFDFFEA 		b	.L284
 3596              	.LVL382:
 3597              	.L397:
1744:../uvc.c      **** 						     /* end test */
 3598              		.loc 1 1744 0
 3599 1e28 70759FE5 		ldr	r7, .L474+80
1717:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3600              		.loc 1 1717 0
 3601 1e2c F884D6E5 		ldrb	r8, [r6, #1272]	@ zero_extendqisi2
 3602              	.LVL383:
1718:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 3603              		.loc 1 1718 0
 3604 1e30 F994D6E5 		ldrb	r9, [r6, #1273]	@ zero_extendqisi2
1719:../uvc.c      **** 
 3605              		.loc 1 1719 0
 3606 1e34 0745D6E5 		ldrb	r4, [r6, #1287]	@ zero_extendqisi2
 3607              	.LVL384:
1744:../uvc.c      **** 						     /* end test */
 3608              		.loc 1 1744 0
 3609 1e38 1C0097E5 		ldr	r0, [r7, #28]
 3610              	.LVL385:
 3611 1e3c 0010E0E3 		mvn	r1, #0
 3612 1e40 FEFFFFEB 		bl	_txe_mutex_get
 3613              	.LVL386:
1719:../uvc.c      **** 
 3614              		.loc 1 1719 0
 3615 1e44 FF4004E2 		and	r4, r4, #255
1717:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3616              		.loc 1 1717 0
 3617 1e48 FF8008E2 		and	r8, r8, #255
 3618              	.LVL387:
1746:../uvc.c      **** 							 dataIdx++;
 3619              		.loc 1 1746 0
 3620 1e4c 0010A0E3 		mov	r1, #0
 3621 1e50 0820A0E1 		mov	r2, r8
 3622 1e54 0430A0E1 		mov	r3, r4
 3623 1e58 0700A0E1 		mov	r0, r7
 3624 1e5c 04108DE5 		str	r1, [sp, #4]
 3625 1e60 00B08DE5 		str	fp, [sp]
 3626 1e64 2410A0E3 		mov	r1, #36
 3627 1e68 FEFFFFEB 		bl	cmdSet
 3628              	.LVL388:
1748:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3629              		.loc 1 1748 0
 3630 1e6c 1C109DE5 		ldr	r1, [sp, #28]
1718:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 3631              		.loc 1 1718 0
 3632 1e70 FF9009E2 		and	r9, r9, #255
 3633              	.LVL389:
1748:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3634              		.loc 1 1748 0
 3635 1e74 0180A0E3 		mov	r8, #1
 3636              	.LVL390:
 3637 1e78 0920A0E1 		mov	r2, r9
 3638 1e7c 0430A0E1 		mov	r3, r4
 3639 1e80 00108DE5 		str	r1, [sp]
 3640 1e84 0700A0E1 		mov	r0, r7
 3641 1e88 2410A0E3 		mov	r1, #36
 3642 1e8c 04808DE5 		str	r8, [sp, #4]
 3643 1e90 FEFFFFEB 		bl	cmdSet
 3644              	.LVL391:
1749:../uvc.c      **** 							 getData1 = Data1;
 3645              		.loc 1 1749 0
 3646 1e94 1C0097E5 		ldr	r0, [r7, #28]
 3647 1e98 FEFFFFEB 		bl	_txe_mutex_put
 3648              	.LVL392:
 3649 1e9c 1C909DE5 		ldr	r9, [sp, #28]
 3650              	.LVL393:
1755:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 3651              		.loc 1 1755 0
 3652 1ea0 FF40A0E3 		mov	r4, #255
 3653              	.LVL394:
1752:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3654              		.loc 1 1752 0
 3655 1ea4 05B5C6E5 		strb	fp, [r6, #1285]
 3656 1ea8 0B70A0E1 		mov	r7, fp
1753:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3657              		.loc 1 1753 0
 3658 1eac 0695C6E5 		strb	r9, [r6, #1286]
1755:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 3659              		.loc 1 1755 0
 3660 1eb0 04A0A0E1 		mov	r10, r4
1754:../uvc.c      **** 							 break;
 3661              		.loc 1 1754 0
 3662 1eb4 0985C6E5 		strb	r8, [r6, #1289]
1755:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 3663              		.loc 1 1755 0
 3664 1eb8 58FDFFEA 		b	.L284
 3665              	.LVL395:
 3666              	.L292:
1304:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 3667              		.loc 1 1304 0
 3668 1ebc CC749FE5 		ldr	r7, .L474+64
 3669 1ec0 A730D7E5 		ldrb	r3, [r7, #167]	@ zero_extendqisi2
 3670 1ec4 000053E3 		cmp	r3, #0
 3671 1ec8 1D03000A 		beq	.L356
1305:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3672              		.loc 1 1305 0
 3673 1ecc 21A6D6E5 		ldrb	r10, [r6, #1569]	@ zero_extendqisi2
1306:../uvc.c      **** 		 	 		 }else{
 3674              		.loc 1 1306 0
 3675 1ed0 2246D6E5 		ldrb	r4, [r6, #1570]	@ zero_extendqisi2
1305:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3676              		.loc 1 1305 0
 3677 1ed4 FFA00AE2 		and	r10, r10, #255
1306:../uvc.c      **** 		 	 		 }else{
 3678              		.loc 1 1306 0
 3679 1ed8 FF4004E2 		and	r4, r4, #255
1305:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3680              		.loc 1 1305 0
 3681 1edc 28A0C7E5 		strb	r10, [r7, #40]
1306:../uvc.c      **** 		 	 		 }else{
 3682              		.loc 1 1306 0
 3683 1ee0 2940C7E5 		strb	r4, [r7, #41]
 3684 1ee4 5FFEFFEA 		b	.L316
 3685              	.L291:
1252:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 3686              		.loc 1 1252 0
 3687 1ee8 A0749FE5 		ldr	r7, .L474+64
 3688 1eec A520D7E5 		ldrb	r2, [r7, #165]	@ zero_extendqisi2
 3689 1ef0 000052E3 		cmp	r2, #0
 3690 1ef4 FC02000A 		beq	.L350
1253:../uvc.c      **** 		 	 		 }else{
 3691              		.loc 1 1253 0
 3692 1ef8 7102D6E5 		ldrb	r0, [r6, #625]	@ zero_extendqisi2
 3693              	.LVL396:
 3694 1efc 23FFFFEA 		b	.L348
 3695              	.LVL397:
 3696              	.L290:
1351:../uvc.c      **** 
 3697              		.loc 1 1351 0
 3698 1f00 88749FE5 		ldr	r7, .L474+64
 3699 1f04 A430D7E5 		ldrb	r3, [r7, #164]	@ zero_extendqisi2
 3700 1f08 000053E3 		cmp	r3, #0
 3701 1f0c FD02000A 		beq	.L362
1353:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
 3702              		.loc 1 1353 0
 3703 1f10 6C3097E5 		ldr	r3, [r7, #108]
1359:../uvc.c      **** 		 	 		 }else{
 3704              		.loc 1 1359 0
 3705 1f14 5A42D6E5 		ldrb	r4, [r6, #602]	@ zero_extendqisi2
1353:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
 3706              		.loc 1 1353 0
 3707 1f18 000053E3 		cmp	r3, #0
 3708 1f1c 02A0A013 		movne	r10, #2
 3709 1f20 01A0A003 		moveq	r10, #1
 3710 1f24 28A0C7E5 		strb	r10, [r7, #40]
1359:../uvc.c      **** 		 	 		 }else{
 3711              		.loc 1 1359 0
 3712 1f28 2940C7E5 		strb	r4, [r7, #41]
 3713 1f2c 4DFEFFEA 		b	.L316
 3714              	.L289:
1321:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
 3715              		.loc 1 1321 0
 3716 1f30 58749FE5 		ldr	r7, .L474+64
 3717 1f34 048087E0 		add	r8, r7, r4
 3718              	.LVL398:
 3719 1f38 A020D8E5 		ldrb	r2, [r8, #160]	@ zero_extendqisi2
 3720 1f3c 000052E3 		cmp	r2, #0
 3721 1f40 2B03000A 		beq	.L358
1322:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 3722              		.loc 1 1322 0
 3723 1f44 29A2D6E5 		ldrb	r10, [r6, #553]	@ zero_extendqisi2
1323:../uvc.c      **** 		 	 		 }else{
 3724              		.loc 1 1323 0
 3725 1f48 2A42D6E5 		ldrb	r4, [r6, #554]	@ zero_extendqisi2
1322:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 3726              		.loc 1 1322 0
 3727 1f4c 28A0C7E5 		strb	r10, [r7, #40]
1323:../uvc.c      **** 		 	 		 }else{
 3728              		.loc 1 1323 0
 3729 1f50 2940C7E5 		strb	r4, [r7, #41]
 3730 1f54 43FEFFEA 		b	.L316
 3731              	.LVL399:
 3732              	.L294:
1269:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 3733              		.loc 1 1269 0
 3734 1f58 30749FE5 		ldr	r7, .L474+64
 3735 1f5c AB20D7E5 		ldrb	r2, [r7, #171]	@ zero_extendqisi2
 3736 1f60 000052E3 		cmp	r2, #0
 3737 1f64 1003000A 		beq	.L352
1270:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 3738              		.loc 1 1270 0
 3739 1f68 FCA5D6E5 		ldrb	r10, [r6, #1532]	@ zero_extendqisi2
1271:../uvc.c      **** 		 	 		 }else{
 3740              		.loc 1 1271 0
 3741 1f6c FE45D6E5 		ldrb	r4, [r6, #1534]	@ zero_extendqisi2
1270:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 3742              		.loc 1 1270 0
 3743 1f70 28A0C7E5 		strb	r10, [r7, #40]
1271:../uvc.c      **** 		 	 		 }else{
 3744              		.loc 1 1271 0
 3745 1f74 2A40C7E5 		strb	r4, [r7, #42]
 3746              	.LVL400:
 3747              	.L353:
1281:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3748              		.loc 1 1281 0
 3749 1f78 0030A0E3 		mov	r3, #0
 3750 1f7c 2930C7E5 		strb	r3, [r7, #41]
1282:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 3751              		.loc 1 1282 0
 3752 1f80 2B30C7E5 		strb	r3, [r7, #43]
 3753              	.LVL401:
1285:../uvc.c      **** 				 case BLCCtlID0:
 3754              		.loc 1 1285 0
 3755 1f84 37FEFFEA 		b	.L316
 3756              	.LVL402:
 3757              	.L295:
1015:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3758              		.loc 1 1015 0
 3759 1f88 00449FE5 		ldr	r4, .L474+64
1008:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3760              		.loc 1 1008 0
 3761 1f8c 2025D6E5 		ldrb	r2, [r6, #1312]	@ zero_extendqisi2
1015:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3762              		.loc 1 1015 0
 3763 1f90 B010D4E5 		ldrb	r1, [r4, #176]	@ zero_extendqisi2
1009:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 3764              		.loc 1 1009 0
 3765 1f94 2135D6E5 		ldrb	r3, [r6, #1313]	@ zero_extendqisi2
1010:../uvc.c      **** 
 3766              		.loc 1 1010 0
 3767 1f98 2F35D6E5 		ldrb	r3, [r6, #1327]	@ zero_extendqisi2
1015:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3768              		.loc 1 1015 0
 3769 1f9c 000051E3 		cmp	r1, #0
1008:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3770              		.loc 1 1008 0
 3771 1fa0 FF0002E2 		and	r0, r2, #255
 3772              	.LVL403:
1010:../uvc.c      **** 
 3773              		.loc 1 1010 0
 3774 1fa4 FF1003E2 		and	r1, r3, #255
 3775              	.LVL404:
1008:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3776              		.loc 1 1008 0
 3777 1fa8 A0639FE5 		ldr	r6, .L474
1015:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3778              		.loc 1 1015 0
 3779 1fac 1C03000A 		beq	.L321
1016:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3780              		.loc 1 1016 0
 3781 1fb0 2DA5D6E5 		ldrb	r10, [r6, #1325]	@ zero_extendqisi2
1017:../uvc.c      **** 		 	 		 }else{
 3782              		.loc 1 1017 0
 3783 1fb4 2E35D6E5 		ldrb	r3, [r6, #1326]	@ zero_extendqisi2
1016:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3784              		.loc 1 1016 0
 3785 1fb8 FFA00AE2 		and	r10, r10, #255
 3786 1fbc 28A0C4E5 		strb	r10, [r4, #40]
1017:../uvc.c      **** 		 	 		 }else{
 3787              		.loc 1 1017 0
 3788 1fc0 2930C4E5 		strb	r3, [r4, #41]
 3789              	.LVL405:
 3790              	.L322:
1030:../uvc.c      **** 			 		 break;
 3791              		.loc 1 1030 0
 3792 1fc4 00708DE5 		str	r7, [sp]
 3793 1fc8 0A20A0E1 		mov	r2, r10
 3794 1fcc 0A30A0E1 		mov	r3, r10
 3795 1fd0 A8139FE5 		ldr	r1, .L474+48
 3796 1fd4 0400A0E3 		mov	r0, #4
 3797 1fd8 0740A0E1 		mov	r4, r7
 3798 1fdc FEFFFFEB 		bl	CyU3PDebugPrint
 3799              	.LVL406:
1031:../uvc.c      **** 			 	 case ExtCtlShutlevCtlID11:
 3800              		.loc 1 1031 0
 3801 1fe0 20FEFFEA 		b	.L316
 3802              	.LVL407:
 3803              	.L293:
1334:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 3804              		.loc 1 1334 0
 3805 1fe4 A4739FE5 		ldr	r7, .L474+64
 3806 1fe8 A920D7E5 		ldrb	r2, [r7, #169]	@ zero_extendqisi2
 3807 1fec 000052E3 		cmp	r2, #0
 3808 1ff0 1B03000A 		beq	.L360
1336:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 3809              		.loc 1 1336 0
 3810 1ff4 D1A2D6E5 		ldrb	r10, [r6, #721]	@ zero_extendqisi2
1337:../uvc.c      **** 		 	 		 }else{
 3811              		.loc 1 1337 0
 3812 1ff8 D242D6E5 		ldrb	r4, [r6, #722]	@ zero_extendqisi2
1336:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 3813              		.loc 1 1336 0
 3814 1ffc 03A00AE2 		and	r10, r10, #3
 3815 2000 28A0C7E5 		strb	r10, [r7, #40]
1337:../uvc.c      **** 		 	 		 }else{
 3816              		.loc 1 1337 0
 3817 2004 2940C7E5 		strb	r4, [r7, #41]
 3818 2008 16FEFFEA 		b	.L316
 3819              	.LVL408:
 3820              	.L388:
1846:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3821              		.loc 1 1846 0
 3822 200c 8C739FE5 		ldr	r7, .L474+80
 3823 2010 0010E0E3 		mvn	r1, #0
 3824 2014 1C0097E5 		ldr	r0, [r7, #28]
 3825              	.LVL409:
 3826 2018 10C08DE5 		str	ip, [sp, #16]
 3827 201c 14308DE5 		str	r3, [sp, #20]
 3828 2020 FEFFFFEB 		bl	_txe_mutex_get
 3829              	.LVL410:
1847:../uvc.c      **** 							 dataIdx++;
 3830              		.loc 1 1847 0
 3831 2024 14309DE5 		ldr	r3, [sp, #20]
 3832 2028 0010A0E3 		mov	r1, #0
 3833 202c 0320A0E1 		mov	r2, r3
 3834 2030 0700A0E1 		mov	r0, r7
 3835 2034 0A30A0E1 		mov	r3, r10
 3836 2038 04108DE5 		str	r1, [sp, #4]
 3837 203c 00B08DE5 		str	fp, [sp]
 3838 2040 0610A0E3 		mov	r1, #6
 3839 2044 FEFFFFEB 		bl	cmdSet
 3840              	.LVL411:
1849:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3841              		.loc 1 1849 0
 3842 2048 10C09DE5 		ldr	ip, [sp, #16]
 3843 204c 0180A0E3 		mov	r8, #1
 3844              	.LVL412:
 3845 2050 0A30A0E1 		mov	r3, r10
 3846 2054 0C20A0E1 		mov	r2, ip
 3847 2058 0700A0E1 		mov	r0, r7
 3848 205c 0610A0E3 		mov	r1, #6
 3849 2060 00B08DE5 		str	fp, [sp]
 3850 2064 04808DE5 		str	r8, [sp, #4]
 3851 2068 FEFFFFEB 		bl	cmdSet
 3852              	.LVL413:
1853:../uvc.c      **** 
 3853              		.loc 1 1853 0
 3854 206c FF40A0E3 		mov	r4, #255
 3855              	.LVL414:
1850:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3856              		.loc 1 1850 0
 3857 2070 1C0097E5 		ldr	r0, [r7, #28]
 3858 2074 FEFFFFEB 		bl	_txe_mutex_put
 3859              	.LVL415:
 3860 2078 0B70A0E1 		mov	r7, fp
 3861 207c 18909DE5 		ldr	r9, [sp, #24]
1852:../uvc.c      **** 							 break;
 3862              		.loc 1 1852 0
 3863 2080 8C82C6E5 		strb	r8, [r6, #652]
1851:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3864              		.loc 1 1851 0
 3865 2084 89B2C6E5 		strb	fp, [r6, #649]
1853:../uvc.c      **** 
 3866              		.loc 1 1853 0
 3867 2088 04A0A0E1 		mov	r10, r4
 3868 208c E3FCFFEA 		b	.L284
 3869              	.LVL416:
 3870              	.L392:
1558:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3871              		.loc 1 1558 0
 3872 2090 08739FE5 		ldr	r7, .L474+80
 3873 2094 0010E0E3 		mvn	r1, #0
 3874 2098 1C0097E5 		ldr	r0, [r7, #28]
 3875              	.LVL417:
1554:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3876              		.loc 1 1554 0
 3877 209c E895D6E5 		ldrb	r9, [r6, #1512]	@ zero_extendqisi2
1555:../uvc.c      **** 						     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 3878              		.loc 1 1555 0
 3879 20a0 E9A5D6E5 		ldrb	r10, [r6, #1513]	@ zero_extendqisi2
1556:../uvc.c      **** 						     dataIdx = 0;
 3880              		.loc 1 1556 0
 3881 20a4 F785D6E5 		ldrb	r8, [r6, #1527]	@ zero_extendqisi2
 3882              	.LVL418:
1558:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3883              		.loc 1 1558 0
 3884 20a8 FEFFFFEB 		bl	_txe_mutex_get
 3885              	.LVL419:
1559:../uvc.c      **** 							 {
 3886              		.loc 1 1559 0
 3887 20ac F525D6E5 		ldrb	r2, [r6, #1525]	@ zero_extendqisi2
1554:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3888              		.loc 1 1554 0
 3889 20b0 FF9009E2 		and	r9, r9, #255
 3890              	.LVL420:
1559:../uvc.c      **** 							 {
 3891              		.loc 1 1559 0
 3892 20b4 02005BE1 		cmp	fp, r2
1555:../uvc.c      **** 						     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 3893              		.loc 1 1555 0
 3894 20b8 FFA00AE2 		and	r10, r10, #255
 3895              	.LVL421:
1556:../uvc.c      **** 						     dataIdx = 0;
 3896              		.loc 1 1556 0
 3897 20bc FF8008E2 		and	r8, r8, #255
 3898              	.LVL422:
1554:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3899              		.loc 1 1554 0
 3900 20c0 88329FE5 		ldr	r3, .L474
 3901 20c4 0B40A001 		moveq	r4, fp
 3902              	.LVL423:
1559:../uvc.c      **** 							 {
 3903              		.loc 1 1559 0
 3904 20c8 0B00000A 		beq	.L405
1561:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 3905              		.loc 1 1561 0
 3906 20cc F5B5C3E5 		strb	fp, [r3, #1525]
1562:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3907              		.loc 1 1562 0
 3908 20d0 2D45D3E5 		ldrb	r4, [r3, #1325]	@ zero_extendqisi2
1563:../uvc.c      **** 								 /*
 3909              		.loc 1 1563 0
 3910 20d4 0030A0E3 		mov	r3, #0
1562:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3911              		.loc 1 1562 0
 3912 20d8 04428BE1 		orr	r4, fp, r4, asl #4
 3913 20dc FF4004E2 		and	r4, r4, #255
 3914              	.LVL424:
1563:../uvc.c      **** 								 /*
 3915              		.loc 1 1563 0
 3916 20e0 04308DE5 		str	r3, [sp, #4]
 3917 20e4 00408DE5 		str	r4, [sp]
 3918 20e8 0920A0E1 		mov	r2, r9
 3919 20ec 0700A0E1 		mov	r0, r7
 3920 20f0 1910A0E3 		mov	r1, #25
 3921 20f4 0830A0E1 		mov	r3, r8
 3922 20f8 FEFFFFEB 		bl	cmdSet
 3923              	.LVL425:
 3924              	.L405:
1575:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 3925              		.loc 1 1575 0
 3926 20fc F635D6E5 		ldrb	r3, [r6, #1526]	@ zero_extendqisi2
 3927 2100 18109DE5 		ldr	r1, [sp, #24]
 3928 2104 44229FE5 		ldr	r2, .L474
 3929 2108 010053E1 		cmp	r3, r1
 3930 210c 0400000A 		beq	.L407
1577:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 3931              		.loc 1 1577 0
 3932 2110 02304BE2 		sub	r3, fp, #2
 3933 2114 FF3003E2 		and	r3, r3, #255
 3934 2118 010053E3 		cmp	r3, #1
1576:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3935              		.loc 1 1576 0
 3936 211c F615C2E5 		strb	r1, [r2, #1526]
1577:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 3937              		.loc 1 1577 0
 3938 2120 A803009A 		bls	.L470
 3939              	.L407:
1582:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3940              		.loc 1 1582 0
 3941 2124 1C0097E5 		ldr	r0, [r7, #28]
 3942 2128 FEFFFFEB 		bl	_txe_mutex_put
 3943              	.LVL426:
1584:../uvc.c      **** 							 break;
 3944              		.loc 1 1584 0
 3945 212c F525D6E5 		ldrb	r2, [r6, #1525]	@ zero_extendqisi2
1583:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3946              		.loc 1 1583 0
 3947 2130 18909DE5 		ldr	r9, [sp, #24]
 3948              	.LVL427:
1584:../uvc.c      **** 							 break;
 3949              		.loc 1 1584 0
 3950 2134 F635D6E5 		ldrb	r3, [r6, #1526]	@ zero_extendqisi2
 3951 2138 2D15D6E5 		ldrb	r1, [r6, #1325]	@ zero_extendqisi2
1583:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3952              		.loc 1 1583 0
 3953 213c 0400A0E3 		mov	r0, #4
 3954 2140 12028DE8 		stmia	sp, {r1, r4, r9}
 3955 2144 2C129FE5 		ldr	r1, .L474+40
 3956 2148 FEFFFFEB 		bl	CyU3PDebugPrint
 3957              	.LVL428:
1585:../uvc.c      **** 
 3958              		.loc 1 1585 0
 3959 214c FF40A0E3 		mov	r4, #255
 3960              	.LVL429:
 3961 2150 0B70A0E1 		mov	r7, fp
 3962 2154 04A0A0E1 		mov	r10, r4
 3963              	.LVL430:
 3964 2158 B0FCFFEA 		b	.L284
 3965              	.LVL431:
 3966              	.L391:
1494:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][0];
 3967              		.loc 1 1494 0
 3968 215c 2095D6E5 		ldrb	r9, [r6, #1312]	@ zero_extendqisi2
1495:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3969              		.loc 1 1495 0
 3970 2160 2135D6E5 		ldrb	r3, [r6, #1313]	@ zero_extendqisi2
1496:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
 3971              		.loc 1 1496 0
 3972 2164 2F45D6E5 		ldrb	r4, [r6, #1327]	@ zero_extendqisi2
1497:../uvc.c      **** #if 1	// register setting directly
 3973              		.loc 1 1497 0
 3974 2168 2DB5C6E5 		strb	fp, [r6, #1325]
1499:../uvc.c      **** 						     {
 3975              		.loc 1 1499 0
 3976 216c F525D6E5 		ldrb	r2, [r6, #1525]	@ zero_extendqisi2
1494:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][0];
 3977              		.loc 1 1494 0
 3978 2170 FF9009E2 		and	r9, r9, #255
 3979              	.LVL432:
1499:../uvc.c      **** 						     {
 3980              		.loc 1 1499 0
 3981 2174 030012E3 		tst	r2, #3
1495:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3982              		.loc 1 1495 0
 3983 2178 FF2003E2 		and	r2, r3, #255
 3984              	.LVL433:
1494:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][0];
 3985              		.loc 1 1494 0
 3986 217c CC319FE5 		ldr	r3, .L474
 3987 2180 0B30A001 		moveq	r3, fp
1496:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
 3988              		.loc 1 1496 0
 3989 2184 FF4004E2 		and	r4, r4, #255
 3990              	.LVL434:
1499:../uvc.c      **** 						     {
 3991              		.loc 1 1499 0
 3992 2188 0370A001 		moveq	r7, r3
 3993 218c 1B00000A 		beq	.L404
1503:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3994              		.loc 1 1503 0
 3995 2190 08829FE5 		ldr	r8, .L474+80
 3996              	.LVL435:
1501:../uvc.c      **** 						    	 dataIdx = 0;
 3997              		.loc 1 1501 0
 3998 2194 F5A5D3E5 		ldrb	r10, [r3, #1525]	@ zero_extendqisi2
1503:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3999              		.loc 1 1503 0
 4000 2198 1C0098E5 		ldr	r0, [r8, #28]
 4001              	.LVL436:
 4002 219c 0010E0E3 		mvn	r1, #0
 4003 21a0 14208DE5 		str	r2, [sp, #20]
 4004 21a4 FEFFFFEB 		bl	_txe_mutex_get
 4005              	.LVL437:
1504:../uvc.c      **** 								 dataIdx++;
 4006              		.loc 1 1504 0
 4007 21a8 0030A0E3 		mov	r3, #0
 4008 21ac 14209DE5 		ldr	r2, [sp, #20]
 4009 21b0 00308DE5 		str	r3, [sp]
 4010 21b4 04308DE5 		str	r3, [sp, #4]
 4011 21b8 1010A0E3 		mov	r1, #16
 4012 21bc 0430A0E1 		mov	r3, r4
1501:../uvc.c      **** 						    	 dataIdx = 0;
 4013              		.loc 1 1501 0
 4014 21c0 0BA28AE1 		orr	r10, r10, fp, asl #4
1504:../uvc.c      **** 								 dataIdx++;
 4015              		.loc 1 1504 0
 4016 21c4 0800A0E1 		mov	r0, r8
 4017 21c8 FEFFFFEB 		bl	cmdSet
 4018              	.LVL438:
1501:../uvc.c      **** 						    	 dataIdx = 0;
 4019              		.loc 1 1501 0
 4020 21cc FFA00AE2 		and	r10, r10, #255
 4021              	.LVL439:
1506:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4022              		.loc 1 1506 0
 4023 21d0 0110A0E3 		mov	r1, #1
 4024 21d4 0430A0E1 		mov	r3, r4
 4025 21d8 0920A0E1 		mov	r2, r9
 4026 21dc 04108DE5 		str	r1, [sp, #4]
 4027 21e0 00A08DE5 		str	r10, [sp]
 4028 21e4 1010A0E3 		mov	r1, #16
 4029 21e8 0800A0E1 		mov	r0, r8
 4030 21ec FEFFFFEB 		bl	cmdSet
 4031              	.LVL440:
1507:../uvc.c      **** 						     }
 4032              		.loc 1 1507 0
 4033 21f0 1C0098E5 		ldr	r0, [r8, #28]
 4034 21f4 FEFFFFEB 		bl	_txe_mutex_put
 4035              	.LVL441:
1501:../uvc.c      **** 						    	 dataIdx = 0;
 4036              		.loc 1 1501 0
 4037 21f8 0B70A0E1 		mov	r7, fp
 4038 21fc 0A30A0E1 		mov	r3, r10
 4039              	.LVL442:
 4040              	.L404:
1510:../uvc.c      **** 						     break;
 4041              		.loc 1 1510 0
 4042 2200 F505D6E5 		ldrb	r0, [r6, #1525]	@ zero_extendqisi2
 4043 2204 2D15D6E5 		ldrb	r1, [r6, #1325]	@ zero_extendqisi2
1509:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 4044              		.loc 1 1509 0
 4045 2208 1C209DE5 		ldr	r2, [sp, #28]
 4046 220c 03008DE8 		stmia	sp, {r0, r1}
 4047 2210 6C119FE5 		ldr	r1, .L474+52
 4048 2214 0400A0E3 		mov	r0, #4
1511:../uvc.c      **** #else	// old fashion
 4049              		.loc 1 1511 0
 4050 2218 FF40A0E3 		mov	r4, #255
 4051              	.LVL443:
1509:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 4052              		.loc 1 1509 0
 4053 221c FEFFFFEB 		bl	CyU3PDebugPrint
 4054              	.LVL444:
1511:../uvc.c      **** #else	// old fashion
 4055              		.loc 1 1511 0
 4056 2220 04A0A0E1 		mov	r10, r4
 4057 2224 18909DE5 		ldr	r9, [sp, #24]
 4058              	.LVL445:
 4059 2228 7CFCFFEA 		b	.L284
 4060              	.LVL446:
 4061              	.L390:
1860:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4062              		.loc 1 1860 0
 4063 222c 6C719FE5 		ldr	r7, .L474+80
 4064 2230 0010E0E3 		mvn	r1, #0
 4065 2234 1C0097E5 		ldr	r0, [r7, #28]
 4066              	.LVL447:
 4067 2238 10C08DE5 		str	ip, [sp, #16]
 4068 223c 14308DE5 		str	r3, [sp, #20]
 4069 2240 FEFFFFEB 		bl	_txe_mutex_get
 4070              	.LVL448:
1861:../uvc.c      **** 							 dataIdx++;
 4071              		.loc 1 1861 0
 4072 2244 14309DE5 		ldr	r3, [sp, #20]
 4073 2248 0010A0E3 		mov	r1, #0
 4074 224c 0320A0E1 		mov	r2, r3
 4075 2250 0700A0E1 		mov	r0, r7
 4076 2254 0A30A0E1 		mov	r3, r10
 4077 2258 04108DE5 		str	r1, [sp, #4]
 4078 225c 00B08DE5 		str	fp, [sp]
 4079 2260 0B10A0E3 		mov	r1, #11
 4080 2264 FEFFFFEB 		bl	cmdSet
 4081              	.LVL449:
1863:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4082              		.loc 1 1863 0
 4083 2268 18209DE5 		ldr	r2, [sp, #24]
 4084 226c 10C09DE5 		ldr	ip, [sp, #16]
 4085 2270 0180A0E3 		mov	r8, #1
 4086              	.LVL450:
 4087 2274 0A30A0E1 		mov	r3, r10
 4088 2278 00208DE5 		str	r2, [sp]
 4089 227c 0700A0E1 		mov	r0, r7
 4090 2280 0C20A0E1 		mov	r2, ip
 4091 2284 0B10A0E3 		mov	r1, #11
 4092 2288 04808DE5 		str	r8, [sp, #4]
 4093 228c FEFFFFEB 		bl	cmdSet
 4094              	.LVL451:
1864:../uvc.c      **** 
 4095              		.loc 1 1864 0
 4096 2290 1C0097E5 		ldr	r0, [r7, #28]
 4097 2294 FEFFFFEB 		bl	_txe_mutex_put
 4098              	.LVL452:
1867:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4099              		.loc 1 1867 0
 4100 2298 18309DE5 		ldr	r3, [sp, #24]
1869:../uvc.c      **** 						 case MFreqCtlID4:
 4101              		.loc 1 1869 0
 4102 229c FF40A0E3 		mov	r4, #255
 4103              	.LVL453:
 4104 22a0 0B70A0E1 		mov	r7, fp
1868:../uvc.c      **** 							 break;
 4105              		.loc 1 1868 0
 4106 22a4 0483C6E5 		strb	r8, [r6, #772]
1866:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 4107              		.loc 1 1866 0
 4108 22a8 FCB5C6E5 		strb	fp, [r6, #1532]
1867:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4109              		.loc 1 1867 0
 4110 22ac FE35C6E5 		strb	r3, [r6, #1534]
 4111 22b0 0390A0E1 		mov	r9, r3
1869:../uvc.c      **** 						 case MFreqCtlID4:
 4112              		.loc 1 1869 0
 4113 22b4 04A0A0E1 		mov	r10, r4
 4114 22b8 58FCFFEA 		b	.L284
 4115              	.LVL454:
 4116              	.L389:
1951:../uvc.c      **** 							 if(Data0 != 0){
 4117              		.loc 1 1951 0
 4118 22bc 0140A0E3 		mov	r4, #1
1946:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 4119              		.loc 1 1946 0
 4120 22c0 1486D6E5 		ldrb	r8, [r6, #1556]	@ zero_extendqisi2
 4121              	.LVL455:
1947:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 4122              		.loc 1 1947 0
 4123 22c4 1596D6E5 		ldrb	r9, [r6, #1557]	@ zero_extendqisi2
1948:../uvc.c      **** 						     dataIdx = 0;
 4124              		.loc 1 1948 0
 4125 22c8 2376D6E5 		ldrb	r7, [r6, #1571]	@ zero_extendqisi2
1950:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 4126              		.loc 1 1950 0
 4127 22cc 21B6C6E5 		strb	fp, [r6, #1569]
1951:../uvc.c      **** 							 if(Data0 != 0){
 4128              		.loc 1 1951 0
 4129 22d0 2546C6E5 		strb	r4, [r6, #1573]
1953:../uvc.c      **** #ifdef COLOR
 4130              		.loc 1 1953 0
 4131 22d4 C4609FE5 		ldr	r6, .L474+80
1952:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4132              		.loc 1 1952 0
 4133 22d8 00005BE3 		cmp	fp, #0
1946:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 4134              		.loc 1 1946 0
 4135 22dc FF8008E2 		and	r8, r8, #255
 4136              	.LVL456:
1947:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 4137              		.loc 1 1947 0
 4138 22e0 FF9009E2 		and	r9, r9, #255
 4139              	.LVL457:
1948:../uvc.c      **** 						     dataIdx = 0;
 4140              		.loc 1 1948 0
 4141 22e4 FF7007E2 		and	r7, r7, #255
 4142              	.LVL458:
1953:../uvc.c      **** #ifdef COLOR
 4143              		.loc 1 1953 0
 4144 22e8 0010E0E3 		mvn	r1, #0
 4145 22ec 1C0096E5 		ldr	r0, [r6, #28]
 4146              	.LVL459:
1952:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4147              		.loc 1 1952 0
 4148 22f0 7101000A 		beq	.L442
1953:../uvc.c      **** #ifdef COLOR
 4149              		.loc 1 1953 0
 4150 22f4 FEFFFFEB 		bl	_txe_mutex_get
 4151              	.LVL460:
1957:../uvc.c      **** 								 dataIdx++;
 4152              		.loc 1 1957 0
 4153 22f8 0030A0E3 		mov	r3, #0
 4154 22fc 0820A0E1 		mov	r2, r8
 4155 2300 04308DE5 		str	r3, [sp, #4]
 4156 2304 00408DE5 		str	r4, [sp]
 4157 2308 0600A0E1 		mov	r0, r6
 4158 230c 0710A0E3 		mov	r1, #7
 4159 2310 0730A0E1 		mov	r3, r7
 4160 2314 FEFFFFEB 		bl	cmdSet
 4161              	.LVL461:
1959:../uvc.c      **** #endif
 4162              		.loc 1 1959 0
 4163 2318 0920A0E1 		mov	r2, r9
 4164 231c 00B08DE5 		str	fp, [sp]
 4165 2320 04408DE5 		str	r4, [sp, #4]
 4166              	.LVL462:
 4167              	.L465:
1964:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4168              		.loc 1 1964 0
 4169 2324 0730A0E1 		mov	r3, r7
 4170 2328 0710A0E3 		mov	r1, #7
 4171 232c 0600A0E1 		mov	r0, r6
 4172 2330 FEFFFFEB 		bl	cmdSet
 4173              	.LVL463:
1965:../uvc.c      **** 
 4174              		.loc 1 1965 0
 4175 2334 FF40A0E3 		mov	r4, #255
 4176 2338 1C0096E5 		ldr	r0, [r6, #28]
 4177 233c FEFFFFEB 		bl	_txe_mutex_put
 4178              	.LVL464:
 4179 2340 0B70A0E1 		mov	r7, fp
 4180              	.LVL465:
 4181 2344 18909DE5 		ldr	r9, [sp, #24]
 4182              	.LVL466:
 4183 2348 04A0A0E1 		mov	r10, r4
 4184 234c 33FCFFEA 		b	.L284
 4185              	.L475:
 4186              		.align	2
 4187              	.L474:
 4188 2350 00000000 		.word	.LANCHOR1
 4189 2354 00000000 		.word	bRequest
 4190 2358 28000000 		.word	.LANCHOR0+40
 4191 235c CC050000 		.word	.LC35
 4192 2360 01000100 		.word	65537
 4193 2364 FF00FF00 		.word	16711935
 4194 2368 5C040000 		.word	.LC27
 4195 236c 98040000 		.word	.LC28
 4196 2370 94000000 		.word	.LANCHOR0+148
 4197 2374 00000000 		.word	.LANCHOR2
 4198 2378 EC040000 		.word	.LC30
 4199 237c 20050000 		.word	.LC31
 4200 2380 FC030000 		.word	.LC25
 4201 2384 C0040000 		.word	.LC29
 4202 2388 58050000 		.word	.LC32
 4203 238c 00000000 		.word	.LANCHOR1
 4204 2390 00000000 		.word	.LANCHOR0
 4205 2394 9C050000 		.word	.LC34
 4206 2398 78050000 		.word	.LC33
 4207 239c D4030000 		.word	.LC24
 4208 23a0 00000000 		.word	cmdQu
 4209 23a4 24040000 		.word	.LC26
 4210              	.LVL467:
 4211              	.L394:
1693:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4212              		.loc 1 1693 0
 4213 23a8 10801FE5 		ldr	r8, .L474+80
 4214              	.LVL468:
1683:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 4215              		.loc 1 1683 0
 4216 23ac 03005BE3 		cmp	fp, #3
1688:../uvc.c      **** 							 }
 4217              		.loc 1 1688 0
 4218 23b0 04C04B82 		subhi	ip, fp, #4
 4219 23b4 FFC00C82 		andhi	ip, ip, #255
 4220              	.LVL469:
1687:../uvc.c      **** 								 Data1 = Data0-4;
 4221              		.loc 1 1687 0
 4222 23b8 01E0A083 		movhi	lr, #1
 4223 23bc 0BC0A091 		movls	ip, fp
 4224              	.LVL470:
1684:../uvc.c      **** 								 Data1 = Data0;
 4225              		.loc 1 1684 0
 4226 23c0 00E0A093 		movls	lr, #0
1692:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4227              		.loc 1 1692 0
 4228 23c4 0120A0E3 		mov	r2, #1
1693:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4229              		.loc 1 1693 0
 4230 23c8 1C0098E5 		ldr	r0, [r8, #28]
 4231              	.LVL471:
 4232 23cc 0010E0E3 		mvn	r1, #0
 4233 23d0 E0E0C7E5 		strb	lr, [r7, #224]
 4234              	.LVL472:
1691:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4235              		.loc 1 1691 0
 4236 23d4 F9C1C6E5 		strb	ip, [r6, #505]
1692:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4237              		.loc 1 1692 0
 4238 23d8 9C24C6E5 		strb	r2, [r6, #1180]
1690:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 4239              		.loc 1 1690 0
 4240 23dc 99B4C6E5 		strb	fp, [r6, #1177]
1693:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4241              		.loc 1 1693 0
 4242 23e0 14308DE5 		str	r3, [sp, #20]
 4243 23e4 FEFFFFEB 		bl	_txe_mutex_get
 4244              	.LVL473:
1694:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4245              		.loc 1 1694 0
 4246 23e8 14309DE5 		ldr	r3, [sp, #20]
 4247 23ec 0010A0E3 		mov	r1, #0
 4248 23f0 0320A0E1 		mov	r2, r3
 4249 23f4 04108DE5 		str	r1, [sp, #4]
 4250 23f8 0A30A0E1 		mov	r3, r10
 4251 23fc 1C10A0E3 		mov	r1, #28
 4252 2400 00B08DE5 		str	fp, [sp]
 4253 2404 0800A0E1 		mov	r0, r8
 4254 2408 FEFFFFEB 		bl	cmdSet
 4255              	.LVL474:
1697:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 4256              		.loc 1 1697 0
 4257 240c FF40A0E3 		mov	r4, #255
 4258              	.LVL475:
1695:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 4259              		.loc 1 1695 0
 4260 2410 1C0098E5 		ldr	r0, [r8, #28]
 4261 2414 FEFFFFEB 		bl	_txe_mutex_put
 4262              	.LVL476:
 4263 2418 0B70A0E1 		mov	r7, fp
 4264 241c 18909DE5 		ldr	r9, [sp, #24]
1697:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 4265              		.loc 1 1697 0
 4266 2420 04A0A0E1 		mov	r10, r4
 4267 2424 FDFBFFEA 		b	.L284
 4268              	.LVL477:
 4269              	.L384:
1808:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 4270              		.loc 1 1808 0
 4271 2428 90701FE5 		ldr	r7, .L474+80
 4272 242c 0010E0E3 		mvn	r1, #0
 4273 2430 1C0097E5 		ldr	r0, [r7, #28]
 4274              	.LVL478:
 4275 2434 10C08DE5 		str	ip, [sp, #16]
 4276 2438 FEFFFFEB 		bl	_txe_mutex_get
 4277              	.LVL479:
1810:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 4278              		.loc 1 1810 0
 4279 243c 80001BE3 		tst	fp, #128
 4280 2440 10C09DE5 		ldr	ip, [sp, #16]
1811:../uvc.c      **** 							  }else{
 4281              		.loc 1 1811 0
 4282 2444 80804B12 		subne	r8, fp, #128
 4283              	.LVL480:
1813:../uvc.c      **** 							  }
 4284              		.loc 1 1813 0
 4285 2448 0B80E001 		mvneq	r8, fp
 4286 244c FF8008E2 		and	r8, r8, #255
 4287              	.LVL481:
1815:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4288              		.loc 1 1815 0
 4289 2450 0010A0E3 		mov	r1, #0
 4290 2454 0A30A0E1 		mov	r3, r10
 4291 2458 0C20A0E1 		mov	r2, ip
 4292 245c 04108DE5 		str	r1, [sp, #4]
 4293 2460 00808DE5 		str	r8, [sp]
 4294 2464 0110A0E3 		mov	r1, #1
 4295 2468 D0001FE5 		ldr	r0, .L474+80
 4296 246c FEFFFFEB 		bl	cmdSet
 4297              	.LVL482:
1816:../uvc.c      **** 
 4298              		.loc 1 1816 0
 4299 2470 1C0097E5 		ldr	r0, [r7, #28]
 4300 2474 FEFFFFEB 		bl	_txe_mutex_put
 4301              	.LVL483:
1822:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 4302              		.loc 1 1822 0
 4303 2478 FF40A0E3 		mov	r4, #255
 4304              	.LVL484:
1819:../uvc.c      **** 
 4305              		.loc 1 1819 0
 4306 247c 0130A0E3 		mov	r3, #1
 4307 2480 0B70A0E1 		mov	r7, fp
 4308 2484 18909DE5 		ldr	r9, [sp, #24]
1818:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4309              		.loc 1 1818 0
 4310 2488 1182C6E5 		strb	r8, [r6, #529]
1819:../uvc.c      **** 
 4311              		.loc 1 1819 0
 4312 248c 1432C6E5 		strb	r3, [r6, #532]
1822:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 4313              		.loc 1 1822 0
 4314 2490 04A0A0E1 		mov	r10, r4
 4315 2494 E1FBFFEA 		b	.L284
 4316              	.LVL485:
 4317              	.L382:
1929:../uvc.c      **** 							 {
 4318              		.loc 1 1929 0
 4319 2498 E020D7E5 		ldrb	r2, [r7, #224]	@ zero_extendqisi2
1919:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 4320              		.loc 1 1919 0
 4321 249c 0076D6E5 		ldrb	r7, [r6, #1536]	@ zero_extendqisi2
1920:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 4322              		.loc 1 1920 0
 4323 24a0 0136D6E5 		ldrb	r3, [r6, #1537]	@ zero_extendqisi2
1921:../uvc.c      **** 						     dataIdx = 0;
 4324              		.loc 1 1921 0
 4325 24a4 0F46D6E5 		ldrb	r4, [r6, #1551]	@ zero_extendqisi2
1929:../uvc.c      **** 							 {
 4326              		.loc 1 1929 0
 4327 24a8 010052E3 		cmp	r2, #1
1927:../uvc.c      **** 
 4328              		.loc 1 1927 0
 4329 24ac 0130A0E3 		mov	r3, #1
1926:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 4330              		.loc 1 1926 0
 4331 24b0 0DB6C6E5 		strb	fp, [r6, #1549]
1919:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 4332              		.loc 1 1919 0
 4333 24b4 FF7007E2 		and	r7, r7, #255
 4334              	.LVL486:
1921:../uvc.c      **** 						     dataIdx = 0;
 4335              		.loc 1 1921 0
 4336 24b8 FF4004E2 		and	r4, r4, #255
 4337              	.LVL487:
1927:../uvc.c      **** 
 4338              		.loc 1 1927 0
 4339 24bc 1136C6E5 		strb	r3, [r6, #1553]
1484:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 4340              		.loc 1 1484 0
 4341 24c0 0B80A011 		movne	r8, fp
 4342              	.LVL488:
1929:../uvc.c      **** 							 {
 4343              		.loc 1 1929 0
 4344 24c4 0101000A 		beq	.L471
 4345              	.LVL489:
 4346              	.L440:
1940:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4347              		.loc 1 1940 0
 4348 24c8 30611FE5 		ldr	r6, .L474+80
 4349 24cc 0010E0E3 		mvn	r1, #0
 4350 24d0 1C0096E5 		ldr	r0, [r6, #28]
 4351 24d4 FEFFFFEB 		bl	_txe_mutex_get
 4352              	.LVL490:
1941:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4353              		.loc 1 1941 0
 4354 24d8 0010A0E3 		mov	r1, #0
 4355 24dc 0720A0E1 		mov	r2, r7
 4356 24e0 0430A0E1 		mov	r3, r4
 4357 24e4 04108DE5 		str	r1, [sp, #4]
 4358 24e8 00808DE5 		str	r8, [sp]
 4359 24ec 0600A0E1 		mov	r0, r6
 4360 24f0 FEFFFFEB 		bl	cmdSet
 4361              	.LVL491:
1944:../uvc.c      **** 					 	 case ShapCtlID7:
 4362              		.loc 1 1944 0
 4363 24f4 FF40A0E3 		mov	r4, #255
 4364              	.LVL492:
1942:../uvc.c      **** 
 4365              		.loc 1 1942 0
 4366 24f8 1C0096E5 		ldr	r0, [r6, #28]
 4367 24fc FEFFFFEB 		bl	_txe_mutex_put
 4368              	.LVL493:
 4369 2500 0B70A0E1 		mov	r7, fp
 4370              	.LVL494:
 4371 2504 18909DE5 		ldr	r9, [sp, #24]
1944:../uvc.c      **** 					 	 case ShapCtlID7:
 4372              		.loc 1 1944 0
 4373 2508 04A0A0E1 		mov	r10, r4
 4374 250c C3FBFFEA 		b	.L284
 4375              	.LVL495:
 4376              	.L386:
1873:../uvc.c      **** 							 is60Hz = Data0;
 4377              		.loc 1 1873 0
 4378 2510 01204BE2 		sub	r2, fp, #1
 4379 2514 FF2002E2 		and	r2, r2, #255
 4380              	.LVL496:
1874:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 4381              		.loc 1 1874 0
 4382 2518 90311FE5 		ldr	r3, .L474+64
 4383              	.LVL497:
1880:../uvc.c      **** 							 {
 4384              		.loc 1 1880 0
 4385 251c 020052E3 		cmp	r2, #2
1874:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 4386              		.loc 1 1874 0
 4387 2520 6C2087E5 		str	r2, [r7, #108]
1883:../uvc.c      **** 							 }
 4388              		.loc 1 1883 0
 4389 2524 0120A083 		movhi	r2, #1
 4390 2528 6C208385 		strhi	r2, [r3, #108]
 4391              	.LVL498:
1885:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 4392              		.loc 1 1885 0
 4393 252c 0400A0E3 		mov	r0, #4
 4394              	.LVL499:
 4395 2530 6C3097E5 		ldr	r3, [r7, #108]
 4396 2534 B4111FE5 		ldr	r1, .L474+56
1872:../uvc.c      **** 							 Data0 = Data0 - 1;
 4397              		.loc 1 1872 0
 4398 2538 59B2C6E5 		strb	fp, [r6, #601]
1885:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 4399              		.loc 1 1885 0
 4400 253c FEFFFFEB 		bl	CyU3PDebugPrint
 4401              	.LVL500:
1886:../uvc.c      **** 							 {
 4402              		.loc 1 1886 0
 4403 2540 883097E5 		ldr	r3, [r7, #136]
1885:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 4404              		.loc 1 1885 0
 4405 2544 BC211FE5 		ldr	r2, .L474+64
1886:../uvc.c      **** 							 {
 4406              		.loc 1 1886 0
 4407 2548 010053E3 		cmp	r3, #1
 4408 254c E400000A 		beq	.L472
 4409              	.L426:
1916:../uvc.c      **** 							 break;
 4410              		.loc 1 1916 0
 4411 2550 0130A0E3 		mov	r3, #1
1917:../uvc.c      **** 					 	 case BLCCtlID0:
 4412              		.loc 1 1917 0
 4413 2554 FF40A0E3 		mov	r4, #255
 4414 2558 0B70A0E1 		mov	r7, fp
 4415 255c 18909DE5 		ldr	r9, [sp, #24]
1916:../uvc.c      **** 							 break;
 4416              		.loc 1 1916 0
 4417 2560 5C32C6E5 		strb	r3, [r6, #604]
1917:../uvc.c      **** 					 	 case BLCCtlID0:
 4418              		.loc 1 1917 0
 4419 2564 04A0A0E1 		mov	r10, r4
 4420 2568 ACFBFFEA 		b	.L284
 4421              	.LVL501:
 4422              	.L395:
1705:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4423              		.loc 1 1705 0
 4424 256c D4411FE5 		ldr	r4, .L474+80
 4425 2570 0010E0E3 		mvn	r1, #0
 4426 2574 1C0094E5 		ldr	r0, [r4, #28]
 4427              	.LVL502:
 4428 2578 14308DE5 		str	r3, [sp, #20]
 4429 257c FEFFFFEB 		bl	_txe_mutex_get
 4430              	.LVL503:
1706:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4431              		.loc 1 1706 0
 4432 2580 14309DE5 		ldr	r3, [sp, #20]
 4433 2584 01C07BE2 		rsbs	ip, fp, #1
 4434 2588 00C0A033 		movcc	ip, #0
 4435 258c 0010A0E3 		mov	r1, #0
 4436 2590 0320A0E1 		mov	r2, r3
 4437 2594 0400A0E1 		mov	r0, r4
 4438 2598 0A30A0E1 		mov	r3, r10
 4439 259c 00C08DE5 		str	ip, [sp]
 4440 25a0 04108DE5 		str	r1, [sp, #4]
 4441 25a4 1E10A0E3 		mov	r1, #30
 4442 25a8 FEFFFFEB 		bl	cmdSet
 4443              	.LVL504:
1707:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4444              		.loc 1 1707 0
 4445 25ac 1C0094E5 		ldr	r0, [r4, #28]
 4446 25b0 FEFFFFEB 		bl	_txe_mutex_put
 4447              	.LVL505:
1709:../uvc.c      **** 						 case ExtI2CCtlID15:
 4448              		.loc 1 1709 0
 4449 25b4 FF40A0E3 		mov	r4, #255
1708:../uvc.c      **** 							 break;
 4450              		.loc 1 1708 0
 4451 25b8 0130A0E3 		mov	r3, #1
 4452 25bc 18909DE5 		ldr	r9, [sp, #24]
 4453 25c0 0B70A0E1 		mov	r7, fp
 4454 25c4 CC34C6E5 		strb	r3, [r6, #1228]
1709:../uvc.c      **** 						 case ExtI2CCtlID15:
 4455              		.loc 1 1709 0
 4456 25c8 04A0A0E1 		mov	r10, r4
 4457 25cc 93FBFFEA 		b	.L284
 4458              	.LVL506:
 4459              	.L387:
1826:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 4460              		.loc 1 1826 0
 4461 25d0 38421FE5 		ldr	r4, .L474+80
 4462 25d4 0010E0E3 		mvn	r1, #0
 4463 25d8 1C0094E5 		ldr	r0, [r4, #28]
 4464              	.LVL507:
 4465 25dc 10C08DE5 		str	ip, [sp, #16]
 4466 25e0 14308DE5 		str	r3, [sp, #20]
 4467 25e4 FEFFFFEB 		bl	_txe_mutex_get
 4468              	.LVL508:
1827:../uvc.c      **** 							 dataIdx++;
 4469              		.loc 1 1827 0
 4470 25e8 14309DE5 		ldr	r3, [sp, #20]
 4471 25ec 80004BE2 		sub	r0, fp, #128
 4472 25f0 FF0000E2 		and	r0, r0, #255
 4473 25f4 0010A0E3 		mov	r1, #0
 4474 25f8 0320A0E1 		mov	r2, r3
 4475 25fc 00008DE5 		str	r0, [sp]
 4476 2600 0A30A0E1 		mov	r3, r10
 4477 2604 0400A0E1 		mov	r0, r4
 4478 2608 04108DE5 		str	r1, [sp, #4]
 4479 260c 0510A0E3 		mov	r1, #5
 4480 2610 FEFFFFEB 		bl	cmdSet
 4481              	.LVL509:
1829:../uvc.c      **** 							 dataIdx++;
 4482              		.loc 1 1829 0
 4483 2614 76304BE2 		sub	r3, fp, #118
 4484 2618 FF3003E2 		and	r3, r3, #255
 4485 261c 0180A0E3 		mov	r8, #1
 4486              	.LVL510:
 4487 2620 00308DE5 		str	r3, [sp]
 4488 2624 0400A0E1 		mov	r0, r4
 4489 2628 0A30A0E1 		mov	r3, r10
 4490 262c 0510A0E3 		mov	r1, #5
 4491 2630 DC20A0E3 		mov	r2, #220
 4492 2634 04808DE5 		str	r8, [sp, #4]
 4493 2638 FEFFFFEB 		bl	cmdSet
 4494              	.LVL511:
1831:../uvc.c      **** 							 dataIdx++;
 4495              		.loc 1 1831 0
 4496 263c 7E208BE2 		add	r2, fp, #126
 4497 2640 FF2002E2 		and	r2, r2, #255
 4498 2644 0230A0E3 		mov	r3, #2
 4499 2648 00208DE5 		str	r2, [sp]
 4500 264c 0400A0E1 		mov	r0, r4
 4501 2650 04308DE5 		str	r3, [sp, #4]
 4502 2654 0510A0E3 		mov	r1, #5
 4503 2658 0A30A0E1 		mov	r3, r10
 4504 265c DE20A0E3 		mov	r2, #222
 4505 2660 FEFFFFEB 		bl	cmdSet
 4506              	.LVL512:
1833:../uvc.c      **** 							 dataIdx++;
 4507              		.loc 1 1833 0
 4508 2664 72208BE2 		add	r2, fp, #114
 4509 2668 FF2002E2 		and	r2, r2, #255
 4510 266c 0330A0E3 		mov	r3, #3
 4511 2670 00208DE5 		str	r2, [sp]
 4512 2674 0400A0E1 		mov	r0, r4
 4513 2678 04308DE5 		str	r3, [sp, #4]
 4514 267c 0510A0E3 		mov	r1, #5
 4515 2680 0A30A0E1 		mov	r3, r10
 4516 2684 E020A0E3 		mov	r2, #224
 4517 2688 FEFFFFEB 		bl	cmdSet
 4518              	.LVL513:
1835:../uvc.c      **** 							 dataIdx++;
 4519              		.loc 1 1835 0
 4520 268c 6F204BE2 		sub	r2, fp, #111
 4521 2690 FF2002E2 		and	r2, r2, #255
 4522 2694 0430A0E3 		mov	r3, #4
 4523 2698 00208DE5 		str	r2, [sp]
 4524 269c 0400A0E1 		mov	r0, r4
 4525 26a0 04308DE5 		str	r3, [sp, #4]
 4526 26a4 0510A0E3 		mov	r1, #5
 4527 26a8 0A30A0E1 		mov	r3, r10
 4528 26ac DD20A0E3 		mov	r2, #221
 4529 26b0 FEFFFFEB 		bl	cmdSet
 4530              	.LVL514:
1837:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4531              		.loc 1 1837 0
 4532 26b4 2800D7E5 		ldrb	r0, [r7, #40]	@ zero_extendqisi2
 4533 26b8 10C09DE5 		ldr	ip, [sp, #16]
 4534 26bc 7F0080E2 		add	r0, r0, #127
 4535 26c0 0510A0E3 		mov	r1, #5
 4536 26c4 FF0000E2 		and	r0, r0, #255
 4537 26c8 0A30A0E1 		mov	r3, r10
 4538 26cc 0C20A0E1 		mov	r2, ip
 4539 26d0 00008DE5 		str	r0, [sp]
 4540 26d4 04108DE5 		str	r1, [sp, #4]
 4541 26d8 0400A0E1 		mov	r0, r4
 4542 26dc FEFFFFEB 		bl	cmdSet
 4543              	.LVL515:
1838:../uvc.c      **** 
 4544              		.loc 1 1838 0
 4545 26e0 1C0094E5 		ldr	r0, [r4, #28]
 4546 26e4 FEFFFFEB 		bl	_txe_mutex_put
 4547              	.LVL516:
1840:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4548              		.loc 1 1840 0
 4549 26e8 2830D7E5 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
1842:../uvc.c      **** 						 case SaturCtlID6:
 4550              		.loc 1 1842 0
 4551 26ec FF40A0E3 		mov	r4, #255
1840:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4552              		.loc 1 1840 0
 4553 26f0 803043E2 		sub	r3, r3, #128
 4554 26f4 18909DE5 		ldr	r9, [sp, #24]
 4555 26f8 0B70A0E1 		mov	r7, fp
1841:../uvc.c      **** 							 break;
 4556              		.loc 1 1841 0
 4557 26fc 7482C6E5 		strb	r8, [r6, #628]
1840:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4558              		.loc 1 1840 0
 4559 2700 7132C6E5 		strb	r3, [r6, #625]
1842:../uvc.c      **** 						 case SaturCtlID6:
 4560              		.loc 1 1842 0
 4561 2704 04A0A0E1 		mov	r10, r4
 4562 2708 44FBFFEA 		b	.L284
 4563              	.LVL517:
 4564              	.L385:
1972:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4565              		.loc 1 1972 0
 4566 270c 74731FE5 		ldr	r7, .L474+80
 4567 2710 0010E0E3 		mvn	r1, #0
 4568 2714 1C0097E5 		ldr	r0, [r7, #28]
 4569              	.LVL518:
 4570 2718 14308DE5 		str	r3, [sp, #20]
 4571 271c FEFFFFEB 		bl	_txe_mutex_get
 4572              	.LVL519:
1973:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4573              		.loc 1 1973 0
 4574 2720 14309DE5 		ldr	r3, [sp, #20]
 4575 2724 00C0A0E3 		mov	ip, #0
 4576 2728 0410A0E1 		mov	r1, r4
 4577 272c 0320A0E1 		mov	r2, r3
 4578 2730 0700A0E1 		mov	r0, r7
 4579 2734 0A30A0E1 		mov	r3, r10
 4580 2738 04C08DE5 		str	ip, [sp, #4]
 4581 273c 00B08DE5 		str	fp, [sp]
 4582 2740 FEFFFFEB 		bl	cmdSet
 4583              	.LVL520:
1974:../uvc.c      **** 
 4584              		.loc 1 1974 0
 4585 2744 1C0097E5 		ldr	r0, [r7, #28]
 4586 2748 FEFFFFEB 		bl	_txe_mutex_put
 4587              	.LVL521:
1981:../uvc.c      **** 						 default:
 4588              		.loc 1 1981 0
 4589 274c FF40A0E3 		mov	r4, #255
1977:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][13] = Data0;  //it's canceled as the both is the same contro
 4590              		.loc 1 1977 0
 4591 2750 0130A0E3 		mov	r3, #1
 4592 2754 18909DE5 		ldr	r9, [sp, #24]
1976:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 4593              		.loc 1 1976 0
 4594 2758 29B2C6E5 		strb	fp, [r6, #553]
 4595 275c 0B70A0E1 		mov	r7, fp
1977:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][13] = Data0;  //it's canceled as the both is the same contro
 4596              		.loc 1 1977 0
 4597 2760 2C32C6E5 		strb	r3, [r6, #556]
1981:../uvc.c      **** 						 default:
 4598              		.loc 1 1981 0
 4599 2764 04A0A0E1 		mov	r10, r4
 4600 2768 2CFBFFEA 		b	.L284
 4601              	.LVL522:
 4602              	.L393:
1592:../uvc.c      **** 							 if(0&&pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
 4603              		.loc 1 1592 0
 4604 276c D4731FE5 		ldr	r7, .L474+80
 4605 2770 0010E0E3 		mvn	r1, #0
 4606 2774 1C0097E5 		ldr	r0, [r7, #28]
 4607              	.LVL523:
1588:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 4608              		.loc 1 1588 0
 4609 2778 3495D6E5 		ldrb	r9, [r6, #1332]	@ zero_extendqisi2
1589:../uvc.c      **** 						     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 4610              		.loc 1 1589 0
 4611 277c 3585D6E5 		ldrb	r8, [r6, #1333]	@ zero_extendqisi2
 4612              	.LVL524:
1590:../uvc.c      **** 						     dataIdx = 0;
 4613              		.loc 1 1590 0
 4614 2780 4345D6E5 		ldrb	r4, [r6, #1347]	@ zero_extendqisi2
 4615              	.LVL525:
1592:../uvc.c      **** 							 if(0&&pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
 4616              		.loc 1 1592 0
 4617 2784 FEFFFFEB 		bl	_txe_mutex_get
 4618              	.LVL526:
1600:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 4619              		.loc 1 1600 0
 4620 2788 4125D6E5 		ldrb	r2, [r6, #1345]	@ zero_extendqisi2
1588:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 4621              		.loc 1 1588 0
 4622 278c FF9009E2 		and	r9, r9, #255
 4623              	.LVL527:
1600:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 4624              		.loc 1 1600 0
 4625 2790 02005BE1 		cmp	fp, r2
1589:../uvc.c      **** 						     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 4626              		.loc 1 1589 0
 4627 2794 FF8008E2 		and	r8, r8, #255
 4628              	.LVL528:
1590:../uvc.c      **** 						     dataIdx = 0;
 4629              		.loc 1 1590 0
 4630 2798 FF4004E2 		and	r4, r4, #255
 4631              	.LVL529:
1588:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 4632              		.loc 1 1588 0
 4633 279c 18341FE5 		ldr	r3, .L474+60
1600:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 4634              		.loc 1 1600 0
 4635 27a0 55FDFF0A 		beq	.L414
1601:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 4636              		.loc 1 1601 0
 4637 27a4 41B5C3E5 		strb	fp, [r3, #1345]
1602:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 4638              		.loc 1 1602 0
 4639 27a8 F525D3E5 		ldrb	r2, [r3, #1525]	@ zero_extendqisi2
 4640 27ac 010052E3 		cmp	r2, #1
 4641 27b0 0200000A 		beq	.L411
1602:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 4642              		.loc 1 1602 0 is_stmt 0 discriminator 1
 4643 27b4 F535D3E5 		ldrb	r3, [r3, #1525]	@ zero_extendqisi2
 4644 27b8 030053E3 		cmp	r3, #3
 4645 27bc 4EFDFF1A 		bne	.L414
 4646              	.L411:
1603:../uvc.c      **** 									 dataIdx++;
 4647              		.loc 1 1603 0 is_stmt 1
 4648 27c0 8010A0E3 		mov	r1, #128
 4649 27c4 0030A0E3 		mov	r3, #0
 4650 27c8 0A008DE8 		stmia	sp, {r1, r3}
 4651 27cc 34041FE5 		ldr	r0, .L474+80
 4652 27d0 0920A0E1 		mov	r2, r9
 4653 27d4 0430A0E1 		mov	r3, r4
 4654 27d8 1B10A0E3 		mov	r1, #27
 4655 27dc FEFFFFEB 		bl	cmdSet
 4656              	.LVL530:
1605:../uvc.c      **** 								 }
 4657              		.loc 1 1605 0
 4658 27e0 0110A0E3 		mov	r1, #1
 4659 27e4 04108DE5 		str	r1, [sp, #4]
 4660 27e8 00B08DE5 		str	fp, [sp]
 4661 27ec 0820A0E1 		mov	r2, r8
 4662 27f0 0430A0E1 		mov	r3, r4
 4663 27f4 1B10A0E3 		mov	r1, #27
 4664 27f8 60041FE5 		ldr	r0, .L474+80
 4665 27fc FEFFFFEB 		bl	cmdSet
 4666              	.LVL531:
 4667 2800 3DFDFFEA 		b	.L414
 4668              	.LVL532:
 4669              	.L381:
1985:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4670              		.loc 1 1985 0
 4671 2804 6C741FE5 		ldr	r7, .L474+80
 4672 2808 0010E0E3 		mvn	r1, #0
 4673 280c 1C0097E5 		ldr	r0, [r7, #28]
 4674              	.LVL533:
 4675 2810 14308DE5 		str	r3, [sp, #20]
 4676 2814 FEFFFFEB 		bl	_txe_mutex_get
 4677              	.LVL534:
1986:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4678              		.loc 1 1986 0
 4679 2818 14309DE5 		ldr	r3, [sp, #20]
 4680 281c 0010A0E3 		mov	r1, #0
 4681 2820 0320A0E1 		mov	r2, r3
 4682 2824 0700A0E1 		mov	r0, r7
 4683 2828 0A30A0E1 		mov	r3, r10
 4684 282c 04108DE5 		str	r1, [sp, #4]
 4685 2830 00B08DE5 		str	fp, [sp]
 4686 2834 0410A0E1 		mov	r1, r4
 4687 2838 FEFFFFEB 		bl	cmdSet
 4688              	.LVL535:
1989:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4689              		.loc 1 1989 0
 4690 283c 844084E0 		add	r4, r4, r4, asl #1
1987:../uvc.c      **** 
 4691              		.loc 1 1987 0
 4692 2840 1C0097E5 		ldr	r0, [r7, #28]
 4693 2844 FEFFFFEB 		bl	_txe_mutex_put
 4694              	.LVL536:
1989:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4695              		.loc 1 1989 0
 4696 2848 846186E0 		add	r6, r6, r4, asl #3
1990:../uvc.c      **** 							 break;
 4697              		.loc 1 1990 0
 4698 284c 0130A0E3 		mov	r3, #1
1991:../uvc.c      **** 					 }
 4699              		.loc 1 1991 0
 4700 2850 FF40A0E3 		mov	r4, #255
 4701 2854 18909DE5 		ldr	r9, [sp, #24]
1989:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4702              		.loc 1 1989 0
 4703 2858 F9B1C6E5 		strb	fp, [r6, #505]
 4704 285c 0B70A0E1 		mov	r7, fp
1990:../uvc.c      **** 							 break;
 4705              		.loc 1 1990 0
 4706 2860 FC31C6E5 		strb	r3, [r6, #508]
1991:../uvc.c      **** 					 }
 4707              		.loc 1 1991 0
 4708 2864 04A0A0E1 		mov	r10, r4
 4709 2868 ECFAFFEA 		b	.L284
 4710              	.LVL537:
 4711              	.L285:
1376:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 4712              		.loc 1 1376 0
 4713 286c E4741FE5 		ldr	r7, .L474+64
 4714 2870 048087E0 		add	r8, r7, r4
 4715              	.LVL538:
 4716 2874 A020D8E5 		ldrb	r2, [r8, #160]	@ zero_extendqisi2
 4717 2878 000052E3 		cmp	r2, #0
 4718 287c 8C00000A 		beq	.L365
1377:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4719              		.loc 1 1377 0
 4720 2880 844084E0 		add	r4, r4, r4, asl #1
 4721 2884 846186E0 		add	r6, r6, r4, asl #3
 4722 2888 F9A1D6E5 		ldrb	r10, [r6, #505]	@ zero_extendqisi2
1378:../uvc.c      **** 		 	 		 }else{
 4723              		.loc 1 1378 0
 4724 288c FA41D6E5 		ldrb	r4, [r6, #506]	@ zero_extendqisi2
1377:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4725              		.loc 1 1377 0
 4726 2890 28A0C7E5 		strb	r10, [r7, #40]
1378:../uvc.c      **** 		 	 		 }else{
 4727              		.loc 1 1378 0
 4728 2894 2940C7E5 		strb	r4, [r7, #41]
 4729 2898 F2FBFFEA 		b	.L316
 4730              	.LVL539:
 4731              	.L380:
1994:../uvc.c      **** 			   }
 4732              		.loc 1 1994 0
 4733 289c FF40A0E3 		mov	r4, #255
 4734 28a0 0400A0E3 		mov	r0, #4
 4735              	.LVL540:
 4736 28a4 18151FE5 		ldr	r1, .L474+68
 4737 28a8 FEFFFFEB 		bl	CyU3PDebugPrint
 4738              	.LVL541:
 4739 28ac 04A0A0E1 		mov	r10, r4
 4740 28b0 0490A0E1 		mov	r9, r4
 4741 28b4 0470A0E1 		mov	r7, r4
 4742 28b8 D8FAFFEA 		b	.L284
 4743              	.LVL542:
 4744              	.L442:
1963:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 4745              		.loc 1 1963 0
 4746 28bc FEFFFFEB 		bl	_txe_mutex_get
 4747              	.LVL543:
1964:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4748              		.loc 1 1964 0
 4749 28c0 00B08DE5 		str	fp, [sp]
 4750 28c4 04B08DE5 		str	fp, [sp, #4]
 4751 28c8 0820A0E1 		mov	r2, r8
 4752 28cc 94FEFFEA 		b	.L465
 4753              	.LVL544:
 4754              	.L471:
1931:../uvc.c      **** 					 				 Data0 += 4;
 4755              		.loc 1 1931 0
 4756 28d0 02005BE3 		cmp	fp, #2
 4757 28d4 C501008A 		bhi	.L441
1932:../uvc.c      **** 					 			 }else{
 4758              		.loc 1 1932 0
 4759 28d8 04808BE2 		add	r8, fp, #4
 4760 28dc FF8008E2 		and	r8, r8, #255
 4761              	.LVL545:
 4762 28e0 F8FEFFEA 		b	.L440
 4763              	.LVL546:
 4764              	.L472:
1889:../uvc.c      **** 			                         {
 4765              		.loc 1 1889 0
 4766 28e4 7030D2E5 		ldrb	r3, [r2, #112]	@ zero_extendqisi2
 4767 28e8 013043E2 		sub	r3, r3, #1
 4768 28ec 030053E3 		cmp	r3, #3
 4769 28f0 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 4770 28f4 15FFFFEA 		b	.L426
 4771              	.L428:
 4772 28f8 0C2A0000 		.word	.L427
 4773 28fc C0290000 		.word	.L429
 4774 2900 64290000 		.word	.L430
 4775 2904 08290000 		.word	.L431
 4776              	.L431:
1907:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4777              		.loc 1 1907 0
 4778 2908 6C2097E5 		ldr	r2, [r7, #108]
 4779 290c 5230D6E5 		ldrb	r3, [r6, #82]	@ zero_extendqisi2
 4780 2910 000052E3 		cmp	r2, #0
 4781 2914 F420A003 		moveq	r2, #244
 4782 2918 7420A013 		movne	r2, #116
 4783 291c 032082E1 		orr	r2, r2, r3
 4784 2920 3010A0E3 		mov	r1, #48
 4785 2924 5230A0E3 		mov	r3, #82
 4786 2928 0100A0E3 		mov	r0, #1
 4787 292c FEFFFFEB 		bl	SensorSetIrisControl
 4788              	.LVL547:
1908:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4789              		.loc 1 1908 0
 4790 2930 7D0FA0E3 		mov	r0, #500
 4791 2934 FEFFFFEB 		bl	_tx_thread_sleep
 4792              	.LVL548:
1909:../uvc.c      **** 			                         	default:
 4793              		.loc 1 1909 0
 4794 2938 6C1097E5 		ldr	r1, [r7, #108]
 4795 293c 5220D6E5 		ldrb	r2, [r6, #82]	@ zero_extendqisi2
 4796 2940 000051E3 		cmp	r1, #0
 4797 2944 F410A003 		moveq	r1, #244
 4798 2948 7410A013 		movne	r1, #116
 4799 294c 022081E1 		orr	r2, r1, r2
 4800 2950 6C3097E5 		ldr	r3, [r7, #108]
 4801 2954 C4151FE5 		ldr	r1, .L474+72
 4802 2958 0400A0E3 		mov	r0, #4
 4803 295c FEFFFFEB 		bl	CyU3PDebugPrint
 4804              	.LVL549:
 4805 2960 FAFEFFEA 		b	.L426
 4806              	.L430:
1902:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4807              		.loc 1 1902 0
 4808 2964 6C2097E5 		ldr	r2, [r7, #108]
 4809 2968 5230D6E5 		ldrb	r3, [r6, #82]	@ zero_extendqisi2
 4810 296c 000052E3 		cmp	r2, #0
 4811 2970 C420A003 		moveq	r2, #196
 4812 2974 4420A013 		movne	r2, #68
 4813 2978 032082E1 		orr	r2, r2, r3
 4814 297c 3010A0E3 		mov	r1, #48
 4815 2980 5230A0E3 		mov	r3, #82
 4816 2984 0100A0E3 		mov	r0, #1
 4817 2988 FEFFFFEB 		bl	SensorSetIrisControl
 4818              	.LVL550:
1903:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4819              		.loc 1 1903 0
 4820 298c 7D0FA0E3 		mov	r0, #500
 4821 2990 FEFFFFEB 		bl	_tx_thread_sleep
 4822              	.LVL551:
1904:../uvc.c      **** 			                         		break;
 4823              		.loc 1 1904 0
 4824 2994 6C1097E5 		ldr	r1, [r7, #108]
 4825 2998 5220D6E5 		ldrb	r2, [r6, #82]	@ zero_extendqisi2
 4826 299c 000051E3 		cmp	r1, #0
 4827 29a0 C410A003 		moveq	r1, #196
 4828 29a4 4410A013 		movne	r1, #68
 4829 29a8 022081E1 		orr	r2, r1, r2
 4830 29ac 6C3097E5 		ldr	r3, [r7, #108]
 4831 29b0 20161FE5 		ldr	r1, .L474+72
 4832 29b4 0400A0E3 		mov	r0, #4
 4833 29b8 FEFFFFEB 		bl	CyU3PDebugPrint
 4834              	.LVL552:
1905:../uvc.c      **** 			                         	case 4: //VGA
 4835              		.loc 1 1905 0
 4836 29bc E3FEFFEA 		b	.L426
 4837              	.L429:
1897:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4838              		.loc 1 1897 0
 4839 29c0 6C2097E5 		ldr	r2, [r7, #108]
 4840 29c4 3010A0E3 		mov	r1, #48
 4841 29c8 000052E3 		cmp	r2, #0
 4842 29cc D420A003 		moveq	r2, #212
 4843 29d0 5420A013 		movne	r2, #84
 4844 29d4 5230A0E3 		mov	r3, #82
 4845 29d8 0100A0E3 		mov	r0, #1
 4846 29dc FEFFFFEB 		bl	SensorSetIrisControl
 4847              	.LVL553:
1898:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4848              		.loc 1 1898 0
 4849 29e0 7D0FA0E3 		mov	r0, #500
 4850 29e4 FEFFFFEB 		bl	_tx_thread_sleep
 4851              	.LVL554:
1899:../uvc.c      **** 			                         		break;
 4852              		.loc 1 1899 0
 4853 29e8 6C2097E5 		ldr	r2, [r7, #108]
 4854 29ec 5C161FE5 		ldr	r1, .L474+72
 4855 29f0 000052E3 		cmp	r2, #0
 4856 29f4 6C3097E5 		ldr	r3, [r7, #108]
 4857 29f8 D420A003 		moveq	r2, #212
 4858 29fc 5420A013 		movne	r2, #84
 4859 2a00 0400A0E3 		mov	r0, #4
 4860 2a04 FEFFFFEB 		bl	CyU3PDebugPrint
 4861              	.LVL555:
1900:../uvc.c      **** 			                         	case 3: //720
 4862              		.loc 1 1900 0
 4863 2a08 D0FEFFEA 		b	.L426
 4864              	.L427:
1892:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4865              		.loc 1 1892 0
 4866 2a0c 6C2097E5 		ldr	r2, [r7, #108]
 4867 2a10 3010A0E3 		mov	r1, #48
 4868 2a14 000052E3 		cmp	r2, #0
 4869 2a18 E420A003 		moveq	r2, #228
 4870 2a1c 6420A013 		movne	r2, #100
 4871 2a20 5230A0E3 		mov	r3, #82
 4872 2a24 0100A0E3 		mov	r0, #1
 4873 2a28 FEFFFFEB 		bl	SensorSetIrisControl
 4874              	.LVL556:
1893:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4875              		.loc 1 1893 0
 4876 2a2c 7D0FA0E3 		mov	r0, #500
 4877 2a30 FEFFFFEB 		bl	_tx_thread_sleep
 4878              	.LVL557:
1894:../uvc.c      **** 			                         		break;
 4879              		.loc 1 1894 0
 4880 2a34 6C2097E5 		ldr	r2, [r7, #108]
 4881 2a38 A8161FE5 		ldr	r1, .L474+72
 4882 2a3c 000052E3 		cmp	r2, #0
 4883 2a40 6C3097E5 		ldr	r3, [r7, #108]
 4884 2a44 E420A003 		moveq	r2, #228
 4885 2a48 6420A013 		movne	r2, #100
 4886 2a4c 0400A0E3 		mov	r0, #4
 4887 2a50 FEFFFFEB 		bl	CyU3PDebugPrint
 4888              	.LVL558:
1895:../uvc.c      **** 			                         	case 2: //1080
 4889              		.loc 1 1895 0
 4890 2a54 BDFEFFEA 		b	.L426
 4891              	.LVL559:
 4892              	.L415:
1638:../uvc.c      **** 								 }
 4893              		.loc 1 1638 0
 4894 2a58 0000A0E3 		mov	r0, #0
 4895 2a5c 04008DE5 		str	r0, [sp, #4]
 4896 2a60 00B08DE5 		str	fp, [sp]
 4897 2a64 0410A0E1 		mov	r1, r4
 4898 2a68 0920A0E1 		mov	r2, r9
 4899 2a6c 0830A0E1 		mov	r3, r8
 4900 2a70 D8061FE5 		ldr	r0, .L474+80
 4901 2a74 FEFFFFEB 		bl	cmdSet
 4902              	.LVL560:
 4903 2a78 9FFCFFEA 		b	.L414
 4904              	.LVL561:
 4905              	.L354:
1291:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x1;
 4906              		.loc 1 1291 0
 4907 2a7c 0300A0E1 		mov	r0, r3
 4908              	.LVL562:
 4909 2a80 0A10A0E1 		mov	r1, r10
 4910 2a84 FEFFFFEB 		bl	SensorGetControl
 4911              	.LVL563:
1295:../uvc.c      **** 		 	 		 }
 4912              		.loc 1 1295 0
 4913 2a88 0130A0E3 		mov	r3, #1
 4914 2a8c A030C7E5 		strb	r3, [r7, #160]
1292:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4915              		.loc 1 1292 0
 4916 2a90 030000E0 		and	r0, r0, r3
1293:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4917              		.loc 1 1293 0
 4918 2a94 0D06C6E5 		strb	r0, [r6, #1549]
1294:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4919              		.loc 1 1294 0
 4920 2a98 0E36D6E5 		ldrb	r3, [r6, #1550]	@ zero_extendqisi2
1295:../uvc.c      **** 		 	 		 }
 4921              		.loc 1 1295 0
 4922 2a9c 00A0A0E1 		mov	r10, r0
1294:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4923              		.loc 1 1294 0
 4924 2aa0 FF3003E2 		and	r3, r3, #255
1295:../uvc.c      **** 		 	 		 }
 4925              		.loc 1 1295 0
 4926 2aa4 0340A0E1 		mov	r4, r3
1294:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4927              		.loc 1 1294 0
 4928 2aa8 2930C7E5 		strb	r3, [r7, #41]
1292:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4929              		.loc 1 1292 0
 4930 2aac 2800C7E5 		strb	r0, [r7, #40]
 4931              	.LVL564:
1299:../uvc.c      **** 				 case ShapCtlID7:
 4932              		.loc 1 1299 0
 4933 2ab0 6CFBFFEA 		b	.L316
 4934              	.LVL565:
 4935              	.L365:
1380:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4936              		.loc 1 1380 0
 4937 2ab4 0300A0E1 		mov	r0, r3
 4938              	.LVL566:
 4939 2ab8 0A10A0E1 		mov	r1, r10
 4940 2abc FEFFFFEB 		bl	SensorGetControl
 4941              	.LVL567:
1381:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4942              		.loc 1 1381 0
 4943 2ac0 844084E0 		add	r4, r4, r4, asl #1
 4944              	.LVL568:
 4945 2ac4 846186E0 		add	r6, r6, r4, asl #3
1382:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4946              		.loc 1 1382 0
 4947 2ac8 FA31D6E5 		ldrb	r3, [r6, #506]	@ zero_extendqisi2
1383:../uvc.c      **** 		 	 		 }
 4948              		.loc 1 1383 0
 4949 2acc 0120A0E3 		mov	r2, #1
 4950 2ad0 0340A0E1 		mov	r4, r3
1382:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4951              		.loc 1 1382 0
 4952 2ad4 2930C7E5 		strb	r3, [r7, #41]
1383:../uvc.c      **** 		 	 		 }
 4953              		.loc 1 1383 0
 4954 2ad8 A020C8E5 		strb	r2, [r8, #160]
 4955 2adc 00A0A0E1 		mov	r10, r0
 4956              	.LVL569:
1381:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4957              		.loc 1 1381 0
 4958 2ae0 F901C6E5 		strb	r0, [r6, #505]
1380:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4959              		.loc 1 1380 0
 4960 2ae4 2800C7E5 		strb	r0, [r7, #40]
1389:../uvc.c      **** 			 }
 4961              		.loc 1 1389 0
 4962 2ae8 5EFBFFEA 		b	.L316
 4963              	.LVL570:
 4964              	.L350:
1255:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 4965              		.loc 1 1255 0
 4966 2aec 0300A0E1 		mov	r0, r3
 4967              	.LVL571:
 4968 2af0 0A10A0E1 		mov	r1, r10
 4969 2af4 FEFFFFEB 		bl	SensorGetControl
 4970              	.LVL572:
1257:../uvc.c      **** 		 	 		 }
 4971              		.loc 1 1257 0
 4972 2af8 0130A0E3 		mov	r3, #1
 4973 2afc A530C7E5 		strb	r3, [r7, #165]
1256:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4974              		.loc 1 1256 0
 4975 2b00 7102C6E5 		strb	r0, [r6, #625]
 4976 2b04 21FCFFEA 		b	.L348
 4977              	.LVL573:
 4978              	.L362:
1361:../uvc.c      **** 		 	 			glEp0Buffer[0] = (Data0&0x80)>>7;
 4979              		.loc 1 1361 0
 4980 2b08 0A10A0E1 		mov	r1, r10
 4981 2b0c 0100A0E3 		mov	r0, #1
 4982              	.LVL574:
 4983 2b10 FEFFFFEB 		bl	SensorGetControl
 4984              	.LVL575:
1365:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4985              		.loc 1 1365 0
 4986 2b14 5A32D6E5 		ldrb	r3, [r6, #602]	@ zero_extendqisi2
1366:../uvc.c      **** 		 	 		 }
 4987              		.loc 1 1366 0
 4988 2b18 0120A0E3 		mov	r2, #1
 4989 2b1c 0340A0E1 		mov	r4, r3
1365:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4990              		.loc 1 1365 0
 4991 2b20 2930C7E5 		strb	r3, [r7, #41]
1366:../uvc.c      **** 		 	 		 }
 4992              		.loc 1 1366 0
 4993 2b24 A420C7E5 		strb	r2, [r7, #164]
1362:../uvc.c      **** 		 	 			glEp0Buffer[0]++;
 4994              		.loc 1 1362 0
 4995 2b28 A003A0E1 		mov	r0, r0, lsr #7
 4996              	.LVL576:
1363:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4997              		.loc 1 1363 0
 4998 2b2c 023080E0 		add	r3, r0, r2
 4999 2b30 FF3003E2 		and	r3, r3, #255
 5000 2b34 03A0A0E1 		mov	r10, r3
 5001 2b38 2830C7E5 		strb	r3, [r7, #40]
1364:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 5002              		.loc 1 1364 0
 5003 2b3c 5932C6E5 		strb	r3, [r6, #601]
 5004              	.LVL577:
1371:../uvc.c      **** 				 case SaturCtlID6:
 5005              		.loc 1 1371 0
 5006 2b40 48FBFFEA 		b	.L316
 5007              	.LVL578:
 5008              	.L356:
1308:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 5009              		.loc 1 1308 0
 5010 2b44 0A10A0E1 		mov	r1, r10
 5011 2b48 0C00A0E1 		mov	r0, ip
 5012              	.LVL579:
 5013 2b4c FEFFFFEB 		bl	SensorGetControl
 5014              	.LVL580:
1311:../uvc.c      **** 		 	 		 }
 5015              		.loc 1 1311 0
 5016 2b50 0120A0E3 		mov	r2, #1
 5017 2b54 A720C7E5 		strb	r2, [r7, #167]
1309:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 5018              		.loc 1 1309 0
 5019 2b58 2106C6E5 		strb	r0, [r6, #1569]
1310:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5020              		.loc 1 1310 0
 5021 2b5c 2236D6E5 		ldrb	r3, [r6, #1570]	@ zero_extendqisi2
1311:../uvc.c      **** 		 	 		 }
 5022              		.loc 1 1311 0
 5023 2b60 00A0A0E1 		mov	r10, r0
 5024              	.LVL581:
1310:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5025              		.loc 1 1310 0
 5026 2b64 FF3003E2 		and	r3, r3, #255
1311:../uvc.c      **** 		 	 		 }
 5027              		.loc 1 1311 0
 5028 2b68 0340A0E1 		mov	r4, r3
 5029              	.LVL582:
1310:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5030              		.loc 1 1310 0
 5031 2b6c 2930C7E5 		strb	r3, [r7, #41]
1308:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 5032              		.loc 1 1308 0
 5033 2b70 2800C7E5 		strb	r0, [r7, #40]
1315:../uvc.c      **** 				 case ExtExRefCtlID10:
 5034              		.loc 1 1315 0
 5035 2b74 3BFBFFEA 		b	.L316
 5036              	.LVL583:
 5037              	.L317:
 976:../uvc.c      **** 			 	 			glEp0Buffer[0] = Data0;
 5038              		.loc 1 976 0
 5039 2b78 0300A0E1 		mov	r0, r3
 5040              	.LVL584:
 5041 2b7c 0A10A0E1 		mov	r1, r10
 5042 2b80 FEFFFFEB 		bl	SensorGetControl
 5043              	.LVL585:
 980:../uvc.c      **** 			 	 		 }
 5044              		.loc 1 980 0
 5045 2b84 0120A0E3 		mov	r2, #1
 5046 2b88 C520C7E5 		strb	r2, [r7, #197]
 978:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 5047              		.loc 1 978 0
 5048 2b8c 1905C6E5 		strb	r0, [r6, #1305]
 979:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 5049              		.loc 1 979 0
 5050 2b90 1A35D6E5 		ldrb	r3, [r6, #1306]	@ zero_extendqisi2
 980:../uvc.c      **** 			 	 		 }
 5051              		.loc 1 980 0
 5052 2b94 00A0A0E1 		mov	r10, r0
 5053              	.LVL586:
 979:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 5054              		.loc 1 979 0
 5055 2b98 FF3003E2 		and	r3, r3, #255
 980:../uvc.c      **** 			 	 		 }
 5056              		.loc 1 980 0
 5057 2b9c 0340A0E1 		mov	r4, r3
 5058              	.LVL587:
 979:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 5059              		.loc 1 979 0
 5060 2ba0 2930C7E5 		strb	r3, [r7, #41]
 977:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5061              		.loc 1 977 0
 5062 2ba4 2800C7E5 		strb	r0, [r7, #40]
 984:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 5063              		.loc 1 984 0
 5064 2ba8 2EFBFFEA 		b	.L316
 5065              	.LVL588:
 5066              	.L352:
1273:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 5067              		.loc 1 1273 0
 5068 2bac 0300A0E1 		mov	r0, r3
 5069              	.LVL589:
 5070 2bb0 0A10A0E1 		mov	r1, r10
 5071 2bb4 10C08DE5 		str	ip, [sp, #16]
 5072 2bb8 FEFFFFEB 		bl	SensorGetControl
 5073              	.LVL590:
1274:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 5074              		.loc 1 1274 0
 5075 2bbc 10C09DE5 		ldr	ip, [sp, #16]
 5076 2bc0 0A10A0E1 		mov	r1, r10
1273:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 5077              		.loc 1 1273 0
 5078 2bc4 0080A0E1 		mov	r8, r0
 5079              	.LVL591:
1274:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 5080              		.loc 1 1274 0
 5081 2bc8 0C00A0E1 		mov	r0, ip
 5082              	.LVL592:
 5083 2bcc FEFFFFEB 		bl	SensorGetControl
 5084              	.LVL593:
1279:../uvc.c      **** 		 	 		 }
 5085              		.loc 1 1279 0
 5086 2bd0 0130A0E3 		mov	r3, #1
 5087 2bd4 08A0A0E1 		mov	r10, r8
1275:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 5088              		.loc 1 1275 0
 5089 2bd8 2880C7E5 		strb	r8, [r7, #40]
1276:../uvc.c      **** 						glEp0Buffer[2] = Data1;
 5090              		.loc 1 1276 0
 5091 2bdc FC85C6E5 		strb	r8, [r6, #1532]
1279:../uvc.c      **** 		 	 		 }
 5092              		.loc 1 1279 0
 5093 2be0 AB30C7E5 		strb	r3, [r7, #171]
 5094 2be4 0040A0E1 		mov	r4, r0
 5095              	.LVL594:
1277:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 5096              		.loc 1 1277 0
 5097 2be8 2A00C7E5 		strb	r0, [r7, #42]
1278:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5098              		.loc 1 1278 0
 5099 2bec FE05C6E5 		strb	r0, [r6, #1534]
 5100 2bf0 E0FCFFEA 		b	.L353
 5101              	.LVL595:
 5102              	.L358:
1325:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
 5103              		.loc 1 1325 0
 5104 2bf4 0300A0E1 		mov	r0, r3
 5105              	.LVL596:
 5106 2bf8 0A10A0E1 		mov	r1, r10
 5107 2bfc FEFFFFEB 		bl	SensorGetControl
 5108              	.LVL597:
1327:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5109              		.loc 1 1327 0
 5110 2c00 2A32D6E5 		ldrb	r3, [r6, #554]	@ zero_extendqisi2
1328:../uvc.c      **** 		 	 		 }
 5111              		.loc 1 1328 0
 5112 2c04 0120A0E3 		mov	r2, #1
 5113 2c08 0340A0E1 		mov	r4, r3
 5114              	.LVL598:
1327:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5115              		.loc 1 1327 0
 5116 2c0c 2930C7E5 		strb	r3, [r7, #41]
1328:../uvc.c      **** 		 	 		 }
 5117              		.loc 1 1328 0
 5118 2c10 A020C8E5 		strb	r2, [r8, #160]
 5119 2c14 00A0A0E1 		mov	r10, r0
 5120              	.LVL599:
1325:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
 5121              		.loc 1 1325 0
 5122 2c18 2800C7E5 		strb	r0, [r7, #40]
1326:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 5123              		.loc 1 1326 0
 5124 2c1c 2902C6E5 		strb	r0, [r6, #553]
1332:../uvc.c      **** 				 case WBTMdCtlID9:
 5125              		.loc 1 1332 0
 5126 2c20 10FBFFEA 		b	.L316
 5127              	.LVL600:
 5128              	.L321:
1019:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
 5129              		.loc 1 1019 0
 5130 2c24 FEFFFFEB 		bl	SensorGetControl
 5131              	.LVL601:
1025:../uvc.c      **** 
 5132              		.loc 1 1025 0
 5133 2c28 94181FE5 		ldr	r1, .L474+76
1020:../uvc.c      **** 		 	 			Data1 = (Data0&0x70)>>4;
 5134              		.loc 1 1020 0
 5135 2c2c 2D05C6E5 		strb	r0, [r6, #1325]
1021:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 5136              		.loc 1 1021 0
 5137 2c30 707000E2 		and	r7, r0, #112
1023:../uvc.c      **** 		 	 			//curFlag[CtrlID] = CyTrue;
 5138              		.loc 1 1023 0
 5139 2c34 2EC5D6E5 		ldrb	ip, [r6, #1326]	@ zero_extendqisi2
1021:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 5140              		.loc 1 1021 0
 5141 2c38 4772A0E1 		mov	r7, r7, asr #4
1025:../uvc.c      **** 
 5142              		.loc 1 1025 0
 5143 2c3c 0720A0E1 		mov	r2, r7
1021:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 5144              		.loc 1 1021 0
 5145 2c40 FF7007E2 		and	r7, r7, #255
 5146              	.LVL602:
1025:../uvc.c      **** 
 5147              		.loc 1 1025 0
 5148 2c44 00008DE5 		str	r0, [sp]
 5149 2c48 0230A0E1 		mov	r3, r2
 5150 2c4c 0400A0E3 		mov	r0, #4
 5151              	.LVL603:
1023:../uvc.c      **** 		 	 			//curFlag[CtrlID] = CyTrue;
 5152              		.loc 1 1023 0
 5153 2c50 29C0C4E5 		strb	ip, [r4, #41]
1022:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 5154              		.loc 1 1022 0
 5155 2c54 2870C4E5 		strb	r7, [r4, #40]
1025:../uvc.c      **** 
 5156              		.loc 1 1025 0
 5157 2c58 FEFFFFEB 		bl	CyU3PDebugPrint
 5158              	.LVL604:
 5159 2c5c 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 5160 2c60 D7FCFFEA 		b	.L322
 5161              	.LVL605:
 5162              	.L360:
1339:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 5163              		.loc 1 1339 0
 5164 2c64 0A10A0E1 		mov	r1, r10
 5165 2c68 0300A0E1 		mov	r0, r3
 5166              	.LVL606:
 5167 2c6c FEFFFFEB 		bl	SensorGetControl
 5168              	.LVL607:
1342:../uvc.c      **** 
 5169              		.loc 1 1342 0
 5170 2c70 D232D6E5 		ldrb	r3, [r6, #722]	@ zero_extendqisi2
1344:../uvc.c      **** 		 	 		 }
 5171              		.loc 1 1344 0
 5172 2c74 0110A0E3 		mov	r1, #1
 5173 2c78 0340A0E1 		mov	r4, r3
1342:../uvc.c      **** 
 5174              		.loc 1 1342 0
 5175 2c7c 2930C7E5 		strb	r3, [r7, #41]
1344:../uvc.c      **** 		 	 		 }
 5176              		.loc 1 1344 0
 5177 2c80 A910C7E5 		strb	r1, [r7, #169]
1341:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 5178              		.loc 1 1341 0
 5179 2c84 032000E2 		and	r2, r0, #3
1344:../uvc.c      **** 		 	 		 }
 5180              		.loc 1 1344 0
 5181 2c88 02A0A0E1 		mov	r10, r2
 5182              	.LVL608:
1340:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 5183              		.loc 1 1340 0
 5184 2c8c D102C6E5 		strb	r0, [r6, #721]
1341:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 5185              		.loc 1 1341 0
 5186 2c90 2820C7E5 		strb	r2, [r7, #40]
1348:../uvc.c      **** 				 case MFreqCtlID4:
 5187              		.loc 1 1348 0
 5188 2c94 F3FAFFEA 		b	.L316
 5189              	.LVL609:
 5190              	.L346:
1237:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 5191              		.loc 1 1237 0
 5192 2c98 0300A0E1 		mov	r0, r3
 5193              	.LVL610:
 5194 2c9c 0A10A0E1 		mov	r1, r10
 5195 2ca0 FEFFFFEB 		bl	SensorGetControl
 5196              	.LVL611:
1239:../uvc.c      **** 		 	 		 }
 5197              		.loc 1 1239 0
 5198 2ca4 0130A0E3 		mov	r3, #1
 5199 2ca8 A130C7E5 		strb	r3, [r7, #161]
1238:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5200              		.loc 1 1238 0
 5201 2cac 1102C6E5 		strb	r0, [r6, #529]
 5202 2cb0 B2FBFFEA 		b	.L347
 5203              	.LVL612:
 5204              	.L344:
1200:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 5205              		.loc 1 1200 0
 5206 2cb4 0410A0E1 		mov	r1, r4
 5207 2cb8 FEFFFFEB 		bl	SensorGetControl
 5208              	.LVL613:
1204:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 5209              		.loc 1 1204 0
 5210 2cbc 0410A0E1 		mov	r1, r4
1201:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5211              		.loc 1 1201 0
 5212 2cc0 033000E2 		and	r3, r0, #3
1204:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 5213              		.loc 1 1204 0
 5214 2cc4 0800A0E1 		mov	r0, r8
1201:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5215              		.loc 1 1201 0
 5216 2cc8 2830C7E5 		strb	r3, [r7, #40]
1202:../uvc.c      **** 
 5217              		.loc 1 1202 0
 5218 2ccc F535C6E5 		strb	r3, [r6, #1525]
1204:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 5219              		.loc 1 1204 0
 5220 2cd0 FEFFFFEB 		bl	SensorGetControl
 5221              	.LVL614:
1206:../uvc.c      **** 		 	 		 }
 5222              		.loc 1 1206 0
 5223 2cd4 0130A0E3 		mov	r3, #1
 5224 2cd8 28A0D7E5 		ldrb	r10, [r7, #40]	@ zero_extendqisi2
 5225 2cdc B930C7E5 		strb	r3, [r7, #185]
 5226 2ce0 0040A0E1 		mov	r4, r0
 5227              	.LVL615:
1204:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 5228              		.loc 1 1204 0
 5229 2ce4 2A00C7E5 		strb	r0, [r7, #42]
1205:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5230              		.loc 1 1205 0
 5231 2ce8 F605C6E5 		strb	r0, [r6, #1526]
 5232 2cec 87FBFFEA 		b	.L345
 5233              	.LVL616:
 5234              	.L314:
 961:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5235              		.loc 1 961 0
 5236 2cf0 0A10A0E1 		mov	r1, r10
 5237 2cf4 0C00A0E1 		mov	r0, ip
 5238              	.LVL617:
 5239 2cf8 14308DE5 		str	r3, [sp, #20]
 5240 2cfc FEFFFFEB 		bl	SensorGetControl
 5241              	.LVL618:
 963:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 5242              		.loc 1 963 0
 5243 2d00 14309DE5 		ldr	r3, [sp, #20]
 5244 2d04 0A10A0E1 		mov	r1, r10
 961:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5245              		.loc 1 961 0
 5246 2d08 0020A0E1 		mov	r2, r0
 963:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 5247              		.loc 1 963 0
 5248 2d0c 0300A0E1 		mov	r0, r3
 961:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5249              		.loc 1 961 0
 5250 2d10 2820C7E5 		strb	r2, [r7, #40]
 962:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 5251              		.loc 1 962 0
 5252 2d14 0525C6E5 		strb	r2, [r6, #1285]
 963:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 5253              		.loc 1 963 0
 5254 2d18 FEFFFFEB 		bl	SensorGetControl
 5255              	.LVL619:
 964:../uvc.c      **** 			 	 		 }
 5256              		.loc 1 964 0
 5257 2d1c 0130A0E3 		mov	r3, #1
 5258 2d20 28A0D7E5 		ldrb	r10, [r7, #40]	@ zero_extendqisi2
 5259 2d24 C430C7E5 		strb	r3, [r7, #196]
 5260              	.LVL620:
 5261 2d28 0040A0E1 		mov	r4, r0
 5262              	.LVL621:
 963:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 5263              		.loc 1 963 0
 5264 2d2c 2900C7E5 		strb	r0, [r7, #41]
 968:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 5265              		.loc 1 968 0
 5266 2d30 CCFAFFEA 		b	.L316
 5267              	.LVL622:
 5268              	.L334:
1128:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5269              		.loc 1 1128 0
 5270 2d34 0A10A0E1 		mov	r1, r10
 5271 2d38 0C00A0E1 		mov	r0, ip
 5272              	.LVL623:
 5273 2d3c 14308DE5 		str	r3, [sp, #20]
 5274 2d40 FEFFFFEB 		bl	SensorGetControl
 5275              	.LVL624:
1130:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5276              		.loc 1 1130 0
 5277 2d44 14309DE5 		ldr	r3, [sp, #20]
 5278 2d48 0A10A0E1 		mov	r1, r10
1128:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5279              		.loc 1 1128 0
 5280 2d4c 0020A0E1 		mov	r2, r0
1130:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5281              		.loc 1 1130 0
 5282 2d50 0300A0E1 		mov	r0, r3
1128:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5283              		.loc 1 1128 0
 5284 2d54 2820C7E5 		strb	r2, [r7, #40]
1129:../uvc.c      **** 		 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 5285              		.loc 1 1129 0
 5286 2d58 9125C6E5 		strb	r2, [r6, #1425]
1130:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5287              		.loc 1 1130 0
 5288 2d5c FEFFFFEB 		bl	SensorGetControl
 5289              	.LVL625:
1131:../uvc.c      **** 		 	 		 }
 5290              		.loc 1 1131 0
 5291 2d60 0130A0E3 		mov	r3, #1
 5292 2d64 28A0D7E5 		ldrb	r10, [r7, #40]	@ zero_extendqisi2
 5293 2d68 CA30C7E5 		strb	r3, [r7, #202]
 5294              	.LVL626:
 5295 2d6c 0040A0E1 		mov	r4, r0
 5296              	.LVL627:
1130:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5297              		.loc 1 1130 0
 5298 2d70 2900C7E5 		strb	r0, [r7, #41]
1135:../uvc.c      **** 		 	 	 case Ext1EnhanceStarEndCtlID11:
 5299              		.loc 1 1135 0
 5300 2d74 BBFAFFEA 		b	.L316
 5301              	.LVL628:
 5302              	.L338:
1154:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5303              		.loc 1 1154 0
 5304 2d78 0A10A0E1 		mov	r1, r10
 5305 2d7c 0C00A0E1 		mov	r0, ip
 5306              	.LVL629:
 5307 2d80 14308DE5 		str	r3, [sp, #20]
 5308 2d84 FEFFFFEB 		bl	SensorGetControl
 5309              	.LVL630:
1156:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5310              		.loc 1 1156 0
 5311 2d88 14309DE5 		ldr	r3, [sp, #20]
 5312 2d8c 0A10A0E1 		mov	r1, r10
1154:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5313              		.loc 1 1154 0
 5314 2d90 0020A0E1 		mov	r2, r0
1156:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5315              		.loc 1 1156 0
 5316 2d94 0300A0E1 		mov	r0, r3
1154:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5317              		.loc 1 1154 0
 5318 2d98 2820C7E5 		strb	r2, [r7, #40]
1155:../uvc.c      **** 		 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 5319              		.loc 1 1155 0
 5320 2d9c B925C6E5 		strb	r2, [r6, #1465]
1156:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5321              		.loc 1 1156 0
 5322 2da0 FEFFFFEB 		bl	SensorGetControl
 5323              	.LVL631:
1157:../uvc.c      **** 		 	 		 }
 5324              		.loc 1 1157 0
 5325 2da4 0130A0E3 		mov	r3, #1
 5326 2da8 28A0D7E5 		ldrb	r10, [r7, #40]	@ zero_extendqisi2
 5327 2dac CC30C7E5 		strb	r3, [r7, #204]
 5328              	.LVL632:
 5329 2db0 0040A0E1 		mov	r4, r0
 5330              	.LVL633:
1156:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5331              		.loc 1 1156 0
 5332 2db4 2900C7E5 		strb	r0, [r7, #41]
1161:../uvc.c      **** 		 	 	 case Ext12DNRGainStarEndCtlID13:
 5333              		.loc 1 1161 0
 5334 2db8 AAFAFFEA 		b	.L316
 5335              	.LVL634:
 5336              	.L336:
1141:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5337              		.loc 1 1141 0
 5338 2dbc 0A10A0E1 		mov	r1, r10
 5339 2dc0 0C00A0E1 		mov	r0, ip
 5340              	.LVL635:
 5341 2dc4 14308DE5 		str	r3, [sp, #20]
 5342 2dc8 FEFFFFEB 		bl	SensorGetControl
 5343              	.LVL636:
1143:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5344              		.loc 1 1143 0
 5345 2dcc 14309DE5 		ldr	r3, [sp, #20]
 5346 2dd0 0A10A0E1 		mov	r1, r10
1141:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5347              		.loc 1 1141 0
 5348 2dd4 0020A0E1 		mov	r2, r0
1143:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5349              		.loc 1 1143 0
 5350 2dd8 0300A0E1 		mov	r0, r3
1141:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5351              		.loc 1 1141 0
 5352 2ddc 2820C7E5 		strb	r2, [r7, #40]
1142:../uvc.c      **** 		 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 5353              		.loc 1 1142 0
 5354 2de0 A525C6E5 		strb	r2, [r6, #1445]
1143:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5355              		.loc 1 1143 0
 5356 2de4 FEFFFFEB 		bl	SensorGetControl
 5357              	.LVL637:
1144:../uvc.c      **** 		 	 		 }
 5358              		.loc 1 1144 0
 5359 2de8 0130A0E3 		mov	r3, #1
 5360 2dec 28A0D7E5 		ldrb	r10, [r7, #40]	@ zero_extendqisi2
 5361 2df0 CB30C7E5 		strb	r3, [r7, #203]
 5362              	.LVL638:
 5363 2df4 0040A0E1 		mov	r4, r0
 5364              	.LVL639:
1143:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5365              		.loc 1 1143 0
 5366 2df8 2900C7E5 		strb	r0, [r7, #41]
1148:../uvc.c      **** 		 	 	 case Ext12DNRGainEnblCtlID12:
 5367              		.loc 1 1148 0
 5368 2dfc 99FAFFEA 		b	.L316
 5369              	.LVL640:
 5370              	.L332:
1115:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5371              		.loc 1 1115 0
 5372 2e00 0A10A0E1 		mov	r1, r10
 5373 2e04 0C00A0E1 		mov	r0, ip
 5374              	.LVL641:
 5375 2e08 14308DE5 		str	r3, [sp, #20]
 5376 2e0c FEFFFFEB 		bl	SensorGetControl
 5377              	.LVL642:
1117:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5378              		.loc 1 1117 0
 5379 2e10 14309DE5 		ldr	r3, [sp, #20]
 5380 2e14 0A10A0E1 		mov	r1, r10
1115:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5381              		.loc 1 1115 0
 5382 2e18 0020A0E1 		mov	r2, r0
1117:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5383              		.loc 1 1117 0
 5384 2e1c 0300A0E1 		mov	r0, r3
1115:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5385              		.loc 1 1115 0
 5386 2e20 2820C7E5 		strb	r2, [r7, #40]
1116:../uvc.c      **** 		 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 5387              		.loc 1 1116 0
 5388 2e24 7D25C6E5 		strb	r2, [r6, #1405]
1117:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5389              		.loc 1 1117 0
 5390 2e28 FEFFFFEB 		bl	SensorGetControl
 5391              	.LVL643:
1118:../uvc.c      **** 		 	 		 }
 5392              		.loc 1 1118 0
 5393 2e2c 0130A0E3 		mov	r3, #1
 5394 2e30 28A0D7E5 		ldrb	r10, [r7, #40]	@ zero_extendqisi2
 5395 2e34 C930C7E5 		strb	r3, [r7, #201]
 5396              	.LVL644:
 5397 2e38 0040A0E1 		mov	r4, r0
 5398              	.LVL645:
1117:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5399              		.loc 1 1117 0
 5400 2e3c 2900C7E5 		strb	r0, [r7, #41]
1122:../uvc.c      **** 		 	 	 case Ext1EnhanceGainCtlID10:
 5401              		.loc 1 1122 0
 5402 2e40 88FAFFEA 		b	.L316
 5403              	.LVL646:
 5404              	.L319:
 994:../uvc.c      **** 			 	 			if(Data0&0x80)
 5405              		.loc 1 994 0
 5406 2e44 0300A0E1 		mov	r0, r3
 5407              	.LVL647:
 5408 2e48 0A10A0E1 		mov	r1, r10
 5409 2e4c FEFFFFEB 		bl	SensorGetControl
 5410              	.LVL648:
1000:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 5411              		.loc 1 1000 0
 5412 2e50 0A31D6E5 		ldrb	r3, [r6, #266]	@ zero_extendqisi2
1001:../uvc.c      **** 			 	 		 }
 5413              		.loc 1 1001 0
 5414 2e54 0120A0E3 		mov	r2, #1
 5415 2e58 0340A0E1 		mov	r4, r3
1000:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 5416              		.loc 1 1000 0
 5417 2e5c 2930C7E5 		strb	r3, [r7, #41]
1001:../uvc.c      **** 			 	 		 }
 5418              		.loc 1 1001 0
 5419 2e60 C620C7E5 		strb	r2, [r7, #198]
 995:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 5420              		.loc 1 995 0
 5421 2e64 A003A0E1 		mov	r0, r0, lsr #7
 5422              	.LVL649:
 996:../uvc.c      **** 			 	 			else
 5423              		.loc 1 996 0
 5424 2e68 02A000E0 		and	r10, r0, r2
 5425 2e6c 28A0C7E5 		strb	r10, [r7, #40]
 999:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 5426              		.loc 1 999 0
 5427 2e70 09A1C6E5 		strb	r10, [r6, #265]
 5428              	.LVL650:
1005:../uvc.c      **** 			 	 }
 5429              		.loc 1 1005 0
 5430 2e74 7BFAFFEA 		b	.L316
 5431              	.LVL651:
 5432              	.L330:
1102:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5433              		.loc 1 1102 0
 5434 2e78 0A10A0E1 		mov	r1, r10
 5435 2e7c 0C00A0E1 		mov	r0, ip
 5436              	.LVL652:
 5437 2e80 14308DE5 		str	r3, [sp, #20]
 5438 2e84 FEFFFFEB 		bl	SensorGetControl
 5439              	.LVL653:
1104:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5440              		.loc 1 1104 0
 5441 2e88 14309DE5 		ldr	r3, [sp, #20]
 5442 2e8c 0A10A0E1 		mov	r1, r10
1102:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5443              		.loc 1 1102 0
 5444 2e90 0020A0E1 		mov	r2, r0
1104:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5445              		.loc 1 1104 0
 5446 2e94 0300A0E1 		mov	r0, r3
1102:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5447              		.loc 1 1102 0
 5448 2e98 2820C7E5 		strb	r2, [r7, #40]
1103:../uvc.c      **** 		 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 5449              		.loc 1 1103 0
 5450 2e9c 6925C6E5 		strb	r2, [r6, #1385]
1104:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5451              		.loc 1 1104 0
 5452 2ea0 FEFFFFEB 		bl	SensorGetControl
 5453              	.LVL654:
1105:../uvc.c      **** 		 	 		 }
 5454              		.loc 1 1105 0
 5455 2ea4 0130A0E3 		mov	r3, #1
 5456 2ea8 28A0D7E5 		ldrb	r10, [r7, #40]	@ zero_extendqisi2
 5457 2eac C830C7E5 		strb	r3, [r7, #200]
 5458              	.LVL655:
 5459 2eb0 0040A0E1 		mov	r4, r0
 5460              	.LVL656:
1104:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5461              		.loc 1 1104 0
 5462 2eb4 2900C7E5 		strb	r0, [r7, #41]
1109:../uvc.c      **** 		 	 	 case Ext1EnhanceModeCtlID9:
 5463              		.loc 1 1109 0
 5464 2eb8 6AFAFFEA 		b	.L316
 5465              	.LVL657:
 5466              	.L328:
1089:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5467              		.loc 1 1089 0
 5468 2ebc 0A10A0E1 		mov	r1, r10
 5469 2ec0 0C00A0E1 		mov	r0, ip
 5470              	.LVL658:
 5471 2ec4 14308DE5 		str	r3, [sp, #20]
 5472 2ec8 FEFFFFEB 		bl	SensorGetControl
 5473              	.LVL659:
1091:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5474              		.loc 1 1091 0
 5475 2ecc 14309DE5 		ldr	r3, [sp, #20]
 5476 2ed0 0A10A0E1 		mov	r1, r10
1089:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5477              		.loc 1 1089 0
 5478 2ed4 0020A0E1 		mov	r2, r0
1091:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5479              		.loc 1 1091 0
 5480 2ed8 0300A0E1 		mov	r0, r3
1089:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5481              		.loc 1 1089 0
 5482 2edc 2820C7E5 		strb	r2, [r7, #40]
1090:../uvc.c      **** 		 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 5483              		.loc 1 1090 0
 5484 2ee0 5525C6E5 		strb	r2, [r6, #1365]
1091:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5485              		.loc 1 1091 0
 5486 2ee4 FEFFFFEB 		bl	SensorGetControl
 5487              	.LVL660:
1092:../uvc.c      **** 		 	 		 }
 5488              		.loc 1 1092 0
 5489 2ee8 0130A0E3 		mov	r3, #1
 5490 2eec 28A0D7E5 		ldrb	r10, [r7, #40]	@ zero_extendqisi2
 5491 2ef0 C730C7E5 		strb	r3, [r7, #199]
 5492              	.LVL661:
 5493 2ef4 0040A0E1 		mov	r4, r0
 5494              	.LVL662:
1091:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5495              		.loc 1 1091 0
 5496 2ef8 2900C7E5 		strb	r0, [r7, #41]
1096:../uvc.c      **** 		 	 	 case Ext1ExCtrlSpeedCtlID8:
 5497              		.loc 1 1096 0
 5498 2efc 59FAFFEA 		b	.L316
 5499              	.LVL663:
 5500              	.L342:
1180:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5501              		.loc 1 1180 0
 5502 2f00 0A10A0E1 		mov	r1, r10
 5503 2f04 0C00A0E1 		mov	r0, ip
 5504              	.LVL664:
 5505 2f08 14308DE5 		str	r3, [sp, #20]
 5506 2f0c FEFFFFEB 		bl	SensorGetControl
 5507              	.LVL665:
1182:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5508              		.loc 1 1182 0
 5509 2f10 14309DE5 		ldr	r3, [sp, #20]
 5510 2f14 0A10A0E1 		mov	r1, r10
1180:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5511              		.loc 1 1180 0
 5512 2f18 0020A0E1 		mov	r2, r0
1182:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5513              		.loc 1 1182 0
 5514 2f1c 0300A0E1 		mov	r0, r3
1180:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5515              		.loc 1 1180 0
 5516 2f20 2820C7E5 		strb	r2, [r7, #40]
1181:../uvc.c      **** 		 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 5517              		.loc 1 1181 0
 5518 2f24 E125C6E5 		strb	r2, [r6, #1505]
1182:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5519              		.loc 1 1182 0
 5520 2f28 FEFFFFEB 		bl	SensorGetControl
 5521              	.LVL666:
1183:../uvc.c      **** 		 	 		 }
 5522              		.loc 1 1183 0
 5523 2f2c 0130A0E3 		mov	r3, #1
 5524 2f30 28A0D7E5 		ldrb	r10, [r7, #40]	@ zero_extendqisi2
 5525 2f34 CE30C7E5 		strb	r3, [r7, #206]
 5526              	.LVL667:
 5527 2f38 0040A0E1 		mov	r4, r0
 5528              	.LVL668:
1182:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5529              		.loc 1 1182 0
 5530 2f3c 2900C7E5 		strb	r0, [r7, #41]
1187:../uvc.c      **** 
 5531              		.loc 1 1187 0
 5532 2f40 48FAFFEA 		b	.L316
 5533              	.LVL669:
 5534              	.L340:
1167:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5535              		.loc 1 1167 0
 5536 2f44 0A10A0E1 		mov	r1, r10
 5537 2f48 0C00A0E1 		mov	r0, ip
 5538              	.LVL670:
 5539 2f4c 14308DE5 		str	r3, [sp, #20]
 5540 2f50 FEFFFFEB 		bl	SensorGetControl
 5541              	.LVL671:
1169:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5542              		.loc 1 1169 0
 5543 2f54 14309DE5 		ldr	r3, [sp, #20]
 5544 2f58 0A10A0E1 		mov	r1, r10
1167:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5545              		.loc 1 1167 0
 5546 2f5c 0020A0E1 		mov	r2, r0
1169:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5547              		.loc 1 1169 0
 5548 2f60 0300A0E1 		mov	r0, r3
1167:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5549              		.loc 1 1167 0
 5550 2f64 2820C7E5 		strb	r2, [r7, #40]
1168:../uvc.c      **** 		 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 5551              		.loc 1 1168 0
 5552 2f68 CD25C6E5 		strb	r2, [r6, #1485]
1169:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5553              		.loc 1 1169 0
 5554 2f6c FEFFFFEB 		bl	SensorGetControl
 5555              	.LVL672:
1170:../uvc.c      **** 		 	 		 }
 5556              		.loc 1 1170 0
 5557 2f70 0130A0E3 		mov	r3, #1
 5558 2f74 28A0D7E5 		ldrb	r10, [r7, #40]	@ zero_extendqisi2
 5559 2f78 CD30C7E5 		strb	r3, [r7, #205]
 5560              	.LVL673:
 5561 2f7c 0040A0E1 		mov	r4, r0
 5562              	.LVL674:
1169:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5563              		.loc 1 1169 0
 5564 2f80 2900C7E5 		strb	r0, [r7, #41]
1174:../uvc.c      **** 		 	 	 case Ext1GammaCorCtlID14:
 5565              		.loc 1 1174 0
 5566 2f84 37FAFFEA 		b	.L316
 5567              	.LVL675:
 5568              	.L323:
1044:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5569              		.loc 1 1044 0
 5570 2f88 FEFFFFEB 		bl	SensorGetControl
 5571              	.LVL676:
1047:../uvc.c      **** 		 	 		 }
 5572              		.loc 1 1047 0
 5573 2f8c 0120A0E3 		mov	r2, #1
 5574 2f90 BB20C7E5 		strb	r2, [r7, #187]
1045:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 5575              		.loc 1 1045 0
 5576 2f94 4105C4E5 		strb	r0, [r4, #1345]
1046:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5577              		.loc 1 1046 0
 5578 2f98 4235D4E5 		ldrb	r3, [r4, #1346]	@ zero_extendqisi2
1047:../uvc.c      **** 		 	 		 }
 5579              		.loc 1 1047 0
 5580 2f9c 00A0A0E1 		mov	r10, r0
 5581              	.LVL677:
1046:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5582              		.loc 1 1046 0
 5583 2fa0 FF3003E2 		and	r3, r3, #255
1047:../uvc.c      **** 		 	 		 }
 5584              		.loc 1 1047 0
 5585 2fa4 0340A0E1 		mov	r4, r3
 5586              	.LVL678:
1046:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 5587              		.loc 1 1046 0
 5588 2fa8 2930C7E5 		strb	r3, [r7, #41]
1044:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 5589              		.loc 1 1044 0
 5590 2fac 2800C7E5 		strb	r0, [r7, #40]
1051:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 5591              		.loc 1 1051 0
 5592 2fb0 2CFAFFEA 		b	.L316
 5593              	.LVL679:
 5594              	.L469:
1056:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 5595              		.loc 1 1056 0
 5596 2fb4 02005AE3 		cmp	r10, #2
 5597 2fb8 1200008A 		bhi	.L473
 5598              	.LVL680:
 5599              	.L326:
1061:../uvc.c      **** 					 }
 5600              		.loc 1 1061 0
 5601 2fbc 04A08AE2 		add	r10, r10, #4
 5602              	.LVL681:
 5603 2fc0 FFA00AE2 		and	r10, r10, #255
 5604              	.LVL682:
 5605 2fc4 80FAFFEA 		b	.L349
 5606              	.LVL683:
 5607              	.L470:
1578:../uvc.c      **** 								 }
 5608              		.loc 1 1578 0
 5609 2fc8 18209DE5 		ldr	r2, [sp, #24]
 5610 2fcc 0010A0E3 		mov	r1, #0
 5611 2fd0 00208DE5 		str	r2, [sp]
 5612 2fd4 04108DE5 		str	r1, [sp, #4]
 5613 2fd8 0A20A0E1 		mov	r2, r10
 5614 2fdc 0830A0E1 		mov	r3, r8
 5615 2fe0 1910A0E3 		mov	r1, #25
 5616 2fe4 4C0C1FE5 		ldr	r0, .L474+80
 5617 2fe8 FEFFFFEB 		bl	cmdSet
 5618              	.LVL684:
 5619 2fec 4CFCFFEA 		b	.L407
 5620              	.LVL685:
 5621              	.L441:
1934:../uvc.c      **** 									Data0 = 4; //set to default.
 5622              		.loc 1 1934 0
 5623 2ff0 0400A0E3 		mov	r0, #4
 5624              	.LVL686:
 5625 2ff4 581C1FE5 		ldr	r1, .L474+84
 5626 2ff8 0B30A0E1 		mov	r3, fp
 5627 2ffc FEFFFFEB 		bl	CyU3PDebugPrint
 5628              	.LVL687:
1935:../uvc.c      **** 					 			 }
 5629              		.loc 1 1935 0
 5630 3000 0480A0E3 		mov	r8, #4
 5631 3004 2FFDFFEA 		b	.L440
 5632              	.LVL688:
 5633              	.L473:
1057:../uvc.c      **** 							sendData = 0; //set back to default
 5634              		.loc 1 1057 0
 5635 3008 0A30A0E1 		mov	r3, r10
 5636 300c 0400A0E3 		mov	r0, #4
 5637              	.LVL689:
 5638 3010 741C1FE5 		ldr	r1, .L474+84
 5639 3014 FEFFFFEB 		bl	CyU3PDebugPrint
 5640              	.LVL690:
1059:../uvc.c      **** 						}
 5641              		.loc 1 1059 0
 5642 3018 0030A0E3 		mov	r3, #0
1058:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 5643              		.loc 1 1058 0
 5644 301c 03A0A0E1 		mov	r10, r3
1059:../uvc.c      **** 						}
 5645              		.loc 1 1059 0
 5646 3020 9934C4E5 		strb	r3, [r4, #1177]
 5647 3024 E4FFFFEA 		b	.L326
 5648              		.cfi_endproc
 5649              	.LFE3:
 5651              		.align	2
 5652              		.global	CTControlHandle
 5654              	CTControlHandle:
 5655              	.LFB4:
2010:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 5656              		.loc 1 2010 0
 5657              		.cfi_startproc
 5658              		@ args = 0, pretend = 0, frame = 24
 5659              		@ frame_needed = 0, uses_anonymous_args = 0
 5660              	.LVL691:
 5661 3028 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5662              	.LCFI19:
 5663              		.cfi_def_cfa_offset 36
 5664              		.cfi_offset 4, -36
 5665              		.cfi_offset 5, -32
 5666              		.cfi_offset 6, -28
 5667              		.cfi_offset 7, -24
 5668              		.cfi_offset 8, -20
 5669              		.cfi_offset 9, -16
 5670              		.cfi_offset 10, -12
 5671              		.cfi_offset 11, -8
 5672              		.cfi_offset 14, -4
2029:../uvc.c      **** 
 5673              		.loc 1 2029 0
 5674 302c 28B89FE5 		ldr	fp, .L514
2021:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5675              		.loc 1 2021 0
 5676 3030 28389FE5 		ldr	r3, .L514+4
2029:../uvc.c      **** 
 5677              		.loc 1 2029 0
 5678 3034 0050DBE5 		ldrb	r5, [fp]	@ zero_extendqisi2
2021:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5679              		.loc 1 2021 0
 5680 3038 8080A0E1 		mov	r8, r0, asl #1
 5681 303c 002088E0 		add	r2, r8, r0
 5682 3040 822183E0 		add	r2, r3, r2, asl #3
2031:../uvc.c      **** 		 {
 5683              		.loc 1 2031 0
 5684 3044 830055E3 		cmp	r5, #131
2010:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 5685              		.loc 1 2010 0
 5686 3048 34D04DE2 		sub	sp, sp, #52
 5687              	.LCFI20:
 5688              		.cfi_def_cfa_offset 88
2010:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 5689              		.loc 1 2010 0
 5690 304c 0060A0E1 		mov	r6, r0
2021:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5691              		.loc 1 2021 0
 5692 3050 3796D2E5 		ldrb	r9, [r2, #1591]	@ zero_extendqisi2
 5693              	.LVL692:
2022:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5694              		.loc 1 2022 0
 5695 3054 28A6D2E5 		ldrb	r10, [r2, #1576]	@ zero_extendqisi2
 5696              	.LVL693:
2024:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5697              		.loc 1 2024 0
 5698 3058 2A76D2E5 		ldrb	r7, [r2, #1578]	@ zero_extendqisi2
 5699              	.LVL694:
2031:../uvc.c      **** 		 {
 5700              		.loc 1 2031 0
 5701 305c 8000000A 		beq	.L478
 5702 3060 2600009A 		bls	.L512
 5703 3064 850055E3 		cmp	r5, #133
 5704 3068 7200000A 		beq	.L483
 5705 306c 5000003A 		bcc	.L484
 5706 3070 860055E3 		cmp	r5, #134
 5707 3074 4300000A 		beq	.L485
 5708 3078 870055E3 		cmp	r5, #135
 5709 307c 5F00001A 		bne	.L477
2093:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5710              		.loc 1 2093 0
 5711 3080 33C6D2E5 		ldrb	ip, [r2, #1587]	@ zero_extendqisi2
 5712 3084 D8479FE5 		ldr	r4, .L514+8
2094:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5713              		.loc 1 2094 0
 5714 3088 3426D2E5 		ldrb	r2, [r2, #1588]	@ zero_extendqisi2
 5715              	.LVL695:
 5716              	.L511:
2071:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 5717              		.loc 1 2071 0
 5718 308c 0A1056E2 		subs	r1, r6, #10
 5719 3090 006071E2 		rsbs	r6, r1, #0
 5720 3094 0160B6E0 		adcs	r6, r6, r1
2073:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5721              		.loc 1 2073 0
 5722 3098 0030A0E3 		mov	r3, #0
 5723              	.LVL696:
2074:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5724              		.loc 1 2074 0
 5725 309c 281084E2 		add	r1, r4, #40
 5726 30a0 0700A0E1 		mov	r0, r7
 5727              	.LVL697:
2071:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 5728              		.loc 1 2071 0
 5729 30a4 2A60C4E5 		strb	r6, [r4, #42]
2069:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5730              		.loc 1 2069 0
 5731 30a8 28C0C4E5 		strb	ip, [r4, #40]
2070:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5732              		.loc 1 2070 0
 5733 30ac 2920C4E5 		strb	r2, [r4, #41]
2073:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5734              		.loc 1 2073 0
 5735 30b0 2B30C4E5 		strb	r3, [r4, #43]
2074:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5736              		.loc 1 2074 0
 5737 30b4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5738              	.LVL698:
 5739 30b8 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
2076:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 5740              		.loc 1 2076 0
 5741 30bc FF80A0E3 		mov	r8, #255
 5742 30c0 0860A0E1 		mov	r6, r8
 5743              	.LVL699:
 5744              	.L487:
2244:../uvc.c      **** }
 5745              		.loc 1 2244 0
 5746 30c4 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 5747 30c8 FFC0A0E3 		mov	ip, #255
 5748 30cc 04108DE5 		str	r1, [sp, #4]
 5749 30d0 10108DE5 		str	r1, [sp, #16]
 5750 30d4 08008DE5 		str	r0, [sp, #8]
 5751 30d8 00808DE5 		str	r8, [sp]
 5752 30dc 14708DE5 		str	r7, [sp, #20]
 5753 30e0 0520A0E1 		mov	r2, r5
 5754 30e4 0630A0E1 		mov	r3, r6
 5755 30e8 0CC08DE5 		str	ip, [sp, #12]
 5756 30ec 74179FE5 		ldr	r1, .L514+12
 5757 30f0 0400A0E3 		mov	r0, #4
 5758 30f4 FEFFFFEB 		bl	CyU3PDebugPrint
 5759              	.LVL700:
2245:../uvc.c      **** 
 5760              		.loc 1 2245 0
 5761 30f8 34D08DE2 		add	sp, sp, #52
 5762              		@ sp needed
 5763 30fc F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 5764              	.LVL701:
 5765              	.L512:
2031:../uvc.c      **** 		 {
 5766              		.loc 1 2031 0
 5767 3100 810055E3 		cmp	r5, #129
 5768 3104 2E00000A 		beq	.L480
 5769 3108 1A00008A 		bhi	.L481
 5770 310c 010055E3 		cmp	r5, #1
 5771 3110 3A00001A 		bne	.L477
2102:../uvc.c      **** 			  glEp0Buffer, &readCount);
 5772              		.loc 1 2102 0
 5773 3114 48479FE5 		ldr	r4, .L514+8
 5774 3118 2E208DE2 		add	r2, sp, #46
 5775              	.LVL702:
 5776 311c 2000A0E3 		mov	r0, #32
 5777              	.LVL703:
 5778 3120 281084E2 		add	r1, r4, #40
 5779 3124 18308DE5 		str	r3, [sp, #24]
 5780 3128 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5781              	.LVL704:
2104:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 5782              		.loc 1 2104 0
 5783 312c 28C0D4E5 		ldrb	ip, [r4, #40]	@ zero_extendqisi2
2108:../uvc.c      **** 			  {
 5784              		.loc 1 2108 0
 5785 3130 012046E2 		sub	r2, r6, #1
2104:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 5786              		.loc 1 2104 0
 5787 3134 1CC08DE5 		str	ip, [sp, #28]
 5788              	.LVL705:
2105:../uvc.c      **** 			  value = Data1;
 5789              		.loc 1 2105 0
 5790 3138 29C0D4E5 		ldrb	ip, [r4, #41]	@ zero_extendqisi2
2108:../uvc.c      **** 			  {
 5791              		.loc 1 2108 0
 5792 313c 18309DE5 		ldr	r3, [sp, #24]
2105:../uvc.c      **** 			  value = Data1;
 5793              		.loc 1 2105 0
 5794 3140 20C08DE5 		str	ip, [sp, #32]
 5795              	.LVL706:
2108:../uvc.c      **** 			  {
 5796              		.loc 1 2108 0
 5797 3144 090052E3 		cmp	r2, #9
 5798 3148 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 5799 314c 1D0100EA 		b	.L488
 5800              	.L490:
 5801 3150 80350000 		.word	.L489
 5802 3154 C8350000 		.word	.L488
 5803 3158 80330000 		.word	.L491
 5804 315c C8350000 		.word	.L488
 5805 3160 C8350000 		.word	.L488
 5806 3164 C8350000 		.word	.L488
 5807 3168 F0320000 		.word	.L492
 5808 316c C8350000 		.word	.L488
 5809 3170 C8350000 		.word	.L488
 5810 3174 74320000 		.word	.L493
 5811              	.LVL707:
 5812              	.L481:
2060:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 5813              		.loc 1 2060 0
 5814 3178 2BC6D2E5 		ldrb	ip, [r2, #1579]	@ zero_extendqisi2
 5815 317c E0469FE5 		ldr	r4, .L514+8
2061:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 5816              		.loc 1 2061 0
 5817 3180 2C26D2E5 		ldrb	r2, [r2, #1580]	@ zero_extendqisi2
 5818              	.LVL708:
 5819 3184 C0FFFFEA 		b	.L511
 5820              	.LVL709:
 5821              	.L485:
2087:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5822              		.loc 1 2087 0
 5823 3188 D4469FE5 		ldr	r4, .L514+8
 5824 318c 3136D2E5 		ldrb	r3, [r2, #1585]	@ zero_extendqisi2
 5825 3190 0410A0E1 		mov	r1, r4
 5826 3194 2830E1E5 		strb	r3, [r1, #40]!
2088:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5827              		.loc 1 2088 0
 5828 3198 0100A0E3 		mov	r0, #1
 5829              	.LVL710:
2091:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 5830              		.loc 1 2091 0
 5831 319c FF80A0E3 		mov	r8, #255
2088:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5832              		.loc 1 2088 0
 5833 31a0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5834              	.LVL711:
2091:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 5835              		.loc 1 2091 0
 5836 31a4 0860A0E1 		mov	r6, r8
 5837 31a8 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
 5838 31ac 0170A0E3 		mov	r7, #1
 5839 31b0 C3FFFFEA 		b	.L487
 5840              	.LVL712:
 5841              	.L484:
2078:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 5842              		.loc 1 2078 0
 5843 31b4 2FC6D2E5 		ldrb	ip, [r2, #1583]	@ zero_extendqisi2
 5844 31b8 A4469FE5 		ldr	r4, .L514+8
2079:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5845              		.loc 1 2079 0
 5846 31bc 3026D2E5 		ldrb	r2, [r2, #1584]	@ zero_extendqisi2
 5847              	.LVL713:
 5848 31c0 B1FFFFEA 		b	.L511
 5849              	.LVL714:
 5850              	.L480:
2045:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 5851              		.loc 1 2045 0
 5852 31c4 98469FE5 		ldr	r4, .L514+8
 5853 31c8 3596D2E5 		ldrb	r9, [r2, #1589]	@ zero_extendqisi2
2046:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 5854              		.loc 1 2046 0
 5855 31cc 36C6D2E5 		ldrb	ip, [r2, #1590]	@ zero_extendqisi2
2047:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 5856              		.loc 1 2047 0
 5857 31d0 0030A0E3 		mov	r3, #0
2053:../uvc.c      **** 
 5858              		.loc 1 2053 0
 5859 31d4 281084E2 		add	r1, r4, #40
 5860 31d8 0700A0E1 		mov	r0, r7
 5861              	.LVL715:
2058:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 5862              		.loc 1 2058 0
 5863 31dc FF80A0E3 		mov	r8, #255
2046:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 5864              		.loc 1 2046 0
 5865 31e0 29C0C4E5 		strb	ip, [r4, #41]
2045:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 5866              		.loc 1 2045 0
 5867 31e4 2890C4E5 		strb	r9, [r4, #40]
2047:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 5868              		.loc 1 2047 0
 5869 31e8 2A30C4E5 		strb	r3, [r4, #42]
2048:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 5870              		.loc 1 2048 0
 5871 31ec 2B30C4E5 		strb	r3, [r4, #43]
 5872              	.LVL716:
2058:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 5873              		.loc 1 2058 0
 5874 31f0 0860A0E1 		mov	r6, r8
 5875              	.LVL717:
2053:../uvc.c      **** 
 5876              		.loc 1 2053 0
 5877 31f4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5878              	.LVL718:
 5879 31f8 0900A0E1 		mov	r0, r9
2058:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 5880              		.loc 1 2058 0
 5881 31fc B0FFFFEA 		b	.L487
 5882              	.LVL719:
 5883              	.L477:
2238:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 5884              		.loc 1 2238 0
 5885 3200 0000A0E3 		mov	r0, #0
 5886              	.LVL720:
 5887 3204 0020A0E1 		mov	r2, r0
 5888              	.LVL721:
 5889 3208 0110A0E3 		mov	r1, #1
 5890 320c FEFFFFEB 		bl	CyU3PUsbStall
 5891              	.LVL722:
2239:../uvc.c      **** 			  break;
 5892              		.loc 1 2239 0
 5893 3210 0620A0E1 		mov	r2, r6
 5894 3214 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 5895 3218 0400A0E3 		mov	r0, #4
 5896 321c 48169FE5 		ldr	r1, .L514+16
 5897 3220 FEFFFFEB 		bl	CyU3PDebugPrint
 5898              	.LVL723:
2240:../uvc.c      **** 		 }
 5899              		.loc 1 2240 0
 5900 3224 FF00A0E3 		mov	r0, #255
 5901 3228 34469FE5 		ldr	r4, .L514+8
 5902 322c 0080A0E1 		mov	r8, r0
 5903 3230 0060A0E1 		mov	r6, r0
 5904 3234 A2FFFFEA 		b	.L487
 5905              	.LVL724:
 5906              	.L483:
2035:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 5907              		.loc 1 2035 0
 5908 3238 24469FE5 		ldr	r4, .L514+8
2036:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5909              		.loc 1 2036 0
 5910 323c 0030A0E3 		mov	r3, #0
2037:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5911              		.loc 1 2037 0
 5912 3240 281084E2 		add	r1, r4, #40
 5913 3244 0200A0E3 		mov	r0, #2
 5914              	.LVL725:
2039:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5915              		.loc 1 2039 0
 5916 3248 FF80A0E3 		mov	r8, #255
2035:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 5917              		.loc 1 2035 0
 5918 324c 2870C4E5 		strb	r7, [r4, #40]
2036:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5919              		.loc 1 2036 0
 5920 3250 2930C4E5 		strb	r3, [r4, #41]
2039:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5921              		.loc 1 2039 0
 5922 3254 0860A0E1 		mov	r6, r8
 5923              	.LVL726:
2037:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5924              		.loc 1 2037 0
 5925 3258 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5926              	.LVL727:
 5927 325c 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
2039:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5928              		.loc 1 2039 0
 5929 3260 97FFFFEA 		b	.L487
 5930              	.LVL728:
 5931              	.L478:
2069:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5932              		.loc 1 2069 0
 5933 3264 2DC6D2E5 		ldrb	ip, [r2, #1581]	@ zero_extendqisi2
 5934 3268 F4459FE5 		ldr	r4, .L514+8
2070:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5935              		.loc 1 2070 0
 5936 326c 2E26D2E5 		ldrb	r2, [r2, #1582]	@ zero_extendqisi2
 5937              	.LVL729:
 5938 3270 85FFFFEA 		b	.L511
 5939              	.LVL730:
 5940              	.L493:
2217:../uvc.c      **** 					  if(getData == 1)
 5941              		.loc 1 2217 0
 5942 3274 F4659FE5 		ldr	r6, .L514+20
 5943 3278 0010E0E3 		mvn	r1, #0
 5944 327c 1C0096E5 		ldr	r0, [r6, #28]
 5945 3280 FEFFFFEB 		bl	_txe_mutex_get
 5946              	.LVL731:
2218:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5947              		.loc 1 2218 0
 5948 3284 1CC09DE5 		ldr	ip, [sp, #28]
 5949 3288 01005CE3 		cmp	ip, #1
2219:../uvc.c      **** 					  else if(getData == 0xff)
 5950              		.loc 1 2219 0
 5951 328c 0400A003 		moveq	r0, #4
2218:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5952              		.loc 1 2218 0
 5953 3290 6901000A 		beq	.L510
2220:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 5954              		.loc 1 2220 0
 5955 3294 FF005CE3 		cmp	ip, #255
 5956 3298 6601000A 		beq	.L513
2223:../uvc.c      **** 					  //dataIdx++;
 5957              		.loc 1 2223 0
 5958 329c 0010A0E3 		mov	r1, #0
 5959 32a0 00108DE5 		str	r1, [sp]
 5960 32a4 04108DE5 		str	r1, [sp, #4]
 5961 32a8 0A20A0E1 		mov	r2, r10
 5962 32ac 0930A0E1 		mov	r3, r9
 5963 32b0 0600A0E1 		mov	r0, r6
 5964 32b4 2310A0E3 		mov	r1, #35
 5965 32b8 FEFFFFEB 		bl	cmdSet
 5966              	.LVL732:
 5967              	.L505:
2226:../uvc.c      **** #endif
 5968              		.loc 1 2226 0
 5969 32bc 1C0096E5 		ldr	r0, [r6, #28]
 5970 32c0 FEFFFFEB 		bl	_txe_mutex_put
 5971              	.LVL733:
2228:../uvc.c      **** 					  break;
 5972              		.loc 1 2228 0
 5973 32c4 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 5974 32c8 1C609DE5 		ldr	r6, [sp, #28]
 5975 32cc 20809DE5 		ldr	r8, [sp, #32]
 5976 32d0 00108DE5 		str	r1, [sp]
 5977 32d4 0620A0E1 		mov	r2, r6
 5978 32d8 0830A0E1 		mov	r3, r8
 5979 32dc 0400A0E3 		mov	r0, #4
 5980 32e0 8C159FE5 		ldr	r1, .L514+24
 5981 32e4 FEFFFFEB 		bl	CyU3PDebugPrint
 5982              	.LVL734:
2229:../uvc.c      **** 
 5983              		.loc 1 2229 0
 5984 32e8 FF00A0E3 		mov	r0, #255
 5985 32ec 74FFFFEA 		b	.L487
 5986              	.LVL735:
 5987              	.L492:
2194:../uvc.c      **** 					  {
 5988              		.loc 1 2194 0
 5989 32f0 4D06D3E5 		ldrb	r0, [r3, #1613]	@ zero_extendqisi2
 5990 32f4 64C59FE5 		ldr	ip, .L514+4
 5991 32f8 010050E3 		cmp	r0, #1
 5992 32fc 08005013 		cmpne	r0, #8
 5993 3300 0000A013 		movne	r0, #0
 5994 3304 0100A003 		moveq	r0, #1
 5995 3308 4601001A 		bne	.L502
 5996              	.LVL736:
2197:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 5997              		.loc 1 2197 0
 5998 330c 5CB59FE5 		ldr	fp, .L514+20
 5999 3310 0010E0E3 		mvn	r1, #0
 6000 3314 1C009BE5 		ldr	r0, [fp, #28]
 6001 3318 18C08DE5 		str	ip, [sp, #24]
 6002 331c FEFFFFEB 		bl	_txe_mutex_get
 6003              	.LVL737:
2198:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6004              		.loc 1 2198 0
 6005 3320 1C009DE5 		ldr	r0, [sp, #28]
 6006 3324 0010A0E3 		mov	r1, #0
 6007 3328 0A20A0E1 		mov	r2, r10
 6008 332c 0930A0E1 		mov	r3, r9
 6009 3330 00008DE5 		str	r0, [sp]
 6010 3334 04108DE5 		str	r1, [sp, #4]
 6011 3338 0B00A0E1 		mov	r0, fp
 6012 333c 2210A0E3 		mov	r1, #34
 6013 3340 FEFFFFEB 		bl	cmdSet
 6014              	.LVL738:
2199:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 6015              		.loc 1 2199 0
 6016 3344 1C009BE5 		ldr	r0, [fp, #28]
 6017 3348 FEFFFFEB 		bl	_txe_mutex_put
 6018              	.LVL739:
2202:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 6019              		.loc 1 2202 0
 6020 334c 18C09DE5 		ldr	ip, [sp, #24]
 6021 3350 1C109DE5 		ldr	r1, [sp, #28]
2203:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 6022              		.loc 1 2203 0
 6023 3354 20209DE5 		ldr	r2, [sp, #32]
2202:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 6024              		.loc 1 2202 0
 6025 3358 066088E0 		add	r6, r8, r6
 6026 335c 86C18CE0 		add	ip, ip, r6, asl #3
2204:../uvc.c      **** 					  }else{
 6027              		.loc 1 2204 0
 6028 3360 0130A0E3 		mov	r3, #1
2202:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 6029              		.loc 1 2202 0
 6030 3364 3516CCE5 		strb	r1, [ip, #1589]
2203:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 6031              		.loc 1 2203 0
 6032 3368 3626CCE5 		strb	r2, [ip, #1590]
2204:../uvc.c      **** 					  }else{
 6033              		.loc 1 2204 0
 6034 336c 3836CCE5 		strb	r3, [ip, #1592]
 6035              	.LVL740:
 6036              	.L503:
 6037 3370 2860D4E5 		ldrb	r6, [r4, #40]	@ zero_extendqisi2
 6038 3374 2980D4E5 		ldrb	r8, [r4, #41]	@ zero_extendqisi2
2211:../uvc.c      **** 			  	  case ZmOpRCtlID10:
 6039              		.loc 1 2211 0
 6040 3378 FF00A0E3 		mov	r0, #255
 6041 337c 50FFFFEA 		b	.L487
 6042              	.LVL741:
 6043              	.L491:
2160:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 6044              		.loc 1 2160 0
 6045 3380 4D36D3E5 		ldrb	r3, [r3, #1613]	@ zero_extendqisi2
 6046 3384 010053E3 		cmp	r3, #1
 6047 3388 04005313 		cmpne	r3, #4
 6048 338c 2001001A 		bne	.L500
2159:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 6049              		.loc 1 2159 0
 6050 3390 1CC09DE5 		ldr	ip, [sp, #28]
 6051 3394 20009DE5 		ldr	r0, [sp, #32]
 6052 3398 00348CE1 		orr	r3, ip, r0, asl #8
2161:../uvc.c      **** 					  {
 6053              		.loc 1 2161 0
 6054 339c F90053E3 		cmp	r3, #249
 6055 33a0 1B01008A 		bhi	.L500
 6056              	.LVL742:
2166:../uvc.c      **** 							}else{
 6057              		.loc 1 2166 0
 6058 33a4 C80043E2 		sub	r0, r3, #200
 6059 33a8 C80053E3 		cmp	r3, #200
2168:../uvc.c      **** 							}
 6060              		.loc 1 2168 0
 6061 33ac C82063E2 		rsb	r2, r3, #200
 6062 33b0 C0149FE5 		ldr	r1, .L514+28
 6063 33b4 0208A091 		movls	r0, r2, asl #16
 6064 33b8 0008A081 		movhi	r0, r0, asl #16
 6065 33bc 642063E2 		rsb	r2, r3, #100
 6066 33c0 640053E3 		cmp	r3, #100
2166:../uvc.c      **** 							}else{
 6067              		.loc 1 2166 0
 6068 33c4 64C043E2 		sub	ip, r3, #100
 6069 33c8 2008A0E1 		mov	r0, r0, lsr #16
 6070 33cc 0C28A081 		movhi	r2, ip, asl #16
 6071 33d0 0228A091 		movls	r2, r2, asl #16
 6072 33d4 010050E1 		cmp	r0, r1
 6073 33d8 00E0A031 		movcc	lr, r0
 6074 33dc 01E0A021 		movcs	lr, r1
 6075 33e0 010050E1 		cmp	r0, r1
 6076 33e4 27C043E2 		sub	ip, r3, #39
2168:../uvc.c      **** 							}
 6077              		.loc 1 2168 0
 6078 33e8 271063E2 		rsb	r1, r3, #39
 6079 33ec 00B0A033 		movcc	fp, #0
 6080 33f0 01B0A023 		movcs	fp, #1
 6081 33f4 270053E3 		cmp	r3, #39
2166:../uvc.c      **** 							}else{
 6082              		.loc 1 2166 0
 6083 33f8 140043E2 		sub	r0, r3, #20
 6084 33fc 01C8A091 		movls	ip, r1, asl #16
 6085 3400 2228A0E1 		mov	r2, r2, lsr #16
2168:../uvc.c      **** 							}
 6086              		.loc 1 2168 0
 6087 3404 141063E2 		rsb	r1, r3, #20
 6088 3408 0CC8A081 		movhi	ip, ip, asl #16
 6089 340c 140053E3 		cmp	r3, #20
 6090 3410 0018A081 		movhi	r1, r0, asl #16
 6091 3414 0118A091 		movls	r1, r1, asl #16
 6092 3418 0E0052E1 		cmp	r2, lr
2166:../uvc.c      **** 							}else{
 6093              		.loc 1 2166 0
 6094 341c 0A0043E2 		sub	r0, r3, #10
 6095 3420 01B0A033 		movcc	fp, #1
 6096 3424 2CC8A0E1 		mov	ip, ip, lsr #16
 6097 3428 02005EE1 		cmp	lr, r2
 6098 342c 0E20A031 		movcc	r2, lr
 6099 3430 0A0053E3 		cmp	r3, #10
 6100 3434 21E8A0E1 		mov	lr, r1, lsr #16
2168:../uvc.c      **** 							}
 6101              		.loc 1 2168 0
 6102 3438 0A1063E2 		rsb	r1, r3, #10
 6103 343c 0118A091 		movls	r1, r1, asl #16
 6104 3440 0018A081 		movhi	r1, r0, asl #16
 6105 3444 0C0052E1 		cmp	r2, ip
 6106 3448 02B0A083 		movhi	fp, #2
 6107 344c 24B08DE5 		str	fp, [sp, #36]
2166:../uvc.c      **** 							}else{
 6108              		.loc 1 2166 0
 6109 3450 050043E2 		sub	r0, r3, #5
 6110 3454 02005CE1 		cmp	ip, r2
 6111 3458 0C20A031 		movcc	r2, ip
 6112 345c 21B8A0E1 		mov	fp, r1, lsr #16
2168:../uvc.c      **** 							}
 6113              		.loc 1 2168 0
 6114 3460 05C063E2 		rsb	ip, r3, #5
 6115 3464 050053E3 		cmp	r3, #5
 6116 3468 24109DE5 		ldr	r1, [sp, #36]
 6117 346c 00C8A081 		movhi	ip, r0, asl #16
 6118 3470 0CC8A091 		movls	ip, ip, asl #16
 6119 3474 0E0052E1 		cmp	r2, lr
 6120 3478 0310A083 		movhi	r1, #3
 6121 347c 24108DE5 		str	r1, [sp, #36]
 6122 3480 02005EE1 		cmp	lr, r2
 6123 3484 0E00A031 		movcc	r0, lr
 6124 3488 0200A021 		movcs	r0, r2
 6125 348c 021063E2 		rsb	r1, r3, #2
2166:../uvc.c      **** 							}else{
 6126              		.loc 1 2166 0
 6127 3490 022043E2 		sub	r2, r3, #2
 6128 3494 020053E3 		cmp	r3, #2
 6129 3498 0128A091 		movls	r2, r1, asl #16
 6130 349c 0228A081 		movhi	r2, r2, asl #16
 6131 34a0 0B0050E1 		cmp	r0, fp
 6132 34a4 24E09DE5 		ldr	lr, [sp, #36]
 6133 34a8 2CC8A0E1 		mov	ip, ip, lsr #16
 6134 34ac 04E0A083 		movhi	lr, #4
 6135 34b0 00005BE1 		cmp	fp, r0
 6136 34b4 0B00A031 		movcc	r0, fp
 6137 34b8 00005CE1 		cmp	ip, r0
 6138 34bc 0C10A031 		movcc	r1, ip
 6139 34c0 0010A021 		movcs	r1, r0
 6140 34c4 0C0050E1 		cmp	r0, ip
 6141 34c8 05E0A083 		movhi	lr, #5
 6142 34cc 01C043E2 		sub	ip, r3, #1
 6143 34d0 010053E3 		cmp	r3, #1
2168:../uvc.c      **** 							}
 6144              		.loc 1 2168 0
 6145 34d4 010063E2 		rsb	r0, r3, #1
 6146 34d8 0C38A081 		movhi	r3, ip, asl #16
2178:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 6147              		.loc 1 2178 0
 6148 34dc 8CC39FE5 		ldr	ip, .L514+20
 6149 34e0 2228A0E1 		mov	r2, r2, lsr #16
 6150 34e4 0038A091 		movls	r3, r0, asl #16
 6151 34e8 010052E1 		cmp	r2, r1
 6152 34ec 0200A031 		movcc	r0, r2
 6153 34f0 0100A021 		movcs	r0, r1
 6154 34f4 020051E1 		cmp	r1, r2
 6155 34f8 0E20A091 		movls	r2, lr
 6156 34fc 0620A083 		movhi	r2, #6
 6157              	.LVL743:
 6158 3500 0010E0E3 		mvn	r1, #0
 6159              	.LVL744:
 6160 3504 230850E1 		cmp	r0, r3, lsr #16
 6161 3508 1C009CE5 		ldr	r0, [ip, #28]
 6162 350c 02B0A091 		movls	fp, r2
 6163 3510 07B0A083 		movhi	fp, #7
 6164              	.LVL745:
 6165 3514 18C08DE5 		str	ip, [sp, #24]
 6166 3518 FEFFFFEB 		bl	_txe_mutex_get
 6167              	.LVL746:
2179:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6168              		.loc 1 2179 0
 6169 351c 18C09DE5 		ldr	ip, [sp, #24]
2175:../uvc.c      **** 
 6170              		.loc 1 2175 0
 6171 3520 01B08BE2 		add	fp, fp, #1
 6172              	.LVL747:
2179:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6173              		.loc 1 2179 0
 6174 3524 0010A0E3 		mov	r1, #0
 6175 3528 0A20A0E1 		mov	r2, r10
 6176 352c 0930A0E1 		mov	r3, r9
 6177 3530 0C00A0E1 		mov	r0, ip
 6178 3534 04108DE5 		str	r1, [sp, #4]
 6179 3538 00B08DE5 		str	fp, [sp]
 6180 353c 0310A0E3 		mov	r1, #3
 6181 3540 FEFFFFEB 		bl	cmdSet
 6182              	.LVL748:
2180:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 6183              		.loc 1 2180 0
 6184 3544 18C09DE5 		ldr	ip, [sp, #24]
 6185 3548 1C009CE5 		ldr	r0, [ip, #28]
 6186 354c FEFFFFEB 		bl	_txe_mutex_put
 6187              	.LVL749:
2186:../uvc.c      **** 					  }else{
 6188              		.loc 1 2186 0
 6189 3550 08C39FE5 		ldr	ip, .L514+4
2183:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 6190              		.loc 1 2183 0
 6191 3554 04239FE5 		ldr	r2, .L514+4
2186:../uvc.c      **** 					  }else{
 6192              		.loc 1 2186 0
 6193 3558 79B3CCE5 		strb	fp, [ip, #889]
2183:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 6194              		.loc 1 2183 0
 6195 355c 1CC09DE5 		ldr	ip, [sp, #28]
 6196 3560 063088E0 		add	r3, r8, r6
 6197 3564 833182E0 		add	r3, r2, r3, asl #3
 6198 3568 35C6C3E5 		strb	ip, [r3, #1589]
2184:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 6199              		.loc 1 2184 0
 6200 356c 20C09DE5 		ldr	ip, [sp, #32]
2185:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 6201              		.loc 1 2185 0
 6202 3570 0120A0E3 		mov	r2, #1
2184:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 6203              		.loc 1 2184 0
 6204 3574 36C6C3E5 		strb	ip, [r3, #1590]
2185:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 6205              		.loc 1 2185 0
 6206 3578 3826C3E5 		strb	r2, [r3, #1592]
2186:../uvc.c      **** 					  }else{
 6207              		.loc 1 2186 0
 6208 357c 7BFFFFEA 		b	.L503
 6209              	.LVL750:
 6210              	.L489:
2117:../uvc.c      **** 						case 1:
 6211              		.loc 1 2117 0
 6212 3580 1CC09DE5 		ldr	ip, [sp, #28]
2113:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 6213              		.loc 1 2113 0
 6214 3584 066088E0 		add	r6, r8, r6
 6215 3588 866183E0 		add	r6, r3, r6, asl #3
2114:../uvc.c      **** 				    getData = glEp0Buffer[0];
 6216              		.loc 1 2114 0
 6217 358c 0110A0E3 		mov	r1, #1
2117:../uvc.c      **** 						case 1:
 6218              		.loc 1 2117 0
 6219 3590 01204CE2 		sub	r2, ip, #1
2113:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 6220              		.loc 1 2113 0
 6221 3594 35C6C6E5 		strb	ip, [r6, #1589]
2114:../uvc.c      **** 				    getData = glEp0Buffer[0];
 6222              		.loc 1 2114 0
 6223 3598 3816C6E5 		strb	r1, [r6, #1592]
 6224              	.LVL751:
2117:../uvc.c      **** 						case 1:
 6225              		.loc 1 2117 0
 6226 359c 070052E3 		cmp	r2, #7
 6227 35a0 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 6228 35a4 960000EA 		b	.L494
 6229              	.L496:
 6230 35a8 A0370000 		.word	.L495
 6231 35ac 04370000 		.word	.L497
 6232 35b0 04380000 		.word	.L494
 6233 35b4 9C360000 		.word	.L498
 6234 35b8 04380000 		.word	.L494
 6235 35bc 04380000 		.word	.L494
 6236 35c0 04380000 		.word	.L494
 6237 35c4 FC350000 		.word	.L499
 6238              	.LVL752:
 6239              	.L488:
2232:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6240              		.loc 1 2232 0
 6241 35c8 1CC09DE5 		ldr	ip, [sp, #28]
 6242 35cc 068088E0 		add	r8, r8, r6
 6243 35d0 888183E0 		add	r8, r3, r8, asl #3
2233:../uvc.c      **** 			  		 break;
 6244              		.loc 1 2233 0
 6245 35d4 0620A0E1 		mov	r2, r6
 6246 35d8 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 6247 35dc 0400A0E3 		mov	r0, #4
 6248 35e0 94129FE5 		ldr	r1, .L514+32
2232:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 6249              		.loc 1 2232 0
 6250 35e4 35C6C8E5 		strb	ip, [r8, #1589]
2233:../uvc.c      **** 			  		 break;
 6251              		.loc 1 2233 0
 6252 35e8 FEFFFFEB 		bl	CyU3PDebugPrint
 6253              	.LVL753:
2234:../uvc.c      **** 			  }
 6254              		.loc 1 2234 0
 6255 35ec FF00A0E3 		mov	r0, #255
 6256 35f0 0080A0E1 		mov	r8, r0
 6257 35f4 0060A0E1 		mov	r6, r0
 6258 35f8 B1FEFFEA 		b	.L487
 6259              	.LVL754:
 6260              	.L499:
2136:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 6261              		.loc 1 2136 0
 6262 35fc 6C629FE5 		ldr	r6, .L514+20
2134:../uvc.c      **** 			  		    	dataIdx = 0;
 6263              		.loc 1 2134 0
 6264 3600 0080A0E3 		mov	r8, #0
2136:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 6265              		.loc 1 2136 0
 6266 3604 1C0096E5 		ldr	r0, [r6, #28]
 6267 3608 0010E0E3 		mvn	r1, #0
2134:../uvc.c      **** 			  		    	dataIdx = 0;
 6268              		.loc 1 2134 0
 6269 360c 7983C3E5 		strb	r8, [r3, #889]
 6270              	.LVL755:
2136:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 6271              		.loc 1 2136 0
 6272 3610 FEFFFFEB 		bl	_txe_mutex_get
 6273              	.LVL756:
2137:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6274              		.loc 1 2137 0
 6275 3614 0A20A0E1 		mov	r2, r10
 6276 3618 0930A0E1 		mov	r3, r9
 6277 361c 1010A0E3 		mov	r1, #16
 6278 3620 00808DE5 		str	r8, [sp]
 6279 3624 04808DE5 		str	r8, [sp, #4]
 6280 3628 0600A0E1 		mov	r0, r6
 6281 362c FEFFFFEB 		bl	cmdSet
 6282              	.LVL757:
2138:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
 6283              		.loc 1 2138 0
 6284 3630 1C0096E5 		ldr	r0, [r6, #28]
 6285 3634 FEFFFFEB 		bl	_txe_mutex_put
 6286              	.LVL758:
 6287              	.LBB82:
 6288              	.LBB83:
 857:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 6289              		.loc 1 857 0
 6290 3638 1C0096E5 		ldr	r0, [r6, #28]
 6291 363c 0010E0E3 		mvn	r1, #0
 6292 3640 FEFFFFEB 		bl	_txe_mutex_get
 6293              	.LVL759:
 858:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 6294              		.loc 1 858 0
 6295 3644 0130A0E3 		mov	r3, #1
 6296 3648 04808DE5 		str	r8, [sp, #4]
 6297 364c 0600A0E1 		mov	r0, r6
 6298 3650 00308DE5 		str	r3, [sp]
 6299 3654 2010A0E3 		mov	r1, #32
 6300 3658 2720A0E3 		mov	r2, #39
 6301 365c 3030A0E3 		mov	r3, #48
 6302 3660 FEFFFFEB 		bl	cmdSet
 6303              	.LVL760:
 859:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6304              		.loc 1 859 0
 6305 3664 0230A0E3 		mov	r3, #2
 6306 3668 04808DE5 		str	r8, [sp, #4]
 6307 366c 0600A0E1 		mov	r0, r6
 6308 3670 00308DE5 		str	r3, [sp]
 6309 3674 2110A0E3 		mov	r1, #33
 6310 3678 2520A0E3 		mov	r2, #37
 6311 367c 3030A0E3 		mov	r3, #48
 6312 3680 FEFFFFEB 		bl	cmdSet
 6313              	.LVL761:
 860:../uvc.c      **** }
 6314              		.loc 1 860 0
 6315 3684 1C0096E5 		ldr	r0, [r6, #28]
 6316 3688 FEFFFFEB 		bl	_txe_mutex_put
 6317              	.LVL762:
 6318 368c FF00A0E3 		mov	r0, #255
 6319 3690 0080A0E1 		mov	r8, r0
 6320 3694 0860A0E3 		mov	r6, #8
 6321 3698 89FEFFEA 		b	.L487
 6322              	.LVL763:
 6323              	.L498:
 6324              	.LBE83:
 6325              	.LBE82:
 6326              	.LBB84:
 6327              	.LBB85:
 857:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 6328              		.loc 1 857 0
 6329 369c CC619FE5 		ldr	r6, .L514+20
 858:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 6330              		.loc 1 858 0
 6331 36a0 0080A0E3 		mov	r8, #0
 857:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 6332              		.loc 1 857 0
 6333 36a4 0010E0E3 		mvn	r1, #0
 6334 36a8 1C0096E5 		ldr	r0, [r6, #28]
 6335 36ac FEFFFFEB 		bl	_txe_mutex_get
 6336              	.LVL764:
 858:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 6337              		.loc 1 858 0
 6338 36b0 0600A0E1 		mov	r0, r6
 6339 36b4 00808DE5 		str	r8, [sp]
 6340 36b8 04808DE5 		str	r8, [sp, #4]
 6341 36bc 2010A0E3 		mov	r1, #32
 6342 36c0 2720A0E3 		mov	r2, #39
 6343 36c4 3030A0E3 		mov	r3, #48
 6344 36c8 FEFFFFEB 		bl	cmdSet
 6345              	.LVL765:
 859:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6346              		.loc 1 859 0
 6347 36cc 0130A0E3 		mov	r3, #1
 6348 36d0 04808DE5 		str	r8, [sp, #4]
 6349 36d4 0600A0E1 		mov	r0, r6
 6350 36d8 00308DE5 		str	r3, [sp]
 6351 36dc 2110A0E3 		mov	r1, #33
 6352 36e0 2520A0E3 		mov	r2, #37
 6353 36e4 3030A0E3 		mov	r3, #48
 6354 36e8 FEFFFFEB 		bl	cmdSet
 6355              	.LVL766:
 860:../uvc.c      **** }
 6356              		.loc 1 860 0
 6357 36ec 1C0096E5 		ldr	r0, [r6, #28]
 6358 36f0 FEFFFFEB 		bl	_txe_mutex_put
 6359              	.LVL767:
 6360 36f4 FF00A0E3 		mov	r0, #255
 6361 36f8 0080A0E1 		mov	r8, r0
 6362 36fc 0460A0E3 		mov	r6, #4
 6363 3700 6FFEFFEA 		b	.L487
 6364              	.LVL768:
 6365              	.L497:
 6366              	.LBE85:
 6367              	.LBE84:
2124:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 6368              		.loc 1 2124 0
 6369 3704 64619FE5 		ldr	r6, .L514+20
2122:../uvc.c      **** 							dataIdx = 0;
 6370              		.loc 1 2122 0
 6371 3708 0080A0E3 		mov	r8, #0
2124:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 6372              		.loc 1 2124 0
 6373 370c 1C0096E5 		ldr	r0, [r6, #28]
 6374 3710 0010E0E3 		mvn	r1, #0
2122:../uvc.c      **** 							dataIdx = 0;
 6375              		.loc 1 2122 0
 6376 3714 7983C3E5 		strb	r8, [r3, #889]
 6377              	.LVL769:
2124:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 6378              		.loc 1 2124 0
 6379 3718 FEFFFFEB 		bl	_txe_mutex_get
 6380              	.LVL770:
2125:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6381              		.loc 1 2125 0
 6382 371c 0A20A0E1 		mov	r2, r10
 6383 3720 0930A0E1 		mov	r3, r9
 6384 3724 1010A0E3 		mov	r1, #16
 6385 3728 00808DE5 		str	r8, [sp]
 6386 372c 04808DE5 		str	r8, [sp, #4]
 6387 3730 0600A0E1 		mov	r0, r6
 6388 3734 FEFFFFEB 		bl	cmdSet
 6389              	.LVL771:
2126:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
 6390              		.loc 1 2126 0
 6391 3738 1C0096E5 		ldr	r0, [r6, #28]
 6392 373c FEFFFFEB 		bl	_txe_mutex_put
 6393              	.LVL772:
 6394              	.LBB86:
 6395              	.LBB87:
 857:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 6396              		.loc 1 857 0
 6397 3740 1C0096E5 		ldr	r0, [r6, #28]
 6398 3744 0010E0E3 		mvn	r1, #0
 6399 3748 FEFFFFEB 		bl	_txe_mutex_get
 6400              	.LVL773:
 858:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 6401              		.loc 1 858 0
 6402 374c 00808DE5 		str	r8, [sp]
 6403 3750 04808DE5 		str	r8, [sp, #4]
 6404 3754 0600A0E1 		mov	r0, r6
 6405 3758 2010A0E3 		mov	r1, #32
 6406 375c 2720A0E3 		mov	r2, #39
 6407 3760 3030A0E3 		mov	r3, #48
 6408 3764 FEFFFFEB 		bl	cmdSet
 6409              	.LVL774:
 859:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6410              		.loc 1 859 0
 6411 3768 0130A0E3 		mov	r3, #1
 6412 376c 04808DE5 		str	r8, [sp, #4]
 6413 3770 0600A0E1 		mov	r0, r6
 6414 3774 00308DE5 		str	r3, [sp]
 6415 3778 2110A0E3 		mov	r1, #33
 6416 377c 2520A0E3 		mov	r2, #37
 6417 3780 3030A0E3 		mov	r3, #48
 6418 3784 FEFFFFEB 		bl	cmdSet
 6419              	.LVL775:
 860:../uvc.c      **** }
 6420              		.loc 1 860 0
 6421 3788 1C0096E5 		ldr	r0, [r6, #28]
 6422 378c FEFFFFEB 		bl	_txe_mutex_put
 6423              	.LVL776:
 6424 3790 FF00A0E3 		mov	r0, #255
 6425 3794 0080A0E1 		mov	r8, r0
 6426 3798 0260A0E3 		mov	r6, #2
 6427 379c 48FEFFEA 		b	.L487
 6428              	.LVL777:
 6429              	.L495:
 6430              	.LBE87:
 6431              	.LBE86:
 6432              	.LBB88:
 6433              	.LBB89:
 857:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 6434              		.loc 1 857 0
 6435 37a0 C8809FE5 		ldr	r8, .L514+20
 6436 37a4 0010E0E3 		mvn	r1, #0
 6437 37a8 1C0098E5 		ldr	r0, [r8, #28]
 6438 37ac FEFFFFEB 		bl	_txe_mutex_get
 6439              	.LVL778:
 858:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 6440              		.loc 1 858 0
 6441 37b0 0090A0E3 		mov	r9, #0
 6442              	.LVL779:
 6443 37b4 0160A0E3 		mov	r6, #1
 6444 37b8 0800A0E1 		mov	r0, r8
 6445 37bc 2010A0E3 		mov	r1, #32
 6446 37c0 2720A0E3 		mov	r2, #39
 6447 37c4 3030A0E3 		mov	r3, #48
 6448 37c8 40028DE8 		stmia	sp, {r6, r9}
 6449 37cc FEFFFFEB 		bl	cmdSet
 6450              	.LVL780:
 859:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6451              		.loc 1 859 0
 6452 37d0 0230A0E3 		mov	r3, #2
 6453 37d4 0800A0E1 		mov	r0, r8
 6454 37d8 00308DE5 		str	r3, [sp]
 6455 37dc 2110A0E3 		mov	r1, #33
 6456 37e0 2520A0E3 		mov	r2, #37
 6457 37e4 3030A0E3 		mov	r3, #48
 6458 37e8 04908DE5 		str	r9, [sp, #4]
 6459 37ec FEFFFFEB 		bl	cmdSet
 6460              	.LVL781:
 860:../uvc.c      **** }
 6461              		.loc 1 860 0
 6462 37f0 1C0098E5 		ldr	r0, [r8, #28]
 6463 37f4 FEFFFFEB 		bl	_txe_mutex_put
 6464              	.LVL782:
 6465 37f8 FF00A0E3 		mov	r0, #255
 6466 37fc 0080A0E1 		mov	r8, r0
 6467 3800 2FFEFFEA 		b	.L487
 6468              	.LVL783:
 6469              	.L494:
 6470              	.LBE89:
 6471              	.LBE88:
2117:../uvc.c      **** 						case 1:
 6472              		.loc 1 2117 0
 6473 3804 FF00A0E3 		mov	r0, #255
 6474 3808 0C60A0E1 		mov	r6, ip
 6475 380c 0080A0E1 		mov	r8, r0
 6476 3810 2BFEFFEA 		b	.L487
 6477              	.LVL784:
 6478              	.L500:
2188:../uvc.c      **** 					  }
 6479              		.loc 1 2188 0
 6480 3814 0000A0E3 		mov	r0, #0
 6481 3818 0020A0E1 		mov	r2, r0
 6482 381c 0110A0E3 		mov	r1, #1
 6483 3820 FEFFFFEB 		bl	CyU3PUsbStall
 6484              	.LVL785:
 6485 3824 D1FEFFEA 		b	.L503
 6486              	.LVL786:
 6487              	.L502:
2206:../uvc.c      **** 					  }
 6488              		.loc 1 2206 0
 6489 3828 0020A0E1 		mov	r2, r0
 6490 382c 0110A0E3 		mov	r1, #1
 6491 3830 FEFFFFEB 		bl	CyU3PUsbStall
 6492              	.LVL787:
 6493 3834 CDFEFFEA 		b	.L503
 6494              	.LVL788:
 6495              	.L513:
2221:../uvc.c      **** 					  else
 6496              		.loc 1 2221 0
 6497 3838 0800A0E3 		mov	r0, #8
 6498              	.L510:
 6499 383c 0010A0E3 		mov	r1, #0
 6500 3840 03008DE8 		stmia	sp, {r0, r1}
 6501 3844 0A20A0E1 		mov	r2, r10
 6502 3848 0930A0E1 		mov	r3, r9
 6503 384c 0600A0E1 		mov	r0, r6
 6504 3850 2310A0E3 		mov	r1, #35
 6505 3854 FEFFFFEB 		bl	cmdSet
 6506              	.LVL789:
 6507 3858 97FEFFEA 		b	.L505
 6508              	.L515:
 6509              		.align	2
 6510              	.L514:
 6511 385c 00000000 		.word	bRequest
 6512 3860 00000000 		.word	.LANCHOR1
 6513 3864 00000000 		.word	.LANCHOR0
 6514 3868 8C060000 		.word	.LC39
 6515 386c 68060000 		.word	.LC38
 6516 3870 00000000 		.word	cmdQu
 6517 3874 1C060000 		.word	.LC36
 6518 3878 FFFF0000 		.word	65535
 6519 387c 44060000 		.word	.LC37
 6520              		.cfi_endproc
 6521              	.LFE4:
 6523              		.align	2
 6524              		.global	CamDefSet
 6526              	CamDefSet:
 6527              	.LFB5:
2249:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
 6528              		.loc 1 2249 0
 6529              		.cfi_startproc
 6530              		@ args = 0, pretend = 0, frame = 24
 6531              		@ frame_needed = 0, uses_anonymous_args = 0
 6532              	.LVL790:
 6533 3880 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 6534              	.LCFI21:
 6535              		.cfi_def_cfa_offset 36
 6536              		.cfi_offset 4, -36
 6537              		.cfi_offset 5, -32
 6538              		.cfi_offset 6, -28
 6539              		.cfi_offset 7, -24
 6540              		.cfi_offset 8, -20
 6541              		.cfi_offset 9, -16
 6542              		.cfi_offset 10, -12
 6543              		.cfi_offset 11, -8
 6544              		.cfi_offset 14, -4
2256:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 6545              		.loc 1 2256 0
 6546 3884 B0429FE5 		ldr	r4, .L519
2261:../uvc.c      ****     if(Data1&0x80){
 6547              		.loc 1 2261 0
 6548 3888 B0229FE5 		ldr	r2, .L519+4
2258:../uvc.c      ****     Data1 = Data0;
 6549              		.loc 1 2258 0
 6550 388c 0F52D4E5 		ldrb	r5, [r4, #527]	@ zero_extendqisi2
2249:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
 6551              		.loc 1 2249 0
 6552 3890 2CD04DE2 		sub	sp, sp, #44
 6553              	.LCFI22:
 6554              		.cfi_def_cfa_offset 80
2261:../uvc.c      ****     if(Data1&0x80){
 6555              		.loc 1 2261 0
 6556 3894 1C0092E5 		ldr	r0, [r2, #28]
 6557 3898 0010E0E3 		mvn	r1, #0
2263:../uvc.c      ****     }else{
 6558              		.loc 1 2263 0
 6559 389c 2563A0E1 		mov	r6, r5, lsr #6
2257:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 6560              		.loc 1 2257 0
 6561 38a0 1372D4E5 		ldrb	r7, [r4, #531]	@ zero_extendqisi2
2256:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 6562              		.loc 1 2256 0
 6563 38a4 0592D4E5 		ldrb	r9, [r4, #517]	@ zero_extendqisi2
 6564              	.LVL791:
2261:../uvc.c      ****     if(Data1&0x80){
 6565              		.loc 1 2261 0
 6566 38a8 FEFFFFEB 		bl	_txe_mutex_get
 6567              	.LVL792:
2262:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 6568              		.loc 1 2262 0
 6569 38ac 800015E3 		tst	r5, #128
2263:../uvc.c      ****     }else{
 6570              		.loc 1 2263 0
 6571 38b0 01600612 		andne	r6, r6, #1
 6572 38b4 0660E011 		mvnne	r6, r6
 6573 38b8 3B600612 		andne	r6, r6, #59
 6574 38bc 0660E011 		mvnne	r6, r6
 6575 38c0 FF600612 		andne	r6, r6, #255
 6576              	.LVL793:
2265:../uvc.c      ****     }
 6577              		.loc 1 2265 0
 6578 38c4 C6608603 		orreq	r6, r6, #198
 6579              	.LVL794:
2269:../uvc.c      **** 
 6580              		.loc 1 2269 0
 6581 38c8 0080A0E3 		mov	r8, #0
2267:../uvc.c      **** 
 6582              		.loc 1 2267 0
 6583 38cc 0551A0E1 		mov	r5, r5, asl #2
 6584              	.LVL795:
 6585 38d0 FF5005E2 		and	r5, r5, #255
 6586              	.LVL796:
2272:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6587              		.loc 1 2272 0
 6588 38d4 01A0A0E3 		mov	r10, #1
2269:../uvc.c      **** 
 6589              		.loc 1 2269 0
 6590 38d8 00608DE5 		str	r6, [sp]
 6591 38dc 0920A0E1 		mov	r2, r9
 6592 38e0 0730A0E1 		mov	r3, r7
 6593 38e4 04808DE5 		str	r8, [sp, #4]
 6594 38e8 0110A0E3 		mov	r1, #1
 6595 38ec 4C029FE5 		ldr	r0, .L519+4
 6596 38f0 FEFFFFEB 		bl	cmdSet
 6597              	.LVL797:
2272:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6598              		.loc 1 2272 0
 6599 38f4 0422D4E5 		ldrb	r2, [r4, #516]	@ zero_extendqisi2
 6600 38f8 0730A0E1 		mov	r3, r7
 6601 38fc 0A10A0E1 		mov	r1, r10
 6602 3900 00508DE5 		str	r5, [sp]
 6603 3904 04A08DE5 		str	r10, [sp, #4]
 6604 3908 30029FE5 		ldr	r0, .L519+4
 6605 390c FEFFFFEB 		bl	cmdSet
 6606              	.LVL798:
2275:../uvc.c      **** 
 6607              		.loc 1 2275 0
 6608 3910 0620A0E1 		mov	r2, r6
 6609 3914 0530A0E1 		mov	r3, r5
 6610 3918 24129FE5 		ldr	r1, .L519+8
 6611 391c 0400A0E3 		mov	r0, #4
2274:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 6612              		.loc 1 2274 0
 6613 3920 1262C4E5 		strb	r6, [r4, #530]
2273:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 6614              		.loc 1 2273 0
 6615 3924 1152C4E5 		strb	r5, [r4, #529]
2275:../uvc.c      **** 
 6616              		.loc 1 2275 0
 6617 3928 FEFFFFEB 		bl	CyU3PDebugPrint
 6618              	.LVL799:
2280:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 6619              		.loc 1 2280 0
 6620 392c 2762D4E5 		ldrb	r6, [r4, #551]	@ zero_extendqisi2
 6621              	.LVL800:
2281:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6622              		.loc 1 2281 0
 6623 3930 1C22D4E5 		ldrb	r2, [r4, #540]	@ zero_extendqisi2
 6624 3934 2B32D4E5 		ldrb	r3, [r4, #555]	@ zero_extendqisi2
 6625 3938 40018DE8 		stmia	sp, {r6, r8}
 6626 393c FC019FE5 		ldr	r0, .L519+4
 6627 3940 0210A0E3 		mov	r1, #2
 6628 3944 FEFFFFEB 		bl	cmdSet
 6629              	.LVL801:
2284:../uvc.c      **** 
 6630              		.loc 1 2284 0
 6631 3948 0620A0E1 		mov	r2, r6
 6632 394c 0530A0E1 		mov	r3, r5
 6633 3950 EC119FE5 		ldr	r1, .L519+8
 6634 3954 0400A0E3 		mov	r0, #4
2282:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
 6635              		.loc 1 2282 0
 6636 3958 2952C4E5 		strb	r5, [r4, #553]
2283:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6637              		.loc 1 2283 0
 6638 395c 6954C4E5 		strb	r5, [r4, #1129]
2284:../uvc.c      **** 
 6639              		.loc 1 2284 0
 6640 3960 FEFFFFEB 		bl	CyU3PDebugPrint
 6641              	.LVL802:
2289:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 6642              		.loc 1 2289 0
 6643 3964 6F72D4E5 		ldrb	r7, [r4, #623]	@ zero_extendqisi2
2288:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6644              		.loc 1 2288 0
 6645 3968 7362D4E5 		ldrb	r6, [r4, #627]	@ zero_extendqisi2
 6646              	.LVL803:
2290:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6647              		.loc 1 2290 0
 6648 396c 80C047E2 		sub	ip, r7, #128
 6649 3970 FF300CE2 		and	r3, ip, #255
2291:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6650              		.loc 1 2291 0
 6651 3974 76E047E2 		sub	lr, r7, #118
2290:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6652              		.loc 1 2290 0
 6653 3978 18308DE5 		str	r3, [sp, #24]
 6654 397c 08018DE8 		stmia	sp, {r3, r8}
 6655 3980 B8019FE5 		ldr	r0, .L519+4
 6656 3984 0630A0E1 		mov	r3, r6
 6657 3988 0510A0E3 		mov	r1, #5
 6658 398c DF20A0E3 		mov	r2, #223
 6659 3990 14C08DE5 		str	ip, [sp, #20]
2291:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6660              		.loc 1 2291 0
 6661 3994 1CE08DE5 		str	lr, [sp, #28]
2290:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6662              		.loc 1 2290 0
 6663 3998 FEFFFFEB 		bl	cmdSet
 6664              	.LVL804:
2291:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6665              		.loc 1 2291 0
 6666 399c 1C209DE5 		ldr	r2, [sp, #28]
2292:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6667              		.loc 1 2292 0
 6668 39a0 7EE087E2 		add	lr, r7, #126
2291:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6669              		.loc 1 2291 0
 6670 39a4 FF3002E2 		and	r3, r2, #255
 6671 39a8 08048DE8 		stmia	sp, {r3, r10}
 6672 39ac 8C019FE5 		ldr	r0, .L519+4
 6673 39b0 0630A0E1 		mov	r3, r6
 6674 39b4 0510A0E3 		mov	r1, #5
 6675 39b8 DC20A0E3 		mov	r2, #220
2292:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6676              		.loc 1 2292 0
 6677 39bc 20E08DE5 		str	lr, [sp, #32]
2291:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6678              		.loc 1 2291 0
 6679 39c0 FEFFFFEB 		bl	cmdSet
 6680              	.LVL805:
2292:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6681              		.loc 1 2292 0
 6682 39c4 20209DE5 		ldr	r2, [sp, #32]
2293:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6683              		.loc 1 2293 0
 6684 39c8 72E087E2 		add	lr, r7, #114
2292:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6685              		.loc 1 2292 0
 6686 39cc FF3002E2 		and	r3, r2, #255
 6687 39d0 0220A0E3 		mov	r2, #2
 6688 39d4 00308DE5 		str	r3, [sp]
 6689 39d8 04208DE5 		str	r2, [sp, #4]
 6690 39dc 0630A0E1 		mov	r3, r6
 6691 39e0 0510A0E3 		mov	r1, #5
 6692 39e4 DE20A0E3 		mov	r2, #222
 6693 39e8 50019FE5 		ldr	r0, .L519+4
2293:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6694              		.loc 1 2293 0
 6695 39ec 24E08DE5 		str	lr, [sp, #36]
2292:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6696              		.loc 1 2292 0
 6697 39f0 FEFFFFEB 		bl	cmdSet
 6698              	.LVL806:
2293:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6699              		.loc 1 2293 0
 6700 39f4 24209DE5 		ldr	r2, [sp, #36]
2294:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 6701              		.loc 1 2294 0
 6702 39f8 6FB047E2 		sub	fp, r7, #111
2293:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6703              		.loc 1 2293 0
 6704 39fc FF3002E2 		and	r3, r2, #255
 6705 3a00 0320A0E3 		mov	r2, #3
 6706 3a04 00308DE5 		str	r3, [sp]
 6707 3a08 04208DE5 		str	r2, [sp, #4]
 6708 3a0c 0630A0E1 		mov	r3, r6
 6709 3a10 0510A0E3 		mov	r1, #5
 6710 3a14 E020A0E3 		mov	r2, #224
 6711 3a18 20019FE5 		ldr	r0, .L519+4
 6712 3a1c FEFFFFEB 		bl	cmdSet
 6713              	.LVL807:
2294:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 6714              		.loc 1 2294 0
 6715 3a20 0490A0E3 		mov	r9, #4
 6716 3a24 FF300BE2 		and	r3, fp, #255
2295:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 6717              		.loc 1 2295 0
 6718 3a28 7F7087E2 		add	r7, r7, #127
 6719              	.LVL808:
2294:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 6720              		.loc 1 2294 0
 6721 3a2c 00308DE5 		str	r3, [sp]
 6722 3a30 04908DE5 		str	r9, [sp, #4]
 6723 3a34 0630A0E1 		mov	r3, r6
 6724 3a38 0510A0E3 		mov	r1, #5
 6725 3a3c DD20A0E3 		mov	r2, #221
 6726 3a40 F8009FE5 		ldr	r0, .L519+4
 6727 3a44 FEFFFFEB 		bl	cmdSet
 6728              	.LVL809:
2295:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 6729              		.loc 1 2295 0
 6730 3a48 FF2007E2 		and	r2, r7, #255
 6731 3a4c 0510A0E3 		mov	r1, #5
 6732 3a50 0630A0E1 		mov	r3, r6
 6733 3a54 00208DE5 		str	r2, [sp]
 6734 3a58 04108DE5 		str	r1, [sp, #4]
 6735 3a5c E120A0E3 		mov	r2, #225
 6736 3a60 D8009FE5 		ldr	r0, .L519+4
 6737 3a64 FEFFFFEB 		bl	cmdSet
 6738              	.LVL810:
2297:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 6739              		.loc 1 2297 0
 6740 3a68 14C09DE5 		ldr	ip, [sp, #20]
 6741 3a6c 24E09DE5 		ldr	lr, [sp, #36]
 6742 3a70 20309DE5 		ldr	r3, [sp, #32]
 6743 3a74 0C20A0E1 		mov	r2, ip
2296:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 6744              		.loc 1 2296 0
 6745 3a78 18C09DE5 		ldr	ip, [sp, #24]
2297:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 6746              		.loc 1 2297 0
 6747 3a7c 04E08DE5 		str	lr, [sp, #4]
 6748 3a80 00308DE5 		str	r3, [sp]
 6749 3a84 0C708DE5 		str	r7, [sp, #12]
 6750 3a88 1C309DE5 		ldr	r3, [sp, #28]
 6751 3a8c 08B08DE5 		str	fp, [sp, #8]
 6752 3a90 0900A0E1 		mov	r0, r9
 6753 3a94 AC109FE5 		ldr	r1, .L519+12
2296:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 6754              		.loc 1 2296 0
 6755 3a98 71C2C4E5 		strb	ip, [r4, #625]
2297:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 6756              		.loc 1 2297 0
 6757 3a9c FEFFFFEB 		bl	CyU3PDebugPrint
 6758              	.LVL811:
2302:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 6759              		.loc 1 2302 0
 6760 3aa0 8762D4E5 		ldrb	r6, [r4, #647]	@ zero_extendqisi2
 6761              	.LVL812:
2301:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6762              		.loc 1 2301 0
 6763 3aa4 8B72D4E5 		ldrb	r7, [r4, #651]	@ zero_extendqisi2
 6764              	.LVL813:
2303:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 6765              		.loc 1 2303 0
 6766 3aa8 00608DE5 		str	r6, [sp]
 6767 3aac 0730A0E1 		mov	r3, r7
 6768 3ab0 04808DE5 		str	r8, [sp, #4]
 6769 3ab4 0610A0E3 		mov	r1, #6
 6770 3ab8 8520A0E3 		mov	r2, #133
 6771 3abc 7C009FE5 		ldr	r0, .L519+4
 6772 3ac0 FEFFFFEB 		bl	cmdSet
 6773              	.LVL814:
2304:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 6774              		.loc 1 2304 0
 6775 3ac4 40048DE8 		stmia	sp, {r6, r10}
 6776 3ac8 70009FE5 		ldr	r0, .L519+4
 6777 3acc 0730A0E1 		mov	r3, r7
 6778 3ad0 0610A0E3 		mov	r1, #6
 6779 3ad4 8620A0E3 		mov	r2, #134
 6780 3ad8 FEFFFFEB 		bl	cmdSet
 6781              	.LVL815:
2306:../uvc.c      **** 
 6782              		.loc 1 2306 0
 6783 3adc 0620A0E1 		mov	r2, r6
 6784 3ae0 0530A0E1 		mov	r3, r5
 6785 3ae4 0900A0E1 		mov	r0, r9
 6786 3ae8 54109FE5 		ldr	r1, .L519+8
2305:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6787              		.loc 1 2305 0
 6788 3aec 8962C4E5 		strb	r6, [r4, #649]
2306:../uvc.c      **** 
 6789              		.loc 1 2306 0
 6790 3af0 FEFFFFEB 		bl	CyU3PDebugPrint
 6791              	.LVL816:
2311:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 6792              		.loc 1 2311 0
 6793 3af4 9F62D4E5 		ldrb	r6, [r4, #671]	@ zero_extendqisi2
 6794              	.LVL817:
2312:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6795              		.loc 1 2312 0
 6796 3af8 9422D4E5 		ldrb	r2, [r4, #660]	@ zero_extendqisi2
 6797 3afc A332D4E5 		ldrb	r3, [r4, #675]	@ zero_extendqisi2
 6798 3b00 40018DE8 		stmia	sp, {r6, r8}
 6799 3b04 34009FE5 		ldr	r0, .L519+4
 6800 3b08 0710A0E3 		mov	r1, #7
 6801 3b0c FEFFFFEB 		bl	cmdSet
 6802              	.LVL818:
2314:../uvc.c      **** 
 6803              		.loc 1 2314 0
 6804 3b10 0620A0E1 		mov	r2, r6
 6805 3b14 0530A0E1 		mov	r3, r5
 6806 3b18 0900A0E1 		mov	r0, r9
 6807 3b1c 20109FE5 		ldr	r1, .L519+8
2313:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6808              		.loc 1 2313 0
 6809 3b20 A152C4E5 		strb	r5, [r4, #673]
2314:../uvc.c      **** 
 6810              		.loc 1 2314 0
 6811 3b24 FEFFFFEB 		bl	CyU3PDebugPrint
 6812              	.LVL819:
2316:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 6813              		.loc 1 2316 0
 6814 3b28 10209FE5 		ldr	r2, .L519+4
 6815 3b2c 1C0092E5 		ldr	r0, [r2, #28]
2319:../uvc.c      **** 
 6816              		.loc 1 2319 0
 6817 3b30 2CD08DE2 		add	sp, sp, #44
 6818              		@ sp needed
 6819 3b34 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 6820              	.LVL820:
2316:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 6821              		.loc 1 2316 0
 6822 3b38 FEFFFFEA 		b	_txe_mutex_put
 6823              	.LVL821:
 6824              	.L520:
 6825              		.align	2
 6826              	.L519:
 6827 3b3c 00000000 		.word	.LANCHOR1
 6828 3b40 00000000 		.word	statQu
 6829 3b44 F0060000 		.word	.LC40
 6830 3b48 10070000 		.word	.LC41
 6831              		.cfi_endproc
 6832              	.LFE5:
 6834              		.align	2
 6835              		.global	CyFxUVCAddHeader
 6837              	CyFxUVCAddHeader:
 6838              	.LFB6:
2327:../uvc.c      ****     /* Copy header to buffer */
 6839              		.loc 1 2327 0
 6840              		.cfi_startproc
 6841              		@ args = 0, pretend = 0, frame = 0
 6842              		@ frame_needed = 0, uses_anonymous_args = 0
 6843              	.LVL822:
 6844 3b4c 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 6845              	.LCFI23:
 6846              		.cfi_def_cfa_offset 16
 6847              		.cfi_offset 3, -16
 6848              		.cfi_offset 4, -12
 6849              		.cfi_offset 5, -8
 6850              		.cfi_offset 14, -4
2327:../uvc.c      ****     /* Copy header to buffer */
 6851              		.loc 1 2327 0
 6852 3b50 0040A0E1 		mov	r4, r0
 6853 3b54 0150A0E1 		mov	r5, r1
2329:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 6854              		.loc 1 2329 0
 6855 3b58 30009FE5 		ldr	r0, .L526
 6856              	.LVL823:
 6857 3b5c 0010E0E3 		mvn	r1, #0
 6858              	.LVL824:
 6859 3b60 FEFFFFEB 		bl	_txe_mutex_get
 6860              	.LVL825:
2330:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 6861              		.loc 1 2330 0
 6862 3b64 0400A0E1 		mov	r0, r4
 6863 3b68 24109FE5 		ldr	r1, .L526+4
 6864 3b6c 0C20A0E3 		mov	r2, #12
 6865 3b70 FEFFFFEB 		bl	CyU3PMemCopy
 6866              	.LVL826:
2331:../uvc.c      **** 
 6867              		.loc 1 2331 0
 6868 3b74 14009FE5 		ldr	r0, .L526
 6869 3b78 FEFFFFEB 		bl	_txe_mutex_put
 6870              	.LVL827:
2334:../uvc.c      ****     {
 6871              		.loc 1 2334 0
 6872 3b7c 020015E3 		tst	r5, #2
2336:../uvc.c      ****     }
 6873              		.loc 1 2336 0
 6874 3b80 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 6875 3b84 02308313 		orrne	r3, r3, #2
 6876 3b88 0130C415 		strneb	r3, [r4, #1]
 6877 3b8c 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 6878              	.L527:
 6879              		.align	2
 6880              	.L526:
 6881 3b90 00000000 		.word	imgHdMux
 6882 3b94 EC040000 		.word	.LANCHOR1+1260
 6883              		.cfi_endproc
 6884              	.LFE6:
 6886              		.align	2
 6887              		.global	CyFxAppErrorHandler
 6889              	CyFxAppErrorHandler:
 6890              	.LFB7:
2346:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
 6891              		.loc 1 2346 0
 6892              		.cfi_startproc
 6893              		@ Volatile: function does not return.
 6894              		@ args = 0, pretend = 0, frame = 0
 6895              		@ frame_needed = 0, uses_anonymous_args = 0
 6896              	.LVL828:
 6897 3b98 08402DE9 		stmfd	sp!, {r3, lr}
 6898              	.LCFI24:
 6899              		.cfi_def_cfa_offset 8
 6900              		.cfi_offset 3, -8
 6901              		.cfi_offset 14, -4
 6902              	.LVL829:
 6903              	.L529:
2356:../uvc.c      ****         CyU3PThreadSleep (1000);
 6904              		.loc 1 2356 0 discriminator 1
 6905 3b9c 10109FE5 		ldr	r1, .L530
 6906 3ba0 0400A0E3 		mov	r0, #4
 6907 3ba4 FEFFFFEB 		bl	CyU3PDebugPrint
 6908              	.LVL830:
2357:../uvc.c      ****     }
 6909              		.loc 1 2357 0 discriminator 1
 6910 3ba8 FA0FA0E3 		mov	r0, #1000
 6911 3bac FEFFFFEB 		bl	_tx_thread_sleep
 6912              	.LVL831:
 6913 3bb0 F9FFFFEA 		b	.L529
 6914              	.L531:
 6915              		.align	2
 6916              	.L530:
 6917 3bb4 48070000 		.word	.LC42
 6918              		.cfi_endproc
 6919              	.LFE7:
 6921              		.align	2
 6922              		.global	UVCAppThread_Entry
 6924              	UVCAppThread_Entry:
 6925              	.LFB19:
3333:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
 6926              		.loc 1 3333 0
 6927              		.cfi_startproc
 6928              		@ args = 0, pretend = 0, frame = 128
 6929              		@ frame_needed = 0, uses_anonymous_args = 0
 6930              	.LVL832:
 6931 3bb8 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 6932              	.LCFI25:
 6933              		.cfi_def_cfa_offset 32
 6934              		.cfi_offset 4, -32
 6935              		.cfi_offset 5, -28
 6936              		.cfi_offset 6, -24
 6937              		.cfi_offset 7, -20
 6938              		.cfi_offset 8, -16
 6939              		.cfi_offset 9, -12
 6940              		.cfi_offset 10, -8
 6941              		.cfi_offset 14, -4
 6942 3bbc 88D04DE2 		sub	sp, sp, #136
 6943              	.LCFI26:
 6944              		.cfi_def_cfa_offset 168
 6945              	.LBB98:
 6946              	.LBB99:
2789:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6947              		.loc 1 2789 0
 6948 3bc0 FEFFFFEB 		bl	CyU3PUartInit
 6949              	.LVL833:
2790:../uvc.c      ****     {
 6950              		.loc 1 2790 0
 6951 3bc4 004050E2 		subs	r4, r0, #0
 6952 3bc8 2902001A 		bne	.L613
2797:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6953              		.loc 1 2797 0
 6954 3bcc 582A9FE5 		ldr	r2, .L644
2798:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6955              		.loc 1 2798 0
 6956 3bd0 0130A0E3 		mov	r3, #1
2806:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6957              		.loc 1 2806 0
 6958 3bd4 0410A0E1 		mov	r1, r4
 6959 3bd8 60008DE2 		add	r0, sp, #96
 6960              	.LVL834:
2799:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 6961              		.loc 1 2799 0
 6962 3bdc 7540CDE5 		strb	r4, [sp, #117]
2801:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 6963              		.loc 1 2801 0
 6964 3be0 64408DE5 		str	r4, [sp, #100]
2802:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 6965              		.loc 1 2802 0
 6966 3be4 68408DE5 		str	r4, [sp, #104]
2797:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6967              		.loc 1 2797 0
 6968 3be8 70208DE5 		str	r2, [sp, #112]
2798:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6969              		.loc 1 2798 0
 6970 3bec 7430CDE5 		strb	r3, [sp, #116]
2800:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 6971              		.loc 1 2800 0
 6972 3bf0 60308DE5 		str	r3, [sp, #96]
2803:../uvc.c      **** 
 6973              		.loc 1 2803 0
 6974 3bf4 6C308DE5 		str	r3, [sp, #108]
2806:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6975              		.loc 1 2806 0
 6976 3bf8 FEFFFFEB 		bl	CyU3PUartSetConfig
 6977              	.LVL835:
2807:../uvc.c      ****     {
 6978              		.loc 1 2807 0
 6979 3bfc 000050E3 		cmp	r0, #0
 6980 3c00 B201001A 		bne	.L612
2813:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6981              		.loc 1 2813 0
 6982 3c04 0000E0E3 		mvn	r0, #0
 6983              	.LVL836:
 6984 3c08 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 6985              	.LVL837:
2814:../uvc.c      ****     {
 6986              		.loc 1 2814 0
 6987 3c0c 000050E3 		cmp	r0, #0
 6988 3c10 AE01001A 		bne	.L612
2820:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6989              		.loc 1 2820 0
 6990 3c14 0300A0E3 		mov	r0, #3
 6991              	.LVL838:
 6992 3c18 0410A0E3 		mov	r1, #4
 6993 3c1c FEFFFFEB 		bl	CyU3PDebugInit
 6994              	.LVL839:
2821:../uvc.c      ****     {
 6995              		.loc 1 2821 0
 6996 3c20 000050E3 		cmp	r0, #0
 6997 3c24 A901001A 		bne	.L612
2827:../uvc.c      **** }
 6998              		.loc 1 2827 0
 6999 3c28 FEFFFFEB 		bl	CyU3PDebugPreamble
 7000              	.LVL840:
 7001 3c2c 0640A0E3 		mov	r4, #6
 7002              	.LVL841:
 7003              	.L538:
 7004              	.LBE99:
 7005              	.LBE98:
3349:../uvc.c      **** 	}
 7006              		.loc 1 3349 0
 7007 3c30 7D0FA0E3 		mov	r0, #500
 7008 3c34 014044E2 		sub	r4, r4, #1
 7009 3c38 FEFFFFEB 		bl	_tx_thread_sleep
 7010              	.LVL842:
3348:../uvc.c      **** 		CyU3PThreadSleep(500);
 7011              		.loc 1 3348 0
 7012 3c3c FF4014E2 		ands	r4, r4, #255
 7013 3c40 FAFFFF1A 		bne	.L538
 7014              	.LBB101:
 7015              	.LBB102:
2837:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 7016              		.loc 1 2837 0
 7017 3c44 FEFFFFEB 		bl	CyU3PI2cInit
 7018              	.LVL843:
2838:../uvc.c      ****     {
 7019              		.loc 1 2838 0
 7020 3c48 005050E2 		subs	r5, r0, #0
 7021 3c4c 3002001A 		bne	.L614
2845:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 7022              		.loc 1 2845 0
 7023 3c50 D8299FE5 		ldr	r2, .L644+4
2847:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 7024              		.loc 1 2847 0
 7025 3c54 0030E0E3 		mvn	r3, #0
2850:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 7026              		.loc 1 2850 0
 7027 3c58 60008DE2 		add	r0, sp, #96
 7028              	.LVL844:
 7029 3c5c 0410A0E1 		mov	r1, r4
2846:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 7030              		.loc 1 2846 0
 7031 3c60 64408DE5 		str	r4, [sp, #100]
2845:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 7032              		.loc 1 2845 0
 7033 3c64 60208DE5 		str	r2, [sp, #96]
2847:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 7034              		.loc 1 2847 0
 7035 3c68 68308DE5 		str	r3, [sp, #104]
2848:../uvc.c      **** 
 7036              		.loc 1 2848 0
 7037 3c6c BC36CDE1 		strh	r3, [sp, #108]	@ movhi
2850:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 7038              		.loc 1 2850 0
 7039 3c70 FEFFFFEB 		bl	CyU3PI2cSetConfig
 7040              	.LVL845:
2851:../uvc.c      ****     {
 7041              		.loc 1 2851 0
 7042 3c74 005050E2 		subs	r5, r0, #0
 7043 3c78 2002001A 		bne	.L615
 7044              	.LBE102:
 7045              	.LBE101:
 7046              	.LBB104:
 7047              	.LBB105:
2924:../uvc.c      ****     if (apiRetStatus != 0)
 7048              		.loc 1 2924 0
 7049 3c7c B0799FE5 		ldr	r7, .L644+8
 7050 3c80 0410A0E1 		mov	r1, r4
 7051 3c84 0700A0E1 		mov	r0, r7
 7052              	.LVL846:
 7053 3c88 2820A0E3 		mov	r2, #40
 7054 3c8c FEFFFFEB 		bl	_txe_event_flags_create
 7055              	.LVL847:
2925:../uvc.c      ****     {
 7056              		.loc 1 2925 0
 7057 3c90 005050E2 		subs	r5, r0, #0
 7058              	.LVL848:
 7059 3c94 1302001A 		bne	.L616
2939:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 7060              		.loc 1 2939 0
 7061 3c98 0230A0E3 		mov	r3, #2
2942:../uvc.c      ****     gpioClock.halfDiv    = 0;
 7062              		.loc 1 2942 0
 7063 3c9c 0320A0E3 		mov	r2, #3
2946:../uvc.c      ****     if (apiRetStatus != 0)
 7064              		.loc 1 2946 0
 7065 3ca0 14008DE2 		add	r0, sp, #20
 7066              	.LVL849:
 7067 3ca4 0410A0E1 		mov	r1, r4
2935:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 7068              		.loc 1 2935 0
 7069 3ca8 8C4087E5 		str	r4, [r7, #140]
2936:../uvc.c      **** 
 7070              		.loc 1 2936 0
 7071 3cac 904087E5 		str	r4, [r7, #144]
2941:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 7072              		.loc 1 2941 0
 7073 3cb0 1C40CDE5 		strb	r4, [sp, #28]
2943:../uvc.c      **** 
 7074              		.loc 1 2943 0
 7075 3cb4 18408DE5 		str	r4, [sp, #24]
2939:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 7076              		.loc 1 2939 0
 7077 3cb8 1430CDE5 		strb	r3, [sp, #20]
2940:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 7078              		.loc 1 2940 0
 7079 3cbc 1530CDE5 		strb	r3, [sp, #21]
2942:../uvc.c      ****     gpioClock.halfDiv    = 0;
 7080              		.loc 1 2942 0
 7081 3cc0 1D20CDE5 		strb	r2, [sp, #29]
2946:../uvc.c      ****     if (apiRetStatus != 0)
 7082              		.loc 1 2946 0
 7083 3cc4 FEFFFFEB 		bl	CyU3PGpioInit
 7084              	.LVL850:
2947:../uvc.c      ****     {
 7085              		.loc 1 2947 0
 7086 3cc8 005050E2 		subs	r5, r0, #0
 7087 3ccc FF01001A 		bne	.L617
2955:../uvc.c      ****     if (apiRetStatus != 0)
 7088              		.loc 1 2955 0
 7089 3cd0 1600A0E3 		mov	r0, #22
 7090              	.LVL851:
 7091 3cd4 0110A0E3 		mov	r1, #1
 7092 3cd8 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 7093              	.LVL852:
2956:../uvc.c      ****     {
 7094              		.loc 1 2956 0
 7095 3cdc 005050E2 		subs	r5, r0, #0
 7096 3ce0 3A02001A 		bne	.L618
2961:../uvc.c      ****     if (apiRetStatus != 0)
 7097              		.loc 1 2961 0
 7098 3ce4 1400A0E3 		mov	r0, #20
 7099              	.LVL853:
 7100 3ce8 0110A0E3 		mov	r1, #1
 7101 3cec FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 7102              	.LVL854:
2962:../uvc.c      ****     {
 7103              		.loc 1 2962 0
 7104 3cf0 005050E2 		subs	r5, r0, #0
 7105 3cf4 2F02001A 		bne	.L619
2967:../uvc.c      ****     if (apiRetStatus != 0)
 7106              		.loc 1 2967 0
 7107 3cf8 1800A0E3 		mov	r0, #24
 7108              	.LVL855:
 7109 3cfc 0110A0E3 		mov	r1, #1
 7110 3d00 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 7111              	.LVL856:
2968:../uvc.c      ****     {
 7112              		.loc 1 2968 0
 7113 3d04 005050E2 		subs	r5, r0, #0
 7114 3d08 2402001A 		bne	.L620
2975:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 7115              		.loc 1 2975 0
 7116 3d0c 0150A0E3 		mov	r5, #1
2980:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7117              		.loc 1 2980 0
 7118 3d10 30108DE2 		add	r1, sp, #48
 7119 3d14 1600A0E3 		mov	r0, #22
 7120              	.LVL857:
2978:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 7121              		.loc 1 2978 0
 7122 3d18 3C408DE5 		str	r4, [sp, #60]
2979:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 7123              		.loc 1 2979 0
 7124 3d1c 4040CDE5 		strb	r4, [sp, #64]
2975:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 7125              		.loc 1 2975 0
 7126 3d20 30508DE5 		str	r5, [sp, #48]
2976:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 7127              		.loc 1 2976 0
 7128 3d24 34508DE5 		str	r5, [sp, #52]
2977:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 7129              		.loc 1 2977 0
 7130 3d28 38508DE5 		str	r5, [sp, #56]
2980:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7131              		.loc 1 2980 0
 7132 3d2c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 7133              	.LVL858:
2981:../uvc.c      ****     {
 7134              		.loc 1 2981 0
 7135 3d30 006050E2 		subs	r6, r0, #0
 7136 3d34 1302001A 		bne	.L621
2994:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7137              		.loc 1 2994 0
 7138 3d38 1400A0E3 		mov	r0, #20
 7139              	.LVL859:
 7140 3d3c 30108DE2 		add	r1, sp, #48
2992:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 7141              		.loc 1 2992 0
 7142 3d40 3C408DE5 		str	r4, [sp, #60]
2993:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 7143              		.loc 1 2993 0
 7144 3d44 4040CDE5 		strb	r4, [sp, #64]
2989:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 7145              		.loc 1 2989 0
 7146 3d48 30508DE5 		str	r5, [sp, #48]
2990:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 7147              		.loc 1 2990 0
 7148 3d4c 34508DE5 		str	r5, [sp, #52]
2991:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 7149              		.loc 1 2991 0
 7150 3d50 38508DE5 		str	r5, [sp, #56]
2994:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7151              		.loc 1 2994 0
 7152 3d54 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 7153              	.LVL860:
2995:../uvc.c      ****     {
 7154              		.loc 1 2995 0
 7155 3d58 004050E2 		subs	r4, r0, #0
 7156 3d5c 0302001A 		bne	.L622
3003:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 7157              		.loc 1 3003 0
 7158 3d60 0030A0E3 		mov	r3, #0
3008:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7159              		.loc 1 3008 0
 7160 3d64 30108DE2 		add	r1, sp, #48
3006:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 7161              		.loc 1 3006 0
 7162 3d68 0150A0E3 		mov	r5, #1
3008:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7163              		.loc 1 3008 0
 7164 3d6c 1800A0E3 		mov	r0, #24
 7165              	.LVL861:
3003:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 7166              		.loc 1 3003 0
 7167 3d70 30308DE5 		str	r3, [sp, #48]
3004:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 7168              		.loc 1 3004 0
 7169 3d74 34308DE5 		str	r3, [sp, #52]
3005:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 7170              		.loc 1 3005 0
 7171 3d78 38308DE5 		str	r3, [sp, #56]
3007:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 7172              		.loc 1 3007 0
 7173 3d7c 4030CDE5 		strb	r3, [sp, #64]
3006:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 7174              		.loc 1 3006 0
 7175 3d80 3C508DE5 		str	r5, [sp, #60]
3008:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7176              		.loc 1 3008 0
 7177 3d84 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 7178              	.LVL862:
3009:../uvc.c      ****     {
 7179              		.loc 1 3009 0
 7180 3d88 004050E2 		subs	r4, r0, #0
 7181 3d8c F101001A 		bne	.L623
3016:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 7182              		.loc 1 3016 0
 7183 3d90 0260A0E3 		mov	r6, #2
3017:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 7184              		.loc 1 3017 0
 7185 3d94 0380A0E3 		mov	r8, #3
3021:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7186              		.loc 1 3021 0
 7187 3d98 0500A0E1 		mov	r0, r5
 7188              	.LVL863:
 7189 3d9c 20108DE2 		add	r1, sp, #32
3018:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 7190              		.loc 1 3018 0
 7191 3da0 28408DE5 		str	r4, [sp, #40]
3019:../uvc.c      **** 
 7192              		.loc 1 3019 0
 7193 3da4 24408DE5 		str	r4, [sp, #36]
3016:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 7194              		.loc 1 3016 0
 7195 3da8 B062CDE1 		strh	r6, [sp, #32]	@ movhi
3017:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 7196              		.loc 1 3017 0
 7197 3dac 2C80CDE5 		strb	r8, [sp, #44]
3021:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7198              		.loc 1 3021 0
 7199 3db0 FEFFFFEB 		bl	CyU3PPibInit
 7200              	.LVL864:
3022:../uvc.c      ****     {
 7201              		.loc 1 3022 0
 7202 3db4 004050E2 		subs	r4, r0, #0
 7203 3db8 E001001A 		bne	.L624
3029:../uvc.c      **** 
 7204              		.loc 1 3029 0
 7205 3dbc 74089FE5 		ldr	r0, .L644+12
 7206              	.LVL865:
 7207 3dc0 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 7208              	.LVL866:
3037:../uvc.c      ****     CyU3PThreadSleep(5000);
 7209              		.loc 1 3037 0
 7210 3dc4 FEFFFFEB 		bl	SensorReset
 7211              	.LVL867:
3038:../uvc.c      ****     //SensorInit ();
 7212              		.loc 1 3038 0
 7213 3dc8 6C089FE5 		ldr	r0, .L644+16
 7214 3dcc FEFFFFEB 		bl	_tx_thread_sleep
 7215              	.LVL868:
3042:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7216              		.loc 1 3042 0
 7217 3dd0 FEFFFFEB 		bl	CyU3PUsbStart
 7218              	.LVL869:
3043:../uvc.c      ****     {
 7219              		.loc 1 3043 0
 7220 3dd4 004050E2 		subs	r4, r0, #0
 7221 3dd8 D201001A 		bne	.L625
3049:../uvc.c      **** 
 7222              		.loc 1 3049 0
 7223 3ddc 0410A0E1 		mov	r1, r4
 7224 3de0 58089FE5 		ldr	r0, .L644+20
 7225              	.LVL870:
 7226 3de4 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 7227              	.LVL871:
3052:../uvc.c      **** 
 7228              		.loc 1 3052 0
 7229 3de8 54089FE5 		ldr	r0, .L644+24
 7230 3dec FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
 7231              	.LVL872:
3058:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 7232              		.loc 1 3058 0
 7233 3df0 0410A0E1 		mov	r1, r4
 7234 3df4 4C289FE5 		ldr	r2, .L644+28
 7235 3df8 0500A0E1 		mov	r0, r5
 7236 3dfc FEFFFFEB 		bl	CyU3PUsbSetDesc
 7237              	.LVL873:
3059:../uvc.c      **** 
 7238              		.loc 1 3059 0
 7239 3e00 0410A0E1 		mov	r1, r4
 7240 3e04 0400A0E1 		mov	r0, r4
 7241 3e08 3C289FE5 		ldr	r2, .L644+32
 7242 3e0c FEFFFFEB 		bl	CyU3PUsbSetDesc
 7243              	.LVL874:
3062:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 7244              		.loc 1 3062 0
 7245 3e10 0410A0E1 		mov	r1, r4
 7246 3e14 34289FE5 		ldr	r2, .L644+36
 7247 3e18 0600A0E1 		mov	r0, r6
 7248 3e1c FEFFFFEB 		bl	CyU3PUsbSetDesc
 7249              	.LVL875:
3063:../uvc.c      **** 
 7250              		.loc 1 3063 0
 7251 3e20 0410A0E1 		mov	r1, r4
 7252 3e24 28289FE5 		ldr	r2, .L644+40
 7253 3e28 0700A0E3 		mov	r0, #7
 7254 3e2c FEFFFFEB 		bl	CyU3PUsbSetDesc
 7255              	.LVL876:
3066:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 7256              		.loc 1 3066 0
 7257 3e30 0410A0E1 		mov	r1, r4
 7258 3e34 1C289FE5 		ldr	r2, .L644+44
 7259 3e38 0400A0E3 		mov	r0, #4
 7260 3e3c FEFFFFEB 		bl	CyU3PUsbSetDesc
 7261              	.LVL877:
3067:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 7262              		.loc 1 3067 0
 7263 3e40 0410A0E1 		mov	r1, r4
 7264 3e44 10289FE5 		ldr	r2, .L644+48
 7265 3e48 0800A0E1 		mov	r0, r8
 7266 3e4c FEFFFFEB 		bl	CyU3PUsbSetDesc
 7267              	.LVL878:
3068:../uvc.c      **** 
 7268              		.loc 1 3068 0
 7269 3e50 0410A0E1 		mov	r1, r4
 7270 3e54 04289FE5 		ldr	r2, .L644+52
 7271 3e58 0600A0E3 		mov	r0, #6
 7272 3e5c FEFFFFEB 		bl	CyU3PUsbSetDesc
 7273              	.LVL879:
3071:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 7274              		.loc 1 3071 0
 7275 3e60 0410A0E1 		mov	r1, r4
 7276 3e64 F8279FE5 		ldr	r2, .L644+56
 7277 3e68 0500A0E3 		mov	r0, #5
 7278 3e6c FEFFFFEB 		bl	CyU3PUsbSetDesc
 7279              	.LVL880:
3072:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 7280              		.loc 1 3072 0
 7281 3e70 0510A0E1 		mov	r1, r5
 7282 3e74 EC279FE5 		ldr	r2, .L644+60
 7283 3e78 0500A0E3 		mov	r0, #5
 7284 3e7c FEFFFFEB 		bl	CyU3PUsbSetDesc
 7285              	.LVL881:
3073:../uvc.c      **** 
 7286              		.loc 1 3073 0
 7287 3e80 0610A0E1 		mov	r1, r6
 7288 3e84 E0279FE5 		ldr	r2, .L644+64
 7289 3e88 0500A0E3 		mov	r0, #5
 7290 3e8c FEFFFFEB 		bl	CyU3PUsbSetDesc
 7291              	.LVL882:
3082:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 7292              		.loc 1 3082 0
 7293 3e90 4030A0E3 		mov	r3, #64
3086:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7294              		.loc 1 3086 0
 7295 3e94 08108DE2 		add	r1, sp, #8
 7296 3e98 8200A0E3 		mov	r0, #130
3083:../uvc.c      ****     endPointConfig.streams  = 0;
 7297              		.loc 1 3083 0
 7298 3e9c 1340CDE5 		strb	r4, [sp, #19]
3084:../uvc.c      ****     endPointConfig.burstLen = 1;
 7299              		.loc 1 3084 0
 7300 3ea0 BE40CDE1 		strh	r4, [sp, #14]	@ movhi
3080:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 7301              		.loc 1 3080 0
 7302 3ea4 08508DE5 		str	r5, [sp, #8]
3081:../uvc.c      ****     endPointConfig.pcktSize = 64;
 7303              		.loc 1 3081 0
 7304 3ea8 0C80CDE5 		strb	r8, [sp, #12]
3085:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 7305              		.loc 1 3085 0
 7306 3eac 1250CDE5 		strb	r5, [sp, #18]
3082:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 7307              		.loc 1 3082 0
 7308 3eb0 B031CDE1 		strh	r3, [sp, #16]	@ movhi
3086:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7309              		.loc 1 3086 0
 7310 3eb4 FEFFFFEB 		bl	CyU3PSetEpConfig
 7311              	.LVL883:
3087:../uvc.c      ****     {
 7312              		.loc 1 3087 0
 7313 3eb8 004050E2 		subs	r4, r0, #0
3090:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7314              		.loc 1 3090 0
 7315 3ebc 0400A013 		movne	r0, #4
 7316              	.LVL884:
3087:../uvc.c      ****     {
 7317              		.loc 1 3087 0
 7318 3ec0 7101001A 		bne	.L610
3095:../uvc.c      ****     dmaInterConfig.count          = 1;
 7319              		.loc 1 3095 0
 7320 3ec4 A4C79FE5 		ldr	ip, .L644+68
 7321 3ec8 413BA0E3 		mov	r3, #66560
3104:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 7322              		.loc 1 3104 0
 7323 3ecc 1080A0E3 		mov	r8, #16
3106:../uvc.c      ****             &dmaInterConfig);
 7324              		.loc 1 3106 0
 7325 3ed0 9C079FE5 		ldr	r0, .L644+72
 7326 3ed4 0410A0E3 		mov	r1, #4
 7327 3ed8 44208DE2 		add	r2, sp, #68
3095:../uvc.c      ****     dmaInterConfig.count          = 1;
 7328              		.loc 1 3095 0
 7329 3edc 4C408DE5 		str	r4, [sp, #76]
 7330 3ee0 50408DE5 		str	r4, [sp, #80]
3103:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 7331              		.loc 1 3103 0
 7332 3ee4 5440CDE5 		strb	r4, [sp, #84]
3105:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 7333              		.loc 1 3105 0
 7334 3ee8 5C408DE5 		str	r4, [sp, #92]
3095:../uvc.c      ****     dmaInterConfig.count          = 1;
 7335              		.loc 1 3095 0
 7336 3eec 48C08DE5 		str	ip, [sp, #72]
 7337 3ef0 44308DE5 		str	r3, [sp, #68]
3104:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 7338              		.loc 1 3104 0
 7339 3ef4 58808DE5 		str	r8, [sp, #88]
3106:../uvc.c      ****             &dmaInterConfig);
 7340              		.loc 1 3106 0
 7341 3ef8 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 7342              	.LVL885:
3108:../uvc.c      ****     {
 7343              		.loc 1 3108 0
 7344 3efc 004050E2 		subs	r4, r0, #0
 7345 3f00 BE01001A 		bne	.L626
3115:../uvc.c      ****     if (glInterStaBuffer == 0)
 7346              		.loc 1 3115 0
 7347 3f04 010BA0E3 		mov	r0, #1024
 7348              	.LVL886:
 7349 3f08 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 7350              	.LVL887:
 7351 3f0c 64379FE5 		ldr	r3, .L644+76
3116:../uvc.c      ****     {
 7352              		.loc 1 3116 0
 7353 3f10 000050E3 		cmp	r0, #0
3115:../uvc.c      ****     if (glInterStaBuffer == 0)
 7354              		.loc 1 3115 0
 7355 3f14 000083E5 		str	r0, [r3]
3116:../uvc.c      ****     {
 7356              		.loc 1 3116 0
 7357 3f18 BE01000A 		beq	.L627
3123:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 7358              		.loc 1 3123 0
 7359 3f1c 0410A0E1 		mov	r1, r4
 7360 3f20 0420A0E1 		mov	r2, r4
 7361 3f24 3830A0E3 		mov	r3, #56
 7362 3f28 4C079FE5 		ldr	r0, .L644+80
 7363 3f2c FEFFFFEB 		bl	_txe_mutex_create
 7364              	.LVL888:
3128:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 7365              		.loc 1 3128 0
 7366 3f30 48179FE5 		ldr	r1, .L644+84
3129:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 7367              		.loc 1 3129 0
 7368 3f34 48279FE5 		ldr	r2, .L644+88
3136:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 7369              		.loc 1 3136 0
 7370 3f38 48A79FE5 		ldr	r10, .L644+92
3125:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 7371              		.loc 1 3125 0
 7372 3f3c 0480A0E3 		mov	r8, #4
3127:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 7373              		.loc 1 3127 0
 7374 3f40 01ECA0E3 		mov	lr, #256
3131:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 7375              		.loc 1 3131 0
 7376 3f44 0CC0A0E3 		mov	ip, #12
3135:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 7377              		.loc 1 3135 0
 7378 3f48 1830A0E3 		mov	r3, #24
3128:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 7379              		.loc 1 3128 0
 7380 3f4c B816CDE1 		strh	r1, [sp, #104]	@ movhi
3129:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 7381              		.loc 1 3129 0
 7382 3f50 BE26CDE1 		strh	r2, [sp, #110]	@ movhi
3124:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 7383              		.loc 1 3124 0
 7384 3f54 0199A0E3 		mov	r9, #16384
3137:../uvc.c      ****             &dmaMultiConfig);
 7385              		.loc 1 3137 0
 7386 3f58 2C079FE5 		ldr	r0, .L644+96
 7387 3f5c 0710A0E3 		mov	r1, #7
 7388 3f60 60208DE2 		add	r2, sp, #96
3130:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 7389              		.loc 1 3130 0
 7390 3f64 B647CDE1 		strh	r4, [sp, #118]	@ movhi
3133:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 7391              		.loc 1 3133 0
 7392 3f68 BC47CDE1 		strh	r4, [sp, #124]	@ movhi
3134:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 7393              		.loc 1 3134 0
 7394 3f6c 7E40CDE5 		strb	r4, [sp, #126]
3126:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 7395              		.loc 1 3126 0
 7396 3f70 B466CDE1 		strh	r6, [sp, #100]	@ movhi
3136:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 7397              		.loc 1 3136 0
 7398 3f74 84A08DE5 		str	r10, [sp, #132]
3124:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 7399              		.loc 1 3124 0
 7400 3f78 B096CDE1 		strh	r9, [sp, #96]	@ movhi
3125:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 7401              		.loc 1 3125 0
 7402 3f7c B286CDE1 		strh	r8, [sp, #98]	@ movhi
3132:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 7403              		.loc 1 3132 0
 7404 3f80 BA87CDE1 		strh	r8, [sp, #122]	@ movhi
3127:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 7405              		.loc 1 3127 0
 7406 3f84 B6E6CDE1 		strh	lr, [sp, #102]	@ movhi
3131:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 7407              		.loc 1 3131 0
 7408 3f88 B8C7CDE1 		strh	ip, [sp, #120]	@ movhi
3135:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 7409              		.loc 1 3135 0
 7410 3f8c 80308DE5 		str	r3, [sp, #128]
3137:../uvc.c      ****             &dmaMultiConfig);
 7411              		.loc 1 3137 0
 7412 3f90 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 7413              	.LVL889:
3139:../uvc.c      ****     {
 7414              		.loc 1 3139 0
 7415 3f94 004050E2 		subs	r4, r0, #0
 7416 3f98 9201001A 		bne	.L628
3230:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7417              		.loc 1 3230 0
 7418 3f9c 0500A0E1 		mov	r0, r5
 7419              	.LVL890:
 7420 3fa0 0510A0E1 		mov	r1, r5
 7421 3fa4 FEFFFFEB 		bl	CyU3PConnectState
 7422              	.LVL891:
3231:../uvc.c      ****     {
 7423              		.loc 1 3231 0
 7424 3fa8 004050E2 		subs	r4, r0, #0
 7425 3fac 3B01001A 		bne	.L629
3237:../uvc.c      **** 
 7426              		.loc 1 3237 0
 7427 3fb0 6400A0E3 		mov	r0, #100
 7428              	.LVL892:
 7429 3fb4 FEFFFFEB 		bl	CyFx3BusyWait
 7430              	.LVL893:
3239:../uvc.c      **** 
 7431              		.loc 1 3239 0
 7432 3fb8 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 7433              	.LVL894:
3254:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7434              		.loc 1 3254 0
 7435 3fbc 08108DE2 		add	r1, sp, #8
3253:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 7436              		.loc 1 3253 0
 7437 3fc0 BE40CDE1 		strh	r4, [sp, #14]	@ movhi
3241:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 7438              		.loc 1 3241 0
 7439 3fc4 08508DE5 		str	r5, [sp, #8]
3242:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 7440              		.loc 1 3242 0
 7441 3fc8 0C60CDE5 		strb	r6, [sp, #12]
3246:../uvc.c      ****     }
 7442              		.loc 1 3246 0
 7443 3fcc 030050E3 		cmp	r0, #3
3239:../uvc.c      **** 
 7444              		.loc 1 3239 0
 7445 3fd0 0030A0E1 		mov	r3, r0
3246:../uvc.c      ****     }
 7446              		.loc 1 3246 0
 7447 3fd4 01C0A013 		movne	ip, #1
 7448 3fd8 10C0A003 		moveq	ip, #16
 7449 3fdc 022CA013 		movne	r2, #512
 7450 3fe0 012BA003 		moveq	r2, #1024
3254:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7451              		.loc 1 3254 0
 7452 3fe4 8300A0E3 		mov	r0, #131
3239:../uvc.c      **** 
 7453              		.loc 1 3239 0
 7454 3fe8 4830C7E5 		strb	r3, [r7, #72]
 7455 3fec 12C0CDE5 		strb	ip, [sp, #18]
 7456 3ff0 B021CDE1 		strh	r2, [sp, #16]	@ movhi
3254:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7457              		.loc 1 3254 0
 7458 3ff4 FEFFFFEB 		bl	CyU3PSetEpConfig
 7459              	.LVL895:
3255:../uvc.c      ****     {
 7460              		.loc 1 3255 0
 7461 3ff8 004050E2 		subs	r4, r0, #0
 7462              	.LBE105:
 7463              	.LBE104:
3378:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 7464              		.loc 1 3378 0
 7465 3ffc 30469F05 		ldreq	r4, .L644+8
 7466              	.LBB110:
 7467              	.LBB106:
3255:../uvc.c      ****     {
 7468              		.loc 1 3255 0
 7469 4000 0C00000A 		beq	.L589
 7470 4004 1F0100EA 		b	.L643
 7471              	.LVL896:
 7472              	.L632:
 7473              	.LBE106:
 7474              	.LBE110:
3424:../uvc.c      ****             {
 7475              		.loc 1 3424 0
 7476 4008 7C3094E5 		ldr	r3, [r4, #124]
 7477 400c 050053E1 		cmp	r3, r5
 7478 4010 0300000A 		beq	.L559
3424:../uvc.c      ****             {
 7479              		.loc 1 3424 0 is_stmt 0 discriminator 1
 7480 4014 B028D4E1 		ldrh	r2, [r4, #128]
 7481 4018 B238D4E1 		ldrh	r3, [r4, #130]
 7482 401c 030052E1 		cmp	r2, r3
 7483 4020 3B00000A 		beq	.L631
 7484              	.L559:
3628:../uvc.c      **** 
 7485              		.loc 1 3628 0 is_stmt 1
 7486 4024 4010A0E3 		mov	r1, #64
 7487 4028 0020A0E3 		mov	r2, #0
 7488 402c 00069FE5 		ldr	r0, .L644+8
 7489 4030 FEFFFFEB 		bl	_txe_event_flags_set
 7490              	.LVL897:
3631:../uvc.c      ****     }
 7491              		.loc 1 3631 0
 7492 4034 FEFFFFEB 		bl	_txe_thread_relinquish
 7493              	.LVL898:
 7494              	.L589:
3378:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 7495              		.loc 1 3378 0
 7496 4038 0050A0E3 		mov	r5, #0
 7497 403c 00508DE5 		str	r5, [sp]
 7498 4040 EC059FE5 		ldr	r0, .L644+8
 7499 4044 0110A0E3 		mov	r1, #1
 7500 4048 0220A0E3 		mov	r2, #2
 7501 404c 60308DE2 		add	r3, sp, #96
 7502 4050 FEFFFFEB 		bl	_txe_event_flags_get
 7503              	.LVL899:
 7504 4054 006050E2 		subs	r6, r0, #0
 7505 4058 EAFFFF0A 		beq	.L632
3535:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 7506              		.loc 1 3535 0
 7507 405c 00508DE5 		str	r5, [sp]
 7508 4060 CC059FE5 		ldr	r0, .L644+8
 7509 4064 0210A0E3 		mov	r1, #2
 7510 4068 0320A0E3 		mov	r2, #3
 7511 406c 60308DE2 		add	r3, sp, #96
 7512 4070 FEFFFFEB 		bl	_txe_event_flags_get
 7513              	.LVL900:
 7514 4074 000050E3 		cmp	r0, #0
 7515 4078 0B00001A 		bne	.L581
3550:../uvc.c      ****                 {
 7516              		.loc 1 3550 0
 7517 407c 903094E5 		ldr	r3, [r4, #144]
3538:../uvc.c      ****                 prodCount = 0;
 7518              		.loc 1 3538 0
 7519 4080 7C0084E5 		str	r0, [r4, #124]
3550:../uvc.c      ****                 {
 7520              		.loc 1 3550 0
 7521 4084 000053E3 		cmp	r3, #0
3539:../uvc.c      ****                 consCount = 0;
 7522              		.loc 1 3539 0
 7523 4088 B008C4E1 		strh	r0, [r4, #128]	@ movhi
3546:../uvc.c      ****                 pb=0;
 7524              		.loc 1 3546 0
 7525 408c B407C4E1 		strh	r0, [r4, #116]	@ movhi
3540:../uvc.c      ****                 if(0&&(prinflag == 0)){
 7526              		.loc 1 3540 0
 7527 4090 B208C4E1 		strh	r0, [r4, #130]	@ movhi
3547:../uvc.c      ****                 pbc=0;
 7528              		.loc 1 3547 0
 7529 4094 B607C4E1 		strh	r0, [r4, #118]	@ movhi
3548:../uvc.c      **** 
 7530              		.loc 1 3548 0
 7531 4098 B807C4E1 		strh	r0, [r4, #120]	@ movhi
3550:../uvc.c      ****                 {
 7532              		.loc 1 3550 0
 7533 409c 4600000A 		beq	.L633
 7534              	.L582:
3562:../uvc.c      ****             }
 7535              		.loc 1 3562 0
 7536 40a0 0030A0E3 		mov	r3, #0
 7537 40a4 903087E5 		str	r3, [r7, #144]
 7538 40a8 DDFFFFEA 		b	.L559
 7539              	.L581:
3567:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
 7540              		.loc 1 3567 0
 7541 40ac 0030E0E3 		mvn	r3, #0
 7542 40b0 00308DE5 		str	r3, [sp]
 7543 40b4 0110A0E3 		mov	r1, #1
 7544 40b8 0220A0E3 		mov	r2, #2
 7545 40bc 60308DE2 		add	r3, sp, #96
 7546 40c0 6C059FE5 		ldr	r0, .L644+8
 7547 40c4 FEFFFFEB 		bl	_txe_event_flags_get
 7548              	.LVL901:
3571:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7549              		.loc 1 3571 0
 7550 40c8 0510A0E1 		mov	r1, r5
 7551 40cc 0520A0E1 		mov	r2, r5
 7552 40d0 B4059FE5 		ldr	r0, .L644+96
 7553 40d4 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 7554              	.LVL902:
3572:../uvc.c      ****                 {
 7555              		.loc 1 3572 0
 7556 40d8 005050E2 		subs	r5, r0, #0
 7557 40dc 9D00001A 		bne	.L634
3580:../uvc.c      ****                 {
 7558              		.loc 1 3580 0
 7559 40e0 883094E5 		ldr	r3, [r4, #136]
 7560 40e4 000053E3 		cmp	r3, #0
 7561 40e8 2B00001A 		bne	.L580
 7562              	.LVL903:
 7563              	.LBB111:
 7564              	.LBB112:
3283:../uvc.c      ****     {
 7565              		.loc 1 3283 0
 7566 40ec 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 7567 40f0 030053E3 		cmp	r3, #3
 7568 40f4 5E00000A 		beq	.L635
3288:../uvc.c      ****     {
 7569              		.loc 1 3288 0
 7570 40f8 020053E3 		cmp	r3, #2
 7571 40fc 7400000A 		beq	.L636
 7572              	.LVL904:
 7573              	.L587:
 7574              	.LBE112:
 7575              	.LBE111:
3616:../uvc.c      ****                     CyU3PThreadSleep(200);
 7576              		.loc 1 3616 0
 7577 4100 0130A0E3 		mov	r3, #1
3617:../uvc.c      ****                     
 7578              		.loc 1 3617 0
 7579 4104 C800A0E3 		mov	r0, #200
3616:../uvc.c      ****                     CyU3PThreadSleep(200);
 7580              		.loc 1 3616 0
 7581 4108 883087E5 		str	r3, [r7, #136]
3617:../uvc.c      ****                     
 7582              		.loc 1 3617 0
 7583 410c FEFFFFEB 		bl	_tx_thread_sleep
 7584              	.LVL905:
 7585 4110 C3FFFFEA 		b	.L559
 7586              	.L631:
3450:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 7587              		.loc 1 3450 0
 7588 4114 74559FE5 		ldr	r5, .L644+100
3449:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 7589              		.loc 1 3449 0
 7590 4118 5C059FE5 		ldr	r0, .L644+80
 7591 411c 0010E0E3 		mvn	r1, #0
3434:../uvc.c      ****                 consCount = 0;
 7592              		.loc 1 3434 0
 7593 4120 B068C4E1 		strh	r6, [r4, #128]	@ movhi
3431:../uvc.c      ****             	pb=0;
 7594              		.loc 1 3431 0
 7595 4124 B467C4E1 		strh	r6, [r4, #116]	@ movhi
3435:../uvc.c      ****                 hitFV     = CyFalse;
 7596              		.loc 1 3435 0
 7597 4128 B268C4E1 		strh	r6, [r4, #130]	@ movhi
3432:../uvc.c      ****             	pbc=0;
 7598              		.loc 1 3432 0
 7599 412c B667C4E1 		strh	r6, [r4, #118]	@ movhi
3433:../uvc.c      ****                 prodCount = 0;
 7600              		.loc 1 3433 0
 7601 4130 B867C4E1 		strh	r6, [r4, #120]	@ movhi
3436:../uvc.c      **** 
 7602              		.loc 1 3436 0
 7603 4134 7C6084E5 		str	r6, [r4, #124]
3449:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 7604              		.loc 1 3449 0
 7605 4138 FEFFFFEB 		bl	_txe_mutex_get
 7606              	.LVL906:
3450:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 7607              		.loc 1 3450 0
 7608 413c ED34D5E5 		ldrb	r3, [r5, #1261]	@ zero_extendqisi2
 7609 4140 013023E2 		eor	r3, r3, #1
 7610 4144 ED34C5E5 		strb	r3, [r5, #1261]
3452:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 7611              		.loc 1 3452 0
 7612 4148 7230D4E5 		ldrb	r3, [r4, #114]	@ zero_extendqisi2
 7613 414c F00053E3 		cmp	r3, #240
 7614 4150 3B00000A 		beq	.L637
 7615              	.L560:
3460:../uvc.c      **** 
 7616              		.loc 1 3460 0
 7617 4154 7230D7E5 		ldrb	r3, [r7, #114]	@ zero_extendqisi2
 7618 4158 FF0053E3 		cmp	r3, #255
 7619 415c 1D00000A 		beq	.L638
3472:../uvc.c      ****                     //CyU3PThreadSleep(400);
 7620              		.loc 1 3472 0
 7621 4160 7230D4E5 		ldrb	r3, [r4, #114]	@ zero_extendqisi2
 7622 4164 AA0053E3 		cmp	r3, #170
 7623 4168 2700000A 		beq	.L639
 7624              	.L561:
3510:../uvc.c      ****                 /* Reset the DMA channel. */
 7625              		.loc 1 3510 0
 7626 416c 08059FE5 		ldr	r0, .L644+80
 7627 4170 FEFFFFEB 		bl	_txe_mutex_put
 7628              	.LVL907:
3512:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7629              		.loc 1 3512 0
 7630 4174 10059FE5 		ldr	r0, .L644+96
 7631 4178 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 7632              	.LVL908:
3513:../uvc.c      ****                 {
 7633              		.loc 1 3513 0
 7634 417c 005050E2 		subs	r5, r0, #0
 7635 4180 7A00001A 		bne	.L640
3520:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7636              		.loc 1 3520 0
 7637 4184 0510A0E1 		mov	r1, r5
 7638 4188 0520A0E1 		mov	r2, r5
 7639 418c F8049FE5 		ldr	r0, .L644+96
 7640              	.LVL909:
 7641 4190 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 7642              	.LVL910:
3521:../uvc.c      ****                 {
 7643              		.loc 1 3521 0
 7644 4194 005050E2 		subs	r5, r0, #0
 7645 4198 6800001A 		bne	.L641
 7646              	.L580:
3529:../uvc.c      ****                 }
 7647              		.loc 1 3529 0
 7648 419c DC049FE5 		ldr	r0, .L644+84
 7649              	.LVL911:
 7650 41a0 0230A0E3 		mov	r3, #2
 7651 41a4 0010A0E3 		mov	r1, #0
 7652 41a8 00308DE5 		str	r3, [sp]
 7653 41ac 0020A0E1 		mov	r2, r0
 7654 41b0 0130A0E1 		mov	r3, r1
 7655 41b4 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 7656              	.LVL912:
 7657 41b8 99FFFFEA 		b	.L559
 7658              	.LVL913:
 7659              	.L633:
3552:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 7660              		.loc 1 3552 0
 7661 41bc C8049FE5 		ldr	r0, .L644+96
 7662 41c0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 7663              	.LVL914:
3553:../uvc.c      ****                     {
 7664              		.loc 1 3553 0
 7665 41c4 000050E3 		cmp	r0, #0
 7666 41c8 4000001A 		bne	.L612
3559:../uvc.c      ****                 }
 7667              		.loc 1 3559 0
 7668 41cc 8300A0E3 		mov	r0, #131
 7669              	.LVL915:
 7670 41d0 FEFFFFEB 		bl	CyU3PUsbFlushEp
 7671              	.LVL916:
 7672 41d4 B1FFFFEA 		b	.L582
 7673              	.L638:
3462:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 7674              		.loc 1 3462 0
 7675 41d8 E130D4E5 		ldrb	r3, [r4, #225]	@ zero_extendqisi2
 7676 41dc 020053E3 		cmp	r3, #2
 7677 41e0 013083E2 		add	r3, r3, #1
 7678 41e4 E130C4E5 		strb	r3, [r4, #225]
 7679 41e8 DFFFFF9A 		bls	.L561
3463:../uvc.c      ****                 		stiflag = 0x0F;
 7680              		.loc 1 3463 0
 7681 41ec ED14D5E5 		ldrb	r1, [r5, #1261]	@ zero_extendqisi2
3464:../uvc.c      ****                 		IMcount = 0;
 7682              		.loc 1 3464 0
 7683 41f0 0F30A0E3 		mov	r3, #15
3463:../uvc.c      ****                 		stiflag = 0x0F;
 7684              		.loc 1 3463 0
 7685 41f4 201081E3 		orr	r1, r1, #32
3465:../uvc.c      ****                 		}
 7686              		.loc 1 3465 0
 7687 41f8 0020A0E3 		mov	r2, #0
3463:../uvc.c      ****                 		stiflag = 0x0F;
 7688              		.loc 1 3463 0
 7689 41fc ED14C5E5 		strb	r1, [r5, #1261]
3465:../uvc.c      ****                 		}
 7690              		.loc 1 3465 0
 7691 4200 E120C4E5 		strb	r2, [r4, #225]
3464:../uvc.c      ****                 		IMcount = 0;
 7692              		.loc 1 3464 0
 7693 4204 7230C4E5 		strb	r3, [r4, #114]
 7694 4208 D7FFFFEA 		b	.L561
 7695              	.L639:
3478:../uvc.c      ****                 	{
 7696              		.loc 1 3478 0
 7697 420c E130D4E5 		ldrb	r3, [r4, #225]	@ zero_extendqisi2
 7698 4210 020053E3 		cmp	r3, #2
 7699 4214 013083E2 		add	r3, r3, #1
 7700 4218 E130C4E5 		strb	r3, [r4, #225]
 7701 421c D2FFFF9A 		bls	.L561
3480:../uvc.c      ****                      {
 7702              		.loc 1 3480 0
 7703 4220 7030D4E5 		ldrb	r3, [r4, #112]	@ zero_extendqisi2
 7704 4224 013043E2 		sub	r3, r3, #1
 7705 4228 030053E3 		cmp	r3, #3
 7706 422c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 7707 4230 3E0000EA 		b	.L565
 7708              	.L567:
 7709 4234 F0420000 		.word	.L566
 7710 4238 DC430000 		.word	.L568
 7711 423c 20440000 		.word	.L569
 7712 4240 88430000 		.word	.L570
 7713              	.L637:
3452:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 7714              		.loc 1 3452 0 discriminator 1
 7715 4244 00608DE5 		str	r6, [sp]
 7716 4248 E4039FE5 		ldr	r0, .L644+8
 7717 424c 8010A0E3 		mov	r1, #128
 7718 4250 0320A0E3 		mov	r2, #3
 7719 4254 60308DE2 		add	r3, sp, #96
 7720 4258 FEFFFFEB 		bl	_txe_event_flags_get
 7721              	.LVL917:
 7722 425c 000050E3 		cmp	r0, #0
 7723 4260 BBFFFF1A 		bne	.L560
3457:../uvc.c      ****                 		IMcount = 0;
 7724              		.loc 1 3457 0
 7725 4264 0030E0E3 		mvn	r3, #0
3458:../uvc.c      ****                 	}
 7726              		.loc 1 3458 0
 7727 4268 E100C4E5 		strb	r0, [r4, #225]
3457:../uvc.c      ****                 		IMcount = 0;
 7728              		.loc 1 3457 0
 7729 426c 7230C4E5 		strb	r3, [r4, #114]
3458:../uvc.c      ****                 	}
 7730              		.loc 1 3458 0
 7731 4270 BDFFFFEA 		b	.L561
 7732              	.LVL918:
 7733              	.L635:
 7734              	.LBB115:
 7735              	.LBB113:
3285:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 7736              		.loc 1 3285 0
 7737 4274 18149FE5 		ldr	r1, .L644+104
 7738 4278 0100A0E3 		mov	r0, #1
 7739              	.LVL919:
 7740 427c FEFFFFEB 		bl	CyU3PDebugPrint
 7741              	.LVL920:
3286:../uvc.c      ****     }
 7742              		.loc 1 3286 0
 7743 4280 10049FE5 		ldr	r0, .L644+108
 7744 4284 FEFFFFEB 		bl	CyU3PGpifLoad
 7745              	.LVL921:
 7746 4288 0050A0E1 		mov	r5, r0
 7747              	.LVL922:
 7748              	.L586:
3293:../uvc.c      ****     {
 7749              		.loc 1 3293 0
 7750 428c 000055E3 		cmp	r5, #0
 7751 4290 8800001A 		bne	.L642
 7752              	.LVL923:
3305:../uvc.c      ****     {
 7753              		.loc 1 3305 0
 7754 4294 4830D7E5 		ldrb	r3, [r7, #72]	@ zero_extendqisi2
 7755 4298 023043E2 		sub	r3, r3, #2
 7756 429c FF3003E2 		and	r3, r3, #255
 7757 42a0 010053E3 		cmp	r3, #1
 7758 42a4 95FFFF8A 		bhi	.L587
3303:../uvc.c      ****     }
 7759              		.loc 1 3303 0
 7760 42a8 0500A0E1 		mov	r0, r5
 7761 42ac 0510A0E1 		mov	r1, r5
 7762 42b0 FEFFFFEB 		bl	CyU3PGpifSMStart
 7763              	.LVL924:
3309:../uvc.c      ****     {
 7764              		.loc 1 3309 0
 7765 42b4 005050E2 		subs	r5, r0, #0
 7766 42b8 90FFFF0A 		beq	.L587
3312:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7767              		.loc 1 3312 0
 7768 42bc 0400A0E3 		mov	r0, #4
 7769              	.LVL925:
 7770 42c0 D4139FE5 		ldr	r1, .L644+112
 7771 42c4 0520A0E1 		mov	r2, r5
 7772 42c8 FEFFFFEB 		bl	CyU3PDebugPrint
 7773              	.LVL926:
3313:../uvc.c      ****     }
 7774              		.loc 1 3313 0
 7775 42cc 0500A0E1 		mov	r0, r5
 7776              	.LVL927:
 7777              	.L612:
3297:../uvc.c      ****     }
 7778              		.loc 1 3297 0
 7779 42d0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7780              	.LVL928:
 7781              	.L636:
3290:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 7782              		.loc 1 3290 0
 7783 42d4 C4139FE5 		ldr	r1, .L644+116
 7784 42d8 0100A0E3 		mov	r0, #1
 7785              	.LVL929:
 7786 42dc FEFFFFEB 		bl	CyU3PDebugPrint
 7787              	.LVL930:
3291:../uvc.c      ****     }
 7788              		.loc 1 3291 0
 7789 42e0 BC039FE5 		ldr	r0, .L644+120
 7790 42e4 FEFFFFEB 		bl	CyU3PGpifLoad
 7791              	.LVL931:
 7792 42e8 0050A0E1 		mov	r5, r0
 7793              	.LVL932:
 7794 42ec E6FFFFEA 		b	.L586
 7795              	.LVL933:
 7796              	.L566:
 7797              	.LBE113:
 7798              	.LBE115:
3483:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 7799              		.loc 1 3483 0
 7800 42f0 6C2097E5 		ldr	r2, [r7, #108]
 7801 42f4 3010A0E3 		mov	r1, #48
 7802 42f8 000052E3 		cmp	r2, #0
 7803 42fc E420A003 		moveq	r2, #228
 7804 4300 6420A013 		movne	r2, #100
 7805 4304 5230A0E3 		mov	r3, #82
 7806 4308 0100A0E3 		mov	r0, #1
 7807 430c FEFFFFEB 		bl	SensorSetIrisControl
 7808              	.LVL934:
3485:../uvc.c      ****                  		break;
 7809              		.loc 1 3485 0
 7810 4310 6C2097E5 		ldr	r2, [r7, #108]
 7811 4314 0400A0E3 		mov	r0, #4
 7812 4318 000052E3 		cmp	r2, #0
 7813 431c 6C3097E5 		ldr	r3, [r7, #108]
 7814 4320 E420A003 		moveq	r2, #228
 7815 4324 6420A013 		movne	r2, #100
 7816 4328 78139FE5 		ldr	r1, .L644+124
 7817 432c FEFFFFEB 		bl	CyU3PDebugPrint
 7818              	.LVL935:
 7819              	.L565:
3505:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 7820              		.loc 1 3505 0
 7821 4330 0030A0E3 		mov	r3, #0
 7822 4334 E130C7E5 		strb	r3, [r7, #225]
3507:../uvc.c      ****                 	}
 7823              		.loc 1 3507 0
 7824 4338 7230C7E5 		strb	r3, [r7, #114]
 7825 433c 8AFFFFEA 		b	.L561
 7826              	.LVL936:
 7827              	.L641:
3523:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 7828              		.loc 1 3523 0
 7829 4340 0400A0E3 		mov	r0, #4
 7830              	.LVL937:
 7831 4344 60139FE5 		ldr	r1, .L644+128
 7832 4348 0520A0E1 		mov	r2, r5
 7833 434c FEFFFFEB 		bl	CyU3PDebugPrint
 7834              	.LVL938:
3524:../uvc.c      ****                 }
 7835              		.loc 1 3524 0
 7836 4350 0500A0E1 		mov	r0, r5
 7837 4354 FEFFFFEB 		bl	CyFxAppErrorHandler
 7838              	.LVL939:
 7839              	.L634:
3575:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 7840              		.loc 1 3575 0
 7841 4358 0400A0E3 		mov	r0, #4
 7842              	.LVL940:
 7843 435c 4C139FE5 		ldr	r1, .L644+132
 7844 4360 0520A0E1 		mov	r2, r5
 7845 4364 FEFFFFEB 		bl	CyU3PDebugPrint
 7846              	.LVL941:
3576:../uvc.c      ****                 }
 7847              		.loc 1 3576 0
 7848 4368 0500A0E1 		mov	r0, r5
 7849 436c FEFFFFEB 		bl	CyFxAppErrorHandler
 7850              	.LVL942:
 7851              	.L640:
3515:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 7852              		.loc 1 3515 0
 7853 4370 0400A0E3 		mov	r0, #4
 7854              	.LVL943:
 7855 4374 38139FE5 		ldr	r1, .L644+136
 7856 4378 0520A0E1 		mov	r2, r5
 7857 437c FEFFFFEB 		bl	CyU3PDebugPrint
 7858              	.LVL944:
3516:../uvc.c      ****                 }
 7859              		.loc 1 3516 0
 7860 4380 0500A0E1 		mov	r0, r5
 7861 4384 FEFFFFEB 		bl	CyFxAppErrorHandler
 7862              	.LVL945:
 7863              	.L570:
3498:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 7864              		.loc 1 3498 0
 7865 4388 6C2097E5 		ldr	r2, [r7, #108]
 7866 438c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 7867 4390 000052E3 		cmp	r2, #0
 7868 4394 F420A003 		moveq	r2, #244
 7869 4398 7420A013 		movne	r2, #116
 7870 439c 032082E1 		orr	r2, r2, r3
 7871 43a0 3010A0E3 		mov	r1, #48
 7872 43a4 5230A0E3 		mov	r3, #82
 7873 43a8 0100A0E3 		mov	r0, #1
 7874 43ac FEFFFFEB 		bl	SensorSetIrisControl
 7875              	.LVL946:
3500:../uvc.c      ****                  		break;
 7876              		.loc 1 3500 0
 7877 43b0 6C1097E5 		ldr	r1, [r7, #108]
 7878 43b4 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 7879 43b8 000051E3 		cmp	r1, #0
 7880 43bc F410A003 		moveq	r1, #244
 7881 43c0 7410A013 		movne	r1, #116
 7882 43c4 022081E1 		orr	r2, r1, r2
 7883 43c8 6C3097E5 		ldr	r3, [r7, #108]
 7884 43cc D4129FE5 		ldr	r1, .L644+124
 7885 43d0 0400A0E3 		mov	r0, #4
 7886 43d4 FEFFFFEB 		bl	CyU3PDebugPrint
 7887              	.LVL947:
3501:../uvc.c      ****                  	default:
 7888              		.loc 1 3501 0
 7889 43d8 D4FFFFEA 		b	.L565
 7890              	.L568:
3488:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 7891              		.loc 1 3488 0
 7892 43dc 6C2097E5 		ldr	r2, [r7, #108]
 7893 43e0 3010A0E3 		mov	r1, #48
 7894 43e4 000052E3 		cmp	r2, #0
 7895 43e8 D420A003 		moveq	r2, #212
 7896 43ec 5420A013 		movne	r2, #84
 7897 43f0 5230A0E3 		mov	r3, #82
 7898 43f4 0100A0E3 		mov	r0, #1
 7899 43f8 FEFFFFEB 		bl	SensorSetIrisControl
 7900              	.LVL948:
3490:../uvc.c      ****                  		break;
 7901              		.loc 1 3490 0
 7902 43fc 6C2097E5 		ldr	r2, [r7, #108]
 7903 4400 A0129FE5 		ldr	r1, .L644+124
 7904 4404 000052E3 		cmp	r2, #0
 7905 4408 6C3097E5 		ldr	r3, [r7, #108]
 7906 440c D420A003 		moveq	r2, #212
 7907 4410 5420A013 		movne	r2, #84
 7908 4414 0400A0E3 		mov	r0, #4
 7909 4418 FEFFFFEB 		bl	CyU3PDebugPrint
 7910              	.LVL949:
3491:../uvc.c      ****                  	case 3: //720
 7911              		.loc 1 3491 0
 7912 441c C3FFFFEA 		b	.L565
 7913              	.L569:
3493:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 7914              		.loc 1 3493 0
 7915 4420 6C2097E5 		ldr	r2, [r7, #108]
 7916 4424 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 7917 4428 000052E3 		cmp	r2, #0
 7918 442c C420A003 		moveq	r2, #196
 7919 4430 4420A013 		movne	r2, #68
 7920 4434 032082E1 		orr	r2, r2, r3
 7921 4438 3010A0E3 		mov	r1, #48
 7922 443c 5230A0E3 		mov	r3, #82
 7923 4440 0100A0E3 		mov	r0, #1
 7924 4444 FEFFFFEB 		bl	SensorSetIrisControl
 7925              	.LVL950:
3495:../uvc.c      ****                  		break;
 7926              		.loc 1 3495 0
 7927 4448 6C1097E5 		ldr	r1, [r7, #108]
 7928 444c 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 7929 4450 000051E3 		cmp	r1, #0
 7930 4454 C410A003 		moveq	r1, #196
 7931 4458 4410A013 		movne	r1, #68
 7932 445c 022081E1 		orr	r2, r1, r2
 7933 4460 6C3097E5 		ldr	r3, [r7, #108]
 7934 4464 3C129FE5 		ldr	r1, .L644+124
 7935 4468 0400A0E3 		mov	r0, #4
 7936 446c FEFFFFEB 		bl	CyU3PDebugPrint
 7937              	.LVL951:
3496:../uvc.c      ****                  	case 4: //VGA
 7938              		.loc 1 3496 0
 7939 4470 AEFFFFEA 		b	.L565
 7940              	.LVL952:
 7941              	.L613:
 7942              	.LBB116:
 7943              	.LBB100:
2792:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7944              		.loc 1 2792 0
 7945 4474 0400A0E3 		mov	r0, #4
 7946              	.LVL953:
 7947 4478 38129FE5 		ldr	r1, .L644+140
 7948 447c FEFFFFEB 		bl	CyU3PDebugPrint
 7949              	.LVL954:
2793:../uvc.c      ****     }
 7950              		.loc 1 2793 0
 7951 4480 0400A0E1 		mov	r0, r4
 7952 4484 FEFFFFEB 		bl	CyFxAppErrorHandler
 7953              	.LVL955:
 7954              	.L643:
 7955              	.LBE100:
 7956              	.LBE116:
 7957              	.LBB117:
 7958              	.LBB107:
3258:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7959              		.loc 1 3258 0
 7960 4488 0800A0E1 		mov	r0, r8
 7961              	.LVL956:
 7962              	.L610:
 7963 448c 28129FE5 		ldr	r1, .L644+144
 7964 4490 0420A0E1 		mov	r2, r4
 7965 4494 FEFFFFEB 		bl	CyU3PDebugPrint
 7966              	.LVL957:
3259:../uvc.c      ****     }
 7967              		.loc 1 3259 0
 7968 4498 0400A0E1 		mov	r0, r4
 7969 449c 8BFFFFEA 		b	.L612
 7970              	.LVL958:
 7971              	.L629:
3233:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7972              		.loc 1 3233 0
 7973 44a0 0800A0E1 		mov	r0, r8
 7974              	.LVL959:
 7975 44a4 14129FE5 		ldr	r1, .L644+148
 7976 44a8 0420A0E1 		mov	r2, r4
 7977 44ac FEFFFFEB 		bl	CyU3PDebugPrint
 7978              	.LVL960:
3234:../uvc.c      ****     }
 7979              		.loc 1 3234 0
 7980 44b0 0400A0E1 		mov	r0, r4
 7981 44b4 FEFFFFEB 		bl	CyFxAppErrorHandler
 7982              	.LVL961:
 7983              	.L642:
 7984              	.LBE107:
 7985              	.LBE117:
 7986              	.LBB118:
 7987              	.LBB114:
3296:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7988              		.loc 1 3296 0
 7989 44b8 0400A0E3 		mov	r0, #4
 7990              	.LVL962:
 7991 44bc 00129FE5 		ldr	r1, .L644+152
 7992 44c0 0520A0E1 		mov	r2, r5
 7993 44c4 FEFFFFEB 		bl	CyU3PDebugPrint
 7994              	.LVL963:
3297:../uvc.c      ****     }
 7995              		.loc 1 3297 0
 7996 44c8 0500A0E1 		mov	r0, r5
 7997 44cc 7FFFFFEA 		b	.L612
 7998              	.LVL964:
 7999              	.L617:
 8000              	.LBE114:
 8001              	.LBE118:
 8002              	.LBB119:
 8003              	.LBB108:
2949:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8004              		.loc 1 2949 0
 8005 44d0 0400A0E3 		mov	r0, #4
 8006              	.LVL965:
 8007 44d4 EC119FE5 		ldr	r1, .L644+156
 8008 44d8 0520A0E1 		mov	r2, r5
 8009 44dc FEFFFFEB 		bl	CyU3PDebugPrint
 8010              	.LVL966:
2950:../uvc.c      ****     }
 8011              		.loc 1 2950 0
 8012 44e0 0500A0E1 		mov	r0, r5
 8013 44e4 FEFFFFEB 		bl	CyFxAppErrorHandler
 8014              	.LVL967:
 8015              	.L616:
2927:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8016              		.loc 1 2927 0
 8017 44e8 0400A0E3 		mov	r0, #4
 8018              	.LVL968:
 8019 44ec D8119FE5 		ldr	r1, .L644+160
 8020 44f0 0520A0E1 		mov	r2, r5
 8021 44f4 FEFFFFEB 		bl	CyU3PDebugPrint
 8022              	.LVL969:
2928:../uvc.c      ****     }
 8023              		.loc 1 2928 0
 8024 44f8 0500A0E1 		mov	r0, r5
 8025 44fc FEFFFFEB 		bl	CyFxAppErrorHandler
 8026              	.LVL970:
 8027              	.L615:
 8028              	.LBE108:
 8029              	.LBE119:
 8030              	.LBB120:
 8031              	.LBB103:
2853:../uvc.c      ****         CyFxAppErrorHandler (status);
 8032              		.loc 1 2853 0
 8033 4500 0400A0E3 		mov	r0, #4
 8034              	.LVL971:
 8035 4504 C4119FE5 		ldr	r1, .L644+164
 8036 4508 FEFFFFEB 		bl	CyU3PDebugPrint
 8037              	.LVL972:
2854:../uvc.c      ****     }
 8038              		.loc 1 2854 0
 8039 450c 0500A0E1 		mov	r0, r5
 8040 4510 FEFFFFEB 		bl	CyFxAppErrorHandler
 8041              	.LVL973:
 8042              	.L614:
2840:../uvc.c      ****         CyFxAppErrorHandler (status);
 8043              		.loc 1 2840 0
 8044 4514 0400A0E3 		mov	r0, #4
 8045              	.LVL974:
 8046 4518 B4119FE5 		ldr	r1, .L644+168
 8047 451c FEFFFFEB 		bl	CyU3PDebugPrint
 8048              	.LVL975:
2841:../uvc.c      ****     }
 8049              		.loc 1 2841 0
 8050 4520 0500A0E1 		mov	r0, r5
 8051 4524 FEFFFFEB 		bl	CyFxAppErrorHandler
 8052              	.LVL976:
 8053              	.L625:
 8054              	.LBE103:
 8055              	.LBE120:
 8056              	.LBB121:
 8057              	.LBB109:
3045:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8058              		.loc 1 3045 0
 8059 4528 0400A0E3 		mov	r0, #4
 8060              	.LVL977:
 8061 452c A4119FE5 		ldr	r1, .L644+172
 8062 4530 0420A0E1 		mov	r2, r4
 8063 4534 FEFFFFEB 		bl	CyU3PDebugPrint
 8064              	.LVL978:
3046:../uvc.c      ****     }
 8065              		.loc 1 3046 0
 8066 4538 0400A0E1 		mov	r0, r4
 8067 453c FEFFFFEB 		bl	CyFxAppErrorHandler
 8068              	.LVL979:
 8069              	.L624:
3024:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8070              		.loc 1 3024 0
 8071 4540 0400A0E3 		mov	r0, #4
 8072              	.LVL980:
 8073 4544 90119FE5 		ldr	r1, .L644+176
 8074 4548 0420A0E1 		mov	r2, r4
 8075 454c FEFFFFEB 		bl	CyU3PDebugPrint
 8076              	.LVL981:
3025:../uvc.c      ****     }
 8077              		.loc 1 3025 0
 8078 4550 0400A0E1 		mov	r0, r4
 8079 4554 FEFFFFEB 		bl	CyFxAppErrorHandler
 8080              	.LVL982:
 8081              	.L623:
3011:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8082              		.loc 1 3011 0
 8083 4558 0400A0E3 		mov	r0, #4
 8084              	.LVL983:
 8085 455c 7C119FE5 		ldr	r1, .L644+180
 8086 4560 0420A0E1 		mov	r2, r4
 8087 4564 FEFFFFEB 		bl	CyU3PDebugPrint
 8088              	.LVL984:
3012:../uvc.c      ****     }
 8089              		.loc 1 3012 0
 8090 4568 0400A0E1 		mov	r0, r4
 8091 456c FEFFFFEB 		bl	CyFxAppErrorHandler
 8092              	.LVL985:
 8093              	.L622:
2997:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8094              		.loc 1 2997 0
 8095 4570 0400A0E3 		mov	r0, #4
 8096              	.LVL986:
 8097 4574 68119FE5 		ldr	r1, .L644+184
 8098 4578 0420A0E1 		mov	r2, r4
 8099 457c FEFFFFEB 		bl	CyU3PDebugPrint
 8100              	.LVL987:
2998:../uvc.c      ****     }
 8101              		.loc 1 2998 0
 8102 4580 0400A0E1 		mov	r0, r4
 8103 4584 FEFFFFEB 		bl	CyFxAppErrorHandler
 8104              	.LVL988:
 8105              	.L621:
2983:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8106              		.loc 1 2983 0
 8107 4588 0400A0E3 		mov	r0, #4
 8108              	.LVL989:
 8109 458c 54119FE5 		ldr	r1, .L644+188
 8110 4590 0620A0E1 		mov	r2, r6
 8111 4594 FEFFFFEB 		bl	CyU3PDebugPrint
 8112              	.LVL990:
2984:../uvc.c      ****     }
 8113              		.loc 1 2984 0
 8114 4598 0600A0E1 		mov	r0, r6
 8115 459c FEFFFFEB 		bl	CyFxAppErrorHandler
 8116              	.LVL991:
 8117              	.L620:
2970:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8118              		.loc 1 2970 0
 8119 45a0 0400A0E3 		mov	r0, #4
 8120              	.LVL992:
 8121 45a4 40119FE5 		ldr	r1, .L644+192
 8122 45a8 0520A0E1 		mov	r2, r5
 8123 45ac FEFFFFEB 		bl	CyU3PDebugPrint
 8124              	.LVL993:
2971:../uvc.c      ****     }
 8125              		.loc 1 2971 0
 8126 45b0 0500A0E1 		mov	r0, r5
 8127 45b4 FEFFFFEB 		bl	CyFxAppErrorHandler
 8128              	.LVL994:
 8129              	.L619:
2964:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8130              		.loc 1 2964 0
 8131 45b8 0400A0E3 		mov	r0, #4
 8132              	.LVL995:
 8133 45bc 2C119FE5 		ldr	r1, .L644+196
 8134 45c0 0520A0E1 		mov	r2, r5
 8135 45c4 FEFFFFEB 		bl	CyU3PDebugPrint
 8136              	.LVL996:
2965:../uvc.c      ****     }
 8137              		.loc 1 2965 0
 8138 45c8 0500A0E1 		mov	r0, r5
 8139 45cc FEFFFFEB 		bl	CyFxAppErrorHandler
 8140              	.LVL997:
 8141              	.L618:
2958:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8142              		.loc 1 2958 0
 8143 45d0 0400A0E3 		mov	r0, #4
 8144              	.LVL998:
 8145 45d4 18119FE5 		ldr	r1, .L644+200
 8146 45d8 0520A0E1 		mov	r2, r5
 8147 45dc FEFFFFEB 		bl	CyU3PDebugPrint
 8148              	.LVL999:
2959:../uvc.c      ****     }
 8149              		.loc 1 2959 0
 8150 45e0 0500A0E1 		mov	r0, r5
 8151 45e4 FEFFFFEB 		bl	CyFxAppErrorHandler
 8152              	.LVL1000:
 8153              	.L628:
3142:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8154              		.loc 1 3142 0
 8155 45e8 0800A0E1 		mov	r0, r8
 8156              	.LVL1001:
 8157 45ec 04119FE5 		ldr	r1, .L644+204
 8158 45f0 0420A0E1 		mov	r2, r4
 8159 45f4 FEFFFFEB 		bl	CyU3PDebugPrint
 8160              	.LVL1002:
3143:../uvc.c      ****     }
 8161              		.loc 1 3143 0
 8162 45f8 0400A0E1 		mov	r0, r4
 8163 45fc FEFFFFEB 		bl	CyFxAppErrorHandler
 8164              	.LVL1003:
 8165              	.L626:
3111:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 8166              		.loc 1 3111 0
 8167 4600 0400A0E3 		mov	r0, #4
 8168              	.LVL1004:
 8169 4604 F0109FE5 		ldr	r1, .L644+208
 8170 4608 0420A0E1 		mov	r2, r4
 8171 460c FEFFFFEB 		bl	CyU3PDebugPrint
 8172              	.LVL1005:
3112:../uvc.c      ****     }
 8173              		.loc 1 3112 0
 8174 4610 0400A0E1 		mov	r0, r4
 8175 4614 FEFFFFEB 		bl	CyFxAppErrorHandler
 8176              	.LVL1006:
 8177              	.L627:
3118:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
 8178              		.loc 1 3118 0
 8179 4618 0400A0E3 		mov	r0, #4
 8180 461c DC109FE5 		ldr	r1, .L644+212
 8181 4620 FEFFFFEB 		bl	CyU3PDebugPrint
 8182              	.LVL1007:
3119:../uvc.c      ****     }
 8183              		.loc 1 3119 0
 8184 4624 0800A0E1 		mov	r0, r8
 8185 4628 FEFFFFEB 		bl	CyFxAppErrorHandler
 8186              	.LVL1008:
 8187              	.L645:
 8188              		.align	2
 8189              	.L644:
 8190 462c 00C20100 		.word	115200
 8191 4630 A0860100 		.word	100000
 8192 4634 00000000 		.word	.LANCHOR0
 8193 4638 00000000 		.word	CyFxGpifCB
 8194 463c 88130000 		.word	5000
 8195 4640 00000000 		.word	CyFxUVCApplnUSBSetupCB
 8196 4644 00000000 		.word	CyFxUVCApplnUSBEventCB
 8197 4648 00000000 		.word	CyFxUSBDeviceDscr
 8198 464c 00000000 		.word	CyFxUSBDeviceDscrSS
 8199 4650 00000000 		.word	CyFxUSBDeviceQualDscr
 8200 4654 00000000 		.word	CyFxUSBBOSDscr
 8201 4658 00000000 		.word	CyFxUSBHSConfigDscr
 8202 465c 00000000 		.word	CyFxUSBFSConfigDscr
 8203 4660 00000000 		.word	CyFxUSBSSConfigDscr
 8204 4664 00000000 		.word	CyFxUSBStringLangIDDscr
 8205 4668 00000000 		.word	CyFxUSBManufactureDscr
 8206 466c 00000000 		.word	CyFxUSBProductDscr
 8207 4670 013F0203 		.word	50478849
 8208 4674 00000000 		.word	glChHandleInterStat
 8209 4678 00000000 		.word	glInterStaBuffer
 8210 467c 00000000 		.word	imgHdMux
 8211 4680 01010000 		.word	257
 8212 4684 03030000 		.word	771
 8213 4688 00000000 		.word	CyFxUvcApplnDmaCallback
 8214 468c 00000000 		.word	glChHandleUVCStream
 8215 4690 00000000 		.word	.LANCHOR1
 8216 4694 400B0000 		.word	.LC65
 8217 4698 20010000 		.word	.LANCHOR2+288
 8218 469c 980B0000 		.word	.LC68
 8219 46a0 500B0000 		.word	.LC66
 8220 46a4 3C010000 		.word	.LANCHOR2+316
 8221 46a8 880A0000 		.word	.LC61
 8222 46ac D80A0000 		.word	.LC63
 8223 46b0 0C0B0000 		.word	.LC64
 8224 46b4 AC0A0000 		.word	.LC62
 8225 46b8 5C070000 		.word	.LC43
 8226 46bc 84090000 		.word	.LC56
 8227 46c0 600A0000 		.word	.LC60
 8228 46c4 600B0000 		.word	.LC67
 8229 46c8 E0070000 		.word	.LC47
 8230 46cc B4070000 		.word	.LC46
 8231 46d0 98070000 		.word	.LC45
 8232 46d4 7C070000 		.word	.LC44
 8233 46d8 54090000 		.word	.LC55
 8234 46dc 24090000 		.word	.LC54
 8235 46e0 EC080000 		.word	.LC53
 8236 46e4 B8080000 		.word	.LC52
 8237 46e8 84080000 		.word	.LC51
 8238 46ec 58080000 		.word	.LC50
 8239 46f0 2C080000 		.word	.LC49
 8240 46f4 04080000 		.word	.LC48
 8241 46f8 300A0000 		.word	.LC59
 8242 46fc B8090000 		.word	.LC57
 8243 4700 F8090000 		.word	.LC58
 8244              	.LBE109:
 8245              	.LBE121:
 8246              		.cfi_endproc
 8247              	.LFE19:
 8249              		.align	2
 8250              		.global	UVCAppEP0Thread_Entry
 8252              	UVCAppEP0Thread_Entry:
 8253              	.LFB25:
4428:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 8254              		.loc 1 4428 0
 8255              		.cfi_startproc
 8256              		@ args = 0, pretend = 0, frame = 72
 8257              		@ frame_needed = 0, uses_anonymous_args = 0
 8258              	.LVL1009:
 8259 4704 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 8260              	.LCFI27:
 8261              		.cfi_def_cfa_offset 36
 8262              		.cfi_offset 4, -36
 8263              		.cfi_offset 5, -32
 8264              		.cfi_offset 6, -28
 8265              		.cfi_offset 7, -24
 8266              		.cfi_offset 8, -20
 8267              		.cfi_offset 9, -16
 8268              		.cfi_offset 10, -12
 8269              		.cfi_offset 11, -8
 8270              		.cfi_offset 14, -4
 8271 4708 507F9FE5 		ldr	r7, .L987
 8272 470c 98BF9FE5 		ldr	fp, .L987+76
 8273 4710 4C6F9FE5 		ldr	r6, .L987+4
4502:../uvc.c      ****                 {
 8274              		.loc 1 4502 0
 8275 4714 4C5F9FE5 		ldr	r5, .L987+8
 8276              	.LBB166:
 8277              	.LBB167:
3947:../uvc.c      ****     {
 8278              		.loc 1 3947 0
 8279 4718 4CAF9FE5 		ldr	r10, .L987+12
 8280              	.LBE167:
 8281              	.LBE166:
4428:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 8282              		.loc 1 4428 0
 8283 471c 64D04DE2 		sub	sp, sp, #100
 8284              	.LCFI28:
 8285              		.cfi_def_cfa_offset 136
 8286              	.LVL1010:
4450:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
 8287              		.loc 1 4450 0
 8288 4720 0740A0E1 		mov	r4, r7
 8289              	.LVL1011:
 8290              	.L900:
 8291 4724 0030E0E3 		mvn	r3, #0
 8292 4728 4C10A0E3 		mov	r1, #76
 8293 472c 00308DE5 		str	r3, [sp]
 8294 4730 280F9FE5 		ldr	r0, .L987
 8295 4734 0120A0E3 		mov	r2, #1
 8296 4738 01308DE0 		add	r3, sp, r1
 8297 473c FEFFFFEB 		bl	_txe_event_flags_get
 8298              	.LVL1012:
 8299 4740 000050E3 		cmp	r0, #0
 8300 4744 3B00001A 		bne	.L648
4454:../uvc.c      ****             {
 8301              		.loc 1 4454 0
 8302 4748 8C3094E5 		ldr	r3, [r4, #140]
 8303 474c 000053E3 		cmp	r3, #0
 8304 4750 8A00000A 		beq	.L959
 8305              	.L650:
4463:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 8306              		.loc 1 4463 0
 8307 4754 4C309DE5 		ldr	r3, [sp, #76]
 8308 4758 0C0013E3 		tst	r3, #12
 8309 475c 7200001A 		bne	.L960
 8310              	.L652:
4470:../uvc.c      ****             {
 8311              		.loc 1 4470 0
 8312 4760 040013E3 		tst	r3, #4
 8313 4764 1F00000A 		beq	.L653
4472:../uvc.c      ****                 {
 8314              		.loc 1 4472 0
 8315 4768 B020D5E1 		ldrh	r2, [r5]
 8316 476c 2224A0E1 		mov	r2, r2, lsr #8
 8317 4770 030052E3 		cmp	r2, #3
 8318 4774 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 8319 4778 150000EA 		b	.L654
 8320              	.L656:
 8321 477c D4470000 		.word	.L654
 8322 4780 8C470000 		.word	.L657
 8323 4784 40480000 		.word	.L658
 8324 4788 DC480000 		.word	.L659
 8325              	.L657:
 8326              	.LBB191:
 8327              	.LBB192:
3722:../uvc.c      ****     {
 8328              		.loc 1 3722 0
 8329 478c B020DAE1 		ldrh	r2, [r10]
 8330 4790 060C52E3 		cmp	r2, #1536
 8331 4794 4C02000A 		beq	.L721
 8332 4798 E000009A 		bls	.L961
 8333 479c 090C52E3 		cmp	r2, #2304
 8334 47a0 2402000A 		beq	.L729
 8335 47a4 0E01009A 		bls	.L962
 8336 47a8 0B0C52E3 		cmp	r2, #2816
 8337 47ac 5702000A 		beq	.L732
 8338 47b0 030B52E3 		cmp	r2, #3072
 8339 47b4 8A02000A 		beq	.L733
 8340 47b8 0A0C52E3 		cmp	r2, #2560
 8341 47bc 6C02000A 		beq	.L963
 8342              	.L720:
3779:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 8343              		.loc 1 3779 0
 8344 47c0 A83E9FE5 		ldr	r3, .L987+16
 8345 47c4 0400A0E3 		mov	r0, #4
 8346 47c8 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 8347 47cc A01E9FE5 		ldr	r1, .L987+20
 8348 47d0 FEFFFFEB 		bl	CyU3PDebugPrint
 8349              	.LVL1013:
 8350              	.L654:
 8351              	.LBE192:
 8352              	.LBE191:
4493:../uvc.c      ****                         break;
 8353              		.loc 1 4493 0
 8354 47d4 0000A0E3 		mov	r0, #0
 8355 47d8 0020A0E1 		mov	r2, r0
 8356 47dc 0110A0E3 		mov	r1, #1
 8357 47e0 FEFFFFEB 		bl	CyU3PUsbStall
 8358              	.LVL1014:
 8359 47e4 4C309DE5 		ldr	r3, [sp, #76]
 8360              	.L653:
4498:../uvc.c      ****             {
 8361              		.loc 1 4498 0
 8362 47e8 080013E3 		tst	r3, #8
 8363 47ec 0700000A 		beq	.L894
4502:../uvc.c      ****                 {
 8364              		.loc 1 4502 0
 8365 47f0 B030D5E1 		ldrh	r3, [r5]
 8366 47f4 010053E3 		cmp	r3, #1
 8367 47f8 6600000A 		beq	.L895
4504:../uvc.c      ****                 }
 8368              		.loc 1 4504 0
 8369 47fc 0000A0E3 		mov	r0, #0
 8370 4800 0020A0E1 		mov	r2, r0
 8371 4804 0110A0E3 		mov	r1, #1
 8372 4808 FEFFFFEB 		bl	CyU3PUsbStall
 8373              	.LVL1015:
 8374 480c 4C309DE5 		ldr	r3, [sp, #76]
 8375              	.L894:
4513:../uvc.c      ****             {
 8376              		.loc 1 4513 0
 8377 4810 400013E3 		tst	r3, #64
 8378 4814 0700000A 		beq	.L648
4518:../uvc.c      **** 
 8379              		.loc 1 4518 0
 8380 4818 1800A0E3 		mov	r0, #24
 8381 481c 50108DE2 		add	r1, sp, #80
 8382 4820 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
 8383              	.LVL1016:
4575:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 8384              		.loc 1 4575 0
 8385 4824 A837DBE5 		ldrb	r3, [fp, #1960]	@ zero_extendqisi2
 8386 4828 0F0053E3 		cmp	r3, #15
 8387 482c 7C00000A 		beq	.L964
4602:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 8388              		.loc 1 4602 0
 8389 4830 000053E3 		cmp	r3, #0
 8390 4834 5A00000A 		beq	.L965
 8391              	.L648:
4726:../uvc.c      ****     }
 8392              		.loc 1 4726 0
 8393 4838 FEFFFFEB 		bl	_txe_thread_relinquish
 8394              	.LVL1017:
4727:../uvc.c      **** }
 8395              		.loc 1 4727 0
 8396 483c B8FFFFEA 		b	.L900
 8397              	.L658:
 8398              	.LBB337:
 8399              	.LBB338:
3647:../uvc.c      ****     {
 8400              		.loc 1 3647 0
 8401 4840 B020DAE1 		ldrh	r2, [r10]
 8402 4844 060C52E3 		cmp	r2, #1536
 8403 4848 4801000A 		beq	.L661
 8404 484c A600008A 		bhi	.L662
 8405 4850 030C52E3 		cmp	r2, #768
 8406 4854 3201000A 		beq	.L663
 8407 4858 D100008A 		bhi	.L664
 8408 485c 010C52E3 		cmp	r2, #256
 8409 4860 1F01000A 		beq	.L665
 8410 4864 020C52E3 		cmp	r2, #512
 8411 4868 D4FFFF1A 		bne	.L720
 8412              	.LVL1018:
 8413              	.LBB339:
 8414              	.LBB340:
 934:../uvc.c      ****     /*
 8415              		.loc 1 934 0
 8416 486c FC3D9FE5 		ldr	r3, .L987+16
 927:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 8417              		.loc 1 927 0
 8418 4870 13C2DBE5 		ldrb	ip, [fp, #531]	@ zero_extendqisi2
 934:../uvc.c      ****     /*
 8419              		.loc 1 934 0
 8420 4874 0080D3E5 		ldrb	r8, [r3]	@ zero_extendqisi2
 925:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 8421              		.loc 1 925 0
 8422 4878 0402DBE5 		ldrb	r0, [fp, #516]	@ zero_extendqisi2
 8423              	.LVL1019:
 942:../uvc.c      **** 		 {
 8424              		.loc 1 942 0
 8425 487c 830058E3 		cmp	r8, #131
 926:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 8426              		.loc 1 926 0
 8427 4880 0532DBE5 		ldrb	r3, [fp, #517]	@ zero_extendqisi2
 8428              	.LVL1020:
 927:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 8429              		.loc 1 927 0
 8430 4884 30C08DE5 		str	ip, [sp, #48]
 8431              	.LVL1021:
 928:../uvc.c      ****     }
 8432              		.loc 1 928 0
 8433 4888 0692DBE5 		ldrb	r9, [fp, #518]	@ zero_extendqisi2
 8434              	.LVL1022:
 942:../uvc.c      **** 		 {
 8435              		.loc 1 942 0
 8436 488c 5605000A 		beq	.L675
 8437 4890 8B02009A 		bls	.L966
 8438 4894 850058E3 		cmp	r8, #133
 8439 4898 A805000A 		beq	.L680
 8440 489c 6D05003A 		bcc	.L681
 8441 48a0 860058E3 		cmp	r8, #134
 8442 48a4 9A04000A 		beq	.L682
 8443 48a8 870058E3 		cmp	r8, #135
1473:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 8444              		.loc 1 1473 0
 8445 48ac 0F22DB05 		ldreqb	r2, [fp, #527]	@ zero_extendqisi2
1474:../uvc.c      **** 			 }
 8446              		.loc 1 1474 0
 8447 48b0 1032DB05 		ldreqb	r3, [fp, #528]	@ zero_extendqisi2
 942:../uvc.c      **** 		 {
 8448              		.loc 1 942 0
 8449 48b4 4005001A 		bne	.L674
 8450              	.L935:
1414:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8451              		.loc 1 1414 0
 8452 48b8 E81D9FE5 		ldr	r1, .L987+72
 8453 48bc 0900A0E1 		mov	r0, r9
1411:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 8454              		.loc 1 1411 0
 8455 48c0 2820C7E5 		strb	r2, [r7, #40]
 8456              	.L934:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8457              		.loc 1 930 0
 8458 48c4 FF90A0E3 		mov	r9, #255
1412:../uvc.c      **** 			 }
 8459              		.loc 1 1412 0
 8460 48c8 2930C7E5 		strb	r3, [r7, #41]
1414:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8461              		.loc 1 1414 0
 8462 48cc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8463              	.LVL1023:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8464              		.loc 1 930 0
 8465 48d0 09C0A0E1 		mov	ip, r9
1415:../uvc.c      **** 			  break;
 8466              		.loc 1 1415 0
 8467 48d4 2830D7E5 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
 8468              	.LVL1024:
 8469 48d8 A80200EA 		b	.L684
 8470              	.LVL1025:
 8471              	.L659:
 8472              	.LBE340:
 8473              	.LBE339:
 8474              	.LBE338:
 8475              	.LBE337:
 8476              	.LBB407:
 8477              	.LBB180:
3947:../uvc.c      ****     {
 8478              		.loc 1 3947 0
 8479 48dc B030DAE1 		ldrh	r3, [r10]
 8480 48e0 0D0C53E3 		cmp	r3, #3328
 8481 48e4 5504000A 		beq	.L844
 8482 48e8 6F00008A 		bhi	.L845
 8483 48ec 060C53E3 		cmp	r3, #1536
 8484 48f0 4E04000A 		beq	.L846
 8485 48f4 9400009A 		bls	.L967
 8486 48f8 090C53E3 		cmp	r3, #2304
 8487 48fc 4304000A 		beq	.L854
 8488 4900 5001009A 		bls	.L968
 8489 4904 0B0C53E3 		cmp	r3, #2816
 8490 4908 3C04000A 		beq	.L858
 8491 490c 030B53E3 		cmp	r3, #3072
 8492 4910 1E04000A 		beq	.L859
 8493 4914 0A0C53E3 		cmp	r3, #2560
 8494 4918 ADFFFF1A 		bne	.L654
 8495              	.LVL1026:
3988:../uvc.c      ****     		}else/* no support for 1080p camera */
 8496              		.loc 1 3988 0
 8497 491c 1900A0E3 		mov	r0, #25
 8498 4920 FEFFFFEB 		bl	ControlHandle
 8499              	.LVL1027:
 8500 4924 4C309DE5 		ldr	r3, [sp, #76]
 8501 4928 AEFFFFEA 		b	.L653
 8502              	.L960:
 8503              	.LBE180:
 8504              	.LBE407:
4464:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
 8505              		.loc 1 4464 0
 8506 492c 440D9FE5 		ldr	r0, .L987+24
 8507 4930 381D9FE5 		ldr	r1, .L987+16
 8508 4934 402D9FE5 		ldr	r2, .L987+28
 8509 4938 0000D0E5 		ldrb	r0, [r0]	@ zero_extendqisi2
 8510 493c 00E0D1E5 		ldrb	lr, [r1]	@ zero_extendqisi2
 8511 4940 B010D2E1 		ldrh	r1, [r2]
 8512 4944 B0C0DAE1 		ldrh	ip, [r10]
 8513 4948 00008DE5 		str	r0, [sp]
 8514 494c B000D5E1 		ldrh	r0, [r5]
 8515 4950 10108DE5 		str	r1, [sp, #16]
 8516 4954 0010A0E3 		mov	r1, #0
 8517 4958 0C008DE5 		str	r0, [sp, #12]
 8518 495c 14108DE5 		str	r1, [sp, #20]
 8519 4960 4820D7E5 		ldrb	r2, [r7, #72]	@ zero_extendqisi2
 8520 4964 04E08DE5 		str	lr, [sp, #4]
 8521 4968 08C08DE5 		str	ip, [sp, #8]
 8522 496c 0400A0E3 		mov	r0, #4
 8523 4970 081D9FE5 		ldr	r1, .L987+32
 8524 4974 FEFFFFEB 		bl	CyU3PDebugPrint
 8525              	.LVL1028:
 8526 4978 4C309DE5 		ldr	r3, [sp, #76]
 8527 497c 77FFFFEA 		b	.L652
 8528              	.L959:
4456:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 8529              		.loc 1 4456 0
 8530 4980 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 8531              	.LVL1029:
4457:../uvc.c      ****                 {
 8532              		.loc 1 4457 0
 8533 4984 000050E3 		cmp	r0, #0
4459:../uvc.c      ****                 }
 8534              		.loc 1 4459 0
 8535 4988 0130A013 		movne	r3, #1
4456:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 8536              		.loc 1 4456 0
 8537 498c 4800C4E5 		strb	r0, [r4, #72]
4459:../uvc.c      ****                 }
 8538              		.loc 1 4459 0
 8539 4990 8C308415 		strne	r3, [r4, #140]
 8540 4994 6EFFFFEA 		b	.L650
 8541              	.L895:
4508:../uvc.c      ****                 }
 8542              		.loc 1 4508 0
 8543 4998 A7EDFFEB 		bl	UVCHandleVideoStreamingRqts
 8544              	.LVL1030:
 8545 499c 4C309DE5 		ldr	r3, [sp, #76]
 8546 49a0 9AFFFFEA 		b	.L894
 8547              	.L965:
4604:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 8548              		.loc 1 4604 0
 8549 49a4 002096E5 		ldr	r2, [r6]
 8550 49a8 0210A0E3 		mov	r1, #2
 8551 49ac 0010C2E5 		strb	r1, [r2]
4605:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 8552              		.loc 1 4605 0
 8553 49b0 002096E5 		ldr	r2, [r6]
 8554 49b4 0180A0E3 		mov	r8, #1
 8555 49b8 0180C2E5 		strb	r8, [r2, #1]
4606:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 8556              		.loc 1 4606 0
 8557 49bc 001096E5 		ldr	r1, [r6]
4610:../uvc.c      **** 					interStabuf.status = 0;
 8558              		.loc 1 4610 0
 8559 49c0 012BA0E3 		mov	r2, #1024
4606:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 8560              		.loc 1 4606 0
 8561 49c4 0230C1E5 		strb	r3, [r1, #2]
4607:../uvc.c      **** 
 8562              		.loc 1 4607 0
 8563 49c8 001096E5 		ldr	r1, [r6]
4613:../uvc.c      **** 
 8564              		.loc 1 4613 0
 8565 49cc 0490A0E3 		mov	r9, #4
4607:../uvc.c      **** 
 8566              		.loc 1 4607 0
 8567 49d0 0380C1E5 		strb	r8, [r1, #3]
4609:../uvc.c      **** 					interStabuf.size   = 1024;
 8568              		.loc 1 4609 0
 8569 49d4 001096E5 		ldr	r1, [r6]
4616:../uvc.c      **** 
 8570              		.loc 1 4616 0
 8571 49d8 A40C9FE5 		ldr	r0, .L987+36
4609:../uvc.c      **** 					interStabuf.size   = 1024;
 8572              		.loc 1 4609 0
 8573 49dc 54108DE5 		str	r1, [sp, #84]
4616:../uvc.c      **** 
 8574              		.loc 1 4616 0
 8575 49e0 0010E0E3 		mvn	r1, #0
4611:../uvc.c      **** 
 8576              		.loc 1 4611 0
 8577 49e4 BC35CDE1 		strh	r3, [sp, #92]	@ movhi
4610:../uvc.c      **** 					interStabuf.status = 0;
 8578              		.loc 1 4610 0
 8579 49e8 BA25CDE1 		strh	r2, [sp, #90]	@ movhi
4613:../uvc.c      **** 
 8580              		.loc 1 4613 0
 8581 49ec B895CDE1 		strh	r9, [sp, #88]	@ movhi
4616:../uvc.c      **** 
 8582              		.loc 1 4616 0
 8583 49f0 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 8584              	.LVL1031:
4619:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
 8585              		.loc 1 4619 0
 8586 49f4 880C9FE5 		ldr	r0, .L987+36
 8587 49f8 54108DE2 		add	r1, sp, #84
 8588 49fc FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 8589              	.LVL1032:
4621:../uvc.c      **** 					{
 8590              		.loc 1 4621 0
 8591 4a00 000050E3 		cmp	r0, #0
 8592 4a04 FA01001A 		bne	.L969
4627:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 8593              		.loc 1 4627 0
 8594 4a08 0500A0E3 		mov	r0, #5
 8595              	.LVL1033:
 8596 4a0c 3010A0E3 		mov	r1, #48
 8597 4a10 0820A0E1 		mov	r2, r8
 8598 4a14 FEFFFFEB 		bl	SensorSetControl
 8599              	.LVL1034:
4628:../uvc.c      **** 				}
 8600              		.loc 1 4628 0
 8601 4a18 8C3C9FE5 		ldr	r3, .L987+76
 8602 4a1c A887C3E5 		strb	r8, [r3, #1960]
 8603 4a20 84FFFFEA 		b	.L648
 8604              	.L964:
4577:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 8605              		.loc 1 4577 0
 8606 4a24 003096E5 		ldr	r3, [r6]
 8607 4a28 0220A0E3 		mov	r2, #2
 8608 4a2c 0020C3E5 		strb	r2, [r3]
4578:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 8609              		.loc 1 4578 0
 8610 4a30 003096E5 		ldr	r3, [r6]
 8611 4a34 0180A0E3 		mov	r8, #1
 8612 4a38 0180C3E5 		strb	r8, [r3, #1]
4579:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 8613              		.loc 1 4579 0
 8614 4a3c 002096E5 		ldr	r2, [r6]
 8615 4a40 0030A0E3 		mov	r3, #0
 8616 4a44 0230C2E5 		strb	r3, [r2, #2]
4580:../uvc.c      **** 
 8617              		.loc 1 4580 0
 8618 4a48 001096E5 		ldr	r1, [r6]
4586:../uvc.c      **** 
 8619              		.loc 1 4586 0
 8620 4a4c 04C0A0E3 		mov	ip, #4
4580:../uvc.c      **** 
 8621              		.loc 1 4580 0
 8622 4a50 0330C1E5 		strb	r3, [r1, #3]
4582:../uvc.c      **** 					interStabuf.size   = 1024;
 8623              		.loc 1 4582 0
 8624 4a54 001096E5 		ldr	r1, [r6]
4583:../uvc.c      **** 					interStabuf.status = 0;
 8625              		.loc 1 4583 0
 8626 4a58 012BA0E3 		mov	r2, #1024
4582:../uvc.c      **** 					interStabuf.size   = 1024;
 8627              		.loc 1 4582 0
 8628 4a5c 54108DE5 		str	r1, [sp, #84]
4589:../uvc.c      **** 
 8629              		.loc 1 4589 0
 8630 4a60 1C0C9FE5 		ldr	r0, .L987+36
 8631 4a64 0010E0E3 		mvn	r1, #0
4583:../uvc.c      **** 					interStabuf.status = 0;
 8632              		.loc 1 4583 0
 8633 4a68 BA25CDE1 		strh	r2, [sp, #90]	@ movhi
4586:../uvc.c      **** 
 8634              		.loc 1 4586 0
 8635 4a6c B8C5CDE1 		strh	ip, [sp, #88]	@ movhi
4589:../uvc.c      **** 
 8636              		.loc 1 4589 0
 8637 4a70 24C08DE5 		str	ip, [sp, #36]
4584:../uvc.c      **** 
 8638              		.loc 1 4584 0
 8639 4a74 BC35CDE1 		strh	r3, [sp, #92]	@ movhi
4589:../uvc.c      **** 
 8640              		.loc 1 4589 0
 8641 4a78 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 8642              	.LVL1035:
4592:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
 8643              		.loc 1 4592 0
 8644 4a7c 000C9FE5 		ldr	r0, .L987+36
 8645 4a80 54108DE2 		add	r1, sp, #84
 8646 4a84 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 8647              	.LVL1036:
4594:../uvc.c      **** 					{
 8648              		.loc 1 4594 0
 8649 4a88 24C09DE5 		ldr	ip, [sp, #36]
 8650 4a8c 002050E2 		subs	r2, r0, #0
 8651 4a90 EE03001A 		bne	.L970
4599:../uvc.c      **** 
 8652              		.loc 1 4599 0
 8653 4a94 0500A0E3 		mov	r0, #5
 8654              	.LVL1037:
 8655 4a98 3010A0E3 		mov	r1, #48
 8656 4a9c FEFFFFEB 		bl	SensorSetControl
 8657              	.LVL1038:
4601:../uvc.c      **** 				}else if(!snapButFlag){
 8658              		.loc 1 4601 0
 8659 4aa0 042C9FE5 		ldr	r2, .L987+76
 8660 4aa4 A887C2E5 		strb	r8, [r2, #1960]
 8661 4aa8 62FFFFEA 		b	.L648
 8662              	.L845:
 8663              	.LBB408:
 8664              	.LBB181:
3947:../uvc.c      ****     {
 8665              		.loc 1 3947 0
 8666 4aac 050B53E3 		cmp	r3, #5120
 8667 4ab0 CE03000A 		beq	.L861
 8668 4ab4 2F00009A 		bls	.L971
 8669 4ab8 170C53E3 		cmp	r3, #5888
 8670 4abc C703000A 		beq	.L869
 8671 4ac0 AE00009A 		bls	.L972
 8672 4ac4 1A0C53E3 		cmp	r3, #6656
 8673 4ac8 C003000A 		beq	.L873
 8674 4acc 1B0C53E3 		cmp	r3, #6912
 8675 4ad0 B203000A 		beq	.L874
 8676 4ad4 060B53E3 		cmp	r3, #6144
 8677 4ad8 3DFFFF1A 		bne	.L654
4048:../uvc.c      ****     		break;
 8678              		.loc 1 4048 0
 8679 4adc 2B00A0E3 		mov	r0, #43
 8680 4ae0 FEFFFFEB 		bl	ControlHandle
 8681              	.LVL1039:
 8682 4ae4 4C309DE5 		ldr	r3, [sp, #76]
 8683 4ae8 3EFFFFEA 		b	.L653
 8684              	.L662:
 8685              	.LBE181:
 8686              	.LBE408:
 8687              	.LBB409:
 8688              	.LBB397:
3647:../uvc.c      ****     {
 8689              		.loc 1 3647 0
 8690 4aec 0A0C52E3 		cmp	r2, #2560
 8691 4af0 6000000A 		beq	.L668
 8692 4af4 3200009A 		bls	.L973
 8693 4af8 0D0C52E3 		cmp	r2, #3328
 8694 4afc 5D00000A 		beq	.L668
 8695 4b00 0E0C52E3 		cmp	r2, #3584
 8696 4b04 7200000A 		beq	.L672
 8697 4b08 030B52E3 		cmp	r2, #3072
 8698 4b0c 2BFFFF1A 		bne	.L720
 8699              	.LVL1040:
3688:../uvc.c      ****     		break;
 8700              		.loc 1 3688 0
 8701 4b10 0B00A0E3 		mov	r0, #11
 8702 4b14 FEFFFFEB 		bl	ControlHandle
 8703              	.LVL1041:
 8704 4b18 4C309DE5 		ldr	r3, [sp, #76]
 8705 4b1c 31FFFFEA 		b	.L653
 8706              	.L961:
 8707              	.LBE397:
 8708              	.LBE409:
 8709              	.LBB410:
 8710              	.LBB329:
3722:../uvc.c      ****     {
 8711              		.loc 1 3722 0
 8712 4b20 030C52E3 		cmp	r2, #768
 8713 4b24 CF00000A 		beq	.L723
 8714 4b28 3200008A 		bhi	.L724
 8715 4b2c 010C52E3 		cmp	r2, #256
 8716 4b30 F900000A 		beq	.L725
 8717 4b34 020C52E3 		cmp	r2, #512
 8718 4b38 20FFFF1A 		bne	.L720
 8719              	.LVL1042:
3730:../uvc.c      ****     		break;
 8720              		.loc 1 3730 0
 8721 4b3c 0100A0E3 		mov	r0, #1
 8722 4b40 FEFFFFEB 		bl	CTControlHandle
 8723              	.LVL1043:
 8724 4b44 4C309DE5 		ldr	r3, [sp, #76]
 8725 4b48 26FFFFEA 		b	.L653
 8726              	.L967:
 8727              	.LBE329:
 8728              	.LBE410:
 8729              	.LBB411:
 8730              	.LBB182:
3947:../uvc.c      ****     {
 8731              		.loc 1 3947 0
 8732 4b4c 030C53E3 		cmp	r3, #768
 8733 4b50 9A03000A 		beq	.L848
 8734 4b54 6A00008A 		bhi	.L849
 8735 4b58 010C53E3 		cmp	r3, #256
 8736 4b5c 9303000A 		beq	.L850
 8737 4b60 020C53E3 		cmp	r3, #512
 8738 4b64 1AFFFF1A 		bne	.L654
 8739              	.LVL1044:
3955:../uvc.c      ****     		break;
 8740              		.loc 1 3955 0
 8741 4b68 1100A0E3 		mov	r0, #17
 8742 4b6c FEFFFFEB 		bl	ControlHandle
 8743              	.LVL1045:
 8744 4b70 4C309DE5 		ldr	r3, [sp, #76]
 8745 4b74 1BFFFFEA 		b	.L653
 8746              	.L971:
3947:../uvc.c      ****     {
 8747              		.loc 1 3947 0
 8748 4b78 110C53E3 		cmp	r3, #4352
 8749 4b7c 7703000A 		beq	.L863
 8750 4b80 A800008A 		bhi	.L864
 8751 4b84 0F0C53E3 		cmp	r3, #3840
 8752 4b88 7003000A 		beq	.L865
 8753 4b8c 010A53E3 		cmp	r3, #4096
 8754 4b90 0FFFFF1A 		bne	.L654
 8755              	.LVL1046:
4016:../uvc.c      ****     		break;
 8756              		.loc 1 4016 0
 8757 4b94 1F00A0E3 		mov	r0, #31
 8758 4b98 FEFFFFEB 		bl	ControlHandle
 8759              	.LVL1047:
 8760 4b9c 4C309DE5 		ldr	r3, [sp, #76]
 8761 4ba0 10FFFFEA 		b	.L653
 8762              	.L664:
 8763              	.LBE182:
 8764              	.LBE411:
 8765              	.LBB412:
 8766              	.LBB398:
3647:../uvc.c      ****     {
 8767              		.loc 1 3647 0
 8768 4ba4 010B52E3 		cmp	r2, #1024
 8769 4ba8 0EFFFF0A 		beq	.L653
 8770 4bac 050C52E3 		cmp	r2, #1280
 8771 4bb0 02FFFF1A 		bne	.L720
 8772              	.L702:
 8773              	.LVL1048:
3666:../uvc.c      ****       		break;
 8774              		.loc 1 3666 0
 8775 4bb4 0400A0E3 		mov	r0, #4
 8776 4bb8 FEFFFFEB 		bl	ControlHandle
 8777              	.LVL1049:
 8778 4bbc 4C309DE5 		ldr	r3, [sp, #76]
 8779 4bc0 08FFFFEA 		b	.L653
 8780              	.L973:
3647:../uvc.c      ****     {
 8781              		.loc 1 3647 0
 8782 4bc4 070C52E3 		cmp	r2, #1792
 8783 4bc8 4900000A 		beq	.L670
 8784 4bcc 020B52E3 		cmp	r2, #2048
 8785 4bd0 FAFEFF1A 		bne	.L720
 8786              	.LVL1050:
3678:../uvc.c      ****           		break;
 8787              		.loc 1 3678 0
 8788 4bd4 0700A0E3 		mov	r0, #7
 8789 4bd8 FEFFFFEB 		bl	ControlHandle
 8790              	.LVL1051:
 8791 4bdc 4C309DE5 		ldr	r3, [sp, #76]
 8792 4be0 00FFFFEA 		b	.L653
 8793              	.L962:
 8794              	.LBE398:
 8795              	.LBE412:
 8796              	.LBB413:
 8797              	.LBB330:
3722:../uvc.c      ****     {
 8798              		.loc 1 3722 0
 8799 4be4 070C52E3 		cmp	r2, #1792
 8800 4be8 AF00000A 		beq	.L731
 8801 4bec 020B52E3 		cmp	r2, #2048
 8802 4bf0 FCFEFF0A 		beq	.L653
 8803 4bf4 F1FEFFEA 		b	.L720
 8804              	.L724:
 8805 4bf8 010B52E3 		cmp	r2, #1024
 8806 4bfc E200000A 		beq	.L727
 8807 4c00 050C52E3 		cmp	r2, #1280
 8808 4c04 EDFEFF1A 		bne	.L720
 8809              	.LVL1052:
 8810              	.LBB193:
 8811              	.LBB194:
2029:../uvc.c      **** 
 8812              		.loc 1 2029 0
 8813 4c08 60CA9FE5 		ldr	ip, .L987+16
2024:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8814              		.loc 1 2024 0
 8815 4c0c 8A96DBE5 		ldrb	r9, [fp, #1674]	@ zero_extendqisi2
 8816              	.LVL1053:
2029:../uvc.c      **** 
 8817              		.loc 1 2029 0
 8818 4c10 0080DCE5 		ldrb	r8, [ip]	@ zero_extendqisi2
 8819              	.LVL1054:
2031:../uvc.c      **** 		 {
 8820              		.loc 1 2031 0
 8821 4c14 830058E3 		cmp	r8, #131
 8822 4c18 5C05000A 		beq	.L773
 8823 4c1c 2202009A 		bls	.L974
 8824 4c20 850058E3 		cmp	r8, #133
 8825 4c24 3003000A 		beq	.L835
 8826 4c28 E104003A 		bcc	.L779
 8827 4c2c 860058E3 		cmp	r8, #134
 8828 4c30 CF03000A 		beq	.L780
 8829 4c34 870058E3 		cmp	r8, #135
2093:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8830              		.loc 1 2093 0
 8831 4c38 9316DB05 		ldreqb	r1, [fp, #1683]	@ zero_extendqisi2
2094:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8832              		.loc 1 2094 0
 8833 4c3c 9426DB05 		ldreqb	r2, [fp, #1684]	@ zero_extendqisi2
2031:../uvc.c      **** 		 {
 8834              		.loc 1 2031 0
 8835 4c40 4101000A 		beq	.L952
 8836              	.L772:
2238:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8837              		.loc 1 2238 0
 8838 4c44 0000A0E3 		mov	r0, #0
 8839 4c48 0020A0E1 		mov	r2, r0
 8840 4c4c 0110A0E3 		mov	r1, #1
 8841 4c50 24C08DE5 		str	ip, [sp, #36]
 8842 4c54 FEFFFFEB 		bl	CyU3PUsbStall
 8843              	.LVL1055:
2239:../uvc.c      **** 			  break;
 8844              		.loc 1 2239 0
 8845 4c58 24C09DE5 		ldr	ip, [sp, #36]
 8846 4c5c 0400A0E3 		mov	r0, #4
 8847 4c60 0020A0E1 		mov	r2, r0
 8848 4c64 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 8849 4c68 341A9FE5 		ldr	r1, .L987+68
 8850 4c6c FEFFFFEB 		bl	CyU3PDebugPrint
 8851              	.LVL1056:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8852              		.loc 1 2025 0
 8853 4c70 FF20A0E3 		mov	r2, #255
 8854              	.LVL1057:
 8855 4c74 230300EA 		b	.L839
 8856              	.LVL1058:
 8857              	.L668:
 8858              	.LBE194:
 8859              	.LBE193:
 8860              	.LBE330:
 8861              	.LBE413:
 8862              	.LBB414:
 8863              	.LBB399:
 8864              	.LBB351:
 8865              	.LBB352:
 934:../uvc.c      ****     /*
 8866              		.loc 1 934 0
 8867 4c78 F0299FE5 		ldr	r2, .L987+16
 925:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 8868              		.loc 1 925 0
 8869 4c7c C432DBE5 		ldrb	r3, [fp, #708]	@ zero_extendqisi2
 8870              	.LVL1059:
 934:../uvc.c      ****     /*
 8871              		.loc 1 934 0
 8872 4c80 0080D2E5 		ldrb	r8, [r2]	@ zero_extendqisi2
 927:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 8873              		.loc 1 927 0
 8874 4c84 D3C2DBE5 		ldrb	ip, [fp, #723]	@ zero_extendqisi2
 8875              	.LVL1060:
 942:../uvc.c      **** 		 {
 8876              		.loc 1 942 0
 8877 4c88 830058E3 		cmp	r8, #131
 928:../uvc.c      ****     }
 8878              		.loc 1 928 0
 8879 4c8c C692DBE5 		ldrb	r9, [fp, #710]	@ zero_extendqisi2
 8880              	.LVL1061:
 942:../uvc.c      **** 		 {
 8881              		.loc 1 942 0
 8882 4c90 5104000A 		beq	.L707
 8883 4c94 C401009A 		bls	.L975
 8884 4c98 850058E3 		cmp	r8, #133
 8885 4c9c 7103000A 		beq	.L712
 8886 4ca0 9A04003A 		bcc	.L713
 8887 4ca4 860058E3 		cmp	r8, #134
 8888 4ca8 9203000A 		beq	.L714
 8889 4cac 870058E3 		cmp	r8, #135
 8890 4cb0 FF03001A 		bne	.L706
1473:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 8891              		.loc 1 1473 0
 8892 4cb4 F0E99FE5 		ldr	lr, .L987+76
 8893 4cb8 CFC2DEE5 		ldrb	ip, [lr, #719]	@ zero_extendqisi2
1474:../uvc.c      **** 			 }
 8894              		.loc 1 1474 0
 8895 4cbc D022DEE5 		ldrb	r2, [lr, #720]	@ zero_extendqisi2
 8896              	.LVL1062:
 8897              	.L942:
1414:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8898              		.loc 1 1414 0
 8899 4cc0 0900A0E1 		mov	r0, r9
 8900 4cc4 DC199FE5 		ldr	r1, .L987+72
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8901              		.loc 1 930 0
 8902 4cc8 FF30A0E3 		mov	r3, #255
1411:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 8903              		.loc 1 1411 0
 8904 4ccc 28C0C7E5 		strb	ip, [r7, #40]
 8905 4cd0 690300EA 		b	.L940
 8906              	.L672:
 8907              	.LVL1063:
 8908              	.LBE352:
 8909              	.LBE351:
3692:../uvc.c      ****     		break;
 8910              		.loc 1 3692 0
 8911 4cd4 0E00A0E3 		mov	r0, #14
 8912 4cd8 FEFFFFEB 		bl	ControlHandle
 8913              	.LVL1064:
 8914 4cdc 4C309DE5 		ldr	r3, [sp, #76]
 8915 4ce0 C0FEFFEA 		b	.L653
 8916              	.L665:
 8917              	.LVL1065:
3651:../uvc.c      ****     		break;
 8918              		.loc 1 3651 0
 8919 4ce4 0000A0E3 		mov	r0, #0
 8920 4ce8 FEFFFFEB 		bl	ControlHandle
 8921              	.LVL1066:
 8922 4cec 4C309DE5 		ldr	r3, [sp, #76]
 8923 4cf0 BCFEFFEA 		b	.L653
 8924              	.L670:
 8925              	.LVL1067:
3674:../uvc.c      ****           		break;
 8926              		.loc 1 3674 0
 8927 4cf4 0600A0E3 		mov	r0, #6
 8928 4cf8 FEFFFFEB 		bl	ControlHandle
 8929              	.LVL1068:
 8930 4cfc 4C309DE5 		ldr	r3, [sp, #76]
 8931 4d00 B8FEFFEA 		b	.L653
 8932              	.L849:
 8933              	.LBE399:
 8934              	.LBE414:
 8935              	.LBB415:
 8936              	.LBB183:
3947:../uvc.c      ****     {
 8937              		.loc 1 3947 0
 8938 4d04 010B53E3 		cmp	r3, #1024
 8939 4d08 0C03000A 		beq	.L852
 8940 4d0c 050C53E3 		cmp	r3, #1280
 8941 4d10 AFFEFF1A 		bne	.L654
 8942              	.LVL1069:
3967:../uvc.c      ****     		break;
 8943              		.loc 1 3967 0
 8944 4d14 1400A0E3 		mov	r0, #20
 8945 4d18 FEFFFFEB 		bl	ControlHandle
 8946              	.LVL1070:
 8947 4d1c 4C309DE5 		ldr	r3, [sp, #76]
 8948 4d20 B0FEFFEA 		b	.L653
 8949              	.L663:
 8950              	.LVL1071:
 8951              	.LBE183:
 8952              	.LBE415:
 8953              	.LBB416:
 8954              	.LBB400:
 8955              	.LBB362:
 8956              	.LBB363:
 934:../uvc.c      ****     /*
 8957              		.loc 1 934 0
 8958 4d24 44299FE5 		ldr	r2, .L987+16
 925:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 8959              		.loc 1 925 0
 8960 4d28 1C32DBE5 		ldrb	r3, [fp, #540]	@ zero_extendqisi2
 8961              	.LVL1072:
 934:../uvc.c      ****     /*
 8962              		.loc 1 934 0
 8963 4d2c 0080D2E5 		ldrb	r8, [r2]	@ zero_extendqisi2
 927:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 8964              		.loc 1 927 0
 8965 4d30 2BC2DBE5 		ldrb	ip, [fp, #555]	@ zero_extendqisi2
 8966              	.LVL1073:
 942:../uvc.c      **** 		 {
 8967              		.loc 1 942 0
 8968 4d34 830058E3 		cmp	r8, #131
 928:../uvc.c      ****     }
 8969              		.loc 1 928 0
 8970 4d38 1E92DBE5 		ldrb	r9, [fp, #542]	@ zero_extendqisi2
 8971              	.LVL1074:
 942:../uvc.c      **** 		 {
 8972              		.loc 1 942 0
 8973 4d3c 6F04000A 		beq	.L693
 8974 4d40 3401009A 		bls	.L976
 8975 4d44 850058E3 		cmp	r8, #133
 8976 4d48 4603000A 		beq	.L712
 8977 4d4c 8004003A 		bcc	.L699
 8978 4d50 860058E3 		cmp	r8, #134
 8979 4d54 6003000A 		beq	.L700
 8980 4d58 870058E3 		cmp	r8, #135
 8981 4d5c D403001A 		bne	.L706
1473:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 8982              		.loc 1 1473 0
 8983 4d60 44E99FE5 		ldr	lr, .L987+76
 8984 4d64 27C2DEE5 		ldrb	ip, [lr, #551]	@ zero_extendqisi2
1474:../uvc.c      **** 			 }
 8985              		.loc 1 1474 0
 8986 4d68 2822DEE5 		ldrb	r2, [lr, #552]	@ zero_extendqisi2
 8987 4d6c D3FFFFEA 		b	.L942
 8988              	.LVL1075:
 8989              	.L661:
 8990              	.LBE363:
 8991              	.LBE362:
3670:../uvc.c      ****      		break;
 8992              		.loc 1 3670 0
 8993 4d70 0500A0E3 		mov	r0, #5
 8994 4d74 FEFFFFEB 		bl	ControlHandle
 8995              	.LVL1076:
 8996 4d78 4C309DE5 		ldr	r3, [sp, #76]
 8997 4d7c 99FEFFEA 		b	.L653
 8998              	.L972:
 8999              	.LBE400:
 9000              	.LBE416:
 9001              	.LBB417:
 9002              	.LBB184:
3947:../uvc.c      ****     {
 9003              		.loc 1 3947 0
 9004 4d80 150C53E3 		cmp	r3, #5376
 9005 4d84 2503000A 		beq	.L871
 9006 4d88 160C53E3 		cmp	r3, #5632
 9007 4d8c 90FEFF1A 		bne	.L654
 9008              	.LVL1077:
 9009              	.LBB168:
 9010              	.LBB169:
 934:../uvc.c      ****     /*
 9011              		.loc 1 934 0
 9012 4d90 D8389FE5 		ldr	r3, .L987+16
 920:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 9013              		.loc 1 920 0
 9014 4d94 4491DBE5 		ldrb	r9, [fp, #324]	@ zero_extendqisi2
 9015              	.LVL1078:
 934:../uvc.c      ****     /*
 9016              		.loc 1 934 0
 9017 4d98 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 921:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 9018              		.loc 1 921 0
 9019 4d9c 4501DBE5 		ldrb	r0, [fp, #325]	@ zero_extendqisi2
 9020              	.LVL1079:
 942:../uvc.c      **** 		 {
 9021              		.loc 1 942 0
 9022 4da0 830053E3 		cmp	r3, #131
 934:../uvc.c      ****     /*
 9023              		.loc 1 934 0
 9024 4da4 30308DE5 		str	r3, [sp, #48]
 923:../uvc.c      ****     }else{
 9025              		.loc 1 923 0
 9026 4da8 4681DBE5 		ldrb	r8, [fp, #326]	@ zero_extendqisi2
 922:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 9027              		.loc 1 922 0
 9028 4dac 5331DBE5 		ldrb	r3, [fp, #339]	@ zero_extendqisi2
 9029              	.LVL1080:
 942:../uvc.c      **** 		 {
 9030              		.loc 1 942 0
 9031 4db0 7005000A 		beq	.L877
 9032 4db4 30C09DE5 		ldr	ip, [sp, #48]
 9033 4db8 C703009A 		bls	.L977
 9034 4dbc 85005CE3 		cmp	ip, #133
 9035 4dc0 AD03000A 		beq	.L882
 9036 4dc4 7D05003A 		bcc	.L883
 9037 4dc8 86005CE3 		cmp	ip, #134
 9038 4dcc 7105000A 		beq	.L884
 9039 4dd0 87005CE3 		cmp	ip, #135
1464:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 9040              		.loc 1 1464 0
 9041 4dd4 4FC1DB05 		ldreqb	ip, [fp, #335]	@ zero_extendqisi2
1465:../uvc.c      **** 		 	 }
 9042              		.loc 1 1465 0
 9043 4dd8 5021DB05 		ldreqb	r2, [fp, #336]	@ zero_extendqisi2
 942:../uvc.c      **** 		 {
 9044              		.loc 1 942 0
 9045 4ddc 4805001A 		bne	.L876
 9046              	.L954:
1414:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9047              		.loc 1 1414 0
 9048 4de0 C0189FE5 		ldr	r1, .L987+72
 9049 4de4 0800A0E1 		mov	r0, r8
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9050              		.loc 1 930 0
 9051 4de8 FF90A0E3 		mov	r9, #255
1400:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 9052              		.loc 1 1400 0
 9053 4dec 28C0C7E5 		strb	ip, [r7, #40]
 9054              	.L953:
1401:../uvc.c      **** 		 	 }
 9055              		.loc 1 1401 0
 9056 4df0 2920C7E5 		strb	r2, [r7, #41]
1414:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9057              		.loc 1 1414 0
 9058 4df4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9059              	.LVL1081:
1415:../uvc.c      **** 			  break;
 9060              		.loc 1 1415 0
 9061 4df8 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 9062              	.LVL1082:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9063              		.loc 1 930 0
 9064 4dfc 0980A0E1 		mov	r8, r9
 9065              	.LVL1083:
 9066 4e00 09C0A0E1 		mov	ip, r9
 9067              	.LVL1084:
 9068              	.L886:
2005:../uvc.c      **** }
 9069              		.loc 1 2005 0
 9070 4e04 04028DE9 		stmib	sp, {r2, r9}
 9071 4e08 8C189FE5 		ldr	r1, .L987+60
 9072 4e0c 0C30A0E1 		mov	r3, ip
 9073 4e10 00808DE5 		str	r8, [sp]
 9074 4e14 30209DE5 		ldr	r2, [sp, #48]
 9075              	.LVL1085:
 9076 4e18 0400A0E3 		mov	r0, #4
 9077 4e1c FEFFFFEB 		bl	CyU3PDebugPrint
 9078              	.LVL1086:
 9079 4e20 4C309DE5 		ldr	r3, [sp, #76]
 9080 4e24 6FFEFFEA 		b	.L653
 9081              	.LVL1087:
 9082              	.L864:
 9083              	.LBE169:
 9084              	.LBE168:
3947:../uvc.c      ****     {
 9085              		.loc 1 3947 0
 9086 4e28 120C53E3 		cmp	r3, #4608
 9087 4e2c D302000A 		beq	.L867
 9088 4e30 130C53E3 		cmp	r3, #4864
 9089 4e34 66FEFF1A 		bne	.L654
 9090              	.LVL1088:
4028:../uvc.c      ****     		break;
 9091              		.loc 1 4028 0
 9092 4e38 2600A0E3 		mov	r0, #38
 9093 4e3c FEFFFFEB 		bl	ControlHandle
 9094              	.LVL1089:
 9095 4e40 4C309DE5 		ldr	r3, [sp, #76]
 9096 4e44 67FEFFEA 		b	.L653
 9097              	.L968:
3947:../uvc.c      ****     {
 9098              		.loc 1 3947 0
 9099 4e48 070C53E3 		cmp	r3, #1792
 9100 4e4c C702000A 		beq	.L856
 9101 4e50 020B53E3 		cmp	r3, #2048
 9102 4e54 5EFEFF1A 		bne	.L654
 9103              	.LVL1090:
3979:../uvc.c      ****     		break;
 9104              		.loc 1 3979 0
 9105 4e58 1700A0E3 		mov	r0, #23
 9106 4e5c FEFFFFEB 		bl	ControlHandle
 9107              	.LVL1091:
 9108 4e60 4C309DE5 		ldr	r3, [sp, #76]
 9109 4e64 5FFEFFEA 		b	.L653
 9110              	.L723:
 9111              	.LVL1092:
 9112              	.LBE184:
 9113              	.LBE417:
 9114              	.LBB418:
 9115              	.LBB331:
 9116              	.LBB200:
 9117              	.LBB201:
2029:../uvc.c      **** 
 9118              		.loc 1 2029 0
 9119 4e68 00C89FE5 		ldr	ip, .L987+16
2024:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9120              		.loc 1 2024 0
 9121 4e6c 5A96DBE5 		ldrb	r9, [fp, #1626]	@ zero_extendqisi2
 9122              	.LVL1093:
2029:../uvc.c      **** 
 9123              		.loc 1 2029 0
 9124 4e70 0080DCE5 		ldrb	r8, [ip]	@ zero_extendqisi2
 9125              	.LVL1094:
2031:../uvc.c      **** 		 {
 9126              		.loc 1 2031 0
 9127 4e74 830058E3 		cmp	r8, #131
 9128 4e78 7504000A 		beq	.L747
 9129 4e7c 7501009A 		bls	.L978
 9130 4e80 850058E3 		cmp	r8, #133
 9131 4e84 9802000A 		beq	.L835
 9132 4e88 B804003A 		bcc	.L753
 9133 4e8c 860058E3 		cmp	r8, #134
 9134 4e90 5603000A 		beq	.L754
 9135 4e94 870058E3 		cmp	r8, #135
 9136 4e98 8104001A 		bne	.L746
2093:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 9137              		.loc 1 2093 0
 9138 4e9c 08289FE5 		ldr	r2, .L987+76
 9139 4ea0 6316D2E5 		ldrb	r1, [r2, #1635]	@ zero_extendqisi2
2094:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9140              		.loc 1 2094 0
 9141 4ea4 6426D2E5 		ldrb	r2, [r2, #1636]	@ zero_extendqisi2
 9142 4ea8 A70000EA 		b	.L952
 9143              	.LVL1095:
 9144              	.L731:
 9145              	.LBE201:
 9146              	.LBE200:
 9147              	.LBB209:
 9148              	.LBB210:
2029:../uvc.c      **** 
 9149              		.loc 1 2029 0
 9150 4eac BCC79FE5 		ldr	ip, .L987+16
2024:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9151              		.loc 1 2024 0
 9152 4eb0 BA96DBE5 		ldrb	r9, [fp, #1722]	@ zero_extendqisi2
 9153              	.LVL1096:
2029:../uvc.c      **** 
 9154              		.loc 1 2029 0
 9155 4eb4 0080DCE5 		ldrb	r8, [ip]	@ zero_extendqisi2
 9156              	.LVL1097:
2031:../uvc.c      **** 		 {
 9157              		.loc 1 2031 0
 9158 4eb8 830058E3 		cmp	r8, #131
 9159 4ebc AF04000A 		beq	.L795
 9160 4ec0 A101009A 		bls	.L979
 9161 4ec4 850058E3 		cmp	r8, #133
 9162 4ec8 8702000A 		beq	.L835
 9163 4ecc 5804003A 		bcc	.L801
 9164 4ed0 860058E3 		cmp	r8, #134
 9165 4ed4 3503000A 		beq	.L802
 9166 4ed8 870058E3 		cmp	r8, #135
2093:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 9167              		.loc 1 2093 0
 9168 4edc C316DB05 		ldreqb	r1, [fp, #1731]	@ zero_extendqisi2
2094:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9169              		.loc 1 2094 0
 9170 4ee0 C426DB05 		ldreqb	r2, [fp, #1732]	@ zero_extendqisi2
2031:../uvc.c      **** 		 {
 9171              		.loc 1 2031 0
 9172 4ee4 9800000A 		beq	.L952
 9173              	.L794:
2238:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 9174              		.loc 1 2238 0
 9175 4ee8 0000A0E3 		mov	r0, #0
 9176 4eec 0020A0E1 		mov	r2, r0
 9177 4ef0 0110A0E3 		mov	r1, #1
 9178 4ef4 24C08DE5 		str	ip, [sp, #36]
 9179 4ef8 FEFFFFEB 		bl	CyU3PUsbStall
 9180              	.LVL1098:
2239:../uvc.c      **** 			  break;
 9181              		.loc 1 2239 0
 9182 4efc 24C09DE5 		ldr	ip, [sp, #36]
 9183 4f00 0620A0E3 		mov	r2, #6
 9184 4f04 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 9185 4f08 0400A0E3 		mov	r0, #4
 9186 4f0c 90179FE5 		ldr	r1, .L987+68
 9187 4f10 FEFFFFEB 		bl	CyU3PDebugPrint
 9188              	.LVL1099:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9189              		.loc 1 2025 0
 9190 4f14 FF20A0E3 		mov	r2, #255
 9191              	.LVL1100:
 9192 4f18 7A0200EA 		b	.L839
 9193              	.LVL1101:
 9194              	.L725:
 9195              	.LBE210:
 9196              	.LBE209:
 9197              	.LBB217:
 9198              	.LBB218:
2029:../uvc.c      **** 
 9199              		.loc 1 2029 0
 9200 4f1c 4CC79FE5 		ldr	ip, .L987+16
2024:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9201              		.loc 1 2024 0
 9202 4f20 2A96DBE5 		ldrb	r9, [fp, #1578]	@ zero_extendqisi2
 9203              	.LVL1102:
2029:../uvc.c      **** 
 9204              		.loc 1 2029 0
 9205 4f24 0080DCE5 		ldrb	r8, [ip]	@ zero_extendqisi2
 9206              	.LVL1103:
2031:../uvc.c      **** 		 {
 9207              		.loc 1 2031 0
 9208 4f28 830058E3 		cmp	r8, #131
 9209 4f2c 5404000A 		beq	.L736
 9210 4f30 7101009A 		bls	.L980
 9211 4f34 850058E3 		cmp	r8, #133
 9212 4f38 6B02000A 		beq	.L835
 9213 4f3c 6504003A 		bcc	.L742
 9214 4f40 860058E3 		cmp	r8, #134
 9215 4f44 2703000A 		beq	.L743
 9216 4f48 870058E3 		cmp	r8, #135
2093:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 9217              		.loc 1 2093 0
 9218 4f4c 3316DB05 		ldreqb	r1, [fp, #1587]	@ zero_extendqisi2
2094:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9219              		.loc 1 2094 0
 9220 4f50 3426DB05 		ldreqb	r2, [fp, #1588]	@ zero_extendqisi2
2031:../uvc.c      **** 		 {
 9221              		.loc 1 2031 0
 9222 4f54 7C00000A 		beq	.L952
 9223              	.L735:
2238:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 9224              		.loc 1 2238 0
 9225 4f58 0000A0E3 		mov	r0, #0
 9226 4f5c 0020A0E1 		mov	r2, r0
 9227 4f60 0110A0E3 		mov	r1, #1
 9228 4f64 24C08DE5 		str	ip, [sp, #36]
 9229 4f68 FEFFFFEB 		bl	CyU3PUsbStall
 9230              	.LVL1104:
2239:../uvc.c      **** 			  break;
 9231              		.loc 1 2239 0
 9232 4f6c 24C09DE5 		ldr	ip, [sp, #36]
 9233 4f70 0020A0E3 		mov	r2, #0
 9234 4f74 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 9235 4f78 0400A0E3 		mov	r0, #4
 9236 4f7c 20179FE5 		ldr	r1, .L987+68
 9237 4f80 FEFFFFEB 		bl	CyU3PDebugPrint
 9238              	.LVL1105:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9239              		.loc 1 2025 0
 9240 4f84 FF20A0E3 		mov	r2, #255
 9241              	.LVL1106:
 9242 4f88 5E0200EA 		b	.L839
 9243              	.LVL1107:
 9244              	.L727:
 9245              	.LBE218:
 9246              	.LBE217:
 9247              	.LBB225:
 9248              	.LBB226:
2029:../uvc.c      **** 
 9249              		.loc 1 2029 0
 9250 4f8c DCC69FE5 		ldr	ip, .L987+16
2022:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 9251              		.loc 1 2022 0
 9252 4f90 7086DBE5 		ldrb	r8, [fp, #1648]	@ zero_extendqisi2
2029:../uvc.c      **** 
 9253              		.loc 1 2029 0
 9254 4f94 0090DCE5 		ldrb	r9, [ip]	@ zero_extendqisi2
2022:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 9255              		.loc 1 2022 0
 9256 4f98 30808DE5 		str	r8, [sp, #48]
2031:../uvc.c      **** 		 {
 9257              		.loc 1 2031 0
 9258 4f9c 830059E3 		cmp	r9, #131
2021:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 9259              		.loc 1 2021 0
 9260 4fa0 7F36DBE5 		ldrb	r3, [fp, #1663]	@ zero_extendqisi2
 9261              	.LVL1108:
2024:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9262              		.loc 1 2024 0
 9263 4fa4 7286DBE5 		ldrb	r8, [fp, #1650]	@ zero_extendqisi2
 9264              	.LVL1109:
2031:../uvc.c      **** 		 {
 9265              		.loc 1 2031 0
 9266 4fa8 ED03000A 		beq	.L758
 9267 4fac C101009A 		bls	.L981
 9268 4fb0 850059E3 		cmp	r9, #133
 9269 4fb4 4E04000A 		beq	.L763
 9270 4fb8 BC04003A 		bcc	.L764
 9271 4fbc 860059E3 		cmp	r9, #134
 9272 4fc0 1503000A 		beq	.L765
 9273 4fc4 870059E3 		cmp	r9, #135
2093:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 9274              		.loc 1 2093 0
 9275 4fc8 7B16DB05 		ldreqb	r1, [fp, #1659]	@ zero_extendqisi2
2094:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9276              		.loc 1 2094 0
 9277 4fcc 7C26DB05 		ldreqb	r2, [fp, #1660]	@ zero_extendqisi2
2031:../uvc.c      **** 		 {
 9278              		.loc 1 2031 0
 9279 4fd0 5104001A 		bne	.L757
 9280              	.L946:
2072:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 9281              		.loc 1 2072 0
 9282 4fd4 0030A0E3 		mov	r3, #0
2069:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 9283              		.loc 1 2069 0
 9284 4fd8 2810C7E5 		strb	r1, [r7, #40]
2074:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9285              		.loc 1 2074 0
 9286 4fdc 0800A0E1 		mov	r0, r8
 9287 4fe0 C0169FE5 		ldr	r1, .L987+72
2070:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9288              		.loc 1 2070 0
 9289 4fe4 2920C7E5 		strb	r2, [r7, #41]
2072:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 9290              		.loc 1 2072 0
 9291 4fe8 2A30C7E5 		strb	r3, [r7, #42]
2073:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 9292              		.loc 1 2073 0
 9293 4fec 2B30C7E5 		strb	r3, [r7, #43]
2074:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9294              		.loc 1 2074 0
 9295 4ff0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9296              	.LVL1110:
2075:../uvc.c      **** 			  break;
 9297              		.loc 1 2075 0
 9298 4ff4 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 9299              	.LVL1111:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9300              		.loc 1 2025 0
 9301 4ff8 FF20A0E3 		mov	r2, #255
 9302 4ffc 0230A0E1 		mov	r3, r2
 9303              	.LVL1112:
 9304              	.L767:
2244:../uvc.c      **** }
 9305              		.loc 1 2244 0
 9306 5000 2A10D7E5 		ldrb	r1, [r7, #42]	@ zero_extendqisi2
 9307 5004 00208DE5 		str	r2, [sp]
 9308 5008 FF00A0E3 		mov	r0, #255
 9309 500c 0920A0E1 		mov	r2, r9
 9310              	.LVL1113:
 9311 5010 08C08DE5 		str	ip, [sp, #8]
 9312 5014 14808DE5 		str	r8, [sp, #20]
 9313              	.LVL1114:
 9314              	.L955:
 9315              	.LBE226:
 9316              	.LBE225:
 9317              	.LBB234:
 9318              	.LBB235:
 9319 5018 04108DE5 		str	r1, [sp, #4]
 9320 501c 10108DE5 		str	r1, [sp, #16]
 9321 5020 0C008DE5 		str	r0, [sp, #12]
 9322 5024 68169FE5 		ldr	r1, .L987+52
 9323 5028 0400A0E3 		mov	r0, #4
 9324 502c FEFFFFEB 		bl	CyU3PDebugPrint
 9325              	.LVL1115:
 9326 5030 4C309DE5 		ldr	r3, [sp, #76]
 9327 5034 EBFDFFEA 		b	.L653
 9328              	.L729:
 9329              	.LVL1116:
2029:../uvc.c      **** 
 9330              		.loc 1 2029 0
 9331 5038 30C69FE5 		ldr	ip, .L987+16
2022:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 9332              		.loc 1 2022 0
 9333 503c D0E6DBE5 		ldrb	lr, [fp, #1744]	@ zero_extendqisi2
2029:../uvc.c      **** 
 9334              		.loc 1 2029 0
 9335 5040 0080DCE5 		ldrb	r8, [ip]	@ zero_extendqisi2
2021:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 9336              		.loc 1 2021 0
 9337 5044 DF36DBE5 		ldrb	r3, [fp, #1759]	@ zero_extendqisi2
 9338              	.LVL1117:
2031:../uvc.c      **** 		 {
 9339              		.loc 1 2031 0
 9340 5048 830058E3 		cmp	r8, #131
2022:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 9341              		.loc 1 2022 0
 9342 504c 30E08DE5 		str	lr, [sp, #48]
 9343              	.LVL1118:
2024:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9344              		.loc 1 2024 0
 9345 5050 D296DBE5 		ldrb	r9, [fp, #1746]	@ zero_extendqisi2
 9346              	.LVL1119:
2031:../uvc.c      **** 		 {
 9347              		.loc 1 2031 0
 9348 5054 FA03000A 		beq	.L806
 9349 5058 4F01009A 		bls	.L982
 9350 505c 850058E3 		cmp	r8, #133
 9351 5060 6A04000A 		beq	.L811
 9352 5064 6104003A 		bcc	.L812
 9353 5068 860058E3 		cmp	r8, #134
 9354 506c F402000A 		beq	.L813
 9355 5070 870058E3 		cmp	r8, #135
 9356 5074 6F04001A 		bne	.L805
2093:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 9357              		.loc 1 2093 0
 9358 5078 2C269FE5 		ldr	r2, .L987+76
 9359 507c DB16D2E5 		ldrb	r1, [r2, #1755]	@ zero_extendqisi2
2094:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9360              		.loc 1 2094 0
 9361 5080 DC26D2E5 		ldrb	r2, [r2, #1756]	@ zero_extendqisi2
 9362              	.L950:
2072:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 9363              		.loc 1 2072 0
 9364 5084 0030A0E3 		mov	r3, #0
2069:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 9365              		.loc 1 2069 0
 9366 5088 2810C7E5 		strb	r1, [r7, #40]
2074:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9367              		.loc 1 2074 0
 9368 508c 0900A0E1 		mov	r0, r9
 9369 5090 10169FE5 		ldr	r1, .L987+72
2070:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9370              		.loc 1 2070 0
 9371 5094 2920C7E5 		strb	r2, [r7, #41]
2072:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 9372              		.loc 1 2072 0
 9373 5098 2A30C7E5 		strb	r3, [r7, #42]
2073:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 9374              		.loc 1 2073 0
 9375 509c 2B30C7E5 		strb	r3, [r7, #43]
2074:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9376              		.loc 1 2074 0
 9377 50a0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9378              	.LVL1120:
2075:../uvc.c      **** 			  break;
 9379              		.loc 1 2075 0
 9380 50a4 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 9381              	.LVL1121:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9382              		.loc 1 2025 0
 9383 50a8 FF20A0E3 		mov	r2, #255
 9384 50ac 0230A0E1 		mov	r3, r2
 9385              	.LVL1122:
 9386              	.L815:
2244:../uvc.c      **** }
 9387              		.loc 1 2244 0
 9388 50b0 00208DE5 		str	r2, [sp]
 9389 50b4 2A10D7E5 		ldrb	r1, [r7, #42]	@ zero_extendqisi2
 9390 50b8 FF00A0E3 		mov	r0, #255
 9391 50bc 08C08DE5 		str	ip, [sp, #8]
 9392 50c0 14908DE5 		str	r9, [sp, #20]
 9393 50c4 0820A0E1 		mov	r2, r8
 9394              	.LVL1123:
 9395 50c8 D2FFFFEA 		b	.L955
 9396              	.LVL1124:
 9397              	.L721:
 9398              	.LBE235:
 9399              	.LBE234:
 9400              	.LBB244:
 9401              	.LBB245:
2029:../uvc.c      **** 
 9402              		.loc 1 2029 0
 9403 50cc 9CC59FE5 		ldr	ip, .L987+16
2024:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9404              		.loc 1 2024 0
 9405 50d0 A296DBE5 		ldrb	r9, [fp, #1698]	@ zero_extendqisi2
 9406              	.LVL1125:
2029:../uvc.c      **** 
 9407              		.loc 1 2029 0
 9408 50d4 0080DCE5 		ldrb	r8, [ip]	@ zero_extendqisi2
 9409              	.LVL1126:
2031:../uvc.c      **** 		 {
 9410              		.loc 1 2031 0
 9411 50d8 830058E3 		cmp	r8, #131
 9412 50dc E403000A 		beq	.L784
 9413 50e0 D801009A 		bls	.L983
 9414 50e4 850058E3 		cmp	r8, #133
 9415 50e8 FF01000A 		beq	.L835
 9416 50ec 4304003A 		bcc	.L790
 9417 50f0 860058E3 		cmp	r8, #134
 9418 50f4 DD02000A 		beq	.L791
 9419 50f8 870058E3 		cmp	r8, #135
 9420 50fc 5E04001A 		bne	.L783
2093:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 9421              		.loc 1 2093 0
 9422 5100 A4E59FE5 		ldr	lr, .L987+76
 9423 5104 AB16DEE5 		ldrb	r1, [lr, #1707]	@ zero_extendqisi2
2094:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9424              		.loc 1 2094 0
 9425 5108 AC26DEE5 		ldrb	r2, [lr, #1708]	@ zero_extendqisi2
 9426 510c 0E0000EA 		b	.L952
 9427              	.LVL1127:
 9428              	.L732:
 9429              	.LBE245:
 9430              	.LBE244:
 9431              	.LBB253:
 9432              	.LBB254:
2029:../uvc.c      **** 
 9433              		.loc 1 2029 0
 9434 5110 58C59FE5 		ldr	ip, .L987+16
2024:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9435              		.loc 1 2024 0
 9436 5114 0297DBE5 		ldrb	r9, [fp, #1794]	@ zero_extendqisi2
 9437              	.LVL1128:
2029:../uvc.c      **** 
 9438              		.loc 1 2029 0
 9439 5118 0080DCE5 		ldrb	r8, [ip]	@ zero_extendqisi2
 9440              	.LVL1129:
2031:../uvc.c      **** 		 {
 9441              		.loc 1 2031 0
 9442 511c 830058E3 		cmp	r8, #131
 9443 5120 DB03000A 		beq	.L830
 9444 5124 B301009A 		bls	.L984
 9445 5128 850058E3 		cmp	r8, #133
 9446 512c EE01000A 		beq	.L835
 9447 5130 6204003A 		bcc	.L836
 9448 5134 860058E3 		cmp	r8, #134
 9449 5138 9502000A 		beq	.L837
 9450 513c 870058E3 		cmp	r8, #135
2093:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 9451              		.loc 1 2093 0
 9452 5140 0B17DB05 		ldreqb	r1, [fp, #1803]	@ zero_extendqisi2
2094:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9453              		.loc 1 2094 0
 9454 5144 0C27DB05 		ldreqb	r2, [fp, #1804]	@ zero_extendqisi2
2031:../uvc.c      **** 		 {
 9455              		.loc 1 2031 0
 9456 5148 6004001A 		bne	.L829
 9457              	.LVL1130:
 9458              	.L952:
2072:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 9459              		.loc 1 2072 0
 9460 514c 0030A0E3 		mov	r3, #0
2069:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 9461              		.loc 1 2069 0
 9462 5150 2810C7E5 		strb	r1, [r7, #40]
2074:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9463              		.loc 1 2074 0
 9464 5154 0900A0E1 		mov	r0, r9
 9465 5158 48159FE5 		ldr	r1, .L987+72
2070:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9466              		.loc 1 2070 0
 9467 515c 2920C7E5 		strb	r2, [r7, #41]
2072:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 9468              		.loc 1 2072 0
 9469 5160 2A30C7E5 		strb	r3, [r7, #42]
2073:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 9470              		.loc 1 2073 0
 9471 5164 2B30C7E5 		strb	r3, [r7, #43]
2074:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9472              		.loc 1 2074 0
 9473 5168 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9474              	.LVL1131:
2075:../uvc.c      **** 			  break;
 9475              		.loc 1 2075 0
 9476 516c 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 9477              	.LVL1132:
 9478 5170 E40100EA 		b	.L839
 9479              	.LVL1133:
 9480              	.L963:
 9481              	.LBE254:
 9482              	.LBE253:
 9483              	.LBB263:
 9484              	.LBB264:
2029:../uvc.c      **** 
 9485              		.loc 1 2029 0
 9486 5174 F4C49FE5 		ldr	ip, .L987+16
2024:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 9487              		.loc 1 2024 0
 9488 5178 EA96DBE5 		ldrb	r9, [fp, #1770]	@ zero_extendqisi2
 9489              	.LVL1134:
2029:../uvc.c      **** 
 9490              		.loc 1 2029 0
 9491 517c 0080DCE5 		ldrb	r8, [ip]	@ zero_extendqisi2
 9492              	.LVL1135:
2031:../uvc.c      **** 		 {
 9493              		.loc 1 2031 0
 9494 5180 830058E3 		cmp	r8, #131
 9495 5184 B603000A 		beq	.L819
 9496 5188 C301009A 		bls	.L985
 9497 518c 850058E3 		cmp	r8, #133
 9498 5190 D501000A 		beq	.L835
 9499 5194 D303003A 		bcc	.L825
 9500 5198 860058E3 		cmp	r8, #134
 9501 519c 7E02000A 		beq	.L826
 9502 51a0 870058E3 		cmp	r8, #135
2093:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 9503              		.loc 1 2093 0
 9504 51a4 F316DB05 		ldreqb	r1, [fp, #1779]	@ zero_extendqisi2
2094:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 9505              		.loc 1 2094 0
 9506 51a8 F426DB05 		ldreqb	r2, [fp, #1780]	@ zero_extendqisi2
2031:../uvc.c      **** 		 {
 9507              		.loc 1 2031 0
 9508 51ac E6FFFF0A 		beq	.L952
 9509              	.L818:
2238:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 9510              		.loc 1 2238 0
 9511 51b0 0000A0E3 		mov	r0, #0
 9512 51b4 0020A0E1 		mov	r2, r0
 9513 51b8 0110A0E3 		mov	r1, #1
 9514 51bc 24C08DE5 		str	ip, [sp, #36]
 9515 51c0 FEFFFFEB 		bl	CyU3PUsbStall
 9516              	.LVL1136:
2239:../uvc.c      **** 			  break;
 9517              		.loc 1 2239 0
 9518 51c4 24C09DE5 		ldr	ip, [sp, #36]
 9519 51c8 0820A0E3 		mov	r2, #8
 9520 51cc 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 9521 51d0 0400A0E3 		mov	r0, #4
 9522 51d4 C8149FE5 		ldr	r1, .L987+68
 9523 51d8 FEFFFFEB 		bl	CyU3PDebugPrint
 9524              	.LVL1137:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9525              		.loc 1 2025 0
 9526 51dc FF20A0E3 		mov	r2, #255
 9527              	.LVL1138:
 9528 51e0 C80100EA 		b	.L839
 9529              	.LVL1139:
 9530              	.L733:
 9531              	.LBE264:
 9532              	.LBE263:
3771:../uvc.c      ****     		break;
 9533              		.loc 1 3771 0
 9534 51e4 0A00A0E3 		mov	r0, #10
 9535 51e8 FEFFFFEB 		bl	CTControlHandle
 9536              	.LVL1140:
 9537 51ec 4C309DE5 		ldr	r3, [sp, #76]
 9538 51f0 7CFDFFEA 		b	.L653
 9539              	.LVL1141:
 9540              	.L969:
 9541 51f4 0030A0E1 		mov	r3, r0
 9542              	.LBE331:
 9543              	.LBE418:
4623:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 9544              		.loc 1 4623 0
 9545 51f8 0320A0E1 		mov	r2, r3
 9546 51fc 0900A0E1 		mov	r0, r9
 9547              	.LVL1142:
 9548 5200 90149FE5 		ldr	r1, .L987+56
 9549 5204 28308DE5 		str	r3, [sp, #40]
 9550 5208 FEFFFFEB 		bl	CyU3PDebugPrint
 9551              	.LVL1143:
4624:../uvc.c      **** 					}
 9552              		.loc 1 4624 0
 9553 520c 28309DE5 		ldr	r3, [sp, #40]
 9554 5210 0300A0E1 		mov	r0, r3
 9555 5214 FEFFFFEB 		bl	CyFxAppErrorHandler
 9556              	.LVL1144:
 9557              	.L976:
 9558              	.LBB419:
 9559              	.LBB401:
 9560              	.LBB371:
 9561              	.LBB364:
 942:../uvc.c      **** 		 {
 9562              		.loc 1 942 0
 9563 5218 810058E3 		cmp	r8, #129
 9564 521c 1B03000A 		beq	.L695
 9565 5220 4402008A 		bhi	.L696
 9566 5224 010058E3 		cmp	r8, #1
 9567 5228 A102001A 		bne	.L706
1480:../uvc.c      **** 				  glEp0Buffer, &readCount);
 9568              		.loc 1 1480 0
 9569 522c 4A208DE2 		add	r2, sp, #74
 9570 5230 2000A0E3 		mov	r0, #32
 9571 5234 6C149FE5 		ldr	r1, .L987+72
 9572 5238 28308DE5 		str	r3, [sp, #40]
 9573 523c 24C08DE5 		str	ip, [sp, #36]
 9574 5240 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9575              	.LVL1145:
1482:../uvc.c      **** 			   {
 9576              		.loc 1 1482 0
 9577 5244 002050E2 		subs	r2, r0, #0
 9578 5248 8104001A 		bne	.L719
1972:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 9579              		.loc 1 1972 0
 9580 524c 5C149FE5 		ldr	r1, .L987+80
1487:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9581              		.loc 1 1487 0
 9582 5250 2AE0D4E5 		ldrb	lr, [r4, #42]	@ zero_extendqisi2
1972:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 9583              		.loc 1 1972 0
 9584 5254 1C0091E5 		ldr	r0, [r1, #28]
 9585              	.LVL1146:
 9586 5258 0010E0E3 		mvn	r1, #0
1484:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 9587              		.loc 1 1484 0
 9588 525c 2890D4E5 		ldrb	r9, [r4, #40]	@ zero_extendqisi2
 9589              	.LVL1147:
1487:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9590              		.loc 1 1487 0
 9591 5260 30E08DE5 		str	lr, [sp, #48]
 9592              	.LVL1148:
1972:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 9593              		.loc 1 1972 0
 9594 5264 2C208DE5 		str	r2, [sp, #44]
 9595 5268 FEFFFFEB 		bl	_txe_mutex_get
 9596              	.LVL1149:
1973:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 9597              		.loc 1 1973 0
 9598 526c 24C09DE5 		ldr	ip, [sp, #36]
 9599 5270 2C209DE5 		ldr	r2, [sp, #44]
 9600 5274 28309DE5 		ldr	r3, [sp, #40]
 9601 5278 04208DE5 		str	r2, [sp, #4]
 9602 527c 0210A0E3 		mov	r1, #2
 9603 5280 0320A0E1 		mov	r2, r3
 9604 5284 00908DE5 		str	r9, [sp]
 9605 5288 0C30A0E1 		mov	r3, ip
 9606 528c 1C049FE5 		ldr	r0, .L987+80
 9607 5290 FEFFFFEB 		bl	cmdSet
 9608              	.LVL1150:
1974:../uvc.c      **** 
 9609              		.loc 1 1974 0
 9610 5294 14149FE5 		ldr	r1, .L987+80
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9611              		.loc 1 930 0
 9612 5298 FF30A0E3 		mov	r3, #255
1974:../uvc.c      **** 
 9613              		.loc 1 1974 0
 9614 529c 1C0091E5 		ldr	r0, [r1, #28]
 9615 52a0 28308DE5 		str	r3, [sp, #40]
 9616 52a4 FEFFFFEB 		bl	_txe_mutex_put
 9617              	.LVL1151:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9618              		.loc 1 930 0
 9619 52a8 28309DE5 		ldr	r3, [sp, #40]
1976:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 9620              		.loc 1 1976 0
 9621 52ac F8C39FE5 		ldr	ip, .L987+76
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9622              		.loc 1 930 0
 9623 52b0 0320A0E1 		mov	r2, r3
1976:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 9624              		.loc 1 1976 0
 9625 52b4 2992CCE5 		strb	r9, [ip, #553]
1977:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][13] = Data0;  //it's canceled as the both is the same contro
 9626              		.loc 1 1977 0
 9627 52b8 2C82CCE5 		strb	r8, [ip, #556]
 9628 52bc 30C09DE5 		ldr	ip, [sp, #48]
 9629 52c0 F50100EA 		b	.L716
 9630              	.LVL1152:
 9631              	.L966:
 9632              	.LBE364:
 9633              	.LBE371:
 9634              	.LBB372:
 9635              	.LBB341:
 942:../uvc.c      **** 		 {
 9636              		.loc 1 942 0
 9637 52c4 810058E3 		cmp	r8, #129
 9638 52c8 F902000A 		beq	.L677
 9639 52cc FF01008A 		bhi	.L678
 9640 52d0 010058E3 		cmp	r8, #1
 9641 52d4 B802001A 		bne	.L674
1480:../uvc.c      **** 				  glEp0Buffer, &readCount);
 9642              		.loc 1 1480 0
 9643 52d8 4A208DE2 		add	r2, sp, #74
 9644 52dc 2000A0E3 		mov	r0, #32
 9645 52e0 C0139FE5 		ldr	r1, .L987+72
 9646 52e4 28308DE5 		str	r3, [sp, #40]
 9647 52e8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9648              	.LVL1153:
1482:../uvc.c      **** 			   {
 9649              		.loc 1 1482 0
 9650 52ec 002050E2 		subs	r2, r0, #0
 9651 52f0 8404001A 		bne	.L689
1808:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 9652              		.loc 1 1808 0
 9653 52f4 B4C39FE5 		ldr	ip, .L987+80
 9654 52f8 B0E39FE5 		ldr	lr, .L987+80
 9655 52fc 34C08DE5 		str	ip, [sp, #52]
1484:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 9656              		.loc 1 1484 0
 9657 5300 28C0D4E5 		ldrb	ip, [r4, #40]	@ zero_extendqisi2
 9658              	.LVL1154:
1808:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 9659              		.loc 1 1808 0
 9660 5304 1C009EE5 		ldr	r0, [lr, #28]
 9661              	.LVL1155:
 9662 5308 0010E0E3 		mvn	r1, #0
1487:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9663              		.loc 1 1487 0
 9664 530c 2A90D4E5 		ldrb	r9, [r4, #42]	@ zero_extendqisi2
 9665              	.LVL1156:
1808:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 9666              		.loc 1 1808 0
 9667 5310 24C08DE5 		str	ip, [sp, #36]
 9668 5314 FEFFFFEB 		bl	_txe_mutex_get
 9669              	.LVL1157:
1810:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 9670              		.loc 1 1810 0
 9671 5318 24C09DE5 		ldr	ip, [sp, #36]
 9672 531c 28309DE5 		ldr	r3, [sp, #40]
 9673 5320 80001CE3 		tst	ip, #128
1811:../uvc.c      **** 							  }else{
 9674              		.loc 1 1811 0
 9675 5324 80204C12 		subne	r2, ip, #128
1813:../uvc.c      **** 							  }
 9676              		.loc 1 1813 0
 9677 5328 0C20E001 		mvneq	r2, ip
1815:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 9678              		.loc 1 1815 0
 9679 532c 0010A0E3 		mov	r1, #0
 9680 5330 04108DE5 		str	r1, [sp, #4]
 9681 5334 74039FE5 		ldr	r0, .L987+80
 9682 5338 0110A0E3 		mov	r1, #1
 9683 533c 24C08DE5 		str	ip, [sp, #36]
1813:../uvc.c      **** 							  }
 9684              		.loc 1 1813 0
 9685 5340 FF2002E2 		and	r2, r2, #255
 9686 5344 38208DE5 		str	r2, [sp, #56]
 9687              	.LVL1158:
1815:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 9688              		.loc 1 1815 0
 9689 5348 38209DE5 		ldr	r2, [sp, #56]
 9690 534c 00208DE5 		str	r2, [sp]
 9691 5350 0320A0E1 		mov	r2, r3
 9692 5354 30309DE5 		ldr	r3, [sp, #48]
 9693 5358 FEFFFFEB 		bl	cmdSet
 9694              	.LVL1159:
1816:../uvc.c      **** 
 9695              		.loc 1 1816 0
 9696 535c 34309DE5 		ldr	r3, [sp, #52]
 9697 5360 1C0093E5 		ldr	r0, [r3, #28]
 9698 5364 FEFFFFEB 		bl	_txe_mutex_put
 9699              	.LVL1160:
1818:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 9700              		.loc 1 1818 0
 9701 5368 38E09DE5 		ldr	lr, [sp, #56]
1819:../uvc.c      **** 
 9702              		.loc 1 1819 0
 9703 536c 0130A0E3 		mov	r3, #1
 9704 5370 1432CBE5 		strb	r3, [fp, #532]
1818:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 9705              		.loc 1 1818 0
 9706 5374 11E2CBE5 		strb	lr, [fp, #529]
 9707 5378 24C09DE5 		ldr	ip, [sp, #36]
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9708              		.loc 1 930 0
 9709 537c FF30A0E3 		mov	r3, #255
 9710              	.LVL1161:
 9711              	.L684:
2005:../uvc.c      **** }
 9712              		.loc 1 2005 0
 9713 5380 FF10A0E3 		mov	r1, #255
 9714 5384 04308DE5 		str	r3, [sp, #4]
 9715 5388 08108DE5 		str	r1, [sp, #8]
 9716 538c 0C30A0E1 		mov	r3, ip
 9717              	.LVL1162:
 9718 5390 00908DE5 		str	r9, [sp]
 9719 5394 0820A0E1 		mov	r2, r8
 9720 5398 0400A0E3 		mov	r0, #4
 9721 539c F8129FE5 		ldr	r1, .L987+60
 9722 53a0 FEFFFFEB 		bl	CyU3PDebugPrint
 9723              	.LVL1163:
 9724 53a4 4C309DE5 		ldr	r3, [sp, #76]
 9725 53a8 0EFDFFEA 		b	.L653
 9726              	.LVL1164:
 9727              	.L975:
 9728              	.LBE341:
 9729              	.LBE372:
 9730              	.LBB373:
 9731              	.LBB353:
 942:../uvc.c      **** 		 {
 9732              		.loc 1 942 0
 9733 53ac 810058E3 		cmp	r8, #129
 9734 53b0 9102000A 		beq	.L709
 9735 53b4 C101008A 		bhi	.L710
 9736 53b8 010058E3 		cmp	r8, #1
 9737 53bc 3C02001A 		bne	.L706
1480:../uvc.c      **** 				  glEp0Buffer, &readCount);
 9738              		.loc 1 1480 0
 9739 53c0 4A208DE2 		add	r2, sp, #74
 9740 53c4 2000A0E3 		mov	r0, #32
 9741 53c8 D8129FE5 		ldr	r1, .L987+72
 9742 53cc 28308DE5 		str	r3, [sp, #40]
 9743 53d0 24C08DE5 		str	ip, [sp, #36]
 9744 53d4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9745              	.LVL1165:
1482:../uvc.c      **** 			   {
 9746              		.loc 1 1482 0
 9747 53d8 002050E2 		subs	r2, r0, #0
 9748 53dc 1C04001A 		bne	.L719
1985:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 9749              		.loc 1 1985 0
 9750 53e0 C8129FE5 		ldr	r1, .L987+80
1487:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9751              		.loc 1 1487 0
 9752 53e4 2AE0D4E5 		ldrb	lr, [r4, #42]	@ zero_extendqisi2
1985:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 9753              		.loc 1 1985 0
 9754 53e8 1C0091E5 		ldr	r0, [r1, #28]
 9755              	.LVL1166:
 9756 53ec 0010E0E3 		mvn	r1, #0
1484:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 9757              		.loc 1 1484 0
 9758 53f0 2890D4E5 		ldrb	r9, [r4, #40]	@ zero_extendqisi2
 9759              	.LVL1167:
1487:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9760              		.loc 1 1487 0
 9761 53f4 30E08DE5 		str	lr, [sp, #48]
 9762              	.LVL1168:
1985:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 9763              		.loc 1 1985 0
 9764 53f8 2C208DE5 		str	r2, [sp, #44]
 9765 53fc FEFFFFEB 		bl	_txe_mutex_get
 9766              	.LVL1169:
1986:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 9767              		.loc 1 1986 0
 9768 5400 24C09DE5 		ldr	ip, [sp, #36]
 9769 5404 2C209DE5 		ldr	r2, [sp, #44]
 9770 5408 28309DE5 		ldr	r3, [sp, #40]
 9771 540c 04208DE5 		str	r2, [sp, #4]
 9772 5410 0910A0E3 		mov	r1, #9
 9773 5414 0320A0E1 		mov	r2, r3
 9774 5418 00908DE5 		str	r9, [sp]
 9775 541c 0C30A0E1 		mov	r3, ip
 9776 5420 88029FE5 		ldr	r0, .L987+80
 9777 5424 FEFFFFEB 		bl	cmdSet
 9778              	.LVL1170:
1987:../uvc.c      **** 
 9779              		.loc 1 1987 0
 9780 5428 80129FE5 		ldr	r1, .L987+80
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9781              		.loc 1 930 0
 9782 542c FF30A0E3 		mov	r3, #255
1987:../uvc.c      **** 
 9783              		.loc 1 1987 0
 9784 5430 1C0091E5 		ldr	r0, [r1, #28]
 9785 5434 28308DE5 		str	r3, [sp, #40]
 9786 5438 FEFFFFEB 		bl	_txe_mutex_put
 9787              	.LVL1171:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9788              		.loc 1 930 0
 9789 543c 28309DE5 		ldr	r3, [sp, #40]
1989:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 9790              		.loc 1 1989 0
 9791 5440 64C29FE5 		ldr	ip, .L987+76
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9792              		.loc 1 930 0
 9793 5444 0320A0E1 		mov	r2, r3
1989:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 9794              		.loc 1 1989 0
 9795 5448 D192CCE5 		strb	r9, [ip, #721]
1990:../uvc.c      **** 							 break;
 9796              		.loc 1 1990 0
 9797 544c D482CCE5 		strb	r8, [ip, #724]
 9798 5450 30C09DE5 		ldr	ip, [sp, #48]
 9799 5454 900100EA 		b	.L716
 9800              	.LVL1172:
 9801              	.L978:
 9802              	.LBE353:
 9803              	.LBE373:
 9804              	.LBE401:
 9805              	.LBE419:
 9806              	.LBB420:
 9807              	.LBB332:
 9808              	.LBB270:
 9809              	.LBB202:
2031:../uvc.c      **** 		 {
 9810              		.loc 1 2031 0
 9811 5458 810058E3 		cmp	r8, #129
 9812 545c E902000A 		beq	.L749
 9813 5460 B801008A 		bhi	.L750
 9814 5464 010058E3 		cmp	r8, #1
 9815 5468 0D03001A 		bne	.L746
2102:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9816              		.loc 1 2102 0
 9817 546c 34129FE5 		ldr	r1, .L987+72
 9818 5470 4A208DE2 		add	r2, sp, #74
 9819 5474 2000A0E3 		mov	r0, #32
 9820 5478 24C08DE5 		str	ip, [sp, #36]
 9821 547c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9822              	.LVL1173:
2233:../uvc.c      **** 			  		 break;
 9823              		.loc 1 2233 0
 9824 5480 24C09DE5 		ldr	ip, [sp, #36]
2232:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9825              		.loc 1 2232 0
 9826 5484 28E0D7E5 		ldrb	lr, [r7, #40]	@ zero_extendqisi2
2233:../uvc.c      **** 			  		 break;
 9827              		.loc 1 2233 0
 9828 5488 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
2232:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9829              		.loc 1 2232 0
 9830 548c 18C29FE5 		ldr	ip, .L987+76
2233:../uvc.c      **** 			  		 break;
 9831              		.loc 1 2233 0
 9832 5490 0220A0E3 		mov	r2, #2
 9833 5494 0400A0E3 		mov	r0, #4
 9834 5498 F0119FE5 		ldr	r1, .L987+48
2232:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9835              		.loc 1 2232 0
 9836 549c 65E6CCE5 		strb	lr, [ip, #1637]
2233:../uvc.c      **** 			  		 break;
 9837              		.loc 1 2233 0
 9838 54a0 FEFFFFEB 		bl	CyU3PDebugPrint
 9839              	.LVL1174:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9840              		.loc 1 2025 0
 9841 54a4 FF20A0E3 		mov	r2, #255
 9842 54a8 160100EA 		b	.L839
 9843              	.LVL1175:
 9844              	.L974:
 9845              	.LBE202:
 9846              	.LBE270:
 9847              	.LBB271:
 9848              	.LBB195:
2031:../uvc.c      **** 		 {
 9849              		.loc 1 2031 0
 9850 54ac 810058E3 		cmp	r8, #129
 9851 54b0 D002000A 		beq	.L775
 9852 54b4 AB01008A 		bhi	.L776
 9853 54b8 010058E3 		cmp	r8, #1
 9854 54bc E0FDFF1A 		bne	.L772
2102:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9855              		.loc 1 2102 0
 9856 54c0 E0119FE5 		ldr	r1, .L987+72
 9857 54c4 4A208DE2 		add	r2, sp, #74
 9858 54c8 2000A0E3 		mov	r0, #32
 9859 54cc 24C08DE5 		str	ip, [sp, #36]
 9860 54d0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9861              	.LVL1176:
2233:../uvc.c      **** 			  		 break;
 9862              		.loc 1 2233 0
 9863 54d4 24C09DE5 		ldr	ip, [sp, #36]
2232:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9864              		.loc 1 2232 0
 9865 54d8 28E0D7E5 		ldrb	lr, [r7, #40]	@ zero_extendqisi2
2233:../uvc.c      **** 			  		 break;
 9866              		.loc 1 2233 0
 9867 54dc 0400A0E3 		mov	r0, #4
 9868 54e0 0020A0E1 		mov	r2, r0
 9869 54e4 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 9870 54e8 A0119FE5 		ldr	r1, .L987+48
2232:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9871              		.loc 1 2232 0
 9872 54ec 95E6CBE5 		strb	lr, [fp, #1685]
2233:../uvc.c      **** 			  		 break;
 9873              		.loc 1 2233 0
 9874 54f0 FEFFFFEB 		bl	CyU3PDebugPrint
 9875              	.LVL1177:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9876              		.loc 1 2025 0
 9877 54f4 FF20A0E3 		mov	r2, #255
 9878 54f8 020100EA 		b	.L839
 9879              	.LVL1178:
 9880              	.L980:
 9881              	.LBE195:
 9882              	.LBE271:
 9883              	.LBB272:
 9884              	.LBB219:
2031:../uvc.c      **** 		 {
 9885              		.loc 1 2031 0
 9886 54fc 810058E3 		cmp	r8, #129
 9887 5500 C402000A 		beq	.L738
 9888 5504 9301008A 		bhi	.L739
 9889 5508 010058E3 		cmp	r8, #1
 9890 550c 91FEFF1A 		bne	.L735
2102:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9891              		.loc 1 2102 0
 9892 5510 90119FE5 		ldr	r1, .L987+72
 9893 5514 4A208DE2 		add	r2, sp, #74
 9894 5518 2000A0E3 		mov	r0, #32
 9895 551c 24C08DE5 		str	ip, [sp, #36]
 9896 5520 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9897              	.LVL1179:
2233:../uvc.c      **** 			  		 break;
 9898              		.loc 1 2233 0
 9899 5524 24C09DE5 		ldr	ip, [sp, #36]
2232:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9900              		.loc 1 2232 0
 9901 5528 28E0D7E5 		ldrb	lr, [r7, #40]	@ zero_extendqisi2
2233:../uvc.c      **** 			  		 break;
 9902              		.loc 1 2233 0
 9903 552c 0020A0E3 		mov	r2, #0
 9904 5530 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 9905 5534 0400A0E3 		mov	r0, #4
 9906 5538 50119FE5 		ldr	r1, .L987+48
2232:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9907              		.loc 1 2232 0
 9908 553c 35E6CBE5 		strb	lr, [fp, #1589]
2233:../uvc.c      **** 			  		 break;
 9909              		.loc 1 2233 0
 9910 5540 FEFFFFEB 		bl	CyU3PDebugPrint
 9911              	.LVL1180:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9912              		.loc 1 2025 0
 9913 5544 FF20A0E3 		mov	r2, #255
 9914 5548 EE0000EA 		b	.L839
 9915              	.LVL1181:
 9916              	.L979:
 9917              	.LBE219:
 9918              	.LBE272:
 9919              	.LBB273:
 9920              	.LBB211:
2031:../uvc.c      **** 		 {
 9921              		.loc 1 2031 0
 9922 554c 810058E3 		cmp	r8, #129
 9923 5550 9A02000A 		beq	.L797
 9924 5554 AC01008A 		bhi	.L798
 9925 5558 010058E3 		cmp	r8, #1
 9926 555c 61FEFF1A 		bne	.L794
2102:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9927              		.loc 1 2102 0
 9928 5560 40119FE5 		ldr	r1, .L987+72
 9929 5564 4A208DE2 		add	r2, sp, #74
 9930 5568 2000A0E3 		mov	r0, #32
 9931 556c 24C08DE5 		str	ip, [sp, #36]
 9932 5570 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9933              	.LVL1182:
2233:../uvc.c      **** 			  		 break;
 9934              		.loc 1 2233 0
 9935 5574 24C09DE5 		ldr	ip, [sp, #36]
2232:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9936              		.loc 1 2232 0
 9937 5578 28E0D7E5 		ldrb	lr, [r7, #40]	@ zero_extendqisi2
2233:../uvc.c      **** 			  		 break;
 9938              		.loc 1 2233 0
 9939 557c 0620A0E3 		mov	r2, #6
 9940 5580 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 9941 5584 0400A0E3 		mov	r0, #4
 9942 5588 00119FE5 		ldr	r1, .L987+48
2232:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9943              		.loc 1 2232 0
 9944 558c C5E6CBE5 		strb	lr, [fp, #1733]
2233:../uvc.c      **** 			  		 break;
 9945              		.loc 1 2233 0
 9946 5590 FEFFFFEB 		bl	CyU3PDebugPrint
 9947              	.LVL1183:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9948              		.loc 1 2025 0
 9949 5594 FF20A0E3 		mov	r2, #255
 9950 5598 DA0000EA 		b	.L839
 9951              	.LVL1184:
 9952              	.L982:
 9953              	.LBE211:
 9954              	.LBE273:
 9955              	.LBB274:
 9956              	.LBB236:
2031:../uvc.c      **** 		 {
 9957              		.loc 1 2031 0
 9958 559c 810058E3 		cmp	r8, #129
 9959 55a0 FE02000A 		beq	.L808
 9960 55a4 8301008A 		bhi	.L809
 9961 55a8 010058E3 		cmp	r8, #1
 9962 55ac 2103001A 		bne	.L805
2102:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9963              		.loc 1 2102 0
 9964 55b0 2000A0E3 		mov	r0, #32
 9965 55b4 EC109FE5 		ldr	r1, .L987+72
 9966 55b8 4A208DE2 		add	r2, sp, #74
 9967 55bc 28308DE5 		str	r3, [sp, #40]
 9968 55c0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9969              	.LVL1185:
2194:../uvc.c      **** 					  {
 9970              		.loc 1 2194 0
 9971 55c4 E0C09FE5 		ldr	ip, .L987+76
 9972 55c8 4D06DCE5 		ldrb	r0, [ip, #1613]	@ zero_extendqisi2
2104:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 9973              		.loc 1 2104 0
 9974 55cc 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
2194:../uvc.c      **** 					  {
 9975              		.loc 1 2194 0
 9976 55d0 010050E3 		cmp	r0, #1
 9977 55d4 08005013 		cmpne	r0, #8
2104:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 9978              		.loc 1 2104 0
 9979 55d8 34C08DE5 		str	ip, [sp, #52]
 9980              	.LVL1186:
2105:../uvc.c      **** 			  value = Data1;
 9981              		.loc 1 2105 0
 9982 55dc 29C0D7E5 		ldrb	ip, [r7, #41]	@ zero_extendqisi2
2194:../uvc.c      **** 					  {
 9983              		.loc 1 2194 0
 9984 55e0 0000A013 		movne	r0, #0
 9985 55e4 0100A003 		moveq	r0, #1
2105:../uvc.c      **** 			  value = Data1;
 9986              		.loc 1 2105 0
 9987 55e8 38C08DE5 		str	ip, [sp, #56]
 9988              	.LVL1187:
2194:../uvc.c      **** 					  {
 9989              		.loc 1 2194 0
 9990 55ec 6503001A 		bne	.L816
 9991              	.LVL1188:
2197:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 9992              		.loc 1 2197 0
 9993 55f0 B8C09FE5 		ldr	ip, .L987+80
 9994 55f4 0010E0E3 		mvn	r1, #0
 9995 55f8 1C009CE5 		ldr	r0, [ip, #28]
 9996 55fc 24C08DE5 		str	ip, [sp, #36]
 9997 5600 FEFFFFEB 		bl	_txe_mutex_get
 9998              	.LVL1189:
2198:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 9999              		.loc 1 2198 0
 10000 5604 34E09DE5 		ldr	lr, [sp, #52]
 10001 5608 24C09DE5 		ldr	ip, [sp, #36]
 10002 560c 0010A0E3 		mov	r1, #0
 10003 5610 00E08DE5 		str	lr, [sp]
 10004 5614 30209DE5 		ldr	r2, [sp, #48]
 10005 5618 28309DE5 		ldr	r3, [sp, #40]
 10006 561c 0C00A0E1 		mov	r0, ip
 10007 5620 04108DE5 		str	r1, [sp, #4]
 10008 5624 2210A0E3 		mov	r1, #34
 10009 5628 FEFFFFEB 		bl	cmdSet
 10010              	.LVL1190:
2199:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 10011              		.loc 1 2199 0
 10012 562c 24C09DE5 		ldr	ip, [sp, #36]
 10013 5630 1C009CE5 		ldr	r0, [ip, #28]
 10014 5634 FEFFFFEB 		bl	_txe_mutex_put
 10015              	.LVL1191:
2202:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 10016              		.loc 1 2202 0
 10017 5638 6CE09FE5 		ldr	lr, .L987+76
 10018 563c 34C09DE5 		ldr	ip, [sp, #52]
2204:../uvc.c      **** 					  }else{
 10019              		.loc 1 2204 0
 10020 5640 E086CEE5 		strb	r8, [lr, #1760]
2202:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 10021              		.loc 1 2202 0
 10022 5644 DDC6CEE5 		strb	ip, [lr, #1757]
2203:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 10023              		.loc 1 2203 0
 10024 5648 38C09DE5 		ldr	ip, [sp, #56]
 10025 564c DEC6CEE5 		strb	ip, [lr, #1758]
 10026              	.LVL1192:
 10027              	.L817:
2208:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
 10028              		.loc 1 2208 0
 10029 5650 2830D7E5 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
 10030              	.LVL1193:
2209:../uvc.c      **** 
 10031              		.loc 1 2209 0
 10032 5654 2920D7E5 		ldrb	r2, [r7, #41]	@ zero_extendqisi2
 10033              	.LVL1194:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10034              		.loc 1 2025 0
 10035 5658 FFC0A0E3 		mov	ip, #255
 10036 565c 93FEFFEA 		b	.L815
 10037              	.L988:
 10038              		.align	2
 10039              	.L987:
 10040 5660 00000000 		.word	.LANCHOR0
 10041 5664 00000000 		.word	glInterStaBuffer
 10042 5668 00000000 		.word	wIndex
 10043 566c 00000000 		.word	wValue
 10044 5670 00000000 		.word	bRequest
 10045 5674 4C0C0000 		.word	.LC70
 10046 5678 00000000 		.word	bmReqType
 10047 567c 00000000 		.word	wLength
 10048 5680 D00B0000 		.word	.LC69
 10049 5684 00000000 		.word	glChHandleInterStat
 10050 5688 FFFF0000 		.word	65535
 10051 568c 58010000 		.word	.LANCHOR2+344
 10052 5690 44060000 		.word	.LC37
 10053 5694 8C060000 		.word	.LC39
 10054 5698 780C0000 		.word	.LC71
 10055 569c CC050000 		.word	.LC35
 10056 56a0 20050000 		.word	.LC31
 10057 56a4 68060000 		.word	.LC38
 10058 56a8 28000000 		.word	.LANCHOR0+40
 10059 56ac 00000000 		.word	.LANCHOR1
 10060 56b0 00000000 		.word	cmdQu
 10061 56b4 9C050000 		.word	.LC34
 10062              	.LVL1195:
 10063              	.L981:
 10064              	.LBE236:
 10065              	.LBE274:
 10066              	.LBB275:
 10067              	.LBB227:
2031:../uvc.c      **** 		 {
 10068              		.loc 1 2031 0
 10069 56b8 810059E3 		cmp	r9, #129
 10070 56bc 2C02000A 		beq	.L760
 10071 56c0 4D01008A 		bhi	.L761
 10072 56c4 010059E3 		cmp	r9, #1
 10073 56c8 9302001A 		bne	.L757
2102:../uvc.c      **** 			  glEp0Buffer, &readCount);
 10074              		.loc 1 2102 0
 10075 56cc 4A208DE2 		add	r2, sp, #74
 10076 56d0 2000A0E3 		mov	r0, #32
 10077 56d4 34101FE5 		ldr	r1, .L987+72
 10078 56d8 28308DE5 		str	r3, [sp, #40]
 10079 56dc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10080              	.LVL1196:
2104:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 10081              		.loc 1 2104 0
 10082 56e0 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
2160:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 10083              		.loc 1 2160 0
 10084 56e4 4D26DBE5 		ldrb	r2, [fp, #1613]	@ zero_extendqisi2
2104:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 10085              		.loc 1 2104 0
 10086 56e8 34C08DE5 		str	ip, [sp, #52]
 10087              	.LVL1197:
2105:../uvc.c      **** 			  value = Data1;
 10088              		.loc 1 2105 0
 10089 56ec 29C0D7E5 		ldrb	ip, [r7, #41]	@ zero_extendqisi2
2160:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 10090              		.loc 1 2160 0
 10091 56f0 010052E3 		cmp	r2, #1
 10092 56f4 04005213 		cmpne	r2, #4
2105:../uvc.c      **** 			  value = Data1;
 10093              		.loc 1 2105 0
 10094 56f8 38C08DE5 		str	ip, [sp, #56]
 10095              	.LVL1198:
2160:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 10096              		.loc 1 2160 0
 10097 56fc 28309DE5 		ldr	r3, [sp, #40]
 10098 5700 6301001A 		bne	.L768
2159:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 10099              		.loc 1 2159 0
 10100 5704 34109DE5 		ldr	r1, [sp, #52]
 10101 5708 0CE481E1 		orr	lr, r1, ip, asl #8
2161:../uvc.c      **** 					  {
 10102              		.loc 1 2161 0
 10103 570c F9005EE3 		cmp	lr, #249
 10104 5710 5F01008A 		bhi	.L768
 10105 5714 94C01FE5 		ldr	ip, .L987+40
 10106 5718 0020A0E3 		mov	r2, #0
 10107 571c 0100A0E3 		mov	r0, #1
 10108 5720 20308DE5 		str	r3, [sp, #32]
 10109 5724 1C808DE5 		str	r8, [sp, #28]
 10110              	.LVL1199:
 10111              	.L770:
2165:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 10112              		.loc 1 2165 0
 10113 5728 A4801FE5 		ldr	r8, .L987+44
 10114 572c 8230A0E1 		mov	r3, r2, asl #1
 10115 5730 B33098E1 		ldrh	r3, [r8, r3]
 10116 5734 FF1002E2 		and	r1, r2, #255
2166:../uvc.c      **** 							}else{
 10117              		.loc 1 2166 0
 10118 5738 0E8063E0 		rsb	r8, r3, lr
 10119 573c 03005EE1 		cmp	lr, r3
 10120 5740 3C108DE5 		str	r1, [sp, #60]
2168:../uvc.c      **** 							}
 10121              		.loc 1 2168 0
 10122 5744 03106EE0 		rsb	r1, lr, r3
 10123 5748 0138A091 		movls	r3, r1, asl #16
 10124 574c 0838A081 		movhi	r3, r8, asl #16
 10125 5750 3C809DE5 		ldr	r8, [sp, #60]
 10126 5754 2338A0E1 		mov	r3, r3, lsr #16
 10127 5758 0C0053E1 		cmp	r3, ip
 10128 575c 012082E2 		add	r2, r2, #1
 10129 5760 0800A031 		movcc	r0, r8
 10130              	.LVL1200:
 10131 5764 0C0053E1 		cmp	r3, ip
 10132 5768 03C0A031 		movcc	ip, r3
 10133              	.LVL1201:
2163:../uvc.c      **** 						  {
 10134              		.loc 1 2163 0
 10135 576c 080052E3 		cmp	r2, #8
 10136 5770 ECFFFF1A 		bne	.L770
2178:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 10137              		.loc 1 2178 0
 10138 5774 CCC01FE5 		ldr	ip, .L987+80
 10139              	.LVL1202:
 10140 5778 20309DE5 		ldr	r3, [sp, #32]
2175:../uvc.c      **** 
 10141              		.loc 1 2175 0
 10142 577c 012080E2 		add	r2, r0, #1
 10143 5780 FF2002E2 		and	r2, r2, #255
2178:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 10144              		.loc 1 2178 0
 10145 5784 1C009CE5 		ldr	r0, [ip, #28]
 10146              	.LVL1203:
 10147 5788 0010E0E3 		mvn	r1, #0
2175:../uvc.c      **** 
 10148              		.loc 1 2175 0
 10149 578c 3C208DE5 		str	r2, [sp, #60]
 10150              	.LVL1204:
2178:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 10151              		.loc 1 2178 0
 10152 5790 28308DE5 		str	r3, [sp, #40]
 10153 5794 24C08DE5 		str	ip, [sp, #36]
 10154 5798 1C809DE5 		ldr	r8, [sp, #28]
 10155 579c FEFFFFEB 		bl	_txe_mutex_get
 10156              	.LVL1205:
2179:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 10157              		.loc 1 2179 0
 10158 57a0 3CE09DE5 		ldr	lr, [sp, #60]
 10159 57a4 24C09DE5 		ldr	ip, [sp, #36]
 10160 57a8 0010A0E3 		mov	r1, #0
 10161 57ac 28309DE5 		ldr	r3, [sp, #40]
 10162 57b0 00E08DE5 		str	lr, [sp]
 10163 57b4 30209DE5 		ldr	r2, [sp, #48]
 10164 57b8 0C00A0E1 		mov	r0, ip
 10165 57bc 04108DE5 		str	r1, [sp, #4]
 10166 57c0 0310A0E3 		mov	r1, #3
 10167 57c4 FEFFFFEB 		bl	cmdSet
 10168              	.LVL1206:
2180:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 10169              		.loc 1 2180 0
 10170 57c8 24C09DE5 		ldr	ip, [sp, #36]
 10171 57cc 1C009CE5 		ldr	r0, [ip, #28]
 10172 57d0 FEFFFFEB 		bl	_txe_mutex_put
 10173              	.LVL1207:
2186:../uvc.c      **** 					  }else{
 10174              		.loc 1 2186 0
 10175 57d4 3CC09DE5 		ldr	ip, [sp, #60]
2185:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 10176              		.loc 1 2185 0
 10177 57d8 0130A0E3 		mov	r3, #1
2186:../uvc.c      **** 					  }else{
 10178              		.loc 1 2186 0
 10179 57dc 79C3CBE5 		strb	ip, [fp, #889]
2183:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 10180              		.loc 1 2183 0
 10181 57e0 34C09DE5 		ldr	ip, [sp, #52]
2185:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 10182              		.loc 1 2185 0
 10183 57e4 8036CBE5 		strb	r3, [fp, #1664]
2183:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 10184              		.loc 1 2183 0
 10185 57e8 7DC6CBE5 		strb	ip, [fp, #1661]
2184:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 10186              		.loc 1 2184 0
 10187 57ec 38C09DE5 		ldr	ip, [sp, #56]
 10188 57f0 7EC6CBE5 		strb	ip, [fp, #1662]
 10189 57f4 2A0100EA 		b	.L771
 10190              	.LVL1208:
 10191              	.L984:
 10192              	.LBE227:
 10193              	.LBE275:
 10194              	.LBB276:
 10195              	.LBB255:
2031:../uvc.c      **** 		 {
 10196              		.loc 1 2031 0
 10197 57f8 810058E3 		cmp	r8, #129
 10198 57fc 5702000A 		beq	.L832
 10199 5800 F400008A 		bhi	.L833
 10200 5804 010058E3 		cmp	r8, #1
 10201 5808 B002001A 		bne	.L829
2102:../uvc.c      **** 			  glEp0Buffer, &readCount);
 10202              		.loc 1 2102 0
 10203 580c 6C111FE5 		ldr	r1, .L987+72
 10204 5810 4A208DE2 		add	r2, sp, #74
 10205 5814 2000A0E3 		mov	r0, #32
 10206 5818 24C08DE5 		str	ip, [sp, #36]
 10207 581c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10208              	.LVL1209:
2233:../uvc.c      **** 			  		 break;
 10209              		.loc 1 2233 0
 10210 5820 24C09DE5 		ldr	ip, [sp, #36]
2232:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 10211              		.loc 1 2232 0
 10212 5824 28E0D7E5 		ldrb	lr, [r7, #40]	@ zero_extendqisi2
2233:../uvc.c      **** 			  		 break;
 10213              		.loc 1 2233 0
 10214 5828 0920A0E3 		mov	r2, #9
 10215 582c 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 10216 5830 0400A0E3 		mov	r0, #4
 10217 5834 AC111FE5 		ldr	r1, .L987+48
2232:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 10218              		.loc 1 2232 0
 10219 5838 0DE7CBE5 		strb	lr, [fp, #1805]
2233:../uvc.c      **** 			  		 break;
 10220              		.loc 1 2233 0
 10221 583c FEFFFFEB 		bl	CyU3PDebugPrint
 10222              	.LVL1210:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10223              		.loc 1 2025 0
 10224 5840 FF20A0E3 		mov	r2, #255
 10225 5844 2F0000EA 		b	.L839
 10226              	.LVL1211:
 10227              	.L983:
 10228              	.LBE255:
 10229              	.LBE276:
 10230              	.LBB277:
 10231              	.LBB246:
2031:../uvc.c      **** 		 {
 10232              		.loc 1 2031 0
 10233 5848 810058E3 		cmp	r8, #129
 10234 584c 6302000A 		beq	.L786
 10235 5850 DC00008A 		bhi	.L787
 10236 5854 010058E3 		cmp	r8, #1
 10237 5858 8702001A 		bne	.L783
2102:../uvc.c      **** 			  glEp0Buffer, &readCount);
 10238              		.loc 1 2102 0
 10239 585c BC111FE5 		ldr	r1, .L987+72
 10240 5860 4A208DE2 		add	r2, sp, #74
 10241 5864 2000A0E3 		mov	r0, #32
 10242 5868 24C08DE5 		str	ip, [sp, #36]
 10243 586c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10244              	.LVL1212:
2233:../uvc.c      **** 			  		 break;
 10245              		.loc 1 2233 0
 10246 5870 24C09DE5 		ldr	ip, [sp, #36]
2232:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 10247              		.loc 1 2232 0
 10248 5874 28E0D7E5 		ldrb	lr, [r7, #40]	@ zero_extendqisi2
2233:../uvc.c      **** 			  		 break;
 10249              		.loc 1 2233 0
 10250 5878 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
2232:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 10251              		.loc 1 2232 0
 10252 587c D8C11FE5 		ldr	ip, .L987+76
2233:../uvc.c      **** 			  		 break;
 10253              		.loc 1 2233 0
 10254 5880 0520A0E3 		mov	r2, #5
 10255 5884 0400A0E3 		mov	r0, #4
 10256 5888 00121FE5 		ldr	r1, .L987+48
2232:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 10257              		.loc 1 2232 0
 10258 588c ADE6CCE5 		strb	lr, [ip, #1709]
2233:../uvc.c      **** 			  		 break;
 10259              		.loc 1 2233 0
 10260 5890 FEFFFFEB 		bl	CyU3PDebugPrint
 10261              	.LVL1213:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10262              		.loc 1 2025 0
 10263 5894 FF20A0E3 		mov	r2, #255
 10264 5898 1A0000EA 		b	.L839
 10265              	.LVL1214:
 10266              	.L985:
 10267              	.LBE246:
 10268              	.LBE277:
 10269              	.LBB278:
 10270              	.LBB265:
2031:../uvc.c      **** 		 {
 10271              		.loc 1 2031 0
 10272 589c 810058E3 		cmp	r8, #129
 10273 58a0 E001000A 		beq	.L821
 10274 58a4 BE00008A 		bhi	.L822
 10275 58a8 010058E3 		cmp	r8, #1
 10276 58ac 3FFEFF1A 		bne	.L818
2102:../uvc.c      **** 			  glEp0Buffer, &readCount);
 10277              		.loc 1 2102 0
 10278 58b0 10121FE5 		ldr	r1, .L987+72
 10279 58b4 4A208DE2 		add	r2, sp, #74
 10280 58b8 2000A0E3 		mov	r0, #32
 10281 58bc 24C08DE5 		str	ip, [sp, #36]
 10282 58c0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10283              	.LVL1215:
2233:../uvc.c      **** 			  		 break;
 10284              		.loc 1 2233 0
 10285 58c4 24C09DE5 		ldr	ip, [sp, #36]
2232:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 10286              		.loc 1 2232 0
 10287 58c8 28E0D7E5 		ldrb	lr, [r7, #40]	@ zero_extendqisi2
2233:../uvc.c      **** 			  		 break;
 10288              		.loc 1 2233 0
 10289 58cc 0820A0E3 		mov	r2, #8
 10290 58d0 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 10291 58d4 0400A0E3 		mov	r0, #4
 10292 58d8 50121FE5 		ldr	r1, .L987+48
2232:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 10293              		.loc 1 2232 0
 10294 58dc F5E6CBE5 		strb	lr, [fp, #1781]
2233:../uvc.c      **** 			  		 break;
 10295              		.loc 1 2233 0
 10296 58e0 FEFFFFEB 		bl	CyU3PDebugPrint
 10297              	.LVL1216:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10298              		.loc 1 2025 0
 10299 58e4 FF20A0E3 		mov	r2, #255
 10300 58e8 060000EA 		b	.L839
 10301              	.LVL1217:
 10302              	.L835:
 10303              	.LBE265:
 10304              	.LBE278:
 10305              	.LBB279:
 10306              	.LBB256:
2036:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10307              		.loc 1 2036 0
 10308 58ec 0030A0E3 		mov	r3, #0
2037:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10309              		.loc 1 2037 0
 10310 58f0 0200A0E3 		mov	r0, #2
 10311 58f4 54121FE5 		ldr	r1, .L987+72
2035:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10312              		.loc 1 2035 0
 10313 58f8 2890C7E5 		strb	r9, [r7, #40]
2036:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10314              		.loc 1 2036 0
 10315 58fc 2930C7E5 		strb	r3, [r7, #41]
2037:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10316              		.loc 1 2037 0
 10317 5900 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10318              	.LVL1218:
2038:../uvc.c      **** 			  break;
 10319              		.loc 1 2038 0
 10320 5904 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 10321              	.LVL1219:
 10322              	.L839:
2244:../uvc.c      **** }
 10323              		.loc 1 2244 0
 10324 5908 2A10D7E5 		ldrb	r1, [r7, #42]	@ zero_extendqisi2
 10325 590c FF30A0E3 		mov	r3, #255
 10326 5910 08208DE5 		str	r2, [sp, #8]
 10327 5914 04108DE5 		str	r1, [sp, #4]
 10328 5918 10108DE5 		str	r1, [sp, #16]
 10329 591c 00308DE5 		str	r3, [sp]
 10330 5920 0C308DE5 		str	r3, [sp, #12]
 10331 5924 14908DE5 		str	r9, [sp, #20]
 10332 5928 0820A0E1 		mov	r2, r8
 10333              	.LVL1220:
 10334 592c 0400A0E3 		mov	r0, #4
 10335 5930 A4121FE5 		ldr	r1, .L987+52
 10336 5934 FEFFFFEB 		bl	CyU3PDebugPrint
 10337              	.LVL1221:
 10338 5938 4C309DE5 		ldr	r3, [sp, #76]
 10339 593c A9FBFFEA 		b	.L653
 10340              	.LVL1222:
 10341              	.L852:
 10342              	.LBE256:
 10343              	.LBE279:
 10344              	.LBE332:
 10345              	.LBE420:
 10346              	.LBB421:
 10347              	.LBB185:
3963:../uvc.c      ****     		break;
 10348              		.loc 1 3963 0
 10349 5940 1300A0E3 		mov	r0, #19
 10350 5944 FEFFFFEB 		bl	ControlHandle
 10351              	.LVL1223:
 10352 5948 4C309DE5 		ldr	r3, [sp, #76]
 10353 594c A5FBFFEA 		b	.L653
 10354              	.L865:
 10355              	.LVL1224:
4012:../uvc.c      ****     		break;
 10356              		.loc 1 4012 0
 10357 5950 1E00A0E3 		mov	r0, #30
 10358 5954 FEFFFFEB 		bl	ControlHandle
 10359              	.LVL1225:
 10360 5958 4C309DE5 		ldr	r3, [sp, #76]
 10361 595c A1FBFFEA 		b	.L653
 10362              	.L863:
 10363              	.LVL1226:
4020:../uvc.c      ****     		break;
 10364              		.loc 1 4020 0
 10365 5960 2400A0E3 		mov	r0, #36
 10366 5964 FEFFFFEB 		bl	ControlHandle
 10367              	.LVL1227:
 10368 5968 4C309DE5 		ldr	r3, [sp, #76]
 10369 596c 9DFBFFEA 		b	.L653
 10370              	.L856:
 10371              	.LVL1228:
3975:../uvc.c      ****     		break;
 10372              		.loc 1 3975 0
 10373 5970 1600A0E3 		mov	r0, #22
 10374 5974 FEFFFFEB 		bl	ControlHandle
 10375              	.LVL1229:
 10376 5978 4C309DE5 		ldr	r3, [sp, #76]
 10377 597c 99FBFFEA 		b	.L653
 10378              	.L867:
 10379              	.LVL1230:
4024:../uvc.c      ****     		break;
 10380              		.loc 1 4024 0
 10381 5980 2500A0E3 		mov	r0, #37
 10382 5984 FEFFFFEB 		bl	ControlHandle
 10383              	.LVL1231:
 10384 5988 4C309DE5 		ldr	r3, [sp, #76]
 10385 598c 95FBFFEA 		b	.L653
 10386              	.L859:
 10387              	.LVL1232:
3998:../uvc.c      ****     		break;
 10388              		.loc 1 3998 0
 10389 5990 1B00A0E3 		mov	r0, #27
 10390 5994 FEFFFFEB 		bl	ControlHandle
 10391              	.LVL1233:
 10392 5998 4C309DE5 		ldr	r3, [sp, #76]
 10393 599c 91FBFFEA 		b	.L653
 10394              	.L874:
4056:../uvc.c      ****     		break;
 10395              		.loc 1 4056 0
 10396 59a0 2E00A0E3 		mov	r0, #46
 10397 59a4 FEFFFFEB 		bl	ControlHandle
 10398              	.LVL1234:
 10399 59a8 4C309DE5 		ldr	r3, [sp, #76]
 10400 59ac 8DFBFFEA 		b	.L653
 10401              	.L850:
 10402              	.LVL1235:
3951:../uvc.c      ****     		break;
 10403              		.loc 1 3951 0
 10404 59b0 1000A0E3 		mov	r0, #16
 10405 59b4 FEFFFFEB 		bl	ControlHandle
 10406              	.LVL1236:
 10407 59b8 4C309DE5 		ldr	r3, [sp, #76]
 10408 59bc 89FBFFEA 		b	.L653
 10409              	.L848:
 10410              	.LVL1237:
3959:../uvc.c      ****      		break;
 10411              		.loc 1 3959 0
 10412 59c0 1200A0E3 		mov	r0, #18
 10413 59c4 FEFFFFEB 		bl	ControlHandle
 10414              	.LVL1238:
 10415 59c8 4C309DE5 		ldr	r3, [sp, #76]
 10416 59cc 85FBFFEA 		b	.L653
 10417              	.L873:
4052:../uvc.c      ****     		break;
 10418              		.loc 1 4052 0
 10419 59d0 2D00A0E3 		mov	r0, #45
 10420 59d4 FEFFFFEB 		bl	ControlHandle
 10421              	.LVL1239:
 10422 59d8 4C309DE5 		ldr	r3, [sp, #76]
 10423 59dc 81FBFFEA 		b	.L653
 10424              	.L869:
4044:../uvc.c      ****     		break;
 10425              		.loc 1 4044 0
 10426 59e0 2A00A0E3 		mov	r0, #42
 10427 59e4 FEFFFFEB 		bl	ControlHandle
 10428              	.LVL1240:
 10429 59e8 4C309DE5 		ldr	r3, [sp, #76]
 10430 59ec 7DFBFFEA 		b	.L653
 10431              	.L861:
4032:../uvc.c      ****     		break;
 10432              		.loc 1 4032 0
 10433 59f0 2700A0E3 		mov	r0, #39
 10434 59f4 FEFFFFEB 		bl	ControlHandle
 10435              	.LVL1241:
 10436 59f8 4C309DE5 		ldr	r3, [sp, #76]
 10437 59fc 79FBFFEA 		b	.L653
 10438              	.L858:
 10439              	.LVL1242:
3994:../uvc.c      ****     		break;
 10440              		.loc 1 3994 0
 10441 5a00 1A00A0E3 		mov	r0, #26
 10442 5a04 FEFFFFEB 		bl	ControlHandle
 10443              	.LVL1243:
 10444 5a08 4C309DE5 		ldr	r3, [sp, #76]
 10445 5a0c 75FBFFEA 		b	.L653
 10446              	.L854:
 10447              	.LVL1244:
3983:../uvc.c      ****      		break;
 10448              		.loc 1 3983 0
 10449 5a10 1800A0E3 		mov	r0, #24
 10450 5a14 FEFFFFEB 		bl	ControlHandle
 10451              	.LVL1245:
 10452 5a18 4C309DE5 		ldr	r3, [sp, #76]
 10453 5a1c 71FBFFEA 		b	.L653
 10454              	.L871:
4036:../uvc.c      ****     		break;
 10455              		.loc 1 4036 0
 10456 5a20 2800A0E3 		mov	r0, #40
 10457 5a24 FEFFFFEB 		bl	ControlHandle
 10458              	.LVL1246:
 10459 5a28 4C309DE5 		ldr	r3, [sp, #76]
 10460 5a2c 6DFBFFEA 		b	.L653
 10461              	.L846:
 10462              	.LVL1247:
3971:../uvc.c      ****      		break;
 10463              		.loc 1 3971 0
 10464 5a30 1500A0E3 		mov	r0, #21
 10465 5a34 FEFFFFEB 		bl	ControlHandle
 10466              	.LVL1248:
 10467 5a38 4C309DE5 		ldr	r3, [sp, #76]
 10468 5a3c 69FBFFEA 		b	.L653
 10469              	.L844:
 10470              	.LVL1249:
4004:../uvc.c      ****     		break;
 10471              		.loc 1 4004 0
 10472 5a40 1C00A0E3 		mov	r0, #28
 10473 5a44 FEFFFFEB 		bl	ControlHandle
 10474              	.LVL1250:
 10475 5a48 4C309DE5 		ldr	r3, [sp, #76]
 10476 5a4c 65FBFFEA 		b	.L653
 10477              	.LVL1251:
 10478              	.L970:
 10479 5a50 0290A0E1 		mov	r9, r2
 10480              	.LBE185:
 10481              	.LBE421:
4596:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 10482              		.loc 1 4596 0
 10483 5a54 0C00A0E1 		mov	r0, ip
 10484              	.LVL1252:
 10485 5a58 C8131FE5 		ldr	r1, .L987+56
 10486 5a5c FEFFFFEB 		bl	CyU3PDebugPrint
 10487              	.LVL1253:
4597:../uvc.c      **** 					}
 10488              		.loc 1 4597 0
 10489 5a60 0900A0E1 		mov	r0, r9
 10490 5a64 FEFFFFEB 		bl	CyFxAppErrorHandler
 10491              	.LVL1254:
 10492              	.L712:
 10493              	.LBB422:
 10494              	.LBB402:
 10495              	.LBB374:
 10496              	.LBB354:
 948:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10497              		.loc 1 948 0
 10498 5a68 C8131FE5 		ldr	r1, .L987+72
 947:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10499              		.loc 1 947 0
 10500 5a6c 0020A0E3 		mov	r2, #0
 948:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10501              		.loc 1 948 0
 10502 5a70 0200A0E3 		mov	r0, #2
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10503              		.loc 1 930 0
 10504 5a74 FF30A0E3 		mov	r3, #255
 946:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10505              		.loc 1 946 0
 10506 5a78 2890C7E5 		strb	r9, [r7, #40]
 10507              	.L940:
1412:../uvc.c      **** 			 }
 10508              		.loc 1 1412 0
 10509 5a7c 2920C7E5 		strb	r2, [r7, #41]
 10510              	.L943:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10511              		.loc 1 930 0
 10512 5a80 30308DE5 		str	r3, [sp, #48]
1414:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10513              		.loc 1 1414 0
 10514 5a84 28308DE5 		str	r3, [sp, #40]
 10515 5a88 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10516              	.LVL1255:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10517              		.loc 1 930 0
 10518 5a8c 28309DE5 		ldr	r3, [sp, #40]
1415:../uvc.c      **** 			  break;
 10519              		.loc 1 1415 0
 10520 5a90 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 10521              	.LVL1256:
 10522 5a94 30C09DE5 		ldr	ip, [sp, #48]
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10523              		.loc 1 930 0
 10524 5a98 0390A0E1 		mov	r9, r3
 10525              	.LVL1257:
 10526              	.L716:
2005:../uvc.c      **** }
 10527              		.loc 1 2005 0
 10528 5a9c 0C008DE9 		stmib	sp, {r2, r3}
 10529 5aa0 0C141FE5 		ldr	r1, .L987+60
 10530 5aa4 0930A0E1 		mov	r3, r9
 10531              	.LVL1258:
 10532 5aa8 00C08DE5 		str	ip, [sp]
 10533 5aac 0820A0E1 		mov	r2, r8
 10534              	.LVL1259:
 10535 5ab0 0400A0E3 		mov	r0, #4
 10536 5ab4 FEFFFFEB 		bl	CyU3PDebugPrint
 10537              	.LVL1260:
 10538 5ab8 4C309DE5 		ldr	r3, [sp, #76]
 10539 5abc 49FBFFEA 		b	.L653
 10540              	.LVL1261:
 10541              	.L710:
1411:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 10542              		.loc 1 1411 0
 10543 5ac0 1CE41FE5 		ldr	lr, .L987+76
 10544 5ac4 C7C2DEE5 		ldrb	ip, [lr, #711]	@ zero_extendqisi2
1412:../uvc.c      **** 			 }
 10545              		.loc 1 1412 0
 10546 5ac8 C822DEE5 		ldrb	r2, [lr, #712]	@ zero_extendqisi2
 10547 5acc 7BFCFFEA 		b	.L942
 10548              	.LVL1262:
 10549              	.L678:
 10550              	.LBE354:
 10551              	.LBE374:
 10552              	.LBB375:
 10553              	.LBB342:
1411:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 10554              		.loc 1 1411 0
 10555 5ad0 0722DBE5 		ldrb	r2, [fp, #519]	@ zero_extendqisi2
1412:../uvc.c      **** 			 }
 10556              		.loc 1 1412 0
 10557 5ad4 0832DBE5 		ldrb	r3, [fp, #520]	@ zero_extendqisi2
 10558 5ad8 76FBFFEA 		b	.L935
 10559              	.LVL1263:
 10560              	.L700:
 10561              	.LBE342:
 10562              	.LBE375:
 10563              	.LBB376:
 10564              	.LBB365:
1456:../uvc.c      **** 		 	 }
 10565              		.loc 1 1456 0
 10566 5adc 38341FE5 		ldr	r3, .L987+76
1458:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10567              		.loc 1 1458 0
 10568 5ae0 0100A0E3 		mov	r0, #1
1456:../uvc.c      **** 		 	 }
 10569              		.loc 1 1456 0
 10570 5ae4 2522D3E5 		ldrb	r2, [r3, #549]	@ zero_extendqisi2
1458:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10571              		.loc 1 1458 0
 10572 5ae8 48141FE5 		ldr	r1, .L987+72
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10573              		.loc 1 930 0
 10574 5aec FF30A0E3 		mov	r3, #255
1456:../uvc.c      **** 		 	 }
 10575              		.loc 1 1456 0
 10576 5af0 2820C7E5 		strb	r2, [r7, #40]
 10577 5af4 E1FFFFEA 		b	.L943
 10578              	.LVL1264:
 10579              	.L714:
 10580              	.LBE365:
 10581              	.LBE376:
 10582              	.LBB377:
 10583              	.LBB355:
 10584 5af8 54341FE5 		ldr	r3, .L987+76
1458:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10585              		.loc 1 1458 0
 10586 5afc 0100A0E3 		mov	r0, #1
1456:../uvc.c      **** 		 	 }
 10587              		.loc 1 1456 0
 10588 5b00 CD22D3E5 		ldrb	r2, [r3, #717]	@ zero_extendqisi2
1458:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10589              		.loc 1 1458 0
 10590 5b04 64141FE5 		ldr	r1, .L987+72
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10591              		.loc 1 930 0
 10592 5b08 FF30A0E3 		mov	r3, #255
1456:../uvc.c      **** 		 	 }
 10593              		.loc 1 1456 0
 10594 5b0c 2820C7E5 		strb	r2, [r7, #40]
 10595 5b10 DAFFFFEA 		b	.L943
 10596              	.LVL1265:
 10597              	.L682:
 10598              	.LBE355:
 10599              	.LBE377:
 10600              	.LBB378:
 10601              	.LBB343:
 10602 5b14 0D32DBE5 		ldrb	r3, [fp, #525]	@ zero_extendqisi2
1458:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10603              		.loc 1 1458 0
 10604 5b18 0100A0E3 		mov	r0, #1
 10605 5b1c 7C141FE5 		ldr	r1, .L987+72
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10606              		.loc 1 930 0
 10607 5b20 FF90A0E3 		mov	r9, #255
1456:../uvc.c      **** 		 	 }
 10608              		.loc 1 1456 0
 10609 5b24 2830C7E5 		strb	r3, [r7, #40]
1458:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10610              		.loc 1 1458 0
 10611 5b28 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10612              	.LVL1266:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10613              		.loc 1 930 0
 10614 5b2c 09C0A0E1 		mov	ip, r9
1459:../uvc.c      **** 			  Len = 1;
 10615              		.loc 1 1459 0
 10616 5b30 2830D7E5 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
 10617              	.LVL1267:
 10618 5b34 11FEFFEA 		b	.L684
 10619              	.LVL1268:
 10620              	.L696:
 10621              	.LBE343:
 10622              	.LBE378:
 10623              	.LBB379:
 10624              	.LBB366:
1411:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 10625              		.loc 1 1411 0
 10626 5b38 94E41FE5 		ldr	lr, .L987+76
 10627 5b3c 1FC2DEE5 		ldrb	ip, [lr, #543]	@ zero_extendqisi2
1412:../uvc.c      **** 			 }
 10628              		.loc 1 1412 0
 10629 5b40 2022DEE5 		ldrb	r2, [lr, #544]	@ zero_extendqisi2
 10630 5b44 5DFCFFEA 		b	.L942
 10631              	.LVL1269:
 10632              	.L750:
 10633              	.LBE366:
 10634              	.LBE379:
 10635              	.LBE402:
 10636              	.LBE422:
 10637              	.LBB423:
 10638              	.LBB333:
 10639              	.LBB280:
 10640              	.LBB203:
2060:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 10641              		.loc 1 2060 0
 10642 5b48 A4241FE5 		ldr	r2, .L987+76
 10643 5b4c 5B16D2E5 		ldrb	r1, [r2, #1627]	@ zero_extendqisi2
2061:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 10644              		.loc 1 2061 0
 10645 5b50 5C26D2E5 		ldrb	r2, [r2, #1628]	@ zero_extendqisi2
 10646 5b54 7CFDFFEA 		b	.L952
 10647              	.LVL1270:
 10648              	.L739:
 10649              	.LBE203:
 10650              	.LBE280:
 10651              	.LBB281:
 10652              	.LBB220:
2060:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 10653              		.loc 1 2060 0
 10654 5b58 B4241FE5 		ldr	r2, .L987+76
 10655 5b5c 2B16D2E5 		ldrb	r1, [r2, #1579]	@ zero_extendqisi2
2061:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 10656              		.loc 1 2061 0
 10657 5b60 2C26D2E5 		ldrb	r2, [r2, #1580]	@ zero_extendqisi2
 10658 5b64 78FDFFEA 		b	.L952
 10659              	.LVL1271:
 10660              	.L776:
 10661              	.LBE220:
 10662              	.LBE281:
 10663              	.LBB282:
 10664              	.LBB196:
2060:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 10665              		.loc 1 2060 0
 10666 5b68 8B16DBE5 		ldrb	r1, [fp, #1675]	@ zero_extendqisi2
2061:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 10667              		.loc 1 2061 0
 10668 5b6c 8C26DBE5 		ldrb	r2, [fp, #1676]	@ zero_extendqisi2
 10669 5b70 75FDFFEA 		b	.L952
 10670              	.L780:
2087:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 10671              		.loc 1 2087 0
 10672 5b74 9136DBE5 		ldrb	r3, [fp, #1681]	@ zero_extendqisi2
 10673              	.LVL1272:
 10674              	.L957:
 10675              	.LBE196:
 10676              	.LBE282:
 10677              	.LBB283:
 10678              	.LBB257:
2088:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10679              		.loc 1 2088 0
 10680 5b78 0100A0E3 		mov	r0, #1
 10681 5b7c DC141FE5 		ldr	r1, .L987+72
2087:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 10682              		.loc 1 2087 0
 10683 5b80 2830C7E5 		strb	r3, [r7, #40]
2090:../uvc.c      **** 			  break;
 10684              		.loc 1 2090 0
 10685 5b84 0190A0E3 		mov	r9, #1
2088:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10686              		.loc 1 2088 0
 10687 5b88 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10688              	.LVL1273:
2089:../uvc.c      **** 			  Len = 1;
 10689              		.loc 1 2089 0
 10690 5b8c 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 10691              	.LVL1274:
 10692 5b90 5CFFFFEA 		b	.L839
 10693              	.LVL1275:
 10694              	.L837:
2087:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 10695              		.loc 1 2087 0
 10696 5b94 0937DBE5 		ldrb	r3, [fp, #1801]	@ zero_extendqisi2
 10697 5b98 F6FFFFEA 		b	.L957
 10698              	.LVL1276:
 10699              	.L826:
 10700              	.LBE257:
 10701              	.LBE283:
 10702              	.LBB284:
 10703              	.LBB266:
 10704 5b9c F136DBE5 		ldrb	r3, [fp, #1777]	@ zero_extendqisi2
 10705 5ba0 F4FFFFEA 		b	.L957
 10706              	.L822:
2060:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 10707              		.loc 1 2060 0
 10708 5ba4 EB16DBE5 		ldrb	r1, [fp, #1771]	@ zero_extendqisi2
2061:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 10709              		.loc 1 2061 0
 10710 5ba8 EC26DBE5 		ldrb	r2, [fp, #1772]	@ zero_extendqisi2
 10711 5bac 66FDFFEA 		b	.L952
 10712              	.LVL1277:
 10713              	.L802:
 10714              	.LBE266:
 10715              	.LBE284:
 10716              	.LBB285:
 10717              	.LBB212:
2087:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 10718              		.loc 1 2087 0
 10719 5bb0 C136DBE5 		ldrb	r3, [fp, #1729]	@ zero_extendqisi2
 10720 5bb4 EFFFFFEA 		b	.L957
 10721              	.LVL1278:
 10722              	.L809:
 10723              	.LBE212:
 10724              	.LBE285:
 10725              	.LBB286:
 10726              	.LBB237:
2060:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 10727              		.loc 1 2060 0
 10728 5bb8 14251FE5 		ldr	r2, .L987+76
 10729 5bbc D316D2E5 		ldrb	r1, [r2, #1747]	@ zero_extendqisi2
2061:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 10730              		.loc 1 2061 0
 10731 5bc0 D426D2E5 		ldrb	r2, [r2, #1748]	@ zero_extendqisi2
 10732 5bc4 2EFDFFEA 		b	.L950
 10733              	.LVL1279:
 10734              	.L787:
 10735              	.LBE237:
 10736              	.LBE286:
 10737              	.LBB287:
 10738              	.LBB247:
2060:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 10739              		.loc 1 2060 0
 10740 5bc8 24C51FE5 		ldr	ip, .L987+76
 10741 5bcc A316DCE5 		ldrb	r1, [ip, #1699]	@ zero_extendqisi2
2061:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 10742              		.loc 1 2061 0
 10743 5bd0 A426DCE5 		ldrb	r2, [ip, #1700]	@ zero_extendqisi2
 10744 5bd4 5CFDFFEA 		b	.L952
 10745              	.LVL1280:
 10746              	.L833:
 10747              	.LBE247:
 10748              	.LBE287:
 10749              	.LBB288:
 10750              	.LBB258:
2060:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 10751              		.loc 1 2060 0
 10752 5bd8 34251FE5 		ldr	r2, .L987+76
 10753 5bdc 0317D2E5 		ldrb	r1, [r2, #1795]	@ zero_extendqisi2
2061:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 10754              		.loc 1 2061 0
 10755 5be0 0427D2E5 		ldrb	r2, [r2, #1796]	@ zero_extendqisi2
 10756 5be4 58FDFFEA 		b	.L952
 10757              	.LVL1281:
 10758              	.L743:
 10759              	.LBE258:
 10760              	.LBE288:
 10761              	.LBB289:
 10762              	.LBB221:
2087:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 10763              		.loc 1 2087 0
 10764 5be8 3136DBE5 		ldrb	r3, [fp, #1585]	@ zero_extendqisi2
 10765 5bec E1FFFFEA 		b	.L957
 10766              	.LVL1282:
 10767              	.L754:
 10768              	.LBE221:
 10769              	.LBE289:
 10770              	.LBB290:
 10771              	.LBB204:
 10772 5bf0 4CE51FE5 		ldr	lr, .L987+76
 10773 5bf4 6136DEE5 		ldrb	r3, [lr, #1633]	@ zero_extendqisi2
 10774 5bf8 DEFFFFEA 		b	.L957
 10775              	.LVL1283:
 10776              	.L761:
 10777              	.LBE204:
 10778              	.LBE290:
 10779              	.LBB291:
 10780              	.LBB228:
2060:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 10781              		.loc 1 2060 0
 10782 5bfc 58251FE5 		ldr	r2, .L987+76
 10783 5c00 7316D2E5 		ldrb	r1, [r2, #1651]	@ zero_extendqisi2
2061:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 10784              		.loc 1 2061 0
 10785 5c04 7426D2E5 		ldrb	r2, [r2, #1652]	@ zero_extendqisi2
 10786 5c08 F1FCFFEA 		b	.L946
 10787              	.LVL1284:
 10788              	.L798:
 10789              	.LBE228:
 10790              	.LBE291:
 10791              	.LBB292:
 10792              	.LBB213:
2060:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 10793              		.loc 1 2060 0
 10794 5c0c 68251FE5 		ldr	r2, .L987+76
 10795 5c10 BB16D2E5 		ldrb	r1, [r2, #1723]	@ zero_extendqisi2
2061:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 10796              		.loc 1 2061 0
 10797 5c14 BC26D2E5 		ldrb	r2, [r2, #1724]	@ zero_extendqisi2
 10798 5c18 4BFDFFEA 		b	.L952
 10799              	.LVL1285:
 10800              	.L765:
 10801              	.LBE213:
 10802              	.LBE292:
 10803              	.LBB293:
 10804              	.LBB229:
2087:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 10805              		.loc 1 2087 0
 10806 5c1c 7936DBE5 		ldrb	r3, [fp, #1657]	@ zero_extendqisi2
2088:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10807              		.loc 1 2088 0
 10808 5c20 0100A0E3 		mov	r0, #1
 10809 5c24 84151FE5 		ldr	r1, .L987+72
2087:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 10810              		.loc 1 2087 0
 10811 5c28 2830C7E5 		strb	r3, [r7, #40]
2088:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10812              		.loc 1 2088 0
 10813 5c2c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10814              	.LVL1286:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10815              		.loc 1 2025 0
 10816 5c30 FF20A0E3 		mov	r2, #255
 10817 5c34 0230A0E1 		mov	r3, r2
2089:../uvc.c      **** 			  Len = 1;
 10818              		.loc 1 2089 0
 10819 5c38 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 10820              	.LVL1287:
2090:../uvc.c      **** 			  break;
 10821              		.loc 1 2090 0
 10822 5c3c 0180A0E3 		mov	r8, #1
 10823 5c40 EEFCFFEA 		b	.L767
 10824              	.LVL1288:
 10825              	.L813:
 10826              	.LBE229:
 10827              	.LBE293:
 10828              	.LBB294:
 10829              	.LBB238:
2087:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 10830              		.loc 1 2087 0
 10831 5c44 A0E51FE5 		ldr	lr, .L987+76
2088:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10832              		.loc 1 2088 0
 10833 5c48 0100A0E3 		mov	r0, #1
2087:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 10834              		.loc 1 2087 0
 10835 5c4c D936DEE5 		ldrb	r3, [lr, #1753]	@ zero_extendqisi2
2088:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10836              		.loc 1 2088 0
 10837 5c50 B0151FE5 		ldr	r1, .L987+72
2087:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 10838              		.loc 1 2087 0
 10839 5c54 2830C7E5 		strb	r3, [r7, #40]
2088:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10840              		.loc 1 2088 0
 10841 5c58 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10842              	.LVL1289:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10843              		.loc 1 2025 0
 10844 5c5c FF20A0E3 		mov	r2, #255
 10845 5c60 0230A0E1 		mov	r3, r2
2089:../uvc.c      **** 			  Len = 1;
 10846              		.loc 1 2089 0
 10847 5c64 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 10848              	.LVL1290:
2090:../uvc.c      **** 			  break;
 10849              		.loc 1 2090 0
 10850 5c68 0190A0E3 		mov	r9, #1
 10851 5c6c 0FFDFFEA 		b	.L815
 10852              	.LVL1291:
 10853              	.L791:
 10854              	.LBE238:
 10855              	.LBE294:
 10856              	.LBB295:
 10857              	.LBB248:
2087:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 10858              		.loc 1 2087 0
 10859 5c70 CCC51FE5 		ldr	ip, .L987+76
 10860 5c74 A936DCE5 		ldrb	r3, [ip, #1705]	@ zero_extendqisi2
 10861 5c78 BEFFFFEA 		b	.L957
 10862              	.LVL1292:
 10863              	.L882:
 10864              	.LBE248:
 10865              	.LBE295:
 10866              	.LBE333:
 10867              	.LBE423:
 10868              	.LBB424:
 10869              	.LBB186:
 10870              	.LBB175:
 10871              	.LBB170:
 947:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10872              		.loc 1 947 0
 10873 5c7c 0020A0E3 		mov	r2, #0
 948:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10874              		.loc 1 948 0
 10875 5c80 0200A0E3 		mov	r0, #2
 10876 5c84 E4151FE5 		ldr	r1, .L987+72
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10877              		.loc 1 930 0
 10878 5c88 FF90A0E3 		mov	r9, #255
 946:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10879              		.loc 1 946 0
 10880 5c8c 2880C7E5 		strb	r8, [r7, #40]
 10881 5c90 56FCFFEA 		b	.L953
 10882              	.LVL1293:
 10883              	.L768:
 10884              	.LBE170:
 10885              	.LBE175:
 10886              	.LBE186:
 10887              	.LBE424:
 10888              	.LBB425:
 10889              	.LBB334:
 10890              	.LBB296:
 10891              	.LBB230:
2188:../uvc.c      **** 					  }
 10892              		.loc 1 2188 0
 10893 5c94 0000A0E3 		mov	r0, #0
 10894 5c98 0020A0E1 		mov	r2, r0
 10895 5c9c 0110A0E3 		mov	r1, #1
 10896 5ca0 FEFFFFEB 		bl	CyU3PUsbStall
 10897              	.LVL1294:
 10898              	.L771:
2190:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
 10899              		.loc 1 2190 0
 10900 5ca4 2830D7E5 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
 10901              	.LVL1295:
2191:../uvc.c      **** 					  break;
 10902              		.loc 1 2191 0
 10903 5ca8 2920D7E5 		ldrb	r2, [r7, #41]	@ zero_extendqisi2
 10904              	.LVL1296:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10905              		.loc 1 2025 0
 10906 5cac FFC0A0E3 		mov	ip, #255
 10907 5cb0 D2FCFFEA 		b	.L767
 10908              	.LVL1297:
 10909              	.L706:
 10910              	.LBE230:
 10911              	.LBE296:
 10912              	.LBE334:
 10913              	.LBE425:
 10914              	.LBB426:
 10915              	.LBB403:
 10916              	.LBB380:
 10917              	.LBB356:
2002:../uvc.c      **** 			  break;
 10918              		.loc 1 2002 0
 10919 5cb4 0000A0E3 		mov	r0, #0
 10920 5cb8 0020A0E1 		mov	r2, r0
 10921 5cbc 0110A0E3 		mov	r1, #1
 10922 5cc0 FEFFFFEB 		bl	CyU3PUsbStall
 10923              	.LVL1298:
 10924              	.L941:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10925              		.loc 1 930 0
 10926 5cc4 FF30A0E3 		mov	r3, #255
 10927 5cc8 0320A0E1 		mov	r2, r3
 10928 5ccc 30308DE5 		str	r3, [sp, #48]
 10929 5cd0 0390A0E1 		mov	r9, r3
 10930 5cd4 03C0A0E1 		mov	ip, r3
 10931 5cd8 6FFFFFEA 		b	.L716
 10932              	.LVL1299:
 10933              	.L977:
 10934              	.LBE356:
 10935              	.LBE380:
 10936              	.LBE403:
 10937              	.LBE426:
 10938              	.LBB427:
 10939              	.LBB187:
 10940              	.LBB176:
 10941              	.LBB171:
 942:../uvc.c      **** 		 {
 10942              		.loc 1 942 0
 10943 5cdc 81005CE3 		cmp	ip, #129
 10944 5ce0 9301000A 		beq	.L879
 10945 5ce4 8F01008A 		bhi	.L880
 10946 5ce8 01005CE3 		cmp	ip, #1
 10947 5cec 8401001A 		bne	.L876
1480:../uvc.c      **** 				  glEp0Buffer, &readCount);
 10948              		.loc 1 1480 0
 10949 5cf0 4A208DE2 		add	r2, sp, #74
 10950 5cf4 2000A0E3 		mov	r0, #32
 10951 5cf8 58161FE5 		ldr	r1, .L987+72
 10952 5cfc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10953              	.LVL1300:
1482:../uvc.c      **** 			   {
 10954              		.loc 1 1482 0
 10955 5d00 002050E2 		subs	r2, r0, #0
 10956 5d04 CA01001A 		bne	.L889
1621:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 10957              		.loc 1 1621 0
 10958 5d08 7025DBE5 		ldrb	r2, [fp, #1392]	@ zero_extendqisi2
1625:../uvc.c      **** 							 if(0&&pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
 10959              		.loc 1 1625 0
 10960 5d0c 64861FE5 		ldr	r8, .L987+80
 10961              	.LVL1301:
1622:../uvc.c      **** 						     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 10962              		.loc 1 1622 0
 10963 5d10 7135DBE5 		ldrb	r3, [fp, #1393]	@ zero_extendqisi2
1484:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 10964              		.loc 1 1484 0
 10965 5d14 28C0D4E5 		ldrb	ip, [r4, #40]	@ zero_extendqisi2
 10966              	.LVL1302:
1623:../uvc.c      **** 						     dataIdx = 0;
 10967              		.loc 1 1623 0
 10968 5d18 7F35DBE5 		ldrb	r3, [fp, #1407]	@ zero_extendqisi2
1625:../uvc.c      **** 							 if(0&&pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
 10969              		.loc 1 1625 0
 10970 5d1c 1C0098E5 		ldr	r0, [r8, #28]
 10971              	.LVL1303:
1621:../uvc.c      **** 						     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 10972              		.loc 1 1621 0
 10973 5d20 FF2002E2 		and	r2, r2, #255
1625:../uvc.c      **** 							 if(0&&pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
 10974              		.loc 1 1625 0
 10975 5d24 0010E0E3 		mvn	r1, #0
 10976 5d28 34808DE5 		str	r8, [sp, #52]
1623:../uvc.c      **** 						     dataIdx = 0;
 10977              		.loc 1 1623 0
 10978 5d2c FF9003E2 		and	r9, r3, #255
 10979              	.LVL1304:
1487:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10980              		.loc 1 1487 0
 10981 5d30 2A80D4E5 		ldrb	r8, [r4, #42]	@ zero_extendqisi2
 10982              	.LVL1305:
1625:../uvc.c      **** 							 if(0&&pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != getData)
 10983              		.loc 1 1625 0
 10984 5d34 2C208DE5 		str	r2, [sp, #44]
 10985 5d38 24C08DE5 		str	ip, [sp, #36]
 10986 5d3c FEFFFFEB 		bl	_txe_mutex_get
 10987              	.LVL1306:
1633:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 10988              		.loc 1 1633 0
 10989 5d40 7D15DBE5 		ldrb	r1, [fp, #1405]	@ zero_extendqisi2
 10990 5d44 24C09DE5 		ldr	ip, [sp, #36]
 10991 5d48 2C209DE5 		ldr	r2, [sp, #44]
 10992 5d4c 01005CE1 		cmp	ip, r1
 10993 5d50 0700000A 		beq	.L891
1634:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 10994              		.loc 1 1634 0
 10995 5d54 B0E61FE5 		ldr	lr, .L987+76
 10996 5d58 7DC5CEE5 		strb	ip, [lr, #1405]
1635:../uvc.c      **** 									 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 10997              		.loc 1 1635 0
 10998 5d5c F515DEE5 		ldrb	r1, [lr, #1525]	@ zero_extendqisi2
 10999 5d60 010051E3 		cmp	r1, #1
 11000 5d64 DD01000A 		beq	.L892
 11001 5d68 F515DEE5 		ldrb	r1, [lr, #1525]	@ zero_extendqisi2
 11002 5d6c 030051E3 		cmp	r1, #3
 11003 5d70 DA01000A 		beq	.L892
 11004              	.L891:
1642:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 11005              		.loc 1 1642 0
 11006 5d74 34109DE5 		ldr	r1, [sp, #52]
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11007              		.loc 1 930 0
 11008 5d78 FF90A0E3 		mov	r9, #255
 11009              	.LVL1307:
1642:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 11010              		.loc 1 1642 0
 11011 5d7c 1C0091E5 		ldr	r0, [r1, #28]
 11012 5d80 24C08DE5 		str	ip, [sp, #36]
 11013 5d84 FEFFFFEB 		bl	_txe_mutex_put
 11014              	.LVL1308:
1644:../uvc.c      **** 							 break;
 11015              		.loc 1 1644 0
 11016 5d88 F525DBE5 		ldrb	r2, [fp, #1525]	@ zero_extendqisi2
1643:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 11017              		.loc 1 1643 0
 11018 5d8c 24C09DE5 		ldr	ip, [sp, #36]
1644:../uvc.c      **** 							 break;
 11019              		.loc 1 1644 0
 11020 5d90 F635DBE5 		ldrb	r3, [fp, #1526]	@ zero_extendqisi2
 11021 5d94 4115DBE5 		ldrb	r1, [fp, #1345]	@ zero_extendqisi2
1643:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 11022              		.loc 1 1643 0
 11023 5d98 0400A0E3 		mov	r0, #4
 11024 5d9c 04C08DE5 		str	ip, [sp, #4]
 11025 5da0 00108DE5 		str	r1, [sp]
 11026 5da4 08808DE5 		str	r8, [sp, #8]
 11027 5da8 10171FE5 		ldr	r1, .L987+64
 11028 5dac FEFFFFEB 		bl	CyU3PDebugPrint
 11029              	.LVL1309:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11030              		.loc 1 930 0
 11031 5db0 0920A0E1 		mov	r2, r9
 11032 5db4 24C09DE5 		ldr	ip, [sp, #36]
 11033 5db8 11FCFFEA 		b	.L886
 11034              	.LVL1310:
 11035              	.L674:
 11036              	.LBE171:
 11037              	.LBE176:
 11038              	.LBE187:
 11039              	.LBE427:
 11040              	.LBB428:
 11041              	.LBB404:
 11042              	.LBB381:
 11043              	.LBB344:
2002:../uvc.c      **** 			  break;
 11044              		.loc 1 2002 0
 11045 5dbc 0000A0E3 		mov	r0, #0
 11046 5dc0 0020A0E1 		mov	r2, r0
 11047 5dc4 0110A0E3 		mov	r1, #1
 11048 5dc8 FEFFFFEB 		bl	CyU3PUsbStall
 11049              	.LVL1311:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11050              		.loc 1 930 0
 11051 5dcc FF30A0E3 		mov	r3, #255
 11052 5dd0 0390A0E1 		mov	r9, r3
 11053              	.LVL1312:
 11054 5dd4 03C0A0E1 		mov	ip, r3
 11055 5dd8 68FDFFEA 		b	.L684
 11056              	.LVL1313:
 11057              	.L707:
 11058              	.LBE344:
 11059              	.LBE381:
 11060              	.LBB382:
 11061              	.LBB357:
1429:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 11062              		.loc 1 1429 0
 11063 5ddc 38171FE5 		ldr	r1, .L987+76
 11064 5de0 C9C2D1E5 		ldrb	ip, [r1, #713]	@ zero_extendqisi2
1430:../uvc.c      **** 			 }
 11065              		.loc 1 1430 0
 11066 5de4 CA22D1E5 		ldrb	r2, [r1, #714]	@ zero_extendqisi2
 11067 5de8 B4FBFFEA 		b	.L942
 11068              	.LVL1314:
 11069              	.L675:
 11070              	.LBE357:
 11071              	.LBE382:
 11072              	.LBB383:
 11073              	.LBB345:
1429:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 11074              		.loc 1 1429 0
 11075 5dec 48E71FE5 		ldr	lr, .L987+76
 11076 5df0 0922DEE5 		ldrb	r2, [lr, #521]	@ zero_extendqisi2
1430:../uvc.c      **** 			 }
 11077              		.loc 1 1430 0
 11078 5df4 0A32DEE5 		ldrb	r3, [lr, #522]	@ zero_extendqisi2
 11079 5df8 AEFAFFEA 		b	.L935
 11080              	.LVL1315:
 11081              	.L709:
 11082              	.LBE345:
 11083              	.LBE383:
 11084              	.LBB384:
 11085              	.LBB358:
1334:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 11086              		.loc 1 1334 0
 11087 5dfc A920D7E5 		ldrb	r2, [r7, #169]	@ zero_extendqisi2
 11088 5e00 000052E3 		cmp	r2, #0
 11089 5e04 A801000A 		beq	.L717
1336:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 11090              		.loc 1 1336 0
 11091 5e08 64E71FE5 		ldr	lr, .L987+76
 11092 5e0c D122DEE5 		ldrb	r2, [lr, #721]	@ zero_extendqisi2
1337:../uvc.c      **** 		 	 		 }else{
 11093              		.loc 1 1337 0
 11094 5e10 D232DEE5 		ldrb	r3, [lr, #722]	@ zero_extendqisi2
1336:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 11095              		.loc 1 1336 0
 11096 5e14 032002E2 		and	r2, r2, #3
 11097 5e18 2820C4E5 		strb	r2, [r4, #40]
1337:../uvc.c      **** 		 	 		 }else{
 11098              		.loc 1 1337 0
 11099 5e1c 2930C4E5 		strb	r3, [r4, #41]
 11100              	.LVL1316:
 11101              	.L718:
1346:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
 11102              		.loc 1 1346 0
 11103 5e20 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 11104              	.LVL1317:
1347:../uvc.c      **** 					 break;
 11105              		.loc 1 1347 0
 11106 5e24 2930D7E5 		ldrb	r3, [r7, #41]	@ zero_extendqisi2
 11107              	.LVL1318:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11108              		.loc 1 930 0
 11109 5e28 FFC0A0E3 		mov	ip, #255
1392:../uvc.c      **** 
 11110              		.loc 1 1392 0
 11111 5e2c 0900A0E1 		mov	r0, r9
 11112 5e30 90171FE5 		ldr	r1, .L987+72
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11113              		.loc 1 930 0
 11114 5e34 30C08DE5 		str	ip, [sp, #48]
1392:../uvc.c      **** 
 11115              		.loc 1 1392 0
 11116 5e38 2C208DE5 		str	r2, [sp, #44]
 11117 5e3c 28308DE5 		str	r3, [sp, #40]
 11118 5e40 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11119              	.LVL1319:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11120              		.loc 1 930 0
 11121 5e44 30909DE5 		ldr	r9, [sp, #48]
 11122 5e48 2C209DE5 		ldr	r2, [sp, #44]
 11123 5e4c 28309DE5 		ldr	r3, [sp, #40]
 11124 5e50 09C0A0E1 		mov	ip, r9
 11125 5e54 10FFFFEA 		b	.L716
 11126              	.LVL1320:
 11127              	.L681:
 11128              	.LBE358:
 11129              	.LBE384:
 11130              	.LBB385:
 11131              	.LBB346:
1443:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 11132              		.loc 1 1443 0
 11133 5e58 0B12DBE5 		ldrb	r1, [fp, #523]	@ zero_extendqisi2
1444:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 11134              		.loc 1 1444 0
 11135 5e5c 0C22DBE5 		ldrb	r2, [fp, #524]	@ zero_extendqisi2
1445:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 11136              		.loc 1 1445 0
 11137 5e60 0030A0E3 		mov	r3, #0
1448:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11138              		.loc 1 1448 0
 11139 5e64 0900A0E1 		mov	r0, r9
1443:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 11140              		.loc 1 1443 0
 11141 5e68 2810C7E5 		strb	r1, [r7, #40]
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11142              		.loc 1 930 0
 11143 5e6c FF90A0E3 		mov	r9, #255
1448:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11144              		.loc 1 1448 0
 11145 5e70 D0171FE5 		ldr	r1, .L987+72
1445:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 11146              		.loc 1 1445 0
 11147 5e74 2A30C7E5 		strb	r3, [r7, #42]
1446:../uvc.c      **** 		 	 }
 11148              		.loc 1 1446 0
 11149 5e78 2B30C7E5 		strb	r3, [r7, #43]
1444:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 11150              		.loc 1 1444 0
 11151 5e7c 2920C7E5 		strb	r2, [r7, #41]
1448:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11152              		.loc 1 1448 0
 11153 5e80 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11154              	.LVL1321:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11155              		.loc 1 930 0
 11156 5e84 09C0A0E1 		mov	ip, r9
1449:../uvc.c      **** 			  break;
 11157              		.loc 1 1449 0
 11158 5e88 2830D7E5 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
 11159              	.LVL1322:
 11160 5e8c 3BFDFFEA 		b	.L684
 11161              	.LVL1323:
 11162              	.L695:
 11163              	.LBE346:
 11164              	.LBE385:
 11165              	.LBB386:
 11166              	.LBB367:
1321:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
 11167              		.loc 1 1321 0
 11168 5e90 A220D7E5 		ldrb	r2, [r7, #162]	@ zero_extendqisi2
 11169 5e94 000052E3 		cmp	r2, #0
 11170 5e98 7701000A 		beq	.L703
1322:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 11171              		.loc 1 1322 0
 11172 5e9c F8171FE5 		ldr	r1, .L987+76
 11173 5ea0 2922D1E5 		ldrb	r2, [r1, #553]	@ zero_extendqisi2
1323:../uvc.c      **** 		 	 		 }else{
 11174              		.loc 1 1323 0
 11175 5ea4 2A32D1E5 		ldrb	r3, [r1, #554]	@ zero_extendqisi2
1322:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 11176              		.loc 1 1322 0
 11177 5ea8 2820C4E5 		strb	r2, [r4, #40]
1323:../uvc.c      **** 		 	 		 }else{
 11178              		.loc 1 1323 0
 11179 5eac 2930C4E5 		strb	r3, [r4, #41]
 11180 5eb0 DAFFFFEA 		b	.L718
 11181              	.LVL1324:
 11182              	.L677:
 11183              	.LBE367:
 11184              	.LBE386:
 11185              	.LBB387:
 11186              	.LBB347:
1234:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 11187              		.loc 1 1234 0
 11188 5eb4 A130D7E5 		ldrb	r3, [r7, #161]	@ zero_extendqisi2
 11189 5eb8 000053E3 		cmp	r3, #0
1235:../uvc.c      **** 		 	 		 }else{
 11190              		.loc 1 1235 0
 11191 5ebc 1102DB15 		ldrneb	r0, [fp, #529]	@ zero_extendqisi2
1234:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 11192              		.loc 1 1234 0
 11193 5ec0 6701000A 		beq	.L986
 11194              	.LVL1325:
 11195              	.L686:
1242:../uvc.c      **** 						  Data0 = ~Data0;
 11196              		.loc 1 1242 0
 11197 5ec4 800010E3 		tst	r0, #128
1243:../uvc.c      **** 					  }else{
 11198              		.loc 1 1243 0
 11199 5ec8 0030E011 		mvnne	r3, r0
1245:../uvc.c      **** 					  }
 11200              		.loc 1 1245 0
 11201 5ecc 80304002 		subeq	r3, r0, #128
 11202 5ed0 FF3003E2 		and	r3, r3, #255
 11203              	.LVL1326:
1392:../uvc.c      **** 
 11204              		.loc 1 1392 0
 11205 5ed4 0900A0E1 		mov	r0, r9
1248:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 11206              		.loc 1 1248 0
 11207 5ed8 0020A0E3 		mov	r2, #0
1392:../uvc.c      **** 
 11208              		.loc 1 1392 0
 11209 5edc 3C181FE5 		ldr	r1, .L987+72
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11210              		.loc 1 930 0
 11211 5ee0 FF90A0E3 		mov	r9, #255
 11212              	.LVL1327:
1247:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 11213              		.loc 1 1247 0
 11214 5ee4 2830C7E5 		strb	r3, [r7, #40]
1392:../uvc.c      **** 
 11215              		.loc 1 1392 0
 11216 5ee8 28308DE5 		str	r3, [sp, #40]
1248:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 11217              		.loc 1 1248 0
 11218 5eec 2920C7E5 		strb	r2, [r7, #41]
 11219              	.LVL1328:
1392:../uvc.c      **** 
 11220              		.loc 1 1392 0
 11221 5ef0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11222              	.LVL1329:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11223              		.loc 1 930 0
 11224 5ef4 09C0A0E1 		mov	ip, r9
 11225 5ef8 28309DE5 		ldr	r3, [sp, #40]
 11226 5efc 1FFDFFEA 		b	.L684
 11227              	.LVL1330:
 11228              	.L693:
 11229              	.LBE347:
 11230              	.LBE387:
 11231              	.LBB388:
 11232              	.LBB368:
1429:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 11233              		.loc 1 1429 0
 11234 5f00 5C181FE5 		ldr	r1, .L987+76
 11235 5f04 21C2D1E5 		ldrb	ip, [r1, #545]	@ zero_extendqisi2
1430:../uvc.c      **** 			 }
 11236              		.loc 1 1430 0
 11237 5f08 2222D1E5 		ldrb	r2, [r1, #546]	@ zero_extendqisi2
 11238 5f0c 6BFBFFEA 		b	.L942
 11239              	.LVL1331:
 11240              	.L713:
 11241              	.LBE368:
 11242              	.LBE388:
 11243              	.LBB389:
 11244              	.LBB359:
1443:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 11245              		.loc 1 1443 0
 11246 5f10 6C281FE5 		ldr	r2, .L987+76
 11247 5f14 CB32D2E5 		ldrb	r3, [r2, #715]	@ zero_extendqisi2
1444:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 11248              		.loc 1 1444 0
 11249 5f18 CCC2D2E5 		ldrb	ip, [r2, #716]	@ zero_extendqisi2
 11250              	.LVL1332:
 11251              	.L958:
1445:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 11252              		.loc 1 1445 0
 11253 5f1c 0020A0E3 		mov	r2, #0
1443:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 11254              		.loc 1 1443 0
 11255 5f20 2830C7E5 		strb	r3, [r7, #40]
1448:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11256              		.loc 1 1448 0
 11257 5f24 0900A0E1 		mov	r0, r9
 11258 5f28 88181FE5 		ldr	r1, .L987+72
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11259              		.loc 1 930 0
 11260 5f2c FF30A0E3 		mov	r3, #255
1444:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 11261              		.loc 1 1444 0
 11262 5f30 29C0C7E5 		strb	ip, [r7, #41]
1445:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 11263              		.loc 1 1445 0
 11264 5f34 2A20C7E5 		strb	r2, [r7, #42]
1446:../uvc.c      **** 		 	 }
 11265              		.loc 1 1446 0
 11266 5f38 2B20C7E5 		strb	r2, [r7, #43]
 11267 5f3c CFFEFFEA 		b	.L943
 11268              	.LVL1333:
 11269              	.L680:
 11270              	.LBE359:
 11271              	.LBE389:
 11272              	.LBB390:
 11273              	.LBB348:
 947:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 11274              		.loc 1 947 0
 11275 5f40 0030A0E3 		mov	r3, #0
 948:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11276              		.loc 1 948 0
 11277 5f44 0200A0E3 		mov	r0, #2
 11278 5f48 A8181FE5 		ldr	r1, .L987+72
 946:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 11279              		.loc 1 946 0
 11280 5f4c 2890C7E5 		strb	r9, [r7, #40]
 11281 5f50 5BFAFFEA 		b	.L934
 11282              	.LVL1334:
 11283              	.L699:
 11284              	.LBE348:
 11285              	.LBE390:
 11286              	.LBB391:
 11287              	.LBB369:
1443:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 11288              		.loc 1 1443 0
 11289 5f54 B0281FE5 		ldr	r2, .L987+76
 11290 5f58 2332D2E5 		ldrb	r3, [r2, #547]	@ zero_extendqisi2
1444:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 11291              		.loc 1 1444 0
 11292 5f5c 24C2D2E5 		ldrb	ip, [r2, #548]	@ zero_extendqisi2
 11293 5f60 EDFFFFEA 		b	.L958
 11294              	.LVL1335:
 11295              	.L758:
 11296              	.LBE369:
 11297              	.LBE391:
 11298              	.LBE404:
 11299              	.LBE428:
 11300              	.LBB429:
 11301              	.LBB335:
 11302              	.LBB297:
 11303              	.LBB231:
2069:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11304              		.loc 1 2069 0
 11305 5f64 C0381FE5 		ldr	r3, .L987+76
 11306 5f68 7516D3E5 		ldrb	r1, [r3, #1653]	@ zero_extendqisi2
2070:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11307              		.loc 1 2070 0
 11308 5f6c 7626D3E5 		ldrb	r2, [r3, #1654]	@ zero_extendqisi2
 11309 5f70 17FCFFEA 		b	.L946
 11310              	.L760:
2045:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11311              		.loc 1 2045 0
 11312 5f74 D0E81FE5 		ldr	lr, .L987+76
2047:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11313              		.loc 1 2047 0
 11314 5f78 0030A0E3 		mov	r3, #0
2045:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11315              		.loc 1 2045 0
 11316 5f7c 7DC6DEE5 		ldrb	ip, [lr, #1661]	@ zero_extendqisi2
2046:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11317              		.loc 1 2046 0
 11318 5f80 7E26DEE5 		ldrb	r2, [lr, #1662]	@ zero_extendqisi2
2053:../uvc.c      **** 
 11319              		.loc 1 2053 0
 11320 5f84 0800A0E1 		mov	r0, r8
 11321 5f88 E8181FE5 		ldr	r1, .L987+72
2045:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11322              		.loc 1 2045 0
 11323 5f8c 28C0C7E5 		strb	ip, [r7, #40]
2046:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11324              		.loc 1 2046 0
 11325 5f90 2920C7E5 		strb	r2, [r7, #41]
2047:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11326              		.loc 1 2047 0
 11327 5f94 2A30C7E5 		strb	r3, [r7, #42]
2048:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 11328              		.loc 1 2048 0
 11329 5f98 2B30C7E5 		strb	r3, [r7, #43]
 11330              	.LVL1336:
2053:../uvc.c      **** 
 11331              		.loc 1 2053 0
 11332 5f9c 24C08DE5 		str	ip, [sp, #36]
 11333 5fa0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11334              	.LVL1337:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11335              		.loc 1 2025 0
 11336 5fa4 FF20A0E3 		mov	r2, #255
 11337 5fa8 0230A0E1 		mov	r3, r2
 11338 5fac 24C09DE5 		ldr	ip, [sp, #36]
 11339 5fb0 12FCFFEA 		b	.L767
 11340              	.LVL1338:
 11341              	.L779:
 11342              	.LBE231:
 11343              	.LBE297:
 11344              	.LBB298:
 11345              	.LBB197:
2078:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11346              		.loc 1 2078 0
 11347 5fb4 8F16DBE5 		ldrb	r1, [fp, #1679]	@ zero_extendqisi2
2079:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11348              		.loc 1 2079 0
 11349 5fb8 9026DBE5 		ldrb	r2, [fp, #1680]	@ zero_extendqisi2
 11350 5fbc 62FCFFEA 		b	.L952
 11351              	.LVL1339:
 11352              	.L797:
 11353              	.LBE197:
 11354              	.LBE298:
 11355              	.LBB299:
 11356              	.LBB214:
2045:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11357              		.loc 1 2045 0
 11358 5fc0 1CE91FE5 		ldr	lr, .L987+76
 11359 5fc4 C526DEE5 		ldrb	r2, [lr, #1733]	@ zero_extendqisi2
2046:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11360              		.loc 1 2046 0
 11361 5fc8 C616DEE5 		ldrb	r1, [lr, #1734]	@ zero_extendqisi2
 11362              	.LVL1340:
 11363              	.L956:
 11364              	.LBE214:
 11365              	.LBE299:
 11366              	.LBB300:
 11367              	.LBB259:
2047:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11368              		.loc 1 2047 0
 11369 5fcc 0030A0E3 		mov	r3, #0
2046:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11370              		.loc 1 2046 0
 11371 5fd0 2910C7E5 		strb	r1, [r7, #41]
2053:../uvc.c      **** 
 11372              		.loc 1 2053 0
 11373 5fd4 0900A0E1 		mov	r0, r9
 11374 5fd8 38191FE5 		ldr	r1, .L987+72
2045:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11375              		.loc 1 2045 0
 11376 5fdc 2820C7E5 		strb	r2, [r7, #40]
2053:../uvc.c      **** 
 11377              		.loc 1 2053 0
 11378 5fe0 2C208DE5 		str	r2, [sp, #44]
2047:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11379              		.loc 1 2047 0
 11380 5fe4 2A30C7E5 		strb	r3, [r7, #42]
2048:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 11381              		.loc 1 2048 0
 11382 5fe8 2B30C7E5 		strb	r3, [r7, #43]
 11383              	.LVL1341:
2053:../uvc.c      **** 
 11384              		.loc 1 2053 0
 11385 5fec FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11386              	.LVL1342:
 11387 5ff0 2C209DE5 		ldr	r2, [sp, #44]
 11388 5ff4 43FEFFEA 		b	.L839
 11389              	.LVL1343:
 11390              	.L775:
 11391              	.LBE259:
 11392              	.LBE300:
 11393              	.LBB301:
 11394              	.LBB198:
2045:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11395              		.loc 1 2045 0
 11396 5ff8 54E91FE5 		ldr	lr, .L987+76
 11397 5ffc 9526DEE5 		ldrb	r2, [lr, #1685]	@ zero_extendqisi2
2046:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11398              		.loc 1 2046 0
 11399 6000 9616DEE5 		ldrb	r1, [lr, #1686]	@ zero_extendqisi2
 11400 6004 F0FFFFEA 		b	.L956
 11401              	.LVL1344:
 11402              	.L749:
 11403              	.LBE198:
 11404              	.LBE301:
 11405              	.LBB302:
 11406              	.LBB205:
2045:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11407              		.loc 1 2045 0
 11408 6008 64E91FE5 		ldr	lr, .L987+76
 11409 600c 6526DEE5 		ldrb	r2, [lr, #1637]	@ zero_extendqisi2
2046:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11410              		.loc 1 2046 0
 11411 6010 6616DEE5 		ldrb	r1, [lr, #1638]	@ zero_extendqisi2
 11412 6014 ECFFFFEA 		b	.L956
 11413              	.LVL1345:
 11414              	.L738:
 11415              	.LBE205:
 11416              	.LBE302:
 11417              	.LBB303:
 11418              	.LBB222:
2045:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11419              		.loc 1 2045 0
 11420 6018 74E91FE5 		ldr	lr, .L987+76
 11421 601c 3526DEE5 		ldrb	r2, [lr, #1589]	@ zero_extendqisi2
2046:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11422              		.loc 1 2046 0
 11423 6020 3616DEE5 		ldrb	r1, [lr, #1590]	@ zero_extendqisi2
 11424 6024 E8FFFFEA 		b	.L956
 11425              	.LVL1346:
 11426              	.L821:
 11427              	.LBE222:
 11428              	.LBE303:
 11429              	.LBB304:
 11430              	.LBB267:
2045:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11431              		.loc 1 2045 0
 11432 6028 F526DBE5 		ldrb	r2, [fp, #1781]	@ zero_extendqisi2
2046:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11433              		.loc 1 2046 0
 11434 602c F616DBE5 		ldrb	r1, [fp, #1782]	@ zero_extendqisi2
 11435 6030 E5FFFFEA 		b	.L956
 11436              	.LVL1347:
 11437              	.L801:
 11438              	.LBE267:
 11439              	.LBE304:
 11440              	.LBB305:
 11441              	.LBB215:
2078:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11442              		.loc 1 2078 0
 11443 6034 90C91FE5 		ldr	ip, .L987+76
 11444 6038 BF16DCE5 		ldrb	r1, [ip, #1727]	@ zero_extendqisi2
2079:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11445              		.loc 1 2079 0
 11446 603c C026DCE5 		ldrb	r2, [ip, #1728]	@ zero_extendqisi2
 11447 6040 41FCFFEA 		b	.L952
 11448              	.LVL1348:
 11449              	.L806:
 11450              	.LBE215:
 11451              	.LBE305:
 11452              	.LBB306:
 11453              	.LBB239:
2069:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11454              		.loc 1 2069 0
 11455 6044 A0391FE5 		ldr	r3, .L987+76
 11456 6048 D516D3E5 		ldrb	r1, [r3, #1749]	@ zero_extendqisi2
2070:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11457              		.loc 1 2070 0
 11458 604c D626D3E5 		ldrb	r2, [r3, #1750]	@ zero_extendqisi2
 11459 6050 0BFCFFEA 		b	.L950
 11460              	.LVL1349:
 11461              	.L747:
 11462              	.LBE239:
 11463              	.LBE306:
 11464              	.LBB307:
 11465              	.LBB206:
2069:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11466              		.loc 1 2069 0
 11467 6054 B0391FE5 		ldr	r3, .L987+76
 11468 6058 5D16D3E5 		ldrb	r1, [r3, #1629]	@ zero_extendqisi2
2070:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11469              		.loc 1 2070 0
 11470 605c 5E26D3E5 		ldrb	r2, [r3, #1630]	@ zero_extendqisi2
 11471 6060 39FCFFEA 		b	.L952
 11472              	.LVL1350:
 11473              	.L819:
 11474              	.LBE206:
 11475              	.LBE307:
 11476              	.LBB308:
 11477              	.LBB268:
2069:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11478              		.loc 1 2069 0
 11479 6064 C0E91FE5 		ldr	lr, .L987+76
 11480 6068 ED16DEE5 		ldrb	r1, [lr, #1773]	@ zero_extendqisi2
2070:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11481              		.loc 1 2070 0
 11482 606c EE26DEE5 		ldrb	r2, [lr, #1774]	@ zero_extendqisi2
 11483 6070 35FCFFEA 		b	.L952
 11484              	.LVL1351:
 11485              	.L784:
 11486              	.LBE268:
 11487              	.LBE308:
 11488              	.LBB309:
 11489              	.LBB249:
2069:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11490              		.loc 1 2069 0
 11491 6074 D0E91FE5 		ldr	lr, .L987+76
 11492 6078 A516DEE5 		ldrb	r1, [lr, #1701]	@ zero_extendqisi2
2070:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11493              		.loc 1 2070 0
 11494 607c A626DEE5 		ldrb	r2, [lr, #1702]	@ zero_extendqisi2
 11495 6080 31FCFFEA 		b	.L952
 11496              	.LVL1352:
 11497              	.L736:
 11498              	.LBE249:
 11499              	.LBE309:
 11500              	.LBB310:
 11501              	.LBB223:
2069:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11502              		.loc 1 2069 0
 11503 6084 E0391FE5 		ldr	r3, .L987+76
 11504 6088 2D16D3E5 		ldrb	r1, [r3, #1581]	@ zero_extendqisi2
2070:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11505              		.loc 1 2070 0
 11506 608c 2E26D3E5 		ldrb	r2, [r3, #1582]	@ zero_extendqisi2
 11507 6090 2DFCFFEA 		b	.L952
 11508              	.LVL1353:
 11509              	.L830:
 11510              	.LBE223:
 11511              	.LBE310:
 11512              	.LBB311:
 11513              	.LBB260:
2069:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11514              		.loc 1 2069 0
 11515 6094 F0391FE5 		ldr	r3, .L987+76
 11516 6098 0517D3E5 		ldrb	r1, [r3, #1797]	@ zero_extendqisi2
2070:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11517              		.loc 1 2070 0
 11518 609c 0627D3E5 		ldrb	r2, [r3, #1798]	@ zero_extendqisi2
 11519 60a0 29FCFFEA 		b	.L952
 11520              	.LVL1354:
 11521              	.L746:
 11522              	.LBE260:
 11523              	.LBE311:
 11524              	.LBB312:
 11525              	.LBB207:
2238:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 11526              		.loc 1 2238 0
 11527 60a4 0000A0E3 		mov	r0, #0
 11528 60a8 0020A0E1 		mov	r2, r0
 11529 60ac 0110A0E3 		mov	r1, #1
 11530 60b0 24C08DE5 		str	ip, [sp, #36]
 11531 60b4 FEFFFFEB 		bl	CyU3PUsbStall
 11532              	.LVL1355:
2239:../uvc.c      **** 			  break;
 11533              		.loc 1 2239 0
 11534 60b8 24C09DE5 		ldr	ip, [sp, #36]
 11535 60bc 0220A0E3 		mov	r2, #2
 11536 60c0 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 11537 60c4 0400A0E3 		mov	r0, #4
 11538 60c8 2C1A1FE5 		ldr	r1, .L987+68
 11539 60cc FEFFFFEB 		bl	CyU3PDebugPrint
 11540              	.LVL1356:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11541              		.loc 1 2025 0
 11542 60d0 FF20A0E3 		mov	r2, #255
 11543              	.LVL1357:
 11544 60d4 0BFEFFEA 		b	.L839
 11545              	.LVL1358:
 11546              	.L742:
 11547              	.LBE207:
 11548              	.LBE312:
 11549              	.LBB313:
 11550              	.LBB224:
2078:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11551              		.loc 1 2078 0
 11552 60d8 34CA1FE5 		ldr	ip, .L987+76
 11553 60dc 2F16DCE5 		ldrb	r1, [ip, #1583]	@ zero_extendqisi2
2079:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11554              		.loc 1 2079 0
 11555 60e0 3026DCE5 		ldrb	r2, [ip, #1584]	@ zero_extendqisi2
 11556 60e4 18FCFFEA 		b	.L952
 11557              	.LVL1359:
 11558              	.L825:
 11559              	.LBE224:
 11560              	.LBE313:
 11561              	.LBB314:
 11562              	.LBB269:
2078:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11563              		.loc 1 2078 0
 11564 60e8 EF16DBE5 		ldrb	r1, [fp, #1775]	@ zero_extendqisi2
2079:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11565              		.loc 1 2079 0
 11566 60ec F026DBE5 		ldrb	r2, [fp, #1776]	@ zero_extendqisi2
 11567 60f0 15FCFFEA 		b	.L952
 11568              	.LVL1360:
 11569              	.L763:
 11570              	.LBE269:
 11571              	.LBE314:
 11572              	.LBB315:
 11573              	.LBB232:
2036:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 11574              		.loc 1 2036 0
 11575 60f4 0030A0E3 		mov	r3, #0
2037:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11576              		.loc 1 2037 0
 11577 60f8 0200A0E3 		mov	r0, #2
 11578 60fc 5C1A1FE5 		ldr	r1, .L987+72
2036:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 11579              		.loc 1 2036 0
 11580 6100 2930C7E5 		strb	r3, [r7, #41]
2035:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 11581              		.loc 1 2035 0
 11582 6104 2880C7E5 		strb	r8, [r7, #40]
2037:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11583              		.loc 1 2037 0
 11584 6108 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11585              	.LVL1361:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11586              		.loc 1 2025 0
 11587 610c FF20A0E3 		mov	r2, #255
 11588 6110 0230A0E1 		mov	r3, r2
2038:../uvc.c      **** 			  break;
 11589              		.loc 1 2038 0
 11590 6114 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 11591              	.LVL1362:
 11592 6118 B8FBFFEA 		b	.L767
 11593              	.LVL1363:
 11594              	.L757:
2238:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 11595              		.loc 1 2238 0
 11596 611c 0000A0E3 		mov	r0, #0
 11597 6120 0020A0E1 		mov	r2, r0
 11598 6124 0110A0E3 		mov	r1, #1
 11599 6128 24C08DE5 		str	ip, [sp, #36]
 11600 612c FEFFFFEB 		bl	CyU3PUsbStall
 11601              	.LVL1364:
2239:../uvc.c      **** 			  break;
 11602              		.loc 1 2239 0
 11603 6130 24C09DE5 		ldr	ip, [sp, #36]
 11604 6134 0320A0E3 		mov	r2, #3
 11605 6138 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 11606 613c 0400A0E3 		mov	r0, #4
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11607              		.loc 1 2025 0
 11608 6140 FFC0A0E3 		mov	ip, #255
2239:../uvc.c      **** 			  break;
 11609              		.loc 1 2239 0
 11610 6144 A81A1FE5 		ldr	r1, .L987+68
 11611 6148 24C08DE5 		str	ip, [sp, #36]
 11612 614c FEFFFFEB 		bl	CyU3PDebugPrint
 11613              	.LVL1365:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11614              		.loc 1 2025 0
 11615 6150 24C09DE5 		ldr	ip, [sp, #36]
 11616 6154 0C20A0E1 		mov	r2, ip
 11617 6158 0C30A0E1 		mov	r3, ip
 11618 615c A7FBFFEA 		b	.L767
 11619              	.LVL1366:
 11620              	.L832:
 11621              	.LBE232:
 11622              	.LBE315:
 11623              	.LBB316:
 11624              	.LBB261:
2045:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11625              		.loc 1 2045 0
 11626 6160 BC1A1FE5 		ldr	r1, .L987+76
 11627 6164 0D27D1E5 		ldrb	r2, [r1, #1805]	@ zero_extendqisi2
2046:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11628              		.loc 1 2046 0
 11629 6168 0E17D1E5 		ldrb	r1, [r1, #1806]	@ zero_extendqisi2
 11630 616c 96FFFFEA 		b	.L956
 11631              	.LVL1367:
 11632              	.L753:
 11633              	.LBE261:
 11634              	.LBE316:
 11635              	.LBB317:
 11636              	.LBB208:
2078:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11637              		.loc 1 2078 0
 11638 6170 CCCA1FE5 		ldr	ip, .L987+76
 11639 6174 5F16DCE5 		ldrb	r1, [ip, #1631]	@ zero_extendqisi2
2079:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11640              		.loc 1 2079 0
 11641 6178 6026DCE5 		ldrb	r2, [ip, #1632]	@ zero_extendqisi2
 11642 617c F2FBFFEA 		b	.L952
 11643              	.LVL1368:
 11644              	.L795:
 11645              	.LBE208:
 11646              	.LBE317:
 11647              	.LBB318:
 11648              	.LBB216:
2069:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11649              		.loc 1 2069 0
 11650 6180 DC3A1FE5 		ldr	r3, .L987+76
 11651 6184 BD16D3E5 		ldrb	r1, [r3, #1725]	@ zero_extendqisi2
2070:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11652              		.loc 1 2070 0
 11653 6188 BE26D3E5 		ldrb	r2, [r3, #1726]	@ zero_extendqisi2
 11654 618c EEFBFFEA 		b	.L952
 11655              	.LVL1369:
 11656              	.L773:
 11657              	.LBE216:
 11658              	.LBE318:
 11659              	.LBB319:
 11660              	.LBB199:
2069:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11661              		.loc 1 2069 0
 11662 6190 EC2A1FE5 		ldr	r2, .L987+76
 11663 6194 8D16D2E5 		ldrb	r1, [r2, #1677]	@ zero_extendqisi2
2070:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11664              		.loc 1 2070 0
 11665 6198 8E26D2E5 		ldrb	r2, [r2, #1678]	@ zero_extendqisi2
 11666 619c EAFBFFEA 		b	.L952
 11667              	.LVL1370:
 11668              	.L808:
 11669              	.LBE199:
 11670              	.LBE319:
 11671              	.LBB320:
 11672              	.LBB240:
2045:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11673              		.loc 1 2045 0
 11674 61a0 FC1A1FE5 		ldr	r1, .L987+76
2047:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11675              		.loc 1 2047 0
 11676 61a4 0030A0E3 		mov	r3, #0
2045:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11677              		.loc 1 2045 0
 11678 61a8 DDC6D1E5 		ldrb	ip, [r1, #1757]	@ zero_extendqisi2
2046:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11679              		.loc 1 2046 0
 11680 61ac DE26D1E5 		ldrb	r2, [r1, #1758]	@ zero_extendqisi2
2053:../uvc.c      **** 
 11681              		.loc 1 2053 0
 11682 61b0 0900A0E1 		mov	r0, r9
 11683 61b4 141B1FE5 		ldr	r1, .L987+72
2045:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11684              		.loc 1 2045 0
 11685 61b8 28C0C7E5 		strb	ip, [r7, #40]
2046:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11686              		.loc 1 2046 0
 11687 61bc 2920C7E5 		strb	r2, [r7, #41]
2047:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11688              		.loc 1 2047 0
 11689 61c0 2A30C7E5 		strb	r3, [r7, #42]
2048:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 11690              		.loc 1 2048 0
 11691 61c4 2B30C7E5 		strb	r3, [r7, #43]
 11692              	.LVL1371:
2053:../uvc.c      **** 
 11693              		.loc 1 2053 0
 11694 61c8 24C08DE5 		str	ip, [sp, #36]
 11695 61cc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11696              	.LVL1372:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11697              		.loc 1 2025 0
 11698 61d0 FF20A0E3 		mov	r2, #255
 11699 61d4 0230A0E1 		mov	r3, r2
 11700 61d8 24C09DE5 		ldr	ip, [sp, #36]
 11701 61dc B3FBFFEA 		b	.L815
 11702              	.LVL1373:
 11703              	.L786:
 11704              	.LBE240:
 11705              	.LBE320:
 11706              	.LBB321:
 11707              	.LBB250:
2045:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11708              		.loc 1 2045 0
 11709 61e0 3C3B1FE5 		ldr	r3, .L987+76
 11710 61e4 AD26D3E5 		ldrb	r2, [r3, #1709]	@ zero_extendqisi2
2046:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11711              		.loc 1 2046 0
 11712 61e8 AE16D3E5 		ldrb	r1, [r3, #1710]	@ zero_extendqisi2
 11713 61ec 76FFFFEA 		b	.L956
 11714              	.LVL1374:
 11715              	.L812:
 11716              	.LBE250:
 11717              	.LBE321:
 11718              	.LBB322:
 11719              	.LBB241:
2078:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11720              		.loc 1 2078 0
 11721 61f0 4CCB1FE5 		ldr	ip, .L987+76
 11722 61f4 D716DCE5 		ldrb	r1, [ip, #1751]	@ zero_extendqisi2
2079:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11723              		.loc 1 2079 0
 11724 61f8 D826DCE5 		ldrb	r2, [ip, #1752]	@ zero_extendqisi2
 11725 61fc A0FBFFEA 		b	.L950
 11726              	.LVL1375:
 11727              	.L790:
 11728              	.LBE241:
 11729              	.LBE322:
 11730              	.LBB323:
 11731              	.LBB251:
2078:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11732              		.loc 1 2078 0
 11733 6200 5C2B1FE5 		ldr	r2, .L987+76
 11734 6204 A716D2E5 		ldrb	r1, [r2, #1703]	@ zero_extendqisi2
2079:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11735              		.loc 1 2079 0
 11736 6208 A826D2E5 		ldrb	r2, [r2, #1704]	@ zero_extendqisi2
 11737 620c CEFBFFEA 		b	.L952
 11738              	.LVL1376:
 11739              	.L811:
 11740              	.LBE251:
 11741              	.LBE323:
 11742              	.LBB324:
 11743              	.LBB242:
2036:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 11744              		.loc 1 2036 0
 11745 6210 0030A0E3 		mov	r3, #0
2037:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11746              		.loc 1 2037 0
 11747 6214 0200A0E3 		mov	r0, #2
 11748 6218 781B1FE5 		ldr	r1, .L987+72
2036:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 11749              		.loc 1 2036 0
 11750 621c 2930C7E5 		strb	r3, [r7, #41]
2035:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 11751              		.loc 1 2035 0
 11752 6220 2890C7E5 		strb	r9, [r7, #40]
2037:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11753              		.loc 1 2037 0
 11754 6224 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11755              	.LVL1377:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11756              		.loc 1 2025 0
 11757 6228 FF20A0E3 		mov	r2, #255
 11758 622c 0230A0E1 		mov	r3, r2
2038:../uvc.c      **** 			  break;
 11759              		.loc 1 2038 0
 11760 6230 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 11761              	.LVL1378:
 11762 6234 9DFBFFEA 		b	.L815
 11763              	.LVL1379:
 11764              	.L805:
2238:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 11765              		.loc 1 2238 0
 11766 6238 0000A0E3 		mov	r0, #0
 11767 623c 0020A0E1 		mov	r2, r0
 11768 6240 0110A0E3 		mov	r1, #1
 11769 6244 24C08DE5 		str	ip, [sp, #36]
 11770 6248 FEFFFFEB 		bl	CyU3PUsbStall
 11771              	.LVL1380:
2239:../uvc.c      **** 			  break;
 11772              		.loc 1 2239 0
 11773 624c 24C09DE5 		ldr	ip, [sp, #36]
 11774 6250 0720A0E3 		mov	r2, #7
 11775 6254 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 11776 6258 0400A0E3 		mov	r0, #4
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11777              		.loc 1 2025 0
 11778 625c FFC0A0E3 		mov	ip, #255
2239:../uvc.c      **** 			  break;
 11779              		.loc 1 2239 0
 11780 6260 C41B1FE5 		ldr	r1, .L987+68
 11781 6264 24C08DE5 		str	ip, [sp, #36]
 11782 6268 FEFFFFEB 		bl	CyU3PDebugPrint
 11783              	.LVL1381:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11784              		.loc 1 2025 0
 11785 626c 24C09DE5 		ldr	ip, [sp, #36]
 11786 6270 0C20A0E1 		mov	r2, ip
 11787 6274 0C30A0E1 		mov	r3, ip
 11788 6278 8CFBFFEA 		b	.L815
 11789              	.LVL1382:
 11790              	.L783:
 11791              	.LBE242:
 11792              	.LBE324:
 11793              	.LBB325:
 11794              	.LBB252:
2238:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 11795              		.loc 1 2238 0
 11796 627c 0000A0E3 		mov	r0, #0
 11797 6280 0020A0E1 		mov	r2, r0
 11798 6284 0110A0E3 		mov	r1, #1
 11799 6288 24C08DE5 		str	ip, [sp, #36]
 11800 628c FEFFFFEB 		bl	CyU3PUsbStall
 11801              	.LVL1383:
2239:../uvc.c      **** 			  break;
 11802              		.loc 1 2239 0
 11803 6290 24C09DE5 		ldr	ip, [sp, #36]
 11804 6294 0520A0E3 		mov	r2, #5
 11805 6298 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 11806 629c 0400A0E3 		mov	r0, #4
 11807 62a0 041C1FE5 		ldr	r1, .L987+68
 11808 62a4 FEFFFFEB 		bl	CyU3PDebugPrint
 11809              	.LVL1384:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11810              		.loc 1 2025 0
 11811 62a8 FF20A0E3 		mov	r2, #255
 11812              	.LVL1385:
 11813 62ac 95FDFFEA 		b	.L839
 11814              	.LVL1386:
 11815              	.L764:
 11816              	.LBE252:
 11817              	.LBE325:
 11818              	.LBB326:
 11819              	.LBB233:
2078:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11820              		.loc 1 2078 0
 11821 62b0 0CCC1FE5 		ldr	ip, .L987+76
 11822 62b4 7716DCE5 		ldrb	r1, [ip, #1655]	@ zero_extendqisi2
2079:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11823              		.loc 1 2079 0
 11824 62b8 7826DCE5 		ldrb	r2, [ip, #1656]	@ zero_extendqisi2
 11825 62bc 44FBFFEA 		b	.L946
 11826              	.LVL1387:
 11827              	.L836:
 11828              	.LBE233:
 11829              	.LBE326:
 11830              	.LBB327:
 11831              	.LBB262:
2078:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11832              		.loc 1 2078 0
 11833 62c0 1CCC1FE5 		ldr	ip, .L987+76
 11834 62c4 0717DCE5 		ldrb	r1, [ip, #1799]	@ zero_extendqisi2
2079:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11835              		.loc 1 2079 0
 11836 62c8 0827DCE5 		ldrb	r2, [ip, #1800]	@ zero_extendqisi2
 11837 62cc 9EFBFFEA 		b	.L952
 11838              	.L829:
2238:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 11839              		.loc 1 2238 0
 11840 62d0 0000A0E3 		mov	r0, #0
 11841 62d4 0020A0E1 		mov	r2, r0
 11842 62d8 0110A0E3 		mov	r1, #1
 11843 62dc 24C08DE5 		str	ip, [sp, #36]
 11844 62e0 FEFFFFEB 		bl	CyU3PUsbStall
 11845              	.LVL1388:
2239:../uvc.c      **** 			  break;
 11846              		.loc 1 2239 0
 11847 62e4 24C09DE5 		ldr	ip, [sp, #36]
 11848 62e8 0920A0E3 		mov	r2, #9
 11849 62ec 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 11850 62f0 0400A0E3 		mov	r0, #4
 11851 62f4 581C1FE5 		ldr	r1, .L987+68
 11852 62f8 FEFFFFEB 		bl	CyU3PDebugPrint
 11853              	.LVL1389:
2025:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11854              		.loc 1 2025 0
 11855 62fc FF20A0E3 		mov	r2, #255
 11856 6300 80FDFFEA 		b	.L839
 11857              	.LVL1390:
 11858              	.L876:
 11859              	.LBE262:
 11860              	.LBE327:
 11861              	.LBE335:
 11862              	.LBE429:
 11863              	.LBB430:
 11864              	.LBB188:
 11865              	.LBB177:
 11866              	.LBB172:
2002:../uvc.c      **** 			  break;
 11867              		.loc 1 2002 0
 11868 6304 0000A0E3 		mov	r0, #0
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11869              		.loc 1 930 0
 11870 6308 FF90A0E3 		mov	r9, #255
2002:../uvc.c      **** 			  break;
 11871              		.loc 1 2002 0
 11872 630c 0020A0E1 		mov	r2, r0
 11873 6310 0110A0E3 		mov	r1, #1
 11874 6314 FEFFFFEB 		bl	CyU3PUsbStall
 11875              	.LVL1391:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11876              		.loc 1 930 0
 11877 6318 0980A0E1 		mov	r8, r9
 11878              	.LVL1392:
 11879 631c 0920A0E1 		mov	r2, r9
 11880 6320 09C0A0E1 		mov	ip, r9
 11881 6324 B6FAFFEA 		b	.L886
 11882              	.LVL1393:
 11883              	.L880:
1400:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 11884              		.loc 1 1400 0
 11885 6328 47C1DBE5 		ldrb	ip, [fp, #327]	@ zero_extendqisi2
1401:../uvc.c      **** 		 	 }
 11886              		.loc 1 1401 0
 11887 632c 4821DBE5 		ldrb	r2, [fp, #328]	@ zero_extendqisi2
 11888 6330 AAFAFFEA 		b	.L954
 11889              	.L879:
1111:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 11890              		.loc 1 1111 0
 11891 6334 C910D7E5 		ldrb	r1, [r7, #201]	@ zero_extendqisi2
 11892 6338 000051E3 		cmp	r1, #0
 11893 633c 2E00000A 		beq	.L887
1112:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 11894              		.loc 1 1112 0
 11895 6340 7D25DBE5 		ldrb	r2, [fp, #1405]	@ zero_extendqisi2
1113:../uvc.c      **** 		 	 		 }else{
 11896              		.loc 1 1113 0
 11897 6344 7E35DBE5 		ldrb	r3, [fp, #1406]	@ zero_extendqisi2
1112:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 11898              		.loc 1 1112 0
 11899 6348 2820C4E5 		strb	r2, [r4, #40]
1113:../uvc.c      **** 		 	 		 }else{
 11900              		.loc 1 1113 0
 11901 634c 2930C4E5 		strb	r3, [r4, #41]
 11902              	.LVL1394:
 11903              	.L888:
1120:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
 11904              		.loc 1 1120 0
 11905 6350 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 11906              	.LVL1395:
1392:../uvc.c      **** 
 11907              		.loc 1 1392 0
 11908 6354 0800A0E1 		mov	r0, r8
 11909 6358 B81C1FE5 		ldr	r1, .L987+72
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11910              		.loc 1 930 0
 11911 635c FF80A0E3 		mov	r8, #255
 11912              	.LVL1396:
1392:../uvc.c      **** 
 11913              		.loc 1 1392 0
 11914 6360 2C208DE5 		str	r2, [sp, #44]
1121:../uvc.c      **** 					 break;
 11915              		.loc 1 1121 0
 11916 6364 2990D7E5 		ldrb	r9, [r7, #41]	@ zero_extendqisi2
 11917              	.LVL1397:
1392:../uvc.c      **** 
 11918              		.loc 1 1392 0
 11919 6368 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11920              	.LVL1398:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11921              		.loc 1 930 0
 11922 636c 08C0A0E1 		mov	ip, r8
 11923 6370 2C209DE5 		ldr	r2, [sp, #44]
 11924 6374 A2FAFFEA 		b	.L886
 11925              	.LVL1399:
 11926              	.L877:
1419:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 11927              		.loc 1 1419 0
 11928 6378 D4EC1FE5 		ldr	lr, .L987+76
 11929 637c 49C1DEE5 		ldrb	ip, [lr, #329]	@ zero_extendqisi2
1420:../uvc.c      **** 		 	 }
 11930              		.loc 1 1420 0
 11931 6380 4A21DEE5 		ldrb	r2, [lr, #330]	@ zero_extendqisi2
 11932 6384 95FAFFEA 		b	.L954
 11933              	.LVL1400:
 11934              	.L816:
 11935              	.LBE172:
 11936              	.LBE177:
 11937              	.LBE188:
 11938              	.LBE430:
 11939              	.LBB431:
 11940              	.LBB336:
 11941              	.LBB328:
 11942              	.LBB243:
2206:../uvc.c      **** 					  }
 11943              		.loc 1 2206 0
 11944 6388 0020A0E1 		mov	r2, r0
 11945 638c 0810A0E1 		mov	r1, r8
 11946 6390 FEFFFFEB 		bl	CyU3PUsbStall
 11947              	.LVL1401:
 11948 6394 ADFCFFEA 		b	.L817
 11949              	.LVL1402:
 11950              	.L884:
 11951              	.LBE243:
 11952              	.LBE328:
 11953              	.LBE336:
 11954              	.LBE431:
 11955              	.LBB432:
 11956              	.LBB189:
 11957              	.LBB178:
 11958              	.LBB173:
1453:../uvc.c      **** 		 	 }
 11959              		.loc 1 1453 0
 11960 6398 4D21DBE5 		ldrb	r2, [fp, #333]	@ zero_extendqisi2
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11961              		.loc 1 930 0
 11962 639c FF90A0E3 		mov	r9, #255
1458:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11963              		.loc 1 1458 0
 11964 63a0 0100A0E3 		mov	r0, #1
 11965 63a4 041D1FE5 		ldr	r1, .L987+72
1453:../uvc.c      **** 		 	 }
 11966              		.loc 1 1453 0
 11967 63a8 2820C7E5 		strb	r2, [r7, #40]
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11968              		.loc 1 930 0
 11969 63ac 0980A0E1 		mov	r8, r9
1458:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11970              		.loc 1 1458 0
 11971 63b0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11972              	.LVL1403:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11973              		.loc 1 930 0
 11974 63b4 09C0A0E1 		mov	ip, r9
1459:../uvc.c      **** 			  Len = 1;
 11975              		.loc 1 1459 0
 11976 63b8 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 11977              	.LVL1404:
 11978 63bc 90FAFFEA 		b	.L886
 11979              	.LVL1405:
 11980              	.L883:
1438:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11981              		.loc 1 1438 0
 11982 63c0 4CC1DBE5 		ldrb	ip, [fp, #332]	@ zero_extendqisi2
1437:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 11983              		.loc 1 1437 0
 11984 63c4 4B31DBE5 		ldrb	r3, [fp, #331]	@ zero_extendqisi2
1439:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11985              		.loc 1 1439 0
 11986 63c8 0020A0E3 		mov	r2, #0
1448:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11987              		.loc 1 1448 0
 11988 63cc 0800A0E1 		mov	r0, r8
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11989              		.loc 1 930 0
 11990 63d0 FF90A0E3 		mov	r9, #255
1448:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11991              		.loc 1 1448 0
 11992 63d4 341D1FE5 		ldr	r1, .L987+72
1438:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11993              		.loc 1 1438 0
 11994 63d8 29C0C7E5 		strb	ip, [r7, #41]
1439:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11995              		.loc 1 1439 0
 11996 63dc 2A20C7E5 		strb	r2, [r7, #42]
1440:../uvc.c      **** 		 	 }
 11997              		.loc 1 1440 0
 11998 63e0 2B20C7E5 		strb	r2, [r7, #43]
1437:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 11999              		.loc 1 1437 0
 12000 63e4 2830C7E5 		strb	r3, [r7, #40]
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 12001              		.loc 1 930 0
 12002 63e8 0980A0E1 		mov	r8, r9
1448:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 12003              		.loc 1 1448 0
 12004 63ec FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 12005              	.LVL1406:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 12006              		.loc 1 930 0
 12007 63f0 09C0A0E1 		mov	ip, r9
1449:../uvc.c      **** 			  break;
 12008              		.loc 1 1449 0
 12009 63f4 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 12010              	.LVL1407:
 12011 63f8 81FAFFEA 		b	.L886
 12012              	.LVL1408:
 12013              	.L887:
1115:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12014              		.loc 1 1115 0
 12015 63fc 0310A0E1 		mov	r1, r3
 12016 6400 28308DE5 		str	r3, [sp, #40]
 12017 6404 FEFFFFEB 		bl	SensorGetControl
 12018              	.LVL1409:
1117:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12019              		.loc 1 1117 0
 12020 6408 28309DE5 		ldr	r3, [sp, #40]
 12021 640c 0310A0E1 		mov	r1, r3
1115:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12022              		.loc 1 1115 0
 12023 6410 00C0A0E1 		mov	ip, r0
1117:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12024              		.loc 1 1117 0
 12025 6414 0900A0E1 		mov	r0, r9
1115:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12026              		.loc 1 1115 0
 12027 6418 28C0C4E5 		strb	ip, [r4, #40]
1116:../uvc.c      **** 		 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 12028              		.loc 1 1116 0
 12029 641c 7DC5CBE5 		strb	ip, [fp, #1405]
1117:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12030              		.loc 1 1117 0
 12031 6420 FEFFFFEB 		bl	SensorGetControl
 12032              	.LVL1410:
1118:../uvc.c      **** 		 	 		 }
 12033              		.loc 1 1118 0
 12034 6424 0130A0E3 		mov	r3, #1
 12035 6428 C930C4E5 		strb	r3, [r4, #201]
1117:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12036              		.loc 1 1117 0
 12037 642c 2900C4E5 		strb	r0, [r4, #41]
 12038 6430 C6FFFFEA 		b	.L888
 12039              	.LVL1411:
 12040              	.L889:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 12041              		.loc 1 930 0
 12042 6434 FF90A0E3 		mov	r9, #255
 12043              	.LVL1412:
1994:../uvc.c      **** 			   }
 12044              		.loc 1 1994 0
 12045 6438 0400A0E3 		mov	r0, #4
 12046              	.LVL1413:
 12047 643c 901D1FE5 		ldr	r1, .L987+84
 12048 6440 FEFFFFEB 		bl	CyU3PDebugPrint
 12049              	.LVL1414:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 12050              		.loc 1 930 0
 12051 6444 0980A0E1 		mov	r8, r9
 12052              	.LVL1415:
 12053 6448 0920A0E1 		mov	r2, r9
 12054 644c 09C0A0E1 		mov	ip, r9
 12055 6450 6BFAFFEA 		b	.L886
 12056              	.LVL1416:
 12057              	.L719:
 12058              	.LBE173:
 12059              	.LBE178:
 12060              	.LBE189:
 12061              	.LBE432:
 12062              	.LBB433:
 12063              	.LBB405:
 12064              	.LBB392:
 12065              	.LBB360:
1994:../uvc.c      **** 			   }
 12066              		.loc 1 1994 0
 12067 6454 A81D1FE5 		ldr	r1, .L987+84
 12068 6458 0400A0E3 		mov	r0, #4
 12069 645c FEFFFFEB 		bl	CyU3PDebugPrint
 12070              	.LVL1417:
 12071 6460 17FEFFEA 		b	.L941
 12072              	.LVL1418:
 12073              	.L986:
 12074              	.LBE360:
 12075              	.LBE392:
 12076              	.LBB393:
 12077              	.LBB349:
1237:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 12078              		.loc 1 1237 0
 12079 6464 30109DE5 		ldr	r1, [sp, #48]
 12080 6468 FEFFFFEB 		bl	SensorGetControl
 12081              	.LVL1419:
1239:../uvc.c      **** 		 	 		 }
 12082              		.loc 1 1239 0
 12083 646c 0130A0E3 		mov	r3, #1
 12084 6470 A130C7E5 		strb	r3, [r7, #161]
1238:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12085              		.loc 1 1238 0
 12086 6474 1102CBE5 		strb	r0, [fp, #529]
 12087 6478 91FEFFEA 		b	.L686
 12088              	.LVL1420:
 12089              	.L703:
 12090              	.LBE349:
 12091              	.LBE393:
 12092              	.LBB394:
 12093              	.LBB370:
1325:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
 12094              		.loc 1 1325 0
 12095 647c 0300A0E1 		mov	r0, r3
 12096 6480 0C10A0E1 		mov	r1, ip
 12097 6484 FEFFFFEB 		bl	SensorGetControl
 12098              	.LVL1421:
1327:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12099              		.loc 1 1327 0
 12100 6488 E43D1FE5 		ldr	r3, .L987+76
1326:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 12101              		.loc 1 1326 0
 12102 648c E8CD1FE5 		ldr	ip, .L987+76
1327:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12103              		.loc 1 1327 0
 12104 6490 2A22D3E5 		ldrb	r2, [r3, #554]	@ zero_extendqisi2
1328:../uvc.c      **** 		 	 		 }
 12105              		.loc 1 1328 0
 12106 6494 0130A0E3 		mov	r3, #1
1327:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12107              		.loc 1 1327 0
 12108 6498 2920C4E5 		strb	r2, [r4, #41]
1328:../uvc.c      **** 		 	 		 }
 12109              		.loc 1 1328 0
 12110 649c A230C4E5 		strb	r3, [r4, #162]
1325:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
 12111              		.loc 1 1325 0
 12112 64a0 2800C4E5 		strb	r0, [r4, #40]
1326:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 12113              		.loc 1 1326 0
 12114 64a4 2902CCE5 		strb	r0, [ip, #553]
 12115 64a8 5CFEFFEA 		b	.L718
 12116              	.LVL1422:
 12117              	.L717:
 12118              	.LBE370:
 12119              	.LBE394:
 12120              	.LBB395:
 12121              	.LBB361:
1339:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 12122              		.loc 1 1339 0
 12123 64ac 0300A0E1 		mov	r0, r3
 12124 64b0 0C10A0E1 		mov	r1, ip
 12125 64b4 FEFFFFEB 		bl	SensorGetControl
 12126              	.LVL1423:
1342:../uvc.c      **** 
 12127              		.loc 1 1342 0
 12128 64b8 141E1FE5 		ldr	r1, .L987+76
1340:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 12129              		.loc 1 1340 0
 12130 64bc 183E1FE5 		ldr	r3, .L987+76
1342:../uvc.c      **** 
 12131              		.loc 1 1342 0
 12132 64c0 D222D1E5 		ldrb	r2, [r1, #722]	@ zero_extendqisi2
 12133 64c4 2920C4E5 		strb	r2, [r4, #41]
1341:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 12134              		.loc 1 1341 0
 12135 64c8 031000E2 		and	r1, r0, #3
1340:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 12136              		.loc 1 1340 0
 12137 64cc D102C3E5 		strb	r0, [r3, #721]
1344:../uvc.c      **** 		 	 		 }
 12138              		.loc 1 1344 0
 12139 64d0 0130A0E3 		mov	r3, #1
1341:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 12140              		.loc 1 1341 0
 12141 64d4 2810C4E5 		strb	r1, [r4, #40]
1344:../uvc.c      **** 		 	 		 }
 12142              		.loc 1 1344 0
 12143 64d8 A930C4E5 		strb	r3, [r4, #169]
 12144 64dc 4FFEFFEA 		b	.L718
 12145              	.LVL1424:
 12146              	.L892:
 12147              	.LBE361:
 12148              	.LBE395:
 12149              	.LBE405:
 12150              	.LBE433:
 12151              	.LBB434:
 12152              	.LBB190:
 12153              	.LBB179:
 12154              	.LBB174:
1638:../uvc.c      **** 								 }
 12155              		.loc 1 1638 0
 12156 64e0 0010A0E3 		mov	r1, #0
 12157 64e4 00C08DE5 		str	ip, [sp]
 12158 64e8 04108DE5 		str	r1, [sp, #4]
 12159 64ec 0930A0E1 		mov	r3, r9
 12160 64f0 480E1FE5 		ldr	r0, .L987+80
 12161 64f4 2910A0E3 		mov	r1, #41
 12162 64f8 24C08DE5 		str	ip, [sp, #36]
 12163 64fc FEFFFFEB 		bl	cmdSet
 12164              	.LVL1425:
 12165 6500 24C09DE5 		ldr	ip, [sp, #36]
 12166 6504 1AFEFFEA 		b	.L891
 12167              	.LVL1426:
 12168              	.L689:
 12169              	.LBE174:
 12170              	.LBE179:
 12171              	.LBE190:
 12172              	.LBE434:
 12173              	.LBB435:
 12174              	.LBB406:
 12175              	.LBB396:
 12176              	.LBB350:
1994:../uvc.c      **** 			   }
 12177              		.loc 1 1994 0
 12178 6508 0400A0E3 		mov	r0, #4
 12179              	.LVL1427:
 12180 650c 601E1FE5 		ldr	r1, .L987+84
 12181 6510 FEFFFFEB 		bl	CyU3PDebugPrint
 12182              	.LVL1428:
 930:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 12183              		.loc 1 930 0
 12184 6514 FF30A0E3 		mov	r3, #255
 12185 6518 0390A0E1 		mov	r9, r3
 12186              	.LVL1429:
 12187 651c 03C0A0E1 		mov	ip, r3
 12188 6520 96FBFFEA 		b	.L684
 12189              	.LBE350:
 12190              	.LBE396:
 12191              	.LBE406:
 12192              	.LBE435:
 12193              		.cfi_endproc
 12194              	.LFE25:
 12196              		.align	2
 12197              		.global	CyFxGpifCB
 12199              	CyFxGpifCB:
 12200              	.LFB13:
2768:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 12201              		.loc 1 2768 0
 12202              		.cfi_startproc
 12203              		@ args = 0, pretend = 0, frame = 0
 12204              		@ frame_needed = 0, uses_anonymous_args = 0
2769:../uvc.c      ****     {
 12205              		.loc 1 2769 0
 12206 6524 010050E3 		cmp	r0, #1
2768:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 12207              		.loc 1 2768 0
 12208 6528 10402DE9 		stmfd	sp!, {r4, lr}
 12209              	.LCFI29:
 12210              		.cfi_def_cfa_offset 8
 12211              		.cfi_offset 4, -8
 12212              		.cfi_offset 14, -4
2769:../uvc.c      ****     {
 12213              		.loc 1 2769 0
 12214 652c 1080BD18 		ldmnefd	sp!, {r4, pc}
 12215              	.LBB440:
 12216              	.LBB441:
2666:../uvc.c      ****     {
 12217              		.loc 1 2666 0
 12218 6530 C4309FE5 		ldr	r3, .L1006
 12219 6534 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 12220 6538 030053E3 		cmp	r3, #3
 12221 653c 1000000A 		beq	.L1005
2692:../uvc.c      ****     {
 12222              		.loc 1 2692 0
 12223 6540 020053E3 		cmp	r3, #2
 12224 6544 1080BD18 		ldmnefd	sp!, {r4, pc}
2694:../uvc.c      ****         {
 12225              		.loc 1 2694 0
 12226 6548 083041E2 		sub	r3, r1, #8
 12227 654c 0A0053E3 		cmp	r3, #10
 12228 6550 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 12229 6554 200000EA 		b	.L998
 12230              	.L1000:
 12231 6558 D4650000 		.word	.L993
 12232 655c DC650000 		.word	.L998
 12233 6560 DC650000 		.word	.L998
 12234 6564 A4650000 		.word	.L989
 12235 6568 DC650000 		.word	.L998
 12236 656c DC650000 		.word	.L998
 12237 6570 DC650000 		.word	.L998
 12238 6574 A8650000 		.word	.L1004
 12239 6578 DC650000 		.word	.L998
 12240 657c DC650000 		.word	.L998
 12241 6580 A4650000 		.word	.L989
 12242              	.L1005:
2668:../uvc.c      ****         {
 12243              		.loc 1 2668 0
 12244 6584 0B1041E2 		sub	r1, r1, #11
 12245 6588 030051E3 		cmp	r1, #3
 12246 658c 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 12247 6590 150000EA 		b	.L992
 12248              	.L994:
 12249 6594 D4650000 		.word	.L993
 12250 6598 A8650000 		.word	.L1004
 12251 659c A4650000 		.word	.L989
 12252 65a0 A4650000 		.word	.L989
 12253              	.L989:
 12254 65a4 1080BDE8 		ldmfd	sp!, {r4, pc}
 12255              	.L1004:
2694:../uvc.c      ****         {
 12256              		.loc 1 2694 0
 12257 65a8 0110A0E3 		mov	r1, #1
 12258              	.L995:
2751:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 12259              		.loc 1 2751 0
 12260 65ac 4C009FE5 		ldr	r0, .L1006+4
 12261 65b0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
2752:../uvc.c      ****         {
 12262              		.loc 1 2752 0
 12263 65b4 004050E2 		subs	r4, r0, #0
 12264 65b8 1080BD08 		ldmeqfd	sp!, {r4, pc}
2754:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
 12265              		.loc 1 2754 0
 12266 65bc 0400A0E3 		mov	r0, #4
 12267 65c0 3C109FE5 		ldr	r1, .L1006+8
 12268 65c4 0420A0E1 		mov	r2, r4
 12269 65c8 FEFFFFEB 		bl	CyU3PDebugPrint
2755:../uvc.c      ****         }
 12270              		.loc 1 2755 0
 12271 65cc 0400A0E1 		mov	r0, r4
 12272 65d0 FEFFFFEB 		bl	CyFxAppErrorHandler
 12273              	.L993:
2668:../uvc.c      ****         {
 12274              		.loc 1 2668 0
 12275 65d4 0010A0E3 		mov	r1, #0
 12276 65d8 F3FFFFEA 		b	.L995
 12277              	.L998:
2740:../uvc.c      ****                 /* Unexpected current state. Return error. */
 12278              		.loc 1 2740 0
 12279 65dc 0120A0E1 		mov	r2, r1
 12280 65e0 0100A0E3 		mov	r0, #1
 12281 65e4 1C109FE5 		ldr	r1, .L1006+12
 12282 65e8 FEFFFFEB 		bl	CyU3PDebugPrint
 12283              	.L992:
 12284              	.LBE441:
 12285              	.LBE440:
 12286              	.LBB442:
 12287              	.LBB443:
2775:../uvc.c      ****     }
 12288              		.loc 1 2775 0
 12289 65ec 0400A0E3 		mov	r0, #4
 12290 65f0 14109FE5 		ldr	r1, .L1006+16
 12291              	.LBE443:
 12292              	.LBE442:
2778:../uvc.c      **** 
 12293              		.loc 1 2778 0
 12294 65f4 1040BDE8 		ldmfd	sp!, {r4, lr}
 12295              	.LBB445:
 12296              	.LBB444:
2775:../uvc.c      ****     }
 12297              		.loc 1 2775 0
 12298 65f8 FEFFFFEA 		b	CyU3PDebugPrint
 12299              	.L1007:
 12300              		.align	2
 12301              	.L1006:
 12302 65fc 00000000 		.word	.LANCHOR0
 12303 6600 00000000 		.word	glChHandleUVCStream
 12304 6604 C40C0000 		.word	.LC73
 12305 6608 AC0C0000 		.word	.LC72
 12306 660c F40C0000 		.word	.LC74
 12307              	.LBE444:
 12308              	.LBE445:
 12309              		.cfi_endproc
 12310              	.LFE13:
 12312              		.align	2
 12313              		.global	CyFxApplicationDefine
 12315              	CyFxApplicationDefine:
 12316              	.LFB27:
4993:../uvc.c      **** }
4994:../uvc.c      **** 
4995:../uvc.c      **** 
4996:../uvc.c      **** /*
4997:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
4998:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
4999:../uvc.c      ****  */
5000:../uvc.c      **** void
5001:../uvc.c      **** CyFxApplicationDefine (
5002:../uvc.c      ****         void)
5003:../uvc.c      **** {
 12317              		.loc 1 5003 0
 12318              		.cfi_startproc
 12319              		@ args = 0, pretend = 0, frame = 32
 12320              		@ frame_needed = 0, uses_anonymous_args = 0
 12321              	.LVL1430:
 12322 6610 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 12323              	.LCFI30:
 12324              		.cfi_def_cfa_offset 32
 12325              		.cfi_offset 4, -32
 12326              		.cfi_offset 5, -28
 12327              		.cfi_offset 6, -24
 12328              		.cfi_offset 7, -20
 12329              		.cfi_offset 8, -16
 12330              		.cfi_offset 9, -12
 12331              		.cfi_offset 10, -8
 12332              		.cfi_offset 14, -4
5004:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
5005:../uvc.c      ****     uint32_t retThrdCreate;
5006:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
5007:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
5008:../uvc.c      **** 
5009:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
5010:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12333              		.loc 1 5010 0
 12334 6614 010AA0E3 		mov	r0, #4096
5003:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
 12335              		.loc 1 5003 0
 12336 6618 40D04DE2 		sub	sp, sp, #64
 12337              	.LCFI31:
 12338              		.cfi_def_cfa_offset 96
 12339              		.loc 1 5010 0
 12340 661c FEFFFFEB 		bl	CyU3PMemAlloc
 12341              	.LVL1431:
 12342 6620 0070A0E1 		mov	r7, r0
 12343              	.LVL1432:
5011:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12344              		.loc 1 5011 0
 12345 6624 010AA0E3 		mov	r0, #4096
 12346              	.LVL1433:
 12347 6628 FEFFFFEB 		bl	CyU3PMemAlloc
 12348              	.LVL1434:
 12349 662c 0060A0E1 		mov	r6, r0
 12350              	.LVL1435:
5012:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12351              		.loc 1 5012 0
 12352 6630 010AA0E3 		mov	r0, #4096
 12353              	.LVL1436:
 12354 6634 FEFFFFEB 		bl	CyU3PMemAlloc
 12355              	.LVL1437:
5013:../uvc.c      **** 
5014:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 12356              		.loc 1 5014 0
 12357 6638 000056E3 		cmp	r6, #0
 12358 663c 00005713 		cmpne	r7, #0
 12359 6640 00A0A013 		movne	r10, #0
 12360 6644 01A0A003 		moveq	r10, #1
5012:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12361              		.loc 1 5012 0
 12362 6648 0090A0E1 		mov	r9, r0
 12363              	.LVL1438:
 12364              		.loc 1 5014 0
 12365 664c 0000001A 		bne	.L1019
 12366              	.LVL1439:
 12367              	.L1009:
 12368              	.L1011:
 12369 6650 FEFFFFEA 		b	.L1011
 12370              	.LVL1440:
 12371              	.L1019:
 12372              		.loc 1 5014 0 is_stmt 0 discriminator 1
 12373 6654 000050E3 		cmp	r0, #0
 12374 6658 FCFFFF0A 		beq	.L1009
 12375              	.LVL1441:
5015:../uvc.c      ****         goto fatalErrorHandler;
5016:../uvc.c      **** 
5017:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
5018:../uvc.c      ****     char *cmdName = "I2CcmdQue";
5019:../uvc.c      ****     char *staName = "I2CstaQue";
5020:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 12376              		.loc 1 5020 0 is_stmt 1
 12377 665c F4309FE5 		ldr	r3, .L1020
 12378 6660 20008DE2 		add	r0, sp, #32
 12379              	.LVL1442:
 12380 6664 00308DE5 		str	r3, [sp]
 12381 6668 4010A0E3 		mov	r1, #64
 12382 666c E8209FE5 		ldr	r2, .L1020+4
 12383 6670 0A30A0E1 		mov	r3, r10
 12384 6674 FEFFFFEB 		bl	cmdbufCreate
 12385              	.LVL1443:
 12386 6678 20E08DE2 		add	lr, sp, #32
 12387 667c 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 12388 6680 D8C09FE5 		ldr	ip, .L1020+8
5021:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
5022:../uvc.c      **** 	//VdRingBuf  cmdbufCreate(uint16_t size, char * name, uint8_t id, CyU3PMutex *muxPtr);
5023:../uvc.c      **** 
5024:../uvc.c      **** 	/****** initialize command descriptor ***********/
5025:../uvc.c      **** 	cmdquInit(cmdQuptr);
5026:../uvc.c      **** 	cmdquInit(statQuptr);
5027:../uvc.c      **** 
5028:../uvc.c      ****     /* Create the UVC application thread. */
5029:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 12389              		.loc 1 5029 0
 12390 6684 0840A0E3 		mov	r4, #8
5020:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 12391              		.loc 1 5020 0
 12392 6688 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 12393 668c 0F009EE8 		ldmia	lr, {r0, r1, r2, r3}
 12394              		.loc 1 5029 0
 12395 6690 0150A0E3 		mov	r5, #1
5020:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 12396              		.loc 1 5020 0
 12397 6694 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
5025:../uvc.c      **** 	cmdquInit(statQuptr);
 12398              		.loc 1 5025 0
 12399 6698 10004CE2 		sub	r0, ip, #16
 12400 669c FEFFFFEB 		bl	cmdquInit
 12401              	.LVL1444:
5026:../uvc.c      **** 
 12402              		.loc 1 5026 0
 12403 66a0 BC009FE5 		ldr	r0, .L1020+12
 12404 66a4 FEFFFFEB 		bl	cmdquInit
 12405              	.LVL1445:
 12406              		.loc 1 5029 0
 12407 66a8 A880A0E3 		mov	r8, #168
 12408 66ac 012AA0E3 		mov	r2, #4096
 12409 66b0 0A30A0E1 		mov	r3, r10
 12410 66b4 14008DE9 		stmib	sp, {r2, r4}
 12411 66b8 A8009FE5 		ldr	r0, .L1020+16
 12412 66bc 00708DE5 		str	r7, [sp]
 12413 66c0 10A08DE5 		str	r10, [sp, #16]
 12414 66c4 0C408DE5 		str	r4, [sp, #12]
 12415 66c8 14508DE5 		str	r5, [sp, #20]
 12416 66cc 18808DE5 		str	r8, [sp, #24]
 12417 66d0 94109FE5 		ldr	r1, .L1020+20
 12418 66d4 94209FE5 		ldr	r2, .L1020+24
 12419 66d8 FEFFFFEB 		bl	_txe_thread_create
 12420              	.LVL1446:
5030:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
5031:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
5032:../uvc.c      ****             0,                                          /* No input parameter to thread */
5033:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
5034:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
5035:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
5036:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
5037:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
5038:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
5039:../uvc.c      ****             );
5040:../uvc.c      ****     if (retThrdCreate != 0)
 12421              		.loc 1 5040 0
 12422 66dc 003050E2 		subs	r3, r0, #0
 12423 66e0 DAFFFF1A 		bne	.L1009
5041:../uvc.c      ****     {
5042:../uvc.c      ****         goto fatalErrorHandler;
5043:../uvc.c      ****     }
5044:../uvc.c      **** 
5045:../uvc.c      ****     /* Create the control request handling thread. */
5046:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 12424              		.loc 1 5046 0
 12425 66e4 027BA0E3 		mov	r7, #2048
 12426              	.LVL1447:
 12427 66e8 10308DE5 		str	r3, [sp, #16]
 12428 66ec 00608DE5 		str	r6, [sp]
 12429 66f0 08408DE5 		str	r4, [sp, #8]
 12430 66f4 0C408DE5 		str	r4, [sp, #12]
 12431 66f8 14508DE5 		str	r5, [sp, #20]
 12432 66fc 18808DE5 		str	r8, [sp, #24]
 12433 6700 04708DE5 		str	r7, [sp, #4]
 12434 6704 68009FE5 		ldr	r0, .L1020+28
 12435              	.LVL1448:
 12436 6708 68109FE5 		ldr	r1, .L1020+32
 12437 670c 68209FE5 		ldr	r2, .L1020+36
 12438 6710 FEFFFFEB 		bl	_txe_thread_create
 12439              	.LVL1449:
5047:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
5048:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
5049:../uvc.c      ****             0,                                                  /* No input parameter to thread */
5050:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
5051:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
5052:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
5053:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
5054:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
5055:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
5056:../uvc.c      ****             );
5057:../uvc.c      ****     if (retThrdCreate != 0)
 12440              		.loc 1 5057 0
 12441 6714 003050E2 		subs	r3, r0, #0
 12442 6718 CCFFFF1A 		bne	.L1009
5058:../uvc.c      ****     {
5059:../uvc.c      ****         goto fatalErrorHandler;
5060:../uvc.c      ****     }
5061:../uvc.c      **** #if 1
5062:../uvc.c      ****     /* Create the I2C control command handling thread. */
5063:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 12443              		.loc 1 5063 0
 12444 671c 00908DE5 		str	r9, [sp]
 12445 6720 04708DE5 		str	r7, [sp, #4]
 12446 6724 08408DE5 		str	r4, [sp, #8]
 12447 6728 0C408DE5 		str	r4, [sp, #12]
 12448 672c 10308DE5 		str	r3, [sp, #16]
 12449 6730 14508DE5 		str	r5, [sp, #20]
 12450 6734 18808DE5 		str	r8, [sp, #24]
 12451 6738 40009FE5 		ldr	r0, .L1020+40
 12452              	.LVL1450:
 12453 673c 40109FE5 		ldr	r1, .L1020+44
 12454 6740 40209FE5 		ldr	r2, .L1020+48
 12455 6744 FEFFFFEB 		bl	_txe_thread_create
 12456              	.LVL1451:
5064:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
5065:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
5066:../uvc.c      ****             0,                                          /* No input parameter to thread */
5067:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
5068:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
5069:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
5070:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
5071:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
5072:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
5073:../uvc.c      ****             );
5074:../uvc.c      ****     if (retThrdCreate != 0)
 12457              		.loc 1 5074 0
 12458 6748 000050E3 		cmp	r0, #0
 12459 674c BFFFFF1A 		bne	.L1009
5075:../uvc.c      ****     {
5076:../uvc.c      ****         goto fatalErrorHandler;
5077:../uvc.c      ****     }
5078:../uvc.c      **** #endif
5079:../uvc.c      **** 
5080:../uvc.c      ****     return;
5081:../uvc.c      **** 
5082:../uvc.c      **** fatalErrorHandler:
5083:../uvc.c      ****     /* Add custom recovery or debug actions here */
5084:../uvc.c      ****     /* Loop indefinitely */
5085:../uvc.c      ****     while (1);
5086:../uvc.c      **** }
 12460              		.loc 1 5086 0
 12461 6750 40D08DE2 		add	sp, sp, #64
 12462              		@ sp needed
 12463 6754 F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, pc}
 12464              	.LVL1452:
 12465              	.L1021:
 12466              		.align	2
 12467              	.L1020:
 12468 6758 00000000 		.word	cmdQuMux
 12469 675c 0C0D0000 		.word	.LC75
 12470 6760 00000000 		.word	cmdQu
 12471 6764 00000000 		.word	statQu
 12472 6768 E4000000 		.word	.LANCHOR0+228
 12473 676c 180D0000 		.word	.LC76
 12474 6770 00000000 		.word	UVCAppThread_Entry
 12475 6774 8C010000 		.word	.LANCHOR0+396
 12476 6778 2C0D0000 		.word	.LC77
 12477 677c 00000000 		.word	UVCAppEP0Thread_Entry
 12478 6780 34020000 		.word	.LANCHOR0+564
 12479 6784 440D0000 		.word	.LC78
 12480 6788 00000000 		.word	I2cAppThread_Entry
 12481              		.cfi_endproc
 12482              	.LFE27:
 12484              		.section	.text.startup,"ax",%progbits
 12485              		.align	2
 12486              		.global	main
 12488              	main:
 12489              	.LFB28:
5087:../uvc.c      **** 
5088:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
5089:../uvc.c      ****  * the ThreadX RTOS here.
5090:../uvc.c      ****  */
5091:../uvc.c      **** int
5092:../uvc.c      **** main (
5093:../uvc.c      ****         void)
5094:../uvc.c      **** {
 12490              		.loc 1 5094 0
 12491              		.cfi_startproc
 12492              		@ args = 0, pretend = 0, frame = 56
 12493              		@ frame_needed = 0, uses_anonymous_args = 0
 12494 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 12495              	.LCFI32:
 12496              		.cfi_def_cfa_offset 12
 12497              		.cfi_offset 4, -12
 12498              		.cfi_offset 5, -8
 12499              		.cfi_offset 14, -4
 12500 0004 3CD04DE2 		sub	sp, sp, #60
 12501              	.LCFI33:
 12502              		.cfi_def_cfa_offset 72
5095:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
5096:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
5097:../uvc.c      **** 
5098:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
5099:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
5100:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 12503              		.loc 1 5100 0
 12504 0008 0230A0E3 		mov	r3, #2
5101:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
5102:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
5103:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 12505              		.loc 1 5103 0
 12506 000c 0010A0E3 		mov	r1, #0
5104:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 12507              		.loc 1 5104 0
 12508 0010 0320A0E3 		mov	r2, #3
5099:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 12509              		.loc 1 5099 0
 12510 0014 0150A0E3 		mov	r5, #1
5105:../uvc.c      **** 
5106:../uvc.c      ****     /* Initialize the device */
5107:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 12511              		.loc 1 5107 0
 12512 0018 0D00A0E1 		mov	r0, sp
5099:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 12513              		.loc 1 5099 0
 12514 001c 00508DE5 		str	r5, [sp]
5100:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 12515              		.loc 1 5100 0
 12516 0020 0430CDE5 		strb	r3, [sp, #4]
5101:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 12517              		.loc 1 5101 0
 12518 0024 0530CDE5 		strb	r3, [sp, #5]
5102:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 12519              		.loc 1 5102 0
 12520 0028 0630CDE5 		strb	r3, [sp, #6]
5103:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 12521              		.loc 1 5103 0
 12522 002c 08108DE5 		str	r1, [sp, #8]
5104:../uvc.c      **** 
 12523              		.loc 1 5104 0
 12524 0030 0C20CDE5 		strb	r2, [sp, #12]
 12525              		.loc 1 5107 0
 12526 0034 FEFFFFEB 		bl	CyU3PDeviceInit
 12527              	.LVL1453:
5108:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 12528              		.loc 1 5108 0
 12529 0038 004050E2 		subs	r4, r0, #0
 12530 003c 0000000A 		beq	.L1027
 12531              	.L1023:
 12532              	.L1024:
 12533 0040 FEFFFFEA 		b	.L1024
 12534              	.L1027:
5109:../uvc.c      ****     {
5110:../uvc.c      ****         goto handle_fatal_error;
5111:../uvc.c      ****     }
5112:../uvc.c      **** 
5113:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
5114:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 12535              		.loc 1 5114 0
 12536 0044 0410A0E1 		mov	r1, r4
 12537 0048 0420A0E1 		mov	r2, r4
 12538 004c 0500A0E1 		mov	r0, r5
 12539              	.LVL1454:
 12540 0050 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 12541              	.LVL1455:
5115:../uvc.c      **** 
5116:../uvc.c      ****     /* Configure the IO matrix for the device. */
5117:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
5118:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
5119:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
5120:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
5121:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
5122:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
5123:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
5124:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
5125:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
5126:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
5127:../uvc.c      **** 
5128:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 12542              		.loc 1 5128 0
 12543 0054 10008DE2 		add	r0, sp, #16
5118:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 12544              		.loc 1 5118 0
 12545 0058 2640CDE5 		strb	r4, [sp, #38]
5119:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 12546              		.loc 1 5119 0
 12547 005c 28408DE5 		str	r4, [sp, #40]
5120:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 12548              		.loc 1 5120 0
 12549 0060 2C408DE5 		str	r4, [sp, #44]
5121:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 12550              		.loc 1 5121 0
 12551 0064 30408DE5 		str	r4, [sp, #48]
5122:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 12552              		.loc 1 5122 0
 12553 0068 34408DE5 		str	r4, [sp, #52]
5125:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 12554              		.loc 1 5125 0
 12555 006c 1C408DE5 		str	r4, [sp, #28]
5126:../uvc.c      **** 
 12556              		.loc 1 5126 0
 12557 0070 20408DE5 		str	r4, [sp, #32]
5117:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 12558              		.loc 1 5117 0
 12559 0074 10508DE5 		str	r5, [sp, #16]
5123:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 12560              		.loc 1 5123 0
 12561 0078 14508DE5 		str	r5, [sp, #20]
5124:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 12562              		.loc 1 5124 0
 12563 007c 18508DE5 		str	r5, [sp, #24]
 12564              		.loc 1 5128 0
 12565 0080 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 12566              	.LVL1456:
5129:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 12567              		.loc 1 5129 0
 12568 0084 004050E2 		subs	r4, r0, #0
 12569 0088 ECFFFF1A 		bne	.L1023
5130:../uvc.c      ****     {
5131:../uvc.c      ****         goto handle_fatal_error;
5132:../uvc.c      ****     }
5133:../uvc.c      **** 
5134:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
5135:../uvc.c      ****     CyU3PKernelEntry ();
 12570              		.loc 1 5135 0
 12571 008c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 12572              	.LVL1457:
5136:../uvc.c      **** 
5137:../uvc.c      ****     /* Dummy return to make the compiler happy */
5138:../uvc.c      ****     return 0;
5139:../uvc.c      **** 
5140:../uvc.c      **** handle_fatal_error:
5141:../uvc.c      ****     /* Cannot recover from this error. */
5142:../uvc.c      ****     while (1);
5143:../uvc.c      **** }
 12573              		.loc 1 5143 0
 12574 0090 0400A0E1 		mov	r0, r4
 12575 0094 3CD08DE2 		add	sp, sp, #60
 12576              		@ sp needed
 12577 0098 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 12578              		.cfi_endproc
 12579              	.LFE28:
 12581              		.comm	I2CCmdTimer,44,4
 12582              		.comm	posTick,4,4
 12583              		.global	glUVCHeader
 12584              		.global	glProbeStilCtrl20
 12585              		.global	glProbeCtrl20
 12586              		.global	glProbeStilCtrl
 12587              		.global	glProbeCtrlFull
 12588              		.global	glProbeCtrl
 12589              		.global	streamingStarted
 12590              		.global	clearFeatureRqtReceived
 12591              		.global	usbSpeed
 12592              		.global	isUsbConnected
 12593              		.global	pbcpbak
 12594              		.global	pbcbak
 12595              		.global	pbbak
 12596              		.global	fbbak
 12597              		.global	pbc
 12598              		.global	pb
 12599              		.global	fb
 12600              		.comm	wLength,2,2
 12601              		.comm	wIndex,2,2
 12602              		.comm	wValue,2,2
 12603              		.comm	bRequest,1,1
 12604              		.comm	bmReqType,1,1
 12605              		.comm	imgHdMux,56,4
 12606              		.comm	timMux,56,4
 12607              		.comm	staQuMux,56,4
 12608              		.comm	cmdQuMux,56,4
 12609              		.comm	statQu,32,4
 12610              		.comm	cmdQu,32,4
 12611              		.global	testSnap
 12612              		.global	snapButFlag
 12613              		.comm	glInterStaBuffer,4,4
 12614              		.comm	glChHandleInterStat,172,4
 12615              		.comm	glChHandleStillStream,232,4
 12616              		.comm	glChHandleUVCStream,232,4
 12617              		.global	CyFxGpifConfig_usb2
 12618              		.global	CyFxGpifRegValue_usb2
 12619              		.global	CyFxGpifWavedataPosition_usb2
 12620              		.global	CyFxGpifWavedata_usb2
 12621              		.global	CyFxGpifTransition_usb2
 12622              		.global	CyFxGpifConfig
 12623              		.global	CyFxGpifRegValue
 12624              		.global	CyFxGpifWavedataPosition
 12625              		.global	CyFxGpifWavedata
 12626              		.global	CyFxGpifTransition
 12627              		.section	.rodata
 12628              		.align	2
 12629              		.set	.LANCHOR2,. + 0
 12632              	ShutSp:
 12633 0000 3582     		.short	-32203
 12634 0002 1B41     		.short	16667
 12635 0004 8D20     		.short	8333
 12636 0006 A00F     		.short	4000
 12637 0008 D007     		.short	2000
 12638 000a E803     		.short	1000
 12639 000c F401     		.short	500
 12640 000e C800     		.short	200
 12641 0010 6400     		.short	100
 12642 0012 0A00     		.short	10
 12643 0014 0000     		.short	0
 12644 0016 00000000 		.space	10
 12644      00000000 
 12644      0000
 12647              	pEXTSenCtrl:
 12648 0020 20050000 		.word	EXTShutter
 12649 0024 00000000 		.word	0
 12650 0028 00000000 		.word	0
 12651 002c 00000000 		.word	0
 12652 0030 00000000 		.word	0
 12653 0034 00000000 		.word	0
 12654 0038 00000000 		.word	0
 12655 003c 00000000 		.word	0
 12656 0040 00000000 		.word	0
 12657 0044 E8050000 		.word	EXTAexModGainlev
 12658 0048 00000000 		.word	0
 12659 004c 34050000 		.word	EXTShutlev
 12660 0050 00000000 		.word	0
 12661 0054 00000000 		.word	0
 12662 0058 00000000 		.word	0
 12663 005c 00000000 		.word	0
 12664 0060 00000000 		.word	0
 12665 0064 00000000 		.word	0
 12666 0068 00000000 		.word	0
 12667 006c 00000000 		.word	0
 12668 0070 F8040000 		.word	EXTBLCWinPos
 12669 0074 0C050000 		.word	EXTBLCWeight
 12670 0078 00000000 		.word	0
 12671 007c 48050000 		.word	EXTExHyster
 12672 0080 5C050000 		.word	EXTExCtrlSped
 12673 0084 70050000 		.word	EXTEnhanceMode
 12674 0088 84050000 		.word	EXTEnhanceGain
 12675 008c 98050000 		.word	EXTEnhanceSTED
 12676 0090 AC050000 		.word	EXT2DNRGain
 12677 0094 C0050000 		.word	EXT2DNRSTED
 12678 0098 D4050000 		.word	EXTGammaCor
 12679 009c 00000000 		.word	0
 12680 00a0 00000000 		.word	0
 12681 00a4 00000000 		.space	124
 12681      00000000 
 12681      00000000 
 12681      00000000 
 12681      00000000 
 12684              	CyFxGpifConfig:
 12685 0120 0F00     		.short	15
 12686 0122 0000     		.space	2
 12687 0124 00000000 		.word	CyFxGpifWavedata
 12688 0128 00000000 		.word	CyFxGpifWavedataPosition
 12689 012c 0500     		.short	5
 12690 012e 0000     		.space	2
 12691 0130 00000000 		.word	CyFxGpifTransition
 12692 0134 4C00     		.short	76
 12693 0136 0000     		.space	2
 12694 0138 00000000 		.word	CyFxGpifRegValue
 12697              	CyFxGpifConfig_usb2:
 12698 013c 9300     		.short	147
 12699 013e 0000     		.space	2
 12700 0140 00000000 		.word	CyFxGpifWavedata_usb2
 12701 0144 00000000 		.word	CyFxGpifWavedataPosition_usb2
 12702 0148 0800     		.short	8
 12703 014a 0000     		.space	2
 12704 014c 00000000 		.word	CyFxGpifTransition_usb2
 12705 0150 4C00     		.short	76
 12706 0152 0000     		.space	2
 12707 0154 00000000 		.word	CyFxGpifRegValue_usb2
 12710              	ShutValueArry:
 12711 0158 C800     		.short	200
 12712 015a 6400     		.short	100
 12713 015c 2700     		.short	39
 12714 015e 1400     		.short	20
 12715 0160 0A00     		.short	10
 12716 0162 0500     		.short	5
 12717 0164 0200     		.short	2
 12718 0166 0100     		.short	1
 12719              		.data
 12720              		.align	2
 12721              		.set	.LANCHOR1,. + 0
 12724              	glProbeCtrlFull:
 12725 0000 00       		.byte	0
 12726 0001 00       		.byte	0
 12727 0002 01       		.byte	1
 12728 0003 01       		.byte	1
 12729 0004 15       		.byte	21
 12730 0005 16       		.byte	22
 12731 0006 05       		.byte	5
 12732 0007 00       		.byte	0
 12733 0008 00       		.byte	0
 12734 0009 00       		.byte	0
 12735 000a 00       		.byte	0
 12736 000b 00       		.byte	0
 12737 000c 00       		.byte	0
 12738 000d 00       		.byte	0
 12739 000e 00       		.byte	0
 12740 000f 00       		.byte	0
 12741 0010 00       		.byte	0
 12742 0011 00       		.byte	0
 12743 0012 00       		.byte	0
 12744 0013 C6       		.byte	-58
 12745 0014 99       		.byte	-103
 12746 0015 00       		.byte	0
 12747 0016 00       		.byte	0
 12748 0017 40       		.byte	64
 12749 0018 00       		.byte	0
 12750 0019 00       		.byte	0
 12751 001a 0000     		.space	2
 12754              	glProbeCtrl20:
 12755 001c 00       		.byte	0
 12756 001d 00       		.byte	0
 12757 001e 01       		.byte	1
 12758 001f 01       		.byte	1
 12759 0020 80       		.byte	-128
 12760 0021 1A       		.byte	26
 12761 0022 06       		.byte	6
 12762 0023 00       		.byte	0
 12763 0024 00       		.byte	0
 12764 0025 00       		.byte	0
 12765 0026 00       		.byte	0
 12766 0027 00       		.byte	0
 12767 0028 00       		.byte	0
 12768 0029 00       		.byte	0
 12769 002a 00       		.byte	0
 12770 002b 00       		.byte	0
 12771 002c 00       		.byte	0
 12772 002d 00       		.byte	0
 12773 002e 00       		.byte	0
 12774 002f D2       		.byte	-46
 12775 0030 0F       		.byte	15
 12776 0031 00       		.byte	0
 12777 0032 00       		.byte	0
 12778 0033 40       		.byte	64
 12779 0034 00       		.byte	0
 12780 0035 00       		.byte	0
 12781 0036 0000     		.space	2
 12784              	glProbeCtrl:
 12785 0038 00       		.byte	0
 12786 0039 00       		.byte	0
 12787 003a 01       		.byte	1
 12788 003b 01       		.byte	1
 12789 003c 15       		.byte	21
 12790 003d 16       		.byte	22
 12791 003e 05       		.byte	5
 12792 003f 00       		.byte	0
 12793 0040 00       		.byte	0
 12794 0041 00       		.byte	0
 12795 0042 00       		.byte	0
 12796 0043 00       		.byte	0
 12797 0044 00       		.byte	0
 12798 0045 00       		.byte	0
 12799 0046 00       		.byte	0
 12800 0047 00       		.byte	0
 12801 0048 00       		.byte	0
 12802 0049 00       		.byte	0
 12803 004a 00       		.byte	0
 12804 004b 48       		.byte	72
 12805 004c 3F       		.byte	63
 12806 004d 00       		.byte	0
 12807 004e 00       		.byte	0
 12808 004f 40       		.byte	64
 12809 0050 00       		.byte	0
 12810 0051 00       		.byte	0
 12813              	ROIMode:
 12814 0052 01       		.byte	1
 12815 0053 00       		.space	1
 12818              	glProbeStilCtrl:
 12819 0054 01       		.byte	1
 12820 0055 02       		.byte	2
 12821 0056 00       		.byte	0
 12822 0057 00       		.byte	0
 12823 0058 C6       		.byte	-58
 12824 0059 99       		.byte	-103
 12825 005a 00       		.byte	0
 12826 005b 00       		.byte	0
 12827 005c 40       		.byte	64
 12828 005d 00       		.byte	0
 12829 005e 00       		.byte	0
 12830 005f 00       		.space	1
 12833              	glProbeStilCtrl20:
 12834 0060 01       		.byte	1
 12835 0061 01       		.byte	1
 12836 0062 00       		.byte	0
 12837 0063 00       		.byte	0
 12838 0064 D2       		.byte	-46
 12839 0065 0F       		.byte	15
 12840 0066 00       		.byte	0
 12841 0067 00       		.byte	0
 12842 0068 40       		.byte	64
 12843 0069 00       		.byte	0
 12844 006a 00       		.byte	0
 12845 006b 00       		.space	1
 12848              	ExUCtrlParArry:
 12849 006c 00       		.byte	0
 12850 006d 00       		.byte	0
 12851 006e 04       		.byte	4
 12852 006f 01       		.byte	1
 12853 0070 00       		.byte	0
 12854 0071 38       		.byte	56
 12855 0072 01       		.byte	1
 12856 0073 01       		.byte	1
 12857 0074 00       		.byte	0
 12858 0075 03       		.byte	3
 12859 0076 00       		.byte	0
 12860 0077 4E       		.byte	78
 12861 0078 00       		.byte	0
 12862 0079 4E       		.byte	78
 12863 007a 00       		.byte	0
 12864 007b 30       		.byte	48
 12865 007c 01       		.byte	1
 12866 007d 00       		.byte	0
 12867 007e 00       		.byte	0
 12868 007f 00000000 		.space	5
 12868      00
 12869 0084 00       		.byte	0
 12870 0085 00       		.byte	0
 12871 0086 01       		.byte	1
 12872 0087 00       		.byte	0
 12873 0088 00       		.byte	0
 12874 0089 00       		.byte	0
 12875 008a 00       		.byte	0
 12876 008b 01       		.byte	1
 12877 008c 00       		.byte	0
 12878 008d 03       		.byte	3
 12879 008e 00       		.byte	0
 12880 008f 00       		.byte	0
 12881 0090 00       		.byte	0
 12882 0091 00       		.byte	0
 12883 0092 00       		.byte	0
 12884 0093 30       		.byte	48
 12885 0094 01       		.byte	1
 12886 0095 00       		.byte	0
 12887 0096 00       		.byte	0
 12888 0097 00000000 		.space	5
 12888      00
 12889 009c 00       		.byte	0
 12890 009d 00       		.byte	0
 12891 009e 02       		.byte	2
 12892 009f 00       		.byte	0
 12893 00a0 00       		.byte	0
 12894 00a1 FF       		.byte	-1
 12895 00a2 00       		.byte	0
 12896 00a3 01       		.byte	1
 12897 00a4 00       		.byte	0
 12898 00a5 03       		.byte	3
 12899 00a6 00       		.byte	0
 12900 00a7 01       		.byte	1
 12901 00a8 00       		.byte	0
 12902 00a9 00       		.byte	0
 12903 00aa 00       		.byte	0
 12904 00ab 30       		.byte	48
 12905 00ac 01       		.byte	1
 12906 00ad 01       		.byte	1
 12907 00ae 00       		.byte	0
 12908 00af 00000000 		.space	5
 12908      00
 12909 00b4 00       		.byte	0
 12910 00b5 00       		.byte	0
 12911 00b6 02       		.byte	2
 12912 00b7 00       		.byte	0
 12913 00b8 00       		.byte	0
 12914 00b9 00       		.byte	0
 12915 00ba 00       		.byte	0
 12916 00bb 00       		.byte	0
 12917 00bc 00       		.byte	0
 12918 00bd 03       		.byte	3
 12919 00be 00       		.byte	0
 12920 00bf 00       		.byte	0
 12921 00c0 00       		.byte	0
 12922 00c1 00       		.byte	0
 12923 00c2 00       		.byte	0
 12924 00c3 30       		.byte	48
 12925 00c4 01       		.byte	1
 12926 00c5 01       		.byte	1
 12927 00c6 00       		.byte	0
 12928 00c7 00000000 		.space	5
 12928      00
 12929 00cc 13       		.byte	19
 12930 00cd 14       		.byte	20
 12931 00ce 02       		.byte	2
 12932 00cf 00       		.byte	0
 12933 00d0 00       		.byte	0
 12934 00d1 FF       		.byte	-1
 12935 00d2 FF       		.byte	-1
 12936 00d3 01       		.byte	1
 12937 00d4 00       		.byte	0
 12938 00d5 03       		.byte	3
 12939 00d6 00       		.byte	0
 12940 00d7 66       		.byte	102
 12941 00d8 66       		.byte	102
 12942 00d9 66       		.byte	102
 12943 00da 66       		.byte	102
 12944 00db 30       		.byte	48
 12945 00dc 01       		.byte	1
 12946 00dd 00       		.byte	0
 12947 00de 00       		.byte	0
 12948 00df 00000000 		.space	5
 12948      00
 12949 00e4 11       		.byte	17
 12950 00e5 00       		.byte	0
 12951 00e6 02       		.byte	2
 12952 00e7 01       		.byte	1
 12953 00e8 00       		.byte	0
 12954 00e9 03       		.byte	3
 12955 00ea 00       		.byte	0
 12956 00eb 01       		.byte	1
 12957 00ec 00       		.byte	0
 12958 00ed 03       		.byte	3
 12959 00ee 00       		.byte	0
 12960 00ef 80       		.byte	-128
 12961 00f0 00       		.byte	0
 12962 00f1 80       		.byte	-128
 12963 00f2 00       		.byte	0
 12964 00f3 30       		.byte	48
 12965 00f4 01       		.byte	1
 12966 00f5 01       		.byte	1
 12967 00f6 00       		.byte	0
 12968 00f7 00000000 		.space	5
 12968      00
 12969 00fc 10       		.byte	16
 12970 00fd 00       		.byte	0
 12971 00fe 01       		.byte	1
 12972 00ff 01       		.byte	1
 12973 0100 00       		.byte	0
 12974 0101 02       		.byte	2
 12975 0102 00       		.byte	0
 12976 0103 01       		.byte	1
 12977 0104 00       		.byte	0
 12978 0105 03       		.byte	3
 12979 0106 00       		.byte	0
 12980 0107 00       		.byte	0
 12981 0108 00       		.byte	0
 12982 0109 00       		.byte	0
 12983 010a 00       		.byte	0
 12984 010b 30       		.byte	48
 12985 010c 01       		.byte	1
 12986 010d 01       		.byte	1
 12987 010e 00       		.byte	0
 12988 010f 00000000 		.space	5
 12988      00
 12989 0114 00       		.byte	0
 12990 0115 00       		.byte	0
 12991 0116 04       		.byte	4
 12992 0117 01       		.byte	1
 12993 0118 00       		.byte	0
 12994 0119 38       		.byte	56
 12995 011a 01       		.byte	1
 12996 011b 01       		.byte	1
 12997 011c 00       		.byte	0
 12998 011d 03       		.byte	3
 12999 011e 00       		.byte	0
 13000 011f 4E       		.byte	78
 13001 0120 00       		.byte	0
 13002 0121 4E       		.byte	78
 13003 0122 00       		.byte	0
 13004 0123 30       		.byte	48
 13005 0124 01       		.byte	1
 13006 0125 00       		.byte	0
 13007 0126 00       		.byte	0
 13008 0127 00000000 		.space	5
 13008      00
 13009 012c 00       		.byte	0
 13010 012d 00       		.byte	0
 13011 012e 01       		.byte	1
 13012 012f 00       		.byte	0
 13013 0130 00       		.byte	0
 13014 0131 00       		.byte	0
 13015 0132 00       		.byte	0
 13016 0133 01       		.byte	1
 13017 0134 00       		.byte	0
 13018 0135 03       		.byte	3
 13019 0136 00       		.byte	0
 13020 0137 00       		.byte	0
 13021 0138 00       		.byte	0
 13022 0139 00       		.byte	0
 13023 013a 00       		.byte	0
 13024 013b 30       		.byte	48
 13025 013c 01       		.byte	1
 13026 013d 00       		.byte	0
 13027 013e 00       		.byte	0
 13028 013f 00000000 		.space	5
 13028      00
 13029 0144 00       		.byte	0
 13030 0145 00       		.byte	0
 13031 0146 02       		.byte	2
 13032 0147 00       		.byte	0
 13033 0148 00       		.byte	0
 13034 0149 05       		.byte	5
 13035 014a 00       		.byte	0
 13036 014b 01       		.byte	1
 13037 014c 00       		.byte	0
 13038 014d 03       		.byte	3
 13039 014e 00       		.byte	0
 13040 014f 00       		.byte	0
 13041 0150 00       		.byte	0
 13042 0151 00       		.byte	0
 13043 0152 00       		.byte	0
 13044 0153 30       		.byte	48
 13045 0154 01       		.byte	1
 13046 0155 00       		.byte	0
 13047 0156 00       		.byte	0
 13048 0157 00000000 		.space	5
 13048      00
 13049 015c 00       		.byte	0
 13050 015d 00       		.byte	0
 13051 015e 03       		.byte	3
 13052 015f 00       		.byte	0
 13053 0160 00       		.byte	0
 13054 0161 0A       		.byte	10
 13055 0162 00       		.byte	0
 13056 0163 01       		.byte	1
 13057 0164 00       		.byte	0
 13058 0165 03       		.byte	3
 13059 0166 00       		.byte	0
 13060 0167 00       		.byte	0
 13061 0168 00       		.byte	0
 13062 0169 00       		.byte	0
 13063 016a 00       		.byte	0
 13064 016b 30       		.byte	48
 13065 016c 01       		.byte	1
 13066 016d 00       		.byte	0
 13067 016e 00       		.byte	0
 13068 016f 00000000 		.space	5
 13068      00
 13069 0174 00       		.byte	0
 13070 0175 00       		.byte	0
 13071 0176 02       		.byte	2
 13072 0177 00       		.byte	0
 13073 0178 00       		.byte	0
 13074 0179 40       		.byte	64
 13075 017a 00       		.byte	0
 13076 017b 01       		.byte	1
 13077 017c 00       		.byte	0
 13078 017d 03       		.byte	3
 13079 017e 00       		.byte	0
 13080 017f 0F       		.byte	15
 13081 0180 11       		.byte	17
 13082 0181 00       		.byte	0
 13083 0182 00       		.byte	0
 13084 0183 30       		.byte	48
 13085 0184 01       		.byte	1
 13086 0185 00       		.byte	0
 13087 0186 00       		.byte	0
 13088 0187 00000000 		.space	5
 13088      00
 13089 018c 00       		.byte	0
 13090 018d 00       		.byte	0
 13091 018e 02       		.byte	2
 13092 018f 00       		.byte	0
 13093 0190 00       		.byte	0
 13094 0191 64       		.byte	100
 13095 0192 00       		.byte	0
 13096 0193 01       		.byte	1
 13097 0194 00       		.byte	0
 13098 0195 03       		.byte	3
 13099 0196 00       		.byte	0
 13100 0197 00       		.byte	0
 13101 0198 00       		.byte	0
 13102 0199 00       		.byte	0
 13103 019a 00       		.byte	0
 13104 019b 30       		.byte	48
 13105 019c 01       		.byte	1
 13106 019d 00       		.byte	0
 13107 019e 00       		.byte	0
 13108 019f 00000000 		.space	5
 13108      00
 13109 01a4 00       		.byte	0
 13110 01a5 00       		.byte	0
 13111 01a6 02       		.byte	2
 13112 01a7 00       		.byte	0
 13113 01a8 00       		.byte	0
 13114 01a9 64       		.byte	100
 13115 01aa 00       		.byte	0
 13116 01ab 01       		.byte	1
 13117 01ac 00       		.byte	0
 13118 01ad 03       		.byte	3
 13119 01ae 00       		.byte	0
 13120 01af 00       		.byte	0
 13121 01b0 00       		.byte	0
 13122 01b1 00       		.byte	0
 13123 01b2 00       		.byte	0
 13124 01b3 30       		.byte	48
 13125 01b4 01       		.byte	1
 13126 01b5 00       		.byte	0
 13127 01b6 00       		.byte	0
 13128 01b7 00000000 		.space	5
 13128      00
 13129 01bc 00       		.byte	0
 13130 01bd 00       		.byte	0
 13131 01be 02       		.byte	2
 13132 01bf 00       		.byte	0
 13133 01c0 00       		.byte	0
 13134 01c1 64       		.byte	100
 13135 01c2 00       		.byte	0
 13136 01c3 01       		.byte	1
 13137 01c4 00       		.byte	0
 13138 01c5 03       		.byte	3
 13139 01c6 00       		.byte	0
 13140 01c7 00       		.byte	0
 13141 01c8 00       		.byte	0
 13142 01c9 00       		.byte	0
 13143 01ca 00       		.byte	0
 13144 01cb 30       		.byte	48
 13145 01cc 01       		.byte	1
 13146 01cd 00       		.byte	0
 13147 01ce 00       		.byte	0
 13148 01cf 00000000 		.space	5
 13148      00
 13149 01d4 00       		.byte	0
 13150 01d5 00       		.byte	0
 13151 01d6 02       		.byte	2
 13152 01d7 00       		.byte	0
 13153 01d8 00       		.byte	0
 13154 01d9 64       		.byte	100
 13155 01da 00       		.byte	0
 13156 01db 01       		.byte	1
 13157 01dc 00       		.byte	0
 13158 01dd 03       		.byte	3
 13159 01de 00       		.byte	0
 13160 01df 00       		.byte	0
 13161 01e0 00       		.byte	0
 13162 01e1 00       		.byte	0
 13163 01e2 00       		.byte	0
 13164 01e3 30       		.byte	48
 13165 01e4 01       		.byte	1
 13166 01e5 00       		.byte	0
 13167 01e6 00       		.byte	0
 13168 01e7 00000000 		.space	5
 13168      00
 13171              	CtrlParArry:
 13172 01ec 10       		.byte	16
 13173 01ed 10       		.byte	16
 13174 01ee 02       		.byte	2
 13175 01ef 00       		.byte	0
 13176 01f0 00       		.byte	0
 13177 01f1 03       		.byte	3
 13178 01f2 00       		.byte	0
 13179 01f3 01       		.byte	1
 13180 01f4 00       		.byte	0
 13181 01f5 03       		.byte	3
 13182 01f6 00       		.byte	0
 13183 01f7 03       		.byte	3
 13184 01f8 00       		.byte	0
 13185 01f9 03       		.byte	3
 13186 01fa 00       		.byte	0
 13187 01fb 30       		.byte	48
 13188 01fc 01       		.byte	1
 13189 01fd 00       		.byte	0
 13190 01fe 00       		.byte	0
 13191 01ff 00000000 		.space	5
 13191      00
 13192 0204 15       		.byte	21
 13193 0205 15       		.byte	21
 13194 0206 02       		.byte	2
 13195 0207 00       		.byte	0
 13196 0208 00       		.byte	0
 13197 0209 FF       		.byte	-1
 13198 020a 00       		.byte	0
 13199 020b 01       		.byte	1
 13200 020c 00       		.byte	0
 13201 020d 03       		.byte	3
 13202 020e 00       		.byte	0
 13203 020f 76       		.byte	118
 13204 0210 00       		.byte	0
 13205 0211 76       		.byte	118
 13206 0212 C7       		.byte	-57
 13207 0213 30       		.byte	48
 13208 0214 01       		.byte	1
 13209 0215 01       		.byte	1
 13210 0216 00       		.byte	0
 13211 0217 00000000 		.space	5
 13211      00
 13212 021c 04       		.byte	4
 13213 021d 04       		.byte	4
 13214 021e 02       		.byte	2
 13215 021f 00       		.byte	0
 13216 0220 00       		.byte	0
 13217 0221 FF       		.byte	-1
 13218 0222 00       		.byte	0
 13219 0223 01       		.byte	1
 13220 0224 00       		.byte	0
 13221 0225 03       		.byte	3
 13222 0226 00       		.byte	0
 13223 0227 70       		.byte	112
 13224 0228 00       		.byte	0
 13225 0229 70       		.byte	112
 13226 022a 00       		.byte	0
 13227 022b 30       		.byte	48
 13228 022c 01       		.byte	1
 13229 022d 01       		.byte	1
 13230 022e 00       		.byte	0
 13231 022f 00000000 		.space	5
 13231      00
 13232 0234 00       		.byte	0
 13233 0235 00       		.byte	0
 13234 0236 02       		.byte	2
 13235 0237 00       		.byte	0
 13236 0238 00       		.byte	0
 13237 0239 64       		.byte	100
 13238 023a 00       		.byte	0
 13239 023b 01       		.byte	1
 13240 023c 00       		.byte	0
 13241 023d 03       		.byte	3
 13242 023e 00       		.byte	0
 13243 023f 00       		.byte	0
 13244 0240 00       		.byte	0
 13245 0241 00       		.byte	0
 13246 0242 00       		.byte	0
 13247 0243 30       		.byte	48
 13248 0244 01       		.byte	1
 13249 0245 00       		.byte	0
 13250 0246 00       		.byte	0
 13251 0247 00000000 		.space	5
 13251      00
 13252 024c 07       		.byte	7
 13253 024d 07       		.byte	7
 13254 024e 02       		.byte	2
 13255 024f 00       		.byte	0
 13256 0250 00       		.byte	0
 13257 0251 01       		.byte	1
 13258 0252 00       		.byte	0
 13259 0253 01       		.byte	1
 13260 0254 00       		.byte	0
 13261 0255 03       		.byte	3
 13262 0256 00       		.byte	0
 13263 0257 01       		.byte	1
 13264 0258 00       		.byte	0
 13265 0259 01       		.byte	1
 13266 025a 00       		.byte	0
 13267 025b 30       		.byte	48
 13268 025c 01       		.byte	1
 13269 025d 00       		.byte	0
 13270 025e 00       		.byte	0
 13271 025f 00000000 		.space	5
 13271      00
 13272 0264 DF       		.byte	-33
 13273 0265 E1       		.byte	-31
 13274 0266 02       		.byte	2
 13275 0267 00       		.byte	0
 13276 0268 00       		.byte	0
 13277 0269 FF       		.byte	-1
 13278 026a 00       		.byte	0
 13279 026b 01       		.byte	1
 13280 026c 00       		.byte	0
 13281 026d 03       		.byte	3
 13282 026e 00       		.byte	0
 13283 026f 80       		.byte	-128
 13284 0270 00       		.byte	0
 13285 0271 00       		.byte	0
 13286 0272 00       		.byte	0
 13287 0273 C6       		.byte	-58
 13288 0274 01       		.byte	1
 13289 0275 01       		.byte	1
 13290 0276 00       		.byte	0
 13291 0277 00000000 		.space	5
 13291      00
 13292 027c 85       		.byte	-123
 13293 027d 86       		.byte	-122
 13294 027e 02       		.byte	2
 13295 027f 00       		.byte	0
 13296 0280 00       		.byte	0
 13297 0281 64       		.byte	100
 13298 0282 00       		.byte	0
 13299 0283 01       		.byte	1
 13300 0284 00       		.byte	0
 13301 0285 03       		.byte	3
 13302 0286 00       		.byte	0
 13303 0287 32       		.byte	50
 13304 0288 00       		.byte	0
 13305 0289 32       		.byte	50
 13306 028a 00       		.byte	0
 13307 028b F2       		.byte	-14
 13308 028c 01       		.byte	1
 13309 028d 01       		.byte	1
 13310 028e 00       		.byte	0
 13311 028f 00000000 		.space	5
 13311      00
 13312 0294 06       		.byte	6
 13313 0295 06       		.byte	6
 13314 0296 02       		.byte	2
 13315 0297 00       		.byte	0
 13316 0298 00       		.byte	0
 13317 0299 FF       		.byte	-1
 13318 029a 00       		.byte	0
 13319 029b 01       		.byte	1
 13320 029c 00       		.byte	0
 13321 029d 03       		.byte	3
 13322 029e 00       		.byte	0
 13323 029f 20       		.byte	32
 13324 02a0 00       		.byte	0
 13325 02a1 20       		.byte	32
 13326 02a2 00       		.byte	0
 13327 02a3 30       		.byte	48
 13328 02a4 01       		.byte	1
 13329 02a5 01       		.byte	1
 13330 02a6 00       		.byte	0
 13331 02a7 00000000 		.space	5
 13331      00
 13332 02ac 00       		.byte	0
 13333 02ad 00       		.byte	0
 13334 02ae 02       		.byte	2
 13335 02af 00       		.byte	0
 13336 02b0 00       		.byte	0
 13337 02b1 64       		.byte	100
 13338 02b2 00       		.byte	0
 13339 02b3 01       		.byte	1
 13340 02b4 00       		.byte	0
 13341 02b5 03       		.byte	3
 13342 02b6 00       		.byte	0
 13343 02b7 00       		.byte	0
 13344 02b8 00       		.byte	0
 13345 02b9 00       		.byte	0
 13346 02ba 00       		.byte	0
 13347 02bb 30       		.byte	48
 13348 02bc 01       		.byte	1
 13349 02bd 00       		.byte	0
 13350 02be 00       		.byte	0
 13351 02bf 00000000 		.space	5
 13351      00
 13352 02c4 08       		.byte	8
 13353 02c5 08       		.byte	8
 13354 02c6 02       		.byte	2
 13355 02c7 00       		.byte	0
 13356 02c8 00       		.byte	0
 13357 02c9 05       		.byte	5
 13358 02ca 00       		.byte	0
 13359 02cb 01       		.byte	1
 13360 02cc 00       		.byte	0
 13361 02cd 03       		.byte	3
 13362 02ce 00       		.byte	0
 13363 02cf 00       		.byte	0
 13364 02d0 00       		.byte	0
 13365 02d1 00       		.byte	0
 13366 02d2 00       		.byte	0
 13367 02d3 30       		.byte	48
 13368 02d4 01       		.byte	1
 13369 02d5 00       		.byte	0
 13370 02d6 00       		.byte	0
 13371 02d7 00000000 		.space	5
 13371      00
 13372 02dc 00       		.byte	0
 13373 02dd 00       		.byte	0
 13374 02de 02       		.byte	2
 13375 02df 00       		.byte	0
 13376 02e0 00       		.byte	0
 13377 02e1 40       		.byte	64
 13378 02e2 00       		.byte	0
 13379 02e3 01       		.byte	1
 13380 02e4 00       		.byte	0
 13381 02e5 03       		.byte	3
 13382 02e6 00       		.byte	0
 13383 02e7 00       		.byte	0
 13384 02e8 00       		.byte	0
 13385 02e9 00       		.byte	0
 13386 02ea 00       		.byte	0
 13387 02eb 30       		.byte	48
 13388 02ec 01       		.byte	1
 13389 02ed 00       		.byte	0
 13390 02ee 00       		.byte	0
 13391 02ef 00000000 		.space	5
 13391      00
 13392 02f4 09       		.byte	9
 13393 02f5 0A       		.byte	10
 13394 02f6 04       		.byte	4
 13395 02f7 00       		.byte	0
 13396 02f8 00       		.byte	0
 13397 02f9 40       		.byte	64
 13398 02fa 00       		.byte	0
 13399 02fb 01       		.byte	1
 13400 02fc 00       		.byte	0
 13401 02fd 03       		.byte	3
 13402 02fe 00       		.byte	0
 13403 02ff 20       		.byte	32
 13404 0300 38       		.byte	56
 13405 0301 20       		.byte	32
 13406 0302 38       		.byte	56
 13407 0303 30       		.byte	48
 13408 0304 01       		.byte	1
 13409 0305 00       		.byte	0
 13410 0306 00       		.byte	0
 13411 0307 00000000 		.space	5
 13411      00
 13412 030c 00       		.byte	0
 13413 030d 00       		.byte	0
 13414 030e 02       		.byte	2
 13415 030f 00       		.byte	0
 13416 0310 00       		.byte	0
 13417 0311 64       		.byte	100
 13418 0312 00       		.byte	0
 13419 0313 01       		.byte	1
 13420 0314 00       		.byte	0
 13421 0315 03       		.byte	3
 13422 0316 00       		.byte	0
 13423 0317 00       		.byte	0
 13424 0318 00       		.byte	0
 13425 0319 00       		.byte	0
 13426 031a 00       		.byte	0
 13427 031b 30       		.byte	48
 13428 031c 01       		.byte	1
 13429 031d 00       		.byte	0
 13430 031e 00       		.byte	0
 13431 031f 00000000 		.space	5
 13431      00
 13432 0324 00       		.byte	0
 13433 0325 00       		.byte	0
 13434 0326 02       		.byte	2
 13435 0327 00       		.byte	0
 13436 0328 00       		.byte	0
 13437 0329 64       		.byte	100
 13438 032a 00       		.byte	0
 13439 032b 01       		.byte	1
 13440 032c 00       		.byte	0
 13441 032d 03       		.byte	3
 13442 032e 00       		.byte	0
 13443 032f 00       		.byte	0
 13444 0330 00       		.byte	0
 13445 0331 00       		.byte	0
 13446 0332 00       		.byte	0
 13447 0333 30       		.byte	48
 13448 0334 01       		.byte	1
 13449 0335 00       		.byte	0
 13450 0336 00       		.byte	0
 13451 0337 00000000 		.space	5
 13451      00
 13452 033c 2A       		.byte	42
 13453 033d 2A       		.byte	42
 13454 033e 02       		.byte	2
 13455 033f 00       		.byte	0
 13456 0340 00       		.byte	0
 13457 0341 1B       		.byte	27
 13458 0342 00       		.byte	0
 13459 0343 01       		.byte	1
 13460 0344 00       		.byte	0
 13461 0345 03       		.byte	3
 13462 0346 00       		.byte	0
 13463 0347 00       		.byte	0
 13464 0348 00       		.byte	0
 13465 0349 00       		.byte	0
 13466 034a 00       		.byte	0
 13467 034b 30       		.byte	48
 13468 034c 01       		.byte	1
 13469 034d 00       		.byte	0
 13470 034e 00       		.byte	0
 13471 034f 00000000 		.space	5
 13471      00
 13472 0354 00       		.byte	0
 13473 0355 00       		.byte	0
 13474 0356 02       		.byte	2
 13475 0357 00       		.byte	0
 13476 0358 00       		.byte	0
 13477 0359 64       		.byte	100
 13478 035a 00       		.byte	0
 13479 035b 01       		.byte	1
 13480 035c 00       		.byte	0
 13481 035d 03       		.byte	3
 13482 035e 00       		.byte	0
 13483 035f 00       		.byte	0
 13484 0360 00       		.byte	0
 13485 0361 00       		.byte	0
 13486 0362 00       		.byte	0
 13487 0363 30       		.byte	48
 13488 0364 01       		.byte	1
 13489 0365 00       		.byte	0
 13490 0366 00       		.byte	0
 13491 0367 00000000 		.space	5
 13491      00
 13492 036c 00       		.byte	0
 13493 036d 00       		.byte	0
 13494 036e 02       		.byte	2
 13495 036f 00       		.byte	0
 13496 0370 00       		.byte	0
 13497 0371 12       		.byte	18
 13498 0372 00       		.byte	0
 13499 0373 01       		.byte	1
 13500 0374 00       		.byte	0
 13501 0375 03       		.byte	3
 13502 0376 00       		.byte	0
 13503 0377 00       		.byte	0
 13504 0378 00       		.byte	0
 13505 0379 00       		.byte	0
 13506 037a 00       		.byte	0
 13507 037b 30       		.byte	48
 13508 037c 01       		.byte	1
 13509 037d 00       		.byte	0
 13510 037e 00       		.byte	0
 13511 037f 00000000 		.space	5
 13511      00
 13512 0384 01       		.byte	1
 13513 0385 01       		.byte	1
 13514 0386 02       		.byte	2
 13515 0387 00       		.byte	0
 13516 0388 00       		.byte	0
 13517 0389 09       		.byte	9
 13518 038a 00       		.byte	0
 13519 038b 01       		.byte	1
 13520 038c 00       		.byte	0
 13521 038d 03       		.byte	3
 13522 038e 00       		.byte	0
 13523 038f 00       		.byte	0
 13524 0390 00       		.byte	0
 13525 0391 01       		.byte	1
 13526 0392 00       		.byte	0
 13527 0393 30       		.byte	48
 13528 0394 01       		.byte	1
 13529 0395 00       		.byte	0
 13530 0396 00       		.byte	0
 13531 0397 00000000 		.space	5
 13531      00
 13532 039c 05       		.byte	5
 13533 039d 05       		.byte	5
 13534 039e 02       		.byte	2
 13535 039f 00       		.byte	0
 13536 03a0 00       		.byte	0
 13537 03a1 03       		.byte	3
 13538 03a2 00       		.byte	0
 13539 03a3 01       		.byte	1
 13540 03a4 00       		.byte	0
 13541 03a5 03       		.byte	3
 13542 03a6 00       		.byte	0
 13543 03a7 00       		.byte	0
 13544 03a8 00       		.byte	0
 13545 03a9 00       		.byte	0
 13546 03aa 00       		.byte	0
 13547 03ab 30       		.byte	48
 13548 03ac 01       		.byte	1
 13549 03ad 00       		.byte	0
 13550 03ae 00       		.byte	0
 13551 03af 00000000 		.space	5
 13551      00
 13552 03b4 18       		.byte	24
 13553 03b5 18       		.byte	24
 13554 03b6 02       		.byte	2
 13555 03b7 00       		.byte	0
 13556 03b8 00       		.byte	0
 13557 03b9 01       		.byte	1
 13558 03ba 00       		.byte	0
 13559 03bb 01       		.byte	1
 13560 03bc 00       		.byte	0
 13561 03bd 03       		.byte	3
 13562 03be 00       		.byte	0
 13563 03bf 00       		.byte	0
 13564 03c0 00       		.byte	0
 13565 03c1 00       		.byte	0
 13566 03c2 00       		.byte	0
 13567 03c3 30       		.byte	48
 13568 03c4 01       		.byte	1
 13569 03c5 00       		.byte	0
 13570 03c6 00       		.byte	0
 13571 03c7 00000000 		.space	5
 13571      00
 13572 03cc 19       		.byte	25
 13573 03cd 19       		.byte	25
 13574 03ce 01       		.byte	1
 13575 03cf 00       		.byte	0
 13576 03d0 00       		.byte	0
 13577 03d1 40       		.byte	64
 13578 03d2 00       		.byte	0
 13579 03d3 01       		.byte	1
 13580 03d4 00       		.byte	0
 13581 03d5 03       		.byte	3
 13582 03d6 00       		.byte	0
 13583 03d7 20       		.byte	32
 13584 03d8 00       		.byte	0
 13585 03d9 20       		.byte	32
 13586 03da 00       		.byte	0
 13587 03db 30       		.byte	48
 13588 03dc 01       		.byte	1
 13589 03dd 00       		.byte	0
 13590 03de 00       		.byte	0
 13591 03df 00000000 		.space	5
 13591      00
 13592 03e4 20       		.byte	32
 13593 03e5 20       		.byte	32
 13594 03e6 02       		.byte	2
 13595 03e7 00       		.byte	0
 13596 03e8 00       		.byte	0
 13597 03e9 02       		.byte	2
 13598 03ea 00       		.byte	0
 13599 03eb 01       		.byte	1
 13600 03ec 00       		.byte	0
 13601 03ed 03       		.byte	3
 13602 03ee 00       		.byte	0
 13603 03ef 00       		.byte	0
 13604 03f0 00       		.byte	0
 13605 03f1 00       		.byte	0
 13606 03f2 00       		.byte	0
 13607 03f3 30       		.byte	48
 13608 03f4 01       		.byte	1
 13609 03f5 00       		.byte	0
 13610 03f6 00       		.byte	0
 13611 03f7 00000000 		.space	5
 13611      00
 13612 03fc 22       		.byte	34
 13613 03fd 22       		.byte	34
 13614 03fe 02       		.byte	2
 13615 03ff 00       		.byte	0
 13616 0400 00       		.byte	0
 13617 0401 3F       		.byte	63
 13618 0402 00       		.byte	0
 13619 0403 01       		.byte	1
 13620 0404 00       		.byte	0
 13621 0405 03       		.byte	3
 13622 0406 00       		.byte	0
 13623 0407 00       		.byte	0
 13624 0408 00       		.byte	0
 13625 0409 00       		.byte	0
 13626 040a 00       		.byte	0
 13627 040b 30       		.byte	48
 13628 040c 01       		.byte	1
 13629 040d 00       		.byte	0
 13630 040e 00       		.byte	0
 13631 040f 00000000 		.space	5
 13631      00
 13632 0414 23       		.byte	35
 13633 0415 23       		.byte	35
 13634 0416 02       		.byte	2
 13635 0417 00       		.byte	0
 13636 0418 00       		.byte	0
 13637 0419 64       		.byte	100
 13638 041a 00       		.byte	0
 13639 041b 01       		.byte	1
 13640 041c 00       		.byte	0
 13641 041d 03       		.byte	3
 13642 041e 00       		.byte	0
 13643 041f 10       		.byte	16
 13644 0420 00       		.byte	0
 13645 0421 10       		.byte	16
 13646 0422 00       		.byte	0
 13647 0423 30       		.byte	48
 13648 0424 01       		.byte	1
 13649 0425 00       		.byte	0
 13650 0426 00       		.byte	0
 13651 0427 00000000 		.space	5
 13651      00
 13652 042c 24       		.byte	36
 13653 042d 24       		.byte	36
 13654 042e 02       		.byte	2
 13655 042f 00       		.byte	0
 13656 0430 00       		.byte	0
 13657 0431 64       		.byte	100
 13658 0432 00       		.byte	0
 13659 0433 01       		.byte	1
 13660 0434 00       		.byte	0
 13661 0435 03       		.byte	3
 13662 0436 00       		.byte	0
 13663 0437 10       		.byte	16
 13664 0438 00       		.byte	0
 13665 0439 10       		.byte	16
 13666 043a 00       		.byte	0
 13667 043b 30       		.byte	48
 13668 043c 01       		.byte	1
 13669 043d 00       		.byte	0
 13670 043e 00       		.byte	0
 13671 043f 00000000 		.space	5
 13671      00
 13672 0444 02       		.byte	2
 13673 0445 03       		.byte	3
 13674 0446 04       		.byte	4
 13675 0447 00       		.byte	0
 13676 0448 00       		.byte	0
 13677 0449 7F       		.byte	127
 13678 044a 00       		.byte	0
 13679 044b 01       		.byte	1
 13680 044c 00       		.byte	0
 13681 044d 03       		.byte	3
 13682 044e 00       		.byte	0
 13683 044f 00       		.byte	0
 13684 0450 20       		.byte	32
 13685 0451 00       		.byte	0
 13686 0452 20       		.byte	32
 13687 0453 30       		.byte	48
 13688 0454 01       		.byte	1
 13689 0455 00       		.byte	0
 13690 0456 00       		.byte	0
 13691 0457 00000000 		.space	5
 13691      00
 13692 045c 04       		.byte	4
 13693 045d 04       		.byte	4
 13694 045e 02       		.byte	2
 13695 045f 00       		.byte	0
 13696 0460 00       		.byte	0
 13697 0461 FF       		.byte	-1
 13698 0462 00       		.byte	0
 13699 0463 01       		.byte	1
 13700 0464 00       		.byte	0
 13701 0465 03       		.byte	3
 13702 0466 00       		.byte	0
 13703 0467 60       		.byte	96
 13704 0468 00       		.byte	0
 13705 0469 60       		.byte	96
 13706 046a 00       		.byte	0
 13707 046b 30       		.byte	48
 13708 046c 01       		.byte	1
 13709 046d 00       		.byte	0
 13710 046e 00       		.byte	0
 13711 046f 00000000 		.space	5
 13711      00
 13712 0474 00       		.byte	0
 13713 0475 00       		.byte	0
 13714 0476 02       		.byte	2
 13715 0477 00       		.byte	0
 13716 0478 00       		.byte	0
 13717 0479 19       		.byte	25
 13718 047a 00       		.byte	0
 13719 047b 01       		.byte	1
 13720 047c 00       		.byte	0
 13721 047d 03       		.byte	3
 13722 047e 00       		.byte	0
 13723 047f 00       		.byte	0
 13724 0480 00       		.byte	0
 13725 0481 00       		.byte	0
 13726 0482 00       		.byte	0
 13727 0483 30       		.byte	48
 13728 0484 01       		.byte	1
 13729 0485 00       		.byte	0
 13730 0486 00       		.byte	0
 13731 0487 00000000 		.space	5
 13731      00
 13732 048c 10       		.byte	16
 13733 048d 10       		.byte	16
 13734 048e 02       		.byte	2
 13735 048f 00       		.byte	0
 13736 0490 00       		.byte	0
 13737 0491 06       		.byte	6
 13738 0492 00       		.byte	0
 13739 0493 01       		.byte	1
 13740 0494 00       		.byte	0
 13741 0495 03       		.byte	3
 13742 0496 00       		.byte	0
 13743 0497 03       		.byte	3
 13744 0498 00       		.byte	0
 13745 0499 03       		.byte	3
 13746 049a 00       		.byte	0
 13747 049b 30       		.byte	48
 13748 049c 01       		.byte	1
 13749 049d 00       		.byte	0
 13750 049e 00       		.byte	0
 13751 049f 00000000 		.space	5
 13751      00
 13752 04a4 00       		.byte	0
 13753 04a5 00       		.byte	0
 13754 04a6 02       		.byte	2
 13755 04a7 00       		.byte	0
 13756 04a8 00       		.byte	0
 13757 04a9 03       		.byte	3
 13758 04aa 00       		.byte	0
 13759 04ab 01       		.byte	1
 13760 04ac 00       		.byte	0
 13761 04ad 03       		.byte	3
 13762 04ae 00       		.byte	0
 13763 04af 00       		.byte	0
 13764 04b0 00       		.byte	0
 13765 04b1 00       		.byte	0
 13766 04b2 00       		.byte	0
 13767 04b3 30       		.byte	48
 13768 04b4 01       		.byte	1
 13769 04b5 00       		.byte	0
 13770 04b6 00       		.byte	0
 13771 04b7 00000000 		.space	5
 13771      00
 13772 04bc 50       		.byte	80
 13773 04bd 50       		.byte	80
 13774 04be 01       		.byte	1
 13775 04bf 00       		.byte	0
 13776 04c0 00       		.byte	0
 13777 04c1 03       		.byte	3
 13778 04c2 00       		.byte	0
 13779 04c3 01       		.byte	1
 13780 04c4 00       		.byte	0
 13781 04c5 03       		.byte	3
 13782 04c6 00       		.byte	0
 13783 04c7 00       		.byte	0
 13784 04c8 00       		.byte	0
 13785 04c9 00       		.byte	0
 13786 04ca 00       		.byte	0
 13787 04cb 30       		.byte	48
 13788 04cc 01       		.byte	1
 13789 04cd 00       		.byte	0
 13790 04ce 00       		.byte	0
 13791 04cf 00000000 		.space	5
 13791      00
 13792 04d4 00       		.byte	0
 13793 04d5 00       		.byte	0
 13794 04d6 0B       		.byte	11
 13795 04d7 00       		.byte	0
 13796 04d8 00       		.byte	0
 13797 04d9 FF       		.byte	-1
 13798 04da FF       		.byte	-1
 13799 04db 01       		.byte	1
 13800 04dc 00       		.byte	0
 13801 04dd 03       		.byte	3
 13802 04de 00       		.byte	0
 13803 04df 00       		.byte	0
 13804 04e0 00       		.byte	0
 13805 04e1 00       		.byte	0
 13806 04e2 00       		.byte	0
 13807 04e3 00       		.byte	0
 13808 04e4 01       		.byte	1
 13809 04e5 00       		.byte	0
 13810 04e6 00       		.byte	0
 13811 04e7 00000000 		.space	5
 13811      00
 13814              	glUVCHeader:
 13815 04ec 0C       		.byte	12
 13816 04ed 8C       		.byte	-116
 13817 04ee 00       		.byte	0
 13818 04ef 00       		.byte	0
 13819 04f0 00       		.byte	0
 13820 04f1 00       		.byte	0
 13821 04f2 00       		.byte	0
 13822 04f3 00       		.byte	0
 13823 04f4 00       		.byte	0
 13824 04f5 00       		.byte	0
 13825 04f6 00       		.byte	0
 13826 04f7 00       		.byte	0
 13829              	EXTBLCWinPos:
 13830 04f8 14       		.byte	20
 13831 04f9 13       		.byte	19
 13832 04fa 02       		.byte	2
 13833 04fb 00       		.byte	0
 13834 04fc 00       		.byte	0
 13835 04fd FF       		.byte	-1
 13836 04fe FF       		.byte	-1
 13837 04ff 01       		.byte	1
 13838 0500 00       		.byte	0
 13839 0501 03       		.byte	3
 13840 0502 00       		.byte	0
 13841 0503 66       		.byte	102
 13842 0504 66       		.byte	102
 13843 0505 66       		.byte	102
 13844 0506 66       		.byte	102
 13845 0507 30       		.byte	48
 13846 0508 01       		.byte	1
 13847 0509 00       		.byte	0
 13848 050a 0000     		.space	2
 13851              	EXTBLCWeight:
 13852 050c 11       		.byte	17
 13853 050d 11       		.byte	17
 13854 050e 02       		.byte	2
 13855 050f 00       		.byte	0
 13856 0510 00       		.byte	0
 13857 0511 FF       		.byte	-1
 13858 0512 00       		.byte	0
 13859 0513 01       		.byte	1
 13860 0514 00       		.byte	0
 13861 0515 03       		.byte	3
 13862 0516 00       		.byte	0
 13863 0517 80       		.byte	-128
 13864 0518 00       		.byte	0
 13865 0519 80       		.byte	-128
 13866 051a 00       		.byte	0
 13867 051b 30       		.byte	48
 13868 051c 01       		.byte	1
 13869 051d 00       		.byte	0
 13870 051e 0000     		.space	2
 13873              	EXTShutter:
 13874 0520 00       		.byte	0
 13875 0521 02       		.byte	2
 13876 0522 02       		.byte	2
 13877 0523 00       		.byte	0
 13878 0524 00       		.byte	0
 13879 0525 08       		.byte	8
 13880 0526 00       		.byte	0
 13881 0527 01       		.byte	1
 13882 0528 00       		.byte	0
 13883 0529 03       		.byte	3
 13884 052a 00       		.byte	0
 13885 052b 00       		.byte	0
 13886 052c 00       		.byte	0
 13887 052d 00       		.byte	0
 13888 052e 00       		.byte	0
 13889 052f 30       		.byte	48
 13890 0530 01       		.byte	1
 13891 0531 00       		.byte	0
 13892 0532 0000     		.space	2
 13895              	EXTShutlev:
 13896 0534 02       		.byte	2
 13897 0535 12       		.byte	18
 13898 0536 02       		.byte	2
 13899 0537 00       		.byte	0
 13900 0538 00       		.byte	0
 13901 0539 FF       		.byte	-1
 13902 053a 7F       		.byte	127
 13903 053b 01       		.byte	1
 13904 053c 00       		.byte	0
 13905 053d 03       		.byte	3
 13906 053e 00       		.byte	0
 13907 053f 3F       		.byte	63
 13908 0540 00       		.byte	0
 13909 0541 3F       		.byte	63
 13910 0542 00       		.byte	0
 13911 0543 30       		.byte	48
 13912 0544 01       		.byte	1
 13913 0545 00       		.byte	0
 13914 0546 0000     		.space	2
 13917              	EXTExHyster:
 13918 0548 0B       		.byte	11
 13919 0549 0B       		.byte	11
 13920 054a 02       		.byte	2
 13921 054b 00       		.byte	0
 13922 054c 00       		.byte	0
 13923 054d FF       		.byte	-1
 13924 054e 00       		.byte	0
 13925 054f 01       		.byte	1
 13926 0550 00       		.byte	0
 13927 0551 03       		.byte	3
 13928 0552 00       		.byte	0
 13929 0553 80       		.byte	-128
 13930 0554 00       		.byte	0
 13931 0555 80       		.byte	-128
 13932 0556 00       		.byte	0
 13933 0557 30       		.byte	48
 13934 0558 01       		.byte	1
 13935 0559 00       		.byte	0
 13936 055a 0000     		.space	2
 13939              	EXTExCtrlSped:
 13940 055c 02       		.byte	2
 13941 055d 02       		.byte	2
 13942 055e 02       		.byte	2
 13943 055f 00       		.byte	0
 13944 0560 00       		.byte	0
 13945 0561 FF       		.byte	-1
 13946 0562 00       		.byte	0
 13947 0563 01       		.byte	1
 13948 0564 00       		.byte	0
 13949 0565 03       		.byte	3
 13950 0566 00       		.byte	0
 13951 0567 80       		.byte	-128
 13952 0568 00       		.byte	0
 13953 0569 80       		.byte	-128
 13954 056a 00       		.byte	0
 13955 056b 30       		.byte	48
 13956 056c 01       		.byte	1
 13957 056d 00       		.byte	0
 13958 056e 0000     		.space	2
 13961              	EXTEnhanceMode:
 13962 0570 06       		.byte	6
 13963 0571 06       		.byte	6
 13964 0572 02       		.byte	2
 13965 0573 00       		.byte	0
 13966 0574 00       		.byte	0
 13967 0575 FF       		.byte	-1
 13968 0576 00       		.byte	0
 13969 0577 01       		.byte	1
 13970 0578 00       		.byte	0
 13971 0579 03       		.byte	3
 13972 057a 00       		.byte	0
 13973 057b 80       		.byte	-128
 13974 057c 00       		.byte	0
 13975 057d 80       		.byte	-128
 13976 057e 00       		.byte	0
 13977 057f 30       		.byte	48
 13978 0580 01       		.byte	1
 13979 0581 00       		.byte	0
 13980 0582 0000     		.space	2
 13983              	EXTEnhanceGain:
 13984 0584 07       		.byte	7
 13985 0585 07       		.byte	7
 13986 0586 02       		.byte	2
 13987 0587 00       		.byte	0
 13988 0588 00       		.byte	0
 13989 0589 FF       		.byte	-1
 13990 058a 00       		.byte	0
 13991 058b 01       		.byte	1
 13992 058c 00       		.byte	0
 13993 058d 03       		.byte	3
 13994 058e 00       		.byte	0
 13995 058f 80       		.byte	-128
 13996 0590 00       		.byte	0
 13997 0591 80       		.byte	-128
 13998 0592 00       		.byte	0
 13999 0593 30       		.byte	48
 14000 0594 01       		.byte	1
 14001 0595 00       		.byte	0
 14002 0596 0000     		.space	2
 14005              	EXTEnhanceSTED:
 14006 0598 08       		.byte	8
 14007 0599 09       		.byte	9
 14008 059a 04       		.byte	4
 14009 059b 00       		.byte	0
 14010 059c 00       		.byte	0
 14011 059d FF       		.byte	-1
 14012 059e 00       		.byte	0
 14013 059f 01       		.byte	1
 14014 05a0 00       		.byte	0
 14015 05a1 03       		.byte	3
 14016 05a2 00       		.byte	0
 14017 05a3 80       		.byte	-128
 14018 05a4 00       		.byte	0
 14019 05a5 80       		.byte	-128
 14020 05a6 00       		.byte	0
 14021 05a7 30       		.byte	48
 14022 05a8 01       		.byte	1
 14023 05a9 00       		.byte	0
 14024 05aa 0000     		.space	2
 14027              	EXT2DNRGain:
 14028 05ac 18       		.byte	24
 14029 05ad 19       		.byte	25
 14030 05ae 04       		.byte	4
 14031 05af 00       		.byte	0
 14032 05b0 00       		.byte	0
 14033 05b1 FF       		.byte	-1
 14034 05b2 00       		.byte	0
 14035 05b3 01       		.byte	1
 14036 05b4 00       		.byte	0
 14037 05b5 03       		.byte	3
 14038 05b6 00       		.byte	0
 14039 05b7 80       		.byte	-128
 14040 05b8 00       		.byte	0
 14041 05b9 80       		.byte	-128
 14042 05ba 00       		.byte	0
 14043 05bb 30       		.byte	48
 14044 05bc 01       		.byte	1
 14045 05bd 00       		.byte	0
 14046 05be 0000     		.space	2
 14049              	EXT2DNRSTED:
 14050 05c0 1A       		.byte	26
 14051 05c1 1B       		.byte	27
 14052 05c2 04       		.byte	4
 14053 05c3 00       		.byte	0
 14054 05c4 00       		.byte	0
 14055 05c5 FF       		.byte	-1
 14056 05c6 00       		.byte	0
 14057 05c7 01       		.byte	1
 14058 05c8 00       		.byte	0
 14059 05c9 03       		.byte	3
 14060 05ca 00       		.byte	0
 14061 05cb 80       		.byte	-128
 14062 05cc 00       		.byte	0
 14063 05cd 80       		.byte	-128
 14064 05ce 00       		.byte	0
 14065 05cf 30       		.byte	48
 14066 05d0 01       		.byte	1
 14067 05d1 00       		.byte	0
 14068 05d2 0000     		.space	2
 14071              	EXTGammaCor:
 14072 05d4 17       		.byte	23
 14073 05d5 17       		.byte	23
 14074 05d6 02       		.byte	2
 14075 05d7 00       		.byte	0
 14076 05d8 00       		.byte	0
 14077 05d9 FF       		.byte	-1
 14078 05da 00       		.byte	0
 14079 05db 01       		.byte	1
 14080 05dc 00       		.byte	0
 14081 05dd 03       		.byte	3
 14082 05de 00       		.byte	0
 14083 05df 80       		.byte	-128
 14084 05e0 00       		.byte	0
 14085 05e1 80       		.byte	-128
 14086 05e2 00       		.byte	0
 14087 05e3 30       		.byte	48
 14088 05e4 01       		.byte	1
 14089 05e5 00       		.byte	0
 14090 05e6 0000     		.space	2
 14093              	EXTAexModGainlev:
 14094 05e8 00       		.byte	0
 14095 05e9 03       		.byte	3
 14096 05ea 04       		.byte	4
 14097 05eb 00       		.byte	0
 14098 05ec 00       		.byte	0
 14099 05ed 03       		.byte	3
 14100 05ee 7F       		.byte	127
 14101 05ef 01       		.byte	1
 14102 05f0 00       		.byte	0
 14103 05f1 03       		.byte	3
 14104 05f2 00       		.byte	0
 14105 05f3 00       		.byte	0
 14106 05f4 3F       		.byte	63
 14107 05f5 00       		.byte	0
 14108 05f6 3F       		.byte	63
 14109 05f7 30       		.byte	48
 14110 05f8 01       		.byte	1
 14111 05f9 00       		.byte	0
 14112 05fa 0000     		.space	2
 14115              	WBMenuCmpArry:
 14116 05fc 20       		.byte	32
 14117 05fd 0F       		.byte	15
 14118 05fe 38       		.byte	56
 14119 05ff F0       		.byte	-16
 14122              	PUCBLC:
 14123 0600 10       		.byte	16
 14124 0601 11       		.byte	17
 14125 0602 02       		.byte	2
 14126 0603 00       		.byte	0
 14127 0604 00       		.byte	0
 14128 0605 03       		.byte	3
 14129 0606 00       		.byte	0
 14130 0607 01       		.byte	1
 14131 0608 00       		.byte	0
 14132 0609 03       		.byte	3
 14133 060a 00       		.byte	0
 14134 060b 03       		.byte	3
 14135 060c 00       		.byte	0
 14136 060d 03       		.byte	3
 14137 060e 00       		.byte	0
 14138 060f 30       		.byte	48
 14139 0610 01       		.byte	1
 14140 0611 00       		.byte	0
 14141 0612 0000     		.space	2
 14144              	PUCSharp:
 14145 0614 06       		.byte	6
 14146 0615 07       		.byte	7
 14147 0616 02       		.byte	2
 14148 0617 00       		.byte	0
 14149 0618 00       		.byte	0
 14150 0619 08       		.byte	8
 14151 061a 00       		.byte	0
 14152 061b 01       		.byte	1
 14153 061c 00       		.byte	0
 14154 061d 03       		.byte	3
 14155 061e 00       		.byte	0
 14156 061f 00       		.byte	0
 14157 0620 00       		.byte	0
 14158 0621 00       		.byte	0
 14159 0622 00       		.byte	0
 14160 0623 30       		.byte	48
 14161 0624 01       		.byte	1
 14162 0625 00       		.byte	0
 14163 0626 0000     		.space	2
 14166              	CTCtrlParArry:
 14167 0628 00       		.byte	0
 14168 0629 00       		.byte	0
 14169 062a 01       		.byte	1
 14170 062b 00       		.byte	0
 14171 062c 00       		.byte	0
 14172 062d 03       		.byte	3
 14173 062e 00       		.byte	0
 14174 062f 01       		.byte	1
 14175 0630 00       		.byte	0
 14176 0631 03       		.byte	3
 14177 0632 00       		.byte	0
 14178 0633 03       		.byte	3
 14179 0634 00       		.byte	0
 14180 0635 03       		.byte	3
 14181 0636 00       		.byte	0
 14182 0637 30       		.byte	48
 14183 0638 01       		.byte	1
 14184 0639 00       		.byte	0
 14185 063a 00       		.byte	0
 14186 063b 00000000 		.space	5
 14186      00
 14187 0640 00       		.byte	0
 14188 0641 00       		.byte	0
 14189 0642 01       		.byte	1
 14190 0643 01       		.byte	1
 14191 0644 00       		.byte	0
 14192 0645 0F       		.byte	15
 14193 0646 00       		.byte	0
 14194 0647 0F       		.byte	15
 14195 0648 00       		.byte	0
 14196 0649 03       		.byte	3
 14197 064a 00       		.byte	0
 14198 064b 02       		.byte	2
 14199 064c 00       		.byte	0
 14200 064d 02       		.byte	2
 14201 064e 00       		.byte	0
 14202 064f 30       		.byte	48
 14203 0650 01       		.byte	1
 14204 0651 01       		.byte	1
 14205 0652 00       		.byte	0
 14206 0653 00000000 		.space	5
 14206      00
 14207 0658 02       		.byte	2
 14208 0659 00       		.byte	0
 14209 065a 01       		.byte	1
 14210 065b 00       		.byte	0
 14211 065c 00       		.byte	0
 14212 065d 01       		.byte	1
 14213 065e 00       		.byte	0
 14214 065f 01       		.byte	1
 14215 0660 00       		.byte	0
 14216 0661 03       		.byte	3
 14217 0662 00       		.byte	0
 14218 0663 00       		.byte	0
 14219 0664 00       		.byte	0
 14220 0665 00       		.byte	0
 14221 0666 00       		.byte	0
 14222 0667 30       		.byte	48
 14223 0668 01       		.byte	1
 14224 0669 01       		.byte	1
 14225 066a 00       		.byte	0
 14226 066b 00000000 		.space	5
 14226      00
 14227 0670 00       		.byte	0
 14228 0671 00       		.byte	0
 14229 0672 04       		.byte	4
 14230 0673 01       		.byte	1
 14231 0674 00       		.byte	0
 14232 0675 38       		.byte	56
 14233 0676 01       		.byte	1
 14234 0677 01       		.byte	1
 14235 0678 00       		.byte	0
 14236 0679 03       		.byte	3
 14237 067a 00       		.byte	0
 14238 067b 4E       		.byte	78
 14239 067c 00       		.byte	0
 14240 067d 4E       		.byte	78
 14241 067e 00       		.byte	0
 14242 067f 30       		.byte	48
 14243 0680 01       		.byte	1
 14244 0681 00       		.byte	0
 14245 0682 00       		.byte	0
 14246 0683 00000000 		.space	5
 14246      00
 14247 0688 04       		.byte	4
 14248 0689 00       		.byte	0
 14249 068a 01       		.byte	1
 14250 068b 00       		.byte	0
 14251 068c 00       		.byte	0
 14252 068d 00       		.byte	0
 14253 068e 00       		.byte	0
 14254 068f 01       		.byte	1
 14255 0690 00       		.byte	0
 14256 0691 03       		.byte	3
 14257 0692 00       		.byte	0
 14258 0693 00       		.byte	0
 14259 0694 00       		.byte	0
 14260 0695 00       		.byte	0
 14261 0696 00       		.byte	0
 14262 0697 30       		.byte	48
 14263 0698 01       		.byte	1
 14264 0699 00       		.byte	0
 14265 069a 00       		.byte	0
 14266 069b 00000000 		.space	5
 14266      00
 14267 06a0 05       		.byte	5
 14268 06a1 00       		.byte	0
 14269 06a2 02       		.byte	2
 14270 06a3 00       		.byte	0
 14271 06a4 00       		.byte	0
 14272 06a5 FF       		.byte	-1
 14273 06a6 00       		.byte	0
 14274 06a7 01       		.byte	1
 14275 06a8 00       		.byte	0
 14276 06a9 03       		.byte	3
 14277 06aa 00       		.byte	0
 14278 06ab 01       		.byte	1
 14279 06ac 00       		.byte	0
 14280 06ad 00       		.byte	0
 14281 06ae 00       		.byte	0
 14282 06af 30       		.byte	48
 14283 06b0 01       		.byte	1
 14284 06b1 01       		.byte	1
 14285 06b2 00       		.byte	0
 14286 06b3 00000000 		.space	5
 14286      00
 14287 06b8 06       		.byte	6
 14288 06b9 00       		.byte	0
 14289 06ba 02       		.byte	2
 14290 06bb 00       		.byte	0
 14291 06bc 00       		.byte	0
 14292 06bd 00       		.byte	0
 14293 06be 00       		.byte	0
 14294 06bf 00       		.byte	0
 14295 06c0 00       		.byte	0
 14296 06c1 03       		.byte	3
 14297 06c2 00       		.byte	0
 14298 06c3 00       		.byte	0
 14299 06c4 00       		.byte	0
 14300 06c5 00       		.byte	0
 14301 06c6 00       		.byte	0
 14302 06c7 30       		.byte	48
 14303 06c8 01       		.byte	1
 14304 06c9 01       		.byte	1
 14305 06ca 00       		.byte	0
 14306 06cb 00000000 		.space	5
 14306      00
 14307 06d0 23       		.byte	35
 14308 06d1 00       		.byte	0
 14309 06d2 02       		.byte	2
 14310 06d3 00       		.byte	0
 14311 06d4 00       		.byte	0
 14312 06d5 30       		.byte	48
 14313 06d6 00       		.byte	0
 14314 06d7 01       		.byte	1
 14315 06d8 00       		.byte	0
 14316 06d9 03       		.byte	3
 14317 06da 0A       		.byte	10
 14318 06db 00       		.byte	0
 14319 06dc 00       		.byte	0
 14320 06dd 0A       		.byte	10
 14321 06de 00       		.byte	0
 14322 06df 30       		.byte	48
 14323 06e0 01       		.byte	1
 14324 06e1 01       		.byte	1
 14325 06e2 00       		.byte	0
 14326 06e3 00000000 		.space	5
 14326      00
 14327 06e8 08       		.byte	8
 14328 06e9 00       		.byte	0
 14329 06ea 01       		.byte	1
 14330 06eb 00       		.byte	0
 14331 06ec 00       		.byte	0
 14332 06ed 7F       		.byte	127
 14333 06ee 00       		.byte	0
 14334 06ef 01       		.byte	1
 14335 06f0 00       		.byte	0
 14336 06f1 03       		.byte	3
 14337 06f2 00       		.byte	0
 14338 06f3 00       		.byte	0
 14339 06f4 00       		.byte	0
 14340 06f5 00       		.byte	0
 14341 06f6 00       		.byte	0
 14342 06f7 30       		.byte	48
 14343 06f8 01       		.byte	1
 14344 06f9 00       		.byte	0
 14345 06fa 00       		.byte	0
 14346 06fb 00000000 		.space	5
 14346      00
 14347 0700 09       		.byte	9
 14348 0701 00       		.byte	0
 14349 0702 02       		.byte	2
 14350 0703 00       		.byte	0
 14351 0704 00       		.byte	0
 14352 0705 05       		.byte	5
 14353 0706 00       		.byte	0
 14354 0707 01       		.byte	1
 14355 0708 00       		.byte	0
 14356 0709 03       		.byte	3
 14357 070a 00       		.byte	0
 14358 070b 00       		.byte	0
 14359 070c 00       		.byte	0
 14360 070d 00       		.byte	0
 14361 070e 00       		.byte	0
 14362 070f 30       		.byte	48
 14363 0710 01       		.byte	1
 14364 0711 00       		.byte	0
 14365 0712 00       		.byte	0
 14366 0713 00000000 		.space	5
 14366      00
 14367 0718 10       		.byte	16
 14368 0719 00       		.byte	0
 14369 071a 03       		.byte	3
 14370 071b 00       		.byte	0
 14371 071c 00       		.byte	0
 14372 071d 00       		.byte	0
 14373 071e 00       		.byte	0
 14374 071f 00       		.byte	0
 14375 0720 00       		.byte	0
 14376 0721 03       		.byte	3
 14377 0722 00       		.byte	0
 14378 0723 00       		.byte	0
 14379 0724 00       		.byte	0
 14380 0725 00       		.byte	0
 14381 0726 00       		.byte	0
 14382 0727 30       		.byte	48
 14383 0728 01       		.byte	1
 14384 0729 00       		.byte	0
 14385 072a 00       		.byte	0
 14386 072b 00000000 		.space	5
 14386      00
 14387 0730 00       		.byte	0
 14388 0731 00       		.byte	0
 14389 0732 02       		.byte	2
 14390 0733 00       		.byte	0
 14391 0734 00       		.byte	0
 14392 0735 40       		.byte	64
 14393 0736 00       		.byte	0
 14394 0737 01       		.byte	1
 14395 0738 00       		.byte	0
 14396 0739 03       		.byte	3
 14397 073a 00       		.byte	0
 14398 073b 0F       		.byte	15
 14399 073c 11       		.byte	17
 14400 073d 00       		.byte	0
 14401 073e 00       		.byte	0
 14402 073f 30       		.byte	48
 14403 0740 01       		.byte	1
 14404 0741 00       		.byte	0
 14405 0742 00       		.byte	0
 14406 0743 00000000 		.space	5
 14406      00
 14407 0748 00       		.byte	0
 14408 0749 00       		.byte	0
 14409 074a 02       		.byte	2
 14410 074b 00       		.byte	0
 14411 074c 00       		.byte	0
 14412 074d 64       		.byte	100
 14413 074e 00       		.byte	0
 14414 074f 01       		.byte	1
 14415 0750 00       		.byte	0
 14416 0751 03       		.byte	3
 14417 0752 00       		.byte	0
 14418 0753 00       		.byte	0
 14419 0754 00       		.byte	0
 14420 0755 00       		.byte	0
 14421 0756 00       		.byte	0
 14422 0757 30       		.byte	48
 14423 0758 01       		.byte	1
 14424 0759 00       		.byte	0
 14425 075a 00       		.byte	0
 14426 075b 00000000 		.space	5
 14426      00
 14427 0760 00       		.byte	0
 14428 0761 00       		.byte	0
 14429 0762 02       		.byte	2
 14430 0763 00       		.byte	0
 14431 0764 00       		.byte	0
 14432 0765 64       		.byte	100
 14433 0766 00       		.byte	0
 14434 0767 01       		.byte	1
 14435 0768 00       		.byte	0
 14436 0769 03       		.byte	3
 14437 076a 00       		.byte	0
 14438 076b 00       		.byte	0
 14439 076c 00       		.byte	0
 14440 076d 00       		.byte	0
 14441 076e 00       		.byte	0
 14442 076f 30       		.byte	48
 14443 0770 01       		.byte	1
 14444 0771 00       		.byte	0
 14445 0772 00       		.byte	0
 14446 0773 00000000 		.space	5
 14446      00
 14447 0778 00       		.byte	0
 14448 0779 00       		.byte	0
 14449 077a 02       		.byte	2
 14450 077b 00       		.byte	0
 14451 077c 00       		.byte	0
 14452 077d 64       		.byte	100
 14453 077e 00       		.byte	0
 14454 077f 01       		.byte	1
 14455 0780 00       		.byte	0
 14456 0781 03       		.byte	3
 14457 0782 00       		.byte	0
 14458 0783 00       		.byte	0
 14459 0784 00       		.byte	0
 14460 0785 00       		.byte	0
 14461 0786 00       		.byte	0
 14462 0787 30       		.byte	48
 14463 0788 01       		.byte	1
 14464 0789 00       		.byte	0
 14465 078a 00       		.byte	0
 14466 078b 00000000 		.space	5
 14466      00
 14467 0790 00       		.byte	0
 14468 0791 00       		.byte	0
 14469 0792 02       		.byte	2
 14470 0793 00       		.byte	0
 14471 0794 00       		.byte	0
 14472 0795 64       		.byte	100
 14473 0796 00       		.byte	0
 14474 0797 01       		.byte	1
 14475 0798 00       		.byte	0
 14476 0799 03       		.byte	3
 14477 079a 00       		.byte	0
 14478 079b 00       		.byte	0
 14479 079c 00       		.byte	0
 14480 079d 00       		.byte	0
 14481 079e 00       		.byte	0
 14482 079f 30       		.byte	48
 14483 07a0 01       		.byte	1
 14484 07a1 00       		.byte	0
 14485 07a2 00       		.byte	0
 14486 07a3 00000000 		.space	5
 14486      00
 14489              	snapButFlag:
 14490 07a8 01       		.byte	1
 14491 07a9 000000   		.space	3
 14494              	CyFxGpifRegValue_usb2:
 14495 07ac 08830080 		.word	-2147450104
 14496 07b0 67000000 		.word	103
 14497 07b4 01000000 		.word	1
 14498 07b8 46000000 		.word	70
 14499 07bc 00000000 		.word	0
 14500 07c0 00000000 		.word	0
 14501 07c4 02000000 		.word	2
 14502 07c8 82000000 		.word	130
 14503 07cc 82070000 		.word	1922
 14504 07d0 40040000 		.word	1088
 14505 07d4 FCFF0000 		.word	65532
 14506 07d8 28000000 		.word	40
 14507 07dc 00000000 		.word	0
 14508 07e0 00000000 		.word	0
 14509 07e4 00000000 		.word	0
 14510 07e8 00000000 		.word	0
 14511 07ec 01000000 		.word	1
 14512 07f0 00000000 		.word	0
 14513 07f4 00000000 		.word	0
 14514 07f8 00000000 		.word	0
 14515 07fc 00000000 		.word	0
 14516 0800 00000000 		.word	0
 14517 0804 00000000 		.word	0
 14518 0808 00000000 		.word	0
 14519 080c 00000000 		.word	0
 14520 0810 00000000 		.word	0
 14521 0814 00000000 		.word	0
 14522 0818 00000000 		.word	0
 14523 081c 00000000 		.word	0
 14524 0820 06000000 		.word	6
 14525 0824 00000000 		.word	0
 14526 0828 FFFF0000 		.word	65535
 14527 082c 09010000 		.word	265
 14528 0830 00000000 		.word	0
 14529 0834 F71F0000 		.word	8183
 14530 0838 00000000 		.word	0
 14531 083c FFFF0000 		.word	65535
 14532 0840 09010000 		.word	265
 14533 0844 00000000 		.word	0
 14534 0848 F71F0000 		.word	8183
 14535 084c 00000000 		.word	0
 14536 0850 00000000 		.word	0
 14537 0854 00000000 		.word	0
 14538 0858 00000000 		.word	0
 14539 085c 00000000 		.word	0
 14540 0860 00000000 		.word	0
 14541 0864 00000000 		.word	0
 14542 0868 00000000 		.word	0
 14543 086c 00000000 		.word	0
 14544 0870 00000000 		.word	0
 14545 0874 00000000 		.word	0
 14546 0878 00000000 		.word	0
 14547 087c 00000000 		.word	0
 14548 0880 00000000 		.word	0
 14549 0884 00000000 		.word	0
 14550 0888 00000000 		.word	0
 14551 088c 00000000 		.word	0
 14552 0890 00000000 		.word	0
 14553 0894 00000000 		.word	0
 14554 0898 00000000 		.word	0
 14555 089c 00000000 		.word	0
 14556 08a0 00000000 		.word	0
 14557 08a4 00000000 		.word	0
 14558 08a8 00040180 		.word	-2147417088
 14559 08ac 01040180 		.word	-2147417087
 14560 08b0 02040180 		.word	-2147417086
 14561 08b4 03040180 		.word	-2147417085
 14562 08b8 00000000 		.word	0
 14563 08bc 00000000 		.word	0
 14564 08c0 00000000 		.word	0
 14565 08c4 00000000 		.word	0
 14566 08c8 00000000 		.word	0
 14567 08cc 00000000 		.word	0
 14568 08d0 00000000 		.word	0
 14569 08d4 00000000 		.word	0
 14570 08d8 C1FFFFFF 		.word	-63
 14573              	CyFxGpifWavedataPosition_usb2:
 14574 08dc 00       		.byte	0
 14575 08dd 01       		.byte	1
 14576 08de 02       		.byte	2
 14577 08df 03       		.byte	3
 14578 08e0 04       		.byte	4
 14579 08e1 05       		.byte	5
 14580 08e2 06       		.byte	6
 14581 08e3 07       		.byte	7
 14582 08e4 08       		.byte	8
 14583 08e5 09       		.byte	9
 14584 08e6 0A       		.byte	10
 14585 08e7 08       		.byte	8
 14586 08e8 0B       		.byte	11
 14587 08e9 0C       		.byte	12
 14588 08ea 0D       		.byte	13
 14589 08eb 08       		.byte	8
 14590 08ec 0E       		.byte	14
 14591 08ed 0F       		.byte	15
 14592 08ee 08       		.byte	8
 14593 08ef 08       		.byte	8
 14594 08f0 08       		.byte	8
 14595 08f1 08       		.byte	8
 14596 08f2 08       		.byte	8
 14597 08f3 08       		.byte	8
 14598 08f4 08       		.byte	8
 14599 08f5 08       		.byte	8
 14600 08f6 08       		.byte	8
 14601 08f7 08       		.byte	8
 14602 08f8 08       		.byte	8
 14603 08f9 08       		.byte	8
 14604 08fa 08       		.byte	8
 14605 08fb 08       		.byte	8
 14606 08fc 08       		.byte	8
 14607 08fd 08       		.byte	8
 14608 08fe 08       		.byte	8
 14609 08ff 08       		.byte	8
 14610 0900 08       		.byte	8
 14611 0901 08       		.byte	8
 14612 0902 08       		.byte	8
 14613 0903 08       		.byte	8
 14614 0904 08       		.byte	8
 14615 0905 08       		.byte	8
 14616 0906 08       		.byte	8
 14617 0907 08       		.byte	8
 14618 0908 08       		.byte	8
 14619 0909 08       		.byte	8
 14620 090a 08       		.byte	8
 14621 090b 08       		.byte	8
 14622 090c 08       		.byte	8
 14623 090d 08       		.byte	8
 14624 090e 08       		.byte	8
 14625 090f 08       		.byte	8
 14626 0910 08       		.byte	8
 14627 0911 08       		.byte	8
 14628 0912 08       		.byte	8
 14629 0913 08       		.byte	8
 14630 0914 08       		.byte	8
 14631 0915 08       		.byte	8
 14632 0916 08       		.byte	8
 14633 0917 08       		.byte	8
 14634 0918 08       		.byte	8
 14635 0919 08       		.byte	8
 14636 091a 08       		.byte	8
 14637 091b 08       		.byte	8
 14638 091c 08       		.byte	8
 14639 091d 08       		.byte	8
 14640 091e 08       		.byte	8
 14641 091f 08       		.byte	8
 14642 0920 08       		.byte	8
 14643 0921 08       		.byte	8
 14644 0922 08       		.byte	8
 14645 0923 08       		.byte	8
 14646 0924 08       		.byte	8
 14647 0925 08       		.byte	8
 14648 0926 08       		.byte	8
 14649 0927 08       		.byte	8
 14650 0928 08       		.byte	8
 14651 0929 08       		.byte	8
 14652 092a 08       		.byte	8
 14653 092b 08       		.byte	8
 14654 092c 08       		.byte	8
 14655 092d 08       		.byte	8
 14656 092e 08       		.byte	8
 14657 092f 08       		.byte	8
 14658 0930 08       		.byte	8
 14659 0931 08       		.byte	8
 14660 0932 08       		.byte	8
 14661 0933 08       		.byte	8
 14662 0934 08       		.byte	8
 14663 0935 08       		.byte	8
 14664 0936 08       		.byte	8
 14665 0937 08       		.byte	8
 14666 0938 08       		.byte	8
 14667 0939 08       		.byte	8
 14668 093a 08       		.byte	8
 14669 093b 08       		.byte	8
 14670 093c 08       		.byte	8
 14671 093d 08       		.byte	8
 14672 093e 08       		.byte	8
 14673 093f 08       		.byte	8
 14674 0940 08       		.byte	8
 14675 0941 08       		.byte	8
 14676 0942 08       		.byte	8
 14677 0943 08       		.byte	8
 14678 0944 08       		.byte	8
 14679 0945 08       		.byte	8
 14680 0946 08       		.byte	8
 14681 0947 08       		.byte	8
 14682 0948 08       		.byte	8
 14683 0949 08       		.byte	8
 14684 094a 08       		.byte	8
 14685 094b 08       		.byte	8
 14686 094c 08       		.byte	8
 14687 094d 08       		.byte	8
 14688 094e 08       		.byte	8
 14689 094f 08       		.byte	8
 14690 0950 08       		.byte	8
 14691 0951 08       		.byte	8
 14692 0952 08       		.byte	8
 14693 0953 08       		.byte	8
 14694 0954 08       		.byte	8
 14695 0955 08       		.byte	8
 14696 0956 08       		.byte	8
 14697 0957 08       		.byte	8
 14698 0958 08       		.byte	8
 14699 0959 08       		.byte	8
 14700 095a 08       		.byte	8
 14701 095b 08       		.byte	8
 14702 095c 00       		.byte	0
 14703 095d 01       		.byte	1
 14704 095e 02       		.byte	2
 14705 095f 10       		.byte	16
 14706 0960 04       		.byte	4
 14707 0961 05       		.byte	5
 14708 0962 06       		.byte	6
 14709 0963 07       		.byte	7
 14710 0964 08       		.byte	8
 14711 0965 09       		.byte	9
 14712 0966 0A       		.byte	10
 14713 0967 08       		.byte	8
 14714 0968 11       		.byte	17
 14715 0969 0C       		.byte	12
 14716 096a 0D       		.byte	13
 14717 096b 08       		.byte	8
 14718 096c 0E       		.byte	14
 14719 096d 0F       		.byte	15
 14720 096e 08       		.byte	8
 14721 096f 00       		.space	1
 14724              	CyFxGpifWavedata_usb2:
 14725 0970 0181731E 		.word	510886145
 14726 0974 00000000 		.word	0
 14727 0978 00000080 		.word	-2147483648
 14728 097c 00000000 		.word	0
 14729 0980 00000000 		.word	0
 14730 0984 00000000 		.word	0
 14731 0988 0201703E 		.word	1047527682
 14732 098c 00010000 		.word	256
 14733 0990 A00000C0 		.word	-1073741664
 14734 0994 00000000 		.word	0
 14735 0998 00000000 		.word	0
 14736 099c 00000000 		.word	0
 14737 09a0 0394731E 		.word	510891011
 14738 09a4 04000020 		.word	536870916
 14739 09a8 60004080 		.word	-2143289248
 14740 09ac 00000000 		.word	0
 14741 09b0 00000000 		.word	0
 14742 09b4 00000000 		.word	0
 14743 09b8 0620702E 		.word	779100166
 14744 09bc 0C000000 		.word	12
 14745 09c0 00000080 		.word	-2147483648
 14746 09c4 0620702E 		.word	779100166
 14747 09c8 0C000000 		.word	12
 14748 09cc 00000080 		.word	-2147483648
 14749 09d0 0394731E 		.word	510891011
 14750 09d4 04000020 		.word	536870916
 14751 09d8 60004080 		.word	-2143289248
 14752 09dc 0620702E 		.word	779100166
 14753 09e0 0C000000 		.word	12
 14754 09e4 00000080 		.word	-2147483648
 14755 09e8 0C93731E 		.word	510890764
 14756 09ec 04000024 		.word	603979780
 14757 09f0 90004080 		.word	-2143289200
 14758 09f4 0D20702E 		.word	779100173
 14759 09f8 0C000000 		.word	12
 14760 09fc 00000080 		.word	-2147483648
 14761 0a00 0780724E 		.word	1316126727
 14762 0a04 0A000000 		.word	10
 14763 0a08 00000080 		.word	-2147483648
 14764 0a0c 08000000 		.word	8
 14765 0a10 00000000 		.word	0
 14766 0a14 00010080 		.word	-2147483392
 14767 0a18 0920702E 		.word	779100169
 14768 0a1c 0C010000 		.word	268
 14769 0a20 00000080 		.word	-2147483648
 14770 0a24 0A01701E 		.word	510656778
 14771 0a28 0E000100 		.word	65550
 14772 0a2c 00000080 		.word	-2147483648
 14773 0a30 00000000 		.word	0
 14774 0a34 00000000 		.word	0
 14775 0a38 00000000 		.word	0
 14776 0a3c 00000000 		.word	0
 14777 0a40 00000000 		.word	0
 14778 0a44 00000000 		.word	0
 14779 0a48 0394731E 		.word	510891011
 14780 0a4c 04000020 		.word	536870916
 14781 0a50 60004080 		.word	-2143289248
 14782 0a54 08000000 		.word	8
 14783 0a58 00000000 		.word	0
 14784 0a5c 00010080 		.word	-2147483392
 14785 0a60 0B000000 		.word	11
 14786 0a64 00000000 		.word	0
 14787 0a68 00010080 		.word	-2147483392
 14788 0a6c 0C93731E 		.word	510890764
 14789 0a70 04000024 		.word	603979780
 14790 0a74 90004080 		.word	-2143289200
 14791 0a78 0D20702E 		.word	779100173
 14792 0a7c 0C000000 		.word	12
 14793 0a80 00000080 		.word	-2147483648
 14794 0a84 0D20702E 		.word	779100173
 14795 0a88 0C000000 		.word	12
 14796 0a8c 00000080 		.word	-2147483648
 14797 0a90 0E60724E 		.word	1316118542
 14798 0a94 0A000000 		.word	10
 14799 0a98 00000080 		.word	-2147483648
 14800 0a9c 0F000000 		.word	15
 14801 0aa0 00000000 		.word	0
 14802 0aa4 00010080 		.word	-2147483392
 14803 0aa8 1020702E 		.word	779100176
 14804 0aac 0C010000 		.word	268
 14805 0ab0 00000080 		.word	-2147483648
 14806 0ab4 1101701E 		.word	510656785
 14807 0ab8 0E000100 		.word	65550
 14808 0abc 00000080 		.word	-2147483648
 14809 0ac0 0C93731E 		.word	510890764
 14810 0ac4 04000024 		.word	603979780
 14811 0ac8 90004080 		.word	-2143289200
 14812 0acc 0F000000 		.word	15
 14813 0ad0 00000000 		.word	0
 14814 0ad4 00010080 		.word	-2147483392
 14815 0ad8 12000000 		.word	18
 14816 0adc 00000000 		.word	0
 14817 0ae0 00010080 		.word	-2147483392
 14818 0ae4 0394731E 		.word	510891011
 14819 0ae8 04000020 		.word	536870916
 14820 0aec 60004080 		.word	-2143289248
 14821 0af0 0480732E 		.word	779321348
 14822 0af4 02010000 		.word	258
 14823 0af8 0000C0C0 		.word	-1061158912
 14824 0afc 0580732E 		.word	779321349
 14825 0b00 02010000 		.word	258
 14826 0b04 0000C0C0 		.word	-1061158912
 14827 0b08 0580732E 		.word	779321349
 14828 0b0c 02010000 		.word	258
 14829 0b10 0000C0C0 		.word	-1061158912
 14830 0b14 0480732E 		.word	779321348
 14831 0b18 02010000 		.word	258
 14832 0b1c 0000C0C0 		.word	-1061158912
 14835              	CyFxGpifTransition_usb2:
 14836 0b20 0000     		.short	0
 14837 0b22 5555     		.short	21845
 14838 0b24 AAAA     		.short	-21846
 14839 0b26 8888     		.short	-30584
 14840 0b28 1111     		.short	4369
 14841 0b2a 4444     		.short	17476
 14842 0b2c 3333     		.short	13107
 14843 0b2e CCCC     		.short	-13108
 14846              	CyFxGpifRegValue:
 14847 0b30 08830080 		.word	-2147450104
 14848 0b34 67000000 		.word	103
 14849 0b38 00000000 		.word	0
 14850 0b3c 46000000 		.word	70
 14851 0b40 00000000 		.word	0
 14852 0b44 00000000 		.word	0
 14853 0b48 02000000 		.word	2
 14854 0b4c 82000000 		.word	130
 14855 0b50 82070000 		.word	1922
 14856 0b54 40040000 		.word	1088
 14857 0b58 FCFF0000 		.word	65532
 14858 0b5c 28000000 		.word	40
 14859 0b60 00000000 		.word	0
 14860 0b64 00000000 		.word	0
 14861 0b68 00000000 		.word	0
 14862 0b6c 00000000 		.word	0
 14863 0b70 01000000 		.word	1
 14864 0b74 00000000 		.word	0
 14865 0b78 00000000 		.word	0
 14866 0b7c 00000000 		.word	0
 14867 0b80 00000000 		.word	0
 14868 0b84 00000000 		.word	0
 14869 0b88 00000000 		.word	0
 14870 0b8c 00000000 		.word	0
 14871 0b90 00000000 		.word	0
 14872 0b94 00000000 		.word	0
 14873 0b98 00000000 		.word	0
 14874 0b9c 00000000 		.word	0
 14875 0ba0 00000000 		.word	0
 14876 0ba4 06000000 		.word	6
 14877 0ba8 00000000 		.word	0
 14878 0bac FFFF0000 		.word	65535
 14879 0bb0 09010000 		.word	265
 14880 0bb4 00000000 		.word	0
 14881 0bb8 F71F0000 		.word	8183
 14882 0bbc 00000000 		.word	0
 14883 0bc0 FFFF0000 		.word	65535
 14884 0bc4 09010000 		.word	265
 14885 0bc8 00000000 		.word	0
 14886 0bcc F71F0000 		.word	8183
 14887 0bd0 00000000 		.word	0
 14888 0bd4 00000000 		.word	0
 14889 0bd8 00000000 		.word	0
 14890 0bdc 00000000 		.word	0
 14891 0be0 00000000 		.word	0
 14892 0be4 00000000 		.word	0
 14893 0be8 00000000 		.word	0
 14894 0bec 00000000 		.word	0
 14895 0bf0 00000000 		.word	0
 14896 0bf4 00000000 		.word	0
 14897 0bf8 00000000 		.word	0
 14898 0bfc 00000000 		.word	0
 14899 0c00 00000000 		.word	0
 14900 0c04 00000000 		.word	0
 14901 0c08 00000000 		.word	0
 14902 0c0c 00000000 		.word	0
 14903 0c10 00000000 		.word	0
 14904 0c14 00000000 		.word	0
 14905 0c18 00000000 		.word	0
 14906 0c1c 00000000 		.word	0
 14907 0c20 00000000 		.word	0
 14908 0c24 00000000 		.word	0
 14909 0c28 00000000 		.word	0
 14910 0c2c 00040180 		.word	-2147417088
 14911 0c30 01040180 		.word	-2147417087
 14912 0c34 02040180 		.word	-2147417086
 14913 0c38 03040180 		.word	-2147417085
 14914 0c3c 00000000 		.word	0
 14915 0c40 00000000 		.word	0
 14916 0c44 00000000 		.word	0
 14917 0c48 00000000 		.word	0
 14918 0c4c 00000000 		.word	0
 14919 0c50 00000000 		.word	0
 14920 0c54 00000000 		.word	0
 14921 0c58 00000000 		.word	0
 14922 0c5c C1FFFFFF 		.word	-63
 14925              	CyFxGpifWavedataPosition:
 14926 0c60 00       		.byte	0
 14927 0c61 01       		.byte	1
 14928 0c62 02       		.byte	2
 14929 0c63 03       		.byte	3
 14930 0c64 04       		.byte	4
 14931 0c65 05       		.byte	5
 14932 0c66 06       		.byte	6
 14933 0c67 07       		.byte	7
 14934 0c68 08       		.byte	8
 14935 0c69 09       		.byte	9
 14936 0c6a 0A       		.byte	10
 14937 0c6b 0B       		.byte	11
 14938 0c6c 0B       		.byte	11
 14939 0c6d 0B       		.byte	11
 14940 0c6e 0B       		.byte	11
 14941 0c6f 00       		.space	1
 14944              	CyFxGpifWavedata:
 14945 0c70 0181731E 		.word	510886145
 14946 0c74 00000000 		.word	0
 14947 0c78 00000080 		.word	-2147483648
 14948 0c7c 00000000 		.word	0
 14949 0c80 00000000 		.word	0
 14950 0c84 00000000 		.word	0
 14951 0c88 0201702E 		.word	779092226
 14952 0c8c 00010000 		.word	256
 14953 0c90 A0000080 		.word	-2147483488
 14954 0c94 00000000 		.word	0
 14955 0c98 00000000 		.word	0
 14956 0c9c 00000000 		.word	0
 14957 0ca0 0380722E 		.word	779255811
 14958 0ca4 02010020 		.word	536871170
 14959 0ca8 60000080 		.word	-2147483552
 14960 0cac 00000000 		.word	0
 14961 0cb0 00000000 		.word	0
 14962 0cb4 00000000 		.word	0
 14963 0cb8 0460722E 		.word	779247620
 14964 0cbc 02010024 		.word	603980034
 14965 0cc0 90000080 		.word	-2147483504
 14966 0cc4 0594731E 		.word	510891013
 14967 0cc8 06000000 		.word	6
 14968 0ccc 00000080 		.word	-2147483648
 14969 0cd0 0380722E 		.word	779255811
 14970 0cd4 02010020 		.word	536871170
 14971 0cd8 60000080 		.word	-2147483552
 14972 0cdc 0693731E 		.word	510890758
 14973 0ce0 06000000 		.word	6
 14974 0ce4 00000080 		.word	-2147483648
 14975 0ce8 0720703E 		.word	1047535623
 14976 0cec 08010000 		.word	264
 14977 0cf0 00000080 		.word	-2147483648
 14978 0cf4 0820703E 		.word	1047535624
 14979 0cf8 08010000 		.word	264
 14980 0cfc 00000080 		.word	-2147483648
 14981 0d00 0920703E 		.word	1047535625
 14982 0d04 08010000 		.word	264
 14983 0d08 00000080 		.word	-2147483648
 14984 0d0c 0A20703E 		.word	1047535626
 14985 0d10 08010000 		.word	264
 14986 0d14 00000080 		.word	-2147483648
 14987 0d18 0380722E 		.word	779255811
 14988 0d1c 02010020 		.word	536871170
 14989 0d20 60000080 		.word	-2147483552
 14990 0d24 0B000000 		.word	11
 14991 0d28 00000000 		.word	0
 14992 0d2c 00010080 		.word	-2147483392
 14993 0d30 0460722E 		.word	779247620
 14994 0d34 02010024 		.word	603980034
 14995 0d38 90000080 		.word	-2147483504
 14996 0d3c 0D000000 		.word	13
 14997 0d40 00000000 		.word	0
 14998 0d44 00010080 		.word	-2147483392
 14999 0d48 0460722E 		.word	779247620
 15000 0d4c 02010024 		.word	603980034
 15001 0d50 90000080 		.word	-2147483504
 15002 0d54 0C000000 		.word	12
 15003 0d58 00000000 		.word	0
 15004 0d5c 00010080 		.word	-2147483392
 15005 0d60 0380722E 		.word	779255811
 15006 0d64 02010020 		.word	536871170
 15007 0d68 60000080 		.word	-2147483552
 15008 0d6c 0E000000 		.word	14
 15009 0d70 00000000 		.word	0
 15010 0d74 00010080 		.word	-2147483392
 15011 0d78 00000000 		.word	0
 15012 0d7c 00000000 		.word	0
 15013 0d80 00000000 		.word	0
 15014 0d84 00000000 		.word	0
 15015 0d88 00000000 		.word	0
 15016 0d8c 00000000 		.word	0
 15019              	CyFxGpifTransition:
 15020 0d90 0000     		.short	0
 15021 0d92 5555     		.short	21845
 15022 0d94 8888     		.short	-30584
 15023 0d96 AAAA     		.short	-21846
 15024 0d98 3333     		.short	13107
 15025 0d9a 0000     		.section	.rodata.str1.4,"aMS",%progbits,1
 15026              		.align	2
 15027              	.LC0:
 15028 0000 49324320 		.ascii	"I2C pos-timer %d %d\015\012\000"
 15028      706F732D 
 15028      74696D65 
 15028      72202564 
 15028      2025640D 
 15029 0016 0000     		.space	2
 15030              	.LC1:
 15031 0018 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 15031      6F207374 
 15031      7265616D 
 15031      20474554 
 15031      20726571 
 15032 003d 000000   		.space	3
 15033              	.LC2:
 15034 0040 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 15034      74686520 
 15034      76696465 
 15034      6F206D6F 
 15034      64652066 
 15035 0061 000000   		.space	3
 15036              	.LC3:
 15037 0064 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 15037      74686520 
 15037      76696465 
 15037      6F206D6F 
 15037      64652066 
 15038 0089 000000   		.space	3
 15039              	.LC4:
 15040 008c 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 15040      43595F46 
 15040      585F5556 
 15040      435F5354 
 15040      5245414D 
 15041 00b2 0000     		.space	2
 15042              	.LC5:
 15043 00b4 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 15043      55564320 
 15043      7374696C 
 15043      6C205072 
 15043      6F622873 
 15044 00df 00       		.space	1
 15045              	.LC6:
 15046 00e0 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 15046      74686520 
 15046      7374696C 
 15046      6C206D6F 
 15046      64652066 
 15047 0101 000000   		.space	3
 15048              	.LC7:
 15049 0104 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 15049      7374696C 
 15049      6C20636F 
 15049      6D6D6974 
 15049      20636F6E 
 15050              	.LC8:
 15051 012c 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 15051      43595F46 
 15051      585F5556 
 15051      435F5354 
 15051      494C5F45 
 15052              	.LC9:
 15053 0150 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 15053      55564320 
 15053      7374696C 
 15053      6C207472 
 15053      69676765 
 15054 0179 000000   		.space	3
 15055              	.LC10:
 15056 017c 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 15056      7374696C 
 15056      6C207472 
 15056      69676765 
 15056      7220636F 
 15057 01a3 00       		.space	1
 15058              	.LC11:
 15059 01a4 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 15059      7065722D 
 15059      74696D65 
 15059      72202564 
 15059      0D0A00
 15060 01b7 00       		.space	1
 15061              	.LC12:
 15062 01b8 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 15062      636F6D6D 
 15062      616E6420 
 15062      71756575 
 15062      65206973 
 15063 01db 00       		.space	1
 15064              	.LC13:
 15065 01dc 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 15065      7220696E 
 15065      206D756C 
 15065      74696368 
 15065      616E6E65 
 15066 020f 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 15066      2025782C 
 15066      20646D61 
 15066      446F6E65 
 15066      20256420 
 15067              	.LC14:
 15068 0228 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 15068      5420656E 
 15068      636F756E 
 15068      74657265 
 15068      642E2E2E 
 15069              	.LC15:
 15070 0248 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 15070      454E4420 
 15070      656E636F 
 15070      756E7465 
 15070      7265642E 
 15071 026a 0000     		.space	2
 15072              	.LC16:
 15073 026c 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 15073      64697363 
 15073      6F6E6E65 
 15073      63746564 
 15073      2E2E2E30 
 15074 028b 00       		.space	1
 15075              	.LC17:
 15076 028c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 15076      43595F46 
 15076      585F5556 
 15076      435F5649 
 15076      44454F5F 
 15077 02bf 0A00     		.ascii	"\012\000"
 15078 02c1 000000   		.space	3
 15079              	.LC18:
 15080 02c4 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 15080      43595F46 
 15080      585F5556 
 15080      435F5649 
 15080      44454F5F 
 15081 02f7 00       		.ascii	"\000"
 15082              	.LC19:
 15083 02f8 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 15083      726E6174 
 15083      65207365 
 15083      7474696E 
 15083      6720302E 
 15084              	.LC20:
 15085 0310 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 15085      72206665 
 15085      61747572 
 15085      65207265 
 15085      71756573 
 15086 0333 00       		.space	1
 15087              	.LC21:
 15088 0334 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 15088      49324320 
 15088      636F6D6D 
 15088      616E6420 
 15088      69732030 
 15089 0367 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 15089      78257820 
 15089      30782578 
 15089      20307825 
 15089      78203078 
 15090              	.LC22:
 15091 0380 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 15091      49324320 
 15091      636F6D6D 
 15091      616E6420 
 15091      73657474 
 15092 03a6 0000     		.space	2
 15093              	.LC23:
 15094 03a8 54686520 		.ascii	"The shutter set value %d 0x%x 0x%x 0x%x\015\012\000"
 15094      73687574 
 15094      74657220 
 15094      73657420 
 15094      76616C75 
 15095 03d2 0000     		.space	2
 15096              	.LC24:
 15097 03d4 74657374 		.ascii	"test shutter speed. 0x%x 0x%x 0x%x\015\012\000"
 15097      20736875 
 15097      74746572 
 15097      20737065 
 15097      65642E20 
 15098 03f9 000000   		.space	3
 15099              	.LC25:
 15100 03fc 74657374 		.ascii	"test shutter speed2. 0x%x 0x%x 0x%x\015\012\000"
 15100      20736875 
 15100      74746572 
 15100      20737065 
 15100      6564322E 
 15101 0422 0000     		.space	2
 15102              	.LC26:
 15103 0424 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 15103      206C6967 
 15103      68742063 
 15103      6F6D7065 
 15103      6E736174 
 15104 0457 25640D0A 		.ascii	"%d\015\012\000"
 15104      00
 15105              	.LC27:
 15106 045c 54686520 		.ascii	"The I2C current data is not available. try again. %"
 15106      49324320 
 15106      63757272 
 15106      656E7420 
 15106      64617461 
 15107 048f 64202564 		.ascii	"d %d\015\012\000"
 15107      0D0A00
 15108 0496 0000     		.space	2
 15109              	.LC28:
 15110 0498 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 15110      26414743 
 15110      2073656E 
 15110      7420746F 
 15110      20686F73 
 15111 04be 0000     		.space	2
 15112              	.LC29:
 15113 04c0 54686520 		.ascii	"The shutter&exposure 0x%x 0x%x 0x%x 0x%x\015\012\000"
 15113      73687574 
 15113      74657226 
 15113      6578706F 
 15113      73757265 
 15114 04eb 00       		.space	1
 15115              	.LC30:
 15116 04ec 4578704D 		.ascii	"ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\015"
 15116      26414743 
 15116      20676F74 
 15116      74656E20 
 15116      66726F6D 
 15117 051d 0A00     		.ascii	"\012\000"
 15118 051f 00       		.space	1
 15119              	.LC31:
 15120 0520 53687574 		.ascii	"Shutter level gotten from host. 0x%x %d; 0x%x 0x%x "
 15120      74657220 
 15120      6C657665 
 15120      6C20676F 
 15120      7474656E 
 15121 0553 25640D0A 		.ascii	"%d\015\012\000"
 15121      00
 15122              	.LC32:
 15123 0558 46726571 		.ascii	"Frequency setting is  %d %d\015\012\000"
 15123      75656E63 
 15123      79207365 
 15123      7474696E 
 15123      67206973 
 15124 0576 0000     		.space	2
 15125              	.LC33:
 15126 0578 46536574 		.ascii	"FSet the video mode format %x %d\012\000"
 15126      20746865 
 15126      20766964 
 15126      656F206D 
 15126      6F646520 
 15127 059a 0000     		.space	2
 15128              	.LC34:
 15129 059c 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 15129      67657420 
 15129      64617461 
 15129      2066726F 
 15129      6D20686F 
 15130 05c9 000000   		.space	3
 15131              	.LC35:
 15132 05cc 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 15132      52657175 
 15132      65737420 
 15132      30782578 
 15132      20706172 
 15133 05ff 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 15133      6E642074 
 15133      6F20686F 
 15133      73742030 
 15133      78257820 
 15134 061a 0000     		.space	2
 15135              	.LC36:
 15136 061c 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 15136      204F7020 
 15136      72656365 
 15136      69766573 
 15136      20284354 
 15137 0643 00       		.space	1
 15138              	.LC37:
 15139 0644 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 15139      756C7420 
 15139      73656C65 
 15139      63746F72 
 15139      20284354 
 15140 0666 0000     		.space	2
 15141              	.LC38:
 15142 0668 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 15142      756C7420 
 15142      72657175 
 15142      65737420 
 15142      28435429 
 15143 0689 000000   		.space	3
 15144              	.LC39:
 15145 068c 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 15145      52657175 
 15145      65737420 
 15145      30782578 
 15145      20706172 
 15146 06bf 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 15146      20307825 
 15146      78202F20 
 15146      73656E64 
 15146      20746F20 
 15147 06ec 00       		.ascii	"\000"
 15148 06ed 000000   		.space	3
 15149              	.LC40:
 15150 06f0 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 15150      73657420 
 15150      64656620 
 15150      64617461 
 15150      20307825 
 15151 070f 00       		.space	1
 15152              	.LC41:
 15153 0710 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 15153      73657420 
 15153      64656620 
 15153      64617461 
 15153      20307825 
 15154 0743 2E0D0A00 		.ascii	".\015\012\000"
 15155 0747 00       		.space	1
 15156              	.LC42:
 15157 0748 4572726F 		.ascii	"Error handler...\015\012\000"
 15157      72206861 
 15157      6E646C65 
 15157      722E2E2E 
 15157      0D0A00
 15158 075b 00       		.space	1
 15159              	.LC43:
 15160 075c 55415254 		.ascii	"UART initialization failed!\012\000"
 15160      20696E69 
 15160      7469616C 
 15160      697A6174 
 15160      696F6E20 
 15161 0779 000000   		.space	3
 15162              	.LC44:
 15163 077c 49324320 		.ascii	"I2C initialization failed!\012\000"
 15163      696E6974 
 15163      69616C69 
 15163      7A617469 
 15163      6F6E2066 
 15164              	.LC45:
 15165 0798 49324320 		.ascii	"I2C configuration failed!\012\000"
 15165      636F6E66 
 15165      69677572 
 15165      6174696F 
 15165      6E206661 
 15166 07b3 00       		.space	1
 15167              	.LC46:
 15168 07b4 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 15168      43726561 
 15168      74652045 
 15168      76656E74 
 15168      20666169 
 15169 07de 0000     		.space	2
 15170              	.LC47:
 15171 07e0 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 15171      20496E69 
 15171      74206661 
 15171      696C6564 
 15171      2C204572 
 15172 0803 00       		.space	1
 15173              	.LC48:
 15174 0804 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 15174      204F7665 
 15174      72726964 
 15174      65206661 
 15174      696C6564 
 15175 082b 00       		.space	1
 15176              	.LC49:
 15177 082c 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 15177      28323029 
 15177      204F7665 
 15177      72726964 
 15177      65206661 
 15178 0857 00       		.space	1
 15179              	.LC50:
 15180 0858 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 15180      28323429 
 15180      204F7665 
 15180      72726964 
 15180      65206661 
 15181 0883 00       		.space	1
 15182              	.LC51:
 15183 0884 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 15183      20536574 
 15183      20287265 
 15183      73657420 
 15183      32322920 
 15184 08b6 00       		.ascii	"\000"
 15185 08b7 00       		.space	1
 15186              	.LC52:
 15187 08b8 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 15187      20536574 
 15187      2028706F 
 15187      77657220 
 15187      32302920 
 15188 08ea 00       		.ascii	"\000"
 15189 08eb 00       		.space	1
 15190              	.LC53:
 15191 08ec 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 15191      20536574 
 15191      2028736E 
 15191      61702073 
 15191      686F7420 
 15192 091f 25640A00 		.ascii	"%d\012\000"
 15193 0923 00       		.space	1
 15194              	.LC54:
 15195 0924 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 15195      46756E63 
 15195      74696F6E 
 15195      20466169 
 15195      6C656420 
 15196 0953 00       		.space	1
 15197              	.LC55:
 15198 0954 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 15198      46756E63 
 15198      74696F6E 
 15198      20466169 
 15198      6C656420 
 15199 0983 00       		.space	1
 15200              	.LC56:
 15201 0984 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 15201      53657420 
 15201      456E6470 
 15201      6F696E74 
 15201      20636F6E 
 15202 09b4 00       		.ascii	"\000"
 15203 09b5 000000   		.space	3
 15204              	.LC57:
 15205 09b8 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 15205      496E7465 
 15205      72727570 
 15205      74205374 
 15205      61747573 
 15206 09eb 20436F64 		.ascii	" Code = %d\012\000"
 15206      65203D20 
 15206      25640A00 
 15207 09f7 00       		.space	1
 15208              	.LC58:
 15209 09f8 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 15209      65642074 
 15209      6F20616C 
 15209      6C6F6361 
 15209      7465206D 
 15210 0a2b 65720D0A 		.ascii	"er\015\012\000"
 15210      00
 15211              	.LC59:
 15212 0a30 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 15212      4368616E 
 15212      6E656C20 
 15212      43726561 
 15212      74696F6E 
 15213 0a5e 0000     		.space	2
 15214              	.LC60:
 15215 0a60 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 15215      436F6E6E 
 15215      65637420 
 15215      6661696C 
 15215      65642C20 
 15216 0a85 000000   		.space	3
 15217              	.LC61:
 15218 0a88 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 15218      74686520 
 15218      76696465 
 15218      6F206D6F 
 15218      64652066 
 15219 0aaa 0000     		.space	2
 15220              	.LC62:
 15221 0aac 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 15221      4368616E 
 15221      6E656C20 
 15221      52657365 
 15221      74204661 
 15222 0ad7 00       		.space	1
 15223              	.LC63:
 15224 0ad8 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 15224      4368616E 
 15224      6E656C20 
 15224      53657420 
 15224      5472616E 
 15225 0b09 00       		.ascii	"\000"
 15226 0b0a 0000     		.space	2
 15227              	.LC64:
 15228 0b0c 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 15228      4368616E 
 15228      6E656C20 
 15228      53657420 
 15228      5472616E 
 15229 0b3d 0A00     		.ascii	"\012\000"
 15230 0b3f 00       		.space	1
 15231              	.LC65:
 15232 0b40 0D0A2073 		.ascii	"\015\012 super gpif\000"
 15232      75706572 
 15232      20677069 
 15232      6600
 15233 0b4e 0000     		.space	2
 15234              	.LC66:
 15235 0b50 0D0A2068 		.ascii	"\015\012 high gpif\000"
 15235      69676820 
 15235      67706966 
 15235      00
 15236 0b5d 000000   		.space	3
 15237              	.LC67:
 15238 0b60 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 15238      696E6720 
 15238      47504946 
 15238      20436F6E 
 15238      66696775 
 15239 0b93 0A00     		.ascii	"\012\000"
 15240 0b95 000000   		.space	3
 15241              	.LC68:
 15242 0b98 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 15242      74696E67 
 15242      20475049 
 15242      46207374 
 15242      61746520 
 15243 0bcb 0D0A00   		.ascii	"\015\012\000"
 15244 0bce 0000     		.space	2
 15245              	.LC69:
 15246 0bd0 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 15246      73706565 
 15246      64203D20 
 15246      25642065 
 15246      76656E66 
 15247 0c00 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 15247      71756573 
 15247      74203D20 
 15247      30782578 
 15247      20775661 
 15248 0c30 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 15248      203D2030 
 15248      78257820 
 15248      6973666C 
 15248      61672030 
 15249 0c4a 0000     		.space	2
 15250              	.LC70:
 15251 0c4c 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 15251      64656661 
 15251      756C7420 
 15251      73657475 
 15251      70207265 
 15252              	.LC71:
 15253 0c78 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 15253      65642074 
 15253      6F207365 
 15253      6E642069 
 15253      6E746572 
 15254 0ca9 0A00     		.ascii	"\012\000"
 15255 0cab 00       		.space	1
 15256              	.LC72:
 15257 0cac 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 15257      6F6D6D69 
 15257      74656F66 
 15257      20737461 
 15257      7465203D 
 15258              	.LC73:
 15259 0cc4 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 15259      6E656C20 
 15259      53657420 
 15259      57726170 
 15259      55702066 
 15260 0cf1 000000   		.space	3
 15261              	.LC74:
 15262 0cf4 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 15262      69742045 
 15262      4F462066 
 15262      61696C65 
 15262      64210D0A 
 15263 0d09 000000   		.space	3
 15264              	.LC75:
 15265 0d0c 49324363 		.ascii	"I2CcmdQue\000"
 15265      6D645175 
 15265      6500
 15266 0d16 0000     		.space	2
 15267              	.LC76:
 15268 0d18 33303A55 		.ascii	"30:UVC App Thread\000"
 15268      56432041 
 15268      70702054 
 15268      68726561 
 15268      6400
 15269 0d2a 0000     		.space	2
 15270              	.LC77:
 15271 0d2c 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 15271      56432041 
 15271      70702045 
 15271      50302054 
 15271      68726561 
 15272 0d42 0000     		.space	2
 15273              	.LC78:
 15274 0d44 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 15274      32432041 
 15274      70702043 
 15274      54524C20 
 15274      54687265 
 15275 0d5b 00       		.bss
 15276              		.align	2
 15277              		.set	.LANCHOR0,. + 0
 15280              	glFxUVCEvent:
 15281 0000 00000000 		.space	40
 15281      00000000 
 15281      00000000 
 15281      00000000 
 15281      00000000 
 15284              	glEp0Buffer:
 15285 0028 00000000 		.space	32
 15285      00000000 
 15285      00000000 
 15285      00000000 
 15285      00000000 
 15288              	usbSpeed:
 15289 0048 00       		.space	1
 15290 0049 000000   		.space	3
 15293              	glCommitCtrl:
 15294 004c 00000000 		.space	32
 15294      00000000 
 15294      00000000 
 15294      00000000 
 15294      00000000 
 15297              	is60Hz:
 15298 006c 00000000 		.space	4
 15301              	setRes:
 15302 0070 00       		.space	1
 15305              	setstilRes:
 15306 0071 00       		.space	1
 15309              	stiflag:
 15310 0072 00       		.space	1
 15311 0073 00       		.space	1
 15314              	fb:
 15315 0074 0000     		.space	2
 15318              	pb:
 15319 0076 0000     		.space	2
 15322              	pbc:
 15323 0078 0000     		.space	2
 15324 007a 0000     		.space	2
 15327              	hitFV:
 15328 007c 00000000 		.space	4
 15331              	prodCount:
 15332 0080 0000     		.space	2
 15335              	consCount:
 15336 0082 0000     		.space	2
 15339              	streamingStarted:
 15340 0084 00000000 		.space	4
 15343              	gpif_initialized:
 15344 0088 00000000 		.space	4
 15347              	isUsbConnected:
 15348 008c 00000000 		.space	4
 15351              	clearFeatureRqtReceived:
 15352 0090 00000000 		.space	4
 15355              	I2CCMDArry:
 15356 0094 00000000 		.space	12
 15356      00000000 
 15356      00000000 
 15359              	curFlag:
 15360 00a0 00000000 		.space	64
 15360      00000000 
 15360      00000000 
 15360      00000000 
 15360      00000000 
 15363              	CamMode:
 15364 00e0 00       		.space	1
 15367              	IMcount.8214:
 15368 00e1 00       		.space	1
 15369 00e2 0000     		.space	2
 15372              	uvcAppThread:
 15373 00e4 00000000 		.space	168
 15373      00000000 
 15373      00000000 
 15373      00000000 
 15373      00000000 
 15376              	uvcAppEP0Thread:
 15377 018c 00000000 		.space	168
 15377      00000000 
 15377      00000000 
 15377      00000000 
 15377      00000000 
 15380              	i2cAppThread:
 15381 0234 00000000 		.space	168
 15381      00000000 
 15381      00000000 
 15381      00000000 
 15381      00000000 
 15384              	pbcpbak:
 15385 02dc 0000     		.space	2
 15388              	pbcbak:
 15389 02de 0000     		.space	2
 15392              	pbbak:
 15393 02e0 0000     		.space	2
 15396              	fbbak:
 15397 02e2 0000     		.space	2
 15400              	testSnap:
 15401 02e4 00       		.space	1
 15402 02e5 000000   		.text
 15403              	.Letext0:
 15404              		.file 2 "c:\\program files (x86)\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\s
 15405              		.file 3 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15406              		.file 4 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyfx
 15407              		.file 5 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_p
 15408              		.file 6 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_a
 15409              		.file 7 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15410              		.file 8 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15411              		.file 9 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15412              		.file 10 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15413              		.file 11 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15414              		.file 12 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15415              		.file 13 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15416              		.file 14 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15417              		.file 15 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15418              		.file 16 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15419              		.file 17 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15420              		.file 18 "../sensor.h"
 15421              		.file 19 "../cmdqu.h"
 15422              		.file 20 "../uvc.h"
 15423              		.file 21 "../cyfxgpif2config.h"
 15424              		.file 22 "../cyfxgpif2config_usb2_720.h"
 15425              		.file 23 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:16     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:19     .text:00000000 I2CCmdCb
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:57     .text:00000030 $d
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:63     .text:0000003c $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:65     .text:0000003c UVCHandleVideoStreamingRqts
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:211    .text:00000190 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:218    .text:000001a0 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:404    .text:00000374 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:411    .text:00000384 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:742    .text:000006ec $d
                            *COM*:00000002 wValue
                            *COM*:00000001 bRequest
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:763    .text:00000734 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:766    .text:00000734 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:935    .text:00000894 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:941    .text:000008a4 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:1054   .text:00000974 $d
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:1065   .text:00000994 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:1068   .text:00000994 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:1303   .text:00000b24 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000e8 glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:1313   .text:00000b40 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:1315   .text:00000b40 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:1530   .text:00000cbc $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:1541   .text:00000ccc $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:1543   .text:00000ccc CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:1901   .text:00000f88 $d
                            *COM*:00000002 wLength
                            *COM*:00000002 wIndex
                            *COM*:00000001 bmReqType
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:1919   .text:00000fb4 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:1922   .text:00000fb4 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:2150   .text:000011b8 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:2158   .text:000011cc $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:2161   .text:000011cc setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:2229   .text:00001248 getShutCtrl
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:2254   .text:00001264 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:2267   .text:0000128c $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:2368   .text:00001364 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:2376   .text:00001378 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:2379   .text:00001378 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:2574   .text:000014f4 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:2624   .text:000015b0 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:2677   .text:00001628 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:2726   .text:000016e4 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:4188   .text:00002350 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:4213   .text:000023a8 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:4772   .text:000028f8 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:4778   .text:00002908 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:5654   .text:00003028 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:5801   .text:00003150 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:5814   .text:00003178 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:6230   .text:000035a8 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:6241   .text:000035c8 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:6511   .text:0000385c $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:6523   .text:00003880 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:6526   .text:00003880 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:6827   .text:00003b3c $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:6834   .text:00003b4c $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:6837   .text:00003b4c CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:6881   .text:00003b90 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:6886   .text:00003b98 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:6889   .text:00003b98 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:6917   .text:00003bb4 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:6921   .text:00003bb8 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:6924   .text:00003bb8 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:7709   .text:00004234 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:7715   .text:00004244 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:8190   .text:0000462c $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12199  .text:00006524 CyFxGpifCB
                            *COM*:000000ac glChHandleInterStat
                            *COM*:00000004 glInterStaBuffer
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:8249   .text:00004704 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:8252   .text:00004704 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:8321   .text:0000477c $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:8329   .text:0000478c $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:10040  .text:00005660 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:10069  .text:000056b8 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12231  .text:00006558 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12244  .text:00006584 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12249  .text:00006594 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12254  .text:000065a4 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12302  .text:000065fc $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12312  .text:00006610 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12315  .text:00006610 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12468  .text:00006758 $d
                            *COM*:00000038 cmdQuMux
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12485  .text.startup:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12488  .text.startup:00000000 main
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:13814  .data:000004ec glUVCHeader
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12833  .data:00000060 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12754  .data:0000001c glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12818  .data:00000054 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12724  .data:00000000 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12784  .data:00000038 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15339  .bss:00000084 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15351  .bss:00000090 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15288  .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15347  .bss:0000008c isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15384  .bss:000002dc pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15388  .bss:000002de pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15392  .bss:000002e0 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15396  .bss:000002e2 fbbak
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15322  .bss:00000078 pbc
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15318  .bss:00000076 pb
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15314  .bss:00000074 fb
                            *COM*:00000038 timMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15400  .bss:000002e4 testSnap
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:14489  .data:000007a8 snapButFlag
                            *COM*:000000e8 glChHandleStillStream
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12697  .rodata:0000013c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:14494  .data:000007ac CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:14573  .data:000008dc CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:14724  .data:00000970 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:14835  .data:00000b20 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12684  .rodata:00000120 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:14846  .data:00000b30 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:14925  .data:00000c60 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:14944  .data:00000c70 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15019  .data:00000d90 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12628  .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12632  .rodata:00000000 ShutSp
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12647  .rodata:00000020 pEXTSenCtrl
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:13873  .data:00000520 EXTShutter
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:14093  .data:000005e8 EXTAexModGainlev
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:13895  .data:00000534 EXTShutlev
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:13829  .data:000004f8 EXTBLCWinPos
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:13851  .data:0000050c EXTBLCWeight
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:13917  .data:00000548 EXTExHyster
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:13939  .data:0000055c EXTExCtrlSped
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:13961  .data:00000570 EXTEnhanceMode
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:13983  .data:00000584 EXTEnhanceGain
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:14005  .data:00000598 EXTEnhanceSTED
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:14027  .data:000005ac EXT2DNRGain
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:14049  .data:000005c0 EXT2DNRSTED
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:14071  .data:000005d4 EXTGammaCor
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12710  .rodata:00000158 ShutValueArry
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12720  .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12813  .data:00000052 ROIMode
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:12848  .data:0000006c ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:13171  .data:000001ec CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:14115  .data:000005fc WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:14122  .data:00000600 PUCBLC
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:14144  .data:00000614 PUCSharp
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:14166  .data:00000628 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15026  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15276  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15280  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15284  .bss:00000028 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15293  .bss:0000004c glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15297  .bss:0000006c is60Hz
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15301  .bss:00000070 setRes
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15305  .bss:00000071 setstilRes
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15309  .bss:00000072 stiflag
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15327  .bss:0000007c hitFV
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15331  .bss:00000080 prodCount
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15335  .bss:00000082 consCount
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15343  .bss:00000088 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15355  .bss:00000094 I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15359  .bss:000000a0 curFlag
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15363  .bss:000000e0 CamMode
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15367  .bss:000000e1 IMcount.8214
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15372  .bss:000000e4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15376  .bss:0000018c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccGxpfjX.s:15380  .bss:00000234 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
CyU3PDebugPrint
_txe_event_flags_set
CyU3PUsbSendEP0Data
CyU3PUsbStall
CyU3PUsbGetEP0Data
SensorSetIrisControl
_tx_thread_sleep
_txe_timer_create
_tx_time_get
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
_txe_timer_change
SensorSetControl
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyFx3BusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbAckSetup
SensorWrite2B
SensorRead2B
SensorWrite2B2
cmdSet
memcpy
SensorGetControl
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PUsbGetSpeed
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PDmaMultiChannelSetWrapUp
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
