   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB26:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      **** CyBool_t        streamingRecove = CyFalse;              /* start streaming again */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static CyBool_t stream_start = CyFalse;
 214:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 215:../uvc.c      ****                                                            the current video frame. */
 216:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 217:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 218:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 219:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 220:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 221:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 222:../uvc.c      **** 
 223:../uvc.c      **** /************ control parameters array ***********
 224:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 225:../uvc.c      ****  *    e.g.
 226:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 227:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 228:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 229:../uvc.c      ****  **************************************************/
 230:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 231:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 232:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 233:../uvc.c      **** 		{/*0*/BLCModeRegAct       , BLCModeRegAct        , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,
 234:../uvc.c      **** 		{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 235:../uvc.c      **** 		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1, 
 236:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 237:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 238:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 239:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 240:../uvc.c      **** 		{/*7*/SharpnessReg1       , SharpnessReg1        , 2,    0,    0,  255,    0, 1, 0, 3, 0,  32, 0,
 241:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 242:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 243:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 244:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 245:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 246:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 247:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 248:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 249:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 253:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 254:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 255:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 256:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 257:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 258:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 259:../uvc.c      **** 		{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 260:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 261:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 262:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 263:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 264:../uvc.c      **** 		/**********************************
 265:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 266:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 267:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 268:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 269:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 270:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 271:../uvc.c      **** 		 *
 272:../uvc.c      **** 		 *********************************/
 273:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 274:../uvc.c      **** };
 275:../uvc.c      **** #if 1 // the new control structure
 276:../uvc.c      **** /* the processing unit control request */
 277:../uvc.c      **** //		{ 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,   0, I2C_EAGLESDP_ADDR,  CyTrue, CyFalse,
 278:../uvc.c      **** 
 279:../uvc.c      **** volatile static SensorCtrl PUCBLC =
 280:../uvc.c      **** 		{BLCModeRegAct,		//Reg1: the command register address1
 281:../uvc.c      **** 		 BLCModeRegGain,	//Reg2: the command register address2
 282:../uvc.c      **** 		 2,					//UVCLn: the command length
 283:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 284:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 285:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 286:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 287:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 288:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 289:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 290:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 291:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 292:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 293:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 294:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 295:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 296:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 297:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 298:../uvc.c      **** 		}; //
 299:../uvc.c      **** //volatile static SensorCtrl PUCBright;
 300:../uvc.c      **** //volatile static SensorCtrl PUCContrast;
 301:../uvc.c      **** //volatile static SensorCtrl PUCGain;
 302:../uvc.c      **** //volatile static SensorCtrl PUCPLFreq;
 303:../uvc.c      **** //volatile static SensorCtrl PUCHueC;
 304:../uvc.c      **** //volatile static SensorCtrl PUCSaturation;
 305:../uvc.c      **** volatile static SensorCtrl PUCSharp =
 306:../uvc.c      **** 		{SharpnessReg1,		//Reg1: the command register address1
 307:../uvc.c      **** 		 SharpnessReg2,		//Reg2: the command register address2
 308:../uvc.c      **** 		 2,					//UVCLn: the command length
 309:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 310:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 311:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 312:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 313:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 314:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 315:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 316:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 317:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 318:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 319:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 320:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 321:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 322:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 323:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 324:../uvc.c      **** 		}; //sharpness, Reg1: 0-disable & 1-enable; Reg2: 0x00~0xFF.
 325:../uvc.c      **** //volatile static SensorCtrl PUCWBLC; //?
 326:../uvc.c      **** //volatile static SensorCtrl PUCDZoom;
 327:../uvc.c      **** 
 328:../uvc.c      **** volatile static SensorCtrl *pPUCSenCtrl[0x10] = {
 329:../uvc.c      **** 	&PUCBLC,
 330:../uvc.c      **** 	0, //&PUCBright,
 331:../uvc.c      **** 	0, //&PUCContrast,
 332:../uvc.c      **** 	0, //&PUCGain (AGC?)
 333:../uvc.c      **** 	0, //&PUCPLFreq,
 334:../uvc.c      **** 	0, //&PUCHueC,
 335:../uvc.c      **** 	0, //&PUCSaturation,
 336:../uvc.c      **** 	&PUCSharp,
 337:../uvc.c      **** 	0, //&PUCGamGain,
 338:../uvc.c      **** 	0, //&PUCWBMd,
 339:../uvc.c      **** 	0, //UVCCtlID10,
 340:../uvc.c      **** 	0, //&PUCWBLC,
 341:../uvc.c      **** 	0, //UVCCtlID12,
 342:../uvc.c      **** 	0, //UVCCtlID13,
 343:../uvc.c      **** 	0, //&PUCDZoom,
 344:../uvc.c      **** 	0 //UVCCtlID15
 345:../uvc.c      **** };
 346:../uvc.c      **** 
 347:../uvc.c      **** /* the Camera terminal control request */
 348:../uvc.c      **** //volatile static SensorCtrl CTCAutoExMode;
 349:../uvc.c      **** //volatile static SensorCtrl CTCExposureTAbs;
 350:../uvc.c      **** //volatile static SensorCtrl CTCFocusRel;
 351:../uvc.c      **** //volatile static SensorCtrl CTCIrisAbs;
 352:../uvc.c      **** //volatile static SensorCtrl CTCOPZoomAbs;
 353:../uvc.c      **** 
 354:../uvc.c      **** /* the Extentsion control request */
 355:../uvc.c      **** volatile static SensorCtrl EXTShutter =
 356:../uvc.c      **** 		{ShutterReg,		//Reg1: the command register address1
 357:../uvc.c      **** 		 0x02/*ShutterReg*/,		//Reg2: the command register address2
 358:../uvc.c      **** 		 2,					//UVCLn: the command length
 359:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 360:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 361:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 362:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 363:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 364:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 365:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 366:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 367:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 368:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 369:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 370:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 371:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 372:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 373:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 374:../uvc.c      **** 		}; //shutter control 0 ~ 0x12
 375:../uvc.c      **** /*volatile static SensorCtrl EXTSensUp =
 376:../uvc.c      **** 		{SenseUpReg,		//Reg1: the command register address1
 377:../uvc.c      **** 		 SenseUpReg,		//Reg2: the command register address2
 378:../uvc.c      **** 		 2,					//UVCLn: the command length
 379:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 380:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 381:../uvc.c      **** 		 9,					//UVCMaxLo: the command maximum value low byte
 382:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 383:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 384:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 385:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 386:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 387:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 388:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 389:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 390:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 391:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 392:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 393:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 394:../uvc.c      **** 		};	// sense up control 0 ~ 0x09
 395:../uvc.c      **** */
 396:../uvc.c      **** /*volatile static SensorCtrl EXTMirror =
 397:../uvc.c      **** 		{MirrModeReg,		//Reg1: the command register address1
 398:../uvc.c      **** 		 MirrModeReg,		//Reg2: the command register address2
 399:../uvc.c      **** 		 2,					//UVCLn: the command length
 400:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 401:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 402:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 403:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 404:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 405:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 406:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 407:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 408:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 409:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 410:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 411:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 412:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 413:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 414:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 415:../uvc.c      **** 		};	// mirror mode control 0 ~ 0x03
 416:../uvc.c      **** */
 417:../uvc.c      **** //volatile static SensorCtrl EXT3DnoiseReduceMode;
 418:../uvc.c      **** //volatile static SensorCtrl EXT3DNoiseLev;
 419:../uvc.c      **** //volatile static SensorCtrl EXTDayNightMode;
 420:../uvc.c      **** //volatile static SensorCtrl EXTDayNightdely;
 421:../uvc.c      **** //volatile static SensorCtrl EXTDayNightlev;
 422:../uvc.c      **** //volatile static SensorCtrl EXTNightDaylev;
 423:../uvc.c      **** volatile static SensorCtrl EXTAexModGainlev =
 424:../uvc.c      **** 		{ShutterReg/*AExModeReg*/,		//Reg1: the command register address1
 425:../uvc.c      **** 		 0x03/*AExAGCReg*/,			//Reg2: the command register address2
 426:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 427:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 428:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 429:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 430:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 431:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 432:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 433:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 434:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 435:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 436:../uvc.c      **** 		 63, 				//UVCDefVHi: the command default data value high byte
 437:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 438:../uvc.c      **** 		 63,				//UVCCurVHi: the command current data value high byte
 439:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 440:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 441:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 442:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 443:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 444:../uvc.c      **** //volatile static SensorCtrl EXTExpReflev;
 445:../uvc.c      **** //volatile static SensorCtrl EXTCamMode;
 446:../uvc.c      **** //volatile static SensorCtrl EXTSnapshot;
 447:../uvc.c      **** //volatile static SensorCtrl EXTSensorPare;
 448:../uvc.c      **** //volatile static SensorCtrl EXTI2Ccmd;
 449:../uvc.c      **** volatile static SensorCtrl EXTBLCWinPos =
 450:../uvc.c      **** 		{BLCPosReg,			//Reg1: the command register address1
 451:../uvc.c      **** 		 BLCSizeReg,		//Reg2: the command register address2
 452:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 453:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 454:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 455:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 456:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 457:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 458:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 459:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 460:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 461:../uvc.c      **** 		 0x66,				//UVCDefVLo: the command default data value low byte
 462:../uvc.c      **** 		 0x66, 				//UVCDefVHi: the command default data value high byte
 463:../uvc.c      **** 		 0x66,				//UVCCurVLo: the command current data value low byte
 464:../uvc.c      **** 		 0x66,				//UVCCurVHi: the command current data value high byte
 465:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 466:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 467:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 468:../uvc.c      **** 		}; //BLC position: [7:4]:Top/bottom [3:0]:left/right; BLC size: [7:4]:height [3:0]:width.
 469:../uvc.c      **** //{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 470:../uvc.c      **** volatile static SensorCtrl EXTBLCWeight =
 471:../uvc.c      **** 		{BLCModeRegGain,			//Reg1: the command register address1
 472:../uvc.c      **** 		 BLCModeRegGain,			//Reg2: the command register address2
 473:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 474:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 475:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 476:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 477:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 478:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 479:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 480:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 481:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 482:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 483:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 484:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 485:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 486:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 487:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 488:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 489:../uvc.c      **** 		}; //
 490:../uvc.c      **** //volatile static SensorCtrl EXTBLCGrid;
 491:../uvc.c      **** //{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 492:../uvc.c      **** 
 493:../uvc.c      **** volatile static SensorCtrl EXTShutlev =
 494:../uvc.c      **** 		{0x02/*AExModeReg2*/,		//Reg1: the command register address1
 495:../uvc.c      **** 		 0x12/*ShutterFineReg*/,			//Reg2: the command register address2
 496:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 497:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 498:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 499:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 500:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 501:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 502:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 503:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 504:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 505:../uvc.c      **** 		 63,				//UVCDefVLo: the command default data value low byte
 506:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 507:../uvc.c      **** 		 63,					//UVCCurVLo: the command current data value low byte
 508:../uvc.c      **** 		 0,				//UVCCurVHi: the command current data value high byte
 509:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 510:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 511:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 512:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 513:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 514:../uvc.c      **** 
 515:../uvc.c      **** volatile static SensorCtrl *pEXTSenCtrl[0x20] = {//Extension control
 516:../uvc.c      **** 		&EXTShutter,
 517:../uvc.c      **** 		0, //&EXTSensUp,
 518:../uvc.c      **** 		0, //&EXTMirror,
 519:../uvc.c      **** 		0, //&EXT3DnoiseReduceMode,
 520:../uvc.c      **** 		0, //&EXT3DNoiseLev,
 521:../uvc.c      **** 		0, //&EXTDayNightMode,
 522:../uvc.c      **** 		0, //&EXTDayNightdely,
 523:../uvc.c      **** 		0, //&EXTDayNightlev,
 524:../uvc.c      **** 		0, //&EXTNightDaylev,
 525:../uvc.c      **** 		&EXTAexModGainlev,
 526:../uvc.c      **** 		0, //&EXTExpReflev,
 527:../uvc.c      **** 		&EXTShutlev,
 528:../uvc.c      **** 		0, //&EXTCamMode,
 529:../uvc.c      **** 		0, //&EXTSnapshot,
 530:../uvc.c      **** 		0, //&EXTSensorPare,
 531:../uvc.c      **** 		0, //&EXTI2Ccmd,
 532:../uvc.c      **** 		0, //&Ext1CtlID0 = 0x20,
 533:../uvc.c      **** 		0, //&Ext1CtlID1,
 534:../uvc.c      **** 		0, //&Ext1CtlID2,
 535:../uvc.c      **** 		0, //&Ext1CtlID3,
 536:../uvc.c      **** 		&EXTBLCWinPos,   		// back light compensation range
 537:../uvc.c      **** 		&EXTBLCWeight,  	    // back light compensation weight (gain) factor
 538:../uvc.c      **** 		0, //&EXTBLCGrid,    	// back light compensation grid state
 539:../uvc.c      **** 		0
 540:../uvc.c      **** };
 541:../uvc.c      **** 
 542:../uvc.c      **** #endif //end of the new control structure
 543:../uvc.c      **** 
 544:../uvc.c      **** #ifndef CAM720
 545:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 546:../uvc.c      **** #else
 547:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 548:../uvc.c      **** #endif
 549:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
 550:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
 551:../uvc.c      **** 
 552:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 553:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 554:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 555:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 556:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 557:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    0,    0,    0xff, 0xff, 1, 0, 3
 558:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   0x80,
 559:../uvc.c      **** 		{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 560:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 561:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 562:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 563:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 564:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 565:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 566:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 567:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 568:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 569:../uvc.c      **** };
 570:../uvc.c      **** 
 571:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 572:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 573:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 574:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 575:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 576:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 577:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 578:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 579:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 580:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 581:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 582:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 583:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 584:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 585:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 586:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 587:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 588:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 589:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 590:../uvc.c      **** };
 591:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 592:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 593:../uvc.c      **** static uint16_t ShutSp[16]={33333, 16667, 8333, 4000, 2000, 1000, 500, 200, 100, 10, 0}; // in micr
 594:../uvc.c      **** static uint8_t curFlag[64]={0}; //the curFlag for each controls current records available. 0: unabl
 595:../uvc.c      **** 
 596:../uvc.c      **** static uint8_t debugData[64][2] = {{0,0}};
 597:../uvc.c      **** static uint8_t dbgIdx = 2;
 598:../uvc.c      **** static uint8_t value[32][2] = {{0,0}};
 599:../uvc.c      **** static uint8_t valIdx = 1;
 600:../uvc.c      **** 
 601:../uvc.c      **** /*
 602:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 603:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 604:../uvc.c      ****  */
 605:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 606:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 607:../uvc.c      **** };
 608:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 609:../uvc.c      **** 		0 //bit0:0-read; 1-write. bit1:number of addr. bit2:device addr. bit3:board addr. bit4:DSP addr. 
 610:../uvc.c      **** 			//bit8:number of data. bit9:data0. bit10:data1. ......
 611:../uvc.c      **** };
 612:../uvc.c      **** 
 613:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 614:../uvc.c      **** 
 615:../uvc.c      **** void I2CCmdHandler(){
 616:../uvc.c      **** 	uint8_t buf[2];
 617:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 618:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 619:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 620:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 621:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 622:../uvc.c      **** 	uint8_t i;
 623:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 624:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 625:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 626:../uvc.c      **** 	if((I2CCMDArry[2]==0x70) && (I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01
 627:../uvc.c      **** 	{
 628:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 629:../uvc.c      **** 		if(is60Hz==CyFalse)
 630:../uvc.c      **** 			{
 631:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 632:../uvc.c      **** 			}
 633:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 634:../uvc.c      **** 
 635:../uvc.c      **** 	}
 636:../uvc.c      **** 	else if(I2CCMDArry[2]!=0x70){//for get debug data
 637:../uvc.c      **** 		if(CmdType == 0){ //read
 638:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 639:../uvc.c      **** 		if(I2CCMDArry[3] == 0){
 640:../uvc.c      **** 			if(I2CCMDArry[2] == 0){
 641:../uvc.c      **** 				I2CCMDArry[10] = debugData[0][0]; //number of frame
 642:../uvc.c      **** 				I2CCMDArry[9] = debugData[0][1];  // stream status
 643:../uvc.c      **** 			}
 644:../uvc.c      **** 			else if (I2CCMDArry[2] == 1){
 645:../uvc.c      **** 				I2CCMDArry[9] = debugData[1][0];  // abort code
 646:../uvc.c      **** 				I2CCMDArry[10] = dbgIdx; // freeze count
 647:../uvc.c      **** 			}
 648:../uvc.c      **** 			else if(I2CCMDArry[2] == 17){
 649:../uvc.c      **** 				CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 650:../uvc.c      **** 				apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_OR);
 651:../uvc.c      **** 
 652:../uvc.c      **** 				if (apiRetStatus != CY_U3P_SUCCESS)
 653:../uvc.c      **** 				{
 654:../uvc.c      **** 					CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetStatus);
 655:../uvc.c      **** 				}
 656:../uvc.c      **** 
 657:../uvc.c      **** 			}
 658:../uvc.c      **** 			else {
 659:../uvc.c      **** 				I2CCMDArry[9] = debugData[I2CCMDArry[2]][0];  // bmRequest
 660:../uvc.c      **** 				I2CCMDArry[10] = debugData[I2CCMDArry[2]][1]; // bRequest
 661:../uvc.c      **** 			}
 662:../uvc.c      **** 		}else if(I2CCMDArry[3] == 1){
 663:../uvc.c      **** 			{
 664:../uvc.c      **** 				I2CCMDArry[9] = value[I2CCMDArry[2]][0];  // bmRequest
 665:../uvc.c      **** 				I2CCMDArry[10] = value[I2CCMDArry[2]][1]; // bRequest
 666:../uvc.c      **** 			}
 667:../uvc.c      **** 
 668:../uvc.c      **** 		}
 669:../uvc.c      **** 
 670:../uvc.c      **** 		I2CCMDArry[11] = 0xff;
 671:../uvc.c      **** 		//CmdType = 0xf;//end the routine
 672:../uvc.c      **** 		}else if(CmdType == 1){ //clear debug data
 673:../uvc.c      **** 			debugData[0][0] = 0x00;  debugData[0][1] = 0x00;//
 674:../uvc.c      **** 			debugData[1][0] = 0x00;  debugData[1][1] = 0x00;//
 675:../uvc.c      **** 			debugData[15][0] = 0x00;  debugData[15][1] = 0x00;//
 676:../uvc.c      **** 			dbgIdx = 2;
 677:../uvc.c      **** 			valIdx = 1;
 678:../uvc.c      **** 			value[0][1] = valIdx;
 679:../uvc.c      **** 			//CmdType = 0xf;//end the routine
 680:../uvc.c      **** 		}
 681:../uvc.c      **** 		CmdType = 0xf;//end the routine
 682:../uvc.c      **** 	}
 683:../uvc.c      **** 	if(CmdType == 0)//I2C read
 684:../uvc.c      **** 	{
 685:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 686:../uvc.c      **** #if 0 //for debugging
 687:../uvc.c      **** 		/* test still image operation */
 688:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 689:../uvc.c      **** 			snapButFlag = 0; //press
 690:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 691:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 692:../uvc.c      **** 			snapButFlag = 0xf; //release
 693:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 694:../uvc.c      **** 		}
 695:../uvc.c      **** 
 696:../uvc.c      **** 		/* end of the test */
 697:../uvc.c      **** #endif
 698:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 699:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 700:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 701:../uvc.c      **** 				if(CmdDataLen == 2){
 702:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 703:../uvc.c      **** 				}
 704:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 705:../uvc.c      **** 		}else{//not support currently
 706:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 707:../uvc.c      **** 		}
 708:../uvc.c      **** 	}else if(CmdType == 1){
 709:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 710:../uvc.c      **** 			if(CmdRegLen == 2){
 711:../uvc.c      **** 				for(i = 0; i<4; i++)
 712:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 713:../uvc.c      **** 			}
 714:../uvc.c      **** 			else{
 715:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 716:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 717:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 718:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 719:../uvc.c      **** 				}
 720:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 721:../uvc.c      **** 				//if(I2CCMDArry[5] == 1) stream_start = CyFalse; //clear stream start flag
 722:../uvc.c      **** 			}
 723:../uvc.c      **** 		}else{//not support currently
 724:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 725:../uvc.c      **** 		}
 726:../uvc.c      **** 
 727:../uvc.c      **** 	}
 728:../uvc.c      **** }
 729:../uvc.c      **** 
 730:../uvc.c      **** /************************************
 731:../uvc.c      ****  * set Iris mode
 732:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 733:../uvc.c      ****  */
 734:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 735:../uvc.c      **** 	uint8_t dataIdx = 0;
 736:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 740:../uvc.c      **** }
 741:../uvc.c      **** 
 742:../uvc.c      **** 
 743:../uvc.c      **** 
 744:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 745:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 746:../uvc.c      **** 	uint16_t NumLn;
 747:../uvc.c      **** 	uint16_t fRate, shutTm;
 748:../uvc.c      **** 	uint8_t LnVal;
 749:../uvc.c      **** 	switch (Data){
 750:../uvc.c      **** 	case 1:
 751:../uvc.c      **** 	case 2:
 752:../uvc.c      **** 	case 3:
 753:../uvc.c      **** 	case 4:
 754:../uvc.c      **** 	case 5:
 755:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 756:../uvc.c      **** 		fRate = 30;
 757:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 758:../uvc.c      **** 		if(NumLn > 1944)
 759:../uvc.c      **** 			NumLn =1944;
 760:../uvc.c      **** 		else if(NumLn < 8)
 761:../uvc.c      **** 			NumLn = 8;
 762:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 763:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 764:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 765:../uvc.c      **** 		break;
 766:../uvc.c      **** 	case 6:
 767:../uvc.c      **** 	case 7:
 768:../uvc.c      **** 	case 8:
 769:../uvc.c      **** 	case 9:
 770:../uvc.c      **** 	case 10:
 771:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 772:../uvc.c      **** 		fRate = 30;
 773:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 774:../uvc.c      **** 		if(NumLn > 1944)
 775:../uvc.c      **** 			NumLn =1944;
 776:../uvc.c      **** 		else if(NumLn < 8)
 777:../uvc.c      **** 			NumLn = 8;
 778:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 779:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 780:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 781:../uvc.c      **** 		break;
 782:../uvc.c      **** 	case 0: //auto
 783:../uvc.c      **** 	default:
 784:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 785:../uvc.c      **** 		LnVal = 1;
 786:../uvc.c      **** 		break;
 787:../uvc.c      **** 	}
 788:../uvc.c      **** 	return LnVal;
 789:../uvc.c      **** }
 790:../uvc.c      **** 
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 792:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 793:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 794:../uvc.c      ****     uint16_t readCount;
 795:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID, AxMode;
 796:../uvc.c      ****     uint8_t devAdd;
 797:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 798:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 799:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 800:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 801:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 802:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 803:../uvc.c      ****     }else{
 804:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 805:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 806:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 807:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 808:../uvc.c      ****     }
 809:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 810:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 811:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 812:../uvc.c      **** #endif
 813:../uvc.c      ****     reqData = bRequest;
 814:../uvc.c      ****     /*
 815:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 816:../uvc.c      ****      */
 817:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 818:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 819:../uvc.c      ****     	goto EndofSet;
 820:../uvc.c      ****     }
 821:../uvc.c      ****     switch (bRequest)
 822:../uvc.c      **** 		 {
 823:../uvc.c      **** 
 824:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 825:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 826:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 827:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 828:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 829:../uvc.c      **** 			  break;
 830:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 831:../uvc.c      **** 
 832:../uvc.c      **** 			 switch(CtrlID)
 833:../uvc.c      **** 			 {
 834:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 835:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 836:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 837:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 838:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 839:../uvc.c      **** 			 	 		 }else{
 840:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 841:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 842:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 843:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 844:../uvc.c      **** 			 	 		 }
 845:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 846:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 847:../uvc.c      **** 						 break;
 848:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 849:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 850:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 851:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 852:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 853:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 854:../uvc.c      **** 			 	 		 }else{
 855:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 856:../uvc.c      **** 			 	 			glEp0Buffer[0] = Data0;
 857:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 858:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 859:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 860:../uvc.c      **** 			 	 		 }
 861:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 862:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 863:../uvc.c      **** 			 	 		 break;
 864:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 865:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[CtrlID][13];
 866:../uvc.c      **** 								 //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 867:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[CtrlID][14];
 868:../uvc.c      **** 								 //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 869:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 870:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 871:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 872:../uvc.c      **** 			 	 		 }else{
 873:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 874:../uvc.c      **** 			 	 			if(Data0&0x80)
 875:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 876:../uvc.c      **** 			 	 			else
 877:../uvc.c      **** 			 	 				glEp0Buffer[0] = 0;
 878:../uvc.c      **** 			 	 			ExUCtrlParArry[CtrlID-0x20][13] = glEp0Buffer[0];
 879:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 880:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 881:../uvc.c      **** 			 	 		 }
 882:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 883:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 884:../uvc.c      **** 			 	 		 break;
 885:../uvc.c      **** 			 	 }
 886:../uvc.c      **** 			 	 case ExtShutCtlID0:
 887:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 888:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 889:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 890:../uvc.c      **** 
 891:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 892:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 893:../uvc.c      **** 					 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 894:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 895:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 896:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 897:../uvc.c      **** 		 	 		 }else{
 898:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 899:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
 900:../uvc.c      **** 		 	 			Data1 = (Data0&0x70)>>4;
 901:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 902:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 903:../uvc.c      **** 		 	 			//curFlag[CtrlID] = CyTrue;
 904:../uvc.c      **** 						CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
 905:../uvc.c      **** 
 906:../uvc.c      **** 		 	 		 }
 907:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 908:../uvc.c      **** 					 sendData1 = Data1;//glEp0Buffer[1];
 909:../uvc.c      **** 					 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, send
 910:../uvc.c      **** 			 		 break;
 911:../uvc.c      **** 			 	 case ExtCtlShutlevCtlID11:
 912:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 913:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 914:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 915:../uvc.c      **** 
 916:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 917:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 918:../uvc.c      **** 					 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 919:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 920:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 921:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 922:../uvc.c      **** 		 	 		 }else{
 923:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 924:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 925:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 926:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 927:../uvc.c      **** 		 	 		 }
 928:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 929:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
 930:../uvc.c      **** 			 		 break;
 931:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 932:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 933:../uvc.c      **** 
 934:../uvc.c      **** 					 if(CamMode == 1){//720p
 935:../uvc.c      **** 						if(sendData >= 3){
 936:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 937:../uvc.c      **** 							sendData = 0; //set back to default
 938:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 939:../uvc.c      **** 						}
 940:../uvc.c      **** 						sendData += 4;
 941:../uvc.c      **** 					 }
 942:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 943:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 944:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 945:../uvc.c      **** 					 break;
 946:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 947:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 948:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 949:../uvc.c      **** 			 		 }
 950:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 951:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 952:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 953:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 954:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 955:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 956:../uvc.c      **** #endif
 957:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 958:../uvc.c      **** 			 		 {
 959:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 960:../uvc.c      **** 			 		 }
 961:../uvc.c      **** 			 		 break;
 962:../uvc.c      **** 				 case ExtAexModCtlID9:
 963:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 964:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 965:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 966:../uvc.c      **** 
 967:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 968:../uvc.c      **** 					 //glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 969:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 970:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 971:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 972:../uvc.c      **** 		 	 		 }else{
 973:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 974:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 975:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 976:../uvc.c      **** 
 977:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 978:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 979:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 980:../uvc.c      **** 		 	 		 }
 981:../uvc.c      **** 					 //sendData = glEp0Buffer[0];
 982:../uvc.c      **** 					 //sendData1 = glEp0Buffer[1];
 983:../uvc.c      **** 
 984:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 985:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 986:../uvc.c      **** 					 //glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 987:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 988:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 989:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 990:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 991:../uvc.c      **** 					 break;
 992:../uvc.c      **** 
 993:../uvc.c      **** 			 	 case BrgtCtlID1:
 994:../uvc.c      **** 			 		 /* cancel for 5MP w/b camera
 995:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 996:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 997:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 998:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 999:../uvc.c      **** 					 }else{
1000:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
1001:../uvc.c      **** 					 }
1002:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
1003:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1004:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1005:../uvc.c      **** 					 */
1006:../uvc.c      **** 
1007:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1008:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
1009:../uvc.c      **** 		 	 		 }else{
1010:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1011:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
1012:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1013:../uvc.c      **** 		 	 		 }
1014:../uvc.c      **** 					 //Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode()
1015:../uvc.c      **** 					  if(Data0&0x80){
1016:../uvc.c      **** 						  Data0 = ~Data0;
1017:../uvc.c      **** 					  }else{
1018:../uvc.c      **** 						  Data0 = Data0 + 0x80;
1019:../uvc.c      **** 					  }
1020:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
1021:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1022:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1023:../uvc.c      **** 			 		 break;
1024:../uvc.c      **** 				 case HueCtlID5:
1025:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1026:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
1027:../uvc.c      **** 		 	 		 }else{
1028:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1029:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
1030:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1031:../uvc.c      **** 		 	 		 }
1032:../uvc.c      **** 
1033:../uvc.c      **** 					 glEp0Buffer[0] = Data0 + GREEN_BASE;
1034:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1035:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1036:../uvc.c      **** 					 break;
1037:../uvc.c      **** 				 case WBTLevCtlID11:
1038:../uvc.c      **** 					 //glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
1039:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1040:../uvc.c      **** 					 //glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
1041:../uvc.c      **** 					 //glEp0Buffer[3] = 0;
1042:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1043:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
1044:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
1045:../uvc.c      **** 		 	 		 }else{
1046:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1047:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
1048:../uvc.c      **** 						glEp0Buffer[0] = Data0;
1049:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
1050:../uvc.c      **** 						glEp0Buffer[2] = Data1;
1051:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
1052:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1053:../uvc.c      **** 		 	 		 }
1054:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1055:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1056:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1057:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
1058:../uvc.c      **** 					 break;
1059:../uvc.c      **** 				 case BLCCtlID0:
1060:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1061:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1062:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1063:../uvc.c      **** 		 	 		 }else{
1064:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1065:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x1;
1066:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1067:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1068:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1069:../uvc.c      **** 		 	 		 }
1070:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1071:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1072:../uvc.c      **** 					 break;
1073:../uvc.c      **** 				 case ShapCtlID7:
1074:../uvc.c      **** 					 //glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;
1075:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1076:../uvc.c      **** 					 //glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1077:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1078:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1079:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1080:../uvc.c      **** 		 	 		 }else{
1081:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1082:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1083:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1084:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1085:../uvc.c      **** 		 	 		 }
1086:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1087:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1088:../uvc.c      **** 					 break;
1089:../uvc.c      **** 				 case ExtExRefCtlID10:
1090:../uvc.c      **** 				 case ConsCtlID2:
1091:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[ExtExRefCtlID10][13];//SensorGetControl(RegAdd0, devAdd);
1092:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//SensorGetControl(RegAdd0, devAdd);
1093:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1094:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1095:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
1096:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1097:../uvc.c      **** 		 	 		 }else{
1098:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1099:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
1100:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1101:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1102:../uvc.c      **** 		 	 		 }
1103:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1104:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1105:../uvc.c      **** 					 break;
1106:../uvc.c      **** 				 case WBTMdCtlID9:
1107:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1108:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
1109:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1110:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1111:../uvc.c      **** 		 	 		 }else{
1112:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1113:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1114:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1115:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1116:../uvc.c      **** 
1117:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1118:../uvc.c      **** 		 	 		 }
1119:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1120:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1121:../uvc.c      **** 					 break;
1122:../uvc.c      **** 				 case MFreqCtlID4:
1123:../uvc.c      **** 
1124:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1125:../uvc.c      **** 
1126:../uvc.c      **** 		 	 			 if(is60Hz)
1127:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
1128:../uvc.c      **** 		 	 			 else
1129:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 1;
1130:../uvc.c      **** 
1131:../uvc.c      **** 						 //glEp0Buffer[0] = glEp0Buffer[0] & 0x80;    // get two least Bits
1132:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1133:../uvc.c      **** 		 	 		 }else{
1134:../uvc.c      **** 		 	 			Data0 = SensorGetControl(0x1, devAdd); //get resolution bit7 for main frequency information
1135:../uvc.c      **** 		 	 			glEp0Buffer[0] = (Data0&0x80)>>7;
1136:../uvc.c      **** 		 	 			glEp0Buffer[0]++;
1137:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1138:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1139:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1140:../uvc.c      **** 		 	 		 }
1141:../uvc.c      **** 
1142:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1143:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1144:../uvc.c      **** 					 break;
1145:../uvc.c      **** 				 case SaturCtlID6:
1146:../uvc.c      **** 				 default:
1147:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1148:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1149:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1150:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
1151:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1152:../uvc.c      **** 		 	 		 }else{
1153:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1154:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1155:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1156:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1157:../uvc.c      **** 		 	 		 }
1158:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1159:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1160:../uvc.c      **** 
1161:../uvc.c      **** 					 //sendData = glEp0Buffer[0];
1162:../uvc.c      **** 					 break;
1163:../uvc.c      **** 			 }
1164:../uvc.c      **** 
1165:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1166:../uvc.c      **** 
1167:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1168:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
1169:../uvc.c      **** #endif
1170:../uvc.c      **** 			  break;
1171:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
1172:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1173:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
1174:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
1175:../uvc.c      **** 		 	 }
1176:../uvc.c      **** 
1177:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1178:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
1179:../uvc.c      **** 				 glEp0Buffer[1] = 0;
1180:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
1181:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1182:../uvc.c      **** 			 }else
1183:../uvc.c      **** 			 {
1184:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
1185:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
1186:../uvc.c      **** 			 }
1187:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1188:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1189:../uvc.c      **** 			  break;
1190:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1191:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1192:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
1193:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
1194:../uvc.c      **** 		 	 }
1195:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1196:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
1197:../uvc.c      **** 				 glEp0Buffer[1] = 0;
1198:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
1199:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1200:../uvc.c      **** 			 }else
1201:../uvc.c      **** 			 {
1202:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
1203:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
1204:../uvc.c      **** 			 }
1205:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1206:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1207:../uvc.c      **** 			  break;
1208:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1209:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1210:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
1211:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
1212:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1213:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1214:../uvc.c      **** 		 	 }
1215:../uvc.c      **** 		 	 else{
1216:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
1217:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
1218:../uvc.c      **** 			  glEp0Buffer[2] = 0;
1219:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1220:../uvc.c      **** 		 	 }
1221:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1222:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1223:../uvc.c      **** 			  break;
1224:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1225:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1226:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
1227:../uvc.c      **** 		 	 }
1228:../uvc.c      **** 		 	 else{
1229:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
1230:../uvc.c      **** 		 	 }
1231:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1232:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1233:../uvc.c      **** 			  Len = 1;
1234:../uvc.c      **** 			  break;
1235:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1236:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1237:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
1238:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
1239:../uvc.c      **** 		 	 }
1240:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1241:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
1242:../uvc.c      **** 				  glEp0Buffer[1] = 0;
1243:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
1244:../uvc.c      **** 				  glEp0Buffer[3] = 0;
1245:../uvc.c      **** 			 }else{
1246:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
1247:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
1248:../uvc.c      **** 			 }
1249:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1250:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1251:../uvc.c      **** 			  break;
1252:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1253:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1254:../uvc.c      **** 				  glEp0Buffer, &readCount);
1255:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
1256:../uvc.c      **** 			   {
1257:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
1258:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
1259:../uvc.c      **** 				  getData = glEp0Buffer[0];
1260:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
1261:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1262:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
1263:../uvc.c      **** #endif
1264:../uvc.c      **** 				  switch(CtrlID)
1265:../uvc.c      **** 					 {
1266:../uvc.c      **** 						 case ExtShutCtlID0:
1267:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
1268:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
1269:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
1270:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
1271:../uvc.c      **** #if 1	// register setting directly
1272:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
1273:../uvc.c      **** 						     {
1274:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
1275:../uvc.c      **** 						    	 dataIdx = 0;
1276:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1277:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
1278:../uvc.c      **** 								 dataIdx++;
1279:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1280:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1281:../uvc.c      **** 						     }
1282:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
1283:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
1284:../uvc.c      **** 						     break;
1285:../uvc.c      **** #else	// old fashion
1286:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
1287:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
1288:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
1289:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
1290:../uvc.c      **** 									 }else{
1291:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
1292:../uvc.c      **** 									 }
1293:../uvc.c      **** 								 }
1294:../uvc.c      **** 							 }else{
1295:../uvc.c      **** 								 Data1 = Data0 - 1;
1296:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
1297:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
1298:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
1299:../uvc.c      **** 									 }else{
1300:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
1301:../uvc.c      **** 									 }
1302:../uvc.c      **** 								 }
1303:../uvc.c      **** 								 if(Data1 < 8){
1304:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
1305:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
1306:../uvc.c      **** 								 }else{
1307:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
1308:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
1309:../uvc.c      **** 								 }
1310:../uvc.c      **** 							 }
1311:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
1312:../uvc.c      **** 							 dataIdx = 0;
1313:../uvc.c      **** 							 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
1314:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1315:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
1316:../uvc.c      **** 							 if(AxMode){
1317:../uvc.c      **** 								 dataIdx++;
1318:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
1319:../uvc.c      **** 								 dataIdx++;
1320:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustme
1321:../uvc.c      **** 							 }
1322:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1323:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
1324:../uvc.c      **** 							 break;
1325:../uvc.c      **** #endif
1326:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
1327:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1328:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1329:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
1330:../uvc.c      **** 						     dataIdx = 0;
1331:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1332:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
1333:../uvc.c      **** 							 {
1334:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
1335:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1336:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1337:../uvc.c      **** 								 /*
1338:../uvc.c      **** 								 dataIdx++;
1339:../uvc.c      **** 								 if(getData == 1 || getData == 3){
1340:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x80, dataIdx);  //set AEX mode2 to 0x80 (fixed shu
1341:../uvc.c      **** 									 dataIdx++;
1342:../uvc.c      **** 								 }else{
1343:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x00, dataIdx);  //set AEX mode2 to 0x00
1344:../uvc.c      **** 									 dataIdx++;
1345:../uvc.c      **** 								 }
1346:../uvc.c      **** 								 */
1347:../uvc.c      **** 							 }
1348:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
1349:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
1350:../uvc.c      **** 								 if(getData == 2 || getData == 3){
1351:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
1352:../uvc.c      **** 								 }
1353:../uvc.c      **** 							 }
1354:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1355:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1356:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1357:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
1358:../uvc.c      **** 							 break;
1359:../uvc.c      **** 
1360:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level
1361:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1362:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1363:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
1364:../uvc.c      **** 						     dataIdx = 0;
1365:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1366:../uvc.c      **** 							 if(0&&EXTShutlev.UVCCurVLo != getData)
1367:../uvc.c      **** 							 {
1368:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). CtrlParArr
1369:../uvc.c      **** 								 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1370:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1371:../uvc.c      **** 								 dataIdx++;
1372:../uvc.c      **** 							 }
1373:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
1374:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
1375:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
1376:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
1377:../uvc.c      **** 									 dataIdx++;
1378:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
1379:../uvc.c      **** 								 }
1380:../uvc.c      **** 							 }
1381:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1382:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1383:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1384:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
1385:../uvc.c      **** 							 break;
1386:../uvc.c      **** 						 case ExtCamMCtlID12:
1387:../uvc.c      **** 							 dataIdx = 0;
1388:../uvc.c      **** 							 if(Data0 <= 3){
1389:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
1390:../uvc.c      **** 								 Data1 = Data0;
1391:../uvc.c      **** 							 }else{
1392:../uvc.c      **** 								 CamMode = 1; //set 720p flag
1393:../uvc.c      **** 								 Data1 = Data0-4;
1394:../uvc.c      **** 							 }
1395:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1396:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
1397:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1398:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1399:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1400:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1401:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
1402:../uvc.c      **** 							 break;
1403:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
1404:../uvc.c      **** 							 dataIdx = 0;
1405:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
1406:../uvc.c      **** 								 Data0 = 1;
1407:../uvc.c      **** 							 }else{ //save current sensor parameters.
1408:../uvc.c      **** 								 Data0 = 0;
1409:../uvc.c      **** 							 }
1410:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1411:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1412:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1413:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1414:../uvc.c      **** 							 break;
1415:../uvc.c      **** 						 case ExtI2CCtlID15:
1416:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
1417:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
1418:../uvc.c      **** 					 		 }
1419:../uvc.c      **** 					 		I2CCmdHandler();
1420:../uvc.c      **** 							 break;
1421:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
1422:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
1423:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
1424:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
1425:../uvc.c      **** 
1426:../uvc.c      **** 							 dataIdx = 0;
1427:../uvc.c      **** #if 0 //seperate version
1428:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
1429:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
1430:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1431:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
1432:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
1433:../uvc.c      **** 							 }else{ //disable BLD window
1434:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
1435:../uvc.c      **** 							 }
1436:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
1437:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
1438:../uvc.c      **** 							 dataIdx++;
1439:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
1440:../uvc.c      **** 							 dataIdx++;
1441:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
1442:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
1443:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
1444:../uvc.c      **** 							 dataIdx++;
1445:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
1446:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1447:../uvc.c      **** #else //combination version
1448:../uvc.c      **** 							 //Data0 = Data0&0x7F; //mask window show flag bit.
1449:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1450:../uvc.c      **** 						     /* end test */
1451:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
1452:../uvc.c      **** 							 dataIdx++;
1453:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
1454:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1455:../uvc.c      **** 							 getData1 = Data1;
1456:../uvc.c      **** #endif
1457:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
1458:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
1459:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1460:../uvc.c      **** 							 break;
1461:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
1462:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
1463:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
1464:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
1465:../uvc.c      **** 
1466:../uvc.c      **** 							 dataIdx = 0;
1467:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1468:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
1469:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1470:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
1471:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
1472:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1473:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1474:../uvc.c      **** 							 break;
1475:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
1476:../uvc.c      **** 							 dataIdx = 0;
1477:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
1478:../uvc.c      **** 							 if(Data0 == 1){
1479:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
1480:../uvc.c      **** 							 }else{
1481:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
1482:../uvc.c      **** 							 }
1483:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1484:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
1485:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1486:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1487:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
1488:../uvc.c      **** 							 break;
1489:../uvc.c      **** 				  	  	 case BrgtCtlID1:
1490:../uvc.c      **** #if 0 //cancel for 5MP w/b camera
1491:../uvc.c      **** 							 dataIdx = 0;
1492:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1493:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1494:../uvc.c      **** 							  if(Data0&0x80){
1495:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
1496:../uvc.c      **** 							  }else{
1497:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
1498:../uvc.c      **** 							  }
1499:../uvc.c      **** 							 Data1 |= ~0x03;
1500:../uvc.c      **** 							 Data1 &= 0xC7;
1501:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
1502:../uvc.c      **** 						  	 dataIdx++;
1503:../uvc.c      **** 
1504:../uvc.c      **** 							 Data0 = (Data0 << 2);
1505:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
1506:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1507:../uvc.c      **** 
1508:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1509:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
1510:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1511:../uvc.c      **** #endif
1512:../uvc.c      **** 							 dataIdx = 0;
1513:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1514:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1515:../uvc.c      **** 							  if(Data0&0x80){
1516:../uvc.c      **** 								  Data0 = Data0 - 0x80;
1517:../uvc.c      **** 							  }else{
1518:../uvc.c      **** 								  Data0 = ~Data0;
1519:../uvc.c      **** 							  }
1520:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
1521:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1522:../uvc.c      **** 
1523:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1524:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1525:../uvc.c      **** 
1526:../uvc.c      **** 
1527:../uvc.c      **** 							 break;
1528:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
1529:../uvc.c      **** 							 dataIdx = 0;
1530:../uvc.c      **** 
1531:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1532:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
1533:../uvc.c      **** 							 dataIdx++;
1534:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
1535:../uvc.c      **** 							 dataIdx++;
1536:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
1537:../uvc.c      **** 							 dataIdx++;
1538:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
1539:../uvc.c      **** 							 dataIdx++;
1540:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
1541:../uvc.c      **** 							 dataIdx++;
1542:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
1543:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1544:../uvc.c      **** 
1545:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
1546:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1547:../uvc.c      **** 							 break;
1548:../uvc.c      **** 						 case SaturCtlID6:
1549:../uvc.c      **** 							 dataIdx = 0;
1550:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
1551:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1552:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1553:../uvc.c      **** 							 dataIdx++;
1554:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
1555:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1556:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1557:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1558:../uvc.c      **** 							 break;
1559:../uvc.c      **** 
1560:../uvc.c      **** 						 case WBTLevCtlID11:
1561:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
1562:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
1563:../uvc.c      **** 							 dataIdx = 0;
1564:../uvc.c      **** 
1565:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1566:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1567:../uvc.c      **** 							 dataIdx++;
1568:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
1569:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1570:../uvc.c      **** 
1571:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
1572:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
1573:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1574:../uvc.c      **** 							 break;
1575:../uvc.c      **** 						 case MFreqCtlID4:
1576:../uvc.c      **** 							 dataIdx = 0;
1577:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1578:../uvc.c      **** 							 Data0 = Data0 - 1;
1579:../uvc.c      **** 							 is60Hz = Data0;
1580:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
1581:../uvc.c      **** 							 {
1582:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
1583:../uvc.c      **** 								 is60Hz = CyFalse;
1584:../uvc.c      **** 							 }
1585:../uvc.c      **** 							 else if(Data0 >2)
1586:../uvc.c      **** 							 {
1587:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
1588:../uvc.c      **** 								 is60Hz = CyTrue;
1589:../uvc.c      **** 							 }
1590:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
1591:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
1592:../uvc.c      **** 							 {
1593:../uvc.c      **** 								 //CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1594:../uvc.c      **** 			                       switch (setRes)
1595:../uvc.c      **** 			                         {
1596:../uvc.c      **** 			                         	case 1: //1944
1597:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
1598:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1599:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1600:../uvc.c      **** 			                         		break;
1601:../uvc.c      **** 			                         	case 2: //1080
1602:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
1603:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1604:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1605:../uvc.c      **** 			                         		break;
1606:../uvc.c      **** 			                         	case 3: //720
1607:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
1608:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1609:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1610:../uvc.c      **** 			                         		break;
1611:../uvc.c      **** 			                         	case 4: //VGA
1612:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
1613:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1614:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1615:../uvc.c      **** 			                         	default:
1616:../uvc.c      **** 			                         		break;
1617:../uvc.c      **** 			                         }
1618:../uvc.c      **** 								 //CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1619:../uvc.c      **** 							 }
1620:../uvc.c      **** 
1621:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1622:../uvc.c      **** 							 break;
1623:../uvc.c      **** 					 	 case BLCCtlID0:
1624:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1625:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1626:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1627:../uvc.c      **** 						     dataIdx = 0;
1628:../uvc.c      **** 
1629:../uvc.c      **** 							 //CtrlParArry[CtrlID][13] = Data0;
1630:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1631:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1632:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1633:../uvc.c      **** 
1634:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
1635:../uvc.c      **** 							 {
1636:../uvc.c      **** 								 if(Data0 < 3){
1637:../uvc.c      **** 					 				 Data0 += 4;
1638:../uvc.c      **** 					 			 }else{
1639:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1640:../uvc.c      **** 									Data0 = 4; //set to default.
1641:../uvc.c      **** 					 			 }
1642:../uvc.c      **** 					 		 }
1643:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0;
1644:../uvc.c      **** 							 dataIdx = 0;
1645:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1646:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1647:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1648:../uvc.c      **** 
1649:../uvc.c      **** 					 		 break;
1650:../uvc.c      **** 					 	 case ShapCtlID7:
1651:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1652:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1653:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1654:../uvc.c      **** 						     dataIdx = 0;
1655:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1656:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1657:../uvc.c      **** 							 if(Data0 != 0){
1658:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1659:../uvc.c      **** #ifdef COLOR
1660:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Second: set enhancement valu
1661:../uvc.c      **** #else
1662:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
1663:../uvc.c      **** 								 dataIdx++;
1664:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
1665:../uvc.c      **** #endif
1666:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1667:../uvc.c      **** 							 }else{
1668:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1669:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
1670:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1671:../uvc.c      **** 
1672:../uvc.c      **** 							 }
1673:../uvc.c      **** 							 break;
1674:../uvc.c      **** 						 case ExtExRefCtlID10:
1675:../uvc.c      **** 						 case ConsCtlID2:
1676:../uvc.c      **** 							 dataIdx = 0;
1677:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1678:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1679:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1680:../uvc.c      **** 
1681:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
1682:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
1683:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][13] = Data0;  //it's canceled as the both is the same contro
1684:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][16] = CyTrue;
1685:../uvc.c      **** 
1686:../uvc.c      **** 							 break;
1687:../uvc.c      **** 						 default:
1688:../uvc.c      **** 							 dataIdx = 0;
1689:../uvc.c      **** 
1690:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1691:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1692:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1693:../uvc.c      **** 
1694:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1695:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1696:../uvc.c      **** 							 break;
1697:../uvc.c      **** 					 }
1698:../uvc.c      **** 			   }else{
1699:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
1700:../uvc.c      **** 			   }
1701:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1702:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
1703:../uvc.c      **** #endif
1704:../uvc.c      **** 
1705:../uvc.c      **** 			  break;
1706:../uvc.c      **** 		  default:
1707:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1708:../uvc.c      **** 			  break;
1709:../uvc.c      **** 		 }
1710:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
1711:../uvc.c      **** }
1712:../uvc.c      **** /************** CT control requests handler *************************/
1713:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
1714:../uvc.c      **** 
1715:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
1716:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
1717:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1718:../uvc.c      ****     uint16_t readCount;
1719:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
1720:../uvc.c      ****     uint16_t diff, value, diffRd;
1721:../uvc.c      ****     uint8_t i, shutter, index;
1722:../uvc.c      ****     diff = 0xffff;
1723:../uvc.c      ****     shutter = 1;
1724:../uvc.c      ****     index = 1;
1725:../uvc.c      **** 
1726:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
1727:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
1728:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
1729:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
1730:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
1731:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1732:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
1733:../uvc.c      **** #endif
1734:../uvc.c      ****     reqData = bRequest;
1735:../uvc.c      **** 
1736:../uvc.c      ****     switch (bRequest)
1737:../uvc.c      **** 		 {
1738:../uvc.c      **** 
1739:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
1740:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1741:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1742:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1743:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1744:../uvc.c      **** 			  break;
1745:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1746:../uvc.c      **** 
1747:../uvc.c      **** 			 switch(CtrlID)
1748:../uvc.c      **** 			 {
1749:../uvc.c      **** 				 default:
1750:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
1751:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
1752:../uvc.c      **** 					 glEp0Buffer[2] = 0;
1753:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1754:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1755:../uvc.c      **** 					 break;
1756:../uvc.c      **** 			 }
1757:../uvc.c      **** 
1758:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1759:../uvc.c      **** 
1760:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1761:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
1762:../uvc.c      **** #endif
1763:../uvc.c      **** 			  break;
1764:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
1765:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
1766:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
1767:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
1768:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1769:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1771:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1772:../uvc.c      **** 			  break;
1773:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1774:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
1775:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
1776:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1777:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1778:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1779:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1780:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1781:../uvc.c      **** 			  break;
1782:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1783:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1784:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1785:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1786:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1787:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1788:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1789:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1790:../uvc.c      **** 			  break;
1791:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1792:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1793:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1794:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1795:../uvc.c      **** 			  Len = 1;
1796:../uvc.c      **** 			  break;
1797:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1798:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1799:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1800:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1801:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1802:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1803:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1804:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1805:../uvc.c      **** 			  break;
1806:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1807:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1808:../uvc.c      **** 			  glEp0Buffer, &readCount);
1809:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1810:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1811:../uvc.c      **** 			  value = Data1;
1812:../uvc.c      **** 
1813:../uvc.c      **** 			  switch(CtrlID)
1814:../uvc.c      **** 			  {
1815:../uvc.c      **** 		  	      case AutoExMCtlID1:
1816:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1817:../uvc.c      **** 
1818:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1819:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1820:../uvc.c      **** 				    getData = glEp0Buffer[0];
1821:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1822:../uvc.c      **** 		  		    switch (getData){
1823:../uvc.c      **** 						case 1:
1824:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1825:../uvc.c      **** 							break;
1826:../uvc.c      **** 						case 2:
1827:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1828:../uvc.c      **** 							dataIdx = 0;
1829:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1830:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1831:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1832:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1833:../uvc.c      **** 
1834:../uvc.c      **** 							break;
1835:../uvc.c      **** 						case 4:
1836:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1837:../uvc.c      **** 							break;
1838:../uvc.c      **** 						case 8:
1839:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1840:../uvc.c      **** 			  		    	dataIdx = 0;
1841:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1842:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1843:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1844:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1845:../uvc.c      **** 							break;
1846:../uvc.c      **** 		  		    }
1847:../uvc.c      **** #if 0
1848:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1849:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1850:../uvc.c      **** 						  dataIdx = 0;
1851:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1852:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1853:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1854:../uvc.c      **** 		  		    }
1855:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1856:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1857:../uvc.c      **** 		  		    }
1858:../uvc.c      **** #endif
1859:../uvc.c      **** 				    break;
1860:../uvc.c      **** 
1861:../uvc.c      **** 			  	  case ExTmACtlID3:
1862:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1863:../uvc.c      **** 
1864:../uvc.c      **** 					  value = (value << 8)|Data0;
1865:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1866:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1867:../uvc.c      **** 					  {
1868:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1869:../uvc.c      **** 						  {
1870:../uvc.c      **** 							if(value > ShutValueArry[i]){
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1872:../uvc.c      **** 							}else{
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1874:../uvc.c      **** 							}
1875:../uvc.c      **** 							  if(diff > diffRd){
1876:../uvc.c      **** 								  diff = diffRd;
1877:../uvc.c      **** 								  index = i;
1878:../uvc.c      **** 							  }
1879:../uvc.c      **** 						  }
1880:../uvc.c      **** 						  shutter = shutter+index;
1881:../uvc.c      **** 
1882:../uvc.c      **** 						  dataIdx = 0;
1883:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1884:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1885:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1886:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1887:../uvc.c      **** 
1888:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1889:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1890:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1891:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1892:../uvc.c      **** 					  }else{
1893:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1894:../uvc.c      **** 					  }
1895:../uvc.c      **** 					  getData = glEp0Buffer[0];
1896:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1897:../uvc.c      **** 					  break;
1898:../uvc.c      **** 			  	  case IriACtlID7:
1899:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1900:../uvc.c      **** 					  {
1901:../uvc.c      **** 							 dataIdx = 0;
1902:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1903:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
1904:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1905:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1906:../uvc.c      **** 
1907:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1908:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1909:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1910:../uvc.c      **** 					  }else{
1911:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1912:../uvc.c      **** 					  }
1913:../uvc.c      **** 					  getData = glEp0Buffer[0];
1914:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1915:../uvc.c      **** 
1916:../uvc.c      **** 					  break;
1917:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1918:../uvc.c      **** 					  getData = glEp0Buffer[0];
1919:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1920:../uvc.c      **** #if 1
1921:../uvc.c      **** 					  dataIdx = 0;
1922:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1923:../uvc.c      **** 					  if(getData == 1)
1924:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1925:../uvc.c      **** 					  else if(getData == 0xff)
1926:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1927:../uvc.c      **** 					  else
1928:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
1929:../uvc.c      **** 					  //dataIdx++;
1930:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1931:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1932:../uvc.c      **** #endif
1933:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1934:../uvc.c      **** 					  break;
1935:../uvc.c      **** 
1936:../uvc.c      **** 			  	  default:
1937:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1938:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1939:../uvc.c      **** 			  		 break;
1940:../uvc.c      **** 			  }
1941:../uvc.c      **** 			  break;
1942:../uvc.c      **** 		  default:
1943:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1944:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1945:../uvc.c      **** 			  break;
1946:../uvc.c      **** 		 }
1947:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1948:../uvc.c      **** 
1949:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1950:../uvc.c      **** }
1951:../uvc.c      **** 
1952:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1953:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1954:../uvc.c      **** {
1955:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
1956:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
1957:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1958:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1959:../uvc.c      **** 
1960:../uvc.c      ****     CtrlID = BrgtCtlID1;
1961:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1962:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1963:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1964:../uvc.c      ****     Data1 = Data0;
1965:../uvc.c      **** 
1966:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1967:../uvc.c      ****     if(Data1&0x80){
1968:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1969:../uvc.c      ****     }else{
1970:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1971:../uvc.c      ****     }
1972:../uvc.c      ****     Data0 = (Data0 << 2);
1973:../uvc.c      **** 
1974:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1975:../uvc.c      **** 
1976:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1977:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1978:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1979:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1980:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1981:../uvc.c      **** 
1982:../uvc.c      ****     CtrlID = ConsCtlID2;
1983:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1984:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1985:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1986:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1987:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1988:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
1989:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1990:../uvc.c      **** 
1991:../uvc.c      ****     CtrlID = HueCtlID5;
1992:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1993:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1994:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1995:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1998:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1999:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
2000:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
2001:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
2002:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
2003:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
2004:../uvc.c      **** 
2005:../uvc.c      ****     CtrlID = SaturCtlID6;
2006:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2007:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2008:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
2009:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
2010:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
2011:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2012:../uvc.c      **** 
2013:../uvc.c      ****     CtrlID = ShapCtlID7;
2014:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2015:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2016:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2017:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
2018:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2019:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2020:../uvc.c      **** 
2021:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
2022:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
2023:../uvc.c      **** 	return;
2024:../uvc.c      **** }
2025:../uvc.c      **** 
2026:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
2027:../uvc.c      **** void
2028:../uvc.c      **** CyFxUVCAddHeader (
2029:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
2030:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
2031:../uvc.c      ****         )
2032:../uvc.c      **** {
2033:../uvc.c      ****     /* Copy header to buffer */
2034:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2035:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
2036:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
2037:../uvc.c      **** 
2038:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
2039:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
2040:../uvc.c      ****     {
2041:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
2042:../uvc.c      ****     }
2043:../uvc.c      **** }
2044:../uvc.c      **** 
2045:../uvc.c      **** 
2046:../uvc.c      **** /* Application Error Handler */
2047:../uvc.c      **** void
2048:../uvc.c      **** CyFxAppErrorHandler (
2049:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
2050:../uvc.c      ****         )
2051:../uvc.c      **** {
2052:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
2053:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
2054:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
2055:../uvc.c      **** 
2056:../uvc.c      ****        This function can be modified to take additional error handling actions such
2057:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
2058:../uvc.c      ****      */
2059:../uvc.c      ****     for (;;)
2060:../uvc.c      ****     {
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
2063:../uvc.c      ****     }
2064:../uvc.c      **** }
2065:../uvc.c      **** 
2066:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
2067:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
2068:../uvc.c      ****  */
2069:../uvc.c      **** static void
2070:../uvc.c      **** CyFxUVCApplnAbortHandler (
2071:../uvc.c      ****         void)
2072:../uvc.c      **** {
2073:../uvc.c      **** 	uint32_t flag;
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
2075:../uvc.c      **** 	{
2076:../uvc.c      ****         /* Clear the Video Stream Request Event */
2077:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
2078:../uvc.c      **** 
2079:../uvc.c      ****         /* Set Video Stream Abort Event */
2080:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
2081:../uvc.c      **** 	}
2082:../uvc.c      **** }
2083:../uvc.c      **** 
2084:../uvc.c      **** /* This is the Callback function to handle the USB Events */
2085:../uvc.c      **** static void
2086:../uvc.c      **** CyFxUVCApplnUSBEventCB (
2087:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
2088:../uvc.c      ****         uint16_t             evdata  /* Event data */
2089:../uvc.c      ****         )
2090:../uvc.c      **** {
2091:../uvc.c      ****     switch (evtype)
2092:../uvc.c      ****     {
2093:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
2094:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
2095:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2096:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x01; //set bit0
2097:../uvc.c      ****             gpif_initialized = 0;
2098:../uvc.c      ****             streamingStarted = CyFalse;
2099:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2100:../uvc.c      ****             break;
2101:../uvc.c      **** 
2102:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
2103:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
2104:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2105:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x02; //set bit1
2106:../uvc.c      ****             gpif_initialized = 0;
2107:../uvc.c      ****             streamingStarted = CyFalse;
2108:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2109:../uvc.c      ****             break;
2110:../uvc.c      **** 
2111:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
2112:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
2113:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2114:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x04; //set bit2
2115:../uvc.c      ****             gpif_initialized = 0;
2116:../uvc.c      ****             isUsbConnected = CyFalse;
2117:../uvc.c      ****             streamingStarted = CyFalse;
2118:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2119:../uvc.c      ****             break;
2120:../uvc.c      **** 
2121:../uvc.c      **** #ifdef BACKFLOW_DETECT
2122:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
2123:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
2124:../uvc.c      ****             break;
2125:../uvc.c      **** #endif
2126:../uvc.c      **** 
2127:../uvc.c      ****         default:
2128:../uvc.c      ****             break;
2129:../uvc.c      ****     }
2130:../uvc.c      **** }
2131:../uvc.c      **** 
2132:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
2133:../uvc.c      **** static CyBool_t
2134:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
2135:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
2136:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
2137:../uvc.c      ****         )
2138:../uvc.c      **** {
2139:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
2140:../uvc.c      ****     uint32_t status;
2141:../uvc.c      ****     //CyU3PDebugPrint (4, "The USB setup Requests and UVC events 0x%x, 0x%x\r\n", setupdat0, setupd
2142:../uvc.c      ****     /* Obtain Request Type and Request */
2143:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
2144:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
2145:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
2146:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
2147:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
2148:../uvc.c      ****     CyU3PDebugPrint (4, "bmReqType = 0x%x bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%
2149:../uvc.c      ****     		bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* additional debug message */
2150:../uvc.c      ****     if(dbgIdx < 63){
2151:../uvc.c      ****     	if(!((bmReqType == 0xa1) || (bmReqType == 0x80))){
2152:../uvc.c      **** 		debugData[dbgIdx][0] = bmReqType;
2153:../uvc.c      **** 		debugData[dbgIdx][1] = bRequest;
2154:../uvc.c      **** 		dbgIdx++;
2155:../uvc.c      **** 		debugData[63][1] = dbgIdx;}
2156:../uvc.c      ****     }else debugData[63][1] = 0xFF; //full symbol
2157:../uvc.c      **** 
2158:../uvc.c      ****     /* Check for UVC Class Requests */
2159:../uvc.c      ****     switch (bmReqType)
2160:../uvc.c      ****     {
2161:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
2162:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
2163:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
2164:../uvc.c      ****             switch (wIndex & 0xFF)
2165:../uvc.c      ****             {
2166:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
2167:../uvc.c      ****                     {
2168:../uvc.c      ****                         uvcHandleReq = CyTrue;
2169:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
2170:../uvc.c      ****                                 CYU3P_EVENT_OR);
2171:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2172:../uvc.c      ****                         {
2173:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
2174:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2175:../uvc.c      ****                         }
2176:../uvc.c      ****                     }
2177:../uvc.c      ****                     break;
2178:../uvc.c      **** 
2179:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
2180:../uvc.c      ****                     {
2181:../uvc.c      ****                         uvcHandleReq = CyTrue;
2182:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
2183:../uvc.c      ****                                 CYU3P_EVENT_OR);
2184:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2185:../uvc.c      ****                         {
2186:../uvc.c      ****                             /* Error handling */
2187:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
2188:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2189:../uvc.c      ****                         }
2190:../uvc.c      ****                     }
2191:../uvc.c      ****                     break;
2192:../uvc.c      **** 
2193:../uvc.c      ****                 default:
2194:../uvc.c      ****                     break;
2195:../uvc.c      ****             }
2196:../uvc.c      ****             break;
2197:../uvc.c      **** 
2198:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
2199:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
2200:../uvc.c      ****             {
2201:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
2202:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
2203:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
2204:../uvc.c      ****                 {
2205:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
2206:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
2207:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
2208:../uvc.c      ****                     gpif_initialized = 0;
2209:../uvc.c      ****                     streamingStarted = CyFalse;
2210:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
2211:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2212:../uvc.c      ****                     CyU3PBusyWait (100);
2213:../uvc.c      **** 
2214:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
2215:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2216:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2217:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2218:../uvc.c      ****                     CyU3PBusyWait (100);
2219:../uvc.c      **** 
2220:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
2221:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2222:../uvc.c      ****                     uvcHandleReq = CyTrue;
2223:../uvc.c      ****                     /* Complete Control request handshake */
2224:../uvc.c      ****                     CyU3PUsbAckSetup ();
2225:../uvc.c      ****                     /* Indicate stop streaming to main thread */
2226:../uvc.c      ****                     debugData[1][0] = debugData[1][0]|0x08; //set bit3
2227:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
2228:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
2229:../uvc.c      **** 
2230:../uvc.c      ****                 }
2231:../uvc.c      ****             }
2232:../uvc.c      ****             break;
2233:../uvc.c      **** 
2234:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
2235:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
2236:../uvc.c      ****             {
2237:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
2238:../uvc.c      ****                 {
2239:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
2240:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
2241:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
2242:../uvc.c      ****                 	 * has started. */
2243:../uvc.c      ****                     if (streamingStarted == CyTrue)
2244:../uvc.c      ****                     {
2245:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
2246:../uvc.c      **** 
2247:../uvc.c      ****                         /* Disable the GPIF state machine. */
2248:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
2249:../uvc.c      ****                         gpif_initialized = 0;
2250:../uvc.c      ****                         streamingStarted = CyFalse;
2251:../uvc.c      **** 
2252:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
2253:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2254:../uvc.c      ****                         CyU3PBusyWait (100);
2255:../uvc.c      **** 
2256:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
2257:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2258:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2259:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2260:../uvc.c      ****                         CyU3PBusyWait (100);
2261:../uvc.c      **** 
2262:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
2263:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2264:../uvc.c      **** 
2265:../uvc.c      ****                         uvcHandleReq = CyTrue;
2266:../uvc.c      ****                         /* Complete Control request handshake */
2267:../uvc.c      ****                         CyU3PUsbAckSetup ();
2268:../uvc.c      ****                         /* Indicate stop streaming to main thread */
2269:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
2270:../uvc.c      ****                         debugData[1][0] = debugData[1][0]|0x10; //set bit0
2271:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
2272:../uvc.c      ****                     }
2273:../uvc.c      ****                     else
2274:../uvc.c      ****                     {
2275:../uvc.c      ****                         uvcHandleReq = CyTrue;
2276:../uvc.c      ****                         CyU3PUsbAckSetup ();
2277:../uvc.c      ****                     }
2278:../uvc.c      ****                 }
2279:../uvc.c      ****             }
2280:../uvc.c      ****             break;
2281:../uvc.c      **** 
2282:../uvc.c      ****         default:
2283:../uvc.c      ****             break;
2284:../uvc.c      ****     }
2285:../uvc.c      **** 
2286:../uvc.c      ****     /* Return status of request handling to the USB driver */
2287:../uvc.c      ****     return uvcHandleReq;
2288:../uvc.c      **** }
2289:../uvc.c      **** 
2290:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
2291:../uvc.c      **** 
2292:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
2293:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
2294:../uvc.c      ****  */
2295:../uvc.c      **** void
2296:../uvc.c      **** CyFxUvcApplnDmaCallback (
2297:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
2298:../uvc.c      ****         CyU3PDmaCbType_t      type,
2299:../uvc.c      ****         CyU3PDmaCBInput_t    *input
2300:../uvc.c      ****         )
2301:../uvc.c      **** {
2302:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
2303:../uvc.c      **** #if 1
2304:../uvc.c      ****     CyU3PReturnStatus_t status;
2305:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
2306:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
2307:../uvc.c      **** 
2308:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2309:../uvc.c      ****     {
2310:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
2311:../uvc.c      ****             {
2312:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
2313:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
2314:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2315:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
2316:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2317:../uvc.c      ****                 	stiflag = 0x03;
2318:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
2319:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2320:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2321:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2322:../uvc.c      ****                 }
2323:../uvc.c      **** #endif
2324:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
2325:../uvc.c      ****                 fb++;
2326:../uvc.c      ****             }
2327:../uvc.c      ****             else
2328:../uvc.c      ****             {
2329:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
2330:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
2331:../uvc.c      ****                 pb++;
2332:../uvc.c      ****                 pbc = input->buffer_p.count;
2333:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
2334:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
2335:../uvc.c      ****                 //lineCount = 0; //res test
2336:../uvc.c      **** #if 1   //remove the still flag clearing here
2337:../uvc.c      ****                 if(stiflag == 0x0F){
2338:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2339:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2340:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2341:../uvc.c      ****                 	stiflag = 0xAA;
2342:../uvc.c      ****                 }
2343:../uvc.c      **** #endif
2344:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
2345:../uvc.c      ****             }
2346:../uvc.c      **** 
2347:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
2348:../uvc.c      ****             prodCount++;
2349:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2350:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
2351:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
2352:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
2353:../uvc.c      ****             {
2354:../uvc.c      ****                 prodCount--;
2355:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
2356:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
2357:../uvc.c      ****             }
2358:../uvc.c      ****     }
2359:../uvc.c      **** #endif
2360:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
2361:../uvc.c      ****     {
2362:../uvc.c      ****         consCount++;
2363:../uvc.c      ****         streamingStarted = CyTrue;
2364:../uvc.c      ****     }
2365:../uvc.c      **** }
2366:../uvc.c      **** 
2367:../uvc.c      **** /*
2368:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
2369:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
2370:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
2371:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
2372:../uvc.c      ****  * to commit the buffer.
2373:../uvc.c      ****  */
2374:../uvc.c      **** static uint8_t
2375:../uvc.c      **** CyFxUvcAppCommitEOF (
2376:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
2377:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
2378:../uvc.c      ****         )
2379:../uvc.c      **** {
2380:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2381:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
2382:../uvc.c      **** 
2383:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
2384:../uvc.c      **** 
2385:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2386:../uvc.c      ****     {
2387:../uvc.c      ****         switch (stateId)
2388:../uvc.c      ****         {
2389:../uvc.c      **** 
2390:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
2391:../uvc.c      ****             case FULL_BUF_IN_SCK1:
2392:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2393:../uvc.c      ****                 break;
2394:../uvc.c      **** 
2395:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
2396:../uvc.c      ****                 socket = 0;
2397:../uvc.c      ****                 break;
2398:../uvc.c      **** 
2399:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
2400:../uvc.c      ****                 socket = 1;
2401:../uvc.c      ****                 break;
2402:../uvc.c      **** 
2403:../uvc.c      ****             default:
2404:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2405:../uvc.c      ****                 /* Unexpected current state. Return error. */
2406:../uvc.c      ****             	//lineCount++;
2407:../uvc.c      ****             	return 1;
2408:../uvc.c      ****         }
2409:../uvc.c      ****     }
2410:../uvc.c      **** 
2411:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2412:../uvc.c      ****     {
2413:../uvc.c      ****         switch (stateId)
2414:../uvc.c      ****         {
2415:../uvc.c      **** #ifndef CAM720
2416:../uvc.c      **** #ifdef GPIFIIM
2417:../uvc.c      ****             case 13:
2418:../uvc.c      ****             case 24:
2419:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2420:../uvc.c      ****                 break;
2421:../uvc.c      **** 
2422:../uvc.c      ****             case 8:
2423:../uvc.c      ****                 socket = 0;
2424:../uvc.c      ****                 break;
2425:../uvc.c      **** 
2426:../uvc.c      ****             case 20:
2427:../uvc.c      ****                 socket = 1;
2428:../uvc.c      ****                 break;
2429:../uvc.c      **** #else
2430:../uvc.c      ****             case 11:
2431:../uvc.c      ****             case 18:
2432:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2433:../uvc.c      ****                 break;
2434:../uvc.c      **** 
2435:../uvc.c      ****             case 8:
2436:../uvc.c      ****                 socket = 0;
2437:../uvc.c      ****                 break;
2438:../uvc.c      **** 
2439:../uvc.c      ****             case 15:
2440:../uvc.c      ****                 socket = 1;
2441:../uvc.c      ****                 break;
2442:../uvc.c      **** #endif
2443:../uvc.c      **** #else
2444:../uvc.c      ****             case 11:
2445:../uvc.c      ****             case 18:
2446:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2447:../uvc.c      ****                 break;
2448:../uvc.c      **** 
2449:../uvc.c      ****             case 8:
2450:../uvc.c      ****                 socket = 0;
2451:../uvc.c      ****                 break;
2452:../uvc.c      **** 
2453:../uvc.c      ****             case 15:
2454:../uvc.c      ****                 socket = 1;
2455:../uvc.c      ****                 break;
2456:../uvc.c      **** 
2457:../uvc.c      **** #endif
2458:../uvc.c      ****              default:
2459:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2460:../uvc.c      ****                 /* Unexpected current state. Return error. */
2461:../uvc.c      ****                return 1;
2462:../uvc.c      ****         }
2463:../uvc.c      ****     }
2464:../uvc.c      **** 
2465:../uvc.c      ****     if (socket != 0xFF)
2466:../uvc.c      ****     {
2467:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
2468:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
2469:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
2470:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
2471:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
2472:../uvc.c      ****         {
2473:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
2474:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
2475:../uvc.c      ****         }
2476:../uvc.c      ****     }
2477:../uvc.c      **** 
2478:../uvc.c      ****     return 0;
2479:../uvc.c      **** }
2480:../uvc.c      **** 
2481:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
2482:../uvc.c      **** void
2483:../uvc.c      **** CyFxGpifCB (
2484:../uvc.c      ****         CyU3PGpifEventType event,
2485:../uvc.c      ****         uint8_t currentState
2486:../uvc.c      ****         )
2487:../uvc.c      **** {
2488:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
2489:../uvc.c      ****     {
2490:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
2491:../uvc.c      ****     	           in the UVC implementation. */
2492:../uvc.c      ****     	//hitFV = CyTrue;
2493:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
2494:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
2495:../uvc.c      ****     }
2496:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
2497:../uvc.c      **** }
2498:../uvc.c      **** 
2499:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
2500:../uvc.c      **** static void
2501:../uvc.c      **** CyFxUVCApplnDebugInit (
2502:../uvc.c      ****         void)
2503:../uvc.c      **** {
2504:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
2505:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
2506:../uvc.c      **** 
2507:../uvc.c      ****     /* Initialize the UART for printing debug messages */
2508:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
2509:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2510:../uvc.c      ****     {
2511:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
2512:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2513:../uvc.c      ****     }
2514:../uvc.c      **** 
2515:../uvc.c      ****     /* Set UART Configuration */
2516:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
2517:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
2518:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
2519:../uvc.c      ****     uartConfig.txEnable = CyTrue;
2520:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
2521:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
2522:../uvc.c      ****     uartConfig.isDma    = CyTrue;
2523:../uvc.c      **** 
2524:../uvc.c      ****     /* Set the UART configuration */
2525:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
2526:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2527:../uvc.c      ****     {
2528:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2529:../uvc.c      ****     }
2530:../uvc.c      **** 
2531:../uvc.c      ****     /* Set the UART transfer */
2532:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
2533:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2534:../uvc.c      ****     {
2535:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2536:../uvc.c      ****     }
2537:../uvc.c      **** 
2538:../uvc.c      ****     /* Initialize the Debug logger module. */
2539:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
2540:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2541:../uvc.c      ****     {
2542:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2543:../uvc.c      ****     }
2544:../uvc.c      **** 
2545:../uvc.c      ****     /* Disable log message headers. */
2546:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
2547:../uvc.c      **** }
2548:../uvc.c      **** 
2549:../uvc.c      **** /* I2C initialization. */
2550:../uvc.c      **** static void
2551:../uvc.c      **** CyFxUVCApplnI2CInit (void)
2552:../uvc.c      **** {
2553:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
2554:../uvc.c      ****     CyU3PReturnStatus_t status;
2555:../uvc.c      **** 
2556:../uvc.c      ****     status = CyU3PI2cInit ();
2557:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
2558:../uvc.c      ****     {
2559:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
2560:../uvc.c      ****         CyFxAppErrorHandler (status);
2561:../uvc.c      ****     }
2562:../uvc.c      **** 
2563:../uvc.c      ****     /*  Set I2C Configuration */
2564:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
2565:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
2566:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
2567:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
2568:../uvc.c      **** 
2569:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
2570:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
2571:../uvc.c      ****     {
2572:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
2573:../uvc.c      ****         CyFxAppErrorHandler (status);
2574:../uvc.c      ****     }
2575:../uvc.c      **** }
2576:../uvc.c      **** 
2577:../uvc.c      **** #ifdef BACKFLOW_DETECT
2578:../uvc.c      **** static void CyFxUvcAppPibCallback (
2579:../uvc.c      ****         CyU3PPibIntrType cbType,
2580:../uvc.c      ****         uint16_t cbArg)
2581:../uvc.c      **** {
2582:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
2583:../uvc.c      ****     {
2584:../uvc.c      ****         if (!back_flow_detected)
2585:../uvc.c      ****         {
2586:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
2587:../uvc.c      ****             back_flow_detected = 1;
2588:../uvc.c      ****         }
2589:../uvc.c      ****     }
2590:../uvc.c      **** }
2591:../uvc.c      **** #endif
2592:../uvc.c      **** 
2593:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2594:../uvc.c      **** static void
2595:../uvc.c      **** CyFxUvcAppDebugCallback (
2596:../uvc.c      ****         CyU3PDmaChannel   *handle,
2597:../uvc.c      ****         CyU3PDmaCbType_t   type,
2598:../uvc.c      ****         CyU3PDmaCBInput_t *input)
2599:../uvc.c      **** {
2600:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2601:../uvc.c      ****     {
2602:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
2603:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
2604:../uvc.c      ****     }
2605:../uvc.c      **** }
2606:../uvc.c      **** #endif
2607:../uvc.c      **** 
2608:../uvc.c      **** #if 0
2609:../uvc.c      **** static void CyFxAppIntEpCb(
2610:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
2611:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
2612:../uvc.c      **** 		uint8_t  ebNum)
2613:../uvc.c      **** 		{
2614:../uvc.c      **** 			//CyBool_t value;
2615:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
2616:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
2617:../uvc.c      **** 
2618:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
2619:../uvc.c      **** 		}
2620:../uvc.c      **** #endif
2621:../uvc.c      **** 
2622:../uvc.c      **** /* This function initializes the USB Module, creates event group,
2623:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
2624:../uvc.c      ****    configures the DMA module for the UVC Application */
2625:../uvc.c      **** static void
2626:../uvc.c      **** CyFxUVCApplnInit (void)
2627:../uvc.c      **** {
2628:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
2629:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
2630:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
2631:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
2632:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
2633:../uvc.c      ****     CyU3PPibClock_t              pibclock;
2634:../uvc.c      **** 
2635:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
2636:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
2637:../uvc.c      **** 
2638:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2639:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
2640:../uvc.c      **** #endif
2641:../uvc.c      **** 
2642:../uvc.c      ****     /* Create UVC event group */
2643:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
2644:../uvc.c      ****     if (apiRetStatus != 0)
2645:../uvc.c      ****     {
2646:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
2647:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2648:../uvc.c      ****     }
2649:../uvc.c      **** 
2650:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2651:../uvc.c      ****     CyFxUvcAppPTZInit ();
2652:../uvc.c      **** #endif
2653:../uvc.c      **** 
2654:../uvc.c      ****     isUsbConnected = CyFalse;
2655:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
2656:../uvc.c      **** 
2657:../uvc.c      ****     /* Init the GPIO module */
2658:../uvc.c      ****     gpioClock.fastClkDiv = 2;
2659:../uvc.c      ****     gpioClock.slowClkDiv = 2;
2660:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
2661:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
2662:../uvc.c      ****     gpioClock.halfDiv    = 0;
2663:../uvc.c      **** 
2664:../uvc.c      ****     /* Initialize Gpio interface */
2665:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
2666:../uvc.c      ****     if (apiRetStatus != 0)
2667:../uvc.c      ****     {
2668:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
2669:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2670:../uvc.c      ****     }
2671:../uvc.c      **** 
2672:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
2673:../uvc.c      ****      * must use GpioOverride to configure it */
2674:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
2675:../uvc.c      ****     if (apiRetStatus != 0)
2676:../uvc.c      ****     {
2677:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
2678:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2679:../uvc.c      ****     }
2680:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
2681:../uvc.c      ****     if (apiRetStatus != 0)
2682:../uvc.c      ****     {
2683:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
2684:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2685:../uvc.c      ****     }
2686:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
2687:../uvc.c      ****     if (apiRetStatus != 0)
2688:../uvc.c      ****     {
2689:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
2690:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2691:../uvc.c      ****     }
2692:../uvc.c      **** 
2693:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
2694:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2695:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2696:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2697:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2698:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2699:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
2700:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2701:../uvc.c      ****     {
2702:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
2703:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2704:../uvc.c      ****     }
2705:../uvc.c      **** 
2706:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
2707:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2708:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2709:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2710:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2711:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2712:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2713:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
2714:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2715:../uvc.c      ****     {
2716:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
2717:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2718:../uvc.c      ****     }
2719:../uvc.c      **** 
2720:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
2721:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2722:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
2723:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
2724:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
2725:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
2726:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2727:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
2728:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2729:../uvc.c      ****     {
2730:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
2731:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2732:../uvc.c      ****     }
2733:../uvc.c      **** 
2734:../uvc.c      ****     /* Initialize the P-port. */
2735:../uvc.c      ****     pibclock.clkDiv      = 2;
2736:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
2737:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
2738:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
2739:../uvc.c      **** 
2740:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
2741:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2742:../uvc.c      ****     {
2743:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2744:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2745:../uvc.c      ****     }
2746:../uvc.c      **** 
2747:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
2748:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
2749:../uvc.c      **** 
2750:../uvc.c      **** #ifdef BACKFLOW_DETECT
2751:../uvc.c      ****     back_flow_detected = 0;
2752:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
2753:../uvc.c      **** #endif
2754:../uvc.c      **** 
2755:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
2756:../uvc.c      ****     SensorReset ();
2757:../uvc.c      ****     CyU3PThreadSleep(5000);
2758:../uvc.c      ****     //SensorInit ();
2759:../uvc.c      **** 
2760:../uvc.c      ****     /* USB initialization. */
2761:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
2762:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2763:../uvc.c      ****     {
2764:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2765:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2766:../uvc.c      ****     }
2767:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
2768:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
2769:../uvc.c      **** 
2770:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
2771:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
2772:../uvc.c      **** 
2773:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
2774:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
2775:../uvc.c      **** 
2776:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
2777:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
2778:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
2779:../uvc.c      **** 
2780:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
2781:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
2782:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
2783:../uvc.c      **** 
2784:../uvc.c      ****     /* Configuration descriptors. */
2785:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
2786:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
2787:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
2788:../uvc.c      **** 
2789:../uvc.c      ****     /* String Descriptors */
2790:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
2791:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
2792:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
2793:../uvc.c      **** 
2794:../uvc.c      ****     /* Configure the status interrupt endpoint.
2795:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
2796:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
2797:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
2798:../uvc.c      ****      */
2799:../uvc.c      ****     endPointConfig.enable   = 1;
2800:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
2801:../uvc.c      ****     endPointConfig.pcktSize = 64;
2802:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2803:../uvc.c      ****     endPointConfig.streams  = 0;
2804:../uvc.c      ****     endPointConfig.burstLen = 1;
2805:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
2806:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2807:../uvc.c      ****     {
2808:../uvc.c      ****         /* Error Handling */
2809:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2810:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2811:../uvc.c      ****     }
2812:../uvc.c      **** 
2813:../uvc.c      ****     /* create a DMA for interrupt endpoint */
2814:../uvc.c      ****     dmaInterConfig.size           = 1024;
2815:../uvc.c      ****     dmaInterConfig.count          = 1;
2816:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2817:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
2818:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
2819:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
2820:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
2821:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2822:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2823:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2824:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2825:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2826:../uvc.c      ****             &dmaInterConfig);
2827:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2828:../uvc.c      ****     {
2829:../uvc.c      ****         /* Error handling */
2830:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2831:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2832:../uvc.c      ****     }
2833:../uvc.c      **** 
2834:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2835:../uvc.c      ****     if (glInterStaBuffer == 0)
2836:../uvc.c      ****     {
2837:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2838:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2839:../uvc.c      ****     }
2840:../uvc.c      **** 
2841:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2842:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
2843:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2844:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2845:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2846:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2847:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2848:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2849:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2850:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2851:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2852:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2853:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2854:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2855:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2856:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2857:../uvc.c      ****             &dmaMultiConfig);
2858:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2859:../uvc.c      ****     {
2860:../uvc.c      ****         /* Error handling */
2861:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2862:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2863:../uvc.c      ****     }
2864:../uvc.c      **** 
2865:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2866:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2867:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2868:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2869:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2870:../uvc.c      ****      */
2871:../uvc.c      **** 
2872:../uvc.c      ****     endPointConfig.enable   = 1;
2873:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2874:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2875:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2876:../uvc.c      ****     endPointConfig.streams  = 0;
2877:../uvc.c      ****     endPointConfig.burstLen = 1;
2878:../uvc.c      **** 
2879:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2880:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2881:../uvc.c      ****     {
2882:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2883:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2884:../uvc.c      ****     }
2885:../uvc.c      **** 
2886:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2887:../uvc.c      **** 
2888:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2889:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2890:../uvc.c      ****     {
2891:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2892:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2893:../uvc.c      ****     }
2894:../uvc.c      **** 
2895:../uvc.c      ****     channelConfig.size           = 1024;
2896:../uvc.c      ****     channelConfig.count          = 1;
2897:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2898:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2899:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2900:../uvc.c      ****     channelConfig.prodHeader     = 0;
2901:../uvc.c      ****     channelConfig.prodFooter     = 0;
2902:../uvc.c      ****     channelConfig.consHeader     = 0;
2903:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2904:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2905:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2906:../uvc.c      **** 
2907:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2908:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2909:../uvc.c      ****     {
2910:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2911:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2912:../uvc.c      ****     }
2913:../uvc.c      **** 
2914:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2915:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2916:../uvc.c      ****     {
2917:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2918:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2919:../uvc.c      ****     }
2920:../uvc.c      **** 
2921:../uvc.c      ****     channelConfig.size           = 1024;
2922:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2923:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2924:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2925:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2926:../uvc.c      ****     channelConfig.prodHeader     = 0;
2927:../uvc.c      ****     channelConfig.prodFooter     = 0;
2928:../uvc.c      ****     channelConfig.consHeader     = 0;
2929:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2930:../uvc.c      ****     channelConfig.notification   = 0;
2931:../uvc.c      ****     channelConfig.cb             = 0;
2932:../uvc.c      **** 
2933:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2934:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2935:../uvc.c      ****     {
2936:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2937:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2938:../uvc.c      ****     }
2939:../uvc.c      **** 
2940:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2941:../uvc.c      ****     if (glDebugRspBuffer == 0)
2942:../uvc.c      ****     {
2943:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2944:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2945:../uvc.c      ****     }
2946:../uvc.c      **** #endif
2947:../uvc.c      **** 
2948:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2949:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2950:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2951:../uvc.c      ****     {
2952:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2953:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2954:../uvc.c      ****     }
2955:../uvc.c      **** 
2956:../uvc.c      ****     CyU3PBusyWait(100);
2957:../uvc.c      **** 
2958:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2959:../uvc.c      **** 
2960:../uvc.c      ****     endPointConfig.enable   = 1;
2961:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2962:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2963:../uvc.c      ****     {
2964:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2965:../uvc.c      ****     	endPointConfig.burstLen = 16;
2966:../uvc.c      ****     }
2967:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2968:../uvc.c      ****     {
2969:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2970:../uvc.c      ****     	endPointConfig.burstLen = 1;
2971:../uvc.c      ****     }
2972:../uvc.c      ****     endPointConfig.streams  = 0;
2973:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2974:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2975:../uvc.c      ****     {
2976:../uvc.c      ****         /* Error Handling */
2977:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2978:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2979:../uvc.c      ****     }
2980:../uvc.c      **** #if 0    //for still image method 3 using
2981:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2982:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2983:../uvc.c      ****     {
2984:../uvc.c      ****         /* Error Handling */
2985:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2986:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2987:../uvc.c      ****     }
2988:../uvc.c      **** #endif
2989:../uvc.c      **** 
2990:../uvc.c      **** }
2991:../uvc.c      **** 
2992:../uvc.c      **** /*
2993:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2994:../uvc.c      ****  * streaming session is started.
2995:../uvc.c      ****  */
2996:../uvc.c      **** static void
2997:../uvc.c      **** CyFxUvcAppGpifInit (
2998:../uvc.c      ****         void)
2999:../uvc.c      **** {
3000:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
3001:../uvc.c      **** 
3002:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3003:../uvc.c      ****     {
3004:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
3005:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
3006:../uvc.c      ****     }
3007:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
3008:../uvc.c      ****     {
3009:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
3010:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
3011:../uvc.c      ****     }
3012:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3013:../uvc.c      ****     {
3014:../uvc.c      ****         /* Error Handling */
3015:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
3016:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3017:../uvc.c      ****     }
3018:../uvc.c      **** 
3019:../uvc.c      ****     /* Start the state machine from the designated start state. */
3020:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3021:../uvc.c      ****     {
3022:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
3023:../uvc.c      ****     }
3024:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
3025:../uvc.c      ****     {
3026:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
3027:../uvc.c      ****     }
3028:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3029:../uvc.c      ****     {
3030:../uvc.c      ****         /* Error Handling */
3031:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
3032:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3033:../uvc.c      ****     }
3034:../uvc.c      **** }
3035:../uvc.c      **** 
3036:../uvc.c      **** /*
3037:../uvc.c      ****  * Entry function for the UVC Application Thread
3038:../uvc.c      ****  */
3039:../uvc.c      **** 
3040:../uvc.c      **** uint32_t posTick;
3041:../uvc.c      **** CyU3PTimer I2CCmdTimer;
3042:../uvc.c      **** 
3043:../uvc.c      **** void  I2CCmdCb(uint32_t input){
3044:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
3045:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
3046:../uvc.c      **** }
3047:../uvc.c      **** 
3048:../uvc.c      **** 
3049:../uvc.c      **** void
3050:../uvc.c      **** UVCAppThread_Entry (
3051:../uvc.c      ****         uint32_t input)
3052:../uvc.c      **** {
3053:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
3054:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
3055:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
3056:../uvc.c      ****     uint8_t i = 0;
3057:../uvc.c      ****     uint32_t flag;
3058:../uvc.c      ****     uint32_t prinflag = 0;
3059:../uvc.c      **** static uint8_t IMcount = 0;
3060:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
3061:../uvc.c      ****     uint32_t frameCnt = 0;
3062:../uvc.c      **** #endif
3063:../uvc.c      ****     /* Initialize the Uart Debug Module */
3064:../uvc.c      ****     CyFxUVCApplnDebugInit ();
3065:../uvc.c      **** 
3066:../uvc.c      ****     /* Initialize the I2C interface */
3067:../uvc.c      **** 	while (i++ < 6){
3068:../uvc.c      **** 		CyU3PThreadSleep(500);
3069:../uvc.c      **** 	}
3070:../uvc.c      **** 
3071:../uvc.c      ****     CyFxUVCApplnI2CInit ();
3072:../uvc.c      **** 
3073:../uvc.c      ****     /* Initialize the UVC Application */
3074:../uvc.c      ****     CyFxUVCApplnInit ();
3075:../uvc.c      ****     /*
3076:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
3077:../uvc.c      **** 
3078:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
3079:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
3080:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
3081:../uvc.c      **** 
3082:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
3083:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
3084:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
3085:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
3086:../uvc.c      **** 
3087:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
3088:../uvc.c      ****        of handling the abort request.
3089:../uvc.c      ****      */
3090:../uvc.c      **** 
3091:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
3092:../uvc.c      ****     //CyU3PThreadSleep(1000);
3093:../uvc.c      **** 
3094:../uvc.c      ****     for (;;)
3095:../uvc.c      ****     {
3096:../uvc.c      ****         /* Waiting for the Video Stream Event */
3097:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
3098:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3099:../uvc.c      ****         {
3100:../uvc.c      ****         	debugData[0][1] = debugData[0][1]&0xFF;
3101:../uvc.c      ****         	debugData[0][1] = debugData[0][1]|0x01;
3102:../uvc.c      **** #if 0 //test for new firmware no video bring up
3103:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
3104:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
3105:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
3106:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
3107:../uvc.c      ****             {
3108:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
3109:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
3110:../uvc.c      ****                 {
3111:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3112:../uvc.c      **** #ifdef  USB_LOWRES_IMG
3113:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
3114:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
3115:../uvc.c      **** #endif
3116:../uvc.c      **** #endif
3117:../uvc.c      ****                     }
3118:../uvc.c      ****                 else
3119:../uvc.c      ****                 {
3120:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
3121:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3122:../uvc.c      **** #ifdef USB_LOWRES_IMG
3123:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
3124:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3125:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
3126:../uvc.c      **** #endif
3127:../uvc.c      **** #endif
3128:../uvc.c      ****                 }
3129:../uvc.c      **** 
3130:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
3131:../uvc.c      ****                 prodCount++;
3132:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
3133:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
3134:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
3135:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3136:../uvc.c      ****                 {
3137:../uvc.c      ****                     prodCount--;
3138:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
3139:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
3140:../uvc.c      ****                 }
3141:../uvc.c      ****             }
3142:../uvc.c      **** #endif
3143:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
3144:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
3145:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
3146:../uvc.c      ****             {
3147:../uvc.c      ****             	if(0&&(prinflag == 0)){
3148:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
3149:../uvc.c      ****             		prinflag = 1;
3150:../uvc.c      ****             	}
3151:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
3152:../uvc.c      ****             	debugData[0][0]++;
3153:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x82;
3154:../uvc.c      ****             	fb=0;
3155:../uvc.c      ****             	pb=0;
3156:../uvc.c      ****             	pbc=0;
3157:../uvc.c      ****                 prodCount = 0;
3158:../uvc.c      ****                 consCount = 0;
3159:../uvc.c      ****                 hitFV     = CyFalse;
3160:../uvc.c      **** 
3161:../uvc.c      **** #ifdef BACKFLOW_DETECT
3162:../uvc.c      ****                 back_flow_detected = 0;
3163:../uvc.c      **** #endif
3164:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
3165:../uvc.c      ****                 frameCnt++;
3166:../uvc.c      **** #endif
3167:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
3168:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
3169:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
3170:../uvc.c      ****                 //}
3171:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
3172:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3173:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
3174:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
3175:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3176:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
3177:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
3178:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
3179:../uvc.c      ****                      	//CyU3PThreadSleep(100);
3180:../uvc.c      ****                 		stiflag = 0xFF;
3181:../uvc.c      ****                 		IMcount = 0;
3182:../uvc.c      ****                 	}
3183:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
3184:../uvc.c      **** 
3185:../uvc.c      ****                  		if(IMcount++ >= 0x3){
3186:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
3187:../uvc.c      ****                 		stiflag = 0x0F;
3188:../uvc.c      ****                 		IMcount = 0;
3189:../uvc.c      ****                 		}
3190:../uvc.c      ****                  		/*if(IMcount > 0x4){
3191:../uvc.c      ****                 			stiflag = 0x0F;
3192:../uvc.c      ****                 			IMcount = 0;
3193:../uvc.c      ****                 		}*/
3194:../uvc.c      **** 
3195:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
3196:../uvc.c      ****                     //CyU3PThreadSleep(400);
3197:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3198:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3199:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
3200:../uvc.c      **** 
3201:../uvc.c      ****                 	if(IMcount++ >= 0x3)
3202:../uvc.c      ****                 	{
3203:../uvc.c      ****                     switch (setRes)
3204:../uvc.c      ****                      {
3205:../uvc.c      ****                  	case 1: //1944
3206:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
3207:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3208:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
3209:../uvc.c      ****                  		break;
3210:../uvc.c      ****                  	case 2: //1080
3211:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
3212:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3213:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
3214:../uvc.c      ****                  		break;
3215:../uvc.c      ****                  	case 3: //720
3216:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
3217:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3218:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
3219:../uvc.c      ****                  		break;
3220:../uvc.c      ****                  	case 4: //VGA
3221:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
3222:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3223:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
3224:../uvc.c      ****                  		break;
3225:../uvc.c      ****                  	default:
3226:../uvc.c      ****                  		break;
3227:../uvc.c      ****                      }
3228:../uvc.c      ****                     IMcount = 0;
3229:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3230:../uvc.c      ****                 	stiflag = 0x0;
3231:../uvc.c      ****                 	}
3232:../uvc.c      ****                 }
3233:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
3234:../uvc.c      ****                 /* Reset the DMA channel. */
3235:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3236:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3237:../uvc.c      ****                 {
3238:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
3239:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3240:../uvc.c      ****                 }
3241:../uvc.c      **** 
3242:../uvc.c      ****                 /* Start Channel Immediately */
3243:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3244:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3245:../uvc.c      ****                 {
3246:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
3247:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3248:../uvc.c      ****                 }
3249:../uvc.c      **** 
3250:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
3251:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
3252:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3253:../uvc.c      ****                 }
3254:../uvc.c      ****         }
3255:../uvc.c      ****         else
3256:../uvc.c      ****         {
3257:../uvc.c      ****             /* If we have a stream abort request pending. */
3258:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
3259:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3260:../uvc.c      ****             {
3261:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
3262:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x04;
3263:../uvc.c      ****             	hitFV     = CyFalse;
3264:../uvc.c      ****                 prodCount = 0;
3265:../uvc.c      ****                 consCount = 0;
3266:../uvc.c      ****                 if(0&&(prinflag == 0)){
3267:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
3268:../uvc.c      ****                 	prinflag = 1;
3269:../uvc.c      ****                 }
3270:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
3271:../uvc.c      ****                 fb=0;
3272:../uvc.c      ****                 pb=0;
3273:../uvc.c      ****                 pbc=0;
3274:../uvc.c      **** 
3275:../uvc.c      ****                 if (!clearFeatureRqtReceived)
3276:../uvc.c      ****                 {
3277:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3278:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
3279:../uvc.c      ****                     {
3280:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
3281:../uvc.c      ****                     }
3282:../uvc.c      **** 
3283:../uvc.c      ****                     /* Flush the Endpoint memory */
3284:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
3285:../uvc.c      ****                 }
3286:../uvc.c      **** 
3287:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
3288:../uvc.c      ****             }
3289:../uvc.c      ****             else
3290:../uvc.c      ****             {
3291:../uvc.c      **** #if 0
3292:../uvc.c      ****                 if(stream_start == CyTrue){
3293:../uvc.c      ****                     if(CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND,
3294:../uvc.c      ****                     		&flag, CYU3P_NO_WAIT != CY_U3P_SUCCESS)){
3295:../uvc.c      ****     					if(1||clearFeatureRqtReceived){
3296:../uvc.c      ****     						CyU3PThreadSleep(3000);
3297:../uvc.c      ****     						//if(stream_start == CyTrue){
3298:../uvc.c      ****     							streamingRecove = CyTrue;
3299:../uvc.c      ****     							debugData[1][1]++;
3300:../uvc.c      ****     						//}
3301:../uvc.c      ****     						clearFeatureRqtReceived = CyFalse;
3302:../uvc.c      ****     						stream_start == CyFalse;
3303:../uvc.c      ****     					}
3304:../uvc.c      ****                     }
3305:../uvc.c      **** 
3306:../uvc.c      ****                 }
3307:../uvc.c      **** #endif
3308:../uvc.c      **** 
3309:../uvc.c      ****             	/* We are essentially idle at this point. Wait for the reception of a start streaming 
3310:../uvc.c      **** 
3311:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
3312:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
3313:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
3314:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
3315:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3316:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3317:../uvc.c      ****                 {
3318:../uvc.c      ****                     /* Error handling */
3319:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
3320:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3321:../uvc.c      ****                 }
3322:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
3323:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x08;
3324:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
3325:../uvc.c      ****                 if (gpif_initialized == CyFalse)
3326:../uvc.c      ****                 {
3327:../uvc.c      **** #if 0
3328:../uvc.c      ****                 	//for start up of the AF Lens
3329:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3330:../uvc.c      ****                     CyU3PThreadSleep(500);
3331:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3332:../uvc.c      ****                     CyU3PThreadSleep(500);
3333:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
3334:../uvc.c      ****                    	CyU3PThreadSleep(300);
3335:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3336:../uvc.c      ****                     CyU3PThreadSleep(500);
3337:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3338:../uvc.c      ****                     CyU3PThreadSleep(500);
3339:../uvc.c      **** #endif
3340:../uvc.c      **** #if 0
3341:../uvc.c      ****                     if(streamingRecove){
3342:../uvc.c      ****                     switch (setRes)
3343:../uvc.c      ****                     {
3344:../uvc.c      ****                      	case 1: //1944
3345:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boa
3346:../uvc.c      ****                      		CyU3PThreadSleep(100);
3347:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:
3348:../uvc.c      ****                      		break;
3349:../uvc.c      ****                      	case 2: //1080
3350:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boa
3351:../uvc.c      ****                      		CyU3PThreadSleep(100);
3352:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:
3353:../uvc.c      ****                      		break;
3354:../uvc.c      ****                      	case 3: //720
3355:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPB
3356:../uvc.c      ****                      		CyU3PThreadSleep(100);
3357:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x4
3358:../uvc.c      ****                      		break;
3359:../uvc.c      ****                      	case 4: //VGA
3360:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPB
3361:../uvc.c      ****                      		CyU3PThreadSleep(100);
3362:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x7
3363:../uvc.c      ****                      		break;
3364:../uvc.c      ****                      	default:
3365:../uvc.c      ****                      		break;
3366:../uvc.c      **** 
3367:../uvc.c      ****                     }
3368:../uvc.c      ****                     streamingRecove = CyFalse;
3369:../uvc.c      ****                     }
3370:../uvc.c      **** #endif
3371:../uvc.c      ****                     CyFxUvcAppGpifInit ();
3372:../uvc.c      **** 
3373:../uvc.c      ****                     gpif_initialized = CyTrue;
3374:../uvc.c      ****                     //stream_start = CyTrue;
3375:../uvc.c      ****                     CyU3PThreadSleep(200);
3376:../uvc.c      ****                     
3377:../uvc.c      ****                 }
3378:../uvc.c      ****                 else
3379:../uvc.c      ****                 {
3380:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
3381:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
3382:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3383:../uvc.c      ****                 }
3384:../uvc.c      ****             }
3385:../uvc.c      ****         }
3386:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
3387:../uvc.c      **** 
3388:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
3389:../uvc.c      ****         CyU3PThreadRelinquish ();
3390:../uvc.c      ****     }
3391:../uvc.c      **** }
3392:../uvc.c      **** 
3393:../uvc.c      **** /*
3394:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
3395:../uvc.c      ****  */
3396:../uvc.c      **** 
3397:../uvc.c      **** static void
3398:../uvc.c      **** UVCHandleProcessingUnitRqts (
3399:../uvc.c      ****         void)
3400:../uvc.c      **** {
3401:../uvc.c      ****     uint8_t CtrlAdd;
3402:../uvc.c      **** #ifdef DbgInfo
3403:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3404:../uvc.c      **** #endif
3405:../uvc.c      ****     switch (wValue)
3406:../uvc.c      ****     {
3407:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
3408:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
3409:../uvc.c      ****     		ControlHandle(BLCCtlID0);
3410:../uvc.c      ****     		break;
3411:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
3412:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
3413:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
3414:../uvc.c      ****     		break;
3415:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
3416:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
3417:../uvc.c      **** 			ControlHandle(ConsCtlID2);
3418:../uvc.c      **** 			break;
3419:../uvc.c      **** 
3420:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
3421:../uvc.c      **** 
3422:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
3423:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
3424:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
3425:../uvc.c      ****       		break;
3426:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
3427:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
3428:../uvc.c      ****      		ControlHandle(HueCtlID5);
3429:../uvc.c      ****      		break;
3430:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
3431:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
3432:../uvc.c      ****           		ControlHandle(SaturCtlID6);
3433:../uvc.c      ****           		break;
3434:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
3435:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
3436:../uvc.c      ****           		ControlHandle(ShapCtlID7);
3437:../uvc.c      ****           		break;
3438:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
3439:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
3440:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
3441:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
3442:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
3443:../uvc.c      ****     		break;
3444:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
3445:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
3446:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
3447:../uvc.c      ****     		break;
3448:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
3449:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
3450:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
3451:../uvc.c      ****     		break;
3452:../uvc.c      **** 
3453:../uvc.c      ****         default:
3454:../uvc.c      ****             /*
3455:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3456:../uvc.c      ****              * other controls.
3457:../uvc.c      ****              */
3458:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3459:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3460:../uvc.c      ****             break;
3461:../uvc.c      ****     }
3462:../uvc.c      **** }
3463:../uvc.c      **** 
3464:../uvc.c      **** /*
3465:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
3466:../uvc.c      ****  */
3467:../uvc.c      **** static void
3468:../uvc.c      **** UVCHandleCameraTerminalRqts (
3469:../uvc.c      ****         void)
3470:../uvc.c      **** {
3471:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3472:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3473:../uvc.c      ****     uint16_t readCount;
3474:../uvc.c      ****     uint16_t zoomVal;
3475:../uvc.c      ****     int32_t  panVal, tiltVal;
3476:../uvc.c      ****     CyBool_t sendData = CyFalse;
3477:../uvc.c      **** #endif
3478:../uvc.c      ****     uint8_t CtrlAdd;
3479:../uvc.c      **** 
3480:../uvc.c      ****     switch (wValue)
3481:../uvc.c      ****     {
3482:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
3483:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
3484:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
3485:../uvc.c      ****     		break;
3486:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
3487:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
3488:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
3489:../uvc.c      ****     		break;
3490:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
3491:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
3492:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
3493:../uvc.c      **** 			break;
3494:../uvc.c      **** 
3495:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
3496:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
3497:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
3498:../uvc.c      **** 			break;
3499:../uvc.c      **** 
3500:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
3501:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
3502:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
3503:../uvc.c      ****       		break;
3504:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
3505:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
3506:../uvc.c      ****      		CTControlHandle(FocACtlID5);
3507:../uvc.c      ****      		break;
3508:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
3509:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
3510:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
3511:../uvc.c      ****           		break;
3512:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
3513:../uvc.c      ****           		break;
3514:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
3515:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
3516:../uvc.c      ****      		CTControlHandle(IriACtlID7);
3517:../uvc.c      ****      		break;
3518:../uvc.c      **** 
3519:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
3520:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
3521:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
3522:../uvc.c      ****     		break;
3523:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3524:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
3525:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
3526:../uvc.c      ****     		break;
3527:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
3528:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
3529:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
3530:../uvc.c      ****     		break;
3531:../uvc.c      **** 
3532:../uvc.c      ****         default:
3533:../uvc.c      ****             /*
3534:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3535:../uvc.c      ****              * other controls.
3536:../uvc.c      ****              */
3537:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3538:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3539:../uvc.c      ****             break;
3540:../uvc.c      ****     }
3541:../uvc.c      **** 
3542:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3543:../uvc.c      ****     switch (wValue)
3544:../uvc.c      ****     {
3545:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3546:../uvc.c      ****             switch (bRequest)
3547:../uvc.c      ****             {
3548:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3549:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
3550:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3551:../uvc.c      ****                     break;
3552:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
3553:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
3554:../uvc.c      ****                     sendData = CyTrue;
3555:../uvc.c      ****                     break;
3556:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
3557:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
3558:../uvc.c      ****                     sendData = CyTrue;
3559:../uvc.c      ****                     break;
3560:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
3561:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
3562:../uvc.c      ****                     sendData = CyTrue;
3563:../uvc.c      ****                     break;
3564:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
3565:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
3566:../uvc.c      ****                     sendData = CyTrue;
3567:../uvc.c      ****                     break;
3568:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
3569:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
3570:../uvc.c      ****                     sendData = CyTrue;
3571:../uvc.c      ****                     break;
3572:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3573:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3574:../uvc.c      ****                             glEp0Buffer, &readCount);
3575:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3576:../uvc.c      ****                     {
3577:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
3578:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
3579:../uvc.c      ****                     }
3580:../uvc.c      ****                     break;
3581:../uvc.c      ****                 default:
3582:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3583:../uvc.c      ****                     break;
3584:../uvc.c      ****             }
3585:../uvc.c      **** 
3586:../uvc.c      ****             if (sendData)
3587:../uvc.c      ****             {
3588:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
3589:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
3590:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
3591:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3592:../uvc.c      ****             }
3593:../uvc.c      ****             break;
3594:../uvc.c      **** 
3595:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
3596:../uvc.c      ****             switch (bRequest)
3597:../uvc.c      ****             {
3598:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3599:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
3600:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3601:../uvc.c      ****                     break;
3602:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3603:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
3604:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
3605:../uvc.c      ****                     sendData = CyTrue;
3606:../uvc.c      ****                     break;
3607:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3608:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
3609:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
3610:../uvc.c      ****                     sendData = CyTrue;
3611:../uvc.c      ****                     break;
3612:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3613:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
3614:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
3615:../uvc.c      ****                     sendData = CyTrue;
3616:../uvc.c      ****                     break;
3617:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
3618:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
3619:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
3620:../uvc.c      ****                     sendData = CyTrue;
3621:../uvc.c      ****                     break;
3622:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
3623:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
3624:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
3625:../uvc.c      ****                     sendData = CyTrue;
3626:../uvc.c      ****                     break;
3627:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3628:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3629:../uvc.c      ****                             glEp0Buffer, &readCount);
3630:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3631:../uvc.c      ****                     {
3632:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
3633:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
3634:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
3635:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
3636:../uvc.c      **** 
3637:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
3638:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
3639:../uvc.c      ****                     }
3640:../uvc.c      ****                     break;
3641:../uvc.c      ****                 default:
3642:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3643:../uvc.c      ****                     break;
3644:../uvc.c      ****             }
3645:../uvc.c      **** 
3646:../uvc.c      ****             if (sendData)
3647:../uvc.c      ****             {
3648:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
3649:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
3650:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
3651:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
3652:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
3653:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
3654:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
3655:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
3656:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
3657:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3658:../uvc.c      ****             }
3659:../uvc.c      ****             break;
3660:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
3661:../uvc.c      ****         default:
3662:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
3663:../uvc.c      ****             break;
3664:../uvc.c      ****     }
3665:../uvc.c      **** #endif
3666:../uvc.c      **** }
3667:../uvc.c      **** 
3668:../uvc.c      **** /*
3669:../uvc.c      ****  * Handler for UVC Interface control requests.
3670:../uvc.c      ****  */
3671:../uvc.c      **** static void
3672:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
3673:../uvc.c      ****         void)
3674:../uvc.c      **** {
3675:../uvc.c      **** 	if(valIdx < 32){
3676:../uvc.c      **** 		value[valIdx][0] = wValue>>8;
3677:../uvc.c      **** 		value[valIdx][1] = (uint8_t)wValue;
3678:../uvc.c      **** 		valIdx++;
3679:../uvc.c      **** 		value[0][1] = valIdx;
3680:../uvc.c      **** 	}
3681:../uvc.c      ****     switch (wValue)
3682:../uvc.c      ****     {
3683:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
3684:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3685:../uvc.c      ****     		break;
3686:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
3687:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
3688:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
3689:../uvc.c      ****     		break;
3690:../uvc.c      ****     	default:
3691:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
3692:../uvc.c      ****      		break;
3693:../uvc.c      ****     }
3694:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
3695:../uvc.c      **** 
3696:../uvc.c      **** }
3697:../uvc.c      **** 
3698:../uvc.c      **** /*
3699:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
3700:../uvc.c      ****  */
3701:../uvc.c      **** static void
3702:../uvc.c      **** UVCHandleExtensionUnitRqts (
3703:../uvc.c      ****         void)
3704:../uvc.c      **** {
3705:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
3706:../uvc.c      **** 
3707:../uvc.c      **** #ifdef DbgInfo
3708:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3709:../uvc.c      **** #endif
3710:../uvc.c      ****     switch (wValue)
3711:../uvc.c      ****     {
3712:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
3713:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
3714:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
3715:../uvc.c      ****     		break;
3716:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
3717:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
3718:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
3719:../uvc.c      ****     		break;
3720:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
3721:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
3722:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
3723:../uvc.c      ****      		break;
3724:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
3725:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
3726:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
3727:../uvc.c      ****     		break;
3728:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
3729:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
3730:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
3731:../uvc.c      ****     		break;
3732:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
3733:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
3734:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
3735:../uvc.c      ****      		break;
3736:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
3737:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
3738:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
3739:../uvc.c      ****     		break;
3740:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
3741:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
3742:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
3743:../uvc.c      ****     		break;
3744:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
3745:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
3746:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
3747:../uvc.c      ****      		break;
3748:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
3749:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
3750:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
3751:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
3752:../uvc.c      ****     		}else/* no support for 1080p camera */
3753:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
3754:../uvc.c      ****     		break;
3755:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
3756:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
3757:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
3758:../uvc.c      ****     		break;
3759:../uvc.c      **** 		case CY_FX_EXT_CONTROL_12: //AEx shutter level CONTROL12
3760:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCtlShutlevCtlID11][0];
3761:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
3762:../uvc.c      ****     		break;
3763:../uvc.c      **** 
3764:../uvc.c      ****     		//ExtCtlShutlevCtlID11
3765:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
3766:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
3767:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
3768:../uvc.c      ****     		break;
3769:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
3770:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
3771:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
3772:../uvc.c      ****     		//break;
3773:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
3774:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
3775:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
3776:../uvc.c      ****     		break;
3777:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
3778:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
3779:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
3780:../uvc.c      ****     		break;
3781:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
3782:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET][0];
3783:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
3784:../uvc.c      ****     		break;
3785:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
3786:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET][0];
3787:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
3788:../uvc.c      ****     		break;
3789:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
3790:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET][0];
3791:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
3792:../uvc.c      ****     		break;
3793:../uvc.c      ****    	default:
3794:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
3795:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3796:../uvc.c      ****     		break;
3797:../uvc.c      ****     }
3798:../uvc.c      **** 
3799:../uvc.c      **** }
3800:../uvc.c      **** 
3801:../uvc.c      **** /*
3802:../uvc.c      ****  * Handler for the video streaming control requests.
3803:../uvc.c      ****  */
3804:../uvc.c      **** static void
3805:../uvc.c      **** UVCHandleVideoStreamingRqts (
3806:../uvc.c      ****         void)
3807:../uvc.c      **** {
3808:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3809:../uvc.c      ****     uint16_t readCount;
3810:../uvc.c      **** 
3811:../uvc.c      ****     switch (wValue)
3812:../uvc.c      ****     {
3813:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
3814:../uvc.c      ****             switch (bRequest)
3815:../uvc.c      ****             {
3816:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3817:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3818:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3819:../uvc.c      ****                     break;
3820:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3821:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3822:../uvc.c      ****                     glEp0Buffer[1] = 0;
3823:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3824:../uvc.c      ****                     break;
3825:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3826:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3827:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3828:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3829:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3830:../uvc.c      ****                     {
3831:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
3832:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
3833:../uvc.c      **** 
3834:../uvc.c      ****                     }
3835:../uvc.c      ****                     else
3836:../uvc.c      ****                     {
3837:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3838:../uvc.c      ****                     }
3839:../uvc.c      ****                     break;
3840:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3841:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3842:../uvc.c      ****                             glCommitCtrl, &readCount);
3843:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3844:../uvc.c      ****                     {
3845:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3846:../uvc.c      ****                         {
3847:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
3848:../uvc.c      ****                                active data structure. */
3849:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
3850:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
3851:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
3852:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
3853:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
3854:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
3855:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
3856:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
3857:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
3858:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
3859:../uvc.c      **** #if 0
3860:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
3861:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
3862:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
3863:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
3864:../uvc.c      **** #endif
3865:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
3866:../uvc.c      ****                        }
3867:../uvc.c      ****                     }
3868:../uvc.c      ****                     break;
3869:../uvc.c      ****                 default:
3870:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3871:../uvc.c      ****                     break;
3872:../uvc.c      ****             }
3873:../uvc.c      ****             break;
3874:../uvc.c      **** 
3875:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
3876:../uvc.c      ****             switch (bRequest)
3877:../uvc.c      ****             {
3878:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3879:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
3880:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3881:../uvc.c      ****                     break;
3882:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3883:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3884:../uvc.c      ****                     glEp0Buffer[1] = 0;
3885:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3886:../uvc.c      ****                     break;
3887:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3888:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3889:../uvc.c      ****                     {
3890:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
3891:../uvc.c      ****                     }
3892:../uvc.c      ****                     else
3893:../uvc.c      ****                     {
3894:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3895:../uvc.c      ****                     }
3896:../uvc.c      ****                     break;
3897:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3898:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
3899:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
3900:../uvc.c      ****                        */
3901:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3902:../uvc.c      ****                             glCommitCtrl, &readCount);
3903:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3904:../uvc.c      ****                     {
3905:../uvc.c      ****                         switch (glCommitCtrl[3])
3906:../uvc.c      ****                          {
3907:../uvc.c      ****                          	case 1: //1944
3908:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
3909:../uvc.c      ****                          		CyU3PThreadSleep(500);
3910:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3911:../uvc.c      ****                          		break;
3912:../uvc.c      ****                          	case 2: //1080
3913:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
3914:../uvc.c      ****                          		CyU3PThreadSleep(500);
3915:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3916:../uvc.c      ****                          		break;
3917:../uvc.c      ****                          	case 3: //720
3918:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
3919:../uvc.c      ****                          		CyU3PThreadSleep(500);
3920:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3921:../uvc.c      ****                          		break;
3922:../uvc.c      ****                          	case 4: //VGA
3923:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
3924:../uvc.c      ****                          		CyU3PThreadSleep(500);
3925:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3926:../uvc.c      ****                          		break;
3927:../uvc.c      ****                          	default:
3928:../uvc.c      ****                          		break;
3929:../uvc.c      ****                          }
3930:../uvc.c      ****                         setRes = glCommitCtrl[3];
3931:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
3932:../uvc.c      **** 
3933:../uvc.c      **** #if 0
3934:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
3935:../uvc.c      ****                         {
3936:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
3937:../uvc.c      ****                         }
3938:../uvc.c      ****                         else
3939:../uvc.c      ****                         {
3940:../uvc.c      ****                             SensorScaling_VGA ();
3941:../uvc.c      ****                         }
3942:../uvc.c      **** #endif
3943:../uvc.c      ****                         /* We can start streaming video now. */
3944:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
3945:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
3946:../uvc.c      ****                         {
3947:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
3948:../uvc.c      ****                         }
3949:../uvc.c      ****                     }
3950:../uvc.c      ****                     break;
3951:../uvc.c      **** 
3952:../uvc.c      ****                 default:
3953:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3954:../uvc.c      ****                     break;
3955:../uvc.c      ****             }
3956:../uvc.c      ****             break;
3957:../uvc.c      **** 
3958:../uvc.c      **** /* still image streaming handler */
3959:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
3960:../uvc.c      ****                 switch (bRequest)
3961:../uvc.c      ****                 {
3962:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3963:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3964:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3965:../uvc.c      ****                         break;
3966:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3967:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3968:../uvc.c      ****                         glEp0Buffer[1] = 0;
3969:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3970:../uvc.c      ****                         break;
3971:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3972:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3973:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3974:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3975:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3976:../uvc.c      ****                         {
3977:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3978:../uvc.c      ****                         }
3979:../uvc.c      ****                         else
3980:../uvc.c      ****                         {
3981:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3982:../uvc.c      ****                         }
3983:../uvc.c      ****                         break;
3984:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3985:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3986:../uvc.c      ****                                 glCommitCtrl, &readCount);
3987:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3988:../uvc.c      ****                         {
3989:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
3990:../uvc.c      ****                             {
3991:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
3992:../uvc.c      ****                                    active data structure. */
3993:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3994:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3995:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
3996:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
3997:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
3998:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
3999:../uvc.c      ****                             }
4000:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
4001:../uvc.c      ****                         }
4002:../uvc.c      ****                         break;
4003:../uvc.c      ****                     default:
4004:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4005:../uvc.c      ****                         break;
4006:../uvc.c      ****                 }
4007:../uvc.c      ****                 break;
4008:../uvc.c      **** 
4009:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
4010:../uvc.c      ****                 switch (bRequest)
4011:../uvc.c      ****                 {
4012:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4013:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
4014:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4015:../uvc.c      ****                         break;
4016:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4017:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4018:../uvc.c      ****                         glEp0Buffer[1] = 0;
4019:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4020:../uvc.c      ****                         break;
4021:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
4022:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4023:../uvc.c      ****                         {
4024:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4025:../uvc.c      ****                         }
4026:../uvc.c      ****                         else
4027:../uvc.c      ****                         {
4028:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4029:../uvc.c      ****                         }
4030:../uvc.c      ****                         break;
4031:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4032:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4033:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4034:../uvc.c      ****                            */
4035:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4036:../uvc.c      ****                                 glCommitCtrl, &readCount);
4037:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4038:../uvc.c      ****                         {
4039:../uvc.c      ****     #if 0
4040:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
4041:../uvc.c      ****                             {
4042:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
4043:../uvc.c      ****                             }
4044:../uvc.c      ****                             else
4045:../uvc.c      ****                             {
4046:../uvc.c      ****                                 SensorScaling_VGA ();
4047:../uvc.c      ****                             }
4048:../uvc.c      ****                             /* We can start streaming video now. */
4049:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
4050:../uvc.c      **** 
4051:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4052:../uvc.c      ****                             {
4053:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
4054:../uvc.c      ****                             }
4055:../uvc.c      **** 	#endif
4056:../uvc.c      ****                            switch (glCommitCtrl[1])
4057:../uvc.c      ****                              {
4058:../uvc.c      ****                              	case 4: //1944
4059:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
4060:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4061:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4062:../uvc.c      ****                              		break;
4063:../uvc.c      ****                              	case 3: //1080
4064:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
4065:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4066:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4067:../uvc.c      ****                              		break;
4068:../uvc.c      ****                              	case 2: //720
4069:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
4070:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4071:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4072:../uvc.c      ****                              		break;
4073:../uvc.c      ****                             	case 1: //VGA
4074:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
4075:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4076:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4077:../uvc.c      ****                              		break;
4078:../uvc.c      ****                               	default:
4079:../uvc.c      ****                              		break;
4080:../uvc.c      ****                              }
4081:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
4082:../uvc.c      **** 
4083:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
4084:../uvc.c      **** 
4085:../uvc.c      ****                         }
4086:../uvc.c      ****                         break;
4087:../uvc.c      **** 
4088:../uvc.c      ****                     default:
4089:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4090:../uvc.c      ****                         break;
4091:../uvc.c      ****                 }
4092:../uvc.c      ****                 break;
4093:../uvc.c      **** 
4094:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
4095:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
4096:../uvc.c      ****             	switch (bRequest)
4097:../uvc.c      ****                 {
4098:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4099:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
4100:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4101:../uvc.c      ****                         break;
4102:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4103:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
4104:../uvc.c      ****                         glEp0Buffer[1] = 0;
4105:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4106:../uvc.c      ****                         break;
4107:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
4108:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4109:../uvc.c      ****                         {
4110:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4111:../uvc.c      ****                         }
4112:../uvc.c      ****                         else
4113:../uvc.c      ****                         {
4114:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4115:../uvc.c      ****                         }
4116:../uvc.c      ****                         break;
4117:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4118:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4119:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4120:../uvc.c      ****                            */
4121:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4122:../uvc.c      ****                                 glCommitCtrl, &readCount);
4123:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4124:../uvc.c      ****                         {
4125:../uvc.c      ****     #if 1
4126:../uvc.c      ****                             /* We can start still streaming video now. */
4127:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
4128:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4129:../uvc.c      ****                             {
4130:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
4131:../uvc.c      ****                             }
4132:../uvc.c      ****     #endif
4133:../uvc.c      ****                             else{
4134:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
4135:../uvc.c      ****                             //stillcont = 0;
4136:../uvc.c      ****                             }
4137:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
4138:../uvc.c      ****                         }else{
4139:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
4140:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
4141:../uvc.c      ****                         }
4142:../uvc.c      ****                         break;
4143:../uvc.c      **** 
4144:../uvc.c      ****                     default:
4145:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4146:../uvc.c      ****                         break;
4147:../uvc.c      ****                 }
4148:../uvc.c      ****                 break;
4149:../uvc.c      **** 
4150:../uvc.c      ****         default:
4151:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4152:../uvc.c      ****             break;
4153:../uvc.c      ****     }
4154:../uvc.c      **** }
4155:../uvc.c      **** 
4156:../uvc.c      **** /*
4157:../uvc.c      ****  * Entry function for the UVC control request processing thread.
4158:../uvc.c      ****  */
4159:../uvc.c      **** void
4160:../uvc.c      **** UVCAppEP0Thread_Entry (
4161:../uvc.c      ****         uint32_t input)
4162:../uvc.c      **** {
4163:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
4164:../uvc.c      ****     uint32_t eventFlag;
4165:../uvc.c      **** 	CyBool_t value;
4166:../uvc.c      **** 	CyBool_t *valueptr = &value;
4167:../uvc.c      **** 
4168:../uvc.c      **** 
4169:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4170:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4171:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
4172:../uvc.c      **** 
4173:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
4174:../uvc.c      **** #endif
4175:../uvc.c      **** 
4176:../uvc.c      ****     /* for interrupt status test */
4177:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4178:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
4179:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
4180:../uvc.c      **** 
4181:../uvc.c      ****     for (;;)
4182:../uvc.c      ****     {
4183:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
4184:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
4185:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
4186:../uvc.c      ****         {
4187:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
4188:../uvc.c      ****             if (!isUsbConnected)
4189:../uvc.c      ****             {
4190:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
4191:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
4192:../uvc.c      ****                 {
4193:../uvc.c      ****                     isUsbConnected = CyTrue;
4194:../uvc.c      ****                 }
4195:../uvc.c      ****             }
4196:../uvc.c      **** #ifdef DbgInfo
4197:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
4198:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
4199:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
4200:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
4201:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
4202:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
4203:../uvc.c      **** #endif
4204:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
4205:../uvc.c      ****             {
4206:../uvc.c      ****             	switch ((wIndex >> 8))
4207:../uvc.c      ****                 {
4208:../uvc.c      **** 
4209:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
4210:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
4211:../uvc.c      ****                         break;
4212:../uvc.c      **** 
4213:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
4214:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
4215:../uvc.c      ****                         break;
4216:../uvc.c      **** 
4217:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
4218:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
4219:../uvc.c      ****                         break;
4220:../uvc.c      **** 
4221:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
4222:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
4223:../uvc.c      ****                         break;
4224:../uvc.c      **** 
4225:../uvc.c      ****                     default:
4226:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
4227:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4228:../uvc.c      ****                         break;
4229:../uvc.c      ****                 }
4230:../uvc.c      ****             }
4231:../uvc.c      **** 
4232:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
4233:../uvc.c      ****             {
4234:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
4235:../uvc.c      **** 
4236:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
4237:../uvc.c      ****                 {
4238:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4239:../uvc.c      ****                 }
4240:../uvc.c      ****                 else
4241:../uvc.c      ****                 {
4242:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
4243:../uvc.c      ****                 }
4244:../uvc.c      ****             }
4245:../uvc.c      **** 
4246:../uvc.c      ****             /* handle interrupt status event */
4247:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
4248:../uvc.c      ****             {
4249:../uvc.c      **** 
4250:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
4251:../uvc.c      ****             	/** preparing interrupt status data **/
4252:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
4253:../uvc.c      **** 
4254:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4255:../uvc.c      **** 
4256:../uvc.c      **** #if 0 //for real button
4257:../uvc.c      **** 				if(value&&(!snapButFlag)){
4258:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4259:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4260:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4261:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4262:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4263:../uvc.c      **** 
4264:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4265:../uvc.c      **** 					interStabuf.size   = 1024;
4266:../uvc.c      **** 					interStabuf.status = 0;
4267:../uvc.c      **** 
4268:../uvc.c      **** 					interStabuf.count = 4;
4269:../uvc.c      **** 
4270:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4271:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4272:../uvc.c      **** 
4273:../uvc.c      **** 					/** send a interrupt status data **/
4274:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4275:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4276:../uvc.c      **** 					{
4277:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4278:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4279:../uvc.c      **** 					}
4280:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
4281:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
4282:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4283:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4284:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4285:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4286:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4287:../uvc.c      **** 
4288:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4289:../uvc.c      **** 					interStabuf.size   = 1024;
4290:../uvc.c      **** 					interStabuf.status = 0;
4291:../uvc.c      **** 
4292:../uvc.c      **** 					interStabuf.count = 4;
4293:../uvc.c      **** 
4294:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4295:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4296:../uvc.c      **** 
4297:../uvc.c      **** 					/** send a interrupt status data **/
4298:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4299:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4300:../uvc.c      **** 					{
4301:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4302:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4303:../uvc.c      **** 					}
4304:../uvc.c      **** 
4305:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
4306:../uvc.c      **** 					stiflag = 0xFF;
4307:../uvc.c      **** 				}
4308:../uvc.c      **** #else			//for botton simulation
4309:../uvc.c      **** 				if(snapButFlag == 0x0f){
4310:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4311:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4312:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4313:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4314:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4315:../uvc.c      **** 
4316:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4317:../uvc.c      **** 					interStabuf.size   = 1024;
4318:../uvc.c      **** 					interStabuf.status = 0;
4319:../uvc.c      **** 
4320:../uvc.c      **** 					interStabuf.count = 4;
4321:../uvc.c      **** 
4322:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4323:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4324:../uvc.c      **** 
4325:../uvc.c      **** 					/** send a interrupt status data **/
4326:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4327:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4328:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4329:../uvc.c      **** 					{
4330:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4331:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4332:../uvc.c      **** 					}
4333:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
4334:../uvc.c      **** 
4335:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
4336:../uvc.c      **** 				}else if(!snapButFlag){
4337:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4338:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4339:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4340:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4341:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4342:../uvc.c      **** 
4343:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4344:../uvc.c      **** 					interStabuf.size   = 1024;
4345:../uvc.c      **** 					interStabuf.status = 0;
4346:../uvc.c      **** 
4347:../uvc.c      **** 					interStabuf.count = 4;
4348:../uvc.c      **** 
4349:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4350:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4351:../uvc.c      **** 
4352:../uvc.c      **** 					/** send a interrupt status data **/
4353:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4354:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4355:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4356:../uvc.c      **** 					{
4357:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4358:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4359:../uvc.c      **** 					}
4360:../uvc.c      **** 
4361:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
4362:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
4363:../uvc.c      **** 				}
4364:../uvc.c      **** #endif
4365:../uvc.c      **** 
4366:../uvc.c      ****             }
4367:../uvc.c      **** 
4368:../uvc.c      **** 
4369:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4370:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
4371:../uvc.c      ****             {
4372:../uvc.c      ****                 /* Get the command buffer */
4373:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
4374:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4375:../uvc.c      ****                 {
4376:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
4377:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4378:../uvc.c      ****                 }
4379:../uvc.c      **** 
4380:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
4381:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
4382:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
4383:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
4384:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
4385:../uvc.c      ****                  * register value high byte and register value low byte.
4386:../uvc.c      ****                  */
4387:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
4388:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
4389:../uvc.c      ****                 {
4390:../uvc.c      ****                     if (dmaInfo.count == 3)
4391:../uvc.c      ****                     {
4392:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
4393:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
4394:../uvc.c      ****                         dmaInfo.count = 3;
4395:../uvc.c      ****                     }
4396:../uvc.c      ****                     else if (dmaInfo.count == 4)
4397:../uvc.c      ****                     {
4398:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
4399:../uvc.c      ****                         {
4400:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
4401:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
4402:../uvc.c      ****                         }
4403:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
4404:../uvc.c      ****                     }
4405:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
4406:../uvc.c      ****                 }
4407:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
4408:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
4409:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
4410:../uvc.c      ****                  */
4411:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
4412:../uvc.c      ****                 {
4413:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4414:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
4415:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4416:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
4417:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
4418:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4419:../uvc.c      ****                         	break;
4420:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
4421:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
4422:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4423:../uvc.c      ****                         	break;*/
4424:../uvc.c      ****                     dmaInfo.count -= 2;
4425:../uvc.c      ****                 }
4426:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
4427:../uvc.c      ****                 else
4428:../uvc.c      ****                 {
4429:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
4430:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
4431:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
4432:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
4433:../uvc.c      ****                 }
4434:../uvc.c      **** 
4435:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
4436:../uvc.c      ****                 dmaInfo.size   = 1024;
4437:../uvc.c      ****                 dmaInfo.status = 0;
4438:../uvc.c      **** 
4439:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
4440:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
4441:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4442:../uvc.c      ****                 {
4443:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
4444:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4445:../uvc.c      ****                 }
4446:../uvc.c      **** 
4447:../uvc.c      ****                 /* Wait until the response has gone out. */
4448:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
4449:../uvc.c      **** 
4450:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
4451:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4452:../uvc.c      ****                 {
4453:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
4454:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4455:../uvc.c      ****                 }
4456:../uvc.c      ****             }
4457:../uvc.c      **** #endif
4458:../uvc.c      ****         }
4459:../uvc.c      ****         /* Allow other ready threads to run. */
4460:../uvc.c      ****         CyU3PThreadRelinquish ();
4461:../uvc.c      ****     }
4462:../uvc.c      **** }
4463:../uvc.c      **** 
4464:../uvc.c      **** /*
4465:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
4466:../uvc.c      ****  * added 10/2013
4467:../uvc.c      ****  */
4468:../uvc.c      **** /*
4469:../uvc.c      **** static uint8_t timeDelay[64] = {
4470:../uvc.c      **** 
4471:../uvc.c      **** };
4472:../uvc.c      **** */
4473:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 4473 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
4474:../uvc.c      **** 
4475:../uvc.c      **** 	uint16_t count = 0, cmdCopyIdx = 0, count1 = 0, cmdQuIdx = 0; //
4476:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4477:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4478:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
4479:../uvc.c      **** 	VdcmdDes  *lcStaDes;
4480:../uvc.c      **** 	uint32_t flag = 0;
4481:../uvc.c      **** 	uint8_t  cmdFlag = 0;
4482:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
4483:../uvc.c      **** 	uint8_t i;
4484:../uvc.c      **** 	uint16_t delaytime;
4485:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
4486:../uvc.c      **** 
4487:../uvc.c      **** #if 0 //for test the command queue
4488:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
4489:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4490:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
4491:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4492:../uvc.c      **** 		lcCmdDes += 1;
4493:../uvc.c      **** 	}
4494:../uvc.c      **** 	lcCmdDes = statQuptr->startAdd;
4495:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4496:../uvc.c      **** 		CyU3PDebugPrint (4, "State Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n",
4497:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4498:../uvc.c      **** 		lcCmdDes += 1;
4499:../uvc.c      **** 	}
4500:../uvc.c      **** 
4501:../uvc.c      **** #endif
4502:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
4503:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 4503 0
  36 0004 30229FE5 		ldr	r2, .L25
4480:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 4480 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
4473:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 4473 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 4503 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 18029FE5 		ldr	r0, .L25+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
4480:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 4480 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 4503 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
4504:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 4504 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 FC119FE5 		ldr	r1, .L25+8
  71 0044 FC519FE5 		ldr	r5, .L25+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
4505:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 4505 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
4506:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 4506 0
  79 005c DC019FE5 		ldr	r0, .L25+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
4507:../uvc.c      **** 
4508:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 4508 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
4509:../uvc.c      ****         /* Allow other ready threads to run. */
4510:../uvc.c      **** 
4511:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 4511 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
4508:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 4508 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
4512:../uvc.c      **** 	}
4513:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 4513 0
  92 0078 C8019FE5 		ldr	r0, .L25+12
  93 007c C8119FE5 		ldr	r1, .L25+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 B8619FE5 		ldr	r6, .L25+20
  99 0094 B8B19FE5 		ldr	fp, .L25+24
4514:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
4515:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
4516:../uvc.c      **** 	//CyU3PThreadSleep(100);
4517:../uvc.c      **** 	//SetCurCmd();
4518:../uvc.c      **** 	/*********** the loop of the thread ***********/
4519:../uvc.c      **** 	for(;;){
4520:../uvc.c      **** 
4521:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 4521 0
 101 0098 0070E0E3 		mvn	r7, #0
4522:../uvc.c      **** /*  // for test GPIO output
4523:../uvc.c      **** 		if(trigger)
4524:../uvc.c      **** 		{
4525:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
4526:../uvc.c      **** 			{
4527:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
4528:../uvc.c      **** 			}
4529:../uvc.c      **** 
4530:../uvc.c      **** 		}else{
4531:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
4532:../uvc.c      **** 			{
4533:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
4534:../uvc.c      **** 			}
4535:../uvc.c      **** 
4536:../uvc.c      **** 		}
4537:../uvc.c      **** */
4538:../uvc.c      **** 		if(0&&streamingRecove){//start stream again after the USB-pipe reset
4539:../uvc.c      **** 			CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
4540:../uvc.c      ****             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_OR);
4541:../uvc.c      **** 
4542:../uvc.c      ****             if (apiRetStatus != CY_U3P_SUCCESS)
4543:../uvc.c      ****             {
4544:../uvc.c      ****                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetStatus);
4545:../uvc.c      ****             }
4546:../uvc.c      **** 		}
4547:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4548:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4549:../uvc.c      **** 			/* find an available reading I2C command in the state queue */
4550:../uvc.c      **** 			lcStaDes = (VdcmdDes*)statQuptr->readPtr;
4551:../uvc.c      **** 			//if(0 && (lcStaDes->cmdFlag == CyTrue)){ /* for state queue it's not used right now. */
4552:../uvc.c      **** 				i = 0;
4553:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 4553 0
 103 009c 0090A0E3 		mov	r9, #0
4554:../uvc.c      **** 					i++;
4555:../uvc.c      **** 					lcCmdDes = lcStaDes->cmdDesNext;
4556:../uvc.c      **** 					statQuptr->readPtr = lcStaDes;
4557:../uvc.c      **** 				}
4558:../uvc.c      **** #if 0
4559:../uvc.c      **** 				if(lcStaDes->cmdFlag != deswait){
4560:../uvc.c      **** 				i = lcStaDes->curNum;
4561:../uvc.c      **** 				regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
4562:../uvc.c      **** 				devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
4563:../uvc.c      **** 				data = ((lcStaDes->CmdPar)+i)->Data;
4564:../uvc.c      **** 				//delaytime = ((lcStaDes->CmdPar)+i)->DelayT;
4565:../uvc.c      **** 
4566:../uvc.c      **** 				//for(i = 0; i < lcStaDes->NumPara; i++){
4567:../uvc.c      **** 					//regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
4568:../uvc.c      **** 					//devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
4569:../uvc.c      **** 					((lcStaDes->CmdPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
4570:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4571:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
4572:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
4573:../uvc.c      **** #endif
4574:../uvc.c      **** 				//}
4575:../uvc.c      **** 				lcStaDes->cmdFlag = CyFalse;
4576:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->cmdDesNext; //update command queue read pointer
4577:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
4578:../uvc.c      **** 				/* setting delay */
4579:../uvc.c      **** 				delaytime = 300;
4580:../uvc.c      **** 				CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
4581:../uvc.c      **** 				CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
4582:../uvc.c      **** 			} //end of the if condition statment
4583:../uvc.c      **** #endif
4584:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
4585:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
4586:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4587:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
4588:../uvc.c      **** 
4589:../uvc.c      **** 				/*
4590:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4591:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4592:../uvc.c      **** 				*/
4593:../uvc.c      **** 
4594:../uvc.c      **** 				/* find a available command */
4595:../uvc.c      **** 				i = 0;
4596:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
4597:../uvc.c      **** 					i++;
4598:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
4599:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
4600:../uvc.c      **** 				}
4601:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
4602:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
4603:../uvc.c      **** 					i = lcCmdDes->curNum;
4604:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
4605:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
4606:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
4607:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
4608:../uvc.c      **** #if 1
4609:../uvc.c      **** 					switch(lcCmdDes->CmdID){
4610:../uvc.c      **** 						case 0x20:
4611:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
4612:../uvc.c      **** 							delaytime = 500;
4613:../uvc.c      **** 							break;
4614:../uvc.c      **** 						case 0x21:
4615:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
4616:../uvc.c      **** 							delaytime = 500;
4617:../uvc.c      **** 							break;
4618:../uvc.c      **** 						case 0x22:
4619:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4620:../uvc.c      **** 							delaytime = 300;
4621:../uvc.c      **** 							break;
4622:../uvc.c      **** 						case 0x23:
4623:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4624:../uvc.c      **** 							delaytime = 300;
4625:../uvc.c      **** 							break;
4626:../uvc.c      **** 						default:
4627:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
4628:../uvc.c      **** 							break;
4629:../uvc.c      **** 					}
4630:../uvc.c      **** #endif
4631:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
4632:../uvc.c      **** 					/** timer's ticket modify **/
4633:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
4634:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
4635:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
4636:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
4637:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
4638:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4639:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
4640:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
4641:../uvc.c      **** #endif
4642:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
4643:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
4644:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
4645:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
4646:../uvc.c      **** 						}else{
4647:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
4648:../uvc.c      **** 						}
4649:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
4650:../uvc.c      **** 					}else{
4651:../uvc.c      **** 						lcCmdDes->curNum ++;
4652:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 4652 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L20:
4521:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 4521 0
 108 00a4 14308DE2 		add	r3, sp, #20
 109 00a8 2010A0E3 		mov	r1, #32
 110 00ac 0320A0E3 		mov	r2, #3
 111 00b0 A0019FE5 		ldr	r0, .L25+28
 112 00b4 00708DE5 		str	r7, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
4547:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 4547 0
 115 00bc 0710A0E1 		mov	r1, r7
 116 00c0 1C0096E5 		ldr	r0, [r6, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
4553:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 119              		.loc 1 4553 0
 120 00c8 101096E5 		ldr	r1, [r6, #16]
 121 00cc 3C3091E5 		ldr	r3, [r1, #60]
 122 00d0 000053E3 		cmp	r3, #0
 123 00d4 0300001A 		bne	.L4
 124              	.LVL4:
 125              	.L5:
4554:../uvc.c      **** 					i++;
 126              		.loc 1 4554 0
 127 00d8 012083E2 		add	r2, r3, #1
 128 00dc FF3002E2 		and	r3, r2, #255
 129              	.LVL5:
4553:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 4553 0
 131 00e0 3F0053E3 		cmp	r3, #63
 132 00e4 FBFFFF9A 		bls	.L5
 133              	.LVL6:
 134              	.L4:
4584:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 135              		.loc 1 4584 0
 136 00e8 1C0096E5 		ldr	r0, [r6, #28]
 137 00ec FEFFFFEB 		bl	_txe_mutex_put
 138              	.LVL7:
4586:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 139              		.loc 1 4586 0
 140 00f0 1C0095E5 		ldr	r0, [r5, #28]
 141 00f4 0010E0E3 		mvn	r1, #0
 142 00f8 FEFFFFEB 		bl	_txe_mutex_get
4587:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 143              		.loc 1 4587 0
 144 00fc 104095E5 		ldr	r4, [r5, #16]
 145              	.LVL8:
4596:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 146              		.loc 1 4596 0
 147 0100 3C2094E5 		ldr	r2, [r4, #60]
 148 0104 000052E3 		cmp	r2, #0
 149 0108 0800001A 		bne	.L6
 150 010c 0030A0E3 		mov	r3, #0
 151              	.LVL9:
 152              	.L7:
4598:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 153              		.loc 1 4598 0
 154 0110 344094E5 		ldr	r4, [r4, #52]
 155              	.LVL10:
4597:../uvc.c      **** 					i++;
 156              		.loc 1 4597 0
 157 0114 01A083E2 		add	sl, r3, #1
4596:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 158              		.loc 1 4596 0
 159 0118 3C2094E5 		ldr	r2, [r4, #60]
4597:../uvc.c      **** 					i++;
 160              		.loc 1 4597 0
 161 011c FF300AE2 		and	r3, sl, #255
 162              	.LVL11:
4596:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 163              		.loc 1 4596 0
 164 0120 3F0053E3 		cmp	r3, #63
 165 0124 00005293 		cmpls	r2, #0
 166 0128 F8FFFF0A 		beq	.L7
 167 012c 104085E5 		str	r4, [r5, #16]
 168              	.LVL12:
 169              	.L6:
4602:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
 170              		.loc 1 4602 0
 171 0130 000052E3 		cmp	r2, #0
 172 0134 2D00000A 		beq	.L8
 173              	.LVL13:
4604:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 174              		.loc 1 4604 0
 175 0138 0110D4E5 		ldrb	r1, [r4, #1]	@ zero_extendqisi2
4609:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 176              		.loc 1 4609 0
 177 013c 0000D4E5 		ldrb	r0, [r4, #0]	@ zero_extendqisi2
4604:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 178              		.loc 1 4604 0
 179 0140 813081E0 		add	r3, r1, r1, asl #1
 180 0144 83E084E0 		add	lr, r4, r3, asl #1
4609:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 181              		.loc 1 4609 0
 182 0148 20C040E2 		sub	ip, r0, #32
4605:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 183              		.loc 1 4605 0
 184 014c 0510DEE5 		ldrb	r1, [lr, #5]	@ zero_extendqisi2
4604:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 185              		.loc 1 4604 0
 186 0150 0400DEE5 		ldrb	r0, [lr, #4]	@ zero_extendqisi2
 187              	.LVL14:
4606:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 188              		.loc 1 4606 0
 189 0154 0620DEE5 		ldrb	r2, [lr, #6]	@ zero_extendqisi2
 190              	.LVL15:
4607:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 191              		.loc 1 4607 0
 192 0158 B8A0DEE1 		ldrh	sl, [lr, #8]
 193              	.LVL16:
4609:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 194              		.loc 1 4609 0
 195 015c 03005CE3 		cmp	ip, #3
 196 0160 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 197 0164 1A0000EA 		b	.L9
 198              	.L14:
 199 0168 E0010000 		.word	.L10
 200 016c C4010000 		.word	.L11
 201 0170 78010000 		.word	.L13
 202 0174 78010000 		.word	.L13
 203              	.L13:
4623:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 204              		.loc 1 4623 0
 205 0178 8230A0E3 		mov	r3, #130
 206 017c FEFFFFEB 		bl	SensorSetIrisControl
 207              	.LVL17:
4625:../uvc.c      **** 							break;
 208              		.loc 1 4625 0
 209 0180 4B1FA0E3 		mov	r1, #300
 210              	.LVL18:
 211              	.L15:
4634:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 212              		.loc 1 4634 0
 213 0184 0020A0E3 		mov	r2, #0
 214 0188 B0009FE5 		ldr	r0, .L25+4
 215 018c FEFFFFEB 		bl	_txe_timer_change
4635:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 216              		.loc 1 4635 0
 217 0190 A8009FE5 		ldr	r0, .L25+4
 218 0194 FEFFFFEB 		bl	_txe_timer_activate
 219              	.LVL19:
4642:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 220              		.loc 1 4642 0
 221 0198 01A0D4E5 		ldrb	sl, [r4, #1]	@ zero_extendqisi2
 222 019c 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 223 01a0 0A0052E1 		cmp	r2, sl
4651:../uvc.c      **** 						lcCmdDes->curNum ++;
 224              		.loc 1 4651 0
 225 01a4 01A08A12 		addne	sl, sl, #1
 226 01a8 01A0C415 		strneb	sl, [r4, #1]
 227              		.loc 1 4652 0
 228 01ac 3C808415 		strne	r8, [r4, #60]
4642:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 229              		.loc 1 4642 0
 230 01b0 1400000A 		beq	.L24
 231              	.LVL20:
 232              	.L19:
4653:../uvc.c      **** 					}
4654:../uvc.c      **** 				}else{
4655:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
4656:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
4657:../uvc.c      **** 				}
4658:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 233              		.loc 1 4658 0
 234 01b4 1C0095E5 		ldr	r0, [r5, #28]
 235 01b8 FEFFFFEB 		bl	_txe_mutex_put
 236              	.LVL21:
4659:../uvc.c      **** 			}
4660:../uvc.c      **** /*
4661:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4662:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4663:../uvc.c      **** */
4664:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4665:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
4666:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
4667:../uvc.c      **** #endif
4668:../uvc.c      **** 
4669:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
4670:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
4671:../uvc.c      **** #if 0
4672:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
4673:../uvc.c      **** 
4674:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
4675:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
4676:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
4677:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
4678:../uvc.c      **** 			    i = 0;
4679:../uvc.c      **** 				 switch(cmdCopyIdx)
4680:../uvc.c      **** 				 {
4681:../uvc.c      **** 					 case BrgtCtlID1:
4682:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
4683:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4684:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
4685:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4686:../uvc.c      **** 							 i++;
4687:../uvc.c      **** 						 }
4688:../uvc.c      **** 						 else{
4689:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4690:../uvc.c      **** 						 }
4691:../uvc.c      **** 
4692:../uvc.c      **** 						 CyU3PBusyWait(500);
4693:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
4694:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4695:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4696:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4697:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4698:../uvc.c      **** 						 }
4699:../uvc.c      **** 						 else{
4700:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4701:../uvc.c      **** 						 }
4702:../uvc.c      **** 						 break;
4703:../uvc.c      **** 					 case HueCtlID5:
4704:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4705:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4706:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4707:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4708:../uvc.c      **** 						 }
4709:../uvc.c      **** 						 else{
4710:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4711:../uvc.c      **** 						 }
4712:../uvc.c      **** 						 break;
4713:../uvc.c      **** 					 case SaturCtlID6:
4714:../uvc.c      **** 					 case WBTLevCtlID10:
4715:../uvc.c      **** 					 default:
4716:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
4717:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4718:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4719:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4720:../uvc.c      **** 						 }
4721:../uvc.c      **** 						 else{
4722:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4723:../uvc.c      **** 						 }
4724:../uvc.c      **** 						 break;
4725:../uvc.c      **** 				 }
4726:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
4727:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
4728:../uvc.c      **** 			}
4729:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
4730:../uvc.c      **** #endif
4731:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
4732:../uvc.c      **** 		/* Allow other ready threads to run. */
4733:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4734:../uvc.c      **** 			CyU3PThreadRelinquish ();
 237              		.loc 1 4734 0
 238 01bc FEFFFFEB 		bl	_txe_thread_relinquish
4735:../uvc.c      **** 		}
 239              		.loc 1 4735 0
 240 01c0 B7FFFFEA 		b	.L20
 241              	.LVL22:
 242              	.L11:
4615:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 243              		.loc 1 4615 0
 244 01c4 5230A0E3 		mov	r3, #82
 245 01c8 FEFFFFEB 		bl	SensorSetIrisControl
 246              	.LVL23:
4617:../uvc.c      **** 							break;
 247              		.loc 1 4617 0
 248 01cc 7D1FA0E3 		mov	r1, #500
 249 01d0 EBFFFFEA 		b	.L15
 250              	.LVL24:
 251              	.L9:
4627:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 252              		.loc 1 4627 0
 253 01d4 FEFFFFEB 		bl	SensorSetControl
 254              	.LVL25:
 255 01d8 0A10A0E1 		mov	r1, sl
4628:../uvc.c      **** 							break;
 256              		.loc 1 4628 0
 257 01dc E8FFFFEA 		b	.L15
 258              	.LVL26:
 259              	.L10:
4611:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
 260              		.loc 1 4611 0
 261 01e0 8230A0E3 		mov	r3, #130
 262 01e4 FEFFFFEB 		bl	SensorSetIrisControl
 263              	.LVL27:
4613:../uvc.c      **** 							break;
 264              		.loc 1 4613 0
 265 01e8 7D1FA0E3 		mov	r1, #500
 266 01ec E4FFFFEA 		b	.L15
 267              	.LVL28:
 268              	.L8:
4655:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 269              		.loc 1 4655 0
 270 01f0 FA1FA0E3 		mov	r1, #1000
 271 01f4 44009FE5 		ldr	r0, .L25+4
 272 01f8 FEFFFFEB 		bl	_txe_timer_change
4656:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 273              		.loc 1 4656 0
 274 01fc 3C009FE5 		ldr	r0, .L25+4
 275 0200 FEFFFFEB 		bl	_txe_timer_activate
 276 0204 EAFFFFEA 		b	.L19
 277              	.LVL29:
 278              	.L24:
4644:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 279              		.loc 1 4644 0
 280 0208 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
4643:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 281              		.loc 1 4643 0
 282 020c 3C9084E5 		str	r9, [r4, #60]
4644:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 283              		.loc 1 4644 0
 284 0210 23005CE3 		cmp	ip, #35
4645:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 285              		.loc 1 4645 0
 286 0214 24C04C82 		subhi	ip, ip, #36
 287 0218 8CC08C80 		addhi	ip, ip, ip, asl #1
4647:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 288              		.loc 1 4647 0
 289 021c 8CC08C90 		addls	ip, ip, ip, asl #1
4645:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 290              		.loc 1 4645 0
 291 0220 8CC18B80 		addhi	ip, fp, ip, asl #3
4647:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 292              		.loc 1 4647 0
 293 0224 8CC18B90 		addls	ip, fp, ip, asl #3
4645:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 294              		.loc 1 4645 0
 295 0228 1090CC85 		strhib	r9, [ip, #16]
4647:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 296              		.loc 1 4647 0
 297 022c 9091CC95 		strlsb	r9, [ip, #400]
4649:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 298              		.loc 1 4649 0
 299 0230 344094E5 		ldr	r4, [r4, #52]
 300              	.LVL30:
 301 0234 104085E5 		str	r4, [r5, #16]
 302 0238 DDFFFFEA 		b	.L19
 303              	.L26:
 304              		.align	2
 305              	.L25:
 306 023c 00000000 		.word	I2CCmdCb
 307 0240 00000000 		.word	I2CCmdTimer
 308 0244 00000000 		.word	.LC0
 309 0248 00000000 		.word	cmdQu
 310 024c 14000000 		.word	.LC1
 311 0250 00000000 		.word	statQu
 312 0254 00000000 		.word	.LANCHOR1
 313 0258 00000000 		.word	.LANCHOR0
 314              		.cfi_endproc
 315              	.LFE26:
 317              		.align	2
 318              		.global	I2CCmdCb
 320              	I2CCmdCb:
 321              	.LFB18:
3043:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 322              		.loc 1 3043 0
 323              		.cfi_startproc
 324              		@ args = 0, pretend = 0, frame = 0
 325              		@ frame_needed = 0, uses_anonymous_args = 0
 326              	.LVL31:
3044:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
 327              		.loc 1 3044 0
 328 025c 28209FE5 		ldr	r2, .L28
3043:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 329              		.loc 1 3043 0
 330 0260 0030A0E1 		mov	r3, r0
 331 0264 10402DE9 		stmfd	sp!, {r4, lr}
 332              	.LCFI2:
 333              		.cfi_def_cfa_offset 8
3044:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
 334              		.loc 1 3044 0
 335 0268 20109FE5 		ldr	r1, .L28+4
 336 026c 002092E5 		ldr	r2, [r2, #0]
 337 0270 0400A0E3 		mov	r0, #4
 338              	.LVL32:
 339              		.cfi_offset 14, -4
 340              		.cfi_offset 4, -8
 341 0274 FEFFFFEB 		bl	CyU3PDebugPrint
 342              	.LVL33:
3045:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 343              		.loc 1 3045 0
 344 0278 14009FE5 		ldr	r0, .L28+8
 345 027c 2010A0E3 		mov	r1, #32
 346 0280 0020A0E3 		mov	r2, #0
3046:../uvc.c      **** }
 347              		.loc 1 3046 0
 348 0284 1040BDE8 		ldmfd	sp!, {r4, lr}
3045:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 349              		.loc 1 3045 0
 350 0288 FEFFFFEA 		b	_txe_event_flags_set
 351              	.L29:
 352              		.align	2
 353              	.L28:
 354 028c 00000000 		.word	posTick
 355 0290 38000000 		.word	.LC2
 356 0294 00000000 		.word	.LANCHOR0
 357              		.cfi_endproc
 358              	.LFE18:
 360              		.align	2
 362              	CyFxUVCApplnUSBEventCB:
 363              	.LFB9:
2090:../uvc.c      **** {
 364              		.loc 1 2090 0
 365              		.cfi_startproc
 366              		@ args = 0, pretend = 0, frame = 8
 367              		@ frame_needed = 0, uses_anonymous_args = 0
 368              	.LVL34:
2091:../uvc.c      ****     switch (evtype)
 369              		.loc 1 2091 0
 370 0298 020050E3 		cmp	r0, #2
2090:../uvc.c      **** {
 371              		.loc 1 2090 0
 372 029c 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 373              	.LCFI3:
 374              		.cfi_def_cfa_offset 16
 375 02a0 0130A0E1 		mov	r3, r1
 376 02a4 10D04DE2 		sub	sp, sp, #16
 377              	.LCFI4:
 378              		.cfi_def_cfa_offset 32
2090:../uvc.c      **** {
 379              		.loc 1 2090 0
 380 02a8 0040A0E1 		mov	r4, r0
 381              		.cfi_offset 14, -4
 382              		.cfi_offset 6, -8
 383              		.cfi_offset 5, -12
 384              		.cfi_offset 4, -16
2091:../uvc.c      ****     switch (evtype)
 385              		.loc 1 2091 0
 386 02ac 3C00000A 		beq	.L33
 387 02b0 040050E3 		cmp	r0, #4
 388 02b4 2200000A 		beq	.L34
 389 02b8 010050E3 		cmp	r0, #1
 390 02bc 0100000A 		beq	.L36
 391              	.LVL35:
 392              	.L30:
2130:../uvc.c      **** }
 393              		.loc 1 2130 0
 394 02c0 10D08DE2 		add	sp, sp, #16
 395 02c4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 396              	.LVL36:
 397              	.L36:
2114:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x04; //set bit2
 398              		.loc 1 2114 0
 399 02c8 4C519FE5 		ldr	r5, .L37
2112:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 400              		.loc 1 2112 0
 401 02cc 0020A0E1 		mov	r2, r0
 402 02d0 48119FE5 		ldr	r1, .L37+4
 403              	.LVL37:
 404 02d4 0400A0E3 		mov	r0, #4
 405              	.LVL38:
 406 02d8 FEFFFFEB 		bl	CyU3PDebugPrint
2113:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 407              		.loc 1 2113 0
 408 02dc 0400A0E1 		mov	r0, r4
 409 02e0 FEFFFFEB 		bl	CyU3PGpifDisable
2114:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x04; //set bit2
 410              		.loc 1 2114 0
 411 02e4 2A20D5E5 		ldrb	r2, [r5, #42]	@ zero_extendqisi2
2115:../uvc.c      ****             gpif_initialized = 0;
 412              		.loc 1 2115 0
 413 02e8 00C0A0E3 		mov	ip, #0
2114:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x04; //set bit2
 414              		.loc 1 2114 0
 415 02ec 04E082E3 		orr	lr, r2, #4
 416              	.LBB16:
 417              	.LBB17:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 418              		.loc 1 2074 0
 419 02f0 0410A0E1 		mov	r1, r4
 420 02f4 0500A0E1 		mov	r0, r5
 421 02f8 0220A0E3 		mov	r2, #2
 422 02fc 0C308DE2 		add	r3, sp, #12
 423              	.LBE17:
 424              	.LBE16:
2114:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x04; //set bit2
 425              		.loc 1 2114 0
 426 0300 2AE0C5E5 		strb	lr, [r5, #42]
2115:../uvc.c      ****             gpif_initialized = 0;
 427              		.loc 1 2115 0
 428 0304 A8C085E5 		str	ip, [r5, #168]
2116:../uvc.c      ****             isUsbConnected = CyFalse;
 429              		.loc 1 2116 0
 430 0308 B0C085E5 		str	ip, [r5, #176]
2117:../uvc.c      ****             streamingStarted = CyFalse;
 431              		.loc 1 2117 0
 432 030c ACC085E5 		str	ip, [r5, #172]
 433              	.LBB19:
 434              	.LBB18:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 435              		.loc 1 2074 0
 436 0310 00C08DE5 		str	ip, [sp, #0]
 437 0314 FEFFFFEB 		bl	_txe_event_flags_get
 438 0318 004050E2 		subs	r4, r0, #0
 439 031c E7FFFF1A 		bne	.L30
2077:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 440              		.loc 1 2077 0
 441 0320 0110E0E3 		mvn	r1, #1
 442 0324 0220A0E3 		mov	r2, #2
 443 0328 0500A0E1 		mov	r0, r5
 444              	.L35:
 445 032c FEFFFFEB 		bl	_txe_event_flags_set
2080:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 446              		.loc 1 2080 0
 447 0330 0500A0E1 		mov	r0, r5
 448 0334 0210A0E3 		mov	r1, #2
 449 0338 0420A0E1 		mov	r2, r4
 450 033c FEFFFFEB 		bl	_txe_event_flags_set
 451 0340 DEFFFFEA 		b	.L30
 452              	.LVL39:
 453              	.L34:
 454              	.LBE18:
 455              	.LBE19:
2096:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x01; //set bit0
 456              		.loc 1 2096 0
 457 0344 D0509FE5 		ldr	r5, .L37
2094:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 458              		.loc 1 2094 0
 459 0348 D4109FE5 		ldr	r1, .L37+8
 460              	.LVL40:
 461 034c 0020A0E1 		mov	r2, r0
 462 0350 FEFFFFEB 		bl	CyU3PDebugPrint
 463              	.LVL41:
2095:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 464              		.loc 1 2095 0
 465 0354 0100A0E3 		mov	r0, #1
 466 0358 FEFFFFEB 		bl	CyU3PGpifDisable
2096:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x01; //set bit0
 467              		.loc 1 2096 0
 468 035c 2A00D5E5 		ldrb	r0, [r5, #42]	@ zero_extendqisi2
2097:../uvc.c      ****             gpif_initialized = 0;
 469              		.loc 1 2097 0
 470 0360 00C0A0E3 		mov	ip, #0
2096:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x01; //set bit0
 471              		.loc 1 2096 0
 472 0364 01E080E3 		orr	lr, r0, #1
 473              	.LBB20:
 474              	.LBB21:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 475              		.loc 1 2074 0
 476 0368 0110A0E3 		mov	r1, #1
 477 036c 0220A0E3 		mov	r2, #2
 478 0370 0500A0E1 		mov	r0, r5
 479 0374 0C308DE2 		add	r3, sp, #12
 480              	.LBE21:
 481              	.LBE20:
2096:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x01; //set bit0
 482              		.loc 1 2096 0
 483 0378 2AE0C5E5 		strb	lr, [r5, #42]
2097:../uvc.c      ****             gpif_initialized = 0;
 484              		.loc 1 2097 0
 485 037c A8C085E5 		str	ip, [r5, #168]
2098:../uvc.c      ****             streamingStarted = CyFalse;
 486              		.loc 1 2098 0
 487 0380 ACC085E5 		str	ip, [r5, #172]
 488              	.LBB23:
 489              	.LBB22:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 490              		.loc 1 2074 0
 491 0384 00C08DE5 		str	ip, [sp, #0]
 492 0388 FEFFFFEB 		bl	_txe_event_flags_get
 493 038c 004050E2 		subs	r4, r0, #0
2077:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 494              		.loc 1 2077 0
 495 0390 0500A001 		moveq	r0, r5
 496 0394 0110E003 		mvneq	r1, #1
 497 0398 0220A003 		moveq	r2, #2
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 498              		.loc 1 2074 0
 499 039c C7FFFF1A 		bne	.L30
 500 03a0 E1FFFFEA 		b	.L35
 501              	.LVL42:
 502              	.L33:
 503              	.LBE22:
 504              	.LBE23:
2105:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x02; //set bit1
 505              		.loc 1 2105 0
 506 03a4 70509FE5 		ldr	r5, .L37
2103:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 507              		.loc 1 2103 0
 508 03a8 0020A0E1 		mov	r2, r0
 509 03ac 74109FE5 		ldr	r1, .L37+12
 510              	.LVL43:
 511 03b0 0400A0E3 		mov	r0, #4
 512              	.LVL44:
 513 03b4 FEFFFFEB 		bl	CyU3PDebugPrint
2104:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 514              		.loc 1 2104 0
 515 03b8 0100A0E3 		mov	r0, #1
 516 03bc FEFFFFEB 		bl	CyU3PGpifDisable
2105:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x02; //set bit1
 517              		.loc 1 2105 0
 518 03c0 2A10D5E5 		ldrb	r1, [r5, #42]	@ zero_extendqisi2
2106:../uvc.c      ****             gpif_initialized = 0;
 519              		.loc 1 2106 0
 520 03c4 0060A0E3 		mov	r6, #0
2105:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x02; //set bit1
 521              		.loc 1 2105 0
 522 03c8 02C081E3 		orr	ip, r1, #2
 523              	.LBB24:
 524              	.LBB26:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 525              		.loc 1 2074 0
 526 03cc 0500A0E1 		mov	r0, r5
 527 03d0 0110A0E3 		mov	r1, #1
 528 03d4 0420A0E1 		mov	r2, r4
 529 03d8 0C308DE2 		add	r3, sp, #12
 530              	.LBE26:
 531              	.LBE24:
2106:../uvc.c      ****             gpif_initialized = 0;
 532              		.loc 1 2106 0
 533 03dc A86085E5 		str	r6, [r5, #168]
2107:../uvc.c      ****             streamingStarted = CyFalse;
 534              		.loc 1 2107 0
 535 03e0 AC6085E5 		str	r6, [r5, #172]
 536              	.LBB28:
 537              	.LBB25:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 538              		.loc 1 2074 0
 539 03e4 00608DE5 		str	r6, [sp, #0]
 540              	.LBE25:
 541              	.LBE28:
2105:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x02; //set bit1
 542              		.loc 1 2105 0
 543 03e8 2AC0C5E5 		strb	ip, [r5, #42]
 544              	.LBB29:
 545              	.LBB27:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 546              		.loc 1 2074 0
 547 03ec FEFFFFEB 		bl	_txe_event_flags_get
 548 03f0 006050E2 		subs	r6, r0, #0
 549 03f4 B1FFFF1A 		bne	.L30
2077:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 550              		.loc 1 2077 0
 551 03f8 0420A0E1 		mov	r2, r4
 552 03fc 0500A0E1 		mov	r0, r5
 553 0400 0110E0E3 		mvn	r1, #1
 554 0404 FEFFFFEB 		bl	_txe_event_flags_set
2080:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 555              		.loc 1 2080 0
 556 0408 0500A0E1 		mov	r0, r5
 557 040c 0410A0E1 		mov	r1, r4
 558 0410 0620A0E1 		mov	r2, r6
 559 0414 FEFFFFEB 		bl	_txe_event_flags_set
 560 0418 A8FFFFEA 		b	.L30
 561              	.L38:
 562              		.align	2
 563              	.L37:
 564 041c 00000000 		.word	.LANCHOR0
 565 0420 94000000 		.word	.LC5
 566 0424 50000000 		.word	.LC3
 567 0428 70000000 		.word	.LC4
 568              	.LBE27:
 569              	.LBE29:
 570              		.cfi_endproc
 571              	.LFE9:
 573              		.align	2
 574              		.global	CyFxUvcApplnDmaCallback
 576              	CyFxUvcApplnDmaCallback:
 577              	.LFB11:
2301:../uvc.c      **** {
 578              		.loc 1 2301 0
 579              		.cfi_startproc
 580              		@ args = 0, pretend = 0, frame = 0
 581              		@ frame_needed = 0, uses_anonymous_args = 0
 582              	.LVL45:
2308:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 583              		.loc 1 2308 0
 584 042c 080051E3 		cmp	r1, #8
2301:../uvc.c      **** {
 585              		.loc 1 2301 0
 586 0430 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 587              	.LCFI5:
 588              		.cfi_def_cfa_offset 20
 589 0434 0250A0E1 		mov	r5, r2
 590              		.cfi_offset 14, -4
 591              		.cfi_offset 7, -8
 592              		.cfi_offset 6, -12
 593              		.cfi_offset 5, -16
 594              		.cfi_offset 4, -20
 595 0438 0CD04DE2 		sub	sp, sp, #12
 596              	.LCFI6:
 597              		.cfi_def_cfa_offset 32
2308:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 598              		.loc 1 2308 0
 599 043c 0B00000A 		beq	.L45
2360:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 600              		.loc 1 2360 0
 601 0440 100051E3 		cmp	r1, #16
 602 0444 0700001A 		bne	.L39
2362:../uvc.c      ****         consCount++;
 603              		.loc 1 2362 0
 604 0448 7C319FE5 		ldr	r3, .L48
2363:../uvc.c      ****         streamingStarted = CyTrue;
 605              		.loc 1 2363 0
 606 044c 0120A0E3 		mov	r2, #1
 607              	.LVL46:
2362:../uvc.c      ****         consCount++;
 608              		.loc 1 2362 0
 609 0450 B20CD3E1 		ldrh	r0, [r3, #194]
 610              	.LVL47:
2363:../uvc.c      ****         streamingStarted = CyTrue;
 611              		.loc 1 2363 0
 612 0454 AC2083E5 		str	r2, [r3, #172]
2362:../uvc.c      ****         consCount++;
 613              		.loc 1 2362 0
 614 0458 02C080E0 		add	ip, r0, r2
 615 045c 0C18A0E1 		mov	r1, ip, asl #16
 616              	.LVL48:
 617 0460 2128A0E1 		mov	r2, r1, lsr #16
 618 0464 B22CC3E1 		strh	r2, [r3, #194]	@ movhi
 619              	.L39:
2365:../uvc.c      **** }
 620              		.loc 1 2365 0
 621 0468 0CD08DE2 		add	sp, sp, #12
 622 046c F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 623              	.LVL49:
 624              	.L45:
2310:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 625              		.loc 1 2310 0
 626 0470 B420D2E1 		ldrh	r2, [r2, #4]
 627 0474 54319FE5 		ldr	r3, .L48+4
 628 0478 030052E1 		cmp	r2, r3
 629 047c 3500000A 		beq	.L46
2330:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 630              		.loc 1 2330 0
 631 0480 006095E5 		ldr	r6, [r5, #0]
 632              	.LBB34:
 633              	.LBB36:
2035:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 634              		.loc 1 2035 0
 635 0484 48719FE5 		ldr	r7, .L48+8
2034:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 636              		.loc 1 2034 0
 637 0488 0010E0E3 		mvn	r1, #0
 638              	.LVL50:
 639              	.LBE36:
 640              	.LBE34:
2330:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 641              		.loc 1 2330 0
 642 048c 0C4046E2 		sub	r4, r6, #12
 643              	.LVL51:
 644              	.LBB38:
 645              	.LBB35:
2034:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 646              		.loc 1 2034 0
 647 0490 40019FE5 		ldr	r0, .L48+12
 648              	.LVL52:
 649 0494 FEFFFFEB 		bl	_txe_mutex_get
2035:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 650              		.loc 1 2035 0
 651 0498 0400A0E1 		mov	r0, r4
 652 049c 121D87E2 		add	r1, r7, #1152
 653 04a0 0C20A0E3 		mov	r2, #12
 654 04a4 FEFFFFEB 		bl	CyU3PMemCopy
2036:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 655              		.loc 1 2036 0
 656 04a8 28019FE5 		ldr	r0, .L48+12
 657 04ac FEFFFFEB 		bl	_txe_mutex_put
2041:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 658              		.loc 1 2041 0
 659 04b0 0BC056E5 		ldrb	ip, [r6, #-11]	@ zero_extendqisi2
 660              	.LBE35:
 661              	.LBE38:
2331:../uvc.c      ****                 pb++;
 662              		.loc 1 2331 0
 663 04b4 10419FE5 		ldr	r4, .L48
 664              	.LVL53:
 665              	.LBB39:
 666              	.LBB37:
2041:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 667              		.loc 1 2041 0
 668 04b8 02108CE3 		orr	r1, ip, #2
 669 04bc 0B1046E5 		strb	r1, [r6, #-11]
 670              	.LBE37:
 671              	.LBE39:
2331:../uvc.c      ****                 pb++;
 672              		.loc 1 2331 0
 673 04c0 B60BD4E1 		ldrh	r0, [r4, #182]
2337:../uvc.c      ****                 if(stiflag == 0x0F){
 674              		.loc 1 2337 0
 675 04c4 BA20D4E5 		ldrb	r2, [r4, #186]	@ zero_extendqisi2
2332:../uvc.c      ****                 pbc = input->buffer_p.count;
 676              		.loc 1 2332 0
 677 04c8 B410D5E1 		ldrh	r1, [r5, #4]
2331:../uvc.c      ****                 pb++;
 678              		.loc 1 2331 0
 679 04cc 013080E2 		add	r3, r0, #1
2337:../uvc.c      ****                 if(stiflag == 0x0F){
 680              		.loc 1 2337 0
 681 04d0 0F0052E3 		cmp	r2, #15
2331:../uvc.c      ****                 pb++;
 682              		.loc 1 2331 0
 683 04d4 B63BC4E1 		strh	r3, [r4, #182]	@ movhi
2332:../uvc.c      ****                 pbc = input->buffer_p.count;
 684              		.loc 1 2332 0
 685 04d8 B81BC4E1 		strh	r1, [r4, #184]	@ movhi
2337:../uvc.c      ****                 if(stiflag == 0x0F){
 686              		.loc 1 2337 0
 687 04dc 2E00000A 		beq	.L47
 688              	.L43:
2344:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
 689              		.loc 1 2344 0
 690 04e0 01E0A0E3 		mov	lr, #1
 691 04e4 BCE084E5 		str	lr, [r4, #188]
 692              	.LVL54:
 693              	.L42:
2348:../uvc.c      ****             prodCount++;
 694              		.loc 1 2348 0
 695 04e8 B0ECD4E1 		ldrh	lr, [r4, #192]
2349:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 696              		.loc 1 2349 0
 697 04ec 0C1081E2 		add	r1, r1, #12
2348:../uvc.c      ****             prodCount++;
 698              		.loc 1 2348 0
 699 04f0 01308EE2 		add	r3, lr, #1
 700 04f4 0308A0E1 		mov	r0, r3, asl #16
 701 04f8 20C8A0E1 		mov	ip, r0, lsr #16
2349:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 702              		.loc 1 2349 0
 703 04fc 0128A0E1 		mov	r2, r1, asl #16
 704 0500 2218A0E1 		mov	r1, r2, lsr #16
 705 0504 D0009FE5 		ldr	r0, .L48+16
 706 0508 0020A0E3 		mov	r2, #0
2348:../uvc.c      ****             prodCount++;
 707              		.loc 1 2348 0
 708 050c B0CCC4E1 		strh	ip, [r4, #192]	@ movhi
2349:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 709              		.loc 1 2349 0
 710 0510 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 711              	.LVL55:
2348:../uvc.c      ****             prodCount++;
 712              		.loc 1 2348 0
 713 0514 B0109FE5 		ldr	r1, .L48
2352:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
 714              		.loc 1 2352 0
 715 0518 002050E2 		subs	r2, r0, #0
 716 051c D1FFFF0A 		beq	.L39
2354:../uvc.c      ****                 prodCount--;
 717              		.loc 1 2354 0
 718 0520 B00CD1E1 		ldrh	r0, [r1, #192]
 719              	.LVL56:
2355:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 720              		.loc 1 2355 0
 721 0524 B430D5E1 		ldrh	r3, [r5, #4]
2354:../uvc.c      ****                 prodCount--;
 722              		.loc 1 2354 0
 723 0528 01E040E2 		sub	lr, r0, #1
 724 052c 0EC8A0E1 		mov	ip, lr, asl #16
 725 0530 2C08A0E1 		mov	r0, ip, lsr #16
 726 0534 B00CC1E1 		strh	r0, [r1, #192]	@ movhi
2355:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 727              		.loc 1 2355 0
 728 0538 B0ECD1E1 		ldrh	lr, [r1, #192]
 729 053c B2CCD1E1 		ldrh	ip, [r1, #194]
 730 0540 0400A0E3 		mov	r0, #4
 731 0544 94109FE5 		ldr	r1, .L48+20
 732 0548 00E08DE5 		str	lr, [sp, #0]
 733 054c 04C08DE5 		str	ip, [sp, #4]
 734 0550 FEFFFFEB 		bl	CyU3PDebugPrint
 735              	.LVL57:
 736 0554 C3FFFFEA 		b	.L39
 737              	.LVL58:
 738              	.L46:
2324:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 739              		.loc 1 2324 0
 740 0558 006095E5 		ldr	r6, [r5, #0]
 741              	.LBB40:
 742              	.LBB41:
2034:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 743              		.loc 1 2034 0
 744 055c 0010E0E3 		mvn	r1, #0
 745              	.LVL59:
 746              	.LBE41:
 747              	.LBE40:
2325:../uvc.c      ****                 fb++;
 748              		.loc 1 2325 0
 749 0560 64409FE5 		ldr	r4, .L48
2324:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 750              		.loc 1 2324 0
 751 0564 0C6046E2 		sub	r6, r6, #12
 752              	.LVL60:
 753              	.LBB43:
 754              	.LBB42:
2034:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 755              		.loc 1 2034 0
 756 0568 68009FE5 		ldr	r0, .L48+12
 757              	.LVL61:
 758 056c FEFFFFEB 		bl	_txe_mutex_get
2035:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 759              		.loc 1 2035 0
 760 0570 6C109FE5 		ldr	r1, .L48+24
 761 0574 0600A0E1 		mov	r0, r6
 762 0578 0C20A0E3 		mov	r2, #12
 763 057c FEFFFFEB 		bl	CyU3PMemCopy
2036:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 764              		.loc 1 2036 0
 765 0580 50009FE5 		ldr	r0, .L48+12
 766 0584 FEFFFFEB 		bl	_txe_mutex_put
 767              	.LBE42:
 768              	.LBE43:
2325:../uvc.c      ****                 fb++;
 769              		.loc 1 2325 0
 770 0588 B4CBD4E1 		ldrh	ip, [r4, #180]
 771 058c B410D5E1 		ldrh	r1, [r5, #4]
 772 0590 01008CE2 		add	r0, ip, #1
 773 0594 B40BC4E1 		strh	r0, [r4, #180]	@ movhi
 774 0598 D2FFFFEA 		b	.L42
 775              	.LVL62:
 776              	.L47:
2338:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 777              		.loc 1 2338 0
 778 059c 0010E0E3 		mvn	r1, #0
 779 05a0 30009FE5 		ldr	r0, .L48+12
 780 05a4 FEFFFFEB 		bl	_txe_mutex_get
2339:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 781              		.loc 1 2339 0
 782 05a8 8114D7E5 		ldrb	r1, [r7, #1153]	@ zero_extendqisi2
2340:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 783              		.loc 1 2340 0
 784 05ac 24009FE5 		ldr	r0, .L48+12
2339:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 785              		.loc 1 2339 0
 786 05b0 DF2001E2 		and	r2, r1, #223
 787 05b4 8124C7E5 		strb	r2, [r7, #1153]
2340:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 788              		.loc 1 2340 0
 789 05b8 FEFFFFEB 		bl	_txe_mutex_put
2341:../uvc.c      ****                 	stiflag = 0xAA;
 790              		.loc 1 2341 0
 791 05bc 5530E0E3 		mvn	r3, #85
 792 05c0 BA30C4E5 		strb	r3, [r4, #186]
 793 05c4 B410D5E1 		ldrh	r1, [r5, #4]
 794 05c8 C4FFFFEA 		b	.L43
 795              	.L49:
 796              		.align	2
 797              	.L48:
 798 05cc 00000000 		.word	.LANCHOR0
 799 05d0 F03F0000 		.word	16368
 800 05d4 00000000 		.word	.LANCHOR1
 801 05d8 00000000 		.word	imgHdMux
 802 05dc 00000000 		.word	glChHandleUVCStream
 803 05e0 B4000000 		.word	.LC6
 804 05e4 80040000 		.word	.LANCHOR1+1152
 805              		.cfi_endproc
 806              	.LFE11:
 808              		.align	2
 810              	CyFxUVCApplnUSBSetupCB:
 811              	.LFB10:
2138:../uvc.c      **** {
 812              		.loc 1 2138 0
 813              		.cfi_startproc
 814              		@ args = 0, pretend = 0, frame = 8
 815              		@ frame_needed = 0, uses_anonymous_args = 0
 816              	.LVL63:
 817 05e8 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 818              	.LCFI7:
 819              		.cfi_def_cfa_offset 32
2144:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 820              		.loc 1 2144 0
 821 05ec 6C839FE5 		ldr	r8, .L79
 822              		.cfi_offset 14, -4
 823              		.cfi_offset 10, -8
 824              		.cfi_offset 9, -12
 825              		.cfi_offset 8, -16
 826              		.cfi_offset 7, -20
 827              		.cfi_offset 6, -24
 828              		.cfi_offset 5, -28
 829              		.cfi_offset 4, -32
 830 05f0 FF3C00E2 		and	r3, r0, #65280
 831 05f4 2364A0E1 		mov	r6, r3, lsr #8
 832 05f8 0060C8E5 		strb	r6, [r8, #0]
2148:../uvc.c      ****     CyU3PDebugPrint (4, "bmReqType = 0x%x bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%
 833              		.loc 1 2148 0
 834 05fc 0630A0E1 		mov	r3, r6
2143:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 835              		.loc 1 2143 0
 836 0600 5C439FE5 		ldr	r4, .L79+4
2147:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 837              		.loc 1 2147 0
 838 0604 5C639FE5 		ldr	r6, .L79+8
2145:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 839              		.loc 1 2145 0
 840 0608 5C939FE5 		ldr	r9, .L79+12
2146:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 841              		.loc 1 2146 0
 842 060c 5CA39FE5 		ldr	sl, .L79+16
2138:../uvc.c      **** {
 843              		.loc 1 2138 0
 844 0610 18D04DE2 		sub	sp, sp, #24
 845              	.LCFI8:
 846              		.cfi_def_cfa_offset 56
2147:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 847              		.loc 1 2147 0
 848 0614 21C8A0E1 		mov	ip, r1, lsr #16
2143:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 849              		.loc 1 2143 0
 850 0618 FF7000E2 		and	r7, r0, #255
2146:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 851              		.loc 1 2146 0
 852 061c 0128A0E1 		mov	r2, r1, asl #16
2147:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 853              		.loc 1 2147 0
 854 0620 B0C0C6E1 		strh	ip, [r6, #0]	@ movhi
2143:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 855              		.loc 1 2143 0
 856 0624 0070C4E5 		strb	r7, [r4, #0]
2146:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 857              		.loc 1 2146 0
 858 0628 22E8A0E1 		mov	lr, r2, lsr #16
2145:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 859              		.loc 1 2145 0
 860 062c 2058A0E1 		mov	r5, r0, lsr #16
2148:../uvc.c      ****     CyU3PDebugPrint (4, "bmReqType = 0x%x bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%
 861              		.loc 1 2148 0
 862 0630 0720A0E1 		mov	r2, r7
 863 0634 08C08DE5 		str	ip, [sp, #8]
 864 0638 0400A0E3 		mov	r0, #4
 865              	.LVL64:
 866 063c 00C0A0E3 		mov	ip, #0
 867 0640 2C139FE5 		ldr	r1, .L79+20
 868              	.LVL65:
2145:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 869              		.loc 1 2145 0
 870 0644 B050C9E1 		strh	r5, [r9, #0]	@ movhi
2146:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 871              		.loc 1 2146 0
 872 0648 B0E0CAE1 		strh	lr, [sl, #0]	@ movhi
2148:../uvc.c      ****     CyU3PDebugPrint (4, "bmReqType = 0x%x bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%
 873              		.loc 1 2148 0
 874 064c 20408DE8 		stmia	sp, {r5, lr}	@ phole stm
 875 0650 0CC08DE5 		str	ip, [sp, #12]
 876 0654 FEFFFFEB 		bl	CyU3PDebugPrint
2150:../uvc.c      ****     if(dbgIdx < 63){
 877              		.loc 1 2150 0
 878 0658 18239FE5 		ldr	r2, .L79+24
 879 065c 8C34D2E5 		ldrb	r3, [r2, #1164]	@ zero_extendqisi2
 880 0660 3E0053E3 		cmp	r3, #62
 881 0664 0D00008A 		bhi	.L51
2151:../uvc.c      ****     	if(!((bmReqType == 0xa1) || (bmReqType == 0x80))){
 882              		.loc 1 2151 0
 883 0668 0040D4E5 		ldrb	r4, [r4, #0]	@ zero_extendqisi2
 884 066c 800054E3 		cmp	r4, #128
 885 0670 A1005413 		cmpne	r4, #161
 886 0674 5800001A 		bne	.L73
 887              	.L52:
2159:../uvc.c      ****     switch (bmReqType)
 888              		.loc 1 2159 0
 889 0678 020054E3 		cmp	r4, #2
 890 067c 0D00000A 		beq	.L55
 891              	.L75:
 892 0680 1900009A 		bls	.L74
 893 0684 210054E3 		cmp	r4, #33
 894 0688 5C00000A 		beq	.L56
 895 068c A10054E3 		cmp	r4, #161
 896 0690 5A00000A 		beq	.L56
 897              	.L70:
2139:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 898              		.loc 1 2139 0
 899 0694 0000A0E3 		mov	r0, #0
 900              	.LVL66:
 901              	.L53:
2288:../uvc.c      **** }
 902              		.loc 1 2288 0
 903 0698 18D08DE2 		add	sp, sp, #24
 904 069c F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 905              	.LVL67:
 906              	.L51:
2156:../uvc.c      ****     }else debugData[63][1] = 0xFF; //full symbol
 907              		.loc 1 2156 0
 908 06a0 0040D4E5 		ldrb	r4, [r4, #0]	@ zero_extendqisi2
 909 06a4 D0029FE5 		ldr	r0, .L79+28
 910 06a8 0020E0E3 		mvn	r2, #0
2159:../uvc.c      ****     switch (bmReqType)
 911              		.loc 1 2159 0
 912 06ac 020054E3 		cmp	r4, #2
2156:../uvc.c      ****     }else debugData[63][1] = 0xFF; //full symbol
 913              		.loc 1 2156 0
 914 06b0 A720C0E5 		strb	r2, [r0, #167]
2159:../uvc.c      ****     switch (bmReqType)
 915              		.loc 1 2159 0
 916 06b4 F1FFFF1A 		bne	.L75
 917              	.L55:
2235:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 918              		.loc 1 2235 0
 919 06b8 0070D8E5 		ldrb	r7, [r8, #0]	@ zero_extendqisi2
 920 06bc 010057E3 		cmp	r7, #1
 921 06c0 F3FFFF1A 		bne	.L70
2237:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 922              		.loc 1 2237 0
 923 06c4 B080DAE1 		ldrh	r8, [sl, #0]
 924 06c8 830058E3 		cmp	r8, #131
 925 06cc F0FFFF1A 		bne	.L70
2243:../uvc.c      ****                     if (streamingStarted == CyTrue)
 926              		.loc 1 2243 0
 927 06d0 A4529FE5 		ldr	r5, .L79+28
 928 06d4 AC6095E5 		ldr	r6, [r5, #172]
 929 06d8 010056E3 		cmp	r6, #1
 930 06dc 6D00000A 		beq	.L76
 931              	.LVL68:
2276:../uvc.c      ****                         CyU3PUsbAckSetup ();
 932              		.loc 1 2276 0
 933 06e0 FEFFFFEB 		bl	CyU3PUsbAckSetup
2275:../uvc.c      ****                         uvcHandleReq = CyTrue;
 934              		.loc 1 2275 0
 935 06e4 0700A0E1 		mov	r0, r7
 936 06e8 EAFFFFEA 		b	.L53
 937              	.LVL69:
 938              	.L74:
2159:../uvc.c      ****     switch (bmReqType)
 939              		.loc 1 2159 0
 940 06ec 010054E3 		cmp	r4, #1
 941 06f0 E7FFFF1A 		bne	.L70
2199:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 942              		.loc 1 2199 0
 943 06f4 0010D8E5 		ldrb	r1, [r8, #0]	@ zero_extendqisi2
 944 06f8 0B0051E3 		cmp	r1, #11
 945 06fc E4FFFF1A 		bne	.L70
2203:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 946              		.loc 1 2203 0
 947 0700 B030DAE1 		ldrh	r3, [sl, #0]
 948 0704 010053E3 		cmp	r3, #1
 949 0708 E1FFFF1A 		bne	.L70
2203:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 950              		.loc 1 2203 0 is_stmt 0 discriminator 1
 951 070c B050D9E1 		ldrh	r5, [r9, #0]
 952 0710 000055E3 		cmp	r5, #0
 953 0714 DEFFFF1A 		bne	.L70
2208:../uvc.c      ****                     gpif_initialized = 0;
 954              		.loc 1 2208 0 is_stmt 1
 955 0718 5C629FE5 		ldr	r6, .L79+28
2206:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 956              		.loc 1 2206 0
 957 071c 5C129FE5 		ldr	r1, .L79+32
 958 0720 0400A0E3 		mov	r0, #4
 959 0724 FEFFFFEB 		bl	CyU3PDebugPrint
2207:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 960              		.loc 1 2207 0
 961 0728 0400A0E1 		mov	r0, r4
 962 072c FEFFFFEB 		bl	CyU3PGpifDisable
2211:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 963              		.loc 1 2211 0
 964 0730 0410A0E1 		mov	r1, r4
2208:../uvc.c      ****                     gpif_initialized = 0;
 965              		.loc 1 2208 0
 966 0734 A85086E5 		str	r5, [r6, #168]
2209:../uvc.c      ****                     streamingStarted = CyFalse;
 967              		.loc 1 2209 0
 968 0738 AC5086E5 		str	r5, [r6, #172]
2211:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 969              		.loc 1 2211 0
 970 073c 8300A0E3 		mov	r0, #131
 971 0740 FEFFFFEB 		bl	CyU3PUsbSetEpNak
2212:../uvc.c      ****                     CyU3PBusyWait (100);
 972              		.loc 1 2212 0
 973 0744 6400A0E3 		mov	r0, #100
 974 0748 FEFFFFEB 		bl	CyU3PBusyWait
2215:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 975              		.loc 1 2215 0
 976 074c 30029FE5 		ldr	r0, .L79+36
 977 0750 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
2216:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 978              		.loc 1 2216 0
 979 0754 8300A0E3 		mov	r0, #131
 980 0758 FEFFFFEB 		bl	CyU3PUsbFlushEp
2217:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 981              		.loc 1 2217 0
 982 075c 0510A0E1 		mov	r1, r5
 983 0760 8300A0E3 		mov	r0, #131
 984 0764 FEFFFFEB 		bl	CyU3PUsbSetEpNak
2218:../uvc.c      ****                     CyU3PBusyWait (100);
 985              		.loc 1 2218 0
 986 0768 6400A0E3 		mov	r0, #100
 987 076c FEFFFFEB 		bl	CyU3PBusyWait
2221:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 988              		.loc 1 2221 0
 989 0770 0510A0E1 		mov	r1, r5
 990 0774 0420A0E1 		mov	r2, r4
 991 0778 8300A0E3 		mov	r0, #131
 992 077c FEFFFFEB 		bl	CyU3PUsbStall
 993              	.LVL70:
2224:../uvc.c      ****                     CyU3PUsbAckSetup ();
 994              		.loc 1 2224 0
 995 0780 FEFFFFEB 		bl	CyU3PUsbAckSetup
2226:../uvc.c      ****                     debugData[1][0] = debugData[1][0]|0x08; //set bit3
 996              		.loc 1 2226 0
 997 0784 2A20D6E5 		ldrb	r2, [r6, #42]	@ zero_extendqisi2
2227:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 998              		.loc 1 2227 0
 999 0788 C44086E5 		str	r4, [r6, #196]
2226:../uvc.c      ****                     debugData[1][0] = debugData[1][0]|0x08; //set bit3
 1000              		.loc 1 2226 0
 1001 078c 08C082E3 		orr	ip, r2, #8
 1002 0790 2AC0C6E5 		strb	ip, [r6, #42]
 1003              	.LBB48:
 1004              	.LBB49:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1005              		.loc 1 2074 0
 1006 0794 0600A0E1 		mov	r0, r6
 1007 0798 0410A0E1 		mov	r1, r4
 1008 079c 0220A0E3 		mov	r2, #2
 1009 07a0 14308DE2 		add	r3, sp, #20
 1010 07a4 00508DE5 		str	r5, [sp, #0]
 1011 07a8 FEFFFFEB 		bl	_txe_event_flags_get
 1012 07ac 005050E2 		subs	r5, r0, #0
 1013 07b0 2D00001A 		bne	.L68
2077:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1014              		.loc 1 2077 0
 1015 07b4 0110E0E3 		mvn	r1, #1
 1016 07b8 0220A0E3 		mov	r2, #2
 1017 07bc 0600A0E1 		mov	r0, r6
 1018 07c0 FEFFFFEB 		bl	_txe_event_flags_set
2080:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1019              		.loc 1 2080 0
 1020 07c4 0600A0E1 		mov	r0, r6
 1021 07c8 0210A0E3 		mov	r1, #2
 1022 07cc 0520A0E1 		mov	r2, r5
 1023 07d0 FEFFFFEB 		bl	_txe_event_flags_set
2222:../uvc.c      ****                     uvcHandleReq = CyTrue;
 1024              		.loc 1 2222 0
 1025 07d4 0400A0E1 		mov	r0, r4
 1026 07d8 AEFFFFEA 		b	.L53
 1027              	.LVL71:
 1028              	.L73:
 1029              	.LBE49:
 1030              	.LBE48:
2152:../uvc.c      **** 		debugData[dbgIdx][0] = bmReqType;
 1031              		.loc 1 2152 0
 1032 07dc 98119FE5 		ldr	r1, .L79+28
2153:../uvc.c      **** 		debugData[dbgIdx][1] = bRequest;
 1033              		.loc 1 2153 0
 1034 07e0 00C0D8E5 		ldrb	ip, [r8, #0]	@ zero_extendqisi2
2154:../uvc.c      **** 		dbgIdx++;
 1035              		.loc 1 2154 0
 1036 07e4 010083E2 		add	r0, r3, #1
2152:../uvc.c      **** 		debugData[dbgIdx][0] = bmReqType;
 1037              		.loc 1 2152 0
 1038 07e8 833081E0 		add	r3, r1, r3, asl #1
 1039 07ec 2840C3E5 		strb	r4, [r3, #40]
2153:../uvc.c      **** 		debugData[dbgIdx][1] = bRequest;
 1040              		.loc 1 2153 0
 1041 07f0 29C0C3E5 		strb	ip, [r3, #41]
2154:../uvc.c      **** 		dbgIdx++;
 1042              		.loc 1 2154 0
 1043 07f4 8C04C2E5 		strb	r0, [r2, #1164]
2155:../uvc.c      **** 		debugData[63][1] = dbgIdx;}
 1044              		.loc 1 2155 0
 1045 07f8 A700C1E5 		strb	r0, [r1, #167]
 1046 07fc 9DFFFFEA 		b	.L52
 1047              	.L56:
2164:../uvc.c      ****             switch (wIndex & 0xFF)
 1048              		.loc 1 2164 0
 1049 0800 0040DAE5 		ldrb	r4, [sl, #0]	@ zero_extendqisi2
 1050 0804 000054E3 		cmp	r4, #0
 1051 0808 0F00001A 		bne	.L77
 1052              	.LVL72:
2169:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 1053              		.loc 1 2169 0
 1054 080c 0420A0E1 		mov	r2, r4
 1055 0810 64019FE5 		ldr	r0, .L79+28
 1056 0814 0410A0E3 		mov	r1, #4
 1057 0818 FEFFFFEB 		bl	_txe_event_flags_set
 1058              	.LVL73:
2171:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 1059              		.loc 1 2171 0
 1060 081c 002050E2 		subs	r2, r0, #0
2168:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1061              		.loc 1 2168 0
 1062 0820 0100A003 		moveq	r0, #1
 1063              	.LVL74:
2171:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 1064              		.loc 1 2171 0
 1065 0824 9BFFFF0A 		beq	.L53
2173:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 1066              		.loc 1 2173 0
 1067 0828 58119FE5 		ldr	r1, .L79+40
 1068 082c 0400A0E3 		mov	r0, #4
 1069 0830 FEFFFFEB 		bl	CyU3PDebugPrint
 1070              	.LVL75:
2174:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1071              		.loc 1 2174 0
 1072 0834 0400A0E1 		mov	r0, r4
 1073 0838 0110A0E3 		mov	r1, #1
 1074 083c 0420A0E1 		mov	r2, r4
 1075 0840 FEFFFFEB 		bl	CyU3PUsbStall
2168:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1076              		.loc 1 2168 0
 1077 0844 0100A0E3 		mov	r0, #1
 1078 0848 92FFFFEA 		b	.L53
 1079              	.LVL76:
 1080              	.L77:
2164:../uvc.c      ****             switch (wIndex & 0xFF)
 1081              		.loc 1 2164 0
 1082 084c 010054E3 		cmp	r4, #1
 1083 0850 8FFFFF1A 		bne	.L70
 1084              	.LVL77:
2182:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 1085              		.loc 1 2182 0
 1086 0854 0020A0E3 		mov	r2, #0
 1087 0858 1C019FE5 		ldr	r0, .L79+28
 1088 085c 0810A0E3 		mov	r1, #8
 1089 0860 FEFFFFEB 		bl	_txe_event_flags_set
 1090              	.LVL78:
2184:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 1091              		.loc 1 2184 0
 1092 0864 002050E2 		subs	r2, r0, #0
 1093 0868 0100001A 		bne	.L78
 1094              	.LVL79:
 1095              	.L68:
 1096              	.LBB51:
 1097              	.LBB50:
2222:../uvc.c      ****                     uvcHandleReq = CyTrue;
 1098              		.loc 1 2222 0
 1099 086c 0400A0E1 		mov	r0, r4
 1100 0870 88FFFFEA 		b	.L53
 1101              	.LVL80:
 1102              	.L78:
 1103              	.LBE50:
 1104              	.LBE51:
2187:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 1105              		.loc 1 2187 0
 1106 0874 10119FE5 		ldr	r1, .L79+44
 1107 0878 0400A0E3 		mov	r0, #4
 1108              	.LVL81:
 1109 087c FEFFFFEB 		bl	CyU3PDebugPrint
 1110              	.LVL82:
2188:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1111              		.loc 1 2188 0
 1112 0880 0000A0E3 		mov	r0, #0
 1113 0884 0410A0E1 		mov	r1, r4
 1114 0888 0020A0E1 		mov	r2, r0
 1115 088c FEFFFFEB 		bl	CyU3PUsbStall
2181:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1116              		.loc 1 2181 0
 1117 0890 0400A0E1 		mov	r0, r4
 1118 0894 7FFFFFEA 		b	.L53
 1119              	.LVL83:
 1120              	.L76:
2245:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 1121              		.loc 1 2245 0
 1122 0898 F0109FE5 		ldr	r1, .L79+48
 1123 089c 0400A0E3 		mov	r0, #4
 1124 08a0 FEFFFFEB 		bl	CyU3PDebugPrint
2249:../uvc.c      ****                         gpif_initialized = 0;
 1125              		.loc 1 2249 0
 1126 08a4 0070A0E3 		mov	r7, #0
2248:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 1127              		.loc 1 2248 0
 1128 08a8 0600A0E1 		mov	r0, r6
 1129 08ac FEFFFFEB 		bl	CyU3PGpifDisable
2253:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1130              		.loc 1 2253 0
 1131 08b0 0610A0E1 		mov	r1, r6
2249:../uvc.c      ****                         gpif_initialized = 0;
 1132              		.loc 1 2249 0
 1133 08b4 A87085E5 		str	r7, [r5, #168]
2250:../uvc.c      ****                         streamingStarted = CyFalse;
 1134              		.loc 1 2250 0
 1135 08b8 AC7085E5 		str	r7, [r5, #172]
2253:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1136              		.loc 1 2253 0
 1137 08bc 0800A0E1 		mov	r0, r8
 1138 08c0 FEFFFFEB 		bl	CyU3PUsbSetEpNak
2254:../uvc.c      ****                         CyU3PBusyWait (100);
 1139              		.loc 1 2254 0
 1140 08c4 6400A0E3 		mov	r0, #100
 1141 08c8 FEFFFFEB 		bl	CyU3PBusyWait
2257:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 1142              		.loc 1 2257 0
 1143 08cc B0009FE5 		ldr	r0, .L79+36
 1144 08d0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
2258:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1145              		.loc 1 2258 0
 1146 08d4 0800A0E1 		mov	r0, r8
 1147 08d8 FEFFFFEB 		bl	CyU3PUsbFlushEp
2259:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1148              		.loc 1 2259 0
 1149 08dc 0710A0E1 		mov	r1, r7
 1150 08e0 0800A0E1 		mov	r0, r8
 1151 08e4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
2260:../uvc.c      ****                         CyU3PBusyWait (100);
 1152              		.loc 1 2260 0
 1153 08e8 6400A0E3 		mov	r0, #100
 1154 08ec FEFFFFEB 		bl	CyU3PBusyWait
2263:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 1155              		.loc 1 2263 0
 1156 08f0 0710A0E1 		mov	r1, r7
 1157 08f4 0620A0E1 		mov	r2, r6
 1158 08f8 0800A0E1 		mov	r0, r8
 1159 08fc FEFFFFEB 		bl	CyU3PUsbStall
 1160              	.LVL84:
2267:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1161              		.loc 1 2267 0
 1162 0900 FEFFFFEB 		bl	CyU3PUsbAckSetup
2270:../uvc.c      ****                         debugData[1][0] = debugData[1][0]|0x10; //set bit0
 1163              		.loc 1 2270 0
 1164 0904 2A10D5E5 		ldrb	r1, [r5, #42]	@ zero_extendqisi2
2269:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 1165              		.loc 1 2269 0
 1166 0908 C46085E5 		str	r6, [r5, #196]
2270:../uvc.c      ****                         debugData[1][0] = debugData[1][0]|0x10; //set bit0
 1167              		.loc 1 2270 0
 1168 090c 10C081E3 		orr	ip, r1, #16
 1169 0910 2AC0C5E5 		strb	ip, [r5, #42]
 1170              	.LBB52:
 1171              	.LBB53:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1172              		.loc 1 2074 0
 1173 0914 0500A0E1 		mov	r0, r5
 1174 0918 0610A0E1 		mov	r1, r6
 1175 091c 0420A0E1 		mov	r2, r4
 1176 0920 14308DE2 		add	r3, sp, #20
 1177 0924 00708DE5 		str	r7, [sp, #0]
 1178 0928 FEFFFFEB 		bl	_txe_event_flags_get
 1179 092c 007050E2 		subs	r7, r0, #0
2265:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1180              		.loc 1 2265 0
 1181 0930 0600A011 		movne	r0, r6
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1182              		.loc 1 2074 0
 1183 0934 57FFFF1A 		bne	.L53
2077:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1184              		.loc 1 2077 0
 1185 0938 0110E0E3 		mvn	r1, #1
 1186 093c 0420A0E1 		mov	r2, r4
 1187 0940 0500A0E1 		mov	r0, r5
 1188 0944 FEFFFFEB 		bl	_txe_event_flags_set
2080:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1189              		.loc 1 2080 0
 1190 0948 0500A0E1 		mov	r0, r5
 1191 094c 0410A0E1 		mov	r1, r4
 1192 0950 0720A0E1 		mov	r2, r7
 1193 0954 FEFFFFEB 		bl	_txe_event_flags_set
2265:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1194              		.loc 1 2265 0
 1195 0958 0600A0E1 		mov	r0, r6
 1196 095c 4DFFFFEA 		b	.L53
 1197              	.L80:
 1198              		.align	2
 1199              	.L79:
 1200 0960 00000000 		.word	bRequest
 1201 0964 00000000 		.word	bmReqType
 1202 0968 00000000 		.word	wLength
 1203 096c 00000000 		.word	wValue
 1204 0970 00000000 		.word	wIndex
 1205 0974 00010000 		.word	.LC7
 1206 0978 00000000 		.word	.LANCHOR1
 1207 097c 00000000 		.word	.LANCHOR0
 1208 0980 C8010000 		.word	.LC10
 1209 0984 00000000 		.word	glChHandleUVCStream
 1210 0988 5C010000 		.word	.LC8
 1211 098c 94010000 		.word	.LC9
 1212 0990 E0010000 		.word	.LC11
 1213              	.LBE53:
 1214              	.LBE52:
 1215              		.cfi_endproc
 1216              	.LFE10:
 1218              		.align	2
 1219              		.global	CyFxGpifCB
 1221              	CyFxGpifCB:
 1222              	.LFB13:
2487:../uvc.c      **** {
 1223              		.loc 1 2487 0
 1224              		.cfi_startproc
 1225              		@ args = 0, pretend = 0, frame = 0
 1226              		@ frame_needed = 0, uses_anonymous_args = 0
 1227              	.LVL85:
2488:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1228              		.loc 1 2488 0
 1229 0994 010050E3 		cmp	r0, #1
2487:../uvc.c      **** {
 1230              		.loc 1 2487 0
 1231 0998 10402DE9 		stmfd	sp!, {r4, lr}
 1232              	.LCFI9:
 1233              		.cfi_def_cfa_offset 8
2487:../uvc.c      **** {
 1234              		.loc 1 2487 0
 1235 099c 0120A0E1 		mov	r2, r1
2488:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1236              		.loc 1 2488 0
 1237 09a0 1080BD18 		ldmnefd	sp!, {r4, pc}
 1238              		.cfi_offset 14, -4
 1239              		.cfi_offset 4, -8
 1240              	.LVL86:
 1241              	.LBB58:
 1242              	.LBB59:
2385:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1243              		.loc 1 2385 0
 1244 09a4 CC309FE5 		ldr	r3, .L96
 1245 09a8 C830D3E5 		ldrb	r3, [r3, #200]	@ zero_extendqisi2
 1246 09ac 030053E3 		cmp	r3, #3
 1247 09b0 2100000A 		beq	.L95
2411:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1248              		.loc 1 2411 0
 1249 09b4 020053E3 		cmp	r3, #2
 1250 09b8 1080BD18 		ldmnefd	sp!, {r4, pc}
2413:../uvc.c      ****         switch (stateId)
 1251              		.loc 1 2413 0
 1252 09bc 080041E2 		sub	r0, r1, #8
 1253              	.LVL87:
 1254 09c0 0A0050E3 		cmp	r0, #10
 1255 09c4 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1256 09c8 230000EA 		b	.L88
 1257              	.L90:
 1258 09cc FC090000 		.word	.L85
 1259 09d0 5C0A0000 		.word	.L88
 1260 09d4 5C0A0000 		.word	.L88
 1261 09d8 F8090000 		.word	.L81
 1262 09dc 5C0A0000 		.word	.L88
 1263 09e0 5C0A0000 		.word	.L88
 1264 09e4 5C0A0000 		.word	.L88
 1265 09e8 340A0000 		.word	.L94
 1266 09ec 5C0A0000 		.word	.L88
 1267 09f0 5C0A0000 		.word	.L88
 1268 09f4 F8090000 		.word	.L81
 1269              	.LVL88:
 1270              	.L81:
 1271 09f8 1080BDE8 		ldmfd	sp!, {r4, pc}
 1272              	.LVL89:
 1273              	.L85:
2396:../uvc.c      ****                 socket = 0;
 1274              		.loc 1 2396 0
 1275 09fc 0010A0E3 		mov	r1, #0
 1276              	.LVL90:
 1277              	.L86:
2470:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1278              		.loc 1 2470 0
 1279 0a00 74009FE5 		ldr	r0, .L96+4
 1280 0a04 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1281              	.LVL91:
2471:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1282              		.loc 1 2471 0
 1283 0a08 002050E2 		subs	r2, r0, #0
 1284 0a0c F9FFFF0A 		beq	.L81
2473:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1285              		.loc 1 2473 0
 1286 0a10 0400A0E3 		mov	r0, #4
 1287              	.LVL92:
 1288 0a14 64109FE5 		ldr	r1, .L96+8
 1289 0a18 FEFFFFEB 		bl	CyU3PDebugPrint
 1290              	.LVL93:
 1291              	.L91:
 1292              	.LBB60:
 1293              	.LBB61:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1294              		.loc 1 2061 0
 1295 0a1c 60109FE5 		ldr	r1, .L96+12
 1296 0a20 0400A0E3 		mov	r0, #4
 1297 0a24 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 1298              		.loc 1 2062 0
 1299 0a28 FA0FA0E3 		mov	r0, #1000
 1300 0a2c FEFFFFEB 		bl	_tx_thread_sleep
 1301 0a30 F9FFFFEA 		b	.L91
 1302              	.LVL94:
 1303              	.L94:
 1304              	.LBE61:
 1305              	.LBE60:
2440:../uvc.c      ****                 socket = 1;
 1306              		.loc 1 2440 0
 1307 0a34 0110A0E3 		mov	r1, #1
 1308              	.LVL95:
 1309 0a38 F0FFFFEA 		b	.L86
 1310              	.LVL96:
 1311              	.L95:
2387:../uvc.c      ****         switch (stateId)
 1312              		.loc 1 2387 0
 1313 0a3c 0B2041E2 		sub	r2, r1, #11
 1314 0a40 030052E3 		cmp	r2, #3
 1315 0a44 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 1316 0a48 060000EA 		b	.L84
 1317              	.L87:
 1318 0a4c FC090000 		.word	.L85
 1319 0a50 340A0000 		.word	.L94
 1320 0a54 F8090000 		.word	.L81
 1321 0a58 F8090000 		.word	.L81
 1322              	.LVL97:
 1323              	.L88:
2459:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1324              		.loc 1 2459 0
 1325 0a5c 24109FE5 		ldr	r1, .L96+16
 1326              	.LVL98:
 1327 0a60 0100A0E3 		mov	r0, #1
 1328 0a64 FEFFFFEB 		bl	CyU3PDebugPrint
 1329              	.LVL99:
 1330              	.L84:
 1331              	.LBE59:
 1332              	.LBE58:
2494:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1333              		.loc 1 2494 0
 1334 0a68 1C109FE5 		ldr	r1, .L96+20
 1335 0a6c 0400A0E3 		mov	r0, #4
2497:../uvc.c      **** }
 1336              		.loc 1 2497 0
 1337 0a70 1040BDE8 		ldmfd	sp!, {r4, lr}
2494:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1338              		.loc 1 2494 0
 1339 0a74 FEFFFFEA 		b	CyU3PDebugPrint
 1340              	.L97:
 1341              		.align	2
 1342              	.L96:
 1343 0a78 00000000 		.word	.LANCHOR0
 1344 0a7c 00000000 		.word	glChHandleUVCStream
 1345 0a80 1C020000 		.word	.LC13
 1346 0a84 4C020000 		.word	.LC14
 1347 0a88 04020000 		.word	.LC12
 1348 0a8c 60020000 		.word	.LC15
 1349              		.cfi_endproc
 1350              	.LFE13:
 1352              		.align	2
 1353              		.global	I2CCmdHandler
 1355              	I2CCmdHandler:
 1356              	.LFB0:
 615:../uvc.c      **** void I2CCmdHandler(){
 1357              		.loc 1 615 0
 1358              		.cfi_startproc
 1359              		@ args = 0, pretend = 0, frame = 16
 1360              		@ frame_needed = 0, uses_anonymous_args = 0
 1361 0a90 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1362              	.LCFI10:
 1363              		.cfi_def_cfa_offset 36
 618:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1364              		.loc 1 618 0
 1365 0a94 44439FE5 		ldr	r4, .L123
 1366              		.cfi_offset 14, -4
 1367              		.cfi_offset 11, -8
 1368              		.cfi_offset 10, -12
 1369              		.cfi_offset 9, -16
 1370              		.cfi_offset 8, -20
 1371              		.cfi_offset 7, -24
 1372              		.cfi_offset 6, -28
 1373              		.cfi_offset 5, -32
 1374              		.cfi_offset 4, -36
 615:../uvc.c      **** void I2CCmdHandler(){
 1375              		.loc 1 615 0
 1376 0a98 3CD04DE2 		sub	sp, sp, #60
 1377              	.LCFI11:
 1378              		.cfi_def_cfa_offset 96
 623:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1379              		.loc 1 623 0
 1380 0a9c D310D4E5 		ldrb	r1, [r4, #211]	@ zero_extendqisi2
 618:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1381              		.loc 1 618 0
 1382 0aa0 CC50D4E5 		ldrb	r5, [r4, #204]	@ zero_extendqisi2
 1383              	.LVL100:
 619:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1384              		.loc 1 619 0
 1385 0aa4 CD70D4E5 		ldrb	r7, [r4, #205]	@ zero_extendqisi2
 1386              	.LVL101:
 620:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1387              		.loc 1 620 0
 1388 0aa8 D460D4E5 		ldrb	r6, [r4, #212]	@ zero_extendqisi2
 1389              	.LVL102:
 623:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1390              		.loc 1 623 0
 1391 0aac CEE0D4E5 		ldrb	lr, [r4, #206]	@ zero_extendqisi2
 1392 0ab0 CF80D4E5 		ldrb	r8, [r4, #207]	@ zero_extendqisi2
 1393 0ab4 D0A0D4E5 		ldrb	sl, [r4, #208]	@ zero_extendqisi2
 1394 0ab8 D190D4E5 		ldrb	r9, [r4, #209]	@ zero_extendqisi2
 1395 0abc D2B0D4E5 		ldrb	fp, [r4, #210]	@ zero_extendqisi2
 1396 0ac0 14108DE5 		str	r1, [sp, #20]
 1397 0ac4 D530D4E5 		ldrb	r3, [r4, #213]	@ zero_extendqisi2
 1398 0ac8 0400A0E3 		mov	r0, #4
 1399 0acc 1C308DE5 		str	r3, [sp, #28]
 1400 0ad0 D6C0D4E5 		ldrb	ip, [r4, #214]	@ zero_extendqisi2
 1401 0ad4 0730A0E1 		mov	r3, r7
 1402 0ad8 04139FE5 		ldr	r1, .L123+4
 1403 0adc 0520A0E1 		mov	r2, r5
 1404 0ae0 00E08DE5 		str	lr, [sp, #0]
 1405 0ae4 00058DE9 		stmib	sp, {r8, sl}	@ phole stm
 1406 0ae8 0C908DE5 		str	r9, [sp, #12]
 1407 0aec 10B08DE5 		str	fp, [sp, #16]
 1408 0af0 18608DE5 		str	r6, [sp, #24]
 1409 0af4 20C08DE5 		str	ip, [sp, #32]
 1410 0af8 FEFFFFEB 		bl	CyU3PDebugPrint
 626:../uvc.c      **** 	if((I2CCMDArry[2]==0x70) && (I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01
 1411              		.loc 1 626 0
 1412 0afc CE30D4E5 		ldrb	r3, [r4, #206]	@ zero_extendqisi2
 1413 0b00 700053E3 		cmp	r3, #112
 1414 0b04 1100000A 		beq	.L116
 637:../uvc.c      **** 		if(CmdType == 0){ //read
 1415              		.loc 1 637 0
 1416 0b08 000055E3 		cmp	r5, #0
 1417 0b0c 0300000A 		beq	.L117
 672:../uvc.c      **** 		}else if(CmdType == 1){ //clear debug data
 1418              		.loc 1 672 0
 1419 0b10 010055E3 		cmp	r5, #1
 1420 0b14 2E00000A 		beq	.L118
 1421              	.LVL103:
 1422              	.L98:
 728:../uvc.c      **** }
 1423              		.loc 1 728 0
 1424 0b18 3CD08DE2 		add	sp, sp, #60
 1425 0b1c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1426              	.LVL104:
 1427              	.L117:
 639:../uvc.c      **** 		if(I2CCMDArry[3] == 0){
 1428              		.loc 1 639 0
 1429 0b20 CF20D4E5 		ldrb	r2, [r4, #207]	@ zero_extendqisi2
 638:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1430              		.loc 1 638 0
 1431 0b24 0F00A0E3 		mov	r0, #15
 639:../uvc.c      **** 		if(I2CCMDArry[3] == 0){
 1432              		.loc 1 639 0
 1433 0b28 000052E3 		cmp	r2, #0
 638:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1434              		.loc 1 638 0
 1435 0b2c D700C4E5 		strb	r0, [r4, #215]
 639:../uvc.c      **** 		if(I2CCMDArry[3] == 0){
 1436              		.loc 1 639 0
 1437 0b30 1F00001A 		bne	.L103
 640:../uvc.c      **** 			if(I2CCMDArry[2] == 0){
 1438              		.loc 1 640 0
 1439 0b34 000053E3 		cmp	r3, #0
 1440 0b38 3200001A 		bne	.L104
 641:../uvc.c      **** 				I2CCMDArry[10] = debugData[0][0]; //number of frame
 1441              		.loc 1 641 0
 1442 0b3c 2820D4E5 		ldrb	r2, [r4, #40]	@ zero_extendqisi2
 642:../uvc.c      **** 				I2CCMDArry[9] = debugData[0][1];  // stream status
 1443              		.loc 1 642 0
 1444 0b40 29C0D4E5 		ldrb	ip, [r4, #41]	@ zero_extendqisi2
 641:../uvc.c      **** 				I2CCMDArry[10] = debugData[0][0]; //number of frame
 1445              		.loc 1 641 0
 1446 0b44 D620C4E5 		strb	r2, [r4, #214]
 642:../uvc.c      **** 				I2CCMDArry[9] = debugData[0][1];  // stream status
 1447              		.loc 1 642 0
 1448 0b48 D5C0C4E5 		strb	ip, [r4, #213]
 1449 0b4c 150000EA 		b	.L110
 1450              	.L116:
 626:../uvc.c      **** 	if((I2CCMDArry[2]==0x70) && (I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01
 1451              		.loc 1 626 0 discriminator 1
 1452 0b50 CF00D4E5 		ldrb	r0, [r4, #207]	@ zero_extendqisi2
 1453 0b54 520050E3 		cmp	r0, #82
 1454 0b58 3400000A 		beq	.L119
 1455              	.L100:
 683:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1456              		.loc 1 683 0
 1457 0b5c 000055E3 		cmp	r5, #0
 1458 0b60 5400001A 		bne	.L109
 699:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1459              		.loc 1 699 0
 1460 0b64 CE00D4E5 		ldrb	r0, [r4, #206]	@ zero_extendqisi2
 1461 0b68 CF10D4E5 		ldrb	r1, [r4, #207]	@ zero_extendqisi2
 685:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1462              		.loc 1 685 0
 1463 0b6c 0FC0A0E3 		mov	ip, #15
 1464 0b70 D7C0C4E5 		strb	ip, [r4, #215]
 699:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1465              		.loc 1 699 0
 1466 0b74 D020D4E5 		ldrb	r2, [r4, #208]	@ zero_extendqisi2
 1467 0b78 D130D4E5 		ldrb	r3, [r4, #209]	@ zero_extendqisi2
 1468 0b7c 34E08DE2 		add	lr, sp, #52
 1469 0b80 010080E3 		orr	r0, r0, #1
 1470 0b84 011081E3 		orr	r1, r1, #1
 1471 0b88 00E08DE5 		str	lr, [sp, #0]
 1472 0b8c FEFFFFEB 		bl	SensorRead2B
 700:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1473              		.loc 1 700 0
 1474 0b90 34C0DDE5 		ldrb	ip, [sp, #52]	@ zero_extendqisi2
 701:../uvc.c      **** 				if(CmdDataLen == 2){
 1475              		.loc 1 701 0
 1476 0b94 020056E3 		cmp	r6, #2
 700:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1477              		.loc 1 700 0
 1478 0b98 D5C0C4E5 		strb	ip, [r4, #213]
 702:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1479              		.loc 1 702 0
 1480 0b9c 3500DD05 		ldreqb	r0, [sp, #53]	@ zero_extendqisi2
 1481 0ba0 38C29F05 		ldreq	ip, .L123
 1482 0ba4 D600CC05 		streqb	r0, [ip, #214]
 1483              	.LVL105:
 1484              	.L110:
 704:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1485              		.loc 1 704 0
 1486 0ba8 0020E0E3 		mvn	r2, #0
 1487 0bac D720C4E5 		strb	r2, [r4, #215]
 1488 0bb0 D8FFFFEA 		b	.L98
 1489              	.LVL106:
 1490              	.L103:
 662:../uvc.c      **** 		}else if(I2CCMDArry[3] == 1){
 1491              		.loc 1 662 0
 1492 0bb4 010052E3 		cmp	r2, #1
 1493 0bb8 FAFFFF1A 		bne	.L110
 664:../uvc.c      **** 				I2CCMDArry[9] = value[I2CCMDArry[2]][0];  // bmRequest
 1494              		.loc 1 664 0
 1495 0bbc 83C084E0 		add	ip, r4, r3, asl #1
 1496 0bc0 DC00DCE5 		ldrb	r0, [ip, #220]	@ zero_extendqisi2
 665:../uvc.c      **** 				I2CCMDArry[10] = value[I2CCMDArry[2]][1]; // bRequest
 1497              		.loc 1 665 0
 1498 0bc4 DD10DCE5 		ldrb	r1, [ip, #221]	@ zero_extendqisi2
 664:../uvc.c      **** 				I2CCMDArry[9] = value[I2CCMDArry[2]][0];  // bmRequest
 1499              		.loc 1 664 0
 1500 0bc8 D500C4E5 		strb	r0, [r4, #213]
 665:../uvc.c      **** 				I2CCMDArry[10] = value[I2CCMDArry[2]][1]; // bRequest
 1501              		.loc 1 665 0
 1502 0bcc D610C4E5 		strb	r1, [r4, #214]
 1503 0bd0 F4FFFFEA 		b	.L110
 1504              	.L118:
 676:../uvc.c      **** 			dbgIdx = 2;
 1505              		.loc 1 676 0
 1506 0bd4 0C229FE5 		ldr	r2, .L123+8
 673:../uvc.c      **** 			debugData[0][0] = 0x00;  debugData[0][1] = 0x00;//
 1507              		.loc 1 673 0
 1508 0bd8 0010A0E3 		mov	r1, #0
 676:../uvc.c      **** 			dbgIdx = 2;
 1509              		.loc 1 676 0
 1510 0bdc 0230A0E3 		mov	r3, #2
 673:../uvc.c      **** 			debugData[0][0] = 0x00;  debugData[0][1] = 0x00;//
 1511              		.loc 1 673 0
 1512 0be0 2810C4E5 		strb	r1, [r4, #40]
 1513 0be4 2910C4E5 		strb	r1, [r4, #41]
 674:../uvc.c      **** 			debugData[1][0] = 0x00;  debugData[1][1] = 0x00;//
 1514              		.loc 1 674 0
 1515 0be8 2A10C4E5 		strb	r1, [r4, #42]
 1516 0bec 2B10C4E5 		strb	r1, [r4, #43]
 675:../uvc.c      **** 			debugData[15][0] = 0x00;  debugData[15][1] = 0x00;//
 1517              		.loc 1 675 0
 1518 0bf0 4610C4E5 		strb	r1, [r4, #70]
 1519 0bf4 4710C4E5 		strb	r1, [r4, #71]
 676:../uvc.c      **** 			dbgIdx = 2;
 1520              		.loc 1 676 0
 1521 0bf8 8C34C2E5 		strb	r3, [r2, #1164]
 677:../uvc.c      **** 			valIdx = 1;
 1522              		.loc 1 677 0
 1523 0bfc 8E54C2E5 		strb	r5, [r2, #1166]
 678:../uvc.c      **** 			value[0][1] = valIdx;
 1524              		.loc 1 678 0
 1525 0c00 DD50C4E5 		strb	r5, [r4, #221]
 1526 0c04 C3FFFFEA 		b	.L98
 1527              	.L104:
 644:../uvc.c      **** 			else if (I2CCMDArry[2] == 1){
 1528              		.loc 1 644 0
 1529 0c08 010053E3 		cmp	r3, #1
 1530 0c0c 1A00000A 		beq	.L120
 648:../uvc.c      **** 			else if(I2CCMDArry[2] == 17){
 1531              		.loc 1 648 0
 1532 0c10 110053E3 		cmp	r3, #17
 1533 0c14 1E00000A 		beq	.L121
 659:../uvc.c      **** 				I2CCMDArry[9] = debugData[I2CCMDArry[2]][0];  // bmRequest
 1534              		.loc 1 659 0
 1535 0c18 833084E0 		add	r3, r4, r3, asl #1
 1536 0c1c 2820D3E5 		ldrb	r2, [r3, #40]	@ zero_extendqisi2
 660:../uvc.c      **** 				I2CCMDArry[10] = debugData[I2CCMDArry[2]][1]; // bRequest
 1537              		.loc 1 660 0
 1538 0c20 29C0D3E5 		ldrb	ip, [r3, #41]	@ zero_extendqisi2
 659:../uvc.c      **** 				I2CCMDArry[9] = debugData[I2CCMDArry[2]][0];  // bmRequest
 1539              		.loc 1 659 0
 1540 0c24 D520C4E5 		strb	r2, [r4, #213]
 660:../uvc.c      **** 				I2CCMDArry[10] = debugData[I2CCMDArry[2]][1]; // bRequest
 1541              		.loc 1 660 0
 1542 0c28 D6C0C4E5 		strb	ip, [r4, #214]
 1543 0c2c DDFFFFEA 		b	.L110
 1544              	.L119:
 626:../uvc.c      **** 	if((I2CCMDArry[2]==0x70) && (I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01
 1545              		.loc 1 626 0 discriminator 1
 1546 0c30 D020D4E5 		ldrb	r2, [r4, #208]	@ zero_extendqisi2
 1547 0c34 300052E3 		cmp	r2, #48
 1548 0c38 C7FFFF1A 		bne	.L100
 1549 0c3c D1C0D4E5 		ldrb	ip, [r4, #209]	@ zero_extendqisi2
 1550 0c40 01005CE3 		cmp	ip, #1
 1551 0c44 C4FFFF1A 		bne	.L100
 628:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 1552              		.loc 1 628 0
 1553 0c48 D520D4E5 		ldrb	r2, [r4, #213]	@ zero_extendqisi2
 1554 0c4c 94E19FE5 		ldr	lr, .L123+8
 1555 0c50 031002E2 		and	r1, r2, #3
 1556 0c54 8D14CEE5 		strb	r1, [lr, #1165]
 629:../uvc.c      **** 		if(is60Hz==CyFalse)
 1557              		.loc 1 629 0
 1558 0c58 D83094E5 		ldr	r3, [r4, #216]
 633:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1559              		.loc 1 633 0
 1560 0c5c 88119FE5 		ldr	r1, .L123+12
 629:../uvc.c      **** 		if(is60Hz==CyFalse)
 1561              		.loc 1 629 0
 1562 0c60 000053E3 		cmp	r3, #0
 631:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 1563              		.loc 1 631 0
 1564 0c64 80208203 		orreq	r2, r2, #128
 1565 0c68 D520C405 		streqb	r2, [r4, #213]
 633:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1566              		.loc 1 633 0
 1567 0c6c 8D34DEE5 		ldrb	r3, [lr, #1165]	@ zero_extendqisi2
 1568 0c70 0400A0E3 		mov	r0, #4
 1569 0c74 FEFFFFEB 		bl	CyU3PDebugPrint
 1570 0c78 B7FFFFEA 		b	.L100
 1571              	.L120:
 646:../uvc.c      **** 				I2CCMDArry[10] = dbgIdx; // freeze count
 1572              		.loc 1 646 0
 1573 0c7c 64019FE5 		ldr	r0, .L123+8
 645:../uvc.c      **** 				I2CCMDArry[9] = debugData[1][0];  // abort code
 1574              		.loc 1 645 0
 1575 0c80 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 646:../uvc.c      **** 				I2CCMDArry[10] = dbgIdx; // freeze count
 1576              		.loc 1 646 0
 1577 0c84 8C34D0E5 		ldrb	r3, [r0, #1164]	@ zero_extendqisi2
 645:../uvc.c      **** 				I2CCMDArry[9] = debugData[1][0];  // abort code
 1578              		.loc 1 645 0
 1579 0c88 D510C4E5 		strb	r1, [r4, #213]
 646:../uvc.c      **** 				I2CCMDArry[10] = dbgIdx; // freeze count
 1580              		.loc 1 646 0
 1581 0c8c D630C4E5 		strb	r3, [r4, #214]
 1582 0c90 C4FFFFEA 		b	.L110
 1583              	.L121:
 1584              	.LVL107:
 1585              	.LBB62:
 650:../uvc.c      **** 				apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_OR);
 1586              		.loc 1 650 0
 1587 0c94 0400A0E1 		mov	r0, r4
 1588 0c98 0110A0E3 		mov	r1, #1
 1589 0c9c FEFFFFEB 		bl	_txe_event_flags_set
 1590              	.LVL108:
 652:../uvc.c      **** 				if (apiRetStatus != CY_U3P_SUCCESS)
 1591              		.loc 1 652 0
 1592 0ca0 002050E2 		subs	r2, r0, #0
 1593 0ca4 BFFFFF0A 		beq	.L110
 654:../uvc.c      **** 					CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetStatus);
 1594              		.loc 1 654 0
 1595 0ca8 40119FE5 		ldr	r1, .L123+16
 1596 0cac 0400A0E3 		mov	r0, #4
 1597              	.LVL109:
 1598 0cb0 FEFFFFEB 		bl	CyU3PDebugPrint
 1599              	.LVL110:
 1600 0cb4 BBFFFFEA 		b	.L110
 1601              	.L109:
 1602              	.LBE62:
 708:../uvc.c      **** 	}else if(CmdType == 1){
 1603              		.loc 1 708 0
 1604 0cb8 010055E3 		cmp	r5, #1
 1605 0cbc 95FFFF1A 		bne	.L98
 710:../uvc.c      **** 			if(CmdRegLen == 2){
 1606              		.loc 1 710 0
 1607 0cc0 020057E3 		cmp	r7, #2
 1608 0cc4 2400000A 		beq	.L122
 715:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1609              		.loc 1 715 0
 1610 0cc8 CF10D4E5 		ldrb	r1, [r4, #207]	@ zero_extendqisi2
 1611 0ccc 0C319FE5 		ldr	r3, .L123
 1612 0cd0 FE1001E2 		and	r1, r1, #254
 1613 0cd4 820051E3 		cmp	r1, #130
 718:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1614              		.loc 1 718 0
 1615 0cd8 D050D315 		ldrneb	r5, [r3, #208]	@ zero_extendqisi2
 1616              	.LVL111:
 715:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1617              		.loc 1 715 0
 1618 0cdc 0200001A 		bne	.L115
 715:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1619              		.loc 1 715 0 is_stmt 0 discriminator 1
 1620 0ce0 D050D3E5 		ldrb	r5, [r3, #208]	@ zero_extendqisi2
 1621 0ce4 300055E3 		cmp	r5, #48
 1622 0ce8 0700000A 		beq	.L113
 1623              	.L115:
 718:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1624              		.loc 1 718 0 is_stmt 1
 1625 0cec D130D3E5 		ldrb	r3, [r3, #209]	@ zero_extendqisi2
 1626              	.L114:
 720:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 1627              		.loc 1 720 0
 1628 0cf0 CE00D4E5 		ldrb	r0, [r4, #206]	@ zero_extendqisi2
 1629 0cf4 D5E0D4E5 		ldrb	lr, [r4, #213]	@ zero_extendqisi2
 1630 0cf8 0520A0E1 		mov	r2, r5
 1631 0cfc FE0000E2 		and	r0, r0, #254
 1632 0d00 00E08DE5 		str	lr, [sp, #0]
 1633 0d04 FEFFFFEB 		bl	SensorWrite2B
 1634 0d08 82FFFFEA 		b	.L98
 1635              	.L113:
 715:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1636              		.loc 1 715 0 discriminator 1
 1637 0d0c D130D3E5 		ldrb	r3, [r3, #209]	@ zero_extendqisi2
 1638 0d10 100053E3 		cmp	r3, #16
 1639 0d14 F5FFFF1A 		bne	.L114
 716:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 1640              		.loc 1 716 0
 1641 0d18 D4409FE5 		ldr	r4, .L123+20
 1642 0d1c 0010E0E3 		mvn	r1, #0
 1643 0d20 1C0094E5 		ldr	r0, [r4, #28]
 1644 0d24 2C308DE5 		str	r3, [sp, #44]
 1645 0d28 FEFFFFEB 		bl	_txe_mutex_get
 717:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 1646              		.loc 1 717 0
 1647 0d2c 2C309DE5 		ldr	r3, [sp, #44]
 1648 0d30 00C0A0E3 		mov	ip, #0
 1649 0d34 0320A0E1 		mov	r2, r3
 1650 0d38 0400A0E1 		mov	r0, r4
 1651 0d3c 1710A0E3 		mov	r1, #23
 1652 0d40 0530A0E1 		mov	r3, r5
 1653 0d44 00C08DE5 		str	ip, [sp, #0]
 1654 0d48 04C08DE5 		str	ip, [sp, #4]
 1655 0d4c FEFFFFEB 		bl	cmdSet
 718:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1656              		.loc 1 718 0
 1657 0d50 1C0094E5 		ldr	r0, [r4, #28]
 1658 0d54 FEFFFFEB 		bl	_txe_mutex_put
 1659 0d58 6EFFFFEA 		b	.L98
 1660              	.LVL112:
 1661              	.L122:
 712:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 1662              		.loc 1 712 0
 1663 0d5c CE20D4E5 		ldrb	r2, [r4, #206]	@ zero_extendqisi2
 1664 0d60 D5E0D4E5 		ldrb	lr, [r4, #213]	@ zero_extendqisi2
 1665 0d64 CF10D4E5 		ldrb	r1, [r4, #207]	@ zero_extendqisi2
 1666 0d68 D030D4E5 		ldrb	r3, [r4, #208]	@ zero_extendqisi2
 1667 0d6c FE0002E2 		and	r0, r2, #254
 1668 0d70 0020A0E3 		mov	r2, #0
 1669 0d74 00E08DE5 		str	lr, [sp, #0]
 1670 0d78 FEFFFFEB 		bl	SensorWrite2B2
 1671 0d7c CE00D4E5 		ldrb	r0, [r4, #206]	@ zero_extendqisi2
 1672 0d80 D5C0D4E5 		ldrb	ip, [r4, #213]	@ zero_extendqisi2
 1673 0d84 CF10D4E5 		ldrb	r1, [r4, #207]	@ zero_extendqisi2
 1674 0d88 D030D4E5 		ldrb	r3, [r4, #208]	@ zero_extendqisi2
 1675 0d8c 0020A0E3 		mov	r2, #0
 1676 0d90 FE0000E2 		and	r0, r0, #254
 1677 0d94 00C08DE5 		str	ip, [sp, #0]
 1678 0d98 FEFFFFEB 		bl	SensorWrite2B2
 1679              	.LVL113:
 1680 0d9c CE20D4E5 		ldrb	r2, [r4, #206]	@ zero_extendqisi2
 1681 0da0 D5C0D4E5 		ldrb	ip, [r4, #213]	@ zero_extendqisi2
 1682 0da4 CF10D4E5 		ldrb	r1, [r4, #207]	@ zero_extendqisi2
 1683 0da8 D030D4E5 		ldrb	r3, [r4, #208]	@ zero_extendqisi2
 1684 0dac FE0002E2 		and	r0, r2, #254
 1685 0db0 0020A0E3 		mov	r2, #0
 1686 0db4 00C08DE5 		str	ip, [sp, #0]
 1687 0db8 FEFFFFEB 		bl	SensorWrite2B2
 1688 0dbc CE00D4E5 		ldrb	r0, [r4, #206]	@ zero_extendqisi2
 1689 0dc0 D5C0D4E5 		ldrb	ip, [r4, #213]	@ zero_extendqisi2
 1690 0dc4 CF10D4E5 		ldrb	r1, [r4, #207]	@ zero_extendqisi2
 1691 0dc8 D030D4E5 		ldrb	r3, [r4, #208]	@ zero_extendqisi2
 1692 0dcc 0020A0E3 		mov	r2, #0
 1693 0dd0 FE0000E2 		and	r0, r0, #254
 1694 0dd4 00C08DE5 		str	ip, [sp, #0]
 1695 0dd8 FEFFFFEB 		bl	SensorWrite2B2
 1696 0ddc 4DFFFFEA 		b	.L98
 1697              	.L124:
 1698              		.align	2
 1699              	.L123:
 1700 0de0 00000000 		.word	.LANCHOR0
 1701 0de4 78020000 		.word	.LC16
 1702 0de8 00000000 		.word	.LANCHOR1
 1703 0dec C4020000 		.word	.LC17
 1704 0df0 EC020000 		.word	.LC18
 1705 0df4 00000000 		.word	cmdQu
 1706              		.cfi_endproc
 1707              	.LFE0:
 1709              		.align	2
 1710              		.global	setIrisauto
 1712              	setIrisauto:
 1713              	.LFB1:
 734:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1714              		.loc 1 734 0
 1715              		.cfi_startproc
 1716              		@ args = 0, pretend = 0, frame = 0
 1717              		@ frame_needed = 0, uses_anonymous_args = 0
 1718              	.LVL114:
 1719 0df8 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1720              	.LCFI12:
 1721              		.cfi_def_cfa_offset 16
 1722 0dfc 0160A0E1 		mov	r6, r1
 1723              		.cfi_offset 14, -4
 1724              		.cfi_offset 6, -8
 1725              		.cfi_offset 5, -12
 1726              		.cfi_offset 4, -16
 1727 0e00 08D04DE2 		sub	sp, sp, #8
 1728              	.LCFI13:
 1729              		.cfi_def_cfa_offset 24
 734:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1730              		.loc 1 734 0
 1731 0e04 0040A0E1 		mov	r4, r0
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1732              		.loc 1 737 0
 1733 0e08 0050A0E3 		mov	r5, #0
 736:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1734              		.loc 1 736 0
 1735 0e0c 0010E0E3 		mvn	r1, #0
 1736              	.LVL115:
 1737 0e10 1C0090E5 		ldr	r0, [r0, #28]
 1738              	.LVL116:
 1739 0e14 FEFFFFEB 		bl	_txe_mutex_get
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1740              		.loc 1 737 0
 1741 0e18 060065E0 		rsb	r0, r5, r6
 1742 0e1c 00C070E2 		rsbs	ip, r0, #0
 1743 0e20 00C0ACE0 		adc	ip, ip, r0
 1744 0e24 2010A0E3 		mov	r1, #32
 1745 0e28 2720A0E3 		mov	r2, #39
 1746 0e2c 3030A0E3 		mov	r3, #48
 1747 0e30 0400A0E1 		mov	r0, r4
 1748 0e34 00C08DE5 		str	ip, [sp, #0]
 1749 0e38 04508DE5 		str	r5, [sp, #4]
 1750 0e3c FEFFFFEB 		bl	cmdSet
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 1751              		.loc 1 738 0
 1752 0e40 050056E1 		cmp	r6, r5
 1753 0e44 0260A003 		moveq	r6, #2
 1754 0e48 0160A013 		movne	r6, #1
 1755 0e4c 0400A0E1 		mov	r0, r4
 1756 0e50 2110A0E3 		mov	r1, #33
 1757 0e54 2520A0E3 		mov	r2, #37
 1758 0e58 3030A0E3 		mov	r3, #48
 1759 0e5c 00608DE5 		str	r6, [sp, #0]
 1760 0e60 04508DE5 		str	r5, [sp, #4]
 1761 0e64 FEFFFFEB 		bl	cmdSet
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1762              		.loc 1 739 0
 1763 0e68 1C0094E5 		ldr	r0, [r4, #28]
 740:../uvc.c      **** }
 1764              		.loc 1 740 0
 1765 0e6c 08D08DE2 		add	sp, sp, #8
 1766 0e70 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1767              		.loc 1 739 0
 1768 0e74 FEFFFFEA 		b	_txe_mutex_put
 1769              		.cfi_endproc
 1770              	.LFE1:
 1772              		.align	2
 1773              		.global	getShutCtrl
 1775              	getShutCtrl:
 1776              	.LFB2:
 744:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 1777              		.loc 1 744 0
 1778              		.cfi_startproc
 1779              		@ args = 0, pretend = 0, frame = 0
 1780              		@ frame_needed = 0, uses_anonymous_args = 0
 1781              	.LVL117:
 749:../uvc.c      **** 	switch (Data){
 1782              		.loc 1 749 0
 1783 0e78 013040E2 		sub	r3, r0, #1
 744:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 1784              		.loc 1 744 0
 1785 0e7c 10402DE9 		stmfd	sp!, {r4, lr}
 1786              	.LCFI14:
 1787              		.cfi_def_cfa_offset 8
 1788 0e80 08D04DE2 		sub	sp, sp, #8
 1789              	.LCFI15:
 1790              		.cfi_def_cfa_offset 16
 749:../uvc.c      **** 	switch (Data){
 1791              		.loc 1 749 0
 1792 0e84 090053E3 		cmp	r3, #9
 1793 0e88 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1794 0e8c 380000EA 		b	.L129
 1795              		.cfi_offset 14, -4
 1796              		.cfi_offset 4, -8
 1797              	.L132:
 1798 0e90 280F0000 		.word	.L130
 1799 0e94 280F0000 		.word	.L130
 1800 0e98 280F0000 		.word	.L130
 1801 0e9c 280F0000 		.word	.L130
 1802 0ea0 280F0000 		.word	.L130
 1803 0ea4 B80E0000 		.word	.L131
 1804 0ea8 B80E0000 		.word	.L131
 1805 0eac B80E0000 		.word	.L131
 1806 0eb0 B80E0000 		.word	.L131
 1807 0eb4 B80E0000 		.word	.L131
 1808              	.L131:
 1809              	.LVL118:
 773:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1810              		.loc 1 773 0
 1811 0eb8 ECC09FE5 		ldr	ip, .L141
 771:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 1812              		.loc 1 771 0
 1813 0ebc 8330A0E1 		mov	r3, r3, asl #1
 773:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1814              		.loc 1 773 0
 1815 0ec0 B3309CE1 		ldrh	r3, [ip, r3]
 1816 0ec4 E4E09FE5 		ldr	lr, .L141+4
 1817 0ec8 032263E0 		rsb	r2, r3, r3, asl #4
 1818 0ecc 8240A0E1 		mov	r4, r2, asl #1
 1819 0ed0 94CECEE0 		smull	ip, lr, r4, lr
 1820 0ed4 C4CFA0E1 		mov	ip, r4, asr #31
 1821 0ed8 4E246CE0 		rsb	r2, ip, lr, asr #8
 774:../uvc.c      **** 		if(NumLn > 1944)
 1822              		.loc 1 774 0
 1823 0edc D0E09FE5 		ldr	lr, .L141+8
 773:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1824              		.loc 1 773 0
 1825 0ee0 0228A0E1 		mov	r2, r2, asl #16
 1826 0ee4 22C8A0E1 		mov	ip, r2, lsr #16
 1827              	.LVL119:
 774:../uvc.c      **** 		if(NumLn > 1944)
 1828              		.loc 1 774 0
 1829 0ee8 0E005CE1 		cmp	ip, lr
 1830 0eec 2600008A 		bhi	.L138
 776:../uvc.c      **** 		else if(NumLn < 8)
 1831              		.loc 1 776 0
 1832 0ef0 07005CE3 		cmp	ip, #7
 1833 0ef4 2700008A 		bhi	.L140
 1834              	.LVL120:
 1835              	.L139:
 1836 0ef8 01C0A0E3 		mov	ip, #1
 1837 0efc 08E0A0E3 		mov	lr, #8
 1838 0f00 0C40A0E1 		mov	r4, ip
 1839              	.L135:
 1840              	.LVL121:
 779:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 1841              		.loc 1 779 0
 1842 0f04 0120A0E3 		mov	r2, #1
 1843 0f08 0020C1E5 		strb	r2, [r1, #0]
 780:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 1844              		.loc 1 780 0
 1845 0f0c 0020A0E1 		mov	r2, r0
 1846 0f10 A0109FE5 		ldr	r1, .L141+12
 1847              	.LVL122:
 1848 0f14 0400A0E3 		mov	r0, #4
 1849              	.LVL123:
 1850 0f18 00E08DE5 		str	lr, [sp, #0]
 1851 0f1c 04C08DE5 		str	ip, [sp, #4]
 1852 0f20 FEFFFFEB 		bl	CyU3PDebugPrint
 781:../uvc.c      **** 		break;
 1853              		.loc 1 781 0
 1854 0f24 150000EA 		b	.L134
 1855              	.LVL124:
 1856              	.L130:
 755:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 1857              		.loc 1 755 0
 1858 0f28 7CE09FE5 		ldr	lr, .L141
 1859 0f2c 8330A0E1 		mov	r3, r3, asl #1
 1860 0f30 B3309EE1 		ldrh	r3, [lr, r3]
 1861              	.LVL125:
 757:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 1862              		.loc 1 757 0
 1863 0f34 80C09FE5 		ldr	ip, .L141+16
 758:../uvc.c      **** 		if(NumLn > 1944)
 1864              		.loc 1 758 0
 1865 0f38 74E09FE5 		ldr	lr, .L141+8
 757:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 1866              		.loc 1 757 0
 1867 0f3c 932C8CE0 		umull	r2, ip, r3, ip
 1868 0f40 AC24A0E1 		mov	r2, ip, lsr #9
 1869 0f44 024262E0 		rsb	r4, r2, r2, asl #4
 1870 0f48 8448A0E1 		mov	r4, r4, asl #17
 1871 0f4c 2428A0E1 		mov	r2, r4, lsr #16
 1872              	.LVL126:
 758:../uvc.c      **** 		if(NumLn > 1944)
 1873              		.loc 1 758 0
 1874 0f50 0E0052E1 		cmp	r2, lr
 1875 0f54 0C00008A 		bhi	.L138
 760:../uvc.c      **** 		else if(NumLn < 8)
 1876              		.loc 1 760 0
 1877 0f58 070052E3 		cmp	r2, #7
 1878 0f5c E5FFFF9A 		bls	.L139
 1879 0f60 A449A0E1 		mov	r4, r4, lsr #19
 1880 0f64 FF4004E2 		and	r4, r4, #255
 1881 0f68 02E0A0E1 		mov	lr, r2
 1882 0f6c 04C0A0E1 		mov	ip, r4
 1883 0f70 E3FFFFEA 		b	.L135
 1884              	.LVL127:
 1885              	.L129:
 784:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 1886              		.loc 1 784 0
 1887 0f74 0000A0E3 		mov	r0, #0
 1888              	.LVL128:
 785:../uvc.c      **** 		LnVal = 1;
 1889              		.loc 1 785 0
 1890 0f78 0140A0E3 		mov	r4, #1
 784:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 1891              		.loc 1 784 0
 1892 0f7c 0000C1E5 		strb	r0, [r1, #0]
 1893              	.LVL129:
 1894              	.L134:
 789:../uvc.c      **** }
 1895              		.loc 1 789 0
 1896 0f80 0400A0E1 		mov	r0, r4
 1897 0f84 08D08DE2 		add	sp, sp, #8
 1898 0f88 1080BDE8 		ldmfd	sp!, {r4, pc}
 1899              	.LVL130:
 1900              	.L138:
 774:../uvc.c      **** 		if(NumLn > 1944)
 1901              		.loc 1 774 0
 1902 0f8c F3C0A0E3 		mov	ip, #243
 1903 0f90 0C40A0E1 		mov	r4, ip
 1904 0f94 DAFFFFEA 		b	.L135
 1905              	.LVL131:
 1906              	.L140:
 776:../uvc.c      **** 		else if(NumLn < 8)
 1907              		.loc 1 776 0
 1908 0f98 A2E9A0E1 		mov	lr, r2, lsr #19
 1909 0f9c FF400EE2 		and	r4, lr, #255
 1910 0fa0 0CE0A0E1 		mov	lr, ip
 1911 0fa4 04C0A0E1 		mov	ip, r4
 1912              	.LVL132:
 1913 0fa8 D5FFFFEA 		b	.L135
 1914              	.L142:
 1915              		.align	2
 1916              	.L141:
 1917 0fac 00000000 		.word	.LANCHOR2
 1918 0fb0 817F807F 		.word	2139127681
 1919 0fb4 98070000 		.word	1944
 1920 0fb8 14030000 		.word	.LC19
 1921 0fbc 01FF00FF 		.word	-16711935
 1922              		.cfi_endproc
 1923              	.LFE2:
 1925              		.align	2
 1926              		.global	ControlHandle
 1928              	ControlHandle:
 1929              	.LFB3:
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1930              		.loc 1 791 0
 1931              		.cfi_startproc
 1932              		@ args = 0, pretend = 0, frame = 24
 1933              		@ frame_needed = 0, uses_anonymous_args = 0
 1934              	.LVL133:
 1935 0fc0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1936              	.LCFI16:
 1937              		.cfi_def_cfa_offset 36
 798:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1938              		.loc 1 798 0
 1939 0fc4 230050E3 		cmp	r0, #35
 797:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1940              		.loc 1 797 0
 1941 0fc8 207040E2 		sub	r7, r0, #32
 1942              		.cfi_offset 14, -4
 1943              		.cfi_offset 11, -8
 1944              		.cfi_offset 10, -12
 1945              		.cfi_offset 9, -16
 1946              		.cfi_offset 8, -20
 1947              		.cfi_offset 7, -24
 1948              		.cfi_offset 6, -28
 1949              		.cfi_offset 5, -32
 1950              		.cfi_offset 4, -36
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1951              		.loc 1 791 0
 1952 0fcc 2CD04DE2 		sub	sp, sp, #44
 1953              	.LCFI17:
 1954              		.cfi_def_cfa_offset 80
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1955              		.loc 1 791 0
 1956 0fd0 0040A0E1 		mov	r4, r0
 797:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1957              		.loc 1 797 0
 1958 0fd4 FF7007E2 		and	r7, r7, #255
 1959              	.LVL134:
 798:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1960              		.loc 1 798 0
 1961 0fd8 2300009A 		bls	.L144
 799:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1962              		.loc 1 799 0
 1963 0fdc 586F9FE5 		ldr	r6, .L325+72
 1964 0fe0 872087E0 		add	r2, r7, r7, asl #1
 1965 0fe4 8221A0E1 		mov	r2, r2, asl #3
 1966 0fe8 023086E0 		add	r3, r6, r2
 800:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1967              		.loc 1 800 0
 1968 0fec 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 801:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1969              		.loc 1 801 0
 1970 0ff0 0F90D3E5 		ldrb	r9, [r3, #15]	@ zero_extendqisi2
 802:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1971              		.loc 1 802 0
 1972 0ff4 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 813:../uvc.c      ****     reqData = bRequest;
 1973              		.loc 1 813 0
 1974 0ff8 F43E9FE5 		ldr	r3, .L325
 799:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1975              		.loc 1 799 0
 1976 0ffc 02A0D6E7 		ldrb	sl, [r6, r2]	@ zero_extendqisi2
 1977              	.LVL135:
 813:../uvc.c      ****     reqData = bRequest;
 1978              		.loc 1 813 0
 1979 1000 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1980              	.LVL136:
 821:../uvc.c      ****     switch (bRequest)
 1981              		.loc 1 821 0
 1982 1004 830055E3 		cmp	r5, #131
 1983 1008 2200000A 		beq	.L150
 1984              	.LVL137:
 1985              	.L315:
 1986 100c 2B00009A 		bls	.L313
 1987 1010 850055E3 		cmp	r5, #133
 1988 1014 8800000A 		beq	.L152
 1989 1018 7600003A 		bcc	.L151
 1990 101c 860055E3 		cmp	r5, #134
 1991 1020 C500000A 		beq	.L153
 1992 1024 870055E3 		cmp	r5, #135
 1993 1028 B900000A 		beq	.L314
 1994              	.L146:
1707:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1995              		.loc 1 1707 0
 1996 102c 0000A0E3 		mov	r0, #0
 1997              	.LVL138:
 1998 1030 0110A0E3 		mov	r1, #1
 1999 1034 0020A0E1 		mov	r2, r0
 2000 1038 FEFFFFEB 		bl	CyU3PUsbStall
1708:../uvc.c      **** 			  break;
 2001              		.loc 1 1708 0
 2002 103c FFA0A0E3 		mov	sl, #255
 2003 1040 0A70A0E1 		mov	r7, sl
 2004              	.LVL139:
 2005 1044 0A40A0E1 		mov	r4, sl
 2006 1048 0A80A0E1 		mov	r8, sl
 2007              	.LVL140:
 2008              	.L156:
1710:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 2009              		.loc 1 1710 0
 2010 104c A41E9FE5 		ldr	r1, .L325+4
 2011 1050 0520A0E1 		mov	r2, r5
 2012 1054 0830A0E1 		mov	r3, r8
 2013 1058 0400A0E3 		mov	r0, #4
 2014 105c 90048DE8 		stmia	sp, {r4, r7, sl}	@ phole stm
 2015 1060 FEFFFFEB 		bl	CyU3PDebugPrint
1711:../uvc.c      **** }
 2016              		.loc 1 1711 0
 2017 1064 2CD08DE2 		add	sp, sp, #44
 2018 1068 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 2019              	.LVL141:
 2020              	.L144:
 804:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 2021              		.loc 1 804 0
 2022 106c C86E9FE5 		ldr	r6, .L325+72
 813:../uvc.c      ****     reqData = bRequest;
 2023              		.loc 1 813 0
 2024 1070 7C3E9FE5 		ldr	r3, .L325
 804:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 2025              		.loc 1 804 0
 2026 1074 808080E0 		add	r8, r0, r0, asl #1
 2027 1078 885186E0 		add	r5, r6, r8, asl #3
 2028 107c 80A1D5E5 		ldrb	sl, [r5, #384]	@ zero_extendqisi2
 2029              	.LVL142:
 805:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2030              		.loc 1 805 0
 2031 1080 81B1D5E5 		ldrb	fp, [r5, #385]	@ zero_extendqisi2
 2032              	.LVL143:
 806:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 2033              		.loc 1 806 0
 2034 1084 8F91D5E5 		ldrb	r9, [r5, #399]	@ zero_extendqisi2
 2035              	.LVL144:
 807:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 2036              		.loc 1 807 0
 2037 1088 8281D5E5 		ldrb	r8, [r5, #386]	@ zero_extendqisi2
 2038              	.LVL145:
 813:../uvc.c      ****     reqData = bRequest;
 2039              		.loc 1 813 0
 2040 108c 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 2041              	.LVL146:
 821:../uvc.c      ****     switch (bRequest)
 2042              		.loc 1 821 0
 2043 1090 830055E3 		cmp	r5, #131
 2044 1094 DCFFFF1A 		bne	.L315
 2045              	.LVL147:
 2046              	.L150:
1191:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2047              		.loc 1 1191 0
 2048 1098 230054E3 		cmp	r4, #35
 2049 109c C400009A 		bls	.L223
1192:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 2050              		.loc 1 1192 0
 2051 10a0 872087E0 		add	r2, r7, r7, asl #1
 2052 10a4 826186E0 		add	r6, r6, r2, asl #3
 2053 10a8 909E9FE5 		ldr	r9, .L325+76
 2054 10ac 0530D6E5 		ldrb	r3, [r6, #5]	@ zero_extendqisi2
1193:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 2055              		.loc 1 1193 0
 2056 10b0 0600D6E5 		ldrb	r0, [r6, #6]	@ zero_extendqisi2
 2057              	.LVL148:
1192:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 2058              		.loc 1 1192 0
 2059 10b4 1C31C9E5 		strb	r3, [r9, #284]
1193:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 2060              		.loc 1 1193 0
 2061 10b8 1D01C9E5 		strb	r0, [r9, #285]
 2062 10bc 0B0000EA 		b	.L231
 2063              	.LVL149:
 2064              	.L313:
 821:../uvc.c      ****     switch (bRequest)
 2065              		.loc 1 821 0
 2066 10c0 810055E3 		cmp	r5, #129
 2067 10c4 6800000A 		beq	.L148
 2068 10c8 1000009A 		bls	.L316
1172:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2069              		.loc 1 1172 0
 2070 10cc 230054E3 		cmp	r4, #35
 2071 10d0 AB00009A 		bls	.L220
1173:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 2072              		.loc 1 1173 0
 2073 10d4 879087E0 		add	r9, r7, r7, asl #1
 2074 10d8 896186E0 		add	r6, r6, r9, asl #3
 2075 10dc 0370D6E5 		ldrb	r7, [r6, #3]	@ zero_extendqisi2
 2076              	.LVL150:
 2077 10e0 589E9FE5 		ldr	r9, .L325+76
1174:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 2078              		.loc 1 1174 0
 2079 10e4 04E0D6E5 		ldrb	lr, [r6, #4]	@ zero_extendqisi2
1173:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 2080              		.loc 1 1173 0
 2081 10e8 1C71C9E5 		strb	r7, [r9, #284]
1174:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 2082              		.loc 1 1174 0
 2083 10ec 1DE1C9E5 		strb	lr, [r9, #285]
 2084              	.LVL151:
 2085              	.L231:
1249:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2086              		.loc 1 1249 0
 2087 10f0 0800A0E1 		mov	r0, r8
1251:../uvc.c      **** 			  break;
 2088              		.loc 1 1251 0
 2089 10f4 FFA0A0E3 		mov	sl, #255
1249:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2090              		.loc 1 1249 0
 2091 10f8 FC1D9FE5 		ldr	r1, .L325+8
 2092 10fc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2093              	.LVL152:
1251:../uvc.c      **** 			  break;
 2094              		.loc 1 1251 0
 2095 1100 0A40A0E1 		mov	r4, sl
1249:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2096              		.loc 1 1249 0
 2097 1104 1C71D9E5 		ldrb	r7, [r9, #284]	@ zero_extendqisi2
1251:../uvc.c      **** 			  break;
 2098              		.loc 1 1251 0
 2099 1108 0A80A0E1 		mov	r8, sl
 2100 110c CEFFFFEA 		b	.L156
 2101              	.LVL153:
 2102              	.L316:
 821:../uvc.c      ****     switch (bRequest)
 2103              		.loc 1 821 0
 2104 1110 010055E3 		cmp	r5, #1
 2105 1114 C4FFFF1A 		bne	.L146
1253:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 2106              		.loc 1 1253 0
 2107 1118 201E9FE5 		ldr	r1, .L325+76
 2108 111c 26208DE2 		add	r2, sp, #38
 2109 1120 2000A0E3 		mov	r0, #32
 2110              	.LVL154:
 2111 1124 471F81E2 		add	r1, r1, #284
 2112 1128 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2113              	.LVL155:
1255:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 2114              		.loc 1 1255 0
 2115 112c 002050E2 		subs	r2, r0, #0
 2116 1130 4A04001A 		bne	.L233
1257:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 2117              		.loc 1 1257 0
 2118 1134 04CE9FE5 		ldr	ip, .L325+76
1258:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 2119              		.loc 1 1258 0
 2120 1138 00EE9FE5 		ldr	lr, .L325+76
1257:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 2121              		.loc 1 1257 0
 2122 113c 1C31DCE5 		ldrb	r3, [ip, #284]	@ zero_extendqisi2
1260:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 2123              		.loc 1 1260 0
 2124 1140 1E01DEE5 		ldrb	r0, [lr, #286]	@ zero_extendqisi2
 2125              	.LVL156:
1257:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 2126              		.loc 1 1257 0
 2127 1144 18308DE5 		str	r3, [sp, #24]
 2128              	.LVL157:
1258:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 2129              		.loc 1 1258 0
 2130 1148 1DC1DEE5 		ldrb	ip, [lr, #285]	@ zero_extendqisi2
 2131              	.LVL158:
1260:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 2132              		.loc 1 1260 0
 2133 114c 1C008DE5 		str	r0, [sp, #28]
 2134              	.LVL159:
1264:../uvc.c      **** 				  switch(CtrlID)
 2135              		.loc 1 1264 0
 2136 1150 260054E3 		cmp	r4, #38
 2137 1154 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2138 1158 790300EA 		b	.L234
 2139              	.L252:
 2140 115c 881E0000 		.word	.L235
 2141 1160 1C1E0000 		.word	.L236
 2142 1164 BC1D0000 		.word	.L237
 2143 1168 441F0000 		.word	.L234
 2144 116c 581D0000 		.word	.L238
 2145 1170 181C0000 		.word	.L239
 2146 1174 A01B0000 		.word	.L240
 2147 1178 E0210000 		.word	.L241
 2148 117c 441F0000 		.word	.L234
 2149 1180 441F0000 		.word	.L234
 2150 1184 441F0000 		.word	.L234
 2151 1188 5C210000 		.word	.L242
 2152 118c 441F0000 		.word	.L234
 2153 1190 441F0000 		.word	.L234
 2154 1194 441F0000 		.word	.L234
 2155 1198 441F0000 		.word	.L234
 2156 119c 80200000 		.word	.L243
 2157 11a0 441F0000 		.word	.L234
 2158 11a4 441F0000 		.word	.L234
 2159 11a8 441F0000 		.word	.L234
 2160 11ac 441F0000 		.word	.L234
 2161 11b0 441F0000 		.word	.L234
 2162 11b4 441F0000 		.word	.L234
 2163 11b8 441F0000 		.word	.L234
 2164 11bc 441F0000 		.word	.L234
 2165 11c0 AC1F0000 		.word	.L244
 2166 11c4 BC1D0000 		.word	.L237
 2167 11c8 7C190000 		.word	.L245
 2168 11cc F4180000 		.word	.L246
 2169 11d0 441F0000 		.word	.L234
 2170 11d4 98180000 		.word	.L247
 2171 11d8 14180000 		.word	.L248
 2172 11dc 441F0000 		.word	.L234
 2173 11e0 441F0000 		.word	.L234
 2174 11e4 441F0000 		.word	.L234
 2175 11e8 441F0000 		.word	.L234
 2176 11ec 841A0000 		.word	.L249
 2177 11f0 101A0000 		.word	.L250
 2178 11f4 201B0000 		.word	.L251
 2179              	.LVL160:
 2180              	.L151:
1209:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2181              		.loc 1 1209 0
 2182 11f8 230054E3 		cmp	r4, #35
1216:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2183              		.loc 1 1216 0
 2184 11fc 84408490 		addls	r4, r4, r4, asl #1
1210:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 2185              		.loc 1 1210 0
 2186 1200 87708780 		addhi	r7, r7, r7, asl #1
 2187              	.LVL161:
1216:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2188              		.loc 1 1216 0
 2189 1204 84618690 		addls	r6, r6, r4, asl #3
1210:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 2190              		.loc 1 1210 0
 2191 1208 87618680 		addhi	r6, r6, r7, asl #3
 2192 120c 2C9D9F85 		ldrhi	r9, .L325+76
1216:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2193              		.loc 1 1216 0
 2194 1210 289D9F95 		ldrls	r9, .L325+76
1210:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 2195              		.loc 1 1210 0
 2196 1214 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
1211:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 2197              		.loc 1 1211 0
 2198 1218 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
1216:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2199              		.loc 1 1216 0
 2200 121c 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
1217:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 2201              		.loc 1 1217 0
 2202 1220 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
1218:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 2203              		.loc 1 1218 0
 2204 1224 0040A0E3 		mov	r4, #0
1216:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2205              		.loc 1 1216 0
 2206 1228 1C11C9E5 		strb	r1, [r9, #284]
1217:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 2207              		.loc 1 1217 0
 2208 122c 1D21C9E5 		strb	r2, [r9, #285]
1218:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 2209              		.loc 1 1218 0
 2210 1230 1E41C9E5 		strb	r4, [r9, #286]
1219:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 2211              		.loc 1 1219 0
 2212 1234 1F41C9E5 		strb	r4, [r9, #287]
 2213 1238 ACFFFFEA 		b	.L231
 2214              	.LVL162:
 2215              	.L152:
 825:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 2216              		.loc 1 825 0
 2217 123c FC4C9FE5 		ldr	r4, .L325+76
 826:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2218              		.loc 1 826 0
 2219 1240 00A0A0E3 		mov	sl, #0
 825:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 2220              		.loc 1 825 0
 2221 1244 1C81C4E5 		strb	r8, [r4, #284]
 826:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2222              		.loc 1 826 0
 2223 1248 1DA1C4E5 		strb	sl, [r4, #285]
 827:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2224              		.loc 1 827 0
 2225 124c 471F84E2 		add	r1, r4, #284
 829:../uvc.c      **** 			  break;
 2226              		.loc 1 829 0
 2227 1250 FFA0A0E3 		mov	sl, #255
 827:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2228              		.loc 1 827 0
 2229 1254 0200A0E3 		mov	r0, #2
 2230              	.LVL163:
 2231 1258 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2232              	.LVL164:
 829:../uvc.c      **** 			  break;
 2233              		.loc 1 829 0
 2234 125c 0A80A0E1 		mov	r8, sl
 827:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2235              		.loc 1 827 0
 2236 1260 1C71D4E5 		ldrb	r7, [r4, #284]	@ zero_extendqisi2
 2237              	.LVL165:
 829:../uvc.c      **** 			  break;
 2238              		.loc 1 829 0
 2239 1264 0A40A0E1 		mov	r4, sl
 2240 1268 77FFFFEA 		b	.L156
 2241              	.LVL166:
 2242              	.L148:
 832:../uvc.c      **** 			 switch(CtrlID)
 2243              		.loc 1 832 0
 2244 126c 260054E3 		cmp	r4, #38
 2245 1270 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2246 1274 DB0000EA 		b	.L157
 2247              	.L174:
 2248 1278 44170000 		.word	.L158
 2249 127c 84160000 		.word	.L159
 2250 1280 D8160000 		.word	.L160
 2251 1284 E8150000 		.word	.L157
 2252 1288 84150000 		.word	.L161
 2253 128c F4170000 		.word	.L162
 2254 1290 E8150000 		.word	.L157
 2255 1294 AC160000 		.word	.L163
 2256 1298 E8150000 		.word	.L157
 2257 129c 70170000 		.word	.L164
 2258 12a0 E8150000 		.word	.L157
 2259 12a4 B8150000 		.word	.L165
 2260 12a8 E8150000 		.word	.L157
 2261 12ac E8150000 		.word	.L157
 2262 12b0 E8150000 		.word	.L157
 2263 12b4 E8150000 		.word	.L157
 2264 12b8 98170000 		.word	.L166
 2265 12bc E8150000 		.word	.L157
 2266 12c0 E8150000 		.word	.L157
 2267 12c4 E8150000 		.word	.L157
 2268 12c8 E8150000 		.word	.L157
 2269 12cc E8150000 		.word	.L157
 2270 12d0 E8150000 		.word	.L157
 2271 12d4 E8150000 		.word	.L157
 2272 12d8 E8150000 		.word	.L157
 2273 12dc 18160000 		.word	.L167
 2274 12e0 D8160000 		.word	.L160
 2275 12e4 00170000 		.word	.L168
 2276 12e8 5C150000 		.word	.L169
 2277 12ec E8150000 		.word	.L157
 2278 12f0 E8150000 		.word	.L157
 2279 12f4 30140000 		.word	.L170
 2280 12f8 E8150000 		.word	.L157
 2281 12fc E8150000 		.word	.L157
 2282 1300 E8150000 		.word	.L157
 2283 1304 E8150000 		.word	.L157
 2284 1308 CC140000 		.word	.L171
 2285 130c 30150000 		.word	.L172
 2286 1310 0C150000 		.word	.L173
 2287              	.L314:
1236:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2288              		.loc 1 1236 0
 2289 1314 230054E3 		cmp	r4, #35
 2290 1318 3100009A 		bls	.L230
1237:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2291              		.loc 1 1237 0
 2292 131c 87A087E0 		add	sl, r7, r7, asl #1
 2293 1320 8A6186E0 		add	r6, r6, sl, asl #3
 2294 1324 149C9FE5 		ldr	r9, .L325+76
 2295 1328 0BC0D6E5 		ldrb	ip, [r6, #11]	@ zero_extendqisi2
1238:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2296              		.loc 1 1238 0
 2297 132c 0C10D6E5 		ldrb	r1, [r6, #12]	@ zero_extendqisi2
1237:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2298              		.loc 1 1237 0
 2299 1330 1CC1C9E5 		strb	ip, [r9, #284]
1238:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2300              		.loc 1 1238 0
 2301 1334 1D11C9E5 		strb	r1, [r9, #285]
 2302 1338 6CFFFFEA 		b	.L231
 2303              	.L153:
1225:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2304              		.loc 1 1225 0
 2305 133c 230054E3 		cmp	r4, #35
1226:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2306              		.loc 1 1226 0
 2307 1340 87708780 		addhi	r7, r7, r7, asl #1
 2308              	.LVL167:
1229:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2309              		.loc 1 1229 0
 2310 1344 84408490 		addls	r4, r4, r4, asl #1
1226:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2311              		.loc 1 1226 0
 2312 1348 87618680 		addhi	r6, r6, r7, asl #3
1229:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2313              		.loc 1 1229 0
 2314 134c 84618690 		addls	r6, r6, r4, asl #3
1226:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2315              		.loc 1 1226 0
 2316 1350 E88B9F85 		ldrhi	r8, .L325+76
1229:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2317              		.loc 1 1229 0
 2318 1354 E48B9F95 		ldrls	r8, .L325+76
1226:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2319              		.loc 1 1226 0
 2320 1358 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
1229:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2321              		.loc 1 1229 0
 2322 135c 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
1234:../uvc.c      **** 			  break;
 2323              		.loc 1 1234 0
 2324 1360 FFA0A0E3 		mov	sl, #255
1229:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2325              		.loc 1 1229 0
 2326 1364 1C31C8E5 		strb	r3, [r8, #284]
1231:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2327              		.loc 1 1231 0
 2328 1368 0100A0E3 		mov	r0, #1
 2329              	.LVL168:
 2330 136c 881B9FE5 		ldr	r1, .L325+8
 2331 1370 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2332              	.LVL169:
1234:../uvc.c      **** 			  break;
 2333              		.loc 1 1234 0
 2334 1374 0A40A0E1 		mov	r4, sl
1231:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2335              		.loc 1 1231 0
 2336 1378 1C71D8E5 		ldrb	r7, [r8, #284]	@ zero_extendqisi2
1234:../uvc.c      **** 			  break;
 2337              		.loc 1 1234 0
 2338 137c 0A80A0E1 		mov	r8, sl
 2339 1380 31FFFFEA 		b	.L156
 2340              	.LVL170:
 2341              	.L220:
1177:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2342              		.loc 1 1177 0
 2343 1384 0B0054E3 		cmp	r4, #11
1184:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2344              		.loc 1 1184 0
 2345 1388 84408410 		addne	r4, r4, r4, asl #1
 2346 138c 84618610 		addne	r6, r6, r4, asl #3
 2347 1390 A89B9F15 		ldrne	r9, .L325+76
1178:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2348              		.loc 1 1178 0
 2349 1394 A49B9F05 		ldreq	r9, .L325+76
 2350 1398 603B9F05 		ldreq	r3, .L325+12
1184:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2351              		.loc 1 1184 0
 2352 139c 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
1185:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2353              		.loc 1 1185 0
 2354 13a0 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
1178:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2355              		.loc 1 1178 0
 2356 13a4 1C318905 		streq	r3, [r9, #284]
1184:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2357              		.loc 1 1184 0
 2358 13a8 1C21C915 		strneb	r2, [r9, #284]
1185:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2359              		.loc 1 1185 0
 2360 13ac 1D31C915 		strneb	r3, [r9, #285]
 2361 13b0 4EFFFFEA 		b	.L231
 2362              	.L223:
1195:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2363              		.loc 1 1195 0
 2364 13b4 0B0054E3 		cmp	r4, #11
1202:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2365              		.loc 1 1202 0
 2366 13b8 84408410 		addne	r4, r4, r4, asl #1
 2367 13bc 84618610 		addne	r6, r6, r4, asl #3
 2368 13c0 789B9F15 		ldrne	r9, .L325+76
1196:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2369              		.loc 1 1196 0
 2370 13c4 749B9F05 		ldreq	r9, .L325+76
 2371 13c8 343B9F05 		ldreq	r3, .L325+16
1202:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2372              		.loc 1 1202 0
 2373 13cc 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
1203:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2374              		.loc 1 1203 0
 2375 13d0 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
1196:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2376              		.loc 1 1196 0
 2377 13d4 1C318905 		streq	r3, [r9, #284]
1202:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2378              		.loc 1 1202 0
 2379 13d8 1C21C915 		strneb	r2, [r9, #284]
1203:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2380              		.loc 1 1203 0
 2381 13dc 1D31C915 		strneb	r3, [r9, #285]
 2382 13e0 42FFFFEA 		b	.L231
 2383              	.L230:
1240:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2384              		.loc 1 1240 0
 2385 13e4 0B0054E3 		cmp	r4, #11
 2386 13e8 0700000A 		beq	.L317
1246:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2387              		.loc 1 1246 0
 2388 13ec 849084E0 		add	r9, r4, r4, asl #1
 2389 13f0 896186E0 		add	r6, r6, r9, asl #3
 2390 13f4 8B21D6E5 		ldrb	r2, [r6, #395]	@ zero_extendqisi2
 2391 13f8 409B9FE5 		ldr	r9, .L325+76
1247:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2392              		.loc 1 1247 0
 2393 13fc 8C31D6E5 		ldrb	r3, [r6, #396]	@ zero_extendqisi2
1246:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2394              		.loc 1 1246 0
 2395 1400 1C21C9E5 		strb	r2, [r9, #284]
1247:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2396              		.loc 1 1247 0
 2397 1404 1D31C9E5 		strb	r3, [r9, #285]
 2398 1408 38FFFFEA 		b	.L231
 2399              	.L317:
1241:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2400              		.loc 1 1241 0
 2401 140c 2C9B9FE5 		ldr	r9, .L325+76
 2402 1410 9302D6E5 		ldrb	r0, [r6, #659]	@ zero_extendqisi2
 2403              	.LVL171:
1243:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2404              		.loc 1 1243 0
 2405 1414 9472D6E5 		ldrb	r7, [r6, #660]	@ zero_extendqisi2
 2406              	.LVL172:
1242:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2407              		.loc 1 1242 0
 2408 1418 00E0A0E3 		mov	lr, #0
1241:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2409              		.loc 1 1241 0
 2410 141c 1C01C9E5 		strb	r0, [r9, #284]
1242:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2411              		.loc 1 1242 0
 2412 1420 1DE1C9E5 		strb	lr, [r9, #285]
1243:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2413              		.loc 1 1243 0
 2414 1424 1E71C9E5 		strb	r7, [r9, #286]
1244:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2415              		.loc 1 1244 0
 2416 1428 1FE1C9E5 		strb	lr, [r9, #287]
 2417 142c 2FFFFFEA 		b	.L231
 2418              	.LVL173:
 2419              	.L170:
 947:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2420              		.loc 1 947 0 discriminator 1
 2421 1430 000058E3 		cmp	r8, #0
 2422 1434 EC04000A 		beq	.L309
 945:../uvc.c      **** 					 break;
 2423              		.loc 1 945 0
 2424 1438 28E1A0E1 		mov	lr, r8, lsr #2
 2425 143c 00005EE3 		cmp	lr, #0
 2426 1440 03005813 		cmpne	r8, #3
 2427 1444 0020A083 		movhi	r2, #0
 2428 1448 0120A093 		movls	r2, #1
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2429              		.loc 1 791 0
 2430 144c 0E31A0E1 		mov	r3, lr, asl #2
 945:../uvc.c      **** 					 break;
 2431              		.loc 1 945 0
 2432 1450 F004009A 		bls	.L289
 2433 1454 A01A9FE5 		ldr	r1, .L325+8
 2434 1458 500041E2 		sub	r0, r1, #80
 2435              	.LVL174:
 2436              	.L193:
 948:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2437              		.loc 1 948 0 discriminator 2
 2438 145c 044090E4 		ldr	r4, [r0], #4
 2439 1460 01A082E2 		add	sl, r2, #1
 2440 1464 FF200AE2 		and	r2, sl, #255
 2441 1468 0E0052E1 		cmp	r2, lr
 2442 146c 044081E4 		str	r4, [r1], #4
 2443 1470 F9FFFF3A 		bcc	.L193
 948:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2444              		.loc 1 948 0 is_stmt 0
 2445 1474 030058E1 		cmp	r8, r3
 2446 1478 C00A9F15 		ldrne	r0, .L325+76
 2447 147c DA04000A 		beq	.L309
 2448              	.L302:
 2449 1480 03C080E0 		add	ip, r0, r3
 2450 1484 CCE0DCE5 		ldrb	lr, [ip, #204]	@ zero_extendqisi2
 947:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2451              		.loc 1 947 0 is_stmt 1
 2452 1488 013083E2 		add	r3, r3, #1
 2453 148c FF3003E2 		and	r3, r3, #255
 2454              	.LVL175:
 2455 1490 030058E1 		cmp	r8, r3
 948:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2456              		.loc 1 948 0
 2457 1494 1CE1CCE5 		strb	lr, [ip, #284]
 947:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2458              		.loc 1 947 0
 2459 1498 F8FFFF8A 		bhi	.L302
 2460              	.LVL176:
 2461              	.L176:
 957:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2462              		.loc 1 957 0
 2463 149c D710D0E5 		ldrb	r1, [r0, #215]	@ zero_extendqisi2
 950:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2464              		.loc 1 950 0
 2465 14a0 983A9FE5 		ldr	r3, .L325+76
 957:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2466              		.loc 1 957 0
 2467 14a4 FF0051E3 		cmp	r1, #255
 950:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2468              		.loc 1 950 0
 2469 14a8 2571D0E5 		ldrb	r7, [r0, #293]	@ zero_extendqisi2
 2470              	.LVL177:
 951:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 2471              		.loc 1 951 0
 2472 14ac 26A1D0E5 		ldrb	sl, [r0, #294]	@ zero_extendqisi2
 2473              	.LVL178:
 957:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2474              		.loc 1 957 0
 2475 14b0 0F00000A 		beq	.L179
 959:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 2476              		.loc 1 959 0
 2477 14b4 D520D3E5 		ldrb	r2, [r3, #213]	@ zero_extendqisi2
 2478 14b8 481A9FE5 		ldr	r1, .L325+20
 2479 14bc D630D3E5 		ldrb	r3, [r3, #214]	@ zero_extendqisi2
 2480 14c0 0400A0E3 		mov	r0, #4
 2481 14c4 FEFFFFEB 		bl	CyU3PDebugPrint
 2482 14c8 090000EA 		b	.L179
 2483              	.LVL179:
 2484              	.L171:
 836:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 2485              		.loc 1 836 0
 2486 14cc 6C4A9FE5 		ldr	r4, .L325+76
 2487 14d0 6001D4E5 		ldrb	r0, [r4, #352]	@ zero_extendqisi2
 2488              	.LVL180:
 2489 14d4 000050E3 		cmp	r0, #0
 2490 14d8 0004000A 		beq	.L177
 837:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2491              		.loc 1 837 0
 2492 14dc 9DC4D6E5 		ldrb	ip, [r6, #1181]	@ zero_extendqisi2
 838:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2493              		.loc 1 838 0
 2494 14e0 9E14D6E5 		ldrb	r1, [r6, #1182]	@ zero_extendqisi2
 837:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2495              		.loc 1 837 0
 2496 14e4 FF700CE2 		and	r7, ip, #255
 2497              	.LVL181:
 838:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2498              		.loc 1 838 0
 2499 14e8 FFA001E2 		and	sl, r1, #255
 837:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2500              		.loc 1 837 0
 2501 14ec 1C71C4E5 		strb	r7, [r4, #284]
 838:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2502              		.loc 1 838 0
 2503 14f0 1DA1C4E5 		strb	sl, [r4, #285]
 2504              	.LVL182:
 2505              	.L179:
1165:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2506              		.loc 1 1165 0
 2507 14f4 0800A0E1 		mov	r0, r8
 2508 14f8 FC199FE5 		ldr	r1, .L325+8
 2509 14fc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
1170:../uvc.c      **** 			  break;
 2510              		.loc 1 1170 0
 2511 1500 FF40A0E3 		mov	r4, #255
 2512 1504 0480A0E1 		mov	r8, r4
 2513 1508 CFFEFFEA 		b	.L156
 2514              	.LVL183:
 2515              	.L173:
 869:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 2516              		.loc 1 869 0
 2517 150c 2C4A9FE5 		ldr	r4, .L325+76
 2518 1510 62B1D4E5 		ldrb	fp, [r4, #354]	@ zero_extendqisi2
 2519 1514 00005BE3 		cmp	fp, #0
 2520 1518 FF03000A 		beq	.L182
 870:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 2521              		.loc 1 870 0
 2522 151c 9D70D6E5 		ldrb	r7, [r6, #157]	@ zero_extendqisi2
 2523              	.LVL184:
 871:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 2524              		.loc 1 871 0
 2525 1520 9EA0D6E5 		ldrb	sl, [r6, #158]	@ zero_extendqisi2
 870:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 2526              		.loc 1 870 0
 2527 1524 1C71C4E5 		strb	r7, [r4, #284]
 871:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 2528              		.loc 1 871 0
 2529 1528 1DA1C4E5 		strb	sl, [r4, #285]
 2530 152c F0FFFFEA 		b	.L179
 2531              	.LVL185:
 2532              	.L172:
 851:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 2533              		.loc 1 851 0
 2534 1530 084A9FE5 		ldr	r4, .L325+76
 2535 1534 61E1D4E5 		ldrb	lr, [r4, #353]	@ zero_extendqisi2
 2536 1538 00005EE3 		cmp	lr, #0
 2537 153c 2704000A 		beq	.L180
 852:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2538              		.loc 1 852 0
 2539 1540 B1A4D6E5 		ldrb	sl, [r6, #1201]	@ zero_extendqisi2
 853:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2540              		.loc 1 853 0
 2541 1544 B224D6E5 		ldrb	r2, [r6, #1202]	@ zero_extendqisi2
 852:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2542              		.loc 1 852 0
 2543 1548 FF700AE2 		and	r7, sl, #255
 2544              	.LVL186:
 853:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2545              		.loc 1 853 0
 2546 154c FFA002E2 		and	sl, r2, #255
 852:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2547              		.loc 1 852 0
 2548 1550 1C71C4E5 		strb	r7, [r4, #284]
 853:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2549              		.loc 1 853 0
 2550 1554 1DA1C4E5 		strb	sl, [r4, #285]
 2551 1558 E5FFFFEA 		b	.L179
 2552              	.LVL187:
 2553              	.L169:
 934:../uvc.c      **** 					 if(CamMode == 1){//720p
 2554              		.loc 1 934 0
 2555 155c DC499FE5 		ldr	r4, .L325+76
 932:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 2556              		.loc 1 932 0
 2557 1560 2D74D6E5 		ldrb	r7, [r6, #1069]	@ zero_extendqisi2
 2558              	.LVL188:
 934:../uvc.c      **** 					 if(CamMode == 1){//720p
 2559              		.loc 1 934 0
 2560 1564 7C21D4E5 		ldrb	r2, [r4, #380]	@ zero_extendqisi2
 2561 1568 010052E3 		cmp	r2, #1
 2562 156c 9004000A 		beq	.L318
 2563              	.LVL189:
 2564              	.L310:
1034:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2565              		.loc 1 1034 0
 2566 1570 0030A0E3 		mov	r3, #0
1033:../uvc.c      **** 					 glEp0Buffer[0] = Data0 + GREEN_BASE;
 2567              		.loc 1 1033 0
 2568 1574 1C71C4E5 		strb	r7, [r4, #284]
1034:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2569              		.loc 1 1034 0
 2570 1578 1D31C4E5 		strb	r3, [r4, #285]
 2571              	.LVL190:
 809:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2572              		.loc 1 809 0
 2573 157c FFA0A0E3 		mov	sl, #255
1036:../uvc.c      **** 					 break;
 2574              		.loc 1 1036 0
 2575 1580 DBFFFFEA 		b	.L179
 2576              	.LVL191:
 2577              	.L161:
1124:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2578              		.loc 1 1124 0
 2579 1584 B4499FE5 		ldr	r4, .L325+76
 2580 1588 40E1D4E5 		ldrb	lr, [r4, #320]	@ zero_extendqisi2
 2581 158c 00005EE3 		cmp	lr, #0
 2582 1590 4304000A 		beq	.L214
1126:../uvc.c      **** 		 	 			 if(is60Hz)
 2583              		.loc 1 1126 0
 2584 1594 D8C094E5 		ldr	ip, [r4, #216]
1132:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2585              		.loc 1 1132 0
 2586 1598 EEA1D6E5 		ldrb	sl, [r6, #494]	@ zero_extendqisi2
1126:../uvc.c      **** 		 	 			 if(is60Hz)
 2587              		.loc 1 1126 0
 2588 159c 00005CE3 		cmp	ip, #0
1127:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
 2589              		.loc 1 1127 0
 2590 15a0 02C0A013 		movne	ip, #2
1129:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 1;
 2591              		.loc 1 1129 0
 2592 15a4 01C0A003 		moveq	ip, #1
 2593 15a8 1CC1C4E5 		strb	ip, [r4, #284]
1132:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2594              		.loc 1 1132 0
 2595 15ac 1DA1C4E5 		strb	sl, [r4, #285]
 2596 15b0 1C71D4E5 		ldrb	r7, [r4, #284]	@ zero_extendqisi2
 2597              	.LVL192:
 2598 15b4 CEFFFFEA 		b	.L179
 2599              	.LVL193:
 2600              	.L165:
1042:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2601              		.loc 1 1042 0
 2602 15b8 80499FE5 		ldr	r4, .L325+76
 2603 15bc 4721D4E5 		ldrb	r2, [r4, #327]	@ zero_extendqisi2
 2604 15c0 000052E3 		cmp	r2, #0
 2605 15c4 B603000A 		beq	.L204
1043:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2606              		.loc 1 1043 0
 2607 15c8 F474D6E5 		ldrb	r7, [r6, #1268]	@ zero_extendqisi2
 2608              	.LVL194:
1044:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2609              		.loc 1 1044 0
 2610 15cc F6A4D6E5 		ldrb	sl, [r6, #1270]	@ zero_extendqisi2
1043:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2611              		.loc 1 1043 0
 2612 15d0 1C71C4E5 		strb	r7, [r4, #284]
1044:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2613              		.loc 1 1044 0
 2614 15d4 1EA1C4E5 		strb	sl, [r4, #286]
 2615              	.LVL195:
 2616              	.L205:
1054:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2617              		.loc 1 1054 0
 2618 15d8 00E0A0E3 		mov	lr, #0
 2619 15dc 1DE1C4E5 		strb	lr, [r4, #285]
1055:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2620              		.loc 1 1055 0
 2621 15e0 1FE1C4E5 		strb	lr, [r4, #287]
 2622              	.LVL196:
1058:../uvc.c      **** 					 break;
 2623              		.loc 1 1058 0
 2624 15e4 C2FFFFEA 		b	.L179
 2625              	.LVL197:
 2626              	.L157:
1149:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2627              		.loc 1 1149 0
 2628 15e8 50B99FE5 		ldr	fp, .L325+76
 2629 15ec 04308BE0 		add	r3, fp, r4
 2630 15f0 3C21D3E5 		ldrb	r2, [r3, #316]	@ zero_extendqisi2
 2631 15f4 000052E3 		cmp	r2, #0
 2632 15f8 0F04000A 		beq	.L218
1150:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 2633              		.loc 1 1150 0
 2634 15fc 844084E0 		add	r4, r4, r4, asl #1
 2635 1600 846186E0 		add	r6, r6, r4, asl #3
 2636 1604 8D71D6E5 		ldrb	r7, [r6, #397]	@ zero_extendqisi2
 2637              	.LVL198:
1151:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2638              		.loc 1 1151 0
 2639 1608 8EA1D6E5 		ldrb	sl, [r6, #398]	@ zero_extendqisi2
1150:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 2640              		.loc 1 1150 0
 2641 160c 1C71CBE5 		strb	r7, [fp, #284]
1151:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2642              		.loc 1 1151 0
 2643 1610 1DA1CBE5 		strb	sl, [fp, #285]
 2644 1614 B6FFFFEA 		b	.L179
 2645              	.LVL199:
 2646              	.L167:
 969:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2647              		.loc 1 969 0
 2648 1618 20499FE5 		ldr	r4, .L325+76
 963:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2649              		.loc 1 963 0
 2650 161c E004D6E5 		ldrb	r0, [r6, #1248]	@ zero_extendqisi2
 2651              	.LVL200:
 969:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2652              		.loc 1 969 0
 2653 1620 55A1D4E5 		ldrb	sl, [r4, #341]	@ zero_extendqisi2
 964:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2654              		.loc 1 964 0
 2655 1624 E174D6E5 		ldrb	r7, [r6, #1249]	@ zero_extendqisi2
 2656              	.LVL201:
 965:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2657              		.loc 1 965 0
 2658 1628 EF24D6E5 		ldrb	r2, [r6, #1263]	@ zero_extendqisi2
 969:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2659              		.loc 1 969 0
 2660 162c 00005AE3 		cmp	sl, #0
 963:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2661              		.loc 1 963 0
 2662 1630 04699FE5 		ldr	r6, .L325+72
 964:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2663              		.loc 1 964 0
 2664 1634 FFA007E2 		and	sl, r7, #255
 963:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2665              		.loc 1 963 0
 2666 1638 FF0000E2 		and	r0, r0, #255
 2667              	.LVL202:
 965:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2668              		.loc 1 965 0
 2669 163c FF7002E2 		and	r7, r2, #255
 2670              	.LVL203:
 969:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2671              		.loc 1 969 0
 2672 1640 CF03000A 		beq	.L196
 970:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2673              		.loc 1 970 0
 2674 1644 EDC4D6E5 		ldrb	ip, [r6, #1261]	@ zero_extendqisi2
 971:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2675              		.loc 1 971 0
 2676 1648 EEE4D6E5 		ldrb	lr, [r6, #1262]	@ zero_extendqisi2
 970:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2677              		.loc 1 970 0
 2678 164c 1CC1C4E5 		strb	ip, [r4, #284]
 971:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2679              		.loc 1 971 0
 2680 1650 1EE1C4E5 		strb	lr, [r4, #286]
 2681              	.LVL204:
 2682              	.L197:
 988:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2683              		.loc 1 988 0
 2684 1654 1C71D4E5 		ldrb	r7, [r4, #284]	@ zero_extendqisi2
 2685              	.LVL205:
 989:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 2686              		.loc 1 989 0
 2687 1658 1EA1D4E5 		ldrb	sl, [r4, #286]	@ zero_extendqisi2
 2688              	.LVL206:
 985:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2689              		.loc 1 985 0
 2690 165c 00E0A0E3 		mov	lr, #0
 2691 1660 1DE1C4E5 		strb	lr, [r4, #285]
 987:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2692              		.loc 1 987 0
 2693 1664 1FE1C4E5 		strb	lr, [r4, #287]
 990:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 2694              		.loc 1 990 0
 2695 1668 9C189FE5 		ldr	r1, .L325+24
 2696 166c 0720A0E1 		mov	r2, r7
 2697 1670 0E30A0E1 		mov	r3, lr
 2698 1674 0400A0E3 		mov	r0, #4
 2699 1678 00448DE8 		stmia	sp, {sl, lr}	@ phole stm
 2700 167c FEFFFFEB 		bl	CyU3PDebugPrint
 991:../uvc.c      **** 					 break;
 2701              		.loc 1 991 0
 2702 1680 9BFFFFEA 		b	.L179
 2703              	.LVL207:
 2704              	.L159:
1007:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2705              		.loc 1 1007 0
 2706 1684 B4489FE5 		ldr	r4, .L325+76
 2707 1688 3D11D4E5 		ldrb	r1, [r4, #317]	@ zero_extendqisi2
 2708 168c 000051E3 		cmp	r1, #0
1008:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 2709              		.loc 1 1008 0
 2710 1690 A501D615 		ldrneb	r0, [r6, #421]	@ zero_extendqisi2
 2711              	.LVL208:
1007:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2712              		.loc 1 1007 0
 2713 1694 1B04000A 		beq	.L319
 2714              	.LVL209:
 2715              	.L199:
1015:../uvc.c      **** 					  if(Data0&0x80){
 2716              		.loc 1 1015 0
 2717 1698 800010E3 		tst	r0, #128
1016:../uvc.c      **** 						  Data0 = ~Data0;
 2718              		.loc 1 1016 0
 2719 169c 0000E011 		mvnne	r0, r0
 2720              	.LVL210:
1018:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 2721              		.loc 1 1018 0
 2722 16a0 80004002 		subeq	r0, r0, #128
 2723 16a4 FF7000E2 		and	r7, r0, #255
 2724              	.LVL211:
 2725 16a8 B0FFFFEA 		b	.L310
 2726              	.LVL212:
 2727              	.L163:
1077:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2728              		.loc 1 1077 0
 2729 16ac 8C489FE5 		ldr	r4, .L325+76
 2730 16b0 4321D4E5 		ldrb	r2, [r4, #323]	@ zero_extendqisi2
 2731 16b4 000052E3 		cmp	r2, #0
 2732 16b8 A503000A 		beq	.L208
1078:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2733              		.loc 1 1078 0
 2734 16bc 19E5D6E5 		ldrb	lr, [r6, #1305]	@ zero_extendqisi2
1079:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2735              		.loc 1 1079 0
 2736 16c0 1A15D6E5 		ldrb	r1, [r6, #1306]	@ zero_extendqisi2
1078:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2737              		.loc 1 1078 0
 2738 16c4 FF700EE2 		and	r7, lr, #255
 2739              	.LVL213:
1079:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2740              		.loc 1 1079 0
 2741 16c8 FFA001E2 		and	sl, r1, #255
1078:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2742              		.loc 1 1078 0
 2743 16cc 1C71C4E5 		strb	r7, [r4, #284]
1079:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2744              		.loc 1 1079 0
 2745 16d0 1DA1C4E5 		strb	sl, [r4, #285]
 2746 16d4 86FFFFEA 		b	.L179
 2747              	.LVL214:
 2748              	.L160:
1094:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2749              		.loc 1 1094 0
 2750 16d8 60B89FE5 		ldr	fp, .L325+76
 2751 16dc 04408BE0 		add	r4, fp, r4
 2752 16e0 3C71D4E5 		ldrb	r7, [r4, #316]	@ zero_extendqisi2
 2753              	.LVL215:
 2754 16e4 000057E3 		cmp	r7, #0
 2755 16e8 C803000A 		beq	.L210
1095:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
 2756              		.loc 1 1095 0
 2757 16ec BD71D6E5 		ldrb	r7, [r6, #445]	@ zero_extendqisi2
1096:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 2758              		.loc 1 1096 0
 2759 16f0 BEA1D6E5 		ldrb	sl, [r6, #446]	@ zero_extendqisi2
1095:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
 2760              		.loc 1 1095 0
 2761 16f4 1C71CBE5 		strb	r7, [fp, #284]
1096:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 2762              		.loc 1 1096 0
 2763 16f8 1DA1CBE5 		strb	sl, [fp, #285]
 2764 16fc 7CFFFFEA 		b	.L179
 2765              	.LVL216:
 2766              	.L168:
 919:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2767              		.loc 1 919 0
 2768 1700 38489FE5 		ldr	r4, .L325+76
 912:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2769              		.loc 1 912 0
 2770 1704 CC34D6E5 		ldrb	r3, [r6, #1228]	@ zero_extendqisi2
 919:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2771              		.loc 1 919 0
 2772 1708 5721D4E5 		ldrb	r2, [r4, #343]	@ zero_extendqisi2
 913:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2773              		.loc 1 913 0
 2774 170c CDE4D6E5 		ldrb	lr, [r6, #1229]	@ zero_extendqisi2
 914:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2775              		.loc 1 914 0
 2776 1710 DB14D6E5 		ldrb	r1, [r6, #1243]	@ zero_extendqisi2
 919:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2777              		.loc 1 919 0
 2778 1714 000052E3 		cmp	r2, #0
 912:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2779              		.loc 1 912 0
 2780 1718 1C689FE5 		ldr	r6, .L325+72
 913:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2781              		.loc 1 913 0
 2782 171c FF000EE2 		and	r0, lr, #255
 2783              	.LVL217:
 914:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2784              		.loc 1 914 0
 2785 1720 FF1001E2 		and	r1, r1, #255
 2786              	.LVL218:
 919:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2787              		.loc 1 919 0
 2788 1724 A303000A 		beq	.L188
 920:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2789              		.loc 1 920 0
 2790 1728 D9A4D6E5 		ldrb	sl, [r6, #1241]	@ zero_extendqisi2
 921:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2791              		.loc 1 921 0
 2792 172c DA34D6E5 		ldrb	r3, [r6, #1242]	@ zero_extendqisi2
 920:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2793              		.loc 1 920 0
 2794 1730 FF700AE2 		and	r7, sl, #255
 2795              	.LVL219:
 921:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2796              		.loc 1 921 0
 2797 1734 FFA003E2 		and	sl, r3, #255
 920:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2798              		.loc 1 920 0
 2799 1738 1C71C4E5 		strb	r7, [r4, #284]
 921:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2800              		.loc 1 921 0
 2801 173c 1DA1C4E5 		strb	sl, [r4, #285]
 2802 1740 6BFFFFEA 		b	.L179
 2803              	.LVL220:
 2804              	.L158:
1060:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2805              		.loc 1 1060 0
 2806 1744 F4479FE5 		ldr	r4, .L325+76
 2807 1748 3C71D4E5 		ldrb	r7, [r4, #316]	@ zero_extendqisi2
 2808              	.LVL221:
 2809 174c 000057E3 		cmp	r7, #0
 2810 1750 E003000A 		beq	.L206
1061:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2811              		.loc 1 1061 0
 2812 1754 05A5D6E5 		ldrb	sl, [r6, #1285]	@ zero_extendqisi2
1062:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2813              		.loc 1 1062 0
 2814 1758 06C5D6E5 		ldrb	ip, [r6, #1286]	@ zero_extendqisi2
1061:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2815              		.loc 1 1061 0
 2816 175c FF700AE2 		and	r7, sl, #255
1062:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2817              		.loc 1 1062 0
 2818 1760 FFA00CE2 		and	sl, ip, #255
1061:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2819              		.loc 1 1061 0
 2820 1764 1C71C4E5 		strb	r7, [r4, #284]
1062:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2821              		.loc 1 1062 0
 2822 1768 1DA1C4E5 		strb	sl, [r4, #285]
 2823 176c 60FFFFEA 		b	.L179
 2824              	.LVL222:
 2825              	.L164:
1107:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2826              		.loc 1 1107 0
 2827 1770 C8479FE5 		ldr	r4, .L325+76
 2828 1774 4531D4E5 		ldrb	r3, [r4, #325]	@ zero_extendqisi2
 2829 1778 000053E3 		cmp	r3, #0
 2830 177c BD03000A 		beq	.L212
1109:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 2831              		.loc 1 1109 0
 2832 1780 6522D6E5 		ldrb	r2, [r6, #613]	@ zero_extendqisi2
1110:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2833              		.loc 1 1110 0
 2834 1784 66A2D6E5 		ldrb	sl, [r6, #614]	@ zero_extendqisi2
1109:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 2835              		.loc 1 1109 0
 2836 1788 037002E2 		and	r7, r2, #3
 2837              	.LVL223:
 2838 178c 1C71C4E5 		strb	r7, [r4, #284]
1110:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2839              		.loc 1 1110 0
 2840 1790 1DA1C4E5 		strb	sl, [r4, #285]
 2841 1794 56FFFFEA 		b	.L179
 2842              	.LVL224:
 2843              	.L166:
 894:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2844              		.loc 1 894 0
 2845 1798 A0479FE5 		ldr	r4, .L325+76
 887:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2846              		.loc 1 887 0
 2847 179c B8E4D6E5 		ldrb	lr, [r6, #1208]	@ zero_extendqisi2
 894:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2848              		.loc 1 894 0
 2849 17a0 4C21D4E5 		ldrb	r2, [r4, #332]	@ zero_extendqisi2
 888:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2850              		.loc 1 888 0
 2851 17a4 B934D6E5 		ldrb	r3, [r6, #1209]	@ zero_extendqisi2
 889:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2852              		.loc 1 889 0
 2853 17a8 C774D6E5 		ldrb	r7, [r6, #1223]	@ zero_extendqisi2
 2854              	.LVL225:
 894:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2855              		.loc 1 894 0
 2856 17ac 000052E3 		cmp	r2, #0
 887:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2857              		.loc 1 887 0
 2858 17b0 84679FE5 		ldr	r6, .L325+72
 2859 17b4 FF000EE2 		and	r0, lr, #255
 2860              	.LVL226:
 889:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2861              		.loc 1 889 0
 2862 17b8 FF1007E2 		and	r1, r7, #255
 2863              	.LVL227:
 894:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2864              		.loc 1 894 0
 2865 17bc D803000A 		beq	.L186
 895:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2866              		.loc 1 895 0
 2867 17c0 C5A4D6E5 		ldrb	sl, [r6, #1221]	@ zero_extendqisi2
 896:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2868              		.loc 1 896 0
 2869 17c4 C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
 895:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2870              		.loc 1 895 0
 2871 17c8 FF700AE2 		and	r7, sl, #255
 2872 17cc 1C71C4E5 		strb	r7, [r4, #284]
 896:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2873              		.loc 1 896 0
 2874 17d0 1D31C4E5 		strb	r3, [r4, #285]
 2875              	.LVL228:
 2876              	.L187:
 909:../uvc.c      **** 					 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, send
 2877              		.loc 1 909 0
 2878 17d4 34179FE5 		ldr	r1, .L325+28
 2879 17d8 0720A0E1 		mov	r2, r7
 2880 17dc 0730A0E1 		mov	r3, r7
 2881 17e0 0400A0E3 		mov	r0, #4
 2882 17e4 00C08DE5 		str	ip, [sp, #0]
 908:../uvc.c      **** 					 sendData1 = Data1;//glEp0Buffer[1];
 2883              		.loc 1 908 0
 2884 17e8 0CA0A0E1 		mov	sl, ip
 909:../uvc.c      **** 					 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, send
 2885              		.loc 1 909 0
 2886 17ec FEFFFFEB 		bl	CyU3PDebugPrint
 2887              	.LVL229:
 910:../uvc.c      **** 			 		 break;
 2888              		.loc 1 910 0
 2889 17f0 3FFFFFEA 		b	.L179
 2890              	.LVL230:
 2891              	.L162:
1025:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2892              		.loc 1 1025 0
 2893 17f4 44479FE5 		ldr	r4, .L325+76
 2894 17f8 41C1D4E5 		ldrb	ip, [r4, #321]	@ zero_extendqisi2
 2895 17fc 00005CE3 		cmp	ip, #0
1026:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 2896              		.loc 1 1026 0
 2897 1800 0502D615 		ldrneb	r0, [r6, #517]	@ zero_extendqisi2
 2898              	.LVL231:
1025:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2899              		.loc 1 1025 0
 2900 1804 B002000A 		beq	.L320
 2901              	.L203:
 2902              	.LVL232:
1033:../uvc.c      **** 					 glEp0Buffer[0] = Data0 + GREEN_BASE;
 2903              		.loc 1 1033 0
 2904 1808 800040E2 		sub	r0, r0, #128
 2905              	.LVL233:
 2906 180c FF7000E2 		and	r7, r0, #255
 2907              	.LVL234:
 2908 1810 56FFFFEA 		b	.L310
 2909              	.LVL235:
 2910              	.L248:
1416:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2911              		.loc 1 1416 0 discriminator 1
 2912 1814 000058E3 		cmp	r8, #0
 2913 1818 1800000A 		beq	.L254
1414:../uvc.c      **** 							 break;
 2914              		.loc 1 1414 0
 2915 181c 28E1A0E1 		mov	lr, r8, lsr #2
 2916 1820 00005EE3 		cmp	lr, #0
 2917 1824 03005813 		cmpne	r8, #3
 2918 1828 0020A083 		movhi	r2, #0
 2919 182c 0120A093 		movls	r2, #1
 2920              	.LVL236:
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2921              		.loc 1 791 0
 2922 1830 0E31A0E1 		mov	r3, lr, asl #2
1414:../uvc.c      **** 							 break;
 2923              		.loc 1 1414 0
 2924 1834 FA03009A 		bls	.L291
 2925 1838 D4169FE5 		ldr	r1, .L325+32
 2926 183c 500081E2 		add	r0, r1, #80
 2927              	.LVL237:
 2928              	.L264:
1417:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2929              		.loc 1 1417 0 discriminator 2
 2930 1840 047090E4 		ldr	r7, [r0], #4
 2931 1844 012082E2 		add	r2, r2, #1
 2932 1848 FF2002E2 		and	r2, r2, #255
 2933 184c 02005EE1 		cmp	lr, r2
 2934 1850 047081E4 		str	r7, [r1], #4
 2935 1854 F9FFFF8A 		bhi	.L264
1417:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2936              		.loc 1 1417 0 is_stmt 0
 2937 1858 030058E1 		cmp	r8, r3
 2938 185c 0700000A 		beq	.L254
 2939              	.L303:
 2940 1860 D8069FE5 		ldr	r0, .L325+76
 2941 1864 03E080E0 		add	lr, r0, r3
 2942 1868 1C11DEE5 		ldrb	r1, [lr, #284]	@ zero_extendqisi2
1416:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2943              		.loc 1 1416 0 is_stmt 1
 2944 186c 013083E2 		add	r3, r3, #1
 2945 1870 FF3003E2 		and	r3, r3, #255
 2946              	.LVL238:
 2947 1874 030058E1 		cmp	r8, r3
1417:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2948              		.loc 1 1417 0
 2949 1878 CC10CEE5 		strb	r1, [lr, #204]
1416:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2950              		.loc 1 1416 0
 2951 187c F7FFFF8A 		bhi	.L303
 2952              	.LVL239:
 2953              	.L254:
1420:../uvc.c      **** 							 break;
 2954              		.loc 1 1420 0
 2955 1880 FFA0A0E3 		mov	sl, #255
1419:../uvc.c      **** 					 		I2CCmdHandler();
 2956              		.loc 1 1419 0
 2957 1884 FEFFFFEB 		bl	I2CCmdHandler
 2958              	.LVL240:
1420:../uvc.c      **** 							 break;
 2959              		.loc 1 1420 0
 2960 1888 0A70A0E1 		mov	r7, sl
1419:../uvc.c      **** 					 		I2CCmdHandler();
 2961              		.loc 1 1419 0
 2962 188c 18809DE5 		ldr	r8, [sp, #24]
 2963 1890 1C409DE5 		ldr	r4, [sp, #28]
1420:../uvc.c      **** 							 break;
 2964              		.loc 1 1420 0
 2965 1894 ECFDFFEA 		b	.L156
 2966              	.LVL241:
 2967              	.L247:
1410:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2968              		.loc 1 1410 0
 2969 1898 94769FE5 		ldr	r7, .L325+64
 2970              	.LVL242:
 2971 189c 0010E0E3 		mvn	r1, #0
 2972 18a0 1C0097E5 		ldr	r0, [r7, #28]
 2973 18a4 FEFFFFEB 		bl	_txe_mutex_get
 2974              	.LVL243:
1411:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2975              		.loc 1 1411 0
 2976 18a8 0A20A0E1 		mov	r2, sl
 2977 18ac 18A09DE5 		ldr	sl, [sp, #24]
 2978 18b0 00C0A0E3 		mov	ip, #0
 2979 18b4 01407AE2 		rsbs	r4, sl, #1
 2980 18b8 0040A033 		movcc	r4, #0
 2981 18bc 1E10A0E3 		mov	r1, #30
 2982 18c0 0930A0E1 		mov	r3, r9
 2983 18c4 0700A0E1 		mov	r0, r7
 2984 18c8 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 2985 18cc FEFFFFEB 		bl	cmdSet
1412:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2986              		.loc 1 1412 0
 2987 18d0 1C0097E5 		ldr	r0, [r7, #28]
 2988 18d4 FEFFFFEB 		bl	_txe_mutex_put
1414:../uvc.c      **** 							 break;
 2989              		.loc 1 1414 0
 2990 18d8 FFA0A0E3 		mov	sl, #255
1413:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2991              		.loc 1 1413 0
 2992 18dc 0100A0E3 		mov	r0, #1
 2993 18e0 6004C6E5 		strb	r0, [r6, #1120]
 2994 18e4 18809DE5 		ldr	r8, [sp, #24]
 2995 18e8 1C409DE5 		ldr	r4, [sp, #28]
1414:../uvc.c      **** 							 break;
 2996              		.loc 1 1414 0
 2997 18ec 0A70A0E1 		mov	r7, sl
 2998 18f0 D5FDFFEA 		b	.L156
 2999              	.LVL244:
 3000              	.L246:
1388:../uvc.c      **** 							 if(Data0 <= 3){
 3001              		.loc 1 1388 0
 3002 18f4 030053E3 		cmp	r3, #3
1389:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 3003              		.loc 1 1389 0
 3004 18f8 40069F95 		ldrls	r0, .L325+76
 3005 18fc 03E0A0E1 		mov	lr, r3
 3006              	.LVL245:
 3007 1900 0030A093 		movls	r3, #0
 3008 1904 7C31C095 		strlsb	r3, [r0, #380]
 3009              	.LVL246:
1392:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 3010              		.loc 1 1392 0
 3011 1908 30C69F85 		ldrhi	ip, .L325+76
1389:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 3012              		.loc 1 1389 0
 3013 190c 0E30A091 		movls	r3, lr
1398:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3014              		.loc 1 1398 0
 3015 1910 1C469FE5 		ldr	r4, .L325+64
 3016 1914 18E09D95 		ldrls	lr, [sp, #24]
1393:../uvc.c      **** 								 Data1 = Data0-4;
 3017              		.loc 1 1393 0
 3018 1918 04304382 		subhi	r3, r3, #4
1392:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 3019              		.loc 1 1392 0
 3020 191c 0120A083 		movhi	r2, #1
 3021              	.LVL247:
1396:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 3022              		.loc 1 1396 0
 3023 1920 8D31C6E5 		strb	r3, [r6, #397]
1397:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3024              		.loc 1 1397 0
 3025 1924 0130A0E3 		mov	r3, #1
1392:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 3026              		.loc 1 1392 0
 3027 1928 7C21CC85 		strhib	r2, [ip, #380]
 3028              	.LVL248:
1398:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3029              		.loc 1 1398 0
 3030 192c 0010E0E3 		mvn	r1, #0
1395:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3031              		.loc 1 1395 0
 3032 1930 2DE4C6E5 		strb	lr, [r6, #1069]
1397:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3033              		.loc 1 1397 0
 3034 1934 3034C6E5 		strb	r3, [r6, #1072]
1398:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3035              		.loc 1 1398 0
 3036 1938 1C0094E5 		ldr	r0, [r4, #28]
 3037 193c FEFFFFEB 		bl	_txe_mutex_get
1399:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3038              		.loc 1 1399 0
 3039 1940 18809DE5 		ldr	r8, [sp, #24]
 3040 1944 0A20A0E1 		mov	r2, sl
 3041 1948 1C10A0E3 		mov	r1, #28
 3042 194c 0930A0E1 		mov	r3, r9
 3043 1950 0400A0E1 		mov	r0, r4
 3044 1954 00A0A0E3 		mov	sl, #0
 3045 1958 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3046 195c FEFFFFEB 		bl	cmdSet
1400:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3047              		.loc 1 1400 0
 3048 1960 1C0094E5 		ldr	r0, [r4, #28]
 3049              	.LVL249:
 3050              	.L312:
1666:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3051              		.loc 1 1666 0
 3052 1964 FFA0A0E3 		mov	sl, #255
 3053 1968 FEFFFFEB 		bl	_txe_mutex_put
 3054 196c 0A70A0E1 		mov	r7, sl
 3055 1970 18809DE5 		ldr	r8, [sp, #24]
 3056 1974 1C409DE5 		ldr	r4, [sp, #28]
 3057 1978 B3FDFFEA 		b	.L156
 3058              	.LVL250:
 3059              	.L245:
1365:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3060              		.loc 1 1365 0
 3061 197c B0459FE5 		ldr	r4, .L325+64
1361:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3062              		.loc 1 1361 0
 3063 1980 CC34D6E5 		ldrb	r3, [r6, #1228]	@ zero_extendqisi2
1362:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3064              		.loc 1 1362 0
 3065 1984 CD74D6E5 		ldrb	r7, [r6, #1229]	@ zero_extendqisi2
 3066              	.LVL251:
1363:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 3067              		.loc 1 1363 0
 3068 1988 DBE4D6E5 		ldrb	lr, [r6, #1243]	@ zero_extendqisi2
1365:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3069              		.loc 1 1365 0
 3070 198c 0010E0E3 		mvn	r1, #0
 3071 1990 1C0094E5 		ldr	r0, [r4, #28]
1361:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3072              		.loc 1 1361 0
 3073 1994 FFA003E2 		and	sl, r3, #255
 3074              	.LVL252:
1362:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3075              		.loc 1 1362 0
 3076 1998 FF8007E2 		and	r8, r7, #255
 3077              	.LVL253:
1363:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 3078              		.loc 1 1363 0
 3079 199c FF700EE2 		and	r7, lr, #255
 3080              	.LVL254:
1365:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3081              		.loc 1 1365 0
 3082 19a0 FEFFFFEB 		bl	_txe_mutex_get
 3083              	.LVL255:
1373:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 3084              		.loc 1 1373 0
 3085 19a4 D904D6E5 		ldrb	r0, [r6, #1241]	@ zero_extendqisi2
 3086 19a8 18109DE5 		ldr	r1, [sp, #24]
1361:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3087              		.loc 1 1361 0
 3088 19ac 88359FE5 		ldr	r3, .L325+72
1373:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 3089              		.loc 1 1373 0
 3090 19b0 000051E1 		cmp	r1, r0
 3091 19b4 0600000A 		beq	.L259
1374:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 3092              		.loc 1 1374 0
 3093 19b8 D914C3E5 		strb	r1, [r3, #1241]
1375:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 3094              		.loc 1 1375 0
 3095 19bc ED24D3E5 		ldrb	r2, [r3, #1261]	@ zero_extendqisi2
 3096 19c0 010052E3 		cmp	r2, #1
 3097 19c4 6803000A 		beq	.L260
1375:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 3098              		.loc 1 1375 0 is_stmt 0 discriminator 1
 3099 19c8 ED14D3E5 		ldrb	r1, [r3, #1261]	@ zero_extendqisi2
 3100 19cc 030051E3 		cmp	r1, #3
 3101 19d0 6503000A 		beq	.L260
 3102              	.LVL256:
 3103              	.L259:
1382:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3104              		.loc 1 1382 0 is_stmt 1
 3105 19d4 1C0094E5 		ldr	r0, [r4, #28]
 3106 19d8 FEFFFFEB 		bl	_txe_mutex_put
1384:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3107              		.loc 1 1384 0
 3108 19dc ED24D6E5 		ldrb	r2, [r6, #1261]	@ zero_extendqisi2
1383:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3109              		.loc 1 1383 0
 3110 19e0 18809DE5 		ldr	r8, [sp, #24]
1384:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3111              		.loc 1 1384 0
 3112 19e4 EE34D6E5 		ldrb	r3, [r6, #1262]	@ zero_extendqisi2
1383:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3113              		.loc 1 1383 0
 3114 19e8 1C409DE5 		ldr	r4, [sp, #28]
1384:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3115              		.loc 1 1384 0
 3116 19ec D974D6E5 		ldrb	r7, [r6, #1241]	@ zero_extendqisi2
 3117              	.LVL257:
1383:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3118              		.loc 1 1383 0
 3119 19f0 0400A0E3 		mov	r0, #4
 3120 19f4 1C159FE5 		ldr	r1, .L325+36
1385:../uvc.c      **** 							 break;
 3121              		.loc 1 1385 0
 3122 19f8 FFA0A0E3 		mov	sl, #255
1383:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3123              		.loc 1 1383 0
 3124 19fc 80018DE8 		stmia	sp, {r7, r8}	@ phole stm
 3125 1a00 08408DE5 		str	r4, [sp, #8]
1385:../uvc.c      **** 							 break;
 3126              		.loc 1 1385 0
 3127 1a04 0A70A0E1 		mov	r7, sl
1383:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3128              		.loc 1 1383 0
 3129 1a08 FEFFFFEB 		bl	CyU3PDebugPrint
1385:../uvc.c      **** 							 break;
 3130              		.loc 1 1385 0
 3131 1a0c 8EFDFFEA 		b	.L156
 3132              	.LVL258:
 3133              	.L250:
1462:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3134              		.loc 1 1462 0
 3135 1a10 A4C4D6E5 		ldrb	ip, [r6, #1188]	@ zero_extendqisi2
 3136              	.LVL259:
1467:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3137              		.loc 1 1467 0
 3138 1a14 18A59FE5 		ldr	sl, .L325+64
1463:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3139              		.loc 1 1463 0
 3140 1a18 A534D6E5 		ldrb	r3, [r6, #1189]	@ zero_extendqisi2
1464:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
 3141              		.loc 1 1464 0
 3142 1a1c B3E4D6E5 		ldrb	lr, [r6, #1203]	@ zero_extendqisi2
1462:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3143              		.loc 1 1462 0
 3144 1a20 FF800CE2 		and	r8, ip, #255
 3145              	.LVL260:
1467:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3146              		.loc 1 1467 0
 3147 1a24 0010E0E3 		mvn	r1, #0
 3148 1a28 1C009AE5 		ldr	r0, [sl, #28]
1464:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
 3149              		.loc 1 1464 0
 3150 1a2c FF400EE2 		and	r4, lr, #255
 3151              	.LVL261:
1467:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3152              		.loc 1 1467 0
 3153 1a30 FEFFFFEB 		bl	_txe_mutex_get
 3154              	.LVL262:
1468:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 3155              		.loc 1 1468 0
 3156 1a34 0820A0E1 		mov	r2, r8
 3157 1a38 18809DE5 		ldr	r8, [sp, #24]
 3158              	.LVL263:
 3159 1a3c 0430A0E1 		mov	r3, r4
 3160 1a40 2510A0E3 		mov	r1, #37
 3161 1a44 0A00A0E1 		mov	r0, sl
 3162 1a48 0070A0E3 		mov	r7, #0
 3163              	.LVL264:
 3164 1a4c 00808DE5 		str	r8, [sp, #0]
 3165 1a50 04708DE5 		str	r7, [sp, #4]
 3166 1a54 FEFFFFEB 		bl	cmdSet
 3167              	.LVL265:
1469:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3168              		.loc 1 1469 0
 3169 1a58 1C009AE5 		ldr	r0, [sl, #28]
 3170 1a5c FEFFFFEB 		bl	_txe_mutex_put
1470:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
 3171              		.loc 1 1470 0
 3172 1a60 18409DE5 		ldr	r4, [sp, #24]
 3173              	.LVL266:
1474:../uvc.c      **** 							 break;
 3174              		.loc 1 1474 0
 3175 1a64 FFA0A0E3 		mov	sl, #255
1471:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 3176              		.loc 1 1471 0
 3177 1a68 0100A0E3 		mov	r0, #1
1470:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
 3178              		.loc 1 1470 0
 3179 1a6c B144C6E5 		strb	r4, [r6, #1201]
1471:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 3180              		.loc 1 1471 0
 3181 1a70 0480A0E1 		mov	r8, r4
 3182 1a74 B504C6E5 		strb	r0, [r6, #1205]
 3183 1a78 1C409DE5 		ldr	r4, [sp, #28]
1474:../uvc.c      **** 							 break;
 3184              		.loc 1 1474 0
 3185 1a7c 0A70A0E1 		mov	r7, sl
 3186 1a80 71FDFFEA 		b	.L156
 3187              	.LVL267:
 3188              	.L249:
1422:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3189              		.loc 1 1422 0
 3190 1a84 9034D6E5 		ldrb	r3, [r6, #1168]	@ zero_extendqisi2
1449:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3191              		.loc 1 1449 0
 3192 1a88 A4449FE5 		ldr	r4, .L325+64
1423:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3193              		.loc 1 1423 0
 3194 1a8c 9124D6E5 		ldrb	r2, [r6, #1169]	@ zero_extendqisi2
 3195              	.LVL268:
1424:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 3196              		.loc 1 1424 0
 3197 1a90 9F14D6E5 		ldrb	r1, [r6, #1183]	@ zero_extendqisi2
1449:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3198              		.loc 1 1449 0
 3199 1a94 1C0094E5 		ldr	r0, [r4, #28]
1424:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 3200              		.loc 1 1424 0
 3201 1a98 FF7001E2 		and	r7, r1, #255
 3202              	.LVL269:
1449:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3203              		.loc 1 1449 0
 3204 1a9c 0010E0E3 		mvn	r1, #0
1422:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3205              		.loc 1 1422 0
 3206 1aa0 FF9003E2 		and	r9, r3, #255
 3207              	.LVL270:
1423:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3208              		.loc 1 1423 0
 3209 1aa4 FF8002E2 		and	r8, r2, #255
 3210              	.LVL271:
1449:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3211              		.loc 1 1449 0
 3212 1aa8 14C08DE5 		str	ip, [sp, #20]
 3213 1aac FEFFFFEB 		bl	_txe_mutex_get
 3214              	.LVL272:
1451:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 3215              		.loc 1 1451 0
 3216 1ab0 18C09DE5 		ldr	ip, [sp, #24]
 3217 1ab4 00E0A0E3 		mov	lr, #0
 3218 1ab8 0920A0E1 		mov	r2, r9
 3219 1abc 0730A0E1 		mov	r3, r7
 3220 1ac0 2410A0E3 		mov	r1, #36
 3221 1ac4 0400A0E1 		mov	r0, r4
 3222 1ac8 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 3223 1acc FEFFFFEB 		bl	cmdSet
 3224              	.LVL273:
1453:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 3225              		.loc 1 1453 0
 3226 1ad0 14A09DE5 		ldr	sl, [sp, #20]
 3227 1ad4 0820A0E1 		mov	r2, r8
 3228 1ad8 0730A0E1 		mov	r3, r7
 3229 1adc 0190A0E3 		mov	r9, #1
 3230              	.LVL274:
 3231 1ae0 2410A0E3 		mov	r1, #36
 3232 1ae4 0400A0E1 		mov	r0, r4
 3233 1ae8 00A08DE5 		str	sl, [sp, #0]
 3234 1aec 04908DE5 		str	r9, [sp, #4]
 3235 1af0 FEFFFFEB 		bl	cmdSet
1454:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3236              		.loc 1 1454 0
 3237 1af4 1C0094E5 		ldr	r0, [r4, #28]
 3238 1af8 FEFFFFEB 		bl	_txe_mutex_put
 3239              	.LVL275:
1457:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
 3240              		.loc 1 1457 0
 3241 1afc 18809DE5 		ldr	r8, [sp, #24]
 3242              	.LVL276:
1460:../uvc.c      **** 							 break;
 3243              		.loc 1 1460 0
 3244 1b00 FFA0A0E3 		mov	sl, #255
1457:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
 3245              		.loc 1 1457 0
 3246 1b04 9D84C6E5 		strb	r8, [r6, #1181]
1458:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3247              		.loc 1 1458 0
 3248 1b08 14C09DE5 		ldr	ip, [sp, #20]
1460:../uvc.c      **** 							 break;
 3249              		.loc 1 1460 0
 3250 1b0c 0A70A0E1 		mov	r7, sl
 3251              	.LVL277:
1458:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3252              		.loc 1 1458 0
 3253 1b10 9EC4C6E5 		strb	ip, [r6, #1182]
1459:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3254              		.loc 1 1459 0
 3255 1b14 0C40A0E1 		mov	r4, ip
 3256 1b18 A194C6E5 		strb	r9, [r6, #1185]
1460:../uvc.c      **** 							 break;
 3257              		.loc 1 1460 0
 3258 1b1c 4AFDFFEA 		b	.L156
 3259              	.LVL278:
 3260              	.L251:
1477:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 3261              		.loc 1 1477 0
 3262 1b20 8780A0E1 		mov	r8, r7, asl #1
 3263 1b24 10B49FE5 		ldr	fp, .L325+72
 3264 1b28 07C088E0 		add	ip, r8, r7
 3265              	.LVL279:
 3266 1b2c 8CE186E0 		add	lr, r6, ip, asl #3
1483:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3267              		.loc 1 1483 0
 3268 1b30 FC439FE5 		ldr	r4, .L325+64
1477:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 3269              		.loc 1 1477 0
 3270 1b34 0D30CEE5 		strb	r3, [lr, #13]
1479:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3271              		.loc 1 1479 0
 3272 1b38 05B5DBE5 		ldrb	fp, [fp, #1285]	@ zero_extendqisi2
1478:../uvc.c      **** 							 if(Data0 == 1){
 3273              		.loc 1 1478 0
 3274 1b3c 010053E3 		cmp	r3, #1
1483:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3275              		.loc 1 1483 0
 3276 1b40 0010E0E3 		mvn	r1, #0
 3277 1b44 1C0094E5 		ldr	r0, [r4, #28]
1479:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3278              		.loc 1 1479 0
 3279 1b48 80B08B03 		orreq	fp, fp, #128
 3280              	.LVL280:
1481:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
 3281              		.loc 1 1481 0
 3282 1b4c 7FB00B12 		andne	fp, fp, #127
 3283              	.LVL281:
1483:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3284              		.loc 1 1483 0
 3285 1b50 FEFFFFEB 		bl	_txe_mutex_get
 3286              	.LVL282:
1484:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3287              		.loc 1 1484 0
 3288 1b54 0A20A0E1 		mov	r2, sl
 3289 1b58 2610A0E3 		mov	r1, #38
 3290 1b5c 0930A0E1 		mov	r3, r9
 3291 1b60 0400A0E1 		mov	r0, r4
 3292 1b64 00A0A0E3 		mov	sl, #0
 3293 1b68 04A08DE5 		str	sl, [sp, #4]
 3294 1b6c 00B08DE5 		str	fp, [sp, #0]
 3295 1b70 FEFFFFEB 		bl	cmdSet
1485:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3296              		.loc 1 1485 0
 3297 1b74 1C0094E5 		ldr	r0, [r4, #28]
 3298 1b78 FEFFFFEB 		bl	_txe_mutex_put
1487:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3299              		.loc 1 1487 0
 3300 1b7c 071088E0 		add	r1, r8, r7
 3301 1b80 816186E0 		add	r6, r6, r1, asl #3
1488:../uvc.c      **** 							 break;
 3302              		.loc 1 1488 0
 3303 1b84 FFA0A0E3 		mov	sl, #255
1487:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3304              		.loc 1 1487 0
 3305 1b88 0120A0E3 		mov	r2, #1
 3306 1b8c 1020C6E5 		strb	r2, [r6, #16]
 3307 1b90 18809DE5 		ldr	r8, [sp, #24]
 3308 1b94 1C409DE5 		ldr	r4, [sp, #28]
1488:../uvc.c      **** 							 break;
 3309              		.loc 1 1488 0
 3310 1b98 0A70A0E1 		mov	r7, sl
 3311              	.LVL283:
 3312 1b9c 2AFDFFEA 		b	.L156
 3313              	.LVL284:
 3314              	.L240:
1551:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3315              		.loc 1 1551 0
 3316 1ba0 8C439FE5 		ldr	r4, .L325+64
 3317 1ba4 0010E0E3 		mvn	r1, #0
 3318 1ba8 1C0094E5 		ldr	r0, [r4, #28]
 3319 1bac FEFFFFEB 		bl	_txe_mutex_get
 3320              	.LVL285:
1552:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3321              		.loc 1 1552 0
 3322 1bb0 18C09DE5 		ldr	ip, [sp, #24]
 3323 1bb4 00E0A0E3 		mov	lr, #0
 3324 1bb8 0A20A0E1 		mov	r2, sl
 3325 1bbc 0610A0E3 		mov	r1, #6
 3326 1bc0 0930A0E1 		mov	r3, r9
 3327 1bc4 0400A0E1 		mov	r0, r4
 3328 1bc8 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 3329 1bcc FEFFFFEB 		bl	cmdSet
 3330              	.LVL286:
1554:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 3331              		.loc 1 1554 0
 3332 1bd0 18A09DE5 		ldr	sl, [sp, #24]
 3333 1bd4 0170A0E3 		mov	r7, #1
 3334              	.LVL287:
 3335 1bd8 0610A0E3 		mov	r1, #6
 3336 1bdc 0B20A0E1 		mov	r2, fp
 3337 1be0 0930A0E1 		mov	r3, r9
 3338 1be4 0400A0E1 		mov	r0, r4
 3339 1be8 00A08DE5 		str	sl, [sp, #0]
 3340 1bec 04708DE5 		str	r7, [sp, #4]
 3341 1bf0 FEFFFFEB 		bl	cmdSet
1555:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3342              		.loc 1 1555 0
 3343 1bf4 1C0094E5 		ldr	r0, [r4, #28]
 3344 1bf8 FEFFFFEB 		bl	_txe_mutex_put
1556:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3345              		.loc 1 1556 0
 3346 1bfc 18809DE5 		ldr	r8, [sp, #24]
1558:../uvc.c      **** 							 break;
 3347              		.loc 1 1558 0
 3348 1c00 FFA0A0E3 		mov	sl, #255
1557:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3349              		.loc 1 1557 0
 3350 1c04 2072C6E5 		strb	r7, [r6, #544]
1556:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3351              		.loc 1 1556 0
 3352 1c08 1D82C6E5 		strb	r8, [r6, #541]
1557:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3353              		.loc 1 1557 0
 3354 1c0c 1C409DE5 		ldr	r4, [sp, #28]
1558:../uvc.c      **** 							 break;
 3355              		.loc 1 1558 0
 3356 1c10 0A70A0E1 		mov	r7, sl
 3357 1c14 0CFDFFEA 		b	.L156
 3358              	.LVL288:
 3359              	.L239:
1531:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3360              		.loc 1 1531 0
 3361 1c18 14839FE5 		ldr	r8, .L325+64
 3362 1c1c 0010E0E3 		mvn	r1, #0
 3363 1c20 1C0098E5 		ldr	r0, [r8, #28]
 3364 1c24 FEFFFFEB 		bl	_txe_mutex_get
 3365              	.LVL289:
1532:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 3366              		.loc 1 1532 0
 3367 1c28 18209DE5 		ldr	r2, [sp, #24]
 3368 1c2c 00C0A0E3 		mov	ip, #0
 3369 1c30 803042E2 		sub	r3, r2, #128
 3370 1c34 FF4003E2 		and	r4, r3, #255
 3371 1c38 0A20A0E1 		mov	r2, sl
 3372 1c3c 0510A0E3 		mov	r1, #5
 3373 1c40 0930A0E1 		mov	r3, r9
 3374 1c44 0800A0E1 		mov	r0, r8
 3375 1c48 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3376 1c4c FEFFFFEB 		bl	cmdSet
 3377              	.LVL290:
1534:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 3378              		.loc 1 1534 0
 3379 1c50 18A09DE5 		ldr	sl, [sp, #24]
 3380 1c54 0510A0E3 		mov	r1, #5
 3381 1c58 76704AE2 		sub	r7, sl, #118
 3382              	.LVL291:
 3383 1c5c FFE007E2 		and	lr, r7, #255
 3384 1c60 DC20A0E3 		mov	r2, #220
 3385 1c64 0170A0E3 		mov	r7, #1
 3386 1c68 0930A0E1 		mov	r3, r9
 3387 1c6c 0800A0E1 		mov	r0, r8
 3388 1c70 00E08DE5 		str	lr, [sp, #0]
 3389 1c74 04708DE5 		str	r7, [sp, #4]
 3390 1c78 FEFFFFEB 		bl	cmdSet
 3391              	.LVL292:
1536:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 3392              		.loc 1 1536 0
 3393 1c7c 18009DE5 		ldr	r0, [sp, #24]
 3394 1c80 02C0A0E3 		mov	ip, #2
 3395 1c84 7E1080E2 		add	r1, r0, #126
 3396 1c88 FF4001E2 		and	r4, r1, #255
 3397 1c8c DE20A0E3 		mov	r2, #222
 3398 1c90 0510A0E3 		mov	r1, #5
 3399 1c94 0930A0E1 		mov	r3, r9
 3400 1c98 0800A0E1 		mov	r0, r8
 3401 1c9c 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3402 1ca0 FEFFFFEB 		bl	cmdSet
 3403              	.LVL293:
1538:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 3404              		.loc 1 1538 0
 3405 1ca4 18209DE5 		ldr	r2, [sp, #24]
 3406 1ca8 0510A0E3 		mov	r1, #5
 3407 1cac 723082E2 		add	r3, r2, #114
 3408 1cb0 FFA003E2 		and	sl, r3, #255
 3409 1cb4 E020A0E3 		mov	r2, #224
 3410 1cb8 0930A0E1 		mov	r3, r9
 3411 1cbc 0800A0E1 		mov	r0, r8
 3412 1cc0 0340A0E3 		mov	r4, #3
 3413 1cc4 00A08DE5 		str	sl, [sp, #0]
 3414 1cc8 04408DE5 		str	r4, [sp, #4]
 3415 1ccc FEFFFFEB 		bl	cmdSet
 3416              	.LVL294:
1540:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 3417              		.loc 1 1540 0
 3418 1cd0 18009DE5 		ldr	r0, [sp, #24]
 3419 1cd4 DD20A0E3 		mov	r2, #221
 3420 1cd8 6F1040E2 		sub	r1, r0, #111
 3421 1cdc FFC001E2 		and	ip, r1, #255
 3422 1ce0 0930A0E1 		mov	r3, r9
 3423 1ce4 0510A0E3 		mov	r1, #5
 3424 1ce8 0800A0E1 		mov	r0, r8
 3425 1cec 04A0A0E3 		mov	sl, #4
 3426 1cf0 00C08DE5 		str	ip, [sp, #0]
 3427 1cf4 04A08DE5 		str	sl, [sp, #4]
 3428 1cf8 FEFFFFEB 		bl	cmdSet
 3429              	.LVL295:
1542:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 3430              		.loc 1 1542 0
 3431 1cfc 3C229FE5 		ldr	r2, .L325+76
 3432 1d00 05E0A0E3 		mov	lr, #5
 3433 1d04 1C41D2E5 		ldrb	r4, [r2, #284]	@ zero_extendqisi2
1545:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3434              		.loc 1 1545 0
 3435 1d08 30A29FE5 		ldr	sl, .L325+76
1542:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 3436              		.loc 1 1542 0
 3437 1d0c 7F3084E2 		add	r3, r4, #127
 3438 1d10 FFC003E2 		and	ip, r3, #255
 3439 1d14 0E10A0E1 		mov	r1, lr
 3440 1d18 0B20A0E1 		mov	r2, fp
 3441 1d1c 0930A0E1 		mov	r3, r9
 3442 1d20 0800A0E1 		mov	r0, r8
 3443 1d24 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 3444 1d28 FEFFFFEB 		bl	cmdSet
1543:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3445              		.loc 1 1543 0
 3446 1d2c 1C0098E5 		ldr	r0, [r8, #28]
 3447 1d30 FEFFFFEB 		bl	_txe_mutex_put
1545:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3448              		.loc 1 1545 0
 3449 1d34 1C01DAE5 		ldrb	r0, [sl, #284]	@ zero_extendqisi2
1547:../uvc.c      **** 							 break;
 3450              		.loc 1 1547 0
 3451 1d38 FFA0A0E3 		mov	sl, #255
1545:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3452              		.loc 1 1545 0
 3453 1d3c 801040E2 		sub	r1, r0, #128
1546:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3454              		.loc 1 1546 0
 3455 1d40 0872C6E5 		strb	r7, [r6, #520]
1545:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3456              		.loc 1 1545 0
 3457 1d44 0512C6E5 		strb	r1, [r6, #517]
1546:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3458              		.loc 1 1546 0
 3459 1d48 18809DE5 		ldr	r8, [sp, #24]
 3460 1d4c 1C409DE5 		ldr	r4, [sp, #28]
1547:../uvc.c      **** 							 break;
 3461              		.loc 1 1547 0
 3462 1d50 0A70A0E1 		mov	r7, sl
 3463 1d54 BCFCFFEA 		b	.L156
 3464              	.LVL296:
 3465              	.L238:
1578:../uvc.c      **** 							 Data0 = Data0 - 1;
 3466              		.loc 1 1578 0
 3467 1d58 012043E2 		sub	r2, r3, #1
 3468              	.LVL297:
 3469 1d5c FF2002E2 		and	r2, r2, #255
 3470              	.LVL298:
1579:../uvc.c      **** 							 is60Hz = Data0;
 3471              		.loc 1 1579 0
 3472 1d60 D8119FE5 		ldr	r1, .L325+76
1590:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
 3473              		.loc 1 1590 0
 3474 1d64 D4E19FE5 		ldr	lr, .L325+76
1585:../uvc.c      **** 							 else if(Data0 >2)
 3475              		.loc 1 1585 0
 3476 1d68 020052E3 		cmp	r2, #2
1577:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3477              		.loc 1 1577 0
 3478 1d6c ED31C6E5 		strb	r3, [r6, #493]
1588:../uvc.c      **** 								 is60Hz = CyTrue;
 3479              		.loc 1 1588 0
 3480 1d70 0130A083 		movhi	r3, #1
1579:../uvc.c      **** 							 is60Hz = Data0;
 3481              		.loc 1 1579 0
 3482 1d74 D82081E5 		str	r2, [r1, #216]
 3483              	.LVL299:
1590:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
 3484              		.loc 1 1590 0
 3485 1d78 0400A0E3 		mov	r0, #4
1588:../uvc.c      **** 								 is60Hz = CyTrue;
 3486              		.loc 1 1588 0
 3487 1d7c D8308185 		strhi	r3, [r1, #216]
 3488              	.LVL300:
 3489 1d80 0320A081 		movhi	r2, r3
1590:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
 3490              		.loc 1 1590 0
 3491 1d84 90119FE5 		ldr	r1, .L325+40
 3492 1d88 D8309EE5 		ldr	r3, [lr, #216]
 3493 1d8c FEFFFFEB 		bl	CyU3PDebugPrint
 3494              	.LVL301:
1591:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3495              		.loc 1 1591 0
 3496 1d90 A8019FE5 		ldr	r0, .L325+76
 3497 1d94 A83090E5 		ldr	r3, [r0, #168]
 3498 1d98 010053E3 		cmp	r3, #1
 3499 1d9c 5101000A 		beq	.L321
 3500              	.LVL302:
 3501              	.L272:
1622:../uvc.c      **** 							 break;
 3502              		.loc 1 1622 0
 3503 1da0 FFA0A0E3 		mov	sl, #255
1621:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3504              		.loc 1 1621 0
 3505 1da4 0130A0E3 		mov	r3, #1
 3506 1da8 F031C6E5 		strb	r3, [r6, #496]
 3507 1dac 18809DE5 		ldr	r8, [sp, #24]
 3508 1db0 1C409DE5 		ldr	r4, [sp, #28]
1622:../uvc.c      **** 							 break;
 3509              		.loc 1 1622 0
 3510 1db4 0A70A0E1 		mov	r7, sl
 3511 1db8 A3FCFFEA 		b	.L156
 3512              	.LVL303:
 3513              	.L237:
1677:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3514              		.loc 1 1677 0
 3515 1dbc 70819FE5 		ldr	r8, .L325+64
 3516 1dc0 0010E0E3 		mvn	r1, #0
 3517 1dc4 1C0098E5 		ldr	r0, [r8, #28]
 3518 1dc8 FEFFFFEB 		bl	_txe_mutex_get
 3519              	.LVL304:
1678:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3520              		.loc 1 1678 0
 3521 1dcc 18C09DE5 		ldr	ip, [sp, #24]
 3522 1dd0 0410A0E1 		mov	r1, r4
 3523 1dd4 0A20A0E1 		mov	r2, sl
 3524 1dd8 0930A0E1 		mov	r3, r9
 3525 1ddc 0800A0E1 		mov	r0, r8
 3526 1de0 00A0A0E3 		mov	sl, #0
 3527 1de4 00C08DE5 		str	ip, [sp, #0]
 3528 1de8 04A08DE5 		str	sl, [sp, #4]
 3529 1dec FEFFFFEB 		bl	cmdSet
1679:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3530              		.loc 1 1679 0
 3531 1df0 1C0098E5 		ldr	r0, [r8, #28]
 3532 1df4 FEFFFFEB 		bl	_txe_mutex_put
1681:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
 3533              		.loc 1 1681 0
 3534 1df8 18709DE5 		ldr	r7, [sp, #24]
 3535              	.LVL305:
1686:../uvc.c      **** 							 break;
 3536              		.loc 1 1686 0
 3537 1dfc FFA0A0E3 		mov	sl, #255
1682:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 3538              		.loc 1 1682 0
 3539 1e00 0130A0E3 		mov	r3, #1
1681:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
 3540              		.loc 1 1681 0
 3541 1e04 BD71C6E5 		strb	r7, [r6, #445]
1682:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 3542              		.loc 1 1682 0
 3543 1e08 0780A0E1 		mov	r8, r7
 3544 1e0c C031C6E5 		strb	r3, [r6, #448]
 3545 1e10 1C409DE5 		ldr	r4, [sp, #28]
1686:../uvc.c      **** 							 break;
 3546              		.loc 1 1686 0
 3547 1e14 0A70A0E1 		mov	r7, sl
 3548 1e18 8BFCFFEA 		b	.L156
 3549              	.LVL306:
 3550              	.L236:
1513:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3551              		.loc 1 1513 0
 3552 1e1c 10819FE5 		ldr	r8, .L325+64
 3553 1e20 0010E0E3 		mvn	r1, #0
 3554 1e24 1C0098E5 		ldr	r0, [r8, #28]
 3555 1e28 FEFFFFEB 		bl	_txe_mutex_get
 3556              	.LVL307:
1515:../uvc.c      **** 							  if(Data0&0x80){
 3557              		.loc 1 1515 0
 3558 1e2c 18209DE5 		ldr	r2, [sp, #24]
1520:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 3559              		.loc 1 1520 0
 3560 1e30 0930A0E1 		mov	r3, r9
1515:../uvc.c      **** 							  if(Data0&0x80){
 3561              		.loc 1 1515 0
 3562 1e34 800012E3 		tst	r2, #128
1516:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 3563              		.loc 1 1516 0
 3564 1e38 80704212 		subne	r7, r2, #128
 3565              	.LVL308:
1518:../uvc.c      **** 								  Data0 = ~Data0;
 3566              		.loc 1 1518 0
 3567 1e3c 0270E001 		mvneq	r7, r2
 3568 1e40 FF7007E2 		and	r7, r7, #255
 3569              	.LVL309:
1520:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 3570              		.loc 1 1520 0
 3571 1e44 0110A0E3 		mov	r1, #1
 3572 1e48 0B20A0E1 		mov	r2, fp
 3573 1e4c 0040A0E3 		mov	r4, #0
 3574 1e50 DC009FE5 		ldr	r0, .L325+64
 3575 1e54 00708DE5 		str	r7, [sp, #0]
 3576 1e58 04408DE5 		str	r4, [sp, #4]
 3577 1e5c FEFFFFEB 		bl	cmdSet
1521:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3578              		.loc 1 1521 0
 3579 1e60 1C0098E5 		ldr	r0, [r8, #28]
 3580 1e64 FEFFFFEB 		bl	_txe_mutex_put
1527:../uvc.c      **** 							 break;
 3581              		.loc 1 1527 0
 3582 1e68 FFA0A0E3 		mov	sl, #255
1524:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3583              		.loc 1 1524 0
 3584 1e6c 0130A0E3 		mov	r3, #1
1523:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3585              		.loc 1 1523 0
 3586 1e70 A571C6E5 		strb	r7, [r6, #421]
1524:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3587              		.loc 1 1524 0
 3588 1e74 A831C6E5 		strb	r3, [r6, #424]
 3589 1e78 18809DE5 		ldr	r8, [sp, #24]
 3590 1e7c 1C409DE5 		ldr	r4, [sp, #28]
1527:../uvc.c      **** 							 break;
 3591              		.loc 1 1527 0
 3592 1e80 0A70A0E1 		mov	r7, sl
 3593              	.LVL310:
 3594 1e84 70FCFFEA 		b	.L156
 3595              	.LVL311:
 3596              	.L235:
1634:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3597              		.loc 1 1634 0
 3598 1e88 B0409FE5 		ldr	r4, .L325+76
1624:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3599              		.loc 1 1624 0
 3600 1e8c F874D6E5 		ldrb	r7, [r6, #1272]	@ zero_extendqisi2
 3601              	.LVL312:
1634:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3602              		.loc 1 1634 0
 3603 1e90 7C21D4E5 		ldrb	r2, [r4, #380]	@ zero_extendqisi2
 3604              	.LVL313:
 3605 1e94 0310A0E1 		mov	r1, r3
1625:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3606              		.loc 1 1625 0
 3607 1e98 F934D6E5 		ldrb	r3, [r6, #1273]	@ zero_extendqisi2
1626:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3608              		.loc 1 1626 0
 3609 1e9c 0785D6E5 		ldrb	r8, [r6, #1287]	@ zero_extendqisi2
1634:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3610              		.loc 1 1634 0
 3611 1ea0 010052E3 		cmp	r2, #1
1632:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3612              		.loc 1 1632 0
 3613 1ea4 01E0A0E3 		mov	lr, #1
1631:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3614              		.loc 1 1631 0
 3615 1ea8 0515C6E5 		strb	r1, [r6, #1285]
1624:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3616              		.loc 1 1624 0
 3617 1eac FF7007E2 		and	r7, r7, #255
 3618              	.LVL314:
1632:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3619              		.loc 1 1632 0
 3620 1eb0 09E5C6E5 		strb	lr, [r6, #1289]
1626:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3621              		.loc 1 1626 0
 3622 1eb4 FF8008E2 		and	r8, r8, #255
 3623              	.LVL315:
 3624 1eb8 0160A011 		movne	r6, r1
1634:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3625              		.loc 1 1634 0
 3626 1ebc 6E01000A 		beq	.L322
 3627              	.LVL316:
 3628              	.L286:
1645:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3629              		.loc 1 1645 0
 3630 1ec0 6CA09FE5 		ldr	sl, .L325+64
 3631 1ec4 0010E0E3 		mvn	r1, #0
 3632 1ec8 1C009AE5 		ldr	r0, [sl, #28]
 3633 1ecc FEFFFFEB 		bl	_txe_mutex_get
1646:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3634              		.loc 1 1646 0
 3635 1ed0 00C0A0E3 		mov	ip, #0
 3636 1ed4 0C10A0E1 		mov	r1, ip
 3637 1ed8 0720A0E1 		mov	r2, r7
 3638 1edc 0830A0E1 		mov	r3, r8
 3639 1ee0 0A00A0E1 		mov	r0, sl
 3640 1ee4 40108DE8 		stmia	sp, {r6, ip}	@ phole stm
 3641 1ee8 FEFFFFEB 		bl	cmdSet
1647:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3642              		.loc 1 1647 0
 3643 1eec 1C009AE5 		ldr	r0, [sl, #28]
 3644 1ef0 9BFEFFEA 		b	.L312
 3645              	.L326:
 3646              		.align	2
 3647              	.L325:
 3648 1ef4 00000000 		.word	bRequest
 3649 1ef8 38050000 		.word	.LC31
 3650 1efc 1C010000 		.word	.LANCHOR0+284
 3651 1f00 01000100 		.word	65537
 3652 1f04 FF00FF00 		.word	16711935
 3653 1f08 C8030000 		.word	.LC23
 3654 1f0c 04040000 		.word	.LC24
 3655 1f10 68030000 		.word	.LC21
 3656 1f14 CC000000 		.word	.LANCHOR0+204
 3657 1f18 8C040000 		.word	.LC27
 3658 1f1c C4040000 		.word	.LC28
 3659 1f20 58040000 		.word	.LC26
 3660 1f24 2C040000 		.word	.LC25
 3661 1f28 08050000 		.word	.LC30
 3662 1f2c E4040000 		.word	.LC29
 3663 1f30 40030000 		.word	.LC20
 3664 1f34 00000000 		.word	cmdQu
 3665 1f38 90030000 		.word	.LC22
 3666 1f3c 00000000 		.word	.LANCHOR1
 3667 1f40 00000000 		.word	.LANCHOR0
 3668              	.LVL317:
 3669              	.L234:
1690:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3670              		.loc 1 1690 0
 3671 1f44 18701FE5 		ldr	r7, .L325+64
 3672              	.LVL318:
 3673 1f48 0010E0E3 		mvn	r1, #0
 3674 1f4c 1C0097E5 		ldr	r0, [r7, #28]
 3675 1f50 FEFFFFEB 		bl	_txe_mutex_get
 3676              	.LVL319:
1691:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3677              		.loc 1 1691 0
 3678 1f54 0A20A0E1 		mov	r2, sl
 3679 1f58 18A09DE5 		ldr	sl, [sp, #24]
 3680 1f5c 0410A0E1 		mov	r1, r4
 3681 1f60 0930A0E1 		mov	r3, r9
 3682 1f64 0700A0E1 		mov	r0, r7
 3683 1f68 0080A0E3 		mov	r8, #0
 3684 1f6c 00A08DE5 		str	sl, [sp, #0]
 3685 1f70 04808DE5 		str	r8, [sp, #4]
 3686 1f74 FEFFFFEB 		bl	cmdSet
1692:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3687              		.loc 1 1692 0
 3688 1f78 1C0097E5 		ldr	r0, [r7, #28]
 3689 1f7c FEFFFFEB 		bl	_txe_mutex_put
1694:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3690              		.loc 1 1694 0
 3691 1f80 18109DE5 		ldr	r1, [sp, #24]
 3692 1f84 840084E0 		add	r0, r4, r4, asl #1
 3693 1f88 806186E0 		add	r6, r6, r0, asl #3
1696:../uvc.c      **** 							 break;
 3694              		.loc 1 1696 0
 3695 1f8c FFA0A0E3 		mov	sl, #255
1695:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3696              		.loc 1 1695 0
 3697 1f90 0120A0E3 		mov	r2, #1
1694:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3698              		.loc 1 1694 0
 3699 1f94 8D11C6E5 		strb	r1, [r6, #397]
1695:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3700              		.loc 1 1695 0
 3701 1f98 9021C6E5 		strb	r2, [r6, #400]
 3702 1f9c 0180A0E1 		mov	r8, r1
 3703 1fa0 1C409DE5 		ldr	r4, [sp, #28]
1696:../uvc.c      **** 							 break;
 3704              		.loc 1 1696 0
 3705 1fa4 0A70A0E1 		mov	r7, sl
 3706 1fa8 27FCFFEA 		b	.L156
 3707              	.LVL320:
 3708              	.L244:
1331:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3709              		.loc 1 1331 0
 3710 1fac 80401FE5 		ldr	r4, .L325+64
1327:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3711              		.loc 1 1327 0
 3712 1fb0 E0A4D6E5 		ldrb	sl, [r6, #1248]	@ zero_extendqisi2
1328:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3713              		.loc 1 1328 0
 3714 1fb4 E1E4D6E5 		ldrb	lr, [r6, #1249]	@ zero_extendqisi2
1329:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 3715              		.loc 1 1329 0
 3716 1fb8 EFC4D6E5 		ldrb	ip, [r6, #1263]	@ zero_extendqisi2
 3717              	.LVL321:
1331:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3718              		.loc 1 1331 0
 3719 1fbc 0010E0E3 		mvn	r1, #0
 3720 1fc0 1C0094E5 		ldr	r0, [r4, #28]
1329:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 3721              		.loc 1 1329 0
 3722 1fc4 FF800CE2 		and	r8, ip, #255
1328:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3723              		.loc 1 1328 0
 3724 1fc8 FF900EE2 		and	r9, lr, #255
1331:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3725              		.loc 1 1331 0
 3726 1fcc FEFFFFEB 		bl	_txe_mutex_get
 3727              	.LVL322:
1332:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3728              		.loc 1 1332 0
 3729 1fd0 18C09DE5 		ldr	ip, [sp, #24]
 3730 1fd4 ED14D6E5 		ldrb	r1, [r6, #1261]	@ zero_extendqisi2
1327:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3731              		.loc 1 1327 0
 3732 1fd8 FFA00AE2 		and	sl, sl, #255
 3733              	.LVL323:
1332:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3734              		.loc 1 1332 0
 3735 1fdc 01005CE1 		cmp	ip, r1
1327:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3736              		.loc 1 1327 0
 3737 1fe0 AC301FE5 		ldr	r3, .L325+72
 3738 1fe4 0C70A001 		moveq	r7, ip
 3739              	.LVL324:
1332:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3740              		.loc 1 1332 0
 3741 1fe8 0A00000A 		beq	.L257
1334:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
 3742              		.loc 1 1334 0
 3743 1fec EDC4C3E5 		strb	ip, [r3, #1261]
1335:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 3744              		.loc 1 1335 0
 3745 1ff0 C534D3E5 		ldrb	r3, [r3, #1221]	@ zero_extendqisi2
1336:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3746              		.loc 1 1336 0
 3747 1ff4 0400A0E1 		mov	r0, r4
1335:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 3748              		.loc 1 1335 0
 3749 1ff8 03728CE1 		orr	r7, ip, r3, asl #4
 3750 1ffc FF7007E2 		and	r7, r7, #255
 3751              	.LVL325:
1336:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3752              		.loc 1 1336 0
 3753 2000 00C0A0E3 		mov	ip, #0
 3754 2004 1910A0E3 		mov	r1, #25
 3755 2008 0A20A0E1 		mov	r2, sl
 3756 200c 0830A0E1 		mov	r3, r8
 3757 2010 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 3758 2014 FEFFFFEB 		bl	cmdSet
 3759              	.LVL326:
 3760              	.L257:
1348:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
 3761              		.loc 1 1348 0
 3762 2018 EE04D6E5 		ldrb	r0, [r6, #1262]	@ zero_extendqisi2
 3763 201c 1CE09DE5 		ldr	lr, [sp, #28]
 3764 2020 0E0050E1 		cmp	r0, lr
 3765 2024 0500000A 		beq	.L258
1350:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3766              		.loc 1 1350 0
 3767 2028 18A09DE5 		ldr	sl, [sp, #24]
 3768              	.LVL327:
1349:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 3769              		.loc 1 1349 0
 3770 202c F8201FE5 		ldr	r2, .L325+72
1350:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3771              		.loc 1 1350 0
 3772 2030 02104AE2 		sub	r1, sl, #2
 3773 2034 010051E3 		cmp	r1, #1
1349:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 3774              		.loc 1 1349 0
 3775 2038 EEE4C2E5 		strb	lr, [r2, #1262]
1350:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3776              		.loc 1 1350 0
 3777 203c E101009A 		bls	.L323
 3778              	.LVL328:
 3779              	.L258:
1355:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3780              		.loc 1 1355 0
 3781 2040 1C0094E5 		ldr	r0, [r4, #28]
 3782 2044 FEFFFFEB 		bl	_txe_mutex_put
1357:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3783              		.loc 1 1357 0
 3784 2048 ED24D6E5 		ldrb	r2, [r6, #1261]	@ zero_extendqisi2
1356:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3785              		.loc 1 1356 0
 3786 204c 1C409DE5 		ldr	r4, [sp, #28]
1357:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3787              		.loc 1 1357 0
 3788 2050 EE34D6E5 		ldrb	r3, [r6, #1262]	@ zero_extendqisi2
 3789 2054 C5C4D6E5 		ldrb	ip, [r6, #1221]	@ zero_extendqisi2
1356:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3790              		.loc 1 1356 0
 3791 2058 0400A0E3 		mov	r0, #4
 3792 205c 44111FE5 		ldr	r1, .L325+44
1358:../uvc.c      **** 							 break;
 3793              		.loc 1 1358 0
 3794 2060 FFA0A0E3 		mov	sl, #255
1356:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3795              		.loc 1 1356 0
 3796 2064 04708DE5 		str	r7, [sp, #4]
 3797 2068 00C08DE5 		str	ip, [sp, #0]
 3798 206c 08408DE5 		str	r4, [sp, #8]
1358:../uvc.c      **** 							 break;
 3799              		.loc 1 1358 0
 3800 2070 0A70A0E1 		mov	r7, sl
 3801              	.LVL329:
1356:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3802              		.loc 1 1356 0
 3803 2074 FEFFFFEB 		bl	CyU3PDebugPrint
 3804              	.LVL330:
 3805 2078 18809DE5 		ldr	r8, [sp, #24]
1358:../uvc.c      **** 							 break;
 3806              		.loc 1 1358 0
 3807 207c F2FBFFEA 		b	.L156
 3808              	.LVL331:
 3809              	.L243:
1267:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3810              		.loc 1 1267 0
 3811 2080 B8A4D6E5 		ldrb	sl, [r6, #1208]	@ zero_extendqisi2
 3812 2084 0310A0E1 		mov	r1, r3
1268:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3813              		.loc 1 1268 0
 3814 2088 B984D6E5 		ldrb	r8, [r6, #1209]	@ zero_extendqisi2
1269:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3815              		.loc 1 1269 0
 3816 208c C744D6E5 		ldrb	r4, [r6, #1223]	@ zero_extendqisi2
1270:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
 3817              		.loc 1 1270 0
 3818 2090 C534C6E5 		strb	r3, [r6, #1221]
1272:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3819              		.loc 1 1272 0
 3820 2094 ED34D6E5 		ldrb	r3, [r6, #1261]	@ zero_extendqisi2
1267:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3821              		.loc 1 1267 0
 3822 2098 FF700AE2 		and	r7, sl, #255
 3823              	.LVL332:
1272:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3824              		.loc 1 1272 0
 3825 209c 030013E3 		tst	r3, #3
1268:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3826              		.loc 1 1268 0
 3827 20a0 FF8008E2 		and	r8, r8, #255
 3828              	.LVL333:
1269:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3829              		.loc 1 1269 0
 3830 20a4 FF4004E2 		and	r4, r4, #255
 3831              	.LVL334:
1272:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3832              		.loc 1 1272 0
 3833 20a8 0130A001 		moveq	r3, r1
 3834 20ac 1D00000A 		beq	.L256
1274:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3835              		.loc 1 1274 0
 3836 20b0 7C911FE5 		ldr	r9, .L325+72
1276:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3837              		.loc 1 1276 0
 3838 20b4 88A11FE5 		ldr	sl, .L325+64
1274:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3839              		.loc 1 1274 0
 3840 20b8 ED04D9E5 		ldrb	r0, [r9, #1261]	@ zero_extendqisi2
 3841 20bc 0120A0E1 		mov	r2, r1
 3842              	.LVL335:
 3843 20c0 023280E1 		orr	r3, r0, r2, asl #4
1276:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3844              		.loc 1 1276 0
 3845 20c4 0010E0E3 		mvn	r1, #0
 3846 20c8 1C009AE5 		ldr	r0, [sl, #28]
1274:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3847              		.loc 1 1274 0
 3848 20cc FF9003E2 		and	r9, r3, #255
 3849              	.LVL336:
1276:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3850              		.loc 1 1276 0
 3851 20d0 14C08DE5 		str	ip, [sp, #20]
 3852 20d4 FEFFFFEB 		bl	_txe_mutex_get
 3853              	.LVL337:
1277:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3854              		.loc 1 1277 0
 3855 20d8 00E0A0E3 		mov	lr, #0
 3856 20dc 1010A0E3 		mov	r1, #16
 3857 20e0 0820A0E1 		mov	r2, r8
 3858 20e4 0430A0E1 		mov	r3, r4
 3859 20e8 0A00A0E1 		mov	r0, sl
 3860 20ec 00E08DE5 		str	lr, [sp, #0]
 3861 20f0 04E08DE5 		str	lr, [sp, #4]
 3862 20f4 FEFFFFEB 		bl	cmdSet
 3863              	.LVL338:
1279:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3864              		.loc 1 1279 0
 3865 20f8 0720A0E1 		mov	r2, r7
 3866 20fc 0430A0E1 		mov	r3, r4
 3867 2100 1010A0E3 		mov	r1, #16
 3868 2104 0A00A0E1 		mov	r0, sl
 3869 2108 0170A0E3 		mov	r7, #1
 3870              	.LVL339:
 3871 210c 00908DE5 		str	r9, [sp, #0]
 3872 2110 04708DE5 		str	r7, [sp, #4]
 3873 2114 FEFFFFEB 		bl	cmdSet
 3874              	.LVL340:
1280:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3875              		.loc 1 1280 0
 3876 2118 1C009AE5 		ldr	r0, [sl, #28]
 3877 211c FEFFFFEB 		bl	_txe_mutex_put
 3878 2120 14C09DE5 		ldr	ip, [sp, #20]
 3879 2124 0930A0E1 		mov	r3, r9
 3880              	.LVL341:
 3881              	.L256:
1283:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 3882              		.loc 1 1283 0
 3883 2128 ED84D6E5 		ldrb	r8, [r6, #1261]	@ zero_extendqisi2
 3884              	.LVL342:
 3885 212c C544D6E5 		ldrb	r4, [r6, #1221]	@ zero_extendqisi2
 3886              	.LVL343:
1282:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3887              		.loc 1 1282 0
 3888 2130 0400A0E3 		mov	r0, #4
 3889 2134 18121FE5 		ldr	r1, .L325+48
 3890 2138 0C20A0E1 		mov	r2, ip
1284:../uvc.c      **** 						     break;
 3891              		.loc 1 1284 0
 3892 213c FFA0A0E3 		mov	sl, #255
1282:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3893              		.loc 1 1282 0
 3894 2140 00808DE5 		str	r8, [sp, #0]
 3895 2144 04408DE5 		str	r4, [sp, #4]
1284:../uvc.c      **** 						     break;
 3896              		.loc 1 1284 0
 3897 2148 0A70A0E1 		mov	r7, sl
1282:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3898              		.loc 1 1282 0
 3899 214c FEFFFFEB 		bl	CyU3PDebugPrint
 3900 2150 18809DE5 		ldr	r8, [sp, #24]
 3901 2154 1C409DE5 		ldr	r4, [sp, #28]
1284:../uvc.c      **** 						     break;
 3902              		.loc 1 1284 0
 3903 2158 BBFBFFEA 		b	.L156
 3904              	.LVL344:
 3905              	.L242:
1565:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3906              		.loc 1 1565 0
 3907 215c 30721FE5 		ldr	r7, .L325+64
 3908              	.LVL345:
 3909 2160 0010E0E3 		mvn	r1, #0
 3910 2164 1C0097E5 		ldr	r0, [r7, #28]
 3911 2168 FEFFFFEB 		bl	_txe_mutex_get
 3912              	.LVL346:
1566:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3913              		.loc 1 1566 0
 3914 216c 18C09DE5 		ldr	ip, [sp, #24]
 3915 2170 0A20A0E1 		mov	r2, sl
 3916 2174 0B10A0E3 		mov	r1, #11
 3917 2178 0930A0E1 		mov	r3, r9
 3918 217c 0700A0E1 		mov	r0, r7
 3919 2180 00A0A0E3 		mov	sl, #0
 3920 2184 00C08DE5 		str	ip, [sp, #0]
 3921 2188 04A08DE5 		str	sl, [sp, #4]
 3922 218c FEFFFFEB 		bl	cmdSet
 3923              	.LVL347:
1568:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 3924              		.loc 1 1568 0
 3925 2190 1C409DE5 		ldr	r4, [sp, #28]
 3926 2194 0180A0E3 		mov	r8, #1
 3927 2198 0B10A0E3 		mov	r1, #11
 3928 219c 0B20A0E1 		mov	r2, fp
 3929 21a0 0930A0E1 		mov	r3, r9
 3930 21a4 0700A0E1 		mov	r0, r7
 3931 21a8 10018DE8 		stmia	sp, {r4, r8}	@ phole stm
 3932 21ac FEFFFFEB 		bl	cmdSet
1569:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3933              		.loc 1 1569 0
 3934 21b0 1C0097E5 		ldr	r0, [r7, #28]
 3935 21b4 FEFFFFEB 		bl	_txe_mutex_put
1571:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 3936              		.loc 1 1571 0
 3937 21b8 18009DE5 		ldr	r0, [sp, #24]
1572:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3938              		.loc 1 1572 0
 3939 21bc 1C109DE5 		ldr	r1, [sp, #28]
1574:../uvc.c      **** 							 break;
 3940              		.loc 1 1574 0
 3941 21c0 FFA0A0E3 		mov	sl, #255
1573:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3942              		.loc 1 1573 0
 3943 21c4 9882C6E5 		strb	r8, [r6, #664]
1571:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 3944              		.loc 1 1571 0
 3945 21c8 F404C6E5 		strb	r0, [r6, #1268]
1572:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3946              		.loc 1 1572 0
 3947 21cc F614C6E5 		strb	r1, [r6, #1270]
1573:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3948              		.loc 1 1573 0
 3949 21d0 0080A0E1 		mov	r8, r0
 3950 21d4 0140A0E1 		mov	r4, r1
1574:../uvc.c      **** 							 break;
 3951              		.loc 1 1574 0
 3952 21d8 0A70A0E1 		mov	r7, sl
 3953 21dc 9AFBFFEA 		b	.L156
 3954              	.LVL348:
 3955              	.L241:
1651:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3956              		.loc 1 1651 0
 3957 21e0 0C05D6E5 		ldrb	r0, [r6, #1292]	@ zero_extendqisi2
1652:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3958              		.loc 1 1652 0
 3959 21e4 0D25D6E5 		ldrb	r2, [r6, #1293]	@ zero_extendqisi2
 3960              	.LVL349:
1653:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3961              		.loc 1 1653 0
 3962 21e8 1B15D6E5 		ldrb	r1, [r6, #1307]	@ zero_extendqisi2
1656:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3963              		.loc 1 1656 0
 3964 21ec 0140A0E3 		mov	r4, #1
1657:../uvc.c      **** 							 if(Data0 != 0){
 3965              		.loc 1 1657 0
 3966 21f0 000053E3 		cmp	r3, #0
1655:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3967              		.loc 1 1655 0
 3968 21f4 1935C6E5 		strb	r3, [r6, #1305]
1651:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3969              		.loc 1 1651 0
 3970 21f8 FF8000E2 		and	r8, r0, #255
 3971              	.LVL350:
1652:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3972              		.loc 1 1652 0
 3973 21fc FFA002E2 		and	sl, r2, #255
 3974              	.LVL351:
1653:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3975              		.loc 1 1653 0
 3976 2200 FF7001E2 		and	r7, r1, #255
 3977              	.LVL352:
1656:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3978              		.loc 1 1656 0
 3979 2204 1D45C6E5 		strb	r4, [r6, #1309]
1657:../uvc.c      **** 							 if(Data0 != 0){
 3980              		.loc 1 1657 0
 3981 2208 1C00000A 		beq	.L288
1658:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3982              		.loc 1 1658 0
 3983 220c E0621FE5 		ldr	r6, .L325+64
 3984 2210 0010E0E3 		mvn	r1, #0
 3985 2214 1C0096E5 		ldr	r0, [r6, #28]
 3986 2218 FEFFFFEB 		bl	_txe_mutex_get
 3987              	.LVL353:
1662:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
 3988              		.loc 1 1662 0
 3989 221c 0820A0E1 		mov	r2, r8
 3990 2220 00C0A0E3 		mov	ip, #0
 3991 2224 0710A0E3 		mov	r1, #7
 3992 2228 0730A0E1 		mov	r3, r7
 3993 222c 0600A0E1 		mov	r0, r6
 3994 2230 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3995 2234 FEFFFFEB 		bl	cmdSet
 3996              	.LVL354:
1664:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
 3997              		.loc 1 1664 0
 3998 2238 18809DE5 		ldr	r8, [sp, #24]
 3999              	.LVL355:
 4000 223c 0710A0E3 		mov	r1, #7
 4001 2240 0A20A0E1 		mov	r2, sl
 4002 2244 0730A0E1 		mov	r3, r7
 4003 2248 0600A0E1 		mov	r0, r6
 4004 224c 00808DE5 		str	r8, [sp, #0]
 4005 2250 04408DE5 		str	r4, [sp, #4]
 4006 2254 FEFFFFEB 		bl	cmdSet
1666:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4007              		.loc 1 1666 0
 4008 2258 1C0096E5 		ldr	r0, [r6, #28]
 4009 225c C0FDFFEA 		b	.L312
 4010              	.LVL356:
 4011              	.L233:
1699:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 4012              		.loc 1 1699 0
 4013 2260 FFA0A0E3 		mov	sl, #255
 4014 2264 0400A0E3 		mov	r0, #4
 4015              	.LVL357:
 4016 2268 48131FE5 		ldr	r1, .L325+52
 4017 226c FEFFFFEB 		bl	CyU3PDebugPrint
 4018              	.LVL358:
 4019 2270 0A70A0E1 		mov	r7, sl
 4020              	.LVL359:
 4021 2274 0A40A0E1 		mov	r4, sl
 4022 2278 0A80A0E1 		mov	r8, sl
 4023 227c 72FBFFEA 		b	.L156
 4024              	.LVL360:
 4025              	.L288:
1668:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4026              		.loc 1 1668 0
 4027 2280 54431FE5 		ldr	r4, .L325+64
 4028 2284 0010E0E3 		mvn	r1, #0
 4029 2288 1C0094E5 		ldr	r0, [r4, #28]
 4030 228c FEFFFFEB 		bl	_txe_mutex_get
 4031              	.LVL361:
1669:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 4032              		.loc 1 1669 0
 4033 2290 18E09DE5 		ldr	lr, [sp, #24]
 4034 2294 0820A0E1 		mov	r2, r8
 4035 2298 0730A0E1 		mov	r3, r7
 4036 229c 0710A0E3 		mov	r1, #7
 4037 22a0 0400A0E1 		mov	r0, r4
 4038 22a4 00E08DE5 		str	lr, [sp, #0]
 4039 22a8 04E08DE5 		str	lr, [sp, #4]
1670:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4040              		.loc 1 1670 0
 4041 22ac FFA0A0E3 		mov	sl, #255
 4042              	.LVL362:
1669:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 4043              		.loc 1 1669 0
 4044 22b0 FEFFFFEB 		bl	cmdSet
1670:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4045              		.loc 1 1670 0
 4046 22b4 1C0094E5 		ldr	r0, [r4, #28]
 4047 22b8 FEFFFFEB 		bl	_txe_mutex_put
 4048 22bc 0A70A0E1 		mov	r7, sl
 4049              	.LVL363:
 4050 22c0 1C409DE5 		ldr	r4, [sp, #28]
 4051 22c4 18809DE5 		ldr	r8, [sp, #24]
 4052              	.LVL364:
 4053 22c8 5FFBFFEA 		b	.L156
 4054              	.LVL365:
 4055              	.L320:
1028:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4056              		.loc 1 1028 0
 4057 22cc 0A00A0E1 		mov	r0, sl
 4058 22d0 0910A0E1 		mov	r1, r9
 4059 22d4 FEFFFFEB 		bl	SensorGetControl
 4060              	.LVL366:
1030:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4061              		.loc 1 1030 0
 4062 22d8 01A0A0E3 		mov	sl, #1
 4063 22dc 41A1C4E5 		strb	sl, [r4, #321]
1029:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 4064              		.loc 1 1029 0
 4065 22e0 0502C6E5 		strb	r0, [r6, #517]
 4066 22e4 47FDFFEA 		b	.L203
 4067              	.LVL367:
 4068              	.L321:
1594:../uvc.c      **** 			                       switch (setRes)
 4069              		.loc 1 1594 0
 4070 22e8 7D81D0E5 		ldrb	r8, [r0, #381]	@ zero_extendqisi2
 4071 22ec 010048E2 		sub	r0, r8, #1
 4072 22f0 030050E3 		cmp	r0, #3
 4073 22f4 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 4074 22f8 A8FEFFEA 		b	.L272
 4075              	.L277:
 4076 22fc 28240000 		.word	.L273
 4077 2300 D4230000 		.word	.L274
 4078 2304 70230000 		.word	.L275
 4079 2308 0C230000 		.word	.L276
 4080              	.L276:
1612:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
 4081              		.loc 1 1612 0
 4082 230c D4031FE5 		ldr	r0, .L325+76
1614:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4083              		.loc 1 1614 0
 4084 2310 D8A31FE5 		ldr	sl, .L325+76
1612:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
 4085              		.loc 1 1612 0
 4086 2314 D8C090E5 		ldr	ip, [r0, #216]
 4087 2318 8D24D6E5 		ldrb	r2, [r6, #1165]	@ zero_extendqisi2
 4088 231c 00005CE3 		cmp	ip, #0
 4089 2320 F4C0A003 		moveq	ip, #244
 4090 2324 74C0A013 		movne	ip, #116
 4091 2328 02208CE1 		orr	r2, ip, r2
 4092 232c 3010A0E3 		mov	r1, #48
 4093 2330 5230A0E3 		mov	r3, #82
 4094 2334 0100A0E3 		mov	r0, #1
 4095 2338 FEFFFFEB 		bl	SensorSetIrisControl
1613:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4096              		.loc 1 1613 0
 4097 233c 7D0FA0E3 		mov	r0, #500
 4098 2340 FEFFFFEB 		bl	_tx_thread_sleep
1614:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4099              		.loc 1 1614 0
 4100 2344 D8409AE5 		ldr	r4, [sl, #216]
 4101 2348 8D74D6E5 		ldrb	r7, [r6, #1165]	@ zero_extendqisi2
 4102              	.LVL368:
 4103 234c 000054E3 		cmp	r4, #0
 4104 2350 F440A003 		moveq	r4, #244
 4105 2354 7440A013 		movne	r4, #116
 4106 2358 D8309AE5 		ldr	r3, [sl, #216]
 4107 235c 38141FE5 		ldr	r1, .L325+56
 4108 2360 072084E1 		orr	r2, r4, r7
 4109 2364 0400A0E3 		mov	r0, #4
 4110 2368 FEFFFFEB 		bl	CyU3PDebugPrint
 4111 236c 8BFEFFEA 		b	.L272
 4112              	.LVL369:
 4113              	.L275:
1607:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
 4114              		.loc 1 1607 0
 4115 2370 38841FE5 		ldr	r8, .L325+76
 4116 2374 5230A0E3 		mov	r3, #82
 4117 2378 D8E098E5 		ldr	lr, [r8, #216]
 4118 237c 8D14D6E5 		ldrb	r1, [r6, #1165]	@ zero_extendqisi2
 4119 2380 00005EE3 		cmp	lr, #0
 4120 2384 C4E0A003 		moveq	lr, #196
 4121 2388 44E0A013 		movne	lr, #68
 4122 238c 01208EE1 		orr	r2, lr, r1
 4123 2390 0100A0E3 		mov	r0, #1
 4124 2394 3010A0E3 		mov	r1, #48
 4125 2398 FEFFFFEB 		bl	SensorSetIrisControl
1608:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4126              		.loc 1 1608 0
 4127 239c 7D0FA0E3 		mov	r0, #500
 4128 23a0 FEFFFFEB 		bl	_tx_thread_sleep
1609:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4129              		.loc 1 1609 0
 4130 23a4 6C341FE5 		ldr	r3, .L325+76
 4131 23a8 84141FE5 		ldr	r1, .L325+56
 4132 23ac D80093E5 		ldr	r0, [r3, #216]
 4133 23b0 8D24D6E5 		ldrb	r2, [r6, #1165]	@ zero_extendqisi2
 4134 23b4 000050E3 		cmp	r0, #0
 4135 23b8 C400A003 		moveq	r0, #196
 4136 23bc 4400A013 		movne	r0, #68
 4137 23c0 022080E1 		orr	r2, r0, r2
 4138 23c4 D83093E5 		ldr	r3, [r3, #216]
 4139 23c8 0400A0E3 		mov	r0, #4
 4140 23cc FEFFFFEB 		bl	CyU3PDebugPrint
1610:../uvc.c      **** 			                         		break;
 4141              		.loc 1 1610 0
 4142 23d0 72FEFFEA 		b	.L272
 4143              	.L274:
1602:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 4144              		.loc 1 1602 0
 4145 23d4 9CC41FE5 		ldr	ip, .L325+76
1604:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4146              		.loc 1 1604 0
 4147 23d8 A0A41FE5 		ldr	sl, .L325+76
1602:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 4148              		.loc 1 1602 0
 4149 23dc D8209CE5 		ldr	r2, [ip, #216]
 4150 23e0 3010A0E3 		mov	r1, #48
 4151 23e4 000052E3 		cmp	r2, #0
 4152 23e8 D420A003 		moveq	r2, #212
 4153 23ec 5420A013 		movne	r2, #84
 4154 23f0 5230A0E3 		mov	r3, #82
 4155 23f4 0100A0E3 		mov	r0, #1
 4156 23f8 FEFFFFEB 		bl	SensorSetIrisControl
1603:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4157              		.loc 1 1603 0
 4158 23fc 7D0FA0E3 		mov	r0, #500
 4159 2400 FEFFFFEB 		bl	_tx_thread_sleep
1604:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4160              		.loc 1 1604 0
 4161 2404 D8209AE5 		ldr	r2, [sl, #216]
 4162 2408 E4141FE5 		ldr	r1, .L325+56
 4163 240c 000052E3 		cmp	r2, #0
 4164 2410 D8309AE5 		ldr	r3, [sl, #216]
 4165 2414 D420A003 		moveq	r2, #212
 4166 2418 5420A013 		movne	r2, #84
 4167 241c 0400A0E3 		mov	r0, #4
 4168 2420 FEFFFFEB 		bl	CyU3PDebugPrint
1605:../uvc.c      **** 			                         		break;
 4169              		.loc 1 1605 0
 4170 2424 5DFEFFEA 		b	.L272
 4171              	.L273:
1597:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 4172              		.loc 1 1597 0
 4173 2428 F0441FE5 		ldr	r4, .L325+76
1599:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4174              		.loc 1 1599 0
 4175 242c F4741FE5 		ldr	r7, .L325+76
 4176              	.LVL370:
1597:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 4177              		.loc 1 1597 0
 4178 2430 D82094E5 		ldr	r2, [r4, #216]
 4179 2434 3010A0E3 		mov	r1, #48
 4180 2438 000052E3 		cmp	r2, #0
 4181 243c E420A003 		moveq	r2, #228
 4182 2440 6420A013 		movne	r2, #100
 4183 2444 5230A0E3 		mov	r3, #82
 4184 2448 0100A0E3 		mov	r0, #1
 4185 244c FEFFFFEB 		bl	SensorSetIrisControl
1598:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4186              		.loc 1 1598 0
 4187 2450 7D0FA0E3 		mov	r0, #500
 4188 2454 FEFFFFEB 		bl	_tx_thread_sleep
1599:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4189              		.loc 1 1599 0
 4190 2458 D82097E5 		ldr	r2, [r7, #216]
 4191 245c 38151FE5 		ldr	r1, .L325+56
 4192 2460 000052E3 		cmp	r2, #0
 4193 2464 D83097E5 		ldr	r3, [r7, #216]
 4194 2468 E420A003 		moveq	r2, #228
 4195 246c 6420A013 		movne	r2, #100
 4196 2470 0400A0E3 		mov	r0, #4
 4197 2474 FEFFFFEB 		bl	CyU3PDebugPrint
1600:../uvc.c      **** 			                         		break;
 4198              		.loc 1 1600 0
 4199 2478 48FEFFEA 		b	.L272
 4200              	.LVL371:
 4201              	.L322:
1636:../uvc.c      **** 								 if(Data0 < 3){
 4202              		.loc 1 1636 0
 4203 247c 020051E3 		cmp	r1, #2
1637:../uvc.c      **** 					 				 Data0 += 4;
 4204              		.loc 1 1637 0
 4205 2480 04608192 		addls	r6, r1, #4
 4206 2484 FF600692 		andls	r6, r6, #255
1636:../uvc.c      **** 								 if(Data0 < 3){
 4207              		.loc 1 1636 0
 4208 2488 8CFEFF9A 		bls	.L286
1639:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 4209              		.loc 1 1639 0
 4210 248c 0400A0E3 		mov	r0, #4
 4211 2490 60151FE5 		ldr	r1, .L325+68
 4212 2494 18309DE5 		ldr	r3, [sp, #24]
 4213 2498 FEFFFFEB 		bl	CyU3PDebugPrint
 4214              	.LVL372:
1640:../uvc.c      **** 									Data0 = 4; //set to default.
 4215              		.loc 1 1640 0
 4216 249c 0460A0E3 		mov	r6, #4
 4217 24a0 86FEFFEA 		b	.L286
 4218              	.LVL373:
 4219              	.L204:
1046:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4220              		.loc 1 1046 0
 4221 24a4 0A00A0E1 		mov	r0, sl
 4222              	.LVL374:
 4223 24a8 0910A0E1 		mov	r1, r9
 4224 24ac FEFFFFEB 		bl	SensorGetControl
1047:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 4225              		.loc 1 1047 0
 4226 24b0 0910A0E1 		mov	r1, r9
1046:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4227              		.loc 1 1046 0
 4228 24b4 0070A0E1 		mov	r7, r0
 4229              	.LVL375:
1047:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 4230              		.loc 1 1047 0
 4231 24b8 0B00A0E1 		mov	r0, fp
 4232              	.LVL376:
 4233 24bc FEFFFFEB 		bl	SensorGetControl
1052:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4234              		.loc 1 1052 0
 4235 24c0 0110A0E3 		mov	r1, #1
1048:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 4236              		.loc 1 1048 0
 4237 24c4 1C71C4E5 		strb	r7, [r4, #284]
1049:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 4238              		.loc 1 1049 0
 4239 24c8 F474C6E5 		strb	r7, [r6, #1268]
1052:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4240              		.loc 1 1052 0
 4241 24cc 4711C4E5 		strb	r1, [r4, #327]
1047:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 4242              		.loc 1 1047 0
 4243 24d0 00A0A0E1 		mov	sl, r0
 4244              	.LVL377:
1050:../uvc.c      **** 						glEp0Buffer[2] = Data1;
 4245              		.loc 1 1050 0
 4246 24d4 1E01C4E5 		strb	r0, [r4, #286]
1051:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 4247              		.loc 1 1051 0
 4248 24d8 F604C6E5 		strb	r0, [r6, #1270]
 4249 24dc 3DFCFFEA 		b	.L205
 4250              	.LVL378:
 4251              	.L177:
 840:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4252              		.loc 1 840 0
 4253 24e0 0910A0E1 		mov	r1, r9
 4254 24e4 0B00A0E1 		mov	r0, fp
 4255 24e8 FEFFFFEB 		bl	SensorGetControl
 842:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4256              		.loc 1 842 0
 4257 24ec 0910A0E1 		mov	r1, r9
 843:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4258              		.loc 1 843 0
 4259 24f0 0170A0E3 		mov	r7, #1
 4260              	.LVL379:
 840:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4261              		.loc 1 840 0
 4262 24f4 0030A0E1 		mov	r3, r0
 4263 24f8 1C31C4E5 		strb	r3, [r4, #284]
 842:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4264              		.loc 1 842 0
 4265 24fc 0A00A0E1 		mov	r0, sl
 841:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4266              		.loc 1 841 0
 4267 2500 9D34C6E5 		strb	r3, [r6, #1181]
 842:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4268              		.loc 1 842 0
 4269 2504 FEFFFFEB 		bl	SensorGetControl
 843:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4270              		.loc 1 843 0
 4271 2508 6071C4E5 		strb	r7, [r4, #352]
 4272 250c 1C71D4E5 		ldrb	r7, [r4, #284]	@ zero_extendqisi2
 4273              	.LVL380:
 842:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4274              		.loc 1 842 0
 4275 2510 00A0A0E1 		mov	sl, r0
 4276              	.LVL381:
 4277 2514 1D01C4E5 		strb	r0, [r4, #285]
 847:../uvc.c      **** 						 break;
 4278              		.loc 1 847 0
 4279 2518 F5FBFFEA 		b	.L179
 4280              	.LVL382:
 4281              	.L182:
 873:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4282              		.loc 1 873 0
 4283 251c 0A00A0E1 		mov	r0, sl
 4284              	.LVL383:
 4285 2520 0910A0E1 		mov	r1, r9
 4286 2524 FEFFFFEB 		bl	SensorGetControl
 4287              	.LVL384:
 879:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 4288              		.loc 1 879 0
 4289 2528 9EA0D6E5 		ldrb	sl, [r6, #158]	@ zero_extendqisi2
 880:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4290              		.loc 1 880 0
 4291 252c 01C0A0E3 		mov	ip, #1
 879:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 4292              		.loc 1 879 0
 4293 2530 1DA1C4E5 		strb	sl, [r4, #285]
 880:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4294              		.loc 1 880 0
 4295 2534 62C1C4E5 		strb	ip, [r4, #354]
 874:../uvc.c      **** 			 	 			if(Data0&0x80)
 4296              		.loc 1 874 0
 4297 2538 800010E3 		tst	r0, #128
 875:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 4298              		.loc 1 875 0
 4299 253c 0170A013 		movne	r7, #1
 4300              	.LVL385:
 877:../uvc.c      **** 			 	 				glEp0Buffer[0] = 0;
 4301              		.loc 1 877 0
 4302 2540 0B70A001 		moveq	r7, fp
 4303              	.LVL386:
 875:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 4304              		.loc 1 875 0
 4305 2544 1C71C415 		strneb	r7, [r4, #284]
 877:../uvc.c      **** 			 	 				glEp0Buffer[0] = 0;
 4306              		.loc 1 877 0
 4307 2548 1CB1C405 		streqb	fp, [r4, #284]
 878:../uvc.c      **** 			 	 			ExUCtrlParArry[CtrlID-0x20][13] = glEp0Buffer[0];
 4308              		.loc 1 878 0
 4309 254c 9D70C6E5 		strb	r7, [r6, #157]
 884:../uvc.c      **** 			 	 		 break;
 4310              		.loc 1 884 0
 4311 2550 E7FBFFEA 		b	.L179
 4312              	.LVL387:
 4313              	.L208:
1081:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4314              		.loc 1 1081 0
 4315 2554 0B00A0E1 		mov	r0, fp
 4316              	.LVL388:
 4317 2558 0910A0E1 		mov	r1, r9
 4318 255c FEFFFFEB 		bl	SensorGetControl
1084:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4319              		.loc 1 1084 0
 4320 2560 01C0A0E3 		mov	ip, #1
 4321 2564 43C1C4E5 		strb	ip, [r4, #323]
1082:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4322              		.loc 1 1082 0
 4323 2568 1905C6E5 		strb	r0, [r6, #1305]
1083:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4324              		.loc 1 1083 0
 4325 256c 1AA5D6E5 		ldrb	sl, [r6, #1306]	@ zero_extendqisi2
1081:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4326              		.loc 1 1081 0
 4327 2570 0070A0E1 		mov	r7, r0
 4328              	.LVL389:
1083:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4329              		.loc 1 1083 0
 4330 2574 FFA00AE2 		and	sl, sl, #255
 4331              	.LVL390:
1081:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4332              		.loc 1 1081 0
 4333 2578 1C01C4E5 		strb	r0, [r4, #284]
1083:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4334              		.loc 1 1083 0
 4335 257c 1DA1C4E5 		strb	sl, [r4, #285]
1088:../uvc.c      **** 					 break;
 4336              		.loc 1 1088 0
 4337 2580 DBFBFFEA 		b	.L179
 4338              	.LVL391:
 4339              	.L196:
 973:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4340              		.loc 1 973 0
 4341 2584 0710A0E1 		mov	r1, r7
 4342 2588 FEFFFFEB 		bl	SensorGetControl
 4343              	.LVL392:
 977:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 4344              		.loc 1 977 0
 4345 258c 0710A0E1 		mov	r1, r7
 974:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 4346              		.loc 1 974 0
 4347 2590 032000E2 		and	r2, r0, #3
 4348 2594 1C21C4E5 		strb	r2, [r4, #284]
 977:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 4349              		.loc 1 977 0
 4350 2598 0A00A0E1 		mov	r0, sl
 975:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4351              		.loc 1 975 0
 4352 259c ED24C6E5 		strb	r2, [r6, #1261]
 977:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 4353              		.loc 1 977 0
 4354 25a0 FEFFFFEB 		bl	SensorGetControl
 979:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4355              		.loc 1 979 0
 4356 25a4 0130A0E3 		mov	r3, #1
 4357 25a8 5531C4E5 		strb	r3, [r4, #341]
 977:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 4358              		.loc 1 977 0
 4359 25ac 1E01C4E5 		strb	r0, [r4, #286]
 978:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4360              		.loc 1 978 0
 4361 25b0 EE04C6E5 		strb	r0, [r6, #1262]
 4362 25b4 26FCFFEA 		b	.L197
 4363              	.LVL393:
 4364              	.L188:
 923:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4365              		.loc 1 923 0
 4366 25b8 FEFFFFEB 		bl	SensorGetControl
 4367              	.LVL394:
 926:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4368              		.loc 1 926 0
 4369 25bc 01C0A0E3 		mov	ip, #1
 4370 25c0 57C1C4E5 		strb	ip, [r4, #343]
 924:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4371              		.loc 1 924 0
 4372 25c4 D904C6E5 		strb	r0, [r6, #1241]
 925:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4373              		.loc 1 925 0
 4374 25c8 DA14D6E5 		ldrb	r1, [r6, #1242]	@ zero_extendqisi2
 923:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4375              		.loc 1 923 0
 4376 25cc 0070A0E1 		mov	r7, r0
 4377              	.LVL395:
 925:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4378              		.loc 1 925 0
 4379 25d0 FFA001E2 		and	sl, r1, #255
 4380              	.LVL396:
 923:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4381              		.loc 1 923 0
 4382 25d4 1C01C4E5 		strb	r0, [r4, #284]
 925:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4383              		.loc 1 925 0
 4384 25d8 1DA1C4E5 		strb	sl, [r4, #285]
 930:../uvc.c      **** 			 		 break;
 4385              		.loc 1 930 0
 4386 25dc C4FBFFEA 		b	.L179
 4387              	.LVL397:
 4388              	.L180:
 855:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4389              		.loc 1 855 0
 4390 25e0 0A00A0E1 		mov	r0, sl
 4391              	.LVL398:
 4392 25e4 0910A0E1 		mov	r1, r9
 4393 25e8 FEFFFFEB 		bl	SensorGetControl
 857:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4394              		.loc 1 857 0
 4395 25ec B104C6E5 		strb	r0, [r6, #1201]
 858:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4396              		.loc 1 858 0
 4397 25f0 B214D6E5 		ldrb	r1, [r6, #1202]	@ zero_extendqisi2
 855:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4398              		.loc 1 855 0
 4399 25f4 0070A0E1 		mov	r7, r0
 4400              	.LVL399:
 858:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4401              		.loc 1 858 0
 4402 25f8 FFA001E2 		and	sl, r1, #255
 856:../uvc.c      **** 			 	 			glEp0Buffer[0] = Data0;
 4403              		.loc 1 856 0
 4404 25fc 1C01C4E5 		strb	r0, [r4, #284]
 859:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4405              		.loc 1 859 0
 4406 2600 0100A0E3 		mov	r0, #1
 4407              	.LVL400:
 858:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4408              		.loc 1 858 0
 4409 2604 1DA1C4E5 		strb	sl, [r4, #285]
 859:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4410              		.loc 1 859 0
 4411 2608 6101C4E5 		strb	r0, [r4, #353]
 4412              	.LVL401:
 863:../uvc.c      **** 			 	 		 break;
 4413              		.loc 1 863 0
 4414 260c B8FBFFEA 		b	.L179
 4415              	.LVL402:
 4416              	.L210:
1098:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4417              		.loc 1 1098 0
 4418 2610 0A00A0E1 		mov	r0, sl
 4419              	.LVL403:
 4420 2614 0910A0E1 		mov	r1, r9
 4421 2618 FEFFFFEB 		bl	SensorGetControl
1100:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 4422              		.loc 1 1100 0
 4423 261c BEA1D6E5 		ldrb	sl, [r6, #446]	@ zero_extendqisi2
 4424 2620 1DA1CBE5 		strb	sl, [fp, #285]
1098:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4425              		.loc 1 1098 0
 4426 2624 0070A0E1 		mov	r7, r0
 4427 2628 1C01CBE5 		strb	r0, [fp, #284]
1099:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
 4428              		.loc 1 1099 0
 4429 262c BD01C6E5 		strb	r0, [r6, #445]
1101:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4430              		.loc 1 1101 0
 4431 2630 0100A0E3 		mov	r0, #1
 4432 2634 3C01C4E5 		strb	r0, [r4, #316]
 4433              	.LVL404:
1105:../uvc.c      **** 					 break;
 4434              		.loc 1 1105 0
 4435 2638 ADFBFFEA 		b	.L179
 4436              	.LVL405:
 4437              	.L218:
1153:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4438              		.loc 1 1153 0
 4439 263c 0A00A0E1 		mov	r0, sl
 4440              	.LVL406:
 4441 2640 0910A0E1 		mov	r1, r9
 4442 2644 14308DE5 		str	r3, [sp, #20]
 4443 2648 FEFFFFEB 		bl	SensorGetControl
1154:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4444              		.loc 1 1154 0
 4445 264c 84A084E0 		add	sl, r4, r4, asl #1
 4446 2650 8A6186E0 		add	r6, r6, sl, asl #3
1155:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4447              		.loc 1 1155 0
 4448 2654 8EA1D6E5 		ldrb	sl, [r6, #398]	@ zero_extendqisi2
1156:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4449              		.loc 1 1156 0
 4450 2658 0110A0E3 		mov	r1, #1
1155:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4451              		.loc 1 1155 0
 4452 265c 1DA1CBE5 		strb	sl, [fp, #285]
1153:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4453              		.loc 1 1153 0
 4454 2660 1C01CBE5 		strb	r0, [fp, #284]
1154:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4455              		.loc 1 1154 0
 4456 2664 8D01C6E5 		strb	r0, [r6, #397]
1156:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4457              		.loc 1 1156 0
 4458 2668 14C09DE5 		ldr	ip, [sp, #20]
1153:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4459              		.loc 1 1153 0
 4460 266c 0070A0E1 		mov	r7, r0
 4461              	.LVL407:
1156:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4462              		.loc 1 1156 0
 4463 2670 3C11CCE5 		strb	r1, [ip, #316]
 4464              	.LVL408:
1162:../uvc.c      **** 					 break;
 4465              		.loc 1 1162 0
 4466 2674 9EFBFFEA 		b	.L179
 4467              	.LVL409:
 4468              	.L212:
1112:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4469              		.loc 1 1112 0
 4470 2678 0A00A0E1 		mov	r0, sl
 4471              	.LVL410:
 4472 267c 0910A0E1 		mov	r1, r9
 4473 2680 FEFFFFEB 		bl	SensorGetControl
1115:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4474              		.loc 1 1115 0
 4475 2684 66A2D6E5 		ldrb	sl, [r6, #614]	@ zero_extendqisi2
1117:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4476              		.loc 1 1117 0
 4477 2688 0110A0E3 		mov	r1, #1
1115:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4478              		.loc 1 1115 0
 4479 268c 1DA1C4E5 		strb	sl, [r4, #285]
1117:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4480              		.loc 1 1117 0
 4481 2690 4511C4E5 		strb	r1, [r4, #325]
1114:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 4482              		.loc 1 1114 0
 4483 2694 037000E2 		and	r7, r0, #3
 4484              	.LVL411:
1113:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4485              		.loc 1 1113 0
 4486 2698 6502C6E5 		strb	r0, [r6, #613]
1114:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 4487              		.loc 1 1114 0
 4488 269c 1C71C4E5 		strb	r7, [r4, #284]
1121:../uvc.c      **** 					 break;
 4489              		.loc 1 1121 0
 4490 26a0 93FBFFEA 		b	.L179
 4491              	.LVL412:
 4492              	.L214:
1134:../uvc.c      **** 		 	 			Data0 = SensorGetControl(0x1, devAdd); //get resolution bit7 for main frequency information
 4493              		.loc 1 1134 0
 4494 26a4 0100A0E3 		mov	r0, #1
 4495              	.LVL413:
 4496 26a8 0910A0E1 		mov	r1, r9
 4497 26ac FEFFFFEB 		bl	SensorGetControl
 4498              	.LVL414:
1139:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4499              		.loc 1 1139 0
 4500 26b0 0130A0E3 		mov	r3, #1
1138:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4501              		.loc 1 1138 0
 4502 26b4 EEA1D6E5 		ldrb	sl, [r6, #494]	@ zero_extendqisi2
1139:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4503              		.loc 1 1139 0
 4504 26b8 4031C4E5 		strb	r3, [r4, #320]
1138:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4505              		.loc 1 1138 0
 4506 26bc 1DA1C4E5 		strb	sl, [r4, #285]
1135:../uvc.c      **** 		 	 			glEp0Buffer[0] = (Data0&0x80)>>7;
 4507              		.loc 1 1135 0
 4508 26c0 A003A0E1 		mov	r0, r0, lsr #7
 4509              	.LVL415:
1136:../uvc.c      **** 		 	 			glEp0Buffer[0]++;
 4510              		.loc 1 1136 0
 4511 26c4 037080E0 		add	r7, r0, r3
 4512              	.LVL416:
 4513 26c8 FF7007E2 		and	r7, r7, #255
 4514              	.LVL417:
 4515 26cc 1C71C4E5 		strb	r7, [r4, #284]
1137:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4516              		.loc 1 1137 0
 4517 26d0 ED71C6E5 		strb	r7, [r6, #493]
1144:../uvc.c      **** 					 break;
 4518              		.loc 1 1144 0
 4519 26d4 86FBFFEA 		b	.L179
 4520              	.LVL418:
 4521              	.L206:
1064:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4522              		.loc 1 1064 0
 4523 26d8 0A00A0E1 		mov	r0, sl
 4524              	.LVL419:
 4525 26dc 0910A0E1 		mov	r1, r9
 4526 26e0 FEFFFFEB 		bl	SensorGetControl
1068:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4527              		.loc 1 1068 0
 4528 26e4 0130A0E3 		mov	r3, #1
 4529 26e8 3C31C4E5 		strb	r3, [r4, #316]
1065:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x1;
 4530              		.loc 1 1065 0
 4531 26ec 037000E0 		and	r7, r0, r3
 4532              	.LVL420:
1066:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4533              		.loc 1 1066 0
 4534 26f0 0575C6E5 		strb	r7, [r6, #1285]
1067:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4535              		.loc 1 1067 0
 4536 26f4 0605D6E5 		ldrb	r0, [r6, #1286]	@ zero_extendqisi2
1065:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x1;
 4537              		.loc 1 1065 0
 4538 26f8 1C71C4E5 		strb	r7, [r4, #284]
1067:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4539              		.loc 1 1067 0
 4540 26fc FFA000E2 		and	sl, r0, #255
 4541              	.LVL421:
 4542 2700 1DA1C4E5 		strb	sl, [r4, #285]
1072:../uvc.c      **** 					 break;
 4543              		.loc 1 1072 0
 4544 2704 7AFBFFEA 		b	.L179
 4545              	.LVL422:
 4546              	.L319:
1010:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4547              		.loc 1 1010 0
 4548 2708 0A00A0E1 		mov	r0, sl
 4549 270c 0910A0E1 		mov	r1, r9
 4550 2710 FEFFFFEB 		bl	SensorGetControl
 4551              	.LVL423:
1012:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4552              		.loc 1 1012 0
 4553 2714 0170A0E3 		mov	r7, #1
 4554              	.LVL424:
 4555 2718 3D71C4E5 		strb	r7, [r4, #317]
1011:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 4556              		.loc 1 1011 0
 4557 271c A501C6E5 		strb	r0, [r6, #421]
 4558 2720 DCFBFFEA 		b	.L199
 4559              	.LVL425:
 4560              	.L186:
 898:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4561              		.loc 1 898 0
 4562 2724 FEFFFFEB 		bl	SensorGetControl
 4563              	.LVL426:
 904:../uvc.c      **** 						CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
 4564              		.loc 1 904 0
 4565 2728 00181FE5 		ldr	r1, .L325+60
 899:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
 4566              		.loc 1 899 0
 4567 272c C504C6E5 		strb	r0, [r6, #1221]
 902:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4568              		.loc 1 902 0
 4569 2730 C664D6E5 		ldrb	r6, [r6, #1222]	@ zero_extendqisi2
 898:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4570              		.loc 1 898 0
 4571 2734 0070A0E1 		mov	r7, r0
 4572              	.LVL427:
 900:../uvc.c      **** 		 	 			Data1 = (Data0&0x70)>>4;
 4573              		.loc 1 900 0
 4574 2738 700000E2 		and	r0, r0, #112
 4575              	.LVL428:
 4576 273c 20C2A0E1 		mov	ip, r0, lsr #4
 4577              	.LVL429:
 901:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 4578              		.loc 1 901 0
 4579 2740 1CC1C4E5 		strb	ip, [r4, #284]
 902:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4580              		.loc 1 902 0
 4581 2744 1D61C4E5 		strb	r6, [r4, #285]
 904:../uvc.c      **** 						CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
 4582              		.loc 1 904 0
 4583 2748 0C20A0E1 		mov	r2, ip
 4584 274c 0C30A0E1 		mov	r3, ip
 4585 2750 0400A0E3 		mov	r0, #4
 4586 2754 00708DE5 		str	r7, [sp, #0]
 4587 2758 14C08DE5 		str	ip, [sp, #20]
 4588 275c FEFFFFEB 		bl	CyU3PDebugPrint
 4589              	.LVL430:
 4590 2760 1C71D4E5 		ldrb	r7, [r4, #284]	@ zero_extendqisi2
 4591              	.LVL431:
 4592 2764 14C09DE5 		ldr	ip, [sp, #20]
 4593 2768 19FCFFEA 		b	.L187
 4594              	.LVL432:
 4595              	.L260:
1376:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 4596              		.loc 1 1376 0
 4597 276c 0A20A0E1 		mov	r2, sl
 4598 2770 0730A0E1 		mov	r3, r7
 4599 2774 80E0A0E3 		mov	lr, #128
 4600 2778 00C0A0E3 		mov	ip, #0
 4601 277c 1B10A0E3 		mov	r1, #27
 4602 2780 54081FE5 		ldr	r0, .L325+64
 4603 2784 00E08DE5 		str	lr, [sp, #0]
 4604 2788 04C08DE5 		str	ip, [sp, #4]
 4605 278c FEFFFFEB 		bl	cmdSet
 4606              	.LVL433:
1378:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
 4607              		.loc 1 1378 0
 4608 2790 0820A0E1 		mov	r2, r8
 4609 2794 18809DE5 		ldr	r8, [sp, #24]
 4610              	.LVL434:
 4611 2798 01A0A0E3 		mov	sl, #1
 4612              	.LVL435:
 4613 279c 1B10A0E3 		mov	r1, #27
 4614 27a0 0730A0E1 		mov	r3, r7
 4615 27a4 78081FE5 		ldr	r0, .L325+64
 4616 27a8 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 4617 27ac FEFFFFEB 		bl	cmdSet
 4618              	.LVL436:
 4619 27b0 87FCFFEA 		b	.L259
 4620              	.LVL437:
 4621              	.L318:
 935:../uvc.c      **** 						if(sendData >= 3){
 4622              		.loc 1 935 0
 4623 27b4 020057E3 		cmp	r7, #2
 4624 27b8 0D00008A 		bhi	.L324
 4625              	.LVL438:
 4626              	.L191:
 940:../uvc.c      **** 						sendData += 4;
 4627              		.loc 1 940 0
 4628 27bc 047087E2 		add	r7, r7, #4
 4629              	.LVL439:
 4630 27c0 FF7007E2 		and	r7, r7, #255
 4631              	.LVL440:
 4632 27c4 69FBFFEA 		b	.L310
 4633              	.LVL441:
 4634              	.L323:
1351:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 4635              		.loc 1 1351 0
 4636 27c8 0830A0E1 		mov	r3, r8
 4637 27cc 1910A0E3 		mov	r1, #25
 4638 27d0 0080A0E3 		mov	r8, #0
 4639              	.LVL442:
 4640 27d4 0920A0E1 		mov	r2, r9
 4641 27d8 AC081FE5 		ldr	r0, .L325+64
 4642 27dc 00E08DE5 		str	lr, [sp, #0]
 4643 27e0 04808DE5 		str	r8, [sp, #4]
 4644 27e4 FEFFFFEB 		bl	cmdSet
 4645              	.LVL443:
 4646 27e8 14FEFFEA 		b	.L258
 4647              	.LVL444:
 4648              	.L309:
 4649 27ec B4081FE5 		ldr	r0, .L325+76
 4650 27f0 29FBFFEA 		b	.L176
 4651              	.LVL445:
 4652              	.L324:
 936:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 4653              		.loc 1 936 0
 4654 27f4 0730A0E1 		mov	r3, r7
 4655 27f8 0400A0E3 		mov	r0, #4
 4656              	.LVL446:
 4657 27fc CC181FE5 		ldr	r1, .L325+68
 4658 2800 FEFFFFEB 		bl	CyU3PDebugPrint
 4659              	.LVL447:
 938:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 4660              		.loc 1 938 0
 4661 2804 D0081FE5 		ldr	r0, .L325+72
 4662 2808 0020A0E3 		mov	r2, #0
 937:../uvc.c      **** 							sendData = 0; //set back to default
 4663              		.loc 1 937 0
 4664 280c 0270A0E1 		mov	r7, r2
 938:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 4665              		.loc 1 938 0
 4666 2810 2D24C0E5 		strb	r2, [r0, #1069]
 4667 2814 E8FFFFEA 		b	.L191
 4668              	.LVL448:
 4669              	.L289:
 4670 2818 E0081FE5 		ldr	r0, .L325+76
 4671              	.LVL449:
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 4672              		.loc 1 791 0
 4673 281c 0030A0E3 		mov	r3, #0
 4674 2820 16FBFFEA 		b	.L302
 4675              	.LVL450:
 4676              	.L291:
 4677 2824 0030A0E3 		mov	r3, #0
 4678 2828 0CFCFFEA 		b	.L303
 4679              		.cfi_endproc
 4680              	.LFE3:
 4682              		.align	2
 4683              		.global	CTControlHandle
 4685              	CTControlHandle:
 4686              	.LFB4:
1715:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 4687              		.loc 1 1715 0
 4688              		.cfi_startproc
 4689              		@ args = 0, pretend = 0, frame = 64
 4690              		@ frame_needed = 0, uses_anonymous_args = 0
 4691              	.LVL451:
 4692 282c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4693              	.LCFI18:
 4694              		.cfi_def_cfa_offset 36
1734:../uvc.c      ****     reqData = bRequest;
 4695              		.loc 1 1734 0
 4696 2830 64A99FE5 		ldr	sl, .L412
 4697              		.cfi_offset 14, -4
 4698              		.cfi_offset 11, -8
 4699              		.cfi_offset 10, -12
 4700              		.cfi_offset 9, -16
 4701              		.cfi_offset 8, -20
 4702              		.cfi_offset 7, -24
 4703              		.cfi_offset 6, -28
 4704              		.cfi_offset 5, -32
 4705              		.cfi_offset 4, -36
1726:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 4706              		.loc 1 1726 0
 4707 2834 64899FE5 		ldr	r8, .L412+4
1734:../uvc.c      ****     reqData = bRequest;
 4708              		.loc 1 1734 0
 4709 2838 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
1726:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 4710              		.loc 1 1726 0
 4711 283c 8090A0E1 		mov	r9, r0, asl #1
 4712 2840 002089E0 		add	r2, r9, r0
 4713 2844 822188E0 		add	r2, r8, r2, asl #3
1736:../uvc.c      ****     switch (bRequest)
 4714              		.loc 1 1736 0
 4715 2848 830055E3 		cmp	r5, #131
1715:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 4716              		.loc 1 1715 0
 4717 284c 5CD04DE2 		sub	sp, sp, #92
 4718              	.LCFI19:
 4719              		.cfi_def_cfa_offset 128
1715:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 4720              		.loc 1 1715 0
 4721 2850 0060A0E1 		mov	r6, r0
1726:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 4722              		.loc 1 1726 0
 4723 2854 2F35D2E5 		ldrb	r3, [r2, #1327]	@ zero_extendqisi2
 4724              	.LVL452:
1727:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4725              		.loc 1 1727 0
 4726 2858 20B5D2E5 		ldrb	fp, [r2, #1312]	@ zero_extendqisi2
 4727              	.LVL453:
1729:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 4728              		.loc 1 1729 0
 4729 285c 2275D2E5 		ldrb	r7, [r2, #1314]	@ zero_extendqisi2
 4730              	.LVL454:
1736:../uvc.c      ****     switch (bRequest)
 4731              		.loc 1 1736 0
 4732 2860 7600000A 		beq	.L332
 4733 2864 2100009A 		bls	.L407
 4734 2868 850055E3 		cmp	r5, #133
 4735 286c 5900000A 		beq	.L334
 4736 2870 4E00003A 		bcc	.L333
 4737 2874 860055E3 		cmp	r5, #134
 4738 2878 8000000A 		beq	.L335
 4739 287c 870055E3 		cmp	r5, #135
 4740 2880 7600000A 		beq	.L408
 4741              	.L328:
1943:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 4742              		.loc 1 1943 0
 4743 2884 0000A0E3 		mov	r0, #0
 4744              	.LVL455:
 4745 2888 0110A0E3 		mov	r1, #1
 4746 288c 0020A0E1 		mov	r2, r0
 4747 2890 FEFFFFEB 		bl	CyU3PUsbStall
 4748              	.LVL456:
 4749 2894 08499FE5 		ldr	r4, .L412+8
1944:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 4750              		.loc 1 1944 0
 4751 2898 0620A0E1 		mov	r2, r6
 4752 289c 0400A0E3 		mov	r0, #4
 4753 28a0 00199FE5 		ldr	r1, .L412+12
 4754 28a4 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 4755 28a8 FEFFFFEB 		bl	CyU3PDebugPrint
1945:../uvc.c      **** 			  break;
 4756              		.loc 1 1945 0
 4757 28ac FFC0A0E3 		mov	ip, #255
 4758 28b0 0C60A0E1 		mov	r6, ip
 4759 28b4 0C80A0E1 		mov	r8, ip
 4760              	.LVL457:
 4761              	.L338:
1949:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 4762              		.loc 1 1949 0
 4763 28b8 1EE1D4E5 		ldrb	lr, [r4, #286]	@ zero_extendqisi2
 4764 28bc 08C08DE5 		str	ip, [sp, #8]
 4765 28c0 E4189FE5 		ldr	r1, .L412+16
 4766 28c4 FFC0A0E3 		mov	ip, #255
 4767 28c8 0520A0E1 		mov	r2, r5
 4768 28cc 0830A0E1 		mov	r3, r8
 4769 28d0 0400A0E3 		mov	r0, #4
 4770 28d4 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 4771 28d8 0CC08DE5 		str	ip, [sp, #12]
 4772 28dc 10E08DE5 		str	lr, [sp, #16]
 4773 28e0 14708DE5 		str	r7, [sp, #20]
 4774 28e4 FEFFFFEB 		bl	CyU3PDebugPrint
1950:../uvc.c      **** }
 4775              		.loc 1 1950 0
 4776 28e8 5CD08DE2 		add	sp, sp, #92
 4777 28ec F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 4778              	.LVL458:
 4779              	.L407:
1736:../uvc.c      ****     switch (bRequest)
 4780              		.loc 1 1736 0
 4781 28f0 810055E3 		cmp	r5, #129
 4782 28f4 4200000A 		beq	.L330
 4783 28f8 1100009A 		bls	.L409
1765:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 4784              		.loc 1 1765 0
 4785 28fc A0489FE5 		ldr	r4, .L412+8
 4786 2900 2315D2E5 		ldrb	r1, [r2, #1315]	@ zero_extendqisi2
1766:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 4787              		.loc 1 1766 0
 4788 2904 2465D2E5 		ldrb	r6, [r2, #1316]	@ zero_extendqisi2
1767:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 4789              		.loc 1 1767 0
 4790 2908 0A0050E3 		cmp	r0, #10
1765:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 4791              		.loc 1 1765 0
 4792 290c 1C11C4E5 		strb	r1, [r4, #284]
1766:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 4793              		.loc 1 1766 0
 4794 2910 1D61C4E5 		strb	r6, [r4, #285]
1767:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 4795              		.loc 1 1767 0
 4796 2914 2C00000A 		beq	.L406
 4797              	.LVL459:
 4798              	.L345:
1801:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 4799              		.loc 1 1801 0
 4800 2918 00E0A0E3 		mov	lr, #0
 4801 291c 1EE1C4E5 		strb	lr, [r4, #286]
 4802              	.L346:
1802:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 4803              		.loc 1 1802 0
 4804 2920 0030A0E3 		mov	r3, #0
1803:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4805              		.loc 1 1803 0
 4806 2924 0700A0E1 		mov	r0, r7
 4807              	.LVL460:
 4808 2928 80189FE5 		ldr	r1, .L412+20
1805:../uvc.c      **** 			  break;
 4809              		.loc 1 1805 0
 4810 292c FF60A0E3 		mov	r6, #255
1802:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 4811              		.loc 1 1802 0
 4812 2930 1F31C4E5 		strb	r3, [r4, #287]
1805:../uvc.c      **** 			  break;
 4813              		.loc 1 1805 0
 4814 2934 0680A0E1 		mov	r8, r6
1803:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4815              		.loc 1 1803 0
 4816 2938 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4817              	.LVL461:
 4818 293c 1CC1D4E5 		ldrb	ip, [r4, #284]	@ zero_extendqisi2
1805:../uvc.c      **** 			  break;
 4819              		.loc 1 1805 0
 4820 2940 DCFFFFEA 		b	.L338
 4821              	.LVL462:
 4822              	.L409:
1736:../uvc.c      ****     switch (bRequest)
 4823              		.loc 1 1736 0
 4824 2944 010055E3 		cmp	r5, #1
 4825 2948 CDFFFF1A 		bne	.L328
1807:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4826              		.loc 1 1807 0
 4827 294c 50489FE5 		ldr	r4, .L412+8
 4828 2950 56208DE2 		add	r2, sp, #86
 4829 2954 2000A0E3 		mov	r0, #32
 4830              	.LVL463:
 4831 2958 471F84E2 		add	r1, r4, #284
 4832 295c 2C308DE5 		str	r3, [sp, #44]
 4833 2960 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4834              	.LVL464:
1809:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 4835              		.loc 1 1809 0
 4836 2964 1C01D4E5 		ldrb	r0, [r4, #284]	@ zero_extendqisi2
1810:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4837              		.loc 1 1810 0
 4838 2968 1DC1D4E5 		ldrb	ip, [r4, #285]	@ zero_extendqisi2
1813:../uvc.c      **** 			  switch(CtrlID)
 4839              		.loc 1 1813 0
 4840 296c 012046E2 		sub	r2, r6, #1
1809:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 4841              		.loc 1 1809 0
 4842 2970 30008DE5 		str	r0, [sp, #48]
 4843              	.LVL465:
1810:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4844              		.loc 1 1810 0
 4845 2974 34C08DE5 		str	ip, [sp, #52]
 4846              	.LVL466:
1813:../uvc.c      **** 			  switch(CtrlID)
 4847              		.loc 1 1813 0
 4848 2978 2C309DE5 		ldr	r3, [sp, #44]
 4849 297c 090052E3 		cmp	r2, #9
 4850 2980 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4851 2984 550100EA 		b	.L347
 4852              	.L352:
 4853 2988 9C2E0000 		.word	.L348
 4854 298c E02E0000 		.word	.L347
 4855 2990 AC2B0000 		.word	.L349
 4856 2994 E02E0000 		.word	.L347
 4857 2998 E02E0000 		.word	.L347
 4858 299c E02E0000 		.word	.L347
 4859 29a0 282B0000 		.word	.L350
 4860 29a4 E02E0000 		.word	.L347
 4861 29a8 E02E0000 		.word	.L347
 4862 29ac AC2A0000 		.word	.L351
 4863              	.LVL467:
 4864              	.L333:
1783:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 4865              		.loc 1 1783 0
 4866 29b0 EC479FE5 		ldr	r4, .L412+8
 4867 29b4 2785D2E5 		ldrb	r8, [r2, #1319]	@ zero_extendqisi2
1784:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4868              		.loc 1 1784 0
 4869 29b8 2825D2E5 		ldrb	r2, [r2, #1320]	@ zero_extendqisi2
1785:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4870              		.loc 1 1785 0
 4871 29bc 0A0050E3 		cmp	r0, #10
1783:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 4872              		.loc 1 1783 0
 4873 29c0 1C81C4E5 		strb	r8, [r4, #284]
1784:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4874              		.loc 1 1784 0
 4875 29c4 1D21C4E5 		strb	r2, [r4, #285]
1785:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4876              		.loc 1 1785 0
 4877 29c8 D2FFFF1A 		bne	.L345
 4878              	.LVL468:
 4879              	.L406:
1800:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4880              		.loc 1 1800 0 discriminator 1
 4881 29cc 0110A0E3 		mov	r1, #1
 4882 29d0 1E11C4E5 		strb	r1, [r4, #286]
 4883 29d4 D1FFFFEA 		b	.L346
 4884              	.LVL469:
 4885              	.L334:
1740:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 4886              		.loc 1 1740 0
 4887 29d8 C4479FE5 		ldr	r4, .L412+8
1741:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 4888              		.loc 1 1741 0
 4889 29dc 0030A0E3 		mov	r3, #0
 4890              	.LVL470:
1742:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4891              		.loc 1 1742 0
 4892 29e0 0200A0E3 		mov	r0, #2
 4893              	.LVL471:
 4894 29e4 471F84E2 		add	r1, r4, #284
1744:../uvc.c      **** 			  break;
 4895              		.loc 1 1744 0
 4896 29e8 FF60A0E3 		mov	r6, #255
1740:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 4897              		.loc 1 1740 0
 4898 29ec 1C71C4E5 		strb	r7, [r4, #284]
1741:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 4899              		.loc 1 1741 0
 4900 29f0 1D31C4E5 		strb	r3, [r4, #285]
1744:../uvc.c      **** 			  break;
 4901              		.loc 1 1744 0
 4902 29f4 0680A0E1 		mov	r8, r6
1742:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4903              		.loc 1 1742 0
 4904 29f8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4905              	.LVL472:
 4906 29fc 1CC1D4E5 		ldrb	ip, [r4, #284]	@ zero_extendqisi2
1744:../uvc.c      **** 			  break;
 4907              		.loc 1 1744 0
 4908 2a00 ACFFFFEA 		b	.L338
 4909              	.LVL473:
 4910              	.L330:
1750:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 4911              		.loc 1 1750 0
 4912 2a04 98479FE5 		ldr	r4, .L412+8
 4913 2a08 2DA5D2E5 		ldrb	sl, [r2, #1325]	@ zero_extendqisi2
1751:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4914              		.loc 1 1751 0
 4915 2a0c 2EC5D2E5 		ldrb	ip, [r2, #1326]	@ zero_extendqisi2
1752:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4916              		.loc 1 1752 0
 4917 2a10 0080A0E3 		mov	r8, #0
1758:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4918              		.loc 1 1758 0
 4919 2a14 0700A0E1 		mov	r0, r7
 4920              	.LVL474:
 4921 2a18 471F84E2 		add	r1, r4, #284
1763:../uvc.c      **** 			  break;
 4922              		.loc 1 1763 0
 4923 2a1c FF60A0E3 		mov	r6, #255
1751:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4924              		.loc 1 1751 0
 4925 2a20 1DC1C4E5 		strb	ip, [r4, #285]
1752:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4926              		.loc 1 1752 0
 4927 2a24 1E81C4E5 		strb	r8, [r4, #286]
1753:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4928              		.loc 1 1753 0
 4929 2a28 1F81C4E5 		strb	r8, [r4, #287]
 4930              	.LVL475:
1750:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 4931              		.loc 1 1750 0
 4932 2a2c 1CA1C4E5 		strb	sl, [r4, #284]
1763:../uvc.c      **** 			  break;
 4933              		.loc 1 1763 0
 4934 2a30 0680A0E1 		mov	r8, r6
1758:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4935              		.loc 1 1758 0
 4936 2a34 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4937              	.LVL476:
 4938 2a38 0AC0A0E1 		mov	ip, sl
1763:../uvc.c      **** 			  break;
 4939              		.loc 1 1763 0
 4940 2a3c 9DFFFFEA 		b	.L338
 4941              	.LVL477:
 4942              	.L332:
1774:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 4943              		.loc 1 1774 0
 4944 2a40 5C479FE5 		ldr	r4, .L412+8
 4945 2a44 2535D2E5 		ldrb	r3, [r2, #1317]	@ zero_extendqisi2
 4946              	.LVL478:
1775:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4947              		.loc 1 1775 0
 4948 2a48 26E5D2E5 		ldrb	lr, [r2, #1318]	@ zero_extendqisi2
1776:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4949              		.loc 1 1776 0
 4950 2a4c 0A0050E3 		cmp	r0, #10
1774:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 4951              		.loc 1 1774 0
 4952 2a50 1C31C4E5 		strb	r3, [r4, #284]
1775:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4953              		.loc 1 1775 0
 4954 2a54 1DE1C4E5 		strb	lr, [r4, #285]
1776:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4955              		.loc 1 1776 0
 4956 2a58 AEFFFF1A 		bne	.L345
 4957 2a5c DAFFFFEA 		b	.L406
 4958              	.LVL479:
 4959              	.L408:
1798:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 4960              		.loc 1 1798 0
 4961 2a60 3C479FE5 		ldr	r4, .L412+8
 4962 2a64 2B65D2E5 		ldrb	r6, [r2, #1323]	@ zero_extendqisi2
1799:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4963              		.loc 1 1799 0
 4964 2a68 2CC5D2E5 		ldrb	ip, [r2, #1324]	@ zero_extendqisi2
1800:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4965              		.loc 1 1800 0
 4966 2a6c 0A0050E3 		cmp	r0, #10
1798:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 4967              		.loc 1 1798 0
 4968 2a70 1C61C4E5 		strb	r6, [r4, #284]
1799:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4969              		.loc 1 1799 0
 4970 2a74 1DC1C4E5 		strb	ip, [r4, #285]
1800:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4971              		.loc 1 1800 0
 4972 2a78 A6FFFF1A 		bne	.L345
 4973 2a7c D2FFFFEA 		b	.L406
 4974              	.L335:
1792:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 4975              		.loc 1 1792 0
 4976 2a80 1C479FE5 		ldr	r4, .L412+8
 4977 2a84 2905D2E5 		ldrb	r0, [r2, #1321]	@ zero_extendqisi2
 4978              	.LVL480:
 4979 2a88 0410A0E1 		mov	r1, r4
 4980 2a8c 1C01E1E5 		strb	r0, [r1, #284]!
1796:../uvc.c      **** 			  break;
 4981              		.loc 1 1796 0
 4982 2a90 FF60A0E3 		mov	r6, #255
1793:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4983              		.loc 1 1793 0
 4984 2a94 0100A0E3 		mov	r0, #1
 4985 2a98 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4986              	.LVL481:
1796:../uvc.c      **** 			  break;
 4987              		.loc 1 1796 0
 4988 2a9c 0680A0E1 		mov	r8, r6
1793:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4989              		.loc 1 1793 0
 4990 2aa0 1CC1D4E5 		ldrb	ip, [r4, #284]	@ zero_extendqisi2
1796:../uvc.c      **** 			  break;
 4991              		.loc 1 1796 0
 4992 2aa4 0170A0E3 		mov	r7, #1
 4993 2aa8 82FFFFEA 		b	.L338
 4994              	.LVL482:
 4995              	.L351:
1922:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4996              		.loc 1 1922 0
 4997 2aac 00679FE5 		ldr	r6, .L412+24
 4998 2ab0 0010E0E3 		mvn	r1, #0
 4999 2ab4 1C0096E5 		ldr	r0, [r6, #28]
 5000 2ab8 2C308DE5 		str	r3, [sp, #44]
 5001 2abc FEFFFFEB 		bl	_txe_mutex_get
1923:../uvc.c      **** 					  if(getData == 1)
 5002              		.loc 1 1923 0
 5003 2ac0 30E09DE5 		ldr	lr, [sp, #48]
 5004 2ac4 2C309DE5 		ldr	r3, [sp, #44]
 5005 2ac8 01005EE3 		cmp	lr, #1
 5006 2acc AA01000A 		beq	.L410
1925:../uvc.c      **** 					  else if(getData == 0xff)
 5007              		.loc 1 1925 0
 5008 2ad0 FF005EE3 		cmp	lr, #255
 5009 2ad4 9F01000A 		beq	.L411
1928:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
 5010              		.loc 1 1928 0
 5011 2ad8 0080A0E3 		mov	r8, #0
 5012 2adc 0600A0E1 		mov	r0, r6
 5013 2ae0 2310A0E3 		mov	r1, #35
 5014 2ae4 0B20A0E1 		mov	r2, fp
 5015 2ae8 00808DE5 		str	r8, [sp, #0]
 5016 2aec 04808DE5 		str	r8, [sp, #4]
 5017 2af0 FEFFFFEB 		bl	cmdSet
 5018              	.L404:
1931:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5019              		.loc 1 1931 0
 5020 2af4 1C0096E5 		ldr	r0, [r6, #28]
 5021 2af8 FEFFFFEB 		bl	_txe_mutex_put
1933:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 5022              		.loc 1 1933 0
 5023 2afc 30809DE5 		ldr	r8, [sp, #48]
 5024 2b00 34609DE5 		ldr	r6, [sp, #52]
 5025 2b04 1EC1D4E5 		ldrb	ip, [r4, #286]	@ zero_extendqisi2
 5026 2b08 0400A0E3 		mov	r0, #4
 5027 2b0c A4169FE5 		ldr	r1, .L412+28
 5028 2b10 0820A0E1 		mov	r2, r8
 5029 2b14 0630A0E1 		mov	r3, r6
 5030 2b18 00C08DE5 		str	ip, [sp, #0]
 5031 2b1c FEFFFFEB 		bl	CyU3PDebugPrint
1934:../uvc.c      **** 					  break;
 5032              		.loc 1 1934 0
 5033 2b20 FFC0A0E3 		mov	ip, #255
 5034 2b24 63FFFFEA 		b	.L338
 5035              	.LVL483:
 5036              	.L350:
1899:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 5037              		.loc 1 1899 0
 5038 2b28 4585D8E5 		ldrb	r8, [r8, #1349]	@ zero_extendqisi2
 5039 2b2c 010058E3 		cmp	r8, #1
 5040 2b30 08005813 		cmpne	r8, #8
 5041 2b34 0000A013 		movne	r0, #0
 5042 2b38 0100A003 		moveq	r0, #1
 5043 2b3c 8101001A 		bne	.L401
 5044              	.LVL484:
1902:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5045              		.loc 1 1902 0
 5046 2b40 6C869FE5 		ldr	r8, .L412+24
 5047 2b44 0010E0E3 		mvn	r1, #0
 5048 2b48 1C0098E5 		ldr	r0, [r8, #28]
 5049 2b4c 2C308DE5 		str	r3, [sp, #44]
 5050 2b50 FEFFFFEB 		bl	_txe_mutex_get
1903:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 5051              		.loc 1 1903 0
 5052 2b54 30A09DE5 		ldr	sl, [sp, #48]
 5053 2b58 2210A0E3 		mov	r1, #34
 5054 2b5c 0B20A0E1 		mov	r2, fp
 5055 2b60 2C309DE5 		ldr	r3, [sp, #44]
 5056 2b64 00C0A0E3 		mov	ip, #0
 5057 2b68 0800A0E1 		mov	r0, r8
 5058 2b6c 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 5059 2b70 FEFFFFEB 		bl	cmdSet
1904:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5060              		.loc 1 1904 0
 5061 2b74 1C0098E5 		ldr	r0, [r8, #28]
 5062 2b78 FEFFFFEB 		bl	_txe_mutex_put
1907:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 5063              		.loc 1 1907 0
 5064 2b7c 1C069FE5 		ldr	r0, .L412+4
1908:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5065              		.loc 1 1908 0
 5066 2b80 34209DE5 		ldr	r2, [sp, #52]
1907:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 5067              		.loc 1 1907 0
 5068 2b84 061089E0 		add	r1, r9, r6
 5069 2b88 813180E0 		add	r3, r0, r1, asl #3
1909:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5070              		.loc 1 1909 0
 5071 2b8c 0160A0E3 		mov	r6, #1
1907:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 5072              		.loc 1 1907 0
 5073 2b90 2DA5C3E5 		strb	sl, [r3, #1325]
1908:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5074              		.loc 1 1908 0
 5075 2b94 2E25C3E5 		strb	r2, [r3, #1326]
1909:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5076              		.loc 1 1909 0
 5077 2b98 3065C3E5 		strb	r6, [r3, #1328]
 5078              	.LVL485:
 5079              	.L402:
1911:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 5080              		.loc 1 1911 0
 5081 2b9c 1C81D4E5 		ldrb	r8, [r4, #284]	@ zero_extendqisi2
 5082 2ba0 1D61D4E5 		ldrb	r6, [r4, #285]	@ zero_extendqisi2
1916:../uvc.c      **** 					  break;
 5083              		.loc 1 1916 0
 5084 2ba4 FFC0A0E3 		mov	ip, #255
 5085 2ba8 42FFFFEA 		b	.L338
 5086              	.LVL486:
 5087              	.L349:
1865:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 5088              		.loc 1 1865 0
 5089 2bac 4505D8E5 		ldrb	r0, [r8, #1349]	@ zero_extendqisi2
 5090 2bb0 010050E3 		cmp	r0, #1
 5091 2bb4 04005013 		cmpne	r0, #4
 5092 2bb8 5D01001A 		bne	.L359
1864:../uvc.c      **** 					  value = (value << 8)|Data0;
 5093              		.loc 1 1864 0
 5094 2bbc 30109DE5 		ldr	r1, [sp, #48]
 5095 2bc0 34E09DE5 		ldr	lr, [sp, #52]
 5096 2bc4 0E2481E1 		orr	r2, r1, lr, asl #8
1866:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 5097              		.loc 1 1866 0
 5098 2bc8 F90052E3 		cmp	r2, #249
 5099 2bcc 5801008A 		bhi	.L359
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5100              		.loc 1 1871 0
 5101 2bd0 C8A042E2 		sub	sl, r2, #200
 5102 2bd4 0AC8A0E1 		mov	ip, sl, asl #16
 5103 2bd8 3CC08DE5 		str	ip, [sp, #60]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5104              		.loc 1 1873 0
 5105 2bdc 27A062E2 		rsb	sl, r2, #39
 5106 2be0 38A08DE5 		str	sl, [sp, #56]
 5107 2be4 3CA09DE5 		ldr	sl, [sp, #60]
 5108 2be8 C81062E2 		rsb	r1, r2, #200
 5109 2bec C80052E3 		cmp	r2, #200
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5110              		.loc 1 1871 0
 5111 2bf0 640042E2 		sub	r0, r2, #100
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5112              		.loc 1 1873 0
 5113 2bf4 0118A0E1 		mov	r1, r1, asl #16
 5114 2bf8 64E062E2 		rsb	lr, r2, #100
 5115 2bfc 2A18A081 		movhi	r1, sl, lsr #16
 5116 2c00 2118A091 		movls	r1, r1, lsr #16
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5117              		.loc 1 1871 0
 5118 2c04 00C8A0E1 		mov	ip, r0, asl #16
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5119              		.loc 1 1873 0
 5120 2c08 640052E3 		cmp	r2, #100
 5121 2c0c 0E08A0E1 		mov	r0, lr, asl #16
 5122 2c10 2C08A081 		movhi	r0, ip, lsr #16
 5123 2c14 38C09DE5 		ldr	ip, [sp, #56]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5124              		.loc 1 1871 0
 5125 2c18 14A042E2 		sub	sl, r2, #20
 5126 2c1c 38A08DE5 		str	sl, [sp, #56]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5127              		.loc 1 1873 0
 5128 2c20 2008A091 		movls	r0, r0, lsr #16
 5129 2c24 14A062E2 		rsb	sl, r2, #20
 5130 2c28 3CA08DE5 		str	sl, [sp, #60]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5131              		.loc 1 1871 0
 5132 2c2c 27E042E2 		sub	lr, r2, #39
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5133              		.loc 1 1873 0
 5134 2c30 000051E1 		cmp	r1, r0
 5135 2c34 01A0A031 		movcc	sl, r1
 5136 2c38 00A0A021 		movcs	sl, r0
 5137 2c3c 0CC8A0E1 		mov	ip, ip, asl #16
 5138 2c40 270052E3 		cmp	r2, #39
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5139              		.loc 1 1871 0
 5140 2c44 0EE8A0E1 		mov	lr, lr, asl #16
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5141              		.loc 1 1873 0
 5142 2c48 2CE8A091 		movls	lr, ip, lsr #16
 5143 2c4c 68C59FE5 		ldr	ip, .L412+32
 5144 2c50 20A08DE5 		str	sl, [sp, #32]
 5145 2c54 01A06CE0 		rsb	sl, ip, r1
 5146 2c58 2EE8A081 		movhi	lr, lr, lsr #16
 5147 2c5c 00C07AE2 		rsbs	ip, sl, #0
 5148 2c60 0AC0ACE0 		adc	ip, ip, sl
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5149              		.loc 1 1871 0
 5150 2c64 38A09DE5 		ldr	sl, [sp, #56]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5151              		.loc 1 1873 0
 5152 2c68 44C08DE5 		str	ip, [sp, #68]
 5153              	.LVL487:
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5154              		.loc 1 1871 0
 5155 2c6c 0AC8A0E1 		mov	ip, sl, asl #16
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5156              		.loc 1 1873 0
 5157 2c70 3CA09DE5 		ldr	sl, [sp, #60]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5158              		.loc 1 1871 0
 5159 2c74 4CC08DE5 		str	ip, [sp, #76]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5160              		.loc 1 1873 0
 5161 2c78 0AC8A0E1 		mov	ip, sl, asl #16
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5162              		.loc 1 1871 0
 5163 2c7c 0AA042E2 		sub	sl, r2, #10
 5164 2c80 48A08DE5 		str	sl, [sp, #72]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5165              		.loc 1 1873 0
 5166 2c84 20A09DE5 		ldr	sl, [sp, #32]
 5167 2c88 3CC08DE5 		str	ip, [sp, #60]
 5168 2c8c 0A005EE1 		cmp	lr, sl
 5169 2c90 0EA0A031 		movcc	sl, lr
 5170 2c94 0AC062E2 		rsb	ip, r2, #10
 5171 2c98 40C08DE5 		str	ip, [sp, #64]
 5172 2c9c 38A08DE5 		str	sl, [sp, #56]
 5173 2ca0 3CC09DE5 		ldr	ip, [sp, #60]
 5174 2ca4 4CA09DE5 		ldr	sl, [sp, #76]
 5175 2ca8 140052E3 		cmp	r2, #20
 5176 2cac 2CA8A091 		movls	sl, ip, lsr #16
 5177 2cb0 2AA8A081 		movhi	sl, sl, lsr #16
 5178 2cb4 44C09DE5 		ldr	ip, [sp, #68]
 5179 2cb8 010050E1 		cmp	r0, r1
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5180              		.loc 1 1871 0
 5181 2cbc 48109DE5 		ldr	r1, [sp, #72]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5182              		.loc 1 1873 0
 5183 2cc0 01C0A033 		movcc	ip, #1
 5184 2cc4 3CA08DE5 		str	sl, [sp, #60]
 5185 2cc8 24C08DE5 		str	ip, [sp, #36]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5186              		.loc 1 1871 0
 5187 2ccc 01A8A0E1 		mov	sl, r1, asl #16
 5188 2cd0 05C042E2 		sub	ip, r2, #5
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5189              		.loc 1 1873 0
 5190 2cd4 051062E2 		rsb	r1, r2, #5
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5191              		.loc 1 1871 0
 5192 2cd8 48A08DE5 		str	sl, [sp, #72]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5193              		.loc 1 1873 0
 5194 2cdc 40009DE5 		ldr	r0, [sp, #64]
 5195 2ce0 38A09DE5 		ldr	sl, [sp, #56]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5196              		.loc 1 1871 0
 5197 2ce4 40C08DE5 		str	ip, [sp, #64]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5198              		.loc 1 1873 0
 5199 2ce8 3CC09DE5 		ldr	ip, [sp, #60]
 5200 2cec 4C108DE5 		str	r1, [sp, #76]
 5201 2cf0 48109DE5 		ldr	r1, [sp, #72]
 5202 2cf4 0008A0E1 		mov	r0, r0, asl #16
 5203 2cf8 0A005CE1 		cmp	ip, sl
 5204 2cfc 0AC0A021 		movcs	ip, sl
 5205 2d00 0A0052E3 		cmp	r2, #10
 5206 2d04 20A09DE5 		ldr	sl, [sp, #32]
 5207 2d08 2108A081 		movhi	r0, r1, lsr #16
 5208 2d0c 2008A091 		movls	r0, r0, lsr #16
 5209 2d10 48008DE5 		str	r0, [sp, #72]
 5210 2d14 24009DE5 		ldr	r0, [sp, #36]
 5211 2d18 0A005EE1 		cmp	lr, sl
 5212 2d1c 0200A033 		movcc	r0, #2
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5213              		.loc 1 1871 0
 5214 2d20 02E042E2 		sub	lr, r2, #2
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5215              		.loc 1 1873 0
 5216 2d24 44C08DE5 		str	ip, [sp, #68]
 5217 2d28 24008DE5 		str	r0, [sp, #36]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5218              		.loc 1 1871 0
 5219 2d2c 40C09DE5 		ldr	ip, [sp, #64]
 5220 2d30 1CE08DE5 		str	lr, [sp, #28]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5221              		.loc 1 1873 0
 5222 2d34 44009DE5 		ldr	r0, [sp, #68]
 5223 2d38 48E09DE5 		ldr	lr, [sp, #72]
 5224 2d3c 4C109DE5 		ldr	r1, [sp, #76]
 5225 2d40 02A062E2 		rsb	sl, r2, #2
 5226 2d44 00005EE1 		cmp	lr, r0
 5227 2d48 00E0A021 		movcs	lr, r0
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5228              		.loc 1 1871 0
 5229 2d4c 0CC8A0E1 		mov	ip, ip, asl #16
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5230              		.loc 1 1873 0
 5231 2d50 050052E3 		cmp	r2, #5
 5232 2d54 40A08DE5 		str	sl, [sp, #64]
 5233 2d58 0118A0E1 		mov	r1, r1, asl #16
 5234 2d5c 3CA09DE5 		ldr	sl, [sp, #60]
 5235 2d60 2C18A081 		movhi	r1, ip, lsr #16
 5236 2d64 38C09DE5 		ldr	ip, [sp, #56]
 5237 2d68 4CE08DE5 		str	lr, [sp, #76]
 5238 2d6c 24009DE5 		ldr	r0, [sp, #36]
 5239 2d70 40E09DE5 		ldr	lr, [sp, #64]
 5240 2d74 2118A091 		movls	r1, r1, lsr #16
 5241 2d78 0C005AE1 		cmp	sl, ip
 5242 2d7c 20108DE5 		str	r1, [sp, #32]
 5243 2d80 0300A033 		movcc	r0, #3
 5244 2d84 38008DE5 		str	r0, [sp, #56]
 5245 2d88 4CA09DE5 		ldr	sl, [sp, #76]
 5246 2d8c 0E08A0E1 		mov	r0, lr, asl #16
 5247 2d90 20E09DE5 		ldr	lr, [sp, #32]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5248              		.loc 1 1871 0
 5249 2d94 1C109DE5 		ldr	r1, [sp, #28]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5250              		.loc 1 1873 0
 5251 2d98 0A005EE1 		cmp	lr, sl
 5252 2d9c 0AE0A021 		movcs	lr, sl
 5253 2da0 44C09DE5 		ldr	ip, [sp, #68]
 5254 2da4 48A09DE5 		ldr	sl, [sp, #72]
 5255 2da8 020052E3 		cmp	r2, #2
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5256              		.loc 1 1871 0
 5257 2dac 0118A0E1 		mov	r1, r1, asl #16
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5258              		.loc 1 1873 0
 5259 2db0 2018A091 		movls	r1, r0, lsr #16
 5260 2db4 38009DE5 		ldr	r0, [sp, #56]
 5261 2db8 2118A081 		movhi	r1, r1, lsr #16
 5262 2dbc 0C005AE1 		cmp	sl, ip
 5263 2dc0 0400A033 		movcc	r0, #4
 5264 2dc4 40008DE5 		str	r0, [sp, #64]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5265              		.loc 1 1871 0
 5266 2dc8 010042E2 		sub	r0, r2, #1
 5267 2dcc 38008DE5 		str	r0, [sp, #56]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5268              		.loc 1 1873 0
 5269 2dd0 4CA09DE5 		ldr	sl, [sp, #76]
 5270 2dd4 20009DE5 		ldr	r0, [sp, #32]
 5271 2dd8 01C062E2 		rsb	ip, r2, #1
 5272 2ddc 3CC08DE5 		str	ip, [sp, #60]
 5273 2de0 0A0050E1 		cmp	r0, sl
1880:../uvc.c      **** 						  shutter = shutter+index;
 5274              		.loc 1 1880 0
 5275 2de4 38A09DE5 		ldr	sl, [sp, #56]
 5276 2de8 3C009DE5 		ldr	r0, [sp, #60]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5277              		.loc 1 1873 0
 5278 2dec 40C09DE5 		ldr	ip, [sp, #64]
 5279 2df0 05C0A033 		movcc	ip, #5
1880:../uvc.c      **** 						  shutter = shutter+index;
 5280              		.loc 1 1880 0
 5281 2df4 010052E3 		cmp	r2, #1
 5282 2df8 0028A091 		movls	r2, r0, asl #16
 5283 2dfc 0A28A081 		movhi	r2, sl, asl #16
 5284 2e00 0E0051E1 		cmp	r1, lr
 5285 2e04 01A0A031 		movcc	sl, r1
 5286 2e08 0EA0A021 		movcs	sl, lr
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5287              		.loc 1 1873 0
 5288 2e0c 0E0051E1 		cmp	r1, lr
 5289 2e10 0C10A021 		movcs	r1, ip
 5290 2e14 0610A033 		movcc	r1, #6
1880:../uvc.c      **** 						  shutter = shutter+index;
 5291              		.loc 1 1880 0
 5292 2e18 22085AE1 		cmp	sl, r2, lsr #16
1883:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5293              		.loc 1 1883 0
 5294 2e1c 90A39FE5 		ldr	sl, .L412+24
1880:../uvc.c      **** 						  shutter = shutter+index;
 5295              		.loc 1 1880 0
 5296 2e20 0120A091 		movls	r2, r1
 5297 2e24 0720A083 		movhi	r2, #7
 5298 2e28 012082E2 		add	r2, r2, #1
 5299 2e2c FFE002E2 		and	lr, r2, #255
1883:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5300              		.loc 1 1883 0
 5301 2e30 0010E0E3 		mvn	r1, #0
 5302 2e34 1C009AE5 		ldr	r0, [sl, #28]
1880:../uvc.c      **** 						  shutter = shutter+index;
 5303              		.loc 1 1880 0
 5304 2e38 38E08DE5 		str	lr, [sp, #56]
 5305              	.LVL488:
1883:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5306              		.loc 1 1883 0
 5307 2e3c 2C308DE5 		str	r3, [sp, #44]
 5308 2e40 FEFFFFEB 		bl	_txe_mutex_get
1884:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 5309              		.loc 1 1884 0
 5310 2e44 38C09DE5 		ldr	ip, [sp, #56]
 5311 2e48 0310A0E3 		mov	r1, #3
 5312 2e4c 0B20A0E1 		mov	r2, fp
 5313 2e50 2C309DE5 		ldr	r3, [sp, #44]
 5314 2e54 00C08DE5 		str	ip, [sp, #0]
 5315 2e58 0A00A0E1 		mov	r0, sl
 5316 2e5c 00C0A0E3 		mov	ip, #0
 5317 2e60 04C08DE5 		str	ip, [sp, #4]
 5318 2e64 FEFFFFEB 		bl	cmdSet
1885:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5319              		.loc 1 1885 0
 5320 2e68 1C009AE5 		ldr	r0, [sl, #28]
 5321 2e6c FEFFFFEB 		bl	_txe_mutex_put
1888:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 5322              		.loc 1 1888 0
 5323 2e70 30009DE5 		ldr	r0, [sp, #48]
1889:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5324              		.loc 1 1889 0
 5325 2e74 34C09DE5 		ldr	ip, [sp, #52]
1891:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5326              		.loc 1 1891 0
 5327 2e78 38309DE5 		ldr	r3, [sp, #56]
1888:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 5328              		.loc 1 1888 0
 5329 2e7c 061089E0 		add	r1, r9, r6
 5330 2e80 816188E0 		add	r6, r8, r1, asl #3
1890:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5331              		.loc 1 1890 0
 5332 2e84 0120A0E3 		mov	r2, #1
1888:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 5333              		.loc 1 1888 0
 5334 2e88 2D05C6E5 		strb	r0, [r6, #1325]
1889:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5335              		.loc 1 1889 0
 5336 2e8c 2EC5C6E5 		strb	ip, [r6, #1326]
1890:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5337              		.loc 1 1890 0
 5338 2e90 3025C6E5 		strb	r2, [r6, #1328]
1891:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5339              		.loc 1 1891 0
 5340 2e94 0D33C8E5 		strb	r3, [r8, #781]
 5341 2e98 3FFFFFEA 		b	.L402
 5342              	.LVL489:
 5343              	.L348:
1818:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 5344              		.loc 1 1818 0
 5345 2e9c 062089E0 		add	r2, r9, r6
 5346 2ea0 826188E0 		add	r6, r8, r2, asl #3
1819:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5347              		.loc 1 1819 0
 5348 2ea4 0110A0E3 		mov	r1, #1
1822:../uvc.c      **** 		  		    switch (getData){
 5349              		.loc 1 1822 0
 5350 2ea8 01E040E2 		sub	lr, r0, #1
1818:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 5351              		.loc 1 1818 0
 5352 2eac 2D05C6E5 		strb	r0, [r6, #1325]
1819:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5353              		.loc 1 1819 0
 5354 2eb0 3015C6E5 		strb	r1, [r6, #1328]
 5355              	.LVL490:
1822:../uvc.c      **** 		  		    switch (getData){
 5356              		.loc 1 1822 0
 5357 2eb4 07005EE3 		cmp	lr, #7
 5358 2eb8 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 5359 2ebc 980000EA 		b	.L353
 5360              	.L358:
 5361 2ec0 B8300000 		.word	.L354
 5362 2ec4 1C300000 		.word	.L355
 5363 2ec8 24310000 		.word	.L353
 5364 2ecc B42F0000 		.word	.L356
 5365 2ed0 24310000 		.word	.L353
 5366 2ed4 24310000 		.word	.L353
 5367 2ed8 24310000 		.word	.L353
 5368 2edc 142F0000 		.word	.L357
 5369              	.LVL491:
 5370              	.L347:
1938:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5371              		.loc 1 1938 0
 5372 2ee0 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1937:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 5373              		.loc 1 1937 0
 5374 2ee4 30A09DE5 		ldr	sl, [sp, #48]
 5375 2ee8 069089E0 		add	r9, r9, r6
 5376 2eec 89E188E0 		add	lr, r8, r9, asl #3
1938:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5377              		.loc 1 1938 0
 5378 2ef0 0620A0E1 		mov	r2, r6
 5379 2ef4 0400A0E3 		mov	r0, #4
 5380 2ef8 C0129FE5 		ldr	r1, .L412+36
1937:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 5381              		.loc 1 1937 0
 5382 2efc 2DA5CEE5 		strb	sl, [lr, #1325]
1938:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5383              		.loc 1 1938 0
 5384 2f00 FEFFFFEB 		bl	CyU3PDebugPrint
1939:../uvc.c      **** 			  		 break;
 5385              		.loc 1 1939 0
 5386 2f04 FFC0A0E3 		mov	ip, #255
 5387 2f08 0C60A0E1 		mov	r6, ip
 5388 2f0c 0C80A0E1 		mov	r8, ip
 5389 2f10 68FEFFEA 		b	.L338
 5390              	.LVL492:
 5391              	.L357:
1841:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5392              		.loc 1 1841 0
 5393 2f14 98629FE5 		ldr	r6, .L412+24
1839:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5394              		.loc 1 1839 0
 5395 2f18 00A0A0E3 		mov	sl, #0
1841:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5396              		.loc 1 1841 0
 5397 2f1c 1C0096E5 		ldr	r0, [r6, #28]
1839:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5398              		.loc 1 1839 0
 5399 2f20 0DA3C8E5 		strb	sl, [r8, #781]
 5400              	.LVL493:
1841:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5401              		.loc 1 1841 0
 5402 2f24 0010E0E3 		mvn	r1, #0
 5403 2f28 2C308DE5 		str	r3, [sp, #44]
 5404 2f2c FEFFFFEB 		bl	_txe_mutex_get
1842:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5405              		.loc 1 1842 0
 5406 2f30 0B20A0E1 		mov	r2, fp
 5407 2f34 2C309DE5 		ldr	r3, [sp, #44]
 5408 2f38 1010A0E3 		mov	r1, #16
 5409 2f3c 0600A0E1 		mov	r0, r6
 5410 2f40 00A08DE5 		str	sl, [sp, #0]
 5411 2f44 04A08DE5 		str	sl, [sp, #4]
 5412 2f48 FEFFFFEB 		bl	cmdSet
1843:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5413              		.loc 1 1843 0
 5414 2f4c 1C0096E5 		ldr	r0, [r6, #28]
 5415 2f50 FEFFFFEB 		bl	_txe_mutex_put
 5416              	.LVL494:
 5417              	.LBB71:
 5418              	.LBB72:
 736:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5419              		.loc 1 736 0
 5420 2f54 0010E0E3 		mvn	r1, #0
 5421 2f58 1C0096E5 		ldr	r0, [r6, #28]
 5422 2f5c FEFFFFEB 		bl	_txe_mutex_get
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5423              		.loc 1 737 0
 5424 2f60 01C0A0E3 		mov	ip, #1
 5425 2f64 2010A0E3 		mov	r1, #32
 5426 2f68 2720A0E3 		mov	r2, #39
 5427 2f6c 3030A0E3 		mov	r3, #48
 5428 2f70 0600A0E1 		mov	r0, r6
 5429 2f74 00C08DE5 		str	ip, [sp, #0]
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5430              		.loc 1 738 0
 5431 2f78 0280A0E3 		mov	r8, #2
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5432              		.loc 1 737 0
 5433 2f7c 04A08DE5 		str	sl, [sp, #4]
 5434 2f80 FEFFFFEB 		bl	cmdSet
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5435              		.loc 1 738 0
 5436 2f84 2110A0E3 		mov	r1, #33
 5437 2f88 2520A0E3 		mov	r2, #37
 5438 2f8c 3030A0E3 		mov	r3, #48
 5439 2f90 0600A0E1 		mov	r0, r6
 5440 2f94 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 5441 2f98 FEFFFFEB 		bl	cmdSet
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5442              		.loc 1 739 0
 5443 2f9c 1C0096E5 		ldr	r0, [r6, #28]
 5444 2fa0 FEFFFFEB 		bl	_txe_mutex_put
 5445              	.LBE72:
 5446              	.LBE71:
1845:../uvc.c      **** 							break;
 5447              		.loc 1 1845 0
 5448 2fa4 FFC0A0E3 		mov	ip, #255
 5449 2fa8 0C60A0E1 		mov	r6, ip
 5450 2fac 0880A0E3 		mov	r8, #8
 5451 2fb0 40FEFFEA 		b	.L338
 5452              	.LVL495:
 5453              	.L356:
 5454              	.LBB73:
 5455              	.LBB74:
 736:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5456              		.loc 1 736 0
 5457 2fb4 F8619FE5 		ldr	r6, .L412+24
 5458 2fb8 0010E0E3 		mvn	r1, #0
 5459 2fbc 1C0096E5 		ldr	r0, [r6, #28]
 5460 2fc0 FEFFFFEB 		bl	_txe_mutex_get
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5461              		.loc 1 737 0
 5462 2fc4 0080A0E3 		mov	r8, #0
 5463 2fc8 2010A0E3 		mov	r1, #32
 5464 2fcc 2720A0E3 		mov	r2, #39
 5465 2fd0 3030A0E3 		mov	r3, #48
 5466 2fd4 0600A0E1 		mov	r0, r6
 5467 2fd8 00808DE5 		str	r8, [sp, #0]
 5468 2fdc 04808DE5 		str	r8, [sp, #4]
 5469 2fe0 FEFFFFEB 		bl	cmdSet
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5470              		.loc 1 738 0
 5471 2fe4 01C0A0E3 		mov	ip, #1
 5472 2fe8 2110A0E3 		mov	r1, #33
 5473 2fec 2520A0E3 		mov	r2, #37
 5474 2ff0 3030A0E3 		mov	r3, #48
 5475 2ff4 0600A0E1 		mov	r0, r6
 5476 2ff8 00C08DE5 		str	ip, [sp, #0]
 5477 2ffc 04808DE5 		str	r8, [sp, #4]
 5478 3000 FEFFFFEB 		bl	cmdSet
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5479              		.loc 1 739 0
 5480 3004 1C0096E5 		ldr	r0, [r6, #28]
 5481 3008 FEFFFFEB 		bl	_txe_mutex_put
 5482 300c FFC0A0E3 		mov	ip, #255
 5483 3010 0C60A0E1 		mov	r6, ip
 5484 3014 0480A0E3 		mov	r8, #4
 5485 3018 26FEFFEA 		b	.L338
 5486              	.LVL496:
 5487              	.L355:
 5488              	.LBE74:
 5489              	.LBE73:
1829:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5490              		.loc 1 1829 0
 5491 301c 90619FE5 		ldr	r6, .L412+24
1827:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5492              		.loc 1 1827 0
 5493 3020 00A0A0E3 		mov	sl, #0
1829:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5494              		.loc 1 1829 0
 5495 3024 1C0096E5 		ldr	r0, [r6, #28]
1827:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5496              		.loc 1 1827 0
 5497 3028 0DA3C8E5 		strb	sl, [r8, #781]
 5498              	.LVL497:
1829:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5499              		.loc 1 1829 0
 5500 302c 0010E0E3 		mvn	r1, #0
 5501 3030 2C308DE5 		str	r3, [sp, #44]
 5502 3034 FEFFFFEB 		bl	_txe_mutex_get
1830:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5503              		.loc 1 1830 0
 5504 3038 0B20A0E1 		mov	r2, fp
 5505 303c 2C309DE5 		ldr	r3, [sp, #44]
 5506 3040 1010A0E3 		mov	r1, #16
 5507 3044 0600A0E1 		mov	r0, r6
 5508 3048 00A08DE5 		str	sl, [sp, #0]
 5509 304c 04A08DE5 		str	sl, [sp, #4]
 5510 3050 FEFFFFEB 		bl	cmdSet
1831:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5511              		.loc 1 1831 0
 5512 3054 1C0096E5 		ldr	r0, [r6, #28]
 5513 3058 FEFFFFEB 		bl	_txe_mutex_put
 5514              	.LVL498:
 5515              	.LBB75:
 5516              	.LBB76:
 736:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5517              		.loc 1 736 0
 5518 305c 0010E0E3 		mvn	r1, #0
 5519 3060 1C0096E5 		ldr	r0, [r6, #28]
 5520 3064 FEFFFFEB 		bl	_txe_mutex_get
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5521              		.loc 1 737 0
 5522 3068 2010A0E3 		mov	r1, #32
 5523 306c 2720A0E3 		mov	r2, #39
 5524 3070 3030A0E3 		mov	r3, #48
 5525 3074 0600A0E1 		mov	r0, r6
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5526              		.loc 1 738 0
 5527 3078 0180A0E3 		mov	r8, #1
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5528              		.loc 1 737 0
 5529 307c 00A08DE5 		str	sl, [sp, #0]
 5530 3080 04A08DE5 		str	sl, [sp, #4]
 5531 3084 FEFFFFEB 		bl	cmdSet
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5532              		.loc 1 738 0
 5533 3088 2110A0E3 		mov	r1, #33
 5534 308c 2520A0E3 		mov	r2, #37
 5535 3090 3030A0E3 		mov	r3, #48
 5536 3094 0600A0E1 		mov	r0, r6
 5537 3098 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 5538 309c FEFFFFEB 		bl	cmdSet
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5539              		.loc 1 739 0
 5540 30a0 1C0096E5 		ldr	r0, [r6, #28]
 5541 30a4 FEFFFFEB 		bl	_txe_mutex_put
 5542 30a8 FFC0A0E3 		mov	ip, #255
 5543 30ac 0C60A0E1 		mov	r6, ip
 5544 30b0 0280A0E3 		mov	r8, #2
 5545 30b4 FFFDFFEA 		b	.L338
 5546              	.LVL499:
 5547              	.L354:
 5548              	.LBE76:
 5549              	.LBE75:
 5550              	.LBB77:
 5551              	.LBB78:
 736:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5552              		.loc 1 736 0
 5553 30b8 F4609FE5 		ldr	r6, .L412+24
 5554 30bc 0010E0E3 		mvn	r1, #0
 5555 30c0 1C0096E5 		ldr	r0, [r6, #28]
 5556 30c4 FEFFFFEB 		bl	_txe_mutex_get
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5557              		.loc 1 737 0
 5558 30c8 0080A0E3 		mov	r8, #0
 5559 30cc 01A0A0E3 		mov	sl, #1
 5560 30d0 2010A0E3 		mov	r1, #32
 5561 30d4 2720A0E3 		mov	r2, #39
 5562 30d8 3030A0E3 		mov	r3, #48
 5563 30dc 0600A0E1 		mov	r0, r6
 5564 30e0 04808DE5 		str	r8, [sp, #4]
 5565 30e4 00A08DE5 		str	sl, [sp, #0]
 5566 30e8 FEFFFFEB 		bl	cmdSet
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5567              		.loc 1 738 0
 5568 30ec 02C0A0E3 		mov	ip, #2
 5569 30f0 2110A0E3 		mov	r1, #33
 5570 30f4 2520A0E3 		mov	r2, #37
 5571 30f8 3030A0E3 		mov	r3, #48
 5572 30fc 0600A0E1 		mov	r0, r6
 5573 3100 00C08DE5 		str	ip, [sp, #0]
 5574 3104 04808DE5 		str	r8, [sp, #4]
 5575 3108 FEFFFFEB 		bl	cmdSet
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5576              		.loc 1 739 0
 5577 310c 1C0096E5 		ldr	r0, [r6, #28]
 5578 3110 FEFFFFEB 		bl	_txe_mutex_put
 5579              	.LBE78:
 5580              	.LBE77:
1825:../uvc.c      **** 							break;
 5581              		.loc 1 1825 0
 5582 3114 FFC0A0E3 		mov	ip, #255
 5583 3118 0C60A0E1 		mov	r6, ip
 5584 311c 0A80A0E1 		mov	r8, sl
 5585 3120 E4FDFFEA 		b	.L338
 5586              	.LVL500:
 5587              	.L353:
1822:../uvc.c      **** 		  		    switch (getData){
 5588              		.loc 1 1822 0
 5589 3124 FFC0A0E3 		mov	ip, #255
 5590 3128 0080A0E1 		mov	r8, r0
 5591 312c 0C60A0E1 		mov	r6, ip
 5592 3130 E0FDFFEA 		b	.L338
 5593              	.LVL501:
 5594              	.L359:
1893:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 5595              		.loc 1 1893 0
 5596 3134 0000A0E3 		mov	r0, #0
 5597 3138 0110A0E3 		mov	r1, #1
 5598 313c 0020A0E1 		mov	r2, r0
 5599 3140 FEFFFFEB 		bl	CyU3PUsbStall
 5600              	.LVL502:
 5601 3144 94FEFFEA 		b	.L402
 5602              	.LVL503:
 5603              	.L401:
1911:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 5604              		.loc 1 1911 0
 5605 3148 0110A0E3 		mov	r1, #1
 5606 314c 0020A0E1 		mov	r2, r0
 5607 3150 FEFFFFEB 		bl	CyU3PUsbStall
 5608 3154 90FEFFEA 		b	.L402
 5609              	.LVL504:
 5610              	.L411:
1926:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 5611              		.loc 1 1926 0
 5612 3158 08E0A0E3 		mov	lr, #8
 5613 315c 00C0A0E3 		mov	ip, #0
 5614 3160 0600A0E1 		mov	r0, r6
 5615 3164 2310A0E3 		mov	r1, #35
 5616 3168 0B20A0E1 		mov	r2, fp
 5617 316c 00E08DE5 		str	lr, [sp, #0]
 5618 3170 04C08DE5 		str	ip, [sp, #4]
 5619 3174 FEFFFFEB 		bl	cmdSet
 5620 3178 5DFEFFEA 		b	.L404
 5621              	.L410:
1924:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5622              		.loc 1 1924 0
 5623 317c 0480A0E3 		mov	r8, #4
 5624 3180 00E0A0E3 		mov	lr, #0
 5625 3184 0600A0E1 		mov	r0, r6
 5626 3188 2310A0E3 		mov	r1, #35
 5627 318c 0B20A0E1 		mov	r2, fp
 5628 3190 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 5629 3194 FEFFFFEB 		bl	cmdSet
 5630 3198 55FEFFEA 		b	.L404
 5631              	.L413:
 5632              		.align	2
 5633              	.L412:
 5634 319c 00000000 		.word	bRequest
 5635 31a0 00000000 		.word	.LANCHOR1
 5636 31a4 00000000 		.word	.LANCHOR0
 5637 31a8 D4050000 		.word	.LC34
 5638 31ac F8050000 		.word	.LC35
 5639 31b0 1C010000 		.word	.LANCHOR0+284
 5640 31b4 00000000 		.word	cmdQu
 5641 31b8 88050000 		.word	.LC32
 5642 31bc FFFF0000 		.word	65535
 5643 31c0 B0050000 		.word	.LC33
 5644              		.cfi_endproc
 5645              	.LFE4:
 5647              		.align	2
 5648              		.global	UVCAppEP0Thread_Entry
 5650              	UVCAppEP0Thread_Entry:
 5651              	.LFB25:
4162:../uvc.c      **** {
 5652              		.loc 1 4162 0
 5653              		.cfi_startproc
 5654              		@ args = 0, pretend = 0, frame = 24
 5655              		@ frame_needed = 0, uses_anonymous_args = 0
 5656              	.LVL505:
 5657 31c4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5658              	.LCFI20:
 5659              		.cfi_def_cfa_offset 36
 5660 31c8 404D9FE5 		ldr	r4, .L608
 5661              		.cfi_offset 14, -4
 5662              		.cfi_offset 11, -8
 5663              		.cfi_offset 10, -12
 5664              		.cfi_offset 9, -16
 5665              		.cfi_offset 8, -20
 5666              		.cfi_offset 7, -24
 5667              		.cfi_offset 6, -28
 5668              		.cfi_offset 5, -32
 5669              		.cfi_offset 4, -36
 5670 31cc 405D9FE5 		ldr	r5, .L608+4
 5671 31d0 40BD9FE5 		ldr	fp, .L608+8
 5672 31d4 40AD9FE5 		ldr	sl, .L608+12
 5673 31d8 408D9FE5 		ldr	r8, .L608+16
 5674 31dc 407D9FE5 		ldr	r7, .L608+20
 5675 31e0 24D04DE2 		sub	sp, sp, #36
 5676              	.LCFI21:
 5677              		.cfi_def_cfa_offset 72
 5678              	.LVL506:
4184:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 5679              		.loc 1 4184 0
 5680 31e4 0460A0E1 		mov	r6, r4
 5681              	.LVL507:
 5682              	.L569:
 5683 31e8 00C0E0E3 		mvn	ip, #0
 5684 31ec 1C0D9FE5 		ldr	r0, .L608
 5685 31f0 4C10A0E3 		mov	r1, #76
 5686 31f4 0120A0E3 		mov	r2, #1
 5687 31f8 18308DE2 		add	r3, sp, #24
 5688 31fc 00C08DE5 		str	ip, [sp, #0]
 5689 3200 FEFFFFEB 		bl	_txe_event_flags_get
 5690 3204 000050E3 		cmp	r0, #0
 5691 3208 2E00001A 		bne	.L415
4188:../uvc.c      ****             if (!isUsbConnected)
 5692              		.loc 1 4188 0
 5693 320c B03096E5 		ldr	r3, [r6, #176]
 5694 3210 000053E3 		cmp	r3, #0
 5695 3214 8300000A 		beq	.L598
 5696              	.L416:
4204:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 5697              		.loc 1 4204 0
 5698 3218 18309DE5 		ldr	r3, [sp, #24]
 5699 321c 040013E3 		tst	r3, #4
 5700 3220 1C00000A 		beq	.L417
4206:../uvc.c      ****             	switch ((wIndex >> 8))
 5701              		.loc 1 4206 0
 5702 3224 B090DBE1 		ldrh	r9, [fp, #0]
 5703 3228 2924A0E1 		mov	r2, r9, lsr #8
 5704 322c 030052E3 		cmp	r2, #3
 5705 3230 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 5706 3234 120000EA 		b	.L418
 5707              	.L423:
 5708 3238 F4330000 		.word	.L419
 5709 323c B8330000 		.word	.L420
 5710 3240 48320000 		.word	.L421
 5711 3244 74330000 		.word	.L422
 5712              	.L421:
 5713              	.LBB93:
 5714              	.LBB95:
3405:../uvc.c      ****     switch (wValue)
 5715              		.loc 1 3405 0
 5716 3248 B020DAE1 		ldrh	r2, [sl, #0]
 5717 324c 060C52E3 		cmp	r2, #1536
 5718 3250 9902000A 		beq	.L429
 5719 3254 E600008A 		bhi	.L435
 5720 3258 030C52E3 		cmp	r2, #768
 5721 325c 9202000A 		beq	.L427
 5722 3260 EE00008A 		bhi	.L436
 5723 3264 010C52E3 		cmp	r2, #256
 5724 3268 8B02000A 		beq	.L425
 5725 326c 020C52E3 		cmp	r2, #512
 5726 3270 8502000A 		beq	.L599
 5727              	.L438:
 5728              	.LBE95:
 5729              	.LBE93:
 5730              	.LBB98:
 5731              	.LBB103:
3537:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 5732              		.loc 1 3537 0
 5733 3274 AC1C9FE5 		ldr	r1, .L608+24
 5734 3278 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 5735 327c 0400A0E3 		mov	r0, #4
 5736 3280 FEFFFFEB 		bl	CyU3PDebugPrint
 5737              	.L418:
 5738              	.LBE103:
 5739              	.LBE98:
4227:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 5740              		.loc 1 4227 0
 5741 3284 0000A0E3 		mov	r0, #0
 5742 3288 0110A0E3 		mov	r1, #1
 5743 328c 0020A0E1 		mov	r2, r0
 5744 3290 FEFFFFEB 		bl	CyU3PUsbStall
 5745 3294 18309DE5 		ldr	r3, [sp, #24]
 5746              	.L417:
4232:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 5747              		.loc 1 4232 0
 5748 3298 080013E3 		tst	r3, #8
 5749 329c 0700000A 		beq	.L482
4236:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 5750              		.loc 1 4236 0
 5751 32a0 B030DBE1 		ldrh	r3, [fp, #0]
 5752 32a4 010053E3 		cmp	r3, #1
 5753 32a8 6400000A 		beq	.L483
 5754              	.L484:
 5755              	.LBB109:
 5756              	.LBB114:
4151:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 5757              		.loc 1 4151 0
 5758 32ac 0000A0E3 		mov	r0, #0
 5759 32b0 0110A0E3 		mov	r1, #1
 5760 32b4 0020A0E1 		mov	r2, r0
 5761 32b8 FEFFFFEB 		bl	CyU3PUsbStall
 5762              	.L588:
 5763 32bc 18309DE5 		ldr	r3, [sp, #24]
 5764              	.L482:
 5765              	.LBE114:
 5766              	.LBE109:
4247:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 5767              		.loc 1 4247 0
 5768 32c0 400013E3 		tst	r3, #64
 5769 32c4 0100001A 		bne	.L600
 5770              	.L415:
4460:../uvc.c      ****         CyU3PThreadRelinquish ();
 5771              		.loc 1 4460 0
 5772 32c8 FEFFFFEB 		bl	_txe_thread_relinquish
4461:../uvc.c      ****     }
 5773              		.loc 1 4461 0
 5774 32cc C5FFFFEA 		b	.L569
 5775              	.L600:
4252:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 5776              		.loc 1 4252 0
 5777 32d0 1800A0E3 		mov	r0, #24
 5778 32d4 14108DE2 		add	r1, sp, #20
 5779 32d8 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
4309:../uvc.c      **** 				if(snapButFlag == 0x0f){
 5780              		.loc 1 4309 0
 5781 32dc 0B37D5E5 		ldrb	r3, [r5, #1803]	@ zero_extendqisi2
 5782 32e0 0F0053E3 		cmp	r3, #15
 5783 32e4 8D00000A 		beq	.L601
4336:../uvc.c      **** 				}else if(!snapButFlag){
 5784              		.loc 1 4336 0
 5785 32e8 000053E3 		cmp	r3, #0
 5786 32ec F5FFFF1A 		bne	.L415
4338:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 5787              		.loc 1 4338 0
 5788 32f0 002097E5 		ldr	r2, [r7, #0]
 5789 32f4 0290A0E3 		mov	r9, #2
 5790 32f8 0090C2E5 		strb	r9, [r2, #0]
4339:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 5791              		.loc 1 4339 0
 5792 32fc 001097E5 		ldr	r1, [r7, #0]
 5793 3300 0190A0E3 		mov	r9, #1
 5794 3304 0190C1E5 		strb	r9, [r1, #1]
4340:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 5795              		.loc 1 4340 0
 5796 3308 000097E5 		ldr	r0, [r7, #0]
4344:../uvc.c      **** 					interStabuf.size   = 1024;
 5797              		.loc 1 4344 0
 5798 330c 01EBA0E3 		mov	lr, #1024	@ movhi
4340:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 5799              		.loc 1 4340 0
 5800 3310 0230C0E5 		strb	r3, [r0, #2]
4341:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 5801              		.loc 1 4341 0
 5802 3314 00C097E5 		ldr	ip, [r7, #0]
4350:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5803              		.loc 1 4350 0
 5804 3318 0010E0E3 		mvn	r1, #0
4341:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 5805              		.loc 1 4341 0
 5806 331c 0390CCE5 		strb	r9, [ip, #3]
4343:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5807              		.loc 1 4343 0
 5808 3320 002097E5 		ldr	r2, [r7, #0]
4347:../uvc.c      **** 					interStabuf.count = 4;
 5809              		.loc 1 4347 0
 5810 3324 04C0A0E3 		mov	ip, #4	@ movhi
4350:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5811              		.loc 1 4350 0
 5812 3328 FC0B9FE5 		ldr	r0, .L608+28
4343:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5813              		.loc 1 4343 0
 5814 332c 08208DE5 		str	r2, [sp, #8]
4344:../uvc.c      **** 					interStabuf.size   = 1024;
 5815              		.loc 1 4344 0
 5816 3330 BEE0CDE1 		strh	lr, [sp, #14]	@ movhi
4345:../uvc.c      **** 					interStabuf.status = 0;
 5817              		.loc 1 4345 0
 5818 3334 B031CDE1 		strh	r3, [sp, #16]	@ movhi
4347:../uvc.c      **** 					interStabuf.count = 4;
 5819              		.loc 1 4347 0
 5820 3338 BCC0CDE1 		strh	ip, [sp, #12]	@ movhi
4350:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5821              		.loc 1 4350 0
 5822 333c FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
4353:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 5823              		.loc 1 4353 0
 5824 3340 E40B9FE5 		ldr	r0, .L608+28
 5825 3344 08108DE2 		add	r1, sp, #8
 5826 3348 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 5827              	.LVL508:
4355:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 5828              		.loc 1 4355 0
 5829 334c 002050E2 		subs	r2, r0, #0
 5830 3350 5101001A 		bne	.L602
4361:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
 5831              		.loc 1 4361 0
 5832 3354 3010A0E3 		mov	r1, #48
 5833 3358 0920A0E1 		mov	r2, r9
 5834 335c 0500A0E3 		mov	r0, #5
 5835              	.LVL509:
 5836 3360 FEFFFFEB 		bl	SensorSetControl
4362:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 5837              		.loc 1 4362 0
 5838 3364 A83B9FE5 		ldr	r3, .L608+4
 5839 3368 0B97C3E5 		strb	r9, [r3, #1803]
4460:../uvc.c      ****         CyU3PThreadRelinquish ();
 5840              		.loc 1 4460 0
 5841 336c FEFFFFEB 		bl	_txe_thread_relinquish
 5842 3370 9CFFFFEA 		b	.L569
 5843              	.L422:
 5844              	.LBB119:
 5845              	.LBB125:
3710:../uvc.c      ****     switch (wValue)
 5846              		.loc 1 3710 0
 5847 3374 B030DAE1 		ldrh	r3, [sl, #0]
 5848 3378 090C53E3 		cmp	r3, #2304
 5849 337c 5E02000A 		beq	.L466
 5850 3380 8F00008A 		bhi	.L476
 5851 3384 010B53E3 		cmp	r3, #1024
 5852 3388 5702000A 		beq	.L461
 5853 338c 5001008A 		bhi	.L477
 5854 3390 020C53E3 		cmp	r3, #512
 5855 3394 5002000A 		beq	.L459
 5856 3398 030C53E3 		cmp	r3, #768
 5857 339c 4A02000A 		beq	.L460
 5858 33a0 010C53E3 		cmp	r3, #256
 5859 33a4 B6FFFF1A 		bne	.L418
 5860              	.LVL510:
3714:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 5861              		.loc 1 3714 0
 5862 33a8 1000A0E3 		mov	r0, #16
 5863 33ac FEFFFFEB 		bl	ControlHandle
 5864              	.LVL511:
 5865 33b0 18309DE5 		ldr	r3, [sp, #24]
 5866 33b4 B7FFFFEA 		b	.L417
 5867              	.L420:
 5868              	.LBE125:
 5869              	.LBE119:
 5870              	.LBB131:
 5871              	.LBB104:
3480:../uvc.c      ****     switch (wValue)
 5872              		.loc 1 3480 0
 5873 33b8 B020DAE1 		ldrh	r2, [sl, #0]
 5874 33bc 060C52E3 		cmp	r2, #1536
 5875 33c0 2D02000A 		beq	.L444
 5876 33c4 7600008A 		bhi	.L450
 5877 33c8 030C52E3 		cmp	r2, #768
 5878 33cc C201000A 		beq	.L441
 5879 33d0 5A01008A 		bhi	.L451
 5880 33d4 010C52E3 		cmp	r2, #256
 5881 33d8 BB01000A 		beq	.L439
 5882 33dc 020C52E3 		cmp	r2, #512
 5883 33e0 A3FFFF1A 		bne	.L438
 5884              	.LVL512:
3488:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 5885              		.loc 1 3488 0
 5886 33e4 0100A0E3 		mov	r0, #1
 5887 33e8 FEFFFFEB 		bl	CTControlHandle
 5888              	.LVL513:
 5889 33ec 18309DE5 		ldr	r3, [sp, #24]
 5890 33f0 A8FFFFEA 		b	.L417
 5891              	.L419:
 5892              	.LBE104:
 5893              	.LBE131:
 5894              	.LBB132:
 5895              	.LBB133:
3675:../uvc.c      **** 	if(valIdx < 32){
 5896              		.loc 1 3675 0
 5897 33f4 8E34D5E5 		ldrb	r3, [r5, #1166]	@ zero_extendqisi2
 5898 33f8 1F0053E3 		cmp	r3, #31
 5899 33fc A0FFFF8A 		bhi	.L418
3676:../uvc.c      **** 		value[valIdx][0] = wValue>>8;
 5900              		.loc 1 3676 0
 5901 3400 B0C0DAE1 		ldrh	ip, [sl, #0]
3678:../uvc.c      **** 		valIdx++;
 5902              		.loc 1 3678 0
 5903 3404 081B9FE5 		ldr	r1, .L608+4
 5904 3408 01E083E2 		add	lr, r3, #1
3676:../uvc.c      **** 		value[valIdx][0] = wValue>>8;
 5905              		.loc 1 3676 0
 5906 340c 2C04A0E1 		mov	r0, ip, lsr #8
 5907 3410 833084E0 		add	r3, r4, r3, asl #1
 5908 3414 DC00C3E5 		strb	r0, [r3, #220]
3677:../uvc.c      **** 		value[valIdx][1] = (uint8_t)wValue;
 5909              		.loc 1 3677 0
 5910 3418 DDC0C3E5 		strb	ip, [r3, #221]
3678:../uvc.c      **** 		valIdx++;
 5911              		.loc 1 3678 0
 5912 341c 8EE4C1E5 		strb	lr, [r1, #1166]
3679:../uvc.c      **** 		value[0][1] = valIdx;
 5913              		.loc 1 3679 0
 5914 3420 DDE0C4E5 		strb	lr, [r4, #221]
 5915 3424 96FFFFEA 		b	.L418
 5916              	.L598:
 5917              	.LBE133:
 5918              	.LBE132:
4190:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 5919              		.loc 1 4190 0
 5920 3428 FEFFFFEB 		bl	CyU3PUsbGetSpeed
4191:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 5921              		.loc 1 4191 0
 5922 342c 000050E3 		cmp	r0, #0
4190:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 5923              		.loc 1 4190 0
 5924 3430 C800C6E5 		strb	r0, [r6, #200]
4193:../uvc.c      ****                     isUsbConnected = CyTrue;
 5925              		.loc 1 4193 0
 5926 3434 0100A013 		movne	r0, #1
 5927 3438 B0008615 		strne	r0, [r6, #176]
 5928 343c 75FFFFEA 		b	.L416
 5929              	.L483:
 5930              	.LVL514:
 5931              	.LBB134:
 5932              	.LBB113:
3811:../uvc.c      ****     switch (wValue)
 5933              		.loc 1 3811 0
 5934 3440 B020DAE1 		ldrh	r2, [sl, #0]
 5935 3444 030C52E3 		cmp	r2, #768
 5936 3448 DB00000A 		beq	.L487
 5937 344c 0F00008A 		bhi	.L490
 5938 3450 010C52E3 		cmp	r2, #256
 5939 3454 9800000A 		beq	.L485
 5940 3458 020C52E3 		cmp	r2, #512
 5941 345c 92FFFF1A 		bne	.L484
3876:../uvc.c      ****             switch (bRequest)
 5942              		.loc 1 3876 0
 5943 3460 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 5944 3464 810053E3 		cmp	r3, #129
 5945 3468 8F01000A 		beq	.L556
 5946 346c DF00008A 		bhi	.L505
 5947 3470 010053E3 		cmp	r3, #1
 5948 3474 7D01000A 		beq	.L603
 5949              	.L532:
4089:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 5950              		.loc 1 4089 0
 5951 3478 0000A0E3 		mov	r0, #0
 5952 347c 0110A0E3 		mov	r1, #1
 5953 3480 0020A0E1 		mov	r2, r0
 5954 3484 FEFFFFEB 		bl	CyU3PUsbStall
 5955 3488 18309DE5 		ldr	r3, [sp, #24]
 5956 348c 8BFFFFEA 		b	.L482
 5957              	.L490:
3811:../uvc.c      ****     switch (wValue)
 5958              		.loc 1 3811 0
 5959 3490 010B52E3 		cmp	r2, #1024
 5960 3494 7300000A 		beq	.L488
 5961 3498 050C52E3 		cmp	r2, #1280
 5962 349c 82FFFF1A 		bne	.L484
4096:../uvc.c      ****             	switch (bRequest)
 5963              		.loc 1 4096 0
 5964 34a0 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5965 34a4 810052E3 		cmp	r2, #129
 5966 34a8 7F01000A 		beq	.L556
 5967 34ac 0301008A 		bhi	.L559
 5968 34b0 010052E3 		cmp	r2, #1
 5969 34b4 7CFFFF1A 		bne	.L484
4121:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5970              		.loc 1 4121 0
 5971 34b8 2000A0E3 		mov	r0, #32
 5972 34bc 6C1A9FE5 		ldr	r1, .L608+32
 5973 34c0 1E208DE2 		add	r2, sp, #30
 5974 34c4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5975              	.LVL515:
4123:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 5976              		.loc 1 4123 0
 5977 34c8 000050E3 		cmp	r0, #0
 5978 34cc 6101001A 		bne	.L561
4127:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 5979              		.loc 1 4127 0
 5980 34d0 0020A0E3 		mov	r2, #0
 5981 34d4 340A9FE5 		ldr	r0, .L608
 5982              	.LVL516:
 5983 34d8 8010A0E3 		mov	r1, #128
 5984 34dc FEFFFFEB 		bl	_txe_event_flags_set
 5985              	.LVL517:
4128:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 5986              		.loc 1 4128 0
 5987 34e0 002050E2 		subs	r2, r0, #0
4134:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
 5988              		.loc 1 4134 0
 5989 34e4 0FC0E003 		mvneq	ip, #15
 5990 34e8 BAC0C605 		streqb	ip, [r6, #186]
4128:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 5991              		.loc 1 4128 0
 5992 34ec 0200000A 		beq	.L563
4130:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
 5993              		.loc 1 4130 0
 5994 34f0 3C1A9FE5 		ldr	r1, .L608+36
 5995 34f4 0400A0E3 		mov	r0, #4
 5996              	.LVL518:
 5997 34f8 FEFFFFEB 		bl	CyU3PDebugPrint
 5998              	.LVL519:
 5999              	.L563:
4137:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
 6000              		.loc 1 4137 0
 6001 34fc 8191D4E5 		ldrb	r9, [r4, #385]	@ zero_extendqisi2
 6002 3500 8031D4E5 		ldrb	r3, [r4, #384]	@ zero_extendqisi2
 6003 3504 BE21DDE1 		ldrh	r2, [sp, #30]
 6004              	.LVL520:
 6005 3508 0400A0E3 		mov	r0, #4
 6006 350c 241A9FE5 		ldr	r1, .L608+40
 6007 3510 00908DE5 		str	r9, [sp, #0]
 6008 3514 FEFFFFEB 		bl	CyU3PDebugPrint
 6009 3518 18309DE5 		ldr	r3, [sp, #24]
 6010 351c 67FFFFEA 		b	.L482
 6011              	.LVL521:
 6012              	.L601:
 6013              	.LBE113:
 6014              	.LBE134:
4311:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 6015              		.loc 1 4311 0
 6016 3520 00E097E5 		ldr	lr, [r7, #0]
 6017 3524 0290A0E3 		mov	r9, #2
 6018 3528 0090CEE5 		strb	r9, [lr, #0]
4312:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 6019              		.loc 1 4312 0
 6020 352c 002097E5 		ldr	r2, [r7, #0]
 6021 3530 0190A0E3 		mov	r9, #1
 6022 3534 0190C2E5 		strb	r9, [r2, #1]
4313:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 6023              		.loc 1 4313 0
 6024 3538 001097E5 		ldr	r1, [r7, #0]
 6025 353c 00E0A0E3 		mov	lr, #0
 6026 3540 02E0C1E5 		strb	lr, [r1, #2]
4314:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 6027              		.loc 1 4314 0
 6028 3544 000097E5 		ldr	r0, [r7, #0]
4320:../uvc.c      **** 					interStabuf.count = 4;
 6029              		.loc 1 4320 0
 6030 3548 0420A0E3 		mov	r2, #4	@ movhi
4314:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 6031              		.loc 1 4314 0
 6032 354c 03E0C0E5 		strb	lr, [r0, #3]
4316:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 6033              		.loc 1 4316 0
 6034 3550 00C097E5 		ldr	ip, [r7, #0]
4317:../uvc.c      **** 					interStabuf.size   = 1024;
 6035              		.loc 1 4317 0
 6036 3554 013BA0E3 		mov	r3, #1024	@ movhi
4323:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 6037              		.loc 1 4323 0
 6038 3558 0010E0E3 		mvn	r1, #0
 6039 355c C8099FE5 		ldr	r0, .L608+28
4320:../uvc.c      **** 					interStabuf.count = 4;
 6040              		.loc 1 4320 0
 6041 3560 BC20CDE1 		strh	r2, [sp, #12]	@ movhi
4316:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 6042              		.loc 1 4316 0
 6043 3564 08C08DE5 		str	ip, [sp, #8]
4317:../uvc.c      **** 					interStabuf.size   = 1024;
 6044              		.loc 1 4317 0
 6045 3568 BE30CDE1 		strh	r3, [sp, #14]	@ movhi
4318:../uvc.c      **** 					interStabuf.status = 0;
 6046              		.loc 1 4318 0
 6047 356c B0E1CDE1 		strh	lr, [sp, #16]	@ movhi
4323:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 6048              		.loc 1 4323 0
 6049 3570 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
4326:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 6050              		.loc 1 4326 0
 6051 3574 B0099FE5 		ldr	r0, .L608+28
 6052 3578 08108DE2 		add	r1, sp, #8
 6053 357c FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 6054              	.LVL522:
4328:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 6055              		.loc 1 4328 0
 6056 3580 002050E2 		subs	r2, r0, #0
 6057 3584 F500001A 		bne	.L604
4333:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
 6058              		.loc 1 4333 0
 6059 3588 3010A0E3 		mov	r1, #48
 6060 358c 0500A0E3 		mov	r0, #5
 6061              	.LVL523:
 6062 3590 FEFFFFEB 		bl	SensorSetControl
 6063              	.LVL524:
4335:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
 6064              		.loc 1 4335 0
 6065 3594 78399FE5 		ldr	r3, .L608+4
 6066 3598 0B97C3E5 		strb	r9, [r3, #1803]
4460:../uvc.c      ****         CyU3PThreadRelinquish ();
 6067              		.loc 1 4460 0
 6068 359c FEFFFFEB 		bl	_txe_thread_relinquish
 6069 35a0 10FFFFEA 		b	.L569
 6070              	.L450:
 6071              	.LBB135:
 6072              	.LBB102:
3480:../uvc.c      ****     switch (wValue)
 6073              		.loc 1 3480 0
 6074 35a4 090C52E3 		cmp	r2, #2304
 6075 35a8 2601000A 		beq	.L446
 6076 35ac D100008A 		bhi	.L452
 6077 35b0 070C52E3 		cmp	r2, #1792
 6078 35b4 1F01000A 		beq	.L445
 6079 35b8 020B52E3 		cmp	r2, #2048
 6080 35bc 2CFFFF1A 		bne	.L438
 6081 35c0 34FFFFEA 		b	.L417
 6082              	.L476:
 6083              	.LBE102:
 6084              	.LBE135:
 6085              	.LBB136:
 6086              	.LBB124:
3710:../uvc.c      ****     switch (wValue)
 6087              		.loc 1 3710 0
 6088 35c4 0F0C53E3 		cmp	r3, #3840
 6089 35c8 1601000A 		beq	.L471
 6090 35cc F400008A 		bhi	.L479
 6091 35d0 0B0C53E3 		cmp	r3, #2816
 6092 35d4 0F01000A 		beq	.L468
 6093 35d8 E900008A 		bhi	.L480
 6094 35dc 0A0C53E3 		cmp	r3, #2560
 6095 35e0 27FFFF1A 		bne	.L418
 6096              	.LVL525:
3751:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 6097              		.loc 1 3751 0
 6098 35e4 1900A0E3 		mov	r0, #25
 6099 35e8 FEFFFFEB 		bl	ControlHandle
 6100              	.LVL526:
 6101 35ec 18309DE5 		ldr	r3, [sp, #24]
 6102 35f0 28FFFFEA 		b	.L417
 6103              	.L435:
 6104              	.LBE124:
 6105              	.LBE136:
 6106              	.LBB137:
 6107              	.LBB96:
3405:../uvc.c      ****     switch (wValue)
 6108              		.loc 1 3405 0
 6109 35f4 0A0C52E3 		cmp	r2, #2560
 6110 35f8 0201000A 		beq	.L432
 6111 35fc 0F00008A 		bhi	.L437
 6112 3600 070C52E3 		cmp	r2, #1792
 6113 3604 FB00000A 		beq	.L430
 6114 3608 020B52E3 		cmp	r2, #2048
 6115 360c 18FFFF1A 		bne	.L438
 6116              	.LVL527:
3436:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 6117              		.loc 1 3436 0
 6118 3610 0700A0E3 		mov	r0, #7
 6119 3614 FEFFFFEB 		bl	ControlHandle
 6120              	.LVL528:
 6121 3618 18309DE5 		ldr	r3, [sp, #24]
 6122 361c 1DFFFFEA 		b	.L417
 6123              	.L436:
3405:../uvc.c      ****     switch (wValue)
 6124              		.loc 1 3405 0
 6125 3620 010B52E3 		cmp	r2, #1024
 6126 3624 1BFFFF0A 		beq	.L417
 6127 3628 050C52E3 		cmp	r2, #1280
 6128 362c 10FFFF1A 		bne	.L438
 6129              	.LVL529:
3424:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 6130              		.loc 1 3424 0
 6131 3630 0400A0E3 		mov	r0, #4
 6132 3634 FEFFFFEB 		bl	ControlHandle
 6133              	.LVL530:
 6134 3638 18309DE5 		ldr	r3, [sp, #24]
 6135 363c 15FFFFEA 		b	.L417
 6136              	.L437:
3405:../uvc.c      ****     switch (wValue)
 6137              		.loc 1 3405 0
 6138 3640 0D0C52E3 		cmp	r2, #3328
 6139 3644 EF00000A 		beq	.L432
 6140 3648 0E0C52E3 		cmp	r2, #3584
 6141 364c E500000A 		beq	.L434
 6142 3650 030B52E3 		cmp	r2, #3072
 6143 3654 06FFFF1A 		bne	.L438
 6144              	.LVL531:
3446:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 6145              		.loc 1 3446 0
 6146 3658 0B00A0E3 		mov	r0, #11
 6147 365c FEFFFFEB 		bl	ControlHandle
 6148              	.LVL532:
 6149 3660 18309DE5 		ldr	r3, [sp, #24]
 6150 3664 0BFFFFEA 		b	.L417
 6151              	.LVL533:
 6152              	.L488:
 6153              	.LBE96:
 6154              	.LBE137:
 6155              	.LBB138:
 6156              	.LBB115:
4010:../uvc.c      ****                 switch (bRequest)
 6157              		.loc 1 4010 0
 6158 3668 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 6159 366c 810052E3 		cmp	r2, #129
 6160 3670 5600000A 		beq	.L534
 6161 3674 1D00008A 		bhi	.L537
 6162 3678 010052E3 		cmp	r2, #1
 6163 367c 7DFFFF1A 		bne	.L532
4035:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 6164              		.loc 1 4035 0
 6165 3680 2000A0E3 		mov	r0, #32
 6166 3684 A4189FE5 		ldr	r1, .L608+32
 6167 3688 1E208DE2 		add	r2, sp, #30
 6168 368c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6169              	.LVL534:
4037:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 6170              		.loc 1 4037 0
 6171 3690 000050E3 		cmp	r0, #0
 6172 3694 08FFFF1A 		bne	.L588
4056:../uvc.c      ****                            switch (glCommitCtrl[1])
 6173              		.loc 1 4056 0
 6174 3698 8111D6E5 		ldrb	r1, [r6, #385]	@ zero_extendqisi2
 6175 369c 012041E2 		sub	r2, r1, #1
 6176 36a0 030052E3 		cmp	r2, #3
 6177 36a4 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 6178 36a8 B40100EA 		b	.L540
 6179              	.L545:
 6180 36ac EC3D0000 		.word	.L541
 6181 36b0 403E0000 		.word	.L542
 6182 36b4 A83D0000 		.word	.L543
 6183 36b8 403D0000 		.word	.L544
 6184              	.LVL535:
 6185              	.L485:
3814:../uvc.c      ****             switch (bRequest)
 6186              		.loc 1 3814 0
 6187 36bc 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 6188 36c0 830052E3 		cmp	r2, #131
 6189 36c4 2D00008A 		bhi	.L496
 6190 36c8 810052E3 		cmp	r2, #129
 6191 36cc 1200003A 		bcc	.L605
 6192              	.L493:
3829:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
 6193              		.loc 1 3829 0
 6194 36d0 C820D4E5 		ldrb	r2, [r4, #200]	@ zero_extendqisi2
 6195 36d4 030052E3 		cmp	r2, #3
 6196 36d8 8B01000A 		beq	.L606
 6197              	.L560:
4114:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 6198              		.loc 1 4114 0
 6199 36dc 1A00A0E3 		mov	r0, #26
 6200 36e0 54189FE5 		ldr	r1, .L608+44
 6201 36e4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6202 36e8 18309DE5 		ldr	r3, [sp, #24]
 6203 36ec F3FEFFEA 		b	.L482
 6204              	.L537:
4010:../uvc.c      ****                 switch (bRequest)
 6205              		.loc 1 4010 0
 6206 36f0 850052E3 		cmp	r2, #133
 6207 36f4 2700000A 		beq	.L535
 6208 36f8 860052E3 		cmp	r2, #134
 6209 36fc 5DFFFF1A 		bne	.L532
 6210              	.L592:
4014:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 6211              		.loc 1 4014 0
 6212 3700 0300A0E1 		mov	r0, r3
 6213              	.L587:
3880:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 6214              		.loc 1 3880 0
 6215 3704 34189FE5 		ldr	r1, .L608+48
3879:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 6216              		.loc 1 3879 0
 6217 3708 0390A0E3 		mov	r9, #3
 6218 370c 1C91C4E5 		strb	r9, [r4, #284]
3880:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 6219              		.loc 1 3880 0
 6220 3710 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6221 3714 18309DE5 		ldr	r3, [sp, #24]
 6222 3718 E8FEFFEA 		b	.L482
 6223              	.L605:
3814:../uvc.c      ****             switch (bRequest)
 6224              		.loc 1 3814 0
 6225 371c 010052E3 		cmp	r2, #1
 6226 3720 54FFFF1A 		bne	.L532
3841:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 6227              		.loc 1 3841 0
 6228 3724 2000A0E3 		mov	r0, #32
 6229 3728 00189FE5 		ldr	r1, .L608+32
 6230 372c 1E208DE2 		add	r2, sp, #30
 6231 3730 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6232              	.LVL536:
3843:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 6233              		.loc 1 3843 0
 6234 3734 000050E3 		cmp	r0, #0
 6235 3738 DFFEFF1A 		bne	.L588
3845:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 6236              		.loc 1 3845 0
 6237 373c C890D6E5 		ldrb	r9, [r6, #200]	@ zero_extendqisi2
 6238 3740 030059E3 		cmp	r9, #3
 6239 3744 DCFEFF1A 		bne	.L588
3854:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 6240              		.loc 1 3854 0
 6241 3748 8731D4E5 		ldrb	r3, [r4, #391]	@ zero_extendqisi2
3849:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 6242              		.loc 1 3849 0
 6243 374c 82E1D4E5 		ldrb	lr, [r4, #386]	@ zero_extendqisi2
3850:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 6244              		.loc 1 3850 0
 6245 3750 83C1D4E5 		ldrb	ip, [r4, #387]	@ zero_extendqisi2
3851:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 6246              		.loc 1 3851 0
 6247 3754 8401D4E5 		ldrb	r0, [r4, #388]	@ zero_extendqisi2
 6248              	.LVL537:
3852:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 6249              		.loc 1 3852 0
 6250 3758 8511D4E5 		ldrb	r1, [r4, #389]	@ zero_extendqisi2
3853:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 6251              		.loc 1 3853 0
 6252 375c 8621D4E5 		ldrb	r2, [r4, #390]	@ zero_extendqisi2
3854:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 6253              		.loc 1 3854 0
 6254 3760 A736C5E5 		strb	r3, [r5, #1703]
3849:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 6255              		.loc 1 3849 0
 6256 3764 A2E6C5E5 		strb	lr, [r5, #1698]
3850:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 6257              		.loc 1 3850 0
 6258 3768 A3C6C5E5 		strb	ip, [r5, #1699]
3851:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 6259              		.loc 1 3851 0
 6260 376c A406C5E5 		strb	r0, [r5, #1700]
3852:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 6261              		.loc 1 3852 0
 6262 3770 A516C5E5 		strb	r1, [r5, #1701]
3853:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 6263              		.loc 1 3853 0
 6264 3774 A626C5E5 		strb	r2, [r5, #1702]
3854:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 6265              		.loc 1 3854 0
 6266 3778 18309DE5 		ldr	r3, [sp, #24]
 6267 377c CFFEFFEA 		b	.L482
 6268              	.LVL538:
 6269              	.L496:
3814:../uvc.c      ****             switch (bRequest)
 6270              		.loc 1 3814 0
 6271 3780 860052E3 		cmp	r2, #134
 6272 3784 DDFFFF0A 		beq	.L592
 6273 3788 870052E3 		cmp	r2, #135
 6274 378c CFFFFF0A 		beq	.L493
 6275              	.L597:
3960:../uvc.c      ****                 switch (bRequest)
 6276              		.loc 1 3960 0
 6277 3790 850052E3 		cmp	r2, #133
 6278 3794 37FFFF1A 		bne	.L532
 6279              	.L535:
4019:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6280              		.loc 1 4019 0
 6281 3798 A0179FE5 		ldr	r1, .L608+48
 6282 379c 0200A0E3 		mov	r0, #2
4017:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 6283              		.loc 1 4017 0
 6284 37a0 1A30A0E3 		mov	r3, #26
 6285              	.L589:
4103:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 6286              		.loc 1 4103 0
 6287 37a4 1C31C4E5 		strb	r3, [r4, #284]
4104:../uvc.c      ****                         glEp0Buffer[1] = 0;
 6288              		.loc 1 4104 0
 6289 37a8 0030A0E3 		mov	r3, #0
 6290 37ac 1D31C4E5 		strb	r3, [r4, #285]
4105:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6291              		.loc 1 4105 0
 6292 37b0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6293 37b4 18309DE5 		ldr	r3, [sp, #24]
 6294 37b8 C0FEFFEA 		b	.L482
 6295              	.L487:
3960:../uvc.c      ****                 switch (bRequest)
 6296              		.loc 1 3960 0
 6297 37bc 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 6298 37c0 830052E3 		cmp	r2, #131
 6299 37c4 2F00008A 		bhi	.L528
 6300 37c8 810052E3 		cmp	r2, #129
 6301 37cc 0D00003A 		bcc	.L607
 6302              	.L534:
4022:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 6303              		.loc 1 4022 0
 6304 37d0 C800D4E5 		ldrb	r0, [r4, #200]	@ zero_extendqisi2
 6305 37d4 030050E3 		cmp	r0, #3
4024:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 6306              		.loc 1 4024 0
 6307 37d8 64179F05 		ldreq	r1, .L608+52
 6308 37dc 0B00A0E3 		mov	r0, #11
4028:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 6309              		.loc 1 4028 0
 6310 37e0 60179F15 		ldrne	r1, .L608+56
 6311 37e4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6312 37e8 18309DE5 		ldr	r3, [sp, #24]
 6313 37ec B3FEFFEA 		b	.L482
 6314              	.L505:
3876:../uvc.c      ****             switch (bRequest)
 6315              		.loc 1 3876 0
 6316 37f0 850053E3 		cmp	r3, #133
 6317 37f4 E7FFFF0A 		beq	.L535
 6318 37f8 860053E3 		cmp	r3, #134
 6319 37fc 1DFFFF1A 		bne	.L532
 6320              	.L593:
3880:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 6321              		.loc 1 3880 0
 6322 3800 0100A0E3 		mov	r0, #1
 6323 3804 BEFFFFEA 		b	.L587
 6324              	.L607:
3960:../uvc.c      ****                 switch (bRequest)
 6325              		.loc 1 3960 0
 6326 3808 010052E3 		cmp	r2, #1
 6327 380c 19FFFF1A 		bne	.L532
3985:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 6328              		.loc 1 3985 0
 6329 3810 2000A0E3 		mov	r0, #32
 6330 3814 14179FE5 		ldr	r1, .L608+32
 6331 3818 1E208DE2 		add	r2, sp, #30
 6332 381c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6333              	.LVL539:
3987:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 6334              		.loc 1 3987 0
 6335 3820 000050E3 		cmp	r0, #0
 6336 3824 A4FEFF1A 		bne	.L588
3989:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 6337              		.loc 1 3989 0
 6338 3828 C800D6E5 		ldrb	r0, [r6, #200]	@ zero_extendqisi2
 6339              	.LVL540:
 6340 382c 030050E3 		cmp	r0, #3
 6341 3830 0B00001A 		bne	.L531
3993:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 6342              		.loc 1 3993 0
 6343 3834 81E1D6E5 		ldrb	lr, [r6, #385]	@ zero_extendqisi2
3994:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 6344              		.loc 1 3994 0
 6345 3838 82C1D6E5 		ldrb	ip, [r6, #386]	@ zero_extendqisi2
3995:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 6346              		.loc 1 3995 0
 6347 383c 8331D6E5 		ldrb	r3, [r6, #387]	@ zero_extendqisi2
3996:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 6348              		.loc 1 3996 0
 6349 3840 8411D6E5 		ldrb	r1, [r6, #388]	@ zero_extendqisi2
3997:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 6350              		.loc 1 3997 0
 6351 3844 8521D6E5 		ldrb	r2, [r6, #389]	@ zero_extendqisi2
3998:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 6352              		.loc 1 3998 0
 6353 3848 8691D6E5 		ldrb	r9, [r6, #390]	@ zero_extendqisi2
3993:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 6354              		.loc 1 3993 0
 6355 384c F5E6C5E5 		strb	lr, [r5, #1781]
3994:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 6356              		.loc 1 3994 0
 6357 3850 F6C6C5E5 		strb	ip, [r5, #1782]
3995:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 6358              		.loc 1 3995 0
 6359 3854 F736C5E5 		strb	r3, [r5, #1783]
3996:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 6360              		.loc 1 3996 0
 6361 3858 F816C5E5 		strb	r1, [r5, #1784]
3997:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 6362              		.loc 1 3997 0
 6363 385c F926C5E5 		strb	r2, [r5, #1785]
3998:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 6364              		.loc 1 3998 0
 6365 3860 FA96C5E5 		strb	r9, [r5, #1786]
 6366              	.L531:
4000:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
 6367              		.loc 1 4000 0
 6368 3864 8191D4E5 		ldrb	r9, [r4, #385]	@ zero_extendqisi2
 6369 3868 8031D4E5 		ldrb	r3, [r4, #384]	@ zero_extendqisi2
 6370 386c BE21DDE1 		ldrh	r2, [sp, #30]
 6371              	.LVL541:
 6372 3870 0400A0E3 		mov	r0, #4
 6373 3874 D0169FE5 		ldr	r1, .L608+60
 6374 3878 00908DE5 		str	r9, [sp, #0]
 6375 387c FEFFFFEB 		bl	CyU3PDebugPrint
 6376 3880 18309DE5 		ldr	r3, [sp, #24]
 6377 3884 8DFEFFEA 		b	.L482
 6378              	.LVL542:
 6379              	.L528:
3960:../uvc.c      ****                 switch (bRequest)
 6380              		.loc 1 3960 0
 6381 3888 860052E3 		cmp	r2, #134
 6382 388c 9BFFFF0A 		beq	.L592
 6383 3890 870052E3 		cmp	r2, #135
 6384 3894 BDFFFF1A 		bne	.L597
 6385 3898 CCFFFFEA 		b	.L534
 6386              	.LVL543:
 6387              	.L602:
 6388              	.LBE115:
 6389              	.LBE138:
4357:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 6390              		.loc 1 4357 0
 6391 389c 0400A0E3 		mov	r0, #4
 6392              	.LVL544:
 6393 38a0 A8169FE5 		ldr	r1, .L608+64
 6394 38a4 FEFFFFEB 		bl	CyU3PDebugPrint
 6395              	.LVL545:
 6396              	.L568:
 6397              	.LBB139:
 6398              	.LBB140:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6399              		.loc 1 2061 0
 6400 38a8 A4169FE5 		ldr	r1, .L608+68
 6401 38ac 0400A0E3 		mov	r0, #4
 6402 38b0 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 6403              		.loc 1 2062 0
 6404 38b4 FA0FA0E3 		mov	r0, #1000
 6405 38b8 FEFFFFEB 		bl	_tx_thread_sleep
 6406 38bc F9FFFFEA 		b	.L568
 6407              	.LVL546:
 6408              	.L559:
 6409              	.LBE140:
 6410              	.LBE139:
 6411              	.LBB141:
 6412              	.LBB112:
4096:../uvc.c      ****             	switch (bRequest)
 6413              		.loc 1 4096 0
 6414 38c0 850052E3 		cmp	r2, #133
 6415 38c4 8E01000A 		beq	.L557
 6416 38c8 860052E3 		cmp	r2, #134
 6417 38cc 76FEFF1A 		bne	.L484
 6418 38d0 CAFFFFEA 		b	.L593
 6419              	.LVL547:
 6420              	.L477:
 6421              	.LBE112:
 6422              	.LBE141:
 6423              	.LBB142:
 6424              	.LBB126:
3710:../uvc.c      ****     switch (wValue)
 6425              		.loc 1 3710 0
 6426 38d4 060C53E3 		cmp	r3, #1536
 6427 38d8 8501000A 		beq	.L463
 6428 38dc 0F00008A 		bhi	.L478
 6429 38e0 050C53E3 		cmp	r3, #1280
 6430 38e4 66FEFF1A 		bne	.L418
 6431              	.LVL548:
3730:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 6432              		.loc 1 3730 0
 6433 38e8 1400A0E3 		mov	r0, #20
 6434 38ec FEFFFFEB 		bl	ControlHandle
 6435              	.LVL549:
 6436 38f0 18309DE5 		ldr	r3, [sp, #24]
 6437 38f4 67FEFFEA 		b	.L417
 6438              	.L452:
 6439              	.LBE126:
 6440              	.LBE142:
 6441              	.LBB143:
 6442              	.LBB105:
3480:../uvc.c      ****     switch (wValue)
 6443              		.loc 1 3480 0
 6444 38f8 0B0C52E3 		cmp	r2, #2816
 6445 38fc 7801000A 		beq	.L448
 6446 3900 030B52E3 		cmp	r2, #3072
 6447 3904 7201000A 		beq	.L449
 6448 3908 0A0C52E3 		cmp	r2, #2560
 6449 390c 58FEFF1A 		bne	.L438
 6450              	.LVL550:
3521:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 6451              		.loc 1 3521 0
 6452 3910 0800A0E3 		mov	r0, #8
 6453 3914 FEFFFFEB 		bl	CTControlHandle
 6454              	.LVL551:
 6455 3918 18309DE5 		ldr	r3, [sp, #24]
 6456 391c 5DFEFFEA 		b	.L417
 6457              	.L478:
 6458              	.LBE105:
 6459              	.LBE143:
 6460              	.LBB144:
 6461              	.LBB123:
3710:../uvc.c      ****     switch (wValue)
 6462              		.loc 1 3710 0
 6463 3920 070C53E3 		cmp	r3, #1792
 6464 3924 6601000A 		beq	.L464
 6465 3928 020B53E3 		cmp	r3, #2048
 6466 392c 54FEFF1A 		bne	.L418
 6467              	.LVL552:
3742:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 6468              		.loc 1 3742 0
 6469 3930 1700A0E3 		mov	r0, #23
 6470 3934 FEFFFFEB 		bl	ControlHandle
 6471              	.LVL553:
 6472 3938 18309DE5 		ldr	r3, [sp, #24]
 6473 393c 55FEFFEA 		b	.L417
 6474              	.L451:
 6475              	.LBE123:
 6476              	.LBE144:
 6477              	.LBB145:
 6478              	.LBB101:
3480:../uvc.c      ****     switch (wValue)
 6479              		.loc 1 3480 0
 6480 3940 010B52E3 		cmp	r2, #1024
 6481 3944 5A01000A 		beq	.L442
 6482 3948 050C52E3 		cmp	r2, #1280
 6483 394c 48FEFF1A 		bne	.L438
 6484              	.LVL554:
3502:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 6485              		.loc 1 3502 0
 6486 3950 0400A0E3 		mov	r0, #4
 6487 3954 FEFFFFEB 		bl	CTControlHandle
 6488              	.LVL555:
 6489 3958 18309DE5 		ldr	r3, [sp, #24]
 6490 395c 4DFEFFEA 		b	.L417
 6491              	.LVL556:
 6492              	.L604:
 6493              	.LBE101:
 6494              	.LBE145:
4330:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 6495              		.loc 1 4330 0
 6496 3960 0400A0E3 		mov	r0, #4
 6497              	.LVL557:
 6498 3964 E4159FE5 		ldr	r1, .L608+64
 6499 3968 FEFFFFEB 		bl	CyU3PDebugPrint
 6500              	.LVL558:
 6501              	.L566:
 6502              	.LBB146:
 6503              	.LBB147:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6504              		.loc 1 2061 0
 6505 396c E0159FE5 		ldr	r1, .L608+68
 6506 3970 0400A0E3 		mov	r0, #4
 6507 3974 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 6508              		.loc 1 2062 0
 6509 3978 FA0FA0E3 		mov	r0, #1000
 6510 397c FEFFFFEB 		bl	_tx_thread_sleep
 6511 3980 F9FFFFEA 		b	.L566
 6512              	.L480:
 6513              	.LBE147:
 6514              	.LBE146:
 6515              	.LBB148:
 6516              	.LBB127:
3710:../uvc.c      ****     switch (wValue)
 6517              		.loc 1 3710 0
 6518 3984 030B53E3 		cmp	r3, #3072
 6519 3988 4501000A 		beq	.L469
 6520 398c 0D0C53E3 		cmp	r3, #3328
 6521 3990 3BFEFF1A 		bne	.L418
 6522              	.LVL559:
3767:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 6523              		.loc 1 3767 0
 6524 3994 1C00A0E3 		mov	r0, #28
 6525 3998 FEFFFFEB 		bl	ControlHandle
 6526              	.LVL560:
 6527 399c 18309DE5 		ldr	r3, [sp, #24]
 6528 39a0 3CFEFFEA 		b	.L417
 6529              	.L479:
3710:../uvc.c      ****     switch (wValue)
 6530              		.loc 1 3710 0
 6531 39a4 110C53E3 		cmp	r3, #4352
 6532 39a8 3901000A 		beq	.L473
 6533 39ac 0500008A 		bhi	.L481
 6534 39b0 010A53E3 		cmp	r3, #4096
 6535 39b4 32FEFF1A 		bne	.L418
 6536              	.LVL561:
3779:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 6537              		.loc 1 3779 0
 6538 39b8 1F00A0E3 		mov	r0, #31
 6539 39bc FEFFFFEB 		bl	ControlHandle
 6540              	.LVL562:
 6541 39c0 18309DE5 		ldr	r3, [sp, #24]
 6542 39c4 33FEFFEA 		b	.L417
 6543              	.L481:
3710:../uvc.c      ****     switch (wValue)
 6544              		.loc 1 3710 0
 6545 39c8 120C53E3 		cmp	r3, #4608
 6546 39cc D700000A 		beq	.L474
 6547 39d0 130C53E3 		cmp	r3, #4864
 6548 39d4 2AFEFF1A 		bne	.L418
 6549              	.LVL563:
3791:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
 6550              		.loc 1 3791 0
 6551 39d8 2600A0E3 		mov	r0, #38
 6552 39dc FEFFFFEB 		bl	ControlHandle
 6553              	.LVL564:
 6554 39e0 18309DE5 		ldr	r3, [sp, #24]
 6555 39e4 2BFEFFEA 		b	.L417
 6556              	.L434:
 6557              	.LVL565:
 6558              	.LBE127:
 6559              	.LBE148:
 6560              	.LBB149:
 6561              	.LBB94:
3450:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 6562              		.loc 1 3450 0
 6563 39e8 0E00A0E3 		mov	r0, #14
 6564 39ec FEFFFFEB 		bl	ControlHandle
 6565              	.LVL566:
 6566 39f0 18309DE5 		ldr	r3, [sp, #24]
 6567 39f4 27FEFFEA 		b	.L417
 6568              	.L430:
 6569              	.LVL567:
3432:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 6570              		.loc 1 3432 0
 6571 39f8 0600A0E3 		mov	r0, #6
 6572 39fc FEFFFFEB 		bl	ControlHandle
 6573              	.LVL568:
 6574 3a00 18309DE5 		ldr	r3, [sp, #24]
 6575 3a04 23FEFFEA 		b	.L417
 6576              	.L432:
 6577              	.LVL569:
3442:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 6578              		.loc 1 3442 0
 6579 3a08 0900A0E3 		mov	r0, #9
 6580 3a0c FEFFFFEB 		bl	ControlHandle
 6581              	.LVL570:
 6582 3a10 18309DE5 		ldr	r3, [sp, #24]
 6583 3a14 1FFEFFEA 		b	.L417
 6584              	.L468:
 6585              	.LVL571:
 6586              	.LBE94:
 6587              	.LBE149:
 6588              	.LBB150:
 6589              	.LBB122:
3757:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 6590              		.loc 1 3757 0
 6591 3a18 1A00A0E3 		mov	r0, #26
 6592 3a1c FEFFFFEB 		bl	ControlHandle
 6593              	.LVL572:
 6594 3a20 18309DE5 		ldr	r3, [sp, #24]
 6595 3a24 1BFEFFEA 		b	.L417
 6596              	.L471:
 6597              	.LVL573:
3775:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 6598              		.loc 1 3775 0
 6599 3a28 1E00A0E3 		mov	r0, #30
 6600 3a2c FEFFFFEB 		bl	ControlHandle
 6601              	.LVL574:
 6602 3a30 18309DE5 		ldr	r3, [sp, #24]
 6603 3a34 17FEFFEA 		b	.L417
 6604              	.L445:
 6605              	.LVL575:
 6606              	.LBE122:
 6607              	.LBE150:
 6608              	.LBB151:
 6609              	.LBB106:
3510:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 6610              		.loc 1 3510 0
 6611 3a38 0600A0E3 		mov	r0, #6
 6612 3a3c FEFFFFEB 		bl	CTControlHandle
 6613              	.LVL576:
 6614 3a40 18309DE5 		ldr	r3, [sp, #24]
 6615 3a44 13FEFFEA 		b	.L417
 6616              	.L446:
 6617              	.LVL577:
3516:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 6618              		.loc 1 3516 0
 6619 3a48 0700A0E3 		mov	r0, #7
 6620 3a4c FEFFFFEB 		bl	CTControlHandle
 6621              	.LVL578:
 6622 3a50 18309DE5 		ldr	r3, [sp, #24]
 6623 3a54 0FFEFFEA 		b	.L417
 6624              	.LVL579:
 6625              	.L561:
 6626              	.LBE106:
 6627              	.LBE151:
 6628              	.LBB152:
 6629              	.LBB116:
4139:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 6630              		.loc 1 4139 0
 6631 3a58 F8149FE5 		ldr	r1, .L608+72
 6632 3a5c BE21DDE1 		ldrh	r2, [sp, #30]
 6633 3a60 8031D4E5 		ldrb	r3, [r4, #384]	@ zero_extendqisi2
 6634 3a64 0400A0E3 		mov	r0, #4
 6635              	.LVL580:
 6636 3a68 FEFFFFEB 		bl	CyU3PDebugPrint
 6637 3a6c 0EFEFFEA 		b	.L484
 6638              	.LVL581:
 6639              	.L603:
3901:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 6640              		.loc 1 3901 0
 6641 3a70 2000A0E3 		mov	r0, #32
 6642 3a74 B4149FE5 		ldr	r1, .L608+32
 6643 3a78 1E208DE2 		add	r2, sp, #30
 6644 3a7c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6645              	.LVL582:
3903:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 6646              		.loc 1 3903 0
 6647 3a80 000050E3 		cmp	r0, #0
 6648 3a84 0CFEFF1A 		bne	.L588
3905:../uvc.c      ****                         switch (glCommitCtrl[3])
 6649              		.loc 1 3905 0
 6650 3a88 8321D4E5 		ldrb	r2, [r4, #387]	@ zero_extendqisi2
 6651 3a8c 013042E2 		sub	r3, r2, #1
 6652 3a90 030053E3 		cmp	r3, #3
 6653 3a94 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 6654 3a98 290000EA 		b	.L508
 6655              	.L513:
 6656 3a9c E43B0000 		.word	.L509
 6657 3aa0 303C0000 		.word	.L510
 6658 3aa4 883B0000 		.word	.L511
 6659 3aa8 EC3A0000 		.word	.L512
 6660              	.LVL583:
 6661              	.L556:
4108:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 6662              		.loc 1 4108 0
 6663 3aac C810D4E5 		ldrb	r1, [r4, #200]	@ zero_extendqisi2
 6664 3ab0 030051E3 		cmp	r1, #3
 6665 3ab4 08FFFF1A 		bne	.L560
4110:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 6666              		.loc 1 4110 0
 6667 3ab8 1A00A0E3 		mov	r0, #26
 6668 3abc 98149FE5 		ldr	r1, .L608+76
 6669 3ac0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6670 3ac4 18309DE5 		ldr	r3, [sp, #24]
 6671 3ac8 FCFDFFEA 		b	.L482
 6672              	.LVL584:
 6673              	.L439:
 6674              	.LBE116:
 6675              	.LBE152:
 6676              	.LBB153:
 6677              	.LBB100:
3484:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 6678              		.loc 1 3484 0
 6679 3acc 0000A0E3 		mov	r0, #0
 6680 3ad0 FEFFFFEB 		bl	CTControlHandle
 6681              	.LVL585:
 6682 3ad4 18309DE5 		ldr	r3, [sp, #24]
 6683 3ad8 EEFDFFEA 		b	.L417
 6684              	.L441:
 6685              	.LVL586:
3492:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 6686              		.loc 1 3492 0
 6687 3adc 0200A0E3 		mov	r0, #2
 6688 3ae0 FEFFFFEB 		bl	CTControlHandle
 6689              	.LVL587:
 6690 3ae4 18309DE5 		ldr	r3, [sp, #24]
 6691 3ae8 EAFDFFEA 		b	.L417
 6692              	.LVL588:
 6693              	.L512:
 6694              	.LBE100:
 6695              	.LBE153:
 6696              	.LBB154:
 6697              	.LBB111:
3923:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
 6698              		.loc 1 3923 0
 6699 3aec D8C094E5 		ldr	ip, [r4, #216]
 6700 3af0 8D34D5E5 		ldrb	r3, [r5, #1165]	@ zero_extendqisi2
 6701 3af4 00005CE3 		cmp	ip, #0
 6702 3af8 F4C0A003 		moveq	ip, #244
 6703 3afc 74C0A013 		movne	ip, #116
 6704 3b00 03208CE1 		orr	r2, ip, r3
 6705 3b04 3010A0E3 		mov	r1, #48
 6706 3b08 5230A0E3 		mov	r3, #82
 6707 3b0c 0100A0E3 		mov	r0, #1
 6708              	.LVL589:
 6709 3b10 FEFFFFEB 		bl	SensorSetIrisControl
3924:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6710              		.loc 1 3924 0
 6711 3b14 7D0FA0E3 		mov	r0, #500
 6712 3b18 FEFFFFEB 		bl	_tx_thread_sleep
3925:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 6713              		.loc 1 3925 0
 6714 3b1c D89094E5 		ldr	r9, [r4, #216]
 6715 3b20 8D24D5E5 		ldrb	r2, [r5, #1165]	@ zero_extendqisi2
 6716 3b24 000059E3 		cmp	r9, #0
 6717 3b28 F490A003 		moveq	r9, #244
 6718 3b2c 7490A013 		movne	r9, #116
 6719 3b30 D83094E5 		ldr	r3, [r4, #216]
 6720 3b34 0400A0E3 		mov	r0, #4
 6721 3b38 20149FE5 		ldr	r1, .L608+80
 6722 3b3c 022089E1 		orr	r2, r9, r2
 6723 3b40 FEFFFFEB 		bl	CyU3PDebugPrint
 6724              	.L508:
3930:../uvc.c      ****                         setRes = glCommitCtrl[3];
 6725              		.loc 1 3930 0
 6726 3b44 83E1D4E5 		ldrb	lr, [r4, #387]	@ zero_extendqisi2
3931:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 6727              		.loc 1 3931 0
 6728 3b48 14149FE5 		ldr	r1, .L608+84
 6729 3b4c 0E20A0E1 		mov	r2, lr
 6730 3b50 0400A0E3 		mov	r0, #4
3930:../uvc.c      ****                         setRes = glCommitCtrl[3];
 6731              		.loc 1 3930 0
 6732 3b54 7DE1C4E5 		strb	lr, [r4, #381]
3931:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 6733              		.loc 1 3931 0
 6734 3b58 FEFFFFEB 		bl	CyU3PDebugPrint
3944:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 6735              		.loc 1 3944 0
 6736 3b5c 0020A0E3 		mov	r2, #0
 6737 3b60 A8039FE5 		ldr	r0, .L608
 6738 3b64 0110A0E3 		mov	r1, #1
 6739 3b68 FEFFFFEB 		bl	_txe_event_flags_set
 6740              	.LVL590:
3945:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 6741              		.loc 1 3945 0
 6742 3b6c 002050E2 		subs	r2, r0, #0
 6743 3b70 D1FDFF0A 		beq	.L588
3947:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
 6744              		.loc 1 3947 0
 6745 3b74 0400A0E3 		mov	r0, #4
 6746              	.LVL591:
 6747 3b78 E8139FE5 		ldr	r1, .L608+88
 6748 3b7c FEFFFFEB 		bl	CyU3PDebugPrint
 6749              	.LVL592:
 6750 3b80 18309DE5 		ldr	r3, [sp, #24]
 6751 3b84 CDFDFFEA 		b	.L482
 6752              	.LVL593:
 6753              	.L511:
3918:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
 6754              		.loc 1 3918 0
 6755 3b88 D81094E5 		ldr	r1, [r4, #216]
 6756 3b8c 8DE4D5E5 		ldrb	lr, [r5, #1165]	@ zero_extendqisi2
 6757 3b90 000051E3 		cmp	r1, #0
 6758 3b94 C410A003 		moveq	r1, #196
 6759 3b98 4410A013 		movne	r1, #68
 6760 3b9c 0E2081E1 		orr	r2, r1, lr
 6761 3ba0 5230A0E3 		mov	r3, #82
 6762 3ba4 3010A0E3 		mov	r1, #48
 6763 3ba8 0100A0E3 		mov	r0, #1
 6764              	.LVL594:
 6765 3bac FEFFFFEB 		bl	SensorSetIrisControl
3919:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6766              		.loc 1 3919 0
 6767 3bb0 7D0FA0E3 		mov	r0, #500
 6768 3bb4 FEFFFFEB 		bl	_tx_thread_sleep
3920:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 6769              		.loc 1 3920 0
 6770 3bb8 D80094E5 		ldr	r0, [r4, #216]
 6771 3bbc 8DC4D5E5 		ldrb	ip, [r5, #1165]	@ zero_extendqisi2
 6772 3bc0 000050E3 		cmp	r0, #0
 6773 3bc4 C400A003 		moveq	r0, #196
 6774 3bc8 4400A013 		movne	r0, #68
 6775 3bcc 0C2080E1 		orr	r2, r0, ip
 6776 3bd0 D83094E5 		ldr	r3, [r4, #216]
 6777 3bd4 84139FE5 		ldr	r1, .L608+80
 6778 3bd8 0400A0E3 		mov	r0, #4
 6779 3bdc FEFFFFEB 		bl	CyU3PDebugPrint
 6780 3be0 D7FFFFEA 		b	.L508
 6781              	.LVL595:
 6782              	.L509:
3908:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
 6783              		.loc 1 3908 0
 6784 3be4 D82094E5 		ldr	r2, [r4, #216]
 6785 3be8 3010A0E3 		mov	r1, #48
 6786 3bec 000052E3 		cmp	r2, #0
 6787 3bf0 E420A003 		moveq	r2, #228
 6788 3bf4 6420A013 		movne	r2, #100
 6789 3bf8 5230A0E3 		mov	r3, #82
 6790 3bfc 0100A0E3 		mov	r0, #1
 6791              	.LVL596:
 6792 3c00 FEFFFFEB 		bl	SensorSetIrisControl
3909:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6793              		.loc 1 3909 0
 6794 3c04 7D0FA0E3 		mov	r0, #500
 6795 3c08 FEFFFFEB 		bl	_tx_thread_sleep
3910:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 6796              		.loc 1 3910 0
 6797 3c0c D82094E5 		ldr	r2, [r4, #216]
 6798 3c10 48139FE5 		ldr	r1, .L608+80
 6799 3c14 000052E3 		cmp	r2, #0
 6800 3c18 D83094E5 		ldr	r3, [r4, #216]
 6801 3c1c E420A003 		moveq	r2, #228
 6802 3c20 6420A013 		movne	r2, #100
 6803 3c24 0400A0E3 		mov	r0, #4
 6804 3c28 FEFFFFEB 		bl	CyU3PDebugPrint
 6805 3c2c C4FFFFEA 		b	.L508
 6806              	.LVL597:
 6807              	.L510:
3913:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
 6808              		.loc 1 3913 0
 6809 3c30 D82094E5 		ldr	r2, [r4, #216]
 6810 3c34 3010A0E3 		mov	r1, #48
 6811 3c38 000052E3 		cmp	r2, #0
 6812 3c3c D420A003 		moveq	r2, #212
 6813 3c40 5420A013 		movne	r2, #84
 6814 3c44 5230A0E3 		mov	r3, #82
 6815 3c48 0100A0E3 		mov	r0, #1
 6816              	.LVL598:
 6817 3c4c FEFFFFEB 		bl	SensorSetIrisControl
3914:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6818              		.loc 1 3914 0
 6819 3c50 7D0FA0E3 		mov	r0, #500
 6820 3c54 FEFFFFEB 		bl	_tx_thread_sleep
3915:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 6821              		.loc 1 3915 0
 6822 3c58 D82094E5 		ldr	r2, [r4, #216]
 6823 3c5c FC129FE5 		ldr	r1, .L608+80
 6824 3c60 000052E3 		cmp	r2, #0
 6825 3c64 D83094E5 		ldr	r3, [r4, #216]
 6826 3c68 D420A003 		moveq	r2, #212
 6827 3c6c 5420A013 		movne	r2, #84
 6828 3c70 0400A0E3 		mov	r0, #4
 6829 3c74 FEFFFFEB 		bl	CyU3PDebugPrint
 6830 3c78 B1FFFFEA 		b	.L508
 6831              	.L444:
 6832              	.LVL599:
 6833              	.LBE111:
 6834              	.LBE154:
 6835              	.LBB155:
 6836              	.LBB107:
3506:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 6837              		.loc 1 3506 0
 6838 3c7c 0500A0E3 		mov	r0, #5
 6839 3c80 FEFFFFEB 		bl	CTControlHandle
 6840              	.LVL600:
 6841 3c84 18309DE5 		ldr	r3, [sp, #24]
 6842 3c88 82FDFFEA 		b	.L417
 6843              	.L599:
 6844              	.LVL601:
 6845              	.LBE107:
 6846              	.LBE155:
 6847              	.LBB156:
 6848              	.LBB97:
3413:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 6849              		.loc 1 3413 0
 6850 3c8c 0100A0E3 		mov	r0, #1
 6851 3c90 FEFFFFEB 		bl	ControlHandle
 6852              	.LVL602:
 6853 3c94 18309DE5 		ldr	r3, [sp, #24]
 6854 3c98 7EFDFFEA 		b	.L417
 6855              	.L425:
 6856              	.LVL603:
3409:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 6857              		.loc 1 3409 0
 6858 3c9c 0000A0E3 		mov	r0, #0
 6859 3ca0 FEFFFFEB 		bl	ControlHandle
 6860              	.LVL604:
 6861 3ca4 18309DE5 		ldr	r3, [sp, #24]
 6862 3ca8 7AFDFFEA 		b	.L417
 6863              	.L427:
 6864              	.LVL605:
3417:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 6865              		.loc 1 3417 0
 6866 3cac 0200A0E3 		mov	r0, #2
 6867 3cb0 FEFFFFEB 		bl	ControlHandle
 6868              	.LVL606:
 6869 3cb4 18309DE5 		ldr	r3, [sp, #24]
 6870 3cb8 76FDFFEA 		b	.L417
 6871              	.L429:
 6872              	.LVL607:
3428:../uvc.c      ****      		ControlHandle(HueCtlID5);
 6873              		.loc 1 3428 0
 6874 3cbc 0500A0E3 		mov	r0, #5
 6875 3cc0 FEFFFFEB 		bl	ControlHandle
 6876              	.LVL608:
 6877 3cc4 18309DE5 		ldr	r3, [sp, #24]
 6878 3cc8 72FDFFEA 		b	.L417
 6879              	.L460:
 6880              	.LVL609:
 6881              	.LBE97:
 6882              	.LBE156:
 6883              	.LBB157:
 6884              	.LBB128:
3722:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 6885              		.loc 1 3722 0
 6886 3ccc 1200A0E3 		mov	r0, #18
 6887 3cd0 FEFFFFEB 		bl	ControlHandle
 6888              	.LVL610:
 6889 3cd4 18309DE5 		ldr	r3, [sp, #24]
 6890 3cd8 6EFDFFEA 		b	.L417
 6891              	.L459:
 6892              	.LVL611:
3718:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 6893              		.loc 1 3718 0
 6894 3cdc 1100A0E3 		mov	r0, #17
 6895 3ce0 FEFFFFEB 		bl	ControlHandle
 6896              	.LVL612:
 6897 3ce4 18309DE5 		ldr	r3, [sp, #24]
 6898 3ce8 6AFDFFEA 		b	.L417
 6899              	.L461:
 6900              	.LVL613:
3726:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 6901              		.loc 1 3726 0
 6902 3cec 1300A0E3 		mov	r0, #19
 6903 3cf0 FEFFFFEB 		bl	ControlHandle
 6904              	.LVL614:
 6905 3cf4 18309DE5 		ldr	r3, [sp, #24]
 6906 3cf8 66FDFFEA 		b	.L417
 6907              	.L466:
 6908              	.LVL615:
3746:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 6909              		.loc 1 3746 0
 6910 3cfc 1800A0E3 		mov	r0, #24
 6911 3d00 FEFFFFEB 		bl	ControlHandle
 6912              	.LVL616:
 6913 3d04 18309DE5 		ldr	r3, [sp, #24]
 6914 3d08 62FDFFEA 		b	.L417
 6915              	.LVL617:
 6916              	.L606:
 6917              	.LBE128:
 6918              	.LBE157:
 6919              	.LBB158:
 6920              	.LBB117:
3831:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
 6921              		.loc 1 3831 0
 6922 3d0c 58129FE5 		ldr	r1, .L608+92
 6923 3d10 1A00A0E3 		mov	r0, #26
 6924 3d14 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
3832:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 6925              		.loc 1 3832 0
 6926 3d18 0400A0E3 		mov	r0, #4
 6927 3d1c 4C129FE5 		ldr	r1, .L608+96
 6928 3d20 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 6929 3d24 FEFFFFEB 		bl	CyU3PDebugPrint
 6930 3d28 18309DE5 		ldr	r3, [sp, #24]
 6931 3d2c 63FDFFEA 		b	.L482
 6932              	.LVL618:
 6933              	.L474:
 6934              	.LBE117:
 6935              	.LBE158:
 6936              	.LBB159:
 6937              	.LBB121:
3787:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
 6938              		.loc 1 3787 0
 6939 3d30 2500A0E3 		mov	r0, #37
 6940 3d34 FEFFFFEB 		bl	ControlHandle
 6941              	.LVL619:
 6942 3d38 18309DE5 		ldr	r3, [sp, #24]
 6943 3d3c 55FDFFEA 		b	.L417
 6944              	.LVL620:
 6945              	.L544:
 6946              	.LBE121:
 6947              	.LBE159:
 6948              	.LBB160:
 6949              	.LBB110:
4059:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
 6950              		.loc 1 4059 0
 6951 3d40 D82094E5 		ldr	r2, [r4, #216]
 6952 3d44 3010A0E3 		mov	r1, #48
 6953 3d48 000052E3 		cmp	r2, #0
 6954 3d4c E420A003 		moveq	r2, #228
 6955 3d50 6420A013 		movne	r2, #100
 6956 3d54 5230A0E3 		mov	r3, #82
 6957 3d58 0100A0E3 		mov	r0, #1
 6958              	.LVL621:
 6959 3d5c FEFFFFEB 		bl	SensorSetIrisControl
4061:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
 6960              		.loc 1 4061 0
 6961 3d60 D82094E5 		ldr	r2, [r4, #216]
 6962 3d64 08129FE5 		ldr	r1, .L608+100
 6963 3d68 000052E3 		cmp	r2, #0
 6964 3d6c D83094E5 		ldr	r3, [r4, #216]
 6965 3d70 E420A003 		moveq	r2, #228
 6966 3d74 6420A013 		movne	r2, #100
 6967 3d78 0400A0E3 		mov	r0, #4
 6968 3d7c FEFFFFEB 		bl	CyU3PDebugPrint
 6969              	.L540:
4081:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 6970              		.loc 1 4081 0
 6971 3d80 81E1D4E5 		ldrb	lr, [r4, #385]	@ zero_extendqisi2
4083:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 6972              		.loc 1 4083 0
 6973 3d84 8031D4E5 		ldrb	r3, [r4, #384]	@ zero_extendqisi2
 6974 3d88 BE21DDE1 		ldrh	r2, [sp, #30]
 6975              	.LVL622:
 6976 3d8c 0400A0E3 		mov	r0, #4
 6977 3d90 E0119FE5 		ldr	r1, .L608+104
4081:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 6978              		.loc 1 4081 0
 6979 3d94 A0E1C4E5 		strb	lr, [r4, #416]
4083:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 6980              		.loc 1 4083 0
 6981 3d98 00E08DE5 		str	lr, [sp, #0]
 6982 3d9c FEFFFFEB 		bl	CyU3PDebugPrint
 6983 3da0 18309DE5 		ldr	r3, [sp, #24]
 6984 3da4 45FDFFEA 		b	.L482
 6985              	.LVL623:
 6986              	.L543:
4064:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
 6987              		.loc 1 4064 0
 6988 3da8 D82094E5 		ldr	r2, [r4, #216]
 6989 3dac 3010A0E3 		mov	r1, #48
 6990 3db0 000052E3 		cmp	r2, #0
 6991 3db4 D420A003 		moveq	r2, #212
 6992 3db8 5420A013 		movne	r2, #84
 6993 3dbc 5230A0E3 		mov	r3, #82
 6994 3dc0 0100A0E3 		mov	r0, #1
 6995              	.LVL624:
 6996 3dc4 FEFFFFEB 		bl	SensorSetIrisControl
4066:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
 6997              		.loc 1 4066 0
 6998 3dc8 D82094E5 		ldr	r2, [r4, #216]
 6999 3dcc A0119FE5 		ldr	r1, .L608+100
 7000 3dd0 000052E3 		cmp	r2, #0
 7001 3dd4 D83094E5 		ldr	r3, [r4, #216]
 7002 3dd8 D420A003 		moveq	r2, #212
 7003 3ddc 5420A013 		movne	r2, #84
 7004 3de0 0400A0E3 		mov	r0, #4
 7005 3de4 FEFFFFEB 		bl	CyU3PDebugPrint
 7006 3de8 E4FFFFEA 		b	.L540
 7007              	.LVL625:
 7008              	.L541:
4074:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
 7009              		.loc 1 4074 0
 7010 3dec D80094E5 		ldr	r0, [r4, #216]
 7011              	.LVL626:
 7012 3df0 8D94D5E5 		ldrb	r9, [r5, #1165]	@ zero_extendqisi2
 7013 3df4 000050E3 		cmp	r0, #0
 7014 3df8 F400A003 		moveq	r0, #244
 7015 3dfc 7400A013 		movne	r0, #116
 7016 3e00 092080E1 		orr	r2, r0, r9
 7017 3e04 3010A0E3 		mov	r1, #48
 7018 3e08 5230A0E3 		mov	r3, #82
 7019 3e0c 0100A0E3 		mov	r0, #1
 7020 3e10 FEFFFFEB 		bl	SensorSetIrisControl
4076:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
 7021              		.loc 1 4076 0
 7022 3e14 D82094E5 		ldr	r2, [r4, #216]
 7023 3e18 8DC4D5E5 		ldrb	ip, [r5, #1165]	@ zero_extendqisi2
 7024 3e1c 000052E3 		cmp	r2, #0
 7025 3e20 F420A003 		moveq	r2, #244
 7026 3e24 7420A013 		movne	r2, #116
 7027 3e28 D83094E5 		ldr	r3, [r4, #216]
 7028 3e2c 40119FE5 		ldr	r1, .L608+100
 7029 3e30 0C2082E1 		orr	r2, r2, ip
 7030 3e34 0400A0E3 		mov	r0, #4
 7031 3e38 FEFFFFEB 		bl	CyU3PDebugPrint
 7032 3e3c CFFFFFEA 		b	.L540
 7033              	.LVL627:
 7034              	.L542:
4069:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
 7035              		.loc 1 4069 0
 7036 3e40 D8E094E5 		ldr	lr, [r4, #216]
 7037 3e44 8D34D5E5 		ldrb	r3, [r5, #1165]	@ zero_extendqisi2
 7038 3e48 00005EE3 		cmp	lr, #0
 7039 3e4c C4E0A003 		moveq	lr, #196
 7040 3e50 44E0A013 		movne	lr, #68
 7041 3e54 03208EE1 		orr	r2, lr, r3
 7042 3e58 3010A0E3 		mov	r1, #48
 7043 3e5c 5230A0E3 		mov	r3, #82
 7044 3e60 0100A0E3 		mov	r0, #1
 7045              	.LVL628:
 7046 3e64 FEFFFFEB 		bl	SensorSetIrisControl
4071:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
 7047              		.loc 1 4071 0
 7048 3e68 D89094E5 		ldr	r9, [r4, #216]
 7049 3e6c 8DC4D5E5 		ldrb	ip, [r5, #1165]	@ zero_extendqisi2
 7050 3e70 000059E3 		cmp	r9, #0
 7051 3e74 C490A003 		moveq	r9, #196
 7052 3e78 4490A013 		movne	r9, #68
 7053 3e7c D83094E5 		ldr	r3, [r4, #216]
 7054 3e80 EC109FE5 		ldr	r1, .L608+100
 7055 3e84 0C2089E1 		orr	r2, r9, ip
 7056 3e88 0400A0E3 		mov	r0, #4
 7057 3e8c FEFFFFEB 		bl	CyU3PDebugPrint
 7058 3e90 BAFFFFEA 		b	.L540
 7059              	.L473:
 7060              	.LVL629:
 7061              	.LBE110:
 7062              	.LBE160:
 7063              	.LBB161:
 7064              	.LBB129:
3783:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
 7065              		.loc 1 3783 0
 7066 3e94 2400A0E3 		mov	r0, #36
 7067 3e98 FEFFFFEB 		bl	ControlHandle
 7068              	.LVL630:
 7069 3e9c 18309DE5 		ldr	r3, [sp, #24]
 7070 3ea0 FCFCFFEA 		b	.L417
 7071              	.L469:
 7072              	.LVL631:
3761:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
 7073              		.loc 1 3761 0
 7074 3ea4 1B00A0E3 		mov	r0, #27
 7075 3ea8 FEFFFFEB 		bl	ControlHandle
 7076              	.LVL632:
 7077 3eac 18309DE5 		ldr	r3, [sp, #24]
 7078 3eb0 F8FCFFEA 		b	.L417
 7079              	.L442:
 7080              	.LVL633:
 7081              	.LBE129:
 7082              	.LBE161:
 7083              	.LBB162:
 7084              	.LBB99:
3497:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 7085              		.loc 1 3497 0
 7086 3eb4 0300A0E3 		mov	r0, #3
 7087 3eb8 FEFFFFEB 		bl	CTControlHandle
 7088              	.LVL634:
 7089 3ebc 18309DE5 		ldr	r3, [sp, #24]
 7090 3ec0 F4FCFFEA 		b	.L417
 7091              	.L464:
 7092              	.LVL635:
 7093              	.LBE99:
 7094              	.LBE162:
 7095              	.LBB163:
 7096              	.LBB120:
3738:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 7097              		.loc 1 3738 0
 7098 3ec4 1600A0E3 		mov	r0, #22
 7099 3ec8 FEFFFFEB 		bl	ControlHandle
 7100              	.LVL636:
 7101 3ecc 18309DE5 		ldr	r3, [sp, #24]
 7102 3ed0 F0FCFFEA 		b	.L417
 7103              	.L449:
 7104              	.LVL637:
 7105              	.LBE120:
 7106              	.LBE163:
 7107              	.LBB164:
 7108              	.LBB108:
3529:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 7109              		.loc 1 3529 0
 7110 3ed4 0A00A0E3 		mov	r0, #10
 7111 3ed8 FEFFFFEB 		bl	CTControlHandle
 7112              	.LVL638:
 7113 3edc 18309DE5 		ldr	r3, [sp, #24]
 7114 3ee0 ECFCFFEA 		b	.L417
 7115              	.L448:
 7116              	.LVL639:
3525:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 7117              		.loc 1 3525 0
 7118 3ee4 0900A0E3 		mov	r0, #9
 7119 3ee8 FEFFFFEB 		bl	CTControlHandle
 7120              	.LVL640:
 7121 3eec 18309DE5 		ldr	r3, [sp, #24]
 7122 3ef0 E8FCFFEA 		b	.L417
 7123              	.L463:
 7124              	.LVL641:
 7125              	.LBE108:
 7126              	.LBE164:
 7127              	.LBB165:
 7128              	.LBB130:
3734:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 7129              		.loc 1 3734 0
 7130 3ef4 1500A0E3 		mov	r0, #21
 7131 3ef8 FEFFFFEB 		bl	ControlHandle
 7132              	.LVL642:
 7133 3efc 18309DE5 		ldr	r3, [sp, #24]
 7134 3f00 E4FCFFEA 		b	.L417
 7135              	.LVL643:
 7136              	.L557:
 7137              	.LBE130:
 7138              	.LBE165:
 7139              	.LBB166:
 7140              	.LBB118:
4105:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 7141              		.loc 1 4105 0
 7142 3f04 0200A0E3 		mov	r0, #2
 7143 3f08 30109FE5 		ldr	r1, .L608+48
 7144 3f0c 24FEFFEA 		b	.L589
 7145              	.L609:
 7146              		.align	2
 7147              	.L608:
 7148 3f10 00000000 		.word	.LANCHOR0
 7149 3f14 00000000 		.word	.LANCHOR1
 7150 3f18 00000000 		.word	wIndex
 7151 3f1c 00000000 		.word	wValue
 7152 3f20 00000000 		.word	bRequest
 7153 3f24 00000000 		.word	glInterStaBuffer
 7154 3f28 5C060000 		.word	.LC36
 7155 3f2c 00000000 		.word	glChHandleInterStat
 7156 3f30 80010000 		.word	.LANCHOR0+384
 7157 3f34 74070000 		.word	.LC43
 7158 3f38 98070000 		.word	.LC44
 7159 3f3c BC060000 		.word	.LANCHOR1+1724
 7160 3f40 1C010000 		.word	.LANCHOR0+284
 7161 3f44 F4060000 		.word	.LANCHOR1+1780
 7162 3f48 00070000 		.word	.LANCHOR1+1792
 7163 3f4c FC060000 		.word	.LC40
 7164 3f50 EC070000 		.word	.LC46
 7165 3f54 4C020000 		.word	.LC14
 7166 3f58 C4070000 		.word	.LC45
 7167 3f5c D8060000 		.word	.LANCHOR1+1752
 7168 3f60 B0060000 		.word	.LC38
 7169 3f64 D4060000 		.word	.LC39
 7170 3f68 EC020000 		.word	.LC18
 7171 3f6c A0060000 		.word	.LANCHOR1+1696
 7172 3f70 88060000 		.word	.LC37
 7173 3f74 28070000 		.word	.LC41
 7174 3f78 4C070000 		.word	.LC42
 7175              	.LBE118:
 7176              	.LBE166:
 7177              		.cfi_endproc
 7178              	.LFE25:
 7180              		.align	2
 7181              		.global	CamDefSet
 7183              	CamDefSet:
 7184              	.LFB5:
1954:../uvc.c      **** {
 7185              		.loc 1 1954 0
 7186              		.cfi_startproc
 7187              		@ args = 0, pretend = 0, frame = 24
 7188              		@ frame_needed = 0, uses_anonymous_args = 0
 7189              	.LVL644:
 7190 3f7c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7191              	.LCFI22:
 7192              		.cfi_def_cfa_offset 36
1961:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 7193              		.loc 1 1961 0
 7194 3f80 B0429FE5 		ldr	r4, .L613
 7195              		.cfi_offset 14, -4
 7196              		.cfi_offset 11, -8
 7197              		.cfi_offset 10, -12
 7198              		.cfi_offset 9, -16
 7199              		.cfi_offset 8, -20
 7200              		.cfi_offset 7, -24
 7201              		.cfi_offset 6, -28
 7202              		.cfi_offset 5, -32
 7203              		.cfi_offset 4, -36
1966:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 7204              		.loc 1 1966 0
 7205 3f84 B0229FE5 		ldr	r2, .L613+4
1963:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 7206              		.loc 1 1963 0
 7207 3f88 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1954:../uvc.c      **** {
 7208              		.loc 1 1954 0
 7209 3f8c 2CD04DE2 		sub	sp, sp, #44
 7210              	.LCFI23:
 7211              		.cfi_def_cfa_offset 80
1966:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 7212              		.loc 1 1966 0
 7213 3f90 1C0092E5 		ldr	r0, [r2, #28]
 7214 3f94 0010E0E3 		mvn	r1, #0
1968:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 7215              		.loc 1 1968 0
 7216 3f98 2963A0E1 		mov	r6, r9, lsr #6
1962:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 7217              		.loc 1 1962 0
 7218 3f9c A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1961:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 7219              		.loc 1 1961 0
 7220 3fa0 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 7221              	.LVL645:
1966:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 7222              		.loc 1 1966 0
 7223 3fa4 FEFFFFEB 		bl	_txe_mutex_get
1967:../uvc.c      ****     if(Data1&0x80){
 7224              		.loc 1 1967 0
 7225 3fa8 800019E3 		tst	r9, #128
1968:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 7226              		.loc 1 1968 0
 7227 3fac 01600612 		andne	r6, r6, #1
 7228 3fb0 0660E011 		mvnne	r6, r6
 7229 3fb4 3B600612 		andne	r6, r6, #59
 7230 3fb8 0660E011 		mvnne	r6, r6
 7231 3fbc FF600612 		andne	r6, r6, #255
 7232              	.LVL646:
1970:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 7233              		.loc 1 1970 0
 7234 3fc0 C6608603 		orreq	r6, r6, #198
 7235              	.LVL647:
1974:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 7236              		.loc 1 1974 0
 7237 3fc4 0080A0E3 		mov	r8, #0
 7238 3fc8 0A20A0E1 		mov	r2, sl
 7239 3fcc 0730A0E1 		mov	r3, r7
 7240 3fd0 0110A0E3 		mov	r1, #1
1972:../uvc.c      ****     Data0 = (Data0 << 2);
 7241              		.loc 1 1972 0
 7242 3fd4 0951A0E1 		mov	r5, r9, asl #2
1974:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 7243              		.loc 1 1974 0
 7244 3fd8 5C029FE5 		ldr	r0, .L613+4
1977:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 7245              		.loc 1 1977 0
 7246 3fdc 0190A0E3 		mov	r9, #1
 7247              	.LVL648:
1972:../uvc.c      ****     Data0 = (Data0 << 2);
 7248              		.loc 1 1972 0
 7249 3fe0 FF5005E2 		and	r5, r5, #255
 7250              	.LVL649:
1974:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 7251              		.loc 1 1974 0
 7252 3fe4 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 7253 3fe8 FEFFFFEB 		bl	cmdSet
 7254              	.LVL650:
1977:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 7255              		.loc 1 1977 0
 7256 3fec 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 7257 3ff0 0910A0E1 		mov	r1, r9
 7258 3ff4 0730A0E1 		mov	r3, r7
 7259 3ff8 3C029FE5 		ldr	r0, .L613+4
 7260 3ffc 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 7261 4000 FEFFFFEB 		bl	cmdSet
 7262              	.LVL651:
1980:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 7263              		.loc 1 1980 0
 7264 4004 0620A0E1 		mov	r2, r6
 7265 4008 0530A0E1 		mov	r3, r5
 7266 400c 2C129FE5 		ldr	r1, .L613+8
 7267 4010 0400A0E3 		mov	r0, #4
1979:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 7268              		.loc 1 1979 0
 7269 4014 A661C4E5 		strb	r6, [r4, #422]
1978:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 7270              		.loc 1 1978 0
 7271 4018 A551C4E5 		strb	r5, [r4, #421]
1980:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 7272              		.loc 1 1980 0
 7273 401c FEFFFFEB 		bl	CyU3PDebugPrint
 7274              	.LVL652:
1985:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7275              		.loc 1 1985 0
 7276 4020 BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 7277              	.LVL653:
1986:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 7278              		.loc 1 1986 0
 7279 4024 B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 7280 4028 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 7281 402c 0210A0E3 		mov	r1, #2
 7282 4030 04029FE5 		ldr	r0, .L613+4
 7283 4034 00B08DE5 		str	fp, [sp, #0]
 7284 4038 04808DE5 		str	r8, [sp, #4]
 7285 403c FEFFFFEB 		bl	cmdSet
 7286              	.LVL654:
1989:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7287              		.loc 1 1989 0
 7288 4040 0B20A0E1 		mov	r2, fp
 7289 4044 0530A0E1 		mov	r3, r5
 7290 4048 F0119FE5 		ldr	r1, .L613+8
 7291 404c 0400A0E3 		mov	r0, #4
1987:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 7292              		.loc 1 1987 0
 7293 4050 BD51C4E5 		strb	r5, [r4, #445]
1988:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
 7294              		.loc 1 1988 0
 7295 4054 FD53C4E5 		strb	r5, [r4, #1021]
1989:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7296              		.loc 1 1989 0
 7297 4058 FEFFFFEB 		bl	CyU3PDebugPrint
 7298              	.LVL655:
1994:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7299              		.loc 1 1994 0
 7300 405c 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1993:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 7301              		.loc 1 1993 0
 7302 4060 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 7303              	.LVL656:
1995:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7304              		.loc 1 1995 0
 7305 4064 80B047E2 		sub	fp, r7, #128
 7306 4068 FF100BE2 		and	r1, fp, #255
 7307 406c 14108DE5 		str	r1, [sp, #20]
 7308 4070 14C09DE5 		ldr	ip, [sp, #20]
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7309              		.loc 1 1996 0
 7310 4074 760047E2 		sub	r0, r7, #118
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7311              		.loc 1 1997 0
 7312 4078 7EE087E2 		add	lr, r7, #126
1995:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7313              		.loc 1 1995 0
 7314 407c 0630A0E1 		mov	r3, r6
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7315              		.loc 1 1996 0
 7316 4080 18008DE5 		str	r0, [sp, #24]
1995:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7317              		.loc 1 1995 0
 7318 4084 0510A0E3 		mov	r1, #5
 7319 4088 DF20A0E3 		mov	r2, #223
 7320 408c A8019FE5 		ldr	r0, .L613+4
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7321              		.loc 1 1997 0
 7322 4090 1CE08DE5 		str	lr, [sp, #28]
1995:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7323              		.loc 1 1995 0
 7324 4094 00C08DE5 		str	ip, [sp, #0]
 7325 4098 04808DE5 		str	r8, [sp, #4]
 7326 409c FEFFFFEB 		bl	cmdSet
 7327              	.LVL657:
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7328              		.loc 1 1996 0
 7329 40a0 18A09DE5 		ldr	sl, [sp, #24]
1998:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 7330              		.loc 1 1998 0
 7331 40a4 72E087E2 		add	lr, r7, #114
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7332              		.loc 1 1996 0
 7333 40a8 FFC00AE2 		and	ip, sl, #255
 7334 40ac 0630A0E1 		mov	r3, r6
 7335 40b0 0510A0E3 		mov	r1, #5
 7336 40b4 DC20A0E3 		mov	r2, #220
 7337 40b8 7C019FE5 		ldr	r0, .L613+4
1998:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 7338              		.loc 1 1998 0
 7339 40bc 20E08DE5 		str	lr, [sp, #32]
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7340              		.loc 1 1996 0
 7341 40c0 00C08DE5 		str	ip, [sp, #0]
 7342 40c4 04908DE5 		str	r9, [sp, #4]
 7343 40c8 FEFFFFEB 		bl	cmdSet
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7344              		.loc 1 1997 0
 7345 40cc 1C009DE5 		ldr	r0, [sp, #28]
 7346 40d0 02E0A0E3 		mov	lr, #2
 7347 40d4 FFC000E2 		and	ip, r0, #255
 7348 40d8 0630A0E1 		mov	r3, r6
1999:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7349              		.loc 1 1999 0
 7350 40dc 6FA047E2 		sub	sl, r7, #111
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7351              		.loc 1 1997 0
 7352 40e0 0510A0E3 		mov	r1, #5
 7353 40e4 DE20A0E3 		mov	r2, #222
 7354 40e8 4C019FE5 		ldr	r0, .L613+4
 7355 40ec 04E08DE5 		str	lr, [sp, #4]
1999:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7356              		.loc 1 1999 0
 7357 40f0 24A08DE5 		str	sl, [sp, #36]
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7358              		.loc 1 1997 0
 7359 40f4 00C08DE5 		str	ip, [sp, #0]
 7360 40f8 FEFFFFEB 		bl	cmdSet
1998:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 7361              		.loc 1 1998 0
 7362 40fc 20A09DE5 		ldr	sl, [sp, #32]
 7363 4100 0630A0E1 		mov	r3, r6
 7364 4104 FFC00AE2 		and	ip, sl, #255
 7365 4108 00C08DE5 		str	ip, [sp, #0]
 7366 410c 0510A0E3 		mov	r1, #5
 7367 4110 03C0A0E3 		mov	ip, #3
 7368 4114 E020A0E3 		mov	r2, #224
 7369 4118 1C019FE5 		ldr	r0, .L613+4
 7370 411c 04C08DE5 		str	ip, [sp, #4]
 7371 4120 FEFFFFEB 		bl	cmdSet
1999:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7372              		.loc 1 1999 0
 7373 4124 24009DE5 		ldr	r0, [sp, #36]
 7374 4128 04A0A0E3 		mov	sl, #4
 7375 412c FFC000E2 		and	ip, r0, #255
 7376 4130 0630A0E1 		mov	r3, r6
 7377 4134 0510A0E3 		mov	r1, #5
 7378 4138 DD20A0E3 		mov	r2, #221
 7379 413c F8009FE5 		ldr	r0, .L613+4
 7380 4140 00C08DE5 		str	ip, [sp, #0]
2000:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 7381              		.loc 1 2000 0
 7382 4144 7F7087E2 		add	r7, r7, #127
 7383              	.LVL658:
1999:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7384              		.loc 1 1999 0
 7385 4148 04A08DE5 		str	sl, [sp, #4]
 7386 414c FEFFFFEB 		bl	cmdSet
2000:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 7387              		.loc 1 2000 0
 7388 4150 05E0A0E3 		mov	lr, #5
 7389 4154 0E10A0E1 		mov	r1, lr
 7390 4158 0630A0E1 		mov	r3, r6
 7391 415c E120A0E3 		mov	r2, #225
 7392 4160 FF6007E2 		and	r6, r7, #255
 7393              	.LVL659:
 7394 4164 D0009FE5 		ldr	r0, .L613+4
 7395 4168 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 7396 416c FEFFFFEB 		bl	cmdSet
 7397              	.LVL660:
2001:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 7398              		.loc 1 2001 0
 7399 4170 14C09DE5 		ldr	ip, [sp, #20]
2002:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 7400              		.loc 1 2002 0
 7401 4174 24E09DE5 		ldr	lr, [sp, #36]
 7402 4178 1C609DE5 		ldr	r6, [sp, #28]
2001:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 7403              		.loc 1 2001 0
 7404 417c 05C2C4E5 		strb	ip, [r4, #517]
2002:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 7405              		.loc 1 2002 0
 7406 4180 20C09DE5 		ldr	ip, [sp, #32]
 7407 4184 0B20A0E1 		mov	r2, fp
 7408 4188 18309DE5 		ldr	r3, [sp, #24]
 7409 418c B0109FE5 		ldr	r1, .L613+12
 7410 4190 0A00A0E1 		mov	r0, sl
 7411 4194 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 7412 4198 0C708DE5 		str	r7, [sp, #12]
 7413 419c FEFFFFEB 		bl	CyU3PDebugPrint
 7414              	.LVL661:
2006:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 7415              		.loc 1 2006 0
 7416 41a0 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 7417              	.LVL662:
2007:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7418              		.loc 1 2007 0
 7419 41a4 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 7420              	.LVL663:
2008:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 7421              		.loc 1 2008 0
 7422 41a8 0730A0E1 		mov	r3, r7
 7423 41ac 0610A0E3 		mov	r1, #6
 7424 41b0 8520A0E3 		mov	r2, #133
 7425 41b4 80009FE5 		ldr	r0, .L613+4
 7426 41b8 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 7427 41bc FEFFFFEB 		bl	cmdSet
2009:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 7428              		.loc 1 2009 0
 7429 41c0 0730A0E1 		mov	r3, r7
 7430 41c4 0610A0E3 		mov	r1, #6
 7431 41c8 8620A0E3 		mov	r2, #134
 7432 41cc 68009FE5 		ldr	r0, .L613+4
 7433 41d0 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 7434 41d4 FEFFFFEB 		bl	cmdSet
2011:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7435              		.loc 1 2011 0
 7436 41d8 0620A0E1 		mov	r2, r6
 7437 41dc 0530A0E1 		mov	r3, r5
 7438 41e0 58109FE5 		ldr	r1, .L613+8
 7439 41e4 0A00A0E1 		mov	r0, sl
2010:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 7440              		.loc 1 2010 0
 7441 41e8 1D62C4E5 		strb	r6, [r4, #541]
2011:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7442              		.loc 1 2011 0
 7443 41ec FEFFFFEB 		bl	CyU3PDebugPrint
 7444              	.LVL664:
2016:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7445              		.loc 1 2016 0
 7446 41f0 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 7447              	.LVL665:
2017:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 7448              		.loc 1 2017 0
 7449 41f4 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 7450 41f8 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 7451 41fc 0710A0E3 		mov	r1, #7
 7452 4200 34009FE5 		ldr	r0, .L613+4
 7453 4204 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 7454 4208 FEFFFFEB 		bl	cmdSet
 7455              	.LVL666:
2019:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7456              		.loc 1 2019 0
 7457 420c 0530A0E1 		mov	r3, r5
 7458 4210 0A00A0E1 		mov	r0, sl
 7459 4214 24109FE5 		ldr	r1, .L613+8
 7460 4218 0620A0E1 		mov	r2, r6
2018:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 7461              		.loc 1 2018 0
 7462 421c 3552C4E5 		strb	r5, [r4, #565]
2019:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7463              		.loc 1 2019 0
 7464 4220 FEFFFFEB 		bl	CyU3PDebugPrint
2021:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 7465              		.loc 1 2021 0
 7466 4224 10309FE5 		ldr	r3, .L613+4
 7467 4228 1C0093E5 		ldr	r0, [r3, #28]
2024:../uvc.c      **** }
 7468              		.loc 1 2024 0
 7469 422c 2CD08DE2 		add	sp, sp, #44
 7470 4230 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
2021:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 7471              		.loc 1 2021 0
 7472 4234 FEFFFFEA 		b	_txe_mutex_put
 7473              	.L614:
 7474              		.align	2
 7475              	.L613:
 7476 4238 00000000 		.word	.LANCHOR1
 7477 423c 00000000 		.word	statQu
 7478 4240 20080000 		.word	.LC47
 7479 4244 40080000 		.word	.LC48
 7480              		.cfi_endproc
 7481              	.LFE5:
 7483              		.align	2
 7484              		.global	CyFxUVCAddHeader
 7486              	CyFxUVCAddHeader:
 7487              	.LFB6:
2032:../uvc.c      **** {
 7488              		.loc 1 2032 0
 7489              		.cfi_startproc
 7490              		@ args = 0, pretend = 0, frame = 0
 7491              		@ frame_needed = 0, uses_anonymous_args = 0
 7492              	.LVL667:
 7493 4248 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 7494              	.LCFI24:
 7495              		.cfi_def_cfa_offset 16
2032:../uvc.c      **** {
 7496              		.loc 1 2032 0
 7497 424c 0040A0E1 		mov	r4, r0
 7498              		.cfi_offset 14, -4
 7499              		.cfi_offset 5, -8
 7500              		.cfi_offset 4, -12
 7501              		.cfi_offset 3, -16
 7502 4250 0150A0E1 		mov	r5, r1
2034:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7503              		.loc 1 2034 0
 7504 4254 30009FE5 		ldr	r0, .L617
 7505              	.LVL668:
 7506 4258 0010E0E3 		mvn	r1, #0
 7507              	.LVL669:
 7508 425c FEFFFFEB 		bl	_txe_mutex_get
2035:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 7509              		.loc 1 2035 0
 7510 4260 0400A0E1 		mov	r0, r4
 7511 4264 24109FE5 		ldr	r1, .L617+4
 7512 4268 0C20A0E3 		mov	r2, #12
 7513 426c FEFFFFEB 		bl	CyU3PMemCopy
2036:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 7514              		.loc 1 2036 0
 7515 4270 14009FE5 		ldr	r0, .L617
 7516 4274 FEFFFFEB 		bl	_txe_mutex_put
2039:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 7517              		.loc 1 2039 0
 7518 4278 020015E3 		tst	r5, #2
2041:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 7519              		.loc 1 2041 0
 7520 427c 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 7521 4280 02308313 		orrne	r3, r3, #2
 7522 4284 0130C415 		strneb	r3, [r4, #1]
 7523 4288 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 7524              	.L618:
 7525              		.align	2
 7526              	.L617:
 7527 428c 00000000 		.word	imgHdMux
 7528 4290 80040000 		.word	.LANCHOR1+1152
 7529              		.cfi_endproc
 7530              	.LFE6:
 7532              		.align	2
 7533              		.global	CyFxAppErrorHandler
 7535              	CyFxAppErrorHandler:
 7536              	.LFB7:
2051:../uvc.c      **** {
 7537              		.loc 1 2051 0
 7538              		.cfi_startproc
 7539              		@ args = 0, pretend = 0, frame = 0
 7540              		@ frame_needed = 0, uses_anonymous_args = 0
 7541              	.LVL670:
 7542 4294 08402DE9 		stmfd	sp!, {r3, lr}
 7543              	.LCFI25:
 7544              		.cfi_def_cfa_offset 8
 7545              	.LVL671:
 7546              	.L620:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7547              		.loc 1 2061 0 discriminator 1
 7548 4298 10109FE5 		ldr	r1, .L621
 7549 429c 0400A0E3 		mov	r0, #4
 7550              		.cfi_offset 14, -4
 7551              		.cfi_offset 3, -8
 7552 42a0 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 7553              		.loc 1 2062 0 discriminator 1
 7554 42a4 FA0FA0E3 		mov	r0, #1000
 7555 42a8 FEFFFFEB 		bl	_tx_thread_sleep
 7556 42ac F9FFFFEA 		b	.L620
 7557              	.L622:
 7558              		.align	2
 7559              	.L621:
 7560 42b0 4C020000 		.word	.LC14
 7561              		.cfi_endproc
 7562              	.LFE7:
 7564              		.align	2
 7565              		.global	UVCAppThread_Entry
 7567              	UVCAppThread_Entry:
 7568              	.LFB19:
3052:../uvc.c      **** {
 7569              		.loc 1 3052 0
 7570              		.cfi_startproc
 7571              		@ args = 0, pretend = 0, frame = 176
 7572              		@ frame_needed = 0, uses_anonymous_args = 0
 7573              	.LVL672:
 7574 42b4 F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 7575              	.LCFI26:
 7576              		.cfi_def_cfa_offset 28
 7577 42b8 BCD04DE2 		sub	sp, sp, #188
 7578              	.LCFI27:
 7579              		.cfi_def_cfa_offset 216
 7580              	.LBB219:
 7581              	.LBB220:
2508:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 7582              		.loc 1 2508 0
 7583              		.cfi_offset 14, -4
 7584              		.cfi_offset 10, -8
 7585              		.cfi_offset 8, -12
 7586              		.cfi_offset 7, -16
 7587              		.cfi_offset 6, -20
 7588              		.cfi_offset 5, -24
 7589              		.cfi_offset 4, -28
 7590 42bc FEFFFFEB 		bl	CyU3PUartInit
 7591              	.LVL673:
2509:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7592              		.loc 1 2509 0
 7593 42c0 004050E2 		subs	r4, r0, #0
 7594 42c4 0400000A 		beq	.L624
2511:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 7595              		.loc 1 2511 0
 7596 42c8 0400A0E3 		mov	r0, #4
 7597              	.LVL674:
 7598 42cc 401C9FE5 		ldr	r1, .L740
 7599 42d0 FEFFFFEB 		bl	CyU3PDebugPrint
2512:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7600              		.loc 1 2512 0
 7601 42d4 0400A0E1 		mov	r0, r4
 7602 42d8 FEFFFFEB 		bl	CyFxAppErrorHandler
 7603              	.L624:
2516:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 7604              		.loc 1 2516 0
 7605 42dc 34CC9FE5 		ldr	ip, .L740+4
2518:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 7606              		.loc 1 2518 0
 7607 42e0 0030A0E3 		mov	r3, #0
2517:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 7608              		.loc 1 2517 0
 7609 42e4 0120A0E3 		mov	r2, #1
2525:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 7610              		.loc 1 2525 0
 7611 42e8 50008DE2 		add	r0, sp, #80
 7612 42ec 0310A0E1 		mov	r1, r3
2516:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 7613              		.loc 1 2516 0
 7614 42f0 60C08DE5 		str	ip, [sp, #96]
2517:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 7615              		.loc 1 2517 0
 7616 42f4 6420CDE5 		strb	r2, [sp, #100]
2518:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 7617              		.loc 1 2518 0
 7618 42f8 6530CDE5 		strb	r3, [sp, #101]
2519:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 7619              		.loc 1 2519 0
 7620 42fc 50208DE5 		str	r2, [sp, #80]
2520:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 7621              		.loc 1 2520 0
 7622 4300 54308DE5 		str	r3, [sp, #84]
2521:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 7623              		.loc 1 2521 0
 7624 4304 58308DE5 		str	r3, [sp, #88]
2522:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 7625              		.loc 1 2522 0
 7626 4308 5C208DE5 		str	r2, [sp, #92]
2525:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 7627              		.loc 1 2525 0
 7628 430c FEFFFFEB 		bl	CyU3PUartSetConfig
 7629              	.LVL675:
2526:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7630              		.loc 1 2526 0
 7631 4310 000050E3 		cmp	r0, #0
 7632 4314 0000000A 		beq	.L625
2528:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7633              		.loc 1 2528 0
 7634 4318 FEFFFFEB 		bl	CyFxAppErrorHandler
 7635              	.LVL676:
 7636              	.L625:
2532:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 7637              		.loc 1 2532 0
 7638 431c 0000E0E3 		mvn	r0, #0
 7639 4320 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 7640              	.LVL677:
2533:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7641              		.loc 1 2533 0
 7642 4324 000050E3 		cmp	r0, #0
 7643 4328 0000000A 		beq	.L626
2535:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7644              		.loc 1 2535 0
 7645 432c FEFFFFEB 		bl	CyFxAppErrorHandler
 7646              	.LVL678:
 7647              	.L626:
2539:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 7648              		.loc 1 2539 0
 7649 4330 0300A0E3 		mov	r0, #3
 7650 4334 0410A0E3 		mov	r1, #4
 7651 4338 FEFFFFEB 		bl	CyU3PDebugInit
 7652              	.LVL679:
2540:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7653              		.loc 1 2540 0
 7654 433c 000050E3 		cmp	r0, #0
 7655 4340 0000000A 		beq	.L627
2542:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7656              		.loc 1 2542 0
 7657 4344 FEFFFFEB 		bl	CyFxAppErrorHandler
 7658              	.LVL680:
 7659              	.L627:
2546:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 7660              		.loc 1 2546 0
 7661 4348 0000A0E3 		mov	r0, #0
 7662 434c FEFFFFEB 		bl	CyU3PDebugPreamble
 7663              	.LVL681:
 7664              	.LBE220:
 7665              	.LBE219:
3068:../uvc.c      **** 		CyU3PThreadSleep(500);
 7666              		.loc 1 3068 0
 7667 4350 7D0FA0E3 		mov	r0, #500
 7668 4354 FEFFFFEB 		bl	_tx_thread_sleep
 7669              	.LVL682:
 7670 4358 7D0FA0E3 		mov	r0, #500
 7671 435c FEFFFFEB 		bl	_tx_thread_sleep
 7672 4360 7D0FA0E3 		mov	r0, #500
 7673 4364 FEFFFFEB 		bl	_tx_thread_sleep
 7674 4368 7D0FA0E3 		mov	r0, #500
 7675 436c FEFFFFEB 		bl	_tx_thread_sleep
 7676 4370 7D0FA0E3 		mov	r0, #500
 7677 4374 FEFFFFEB 		bl	_tx_thread_sleep
 7678 4378 7D0FA0E3 		mov	r0, #500
 7679 437c FEFFFFEB 		bl	_tx_thread_sleep
 7680              	.LBB221:
 7681              	.LBB222:
2556:../uvc.c      ****     status = CyU3PI2cInit ();
 7682              		.loc 1 2556 0
 7683 4380 FEFFFFEB 		bl	CyU3PI2cInit
 7684              	.LVL683:
2557:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 7685              		.loc 1 2557 0
 7686 4384 004050E2 		subs	r4, r0, #0
 7687 4388 0400000A 		beq	.L628
2559:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 7688              		.loc 1 2559 0
 7689 438c 0400A0E3 		mov	r0, #4
 7690              	.LVL684:
 7691 4390 841B9FE5 		ldr	r1, .L740+8
 7692 4394 FEFFFFEB 		bl	CyU3PDebugPrint
2560:../uvc.c      ****         CyFxAppErrorHandler (status);
 7693              		.loc 1 2560 0
 7694 4398 0400A0E1 		mov	r0, r4
 7695 439c FEFFFFEB 		bl	CyFxAppErrorHandler
 7696              	.L628:
2564:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7697              		.loc 1 2564 0
 7698 43a0 786B9FE5 		ldr	r6, .L740+12
2565:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 7699              		.loc 1 2565 0
 7700 43a4 0050A0E3 		mov	r5, #0
2566:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 7701              		.loc 1 2566 0
 7702 43a8 0040E0E3 		mvn	r4, #0
 7703              	.LVL685:
2569:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7704              		.loc 1 2569 0
 7705 43ac 8C008DE2 		add	r0, sp, #140
 7706 43b0 0510A0E1 		mov	r1, r5
2566:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 7707              		.loc 1 2566 0
 7708 43b4 94408DE5 		str	r4, [sp, #148]
2567:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 7709              		.loc 1 2567 0
 7710 43b8 B849CDE1 		strh	r4, [sp, #152]	@ movhi
2564:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7711              		.loc 1 2564 0
 7712 43bc 8C608DE5 		str	r6, [sp, #140]
2565:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 7713              		.loc 1 2565 0
 7714 43c0 90508DE5 		str	r5, [sp, #144]
2569:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7715              		.loc 1 2569 0
 7716 43c4 FEFFFFEB 		bl	CyU3PI2cSetConfig
 7717              	.LVL686:
2570:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 7718              		.loc 1 2570 0
 7719 43c8 004050E2 		subs	r4, r0, #0
 7720 43cc 0400000A 		beq	.L629
2572:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 7721              		.loc 1 2572 0
 7722 43d0 0400A0E3 		mov	r0, #4
 7723              	.LVL687:
 7724 43d4 481B9FE5 		ldr	r1, .L740+16
 7725 43d8 FEFFFFEB 		bl	CyU3PDebugPrint
2573:../uvc.c      ****         CyFxAppErrorHandler (status);
 7726              		.loc 1 2573 0
 7727 43dc 0400A0E1 		mov	r0, r4
 7728 43e0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7729              	.L629:
 7730              	.LBE222:
 7731              	.LBE221:
 7732              	.LBB223:
 7733              	.LBB226:
2643:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 7734              		.loc 1 2643 0
 7735 43e4 3C4B9FE5 		ldr	r4, .L740+20
 7736              	.LVL688:
 7737 43e8 2820A0E3 		mov	r2, #40
 7738 43ec 0010A0E3 		mov	r1, #0
 7739 43f0 0400A0E1 		mov	r0, r4
 7740 43f4 FEFFFFEB 		bl	_txe_event_flags_create
 7741              	.LVL689:
2644:../uvc.c      ****     if (apiRetStatus != 0)
 7742              		.loc 1 2644 0
 7743 43f8 002050E2 		subs	r2, r0, #0
 7744 43fc FB00001A 		bne	.L714
2658:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 7745              		.loc 1 2658 0
 7746 4400 0260A0E3 		mov	r6, #2
2665:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 7747              		.loc 1 2665 0
 7748 4404 0210A0E1 		mov	r1, r2
2654:../uvc.c      ****     isUsbConnected = CyFalse;
 7749              		.loc 1 2654 0
 7750 4408 B02084E5 		str	r2, [r4, #176]
2655:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 7751              		.loc 1 2655 0
 7752 440c C42084E5 		str	r2, [r4, #196]
2661:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 7753              		.loc 1 2661 0
 7754 4410 0370A0E3 		mov	r7, #3
2665:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 7755              		.loc 1 2665 0
 7756 4414 9C008DE2 		add	r0, sp, #156
 7757              	.LVL690:
2660:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 7758              		.loc 1 2660 0
 7759 4418 A420CDE5 		strb	r2, [sp, #164]
2662:../uvc.c      ****     gpioClock.halfDiv    = 0;
 7760              		.loc 1 2662 0
 7761 441c A0208DE5 		str	r2, [sp, #160]
2658:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 7762              		.loc 1 2658 0
 7763 4420 9C60CDE5 		strb	r6, [sp, #156]
2659:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 7764              		.loc 1 2659 0
 7765 4424 9D60CDE5 		strb	r6, [sp, #157]
2661:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 7766              		.loc 1 2661 0
 7767 4428 A570CDE5 		strb	r7, [sp, #165]
2665:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 7768              		.loc 1 2665 0
 7769 442c FEFFFFEB 		bl	CyU3PGpioInit
 7770              	.LVL691:
2666:../uvc.c      ****     if (apiRetStatus != 0)
 7771              		.loc 1 2666 0
 7772 4430 002050E2 		subs	r2, r0, #0
 7773 4434 FF00001A 		bne	.L715
2674:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 7774              		.loc 1 2674 0
 7775 4438 1600A0E3 		mov	r0, #22
 7776              	.LVL692:
 7777 443c 0110A0E3 		mov	r1, #1
 7778 4440 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 7779              	.LVL693:
2675:../uvc.c      ****     if (apiRetStatus != 0)
 7780              		.loc 1 2675 0
 7781 4444 002050E2 		subs	r2, r0, #0
 7782 4448 F100001A 		bne	.L716
2680:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 7783              		.loc 1 2680 0
 7784 444c 1400A0E3 		mov	r0, #20
 7785              	.LVL694:
 7786 4450 0110A0E3 		mov	r1, #1
 7787 4454 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 7788              	.LVL695:
2681:../uvc.c      ****     if (apiRetStatus != 0)
 7789              		.loc 1 2681 0
 7790 4458 002050E2 		subs	r2, r0, #0
 7791 445c FE00001A 		bne	.L717
2686:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 7792              		.loc 1 2686 0
 7793 4460 1800A0E3 		mov	r0, #24
 7794              	.LVL696:
 7795 4464 0110A0E3 		mov	r1, #1
 7796 4468 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 7797              	.LVL697:
2687:../uvc.c      ****     if (apiRetStatus != 0)
 7798              		.loc 1 2687 0
 7799 446c 002050E2 		subs	r2, r0, #0
 7800 4470 E101001A 		bne	.L718
2694:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 7801              		.loc 1 2694 0
 7802 4474 0150A0E3 		mov	r5, #1
2699:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 7803              		.loc 1 2699 0
 7804 4478 1600A0E3 		mov	r0, #22
 7805              	.LVL698:
 7806 447c 68108DE2 		add	r1, sp, #104
2697:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 7807              		.loc 1 2697 0
 7808 4480 74208DE5 		str	r2, [sp, #116]
2698:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 7809              		.loc 1 2698 0
 7810 4484 7820CDE5 		strb	r2, [sp, #120]
2694:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 7811              		.loc 1 2694 0
 7812 4488 68508DE5 		str	r5, [sp, #104]
2695:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 7813              		.loc 1 2695 0
 7814 448c 6C508DE5 		str	r5, [sp, #108]
2696:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 7815              		.loc 1 2696 0
 7816 4490 70508DE5 		str	r5, [sp, #112]
2699:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 7817              		.loc 1 2699 0
 7818 4494 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 7819              	.LVL699:
2700:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7820              		.loc 1 2700 0
 7821 4498 002050E2 		subs	r2, r0, #0
 7822 449c CD01001A 		bne	.L719
2713:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 7823              		.loc 1 2713 0
 7824 44a0 1400A0E3 		mov	r0, #20
 7825              	.LVL700:
 7826 44a4 68108DE2 		add	r1, sp, #104
2711:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 7827              		.loc 1 2711 0
 7828 44a8 74208DE5 		str	r2, [sp, #116]
2712:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 7829              		.loc 1 2712 0
 7830 44ac 7820CDE5 		strb	r2, [sp, #120]
2708:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 7831              		.loc 1 2708 0
 7832 44b0 68508DE5 		str	r5, [sp, #104]
2709:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 7833              		.loc 1 2709 0
 7834 44b4 6C508DE5 		str	r5, [sp, #108]
2710:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 7835              		.loc 1 2710 0
 7836 44b8 70508DE5 		str	r5, [sp, #112]
2713:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 7837              		.loc 1 2713 0
 7838 44bc FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 7839              	.LVL701:
2714:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7840              		.loc 1 2714 0
 7841 44c0 002050E2 		subs	r2, r0, #0
 7842 44c4 D501001A 		bne	.L720
2727:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 7843              		.loc 1 2727 0
 7844 44c8 1800A0E3 		mov	r0, #24
 7845              	.LVL702:
 7846 44cc 68108DE2 		add	r1, sp, #104
2722:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 7847              		.loc 1 2722 0
 7848 44d0 68208DE5 		str	r2, [sp, #104]
2723:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 7849              		.loc 1 2723 0
 7850 44d4 6C208DE5 		str	r2, [sp, #108]
2724:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 7851              		.loc 1 2724 0
 7852 44d8 70208DE5 		str	r2, [sp, #112]
2726:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 7853              		.loc 1 2726 0
 7854 44dc 7820CDE5 		strb	r2, [sp, #120]
2725:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 7855              		.loc 1 2725 0
 7856 44e0 74508DE5 		str	r5, [sp, #116]
2727:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 7857              		.loc 1 2727 0
 7858 44e4 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 7859              	.LVL703:
2728:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7860              		.loc 1 2728 0
 7861 44e8 002050E2 		subs	r2, r0, #0
 7862 44ec B001001A 		bne	.L721
2740:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 7863              		.loc 1 2740 0
 7864 44f0 0500A0E1 		mov	r0, r5
 7865              	.LVL704:
 7866 44f4 7C108DE2 		add	r1, sp, #124
2737:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 7867              		.loc 1 2737 0
 7868 44f8 84208DE5 		str	r2, [sp, #132]
2738:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 7869              		.loc 1 2738 0
 7870 44fc 80208DE5 		str	r2, [sp, #128]
2735:../uvc.c      ****     pibclock.clkDiv      = 2;
 7871              		.loc 1 2735 0
 7872 4500 BC67CDE1 		strh	r6, [sp, #124]	@ movhi
2736:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 7873              		.loc 1 2736 0
 7874 4504 8870CDE5 		strb	r7, [sp, #136]
2740:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 7875              		.loc 1 2740 0
 7876 4508 FEFFFFEB 		bl	CyU3PPibInit
 7877              	.LVL705:
2741:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7878              		.loc 1 2741 0
 7879 450c 002050E2 		subs	r2, r0, #0
 7880 4510 9E01001A 		bne	.L722
2748:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 7881              		.loc 1 2748 0
 7882 4514 100A9FE5 		ldr	r0, .L740+24
 7883              	.LVL706:
 7884 4518 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 7885              	.LVL707:
2756:../uvc.c      ****     SensorReset ();
 7886              		.loc 1 2756 0
 7887 451c FEFFFFEB 		bl	SensorReset
2757:../uvc.c      ****     CyU3PThreadSleep(5000);
 7888              		.loc 1 2757 0
 7889 4520 080A9FE5 		ldr	r0, .L740+28
 7890 4524 FEFFFFEB 		bl	_tx_thread_sleep
2761:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 7891              		.loc 1 2761 0
 7892 4528 FEFFFFEB 		bl	CyU3PUsbStart
 7893              	.LVL708:
2762:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7894              		.loc 1 2762 0
 7895 452c 002050E2 		subs	r2, r0, #0
 7896 4530 8D01001A 		bne	.L723
2768:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 7897              		.loc 1 2768 0
 7898 4534 0010A0E3 		mov	r1, #0
 7899 4538 F4099FE5 		ldr	r0, .L740+32
 7900              	.LVL709:
 7901 453c FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 7902              	.LVL710:
2771:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 7903              		.loc 1 2771 0
 7904 4540 F0099FE5 		ldr	r0, .L740+36
 7905 4544 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
2777:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 7906              		.loc 1 2777 0
 7907 4548 0010A0E3 		mov	r1, #0
 7908 454c E8299FE5 		ldr	r2, .L740+40
 7909 4550 0100A0E3 		mov	r0, #1
 7910 4554 FEFFFFEB 		bl	CyU3PUsbSetDesc
2778:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 7911              		.loc 1 2778 0
 7912 4558 0000A0E3 		mov	r0, #0
 7913 455c 0010A0E1 		mov	r1, r0
 7914 4560 D8299FE5 		ldr	r2, .L740+44
 7915 4564 FEFFFFEB 		bl	CyU3PUsbSetDesc
2781:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 7916              		.loc 1 2781 0
 7917 4568 0010A0E3 		mov	r1, #0
 7918 456c D0299FE5 		ldr	r2, .L740+48
 7919 4570 0200A0E3 		mov	r0, #2
 7920 4574 FEFFFFEB 		bl	CyU3PUsbSetDesc
2782:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 7921              		.loc 1 2782 0
 7922 4578 0010A0E3 		mov	r1, #0
 7923 457c C4299FE5 		ldr	r2, .L740+52
 7924 4580 0700A0E3 		mov	r0, #7
 7925 4584 FEFFFFEB 		bl	CyU3PUsbSetDesc
2785:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 7926              		.loc 1 2785 0
 7927 4588 0010A0E3 		mov	r1, #0
 7928 458c B8299FE5 		ldr	r2, .L740+56
 7929 4590 0400A0E3 		mov	r0, #4
 7930 4594 FEFFFFEB 		bl	CyU3PUsbSetDesc
2786:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 7931              		.loc 1 2786 0
 7932 4598 0010A0E3 		mov	r1, #0
 7933 459c AC299FE5 		ldr	r2, .L740+60
 7934 45a0 0300A0E3 		mov	r0, #3
 7935 45a4 FEFFFFEB 		bl	CyU3PUsbSetDesc
2787:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 7936              		.loc 1 2787 0
 7937 45a8 0010A0E3 		mov	r1, #0
 7938 45ac A0299FE5 		ldr	r2, .L740+64
 7939 45b0 0600A0E3 		mov	r0, #6
 7940 45b4 FEFFFFEB 		bl	CyU3PUsbSetDesc
2790:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 7941              		.loc 1 2790 0
 7942 45b8 0010A0E3 		mov	r1, #0
 7943 45bc 94299FE5 		ldr	r2, .L740+68
 7944 45c0 0500A0E3 		mov	r0, #5
 7945 45c4 FEFFFFEB 		bl	CyU3PUsbSetDesc
2791:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 7946              		.loc 1 2791 0
 7947 45c8 0110A0E3 		mov	r1, #1
 7948 45cc 88299FE5 		ldr	r2, .L740+72
 7949 45d0 0500A0E3 		mov	r0, #5
 7950 45d4 FEFFFFEB 		bl	CyU3PUsbSetDesc
2792:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 7951              		.loc 1 2792 0
 7952 45d8 0210A0E3 		mov	r1, #2
 7953 45dc 7C299FE5 		ldr	r2, .L740+76
 7954 45e0 0500A0E3 		mov	r0, #5
 7955 45e4 FEFFFFEB 		bl	CyU3PUsbSetDesc
2802:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 7956              		.loc 1 2802 0
 7957 45e8 0080A0E3 		mov	r8, #0
2799:../uvc.c      ****     endPointConfig.enable   = 1;
 7958              		.loc 1 2799 0
 7959 45ec 0150A0E3 		mov	r5, #1
2801:../uvc.c      ****     endPointConfig.pcktSize = 64;
 7960              		.loc 1 2801 0
 7961 45f0 4070A0E3 		mov	r7, #64	@ movhi
2805:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 7962              		.loc 1 2805 0
 7963 45f4 8200A0E3 		mov	r0, #130
 7964 45f8 A8108DE2 		add	r1, sp, #168
2800:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 7965              		.loc 1 2800 0
 7966 45fc 03A0A0E3 		mov	sl, #3
2801:../uvc.c      ****     endPointConfig.pcktSize = 64;
 7967              		.loc 1 2801 0
 7968 4600 B07BCDE1 		strh	r7, [sp, #176]	@ movhi
2799:../uvc.c      ****     endPointConfig.enable   = 1;
 7969              		.loc 1 2799 0
 7970 4604 A8508DE5 		str	r5, [sp, #168]
2800:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 7971              		.loc 1 2800 0
 7972 4608 ACA0CDE5 		strb	sl, [sp, #172]
2802:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 7973              		.loc 1 2802 0
 7974 460c B380CDE5 		strb	r8, [sp, #179]
2803:../uvc.c      ****     endPointConfig.streams  = 0;
 7975              		.loc 1 2803 0
 7976 4610 BE8ACDE1 		strh	r8, [sp, #174]	@ movhi
2804:../uvc.c      ****     endPointConfig.burstLen = 1;
 7977              		.loc 1 2804 0
 7978 4614 B250CDE5 		strb	r5, [sp, #178]
2805:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 7979              		.loc 1 2805 0
 7980 4618 FEFFFFEB 		bl	CyU3PSetEpConfig
 7981              	.LVL711:
2803:../uvc.c      ****     endPointConfig.streams  = 0;
 7982              		.loc 1 2803 0
 7983 461c 0870A0E1 		mov	r7, r8	@ movhi
2806:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7984              		.loc 1 2806 0
 7985 4620 003050E2 		subs	r3, r0, #0
 7986 4624 4601001A 		bne	.L724
2816:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 7987              		.loc 1 2816 0
 7988 4628 34C99FE5 		ldr	ip, .L740+80
2817:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 7989              		.loc 1 2817 0
 7990 462c 34E99FE5 		ldr	lr, .L740+84
2814:../uvc.c      ****     dmaInterConfig.size           = 1024;
 7991              		.loc 1 2814 0
 7992 4630 016BA0E3 		mov	r6, #1024	@ movhi
2823:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 7993              		.loc 1 2823 0
 7994 4634 1080A0E3 		mov	r8, #16
2825:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 7995              		.loc 1 2825 0
 7996 4638 2C099FE5 		ldr	r0, .L740+88
 7997              	.LVL712:
 7998 463c 0410A0E3 		mov	r1, #4
 7999 4640 34208DE2 		add	r2, sp, #52
2814:../uvc.c      ****     dmaInterConfig.size           = 1024;
 8000              		.loc 1 2814 0
 8001 4644 B463CDE1 		strh	r6, [sp, #52]	@ movhi
2815:../uvc.c      ****     dmaInterConfig.count          = 1;
 8002              		.loc 1 2815 0
 8003 4648 B653CDE1 		strh	r5, [sp, #54]	@ movhi
2816:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 8004              		.loc 1 2816 0
 8005 464c B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
2817:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 8006              		.loc 1 2817 0
 8007 4650 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
2818:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 8008              		.loc 1 2818 0
 8009 4654 BC33CDE1 		strh	r3, [sp, #60]	@ movhi
2819:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 8010              		.loc 1 2819 0
 8011 4658 BE33CDE1 		strh	r3, [sp, #62]	@ movhi
2820:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 8012              		.loc 1 2820 0
 8013 465c B034CDE1 		strh	r3, [sp, #64]	@ movhi
2821:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 8014              		.loc 1 2821 0
 8015 4660 B234CDE1 		strh	r3, [sp, #66]	@ movhi
2822:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 8016              		.loc 1 2822 0
 8017 4664 4470CDE5 		strb	r7, [sp, #68]
2823:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 8018              		.loc 1 2823 0
 8019 4668 48808DE5 		str	r8, [sp, #72]
2824:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 8020              		.loc 1 2824 0
 8021 466c 4C308DE5 		str	r3, [sp, #76]
2825:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 8022              		.loc 1 2825 0
 8023 4670 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 8024              	.LVL713:
2827:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8025              		.loc 1 2827 0
 8026 4674 006050E2 		subs	r6, r0, #0
 8027 4678 EA00001A 		bne	.L725
2834:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 8028              		.loc 1 2834 0
 8029 467c 010BA0E3 		mov	r0, #1024
 8030              	.LVL714:
 8031 4680 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 8032 4684 E4189FE5 		ldr	r1, .L740+92
2835:../uvc.c      ****     if (glInterStaBuffer == 0)
 8033              		.loc 1 2835 0
 8034 4688 000050E3 		cmp	r0, #0
2834:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 8035              		.loc 1 2834 0
 8036 468c 000081E5 		str	r0, [r1, #0]
2835:../uvc.c      ****     if (glInterStaBuffer == 0)
 8037              		.loc 1 2835 0
 8038 4690 DB00000A 		beq	.L726
2842:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
 8039              		.loc 1 2842 0
 8040 4694 0610A0E1 		mov	r1, r6
 8041 4698 0620A0E1 		mov	r2, r6
 8042 469c 3830A0E3 		mov	r3, #56
 8043 46a0 CC089FE5 		ldr	r0, .L740+96
 8044 46a4 FEFFFFEB 		bl	_txe_mutex_create
2844:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 8045              		.loc 1 2844 0
 8046 46a8 0430A0E3 		mov	r3, #4	@ movhi
 8047 46ac BE30CDE1 		strh	r3, [sp, #14]	@ movhi
2847:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 8048              		.loc 1 2847 0
 8049 46b0 C0389FE5 		ldr	r3, .L740+100
2843:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 8050              		.loc 1 2843 0
 8051 46b4 01C9A0E3 		mov	ip, #16384	@ movhi
 8052 46b8 BCC0CDE1 		strh	ip, [sp, #12]	@ movhi
2846:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 8053              		.loc 1 2846 0
 8054 46bc 01CCA0E3 		mov	ip, #256	@ movhi
 8055 46c0 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
2847:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 8056              		.loc 1 2847 0
 8057 46c4 B431CDE1 		strh	r3, [sp, #20]	@ movhi
2848:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 8058              		.loc 1 2848 0
 8059 46c8 ACC89FE5 		ldr	ip, .L740+104
2850:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 8060              		.loc 1 2850 0
 8061 46cc 0C30A0E3 		mov	r3, #12	@ movhi
 8062 46d0 B432CDE1 		strh	r3, [sp, #36]	@ movhi
2855:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 8063              		.loc 1 2855 0
 8064 46d4 A4389FE5 		ldr	r3, .L740+108
2856:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 8065              		.loc 1 2856 0
 8066 46d8 0C208DE2 		add	r2, sp, #12
2848:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 8067              		.loc 1 2848 0
 8068 46dc BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
2853:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 8069              		.loc 1 2853 0
 8070 46e0 2A70CDE5 		strb	r7, [sp, #42]
2851:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 8071              		.loc 1 2851 0
 8072 46e4 04C0A0E3 		mov	ip, #4	@ movhi
2845:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 8073              		.loc 1 2845 0
 8074 46e8 02A0A0E3 		mov	sl, #2	@ movhi
2856:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 8075              		.loc 1 2856 0
 8076 46ec 90089FE5 		ldr	r0, .L740+112
 8077 46f0 0710A0E3 		mov	r1, #7
2854:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 8078              		.loc 1 2854 0
 8079 46f4 1870A0E3 		mov	r7, #24
2845:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 8080              		.loc 1 2845 0
 8081 46f8 B0A1CDE1 		strh	sl, [sp, #16]	@ movhi
2849:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 8082              		.loc 1 2849 0
 8083 46fc B262CDE1 		strh	r6, [sp, #34]	@ movhi
2851:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 8084              		.loc 1 2851 0
 8085 4700 B6C2CDE1 		strh	ip, [sp, #38]	@ movhi
2852:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 8086              		.loc 1 2852 0
 8087 4704 B862CDE1 		strh	r6, [sp, #40]	@ movhi
2854:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 8088              		.loc 1 2854 0
 8089 4708 2C708DE5 		str	r7, [sp, #44]
2855:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 8090              		.loc 1 2855 0
 8091 470c 30308DE5 		str	r3, [sp, #48]
2856:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 8092              		.loc 1 2856 0
 8093 4710 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 8094              	.LVL715:
2858:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8095              		.loc 1 2858 0
 8096 4714 002050E2 		subs	r2, r0, #0
 8097 4718 B000001A 		bne	.L727
2949:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 8098              		.loc 1 2949 0
 8099 471c 0500A0E1 		mov	r0, r5
 8100              	.LVL716:
 8101 4720 0510A0E1 		mov	r1, r5
 8102 4724 FEFFFFEB 		bl	CyU3PConnectState
 8103              	.LVL717:
2950:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8104              		.loc 1 2950 0
 8105 4728 002050E2 		subs	r2, r0, #0
 8106 472c A200001A 		bne	.L728
2956:../uvc.c      ****     CyU3PBusyWait(100);
 8107              		.loc 1 2956 0
 8108 4730 6400A0E3 		mov	r0, #100
 8109              	.LVL718:
 8110 4734 FEFFFFEB 		bl	CyU3PBusyWait
 8111              	.LVL719:
2958:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 8112              		.loc 1 2958 0
 8113 4738 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2972:../uvc.c      ****     endPointConfig.streams  = 0;
 8114              		.loc 1 2972 0
 8115 473c 0020A0E3 		mov	r2, #0	@ movhi
2961:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 8116              		.loc 1 2961 0
 8117 4740 ACA0CDE5 		strb	sl, [sp, #172]
2973:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 8118              		.loc 1 2973 0
 8119 4744 A8108DE2 		add	r1, sp, #168
2972:../uvc.c      ****     endPointConfig.streams  = 0;
 8120              		.loc 1 2972 0
 8121 4748 BE2ACDE1 		strh	r2, [sp, #174]	@ movhi
2960:../uvc.c      ****     endPointConfig.enable   = 1;
 8122              		.loc 1 2960 0
 8123 474c A8508DE5 		str	r5, [sp, #168]
2962:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 8124              		.loc 1 2962 0
 8125 4750 030050E3 		cmp	r0, #3
2958:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 8126              		.loc 1 2958 0
 8127 4754 C800C4E5 		strb	r0, [r4, #200]
2969:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 8128              		.loc 1 2969 0
 8129 4758 020CA013 		movne	r0, #512	@ movhi
2964:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 8130              		.loc 1 2964 0
 8131 475c 01ABA003 		moveq	sl, #1024	@ movhi
2969:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 8132              		.loc 1 2969 0
 8133 4760 B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2973:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 8134              		.loc 1 2973 0
 8135 4764 8300A0E3 		mov	r0, #131
2964:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 8136              		.loc 1 2964 0
 8137 4768 B0ABCD01 		streqh	sl, [sp, #176]	@ movhi
2965:../uvc.c      ****     	endPointConfig.burstLen = 16;
 8138              		.loc 1 2965 0
 8139 476c B280CD05 		streqb	r8, [sp, #178]
2970:../uvc.c      ****     	endPointConfig.burstLen = 1;
 8140              		.loc 1 2970 0
 8141 4770 B250CD15 		strneb	r5, [sp, #178]
2973:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 8142              		.loc 1 2973 0
 8143 4774 FEFFFFEB 		bl	CyU3PSetEpConfig
 8144              	.LVL720:
2974:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8145              		.loc 1 2974 0
 8146 4778 002050E2 		subs	r2, r0, #0
 8147 477c 5600001A 		bne	.L711
 8148 4780 00789FE5 		ldr	r7, .L740+116
 8149              	.LBE226:
 8150              	.LBE223:
3097:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 8151              		.loc 1 3097 0
 8152 4784 9C579FE5 		ldr	r5, .L740+20
 8153 4788 0260A0E1 		mov	r6, r2
3311:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 8154              		.loc 1 3311 0
 8155 478c 0080E0E3 		mvn	r8, #0
 8156              	.LVL721:
 8157              	.L662:
3097:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 8158              		.loc 1 3097 0
 8159 4790 90079FE5 		ldr	r0, .L740+20
 8160 4794 0110A0E3 		mov	r1, #1
 8161 4798 0220A0E3 		mov	r2, #2
 8162 479c B4308DE2 		add	r3, sp, #180
 8163 47a0 00608DE5 		str	r6, [sp, #0]
 8164 47a4 FEFFFFEB 		bl	_txe_event_flags_get
 8165 47a8 000050E3 		cmp	r0, #0
 8166 47ac 3300001A 		bne	.L664
3101:../uvc.c      ****         	debugData[0][1] = debugData[0][1]|0x01;
 8167              		.loc 1 3101 0
 8168 47b0 2910D5E5 		ldrb	r1, [r5, #41]	@ zero_extendqisi2
3145:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 8169              		.loc 1 3145 0
 8170 47b4 BCE095E5 		ldr	lr, [r5, #188]
3101:../uvc.c      ****         	debugData[0][1] = debugData[0][1]|0x01;
 8171              		.loc 1 3101 0
 8172 47b8 013081E3 		orr	r3, r1, #1
3145:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 8173              		.loc 1 3145 0
 8174 47bc 00005EE3 		cmp	lr, #0
3101:../uvc.c      ****         	debugData[0][1] = debugData[0][1]|0x01;
 8175              		.loc 1 3101 0
 8176 47c0 2930C5E5 		strb	r3, [r5, #41]
3145:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 8177              		.loc 1 3145 0
 8178 47c4 0300000A 		beq	.L665
3145:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 8179              		.loc 1 3145 0 is_stmt 0 discriminator 1
 8180 47c8 B0CCD5E1 		ldrh	ip, [r5, #192]
 8181 47cc B22CD5E1 		ldrh	r2, [r5, #194]
 8182 47d0 02005CE1 		cmp	ip, r2
 8183 47d4 1A01000A 		beq	.L729
 8184              	.L665:
3386:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 8185              		.loc 1 3386 0 is_stmt 1
 8186 47d8 4010A0E3 		mov	r1, #64
 8187 47dc 0020A0E3 		mov	r2, #0
 8188 47e0 40079FE5 		ldr	r0, .L740+20
 8189 47e4 FEFFFFEB 		bl	_txe_event_flags_set
3389:../uvc.c      ****         CyU3PThreadRelinquish ();
 8190              		.loc 1 3389 0
 8191 47e8 FEFFFFEB 		bl	_txe_thread_relinquish
3390:../uvc.c      ****     }
 8192              		.loc 1 3390 0
 8193 47ec E7FFFFEA 		b	.L662
 8194              	.LVL722:
 8195              	.L714:
 8196              	.LBB261:
 8197              	.LBB225:
2646:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 8198              		.loc 1 2646 0
 8199 47f0 0400A0E3 		mov	r0, #4
 8200              	.LVL723:
 8201 47f4 90179FE5 		ldr	r1, .L740+120
 8202 47f8 FEFFFFEB 		bl	CyU3PDebugPrint
 8203              	.LVL724:
 8204              	.L631:
 8205              	.LBB241:
 8206              	.LBB242:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8207              		.loc 1 2061 0
 8208 47fc 8C179FE5 		ldr	r1, .L740+124
 8209 4800 0400A0E3 		mov	r0, #4
 8210 4804 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8211              		.loc 1 2062 0
 8212 4808 FA0FA0E3 		mov	r0, #1000
 8213 480c FEFFFFEB 		bl	_tx_thread_sleep
 8214 4810 F9FFFFEA 		b	.L631
 8215              	.LVL725:
 8216              	.L716:
 8217              	.LBE242:
 8218              	.LBE241:
2677:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 8219              		.loc 1 2677 0
 8220 4814 0400A0E3 		mov	r0, #4
 8221              	.LVL726:
 8222 4818 74179FE5 		ldr	r1, .L740+128
 8223 481c FEFFFFEB 		bl	CyU3PDebugPrint
 8224              	.LVL727:
 8225              	.L635:
 8226              	.LBB239:
 8227              	.LBB240:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8228              		.loc 1 2061 0
 8229 4820 68179FE5 		ldr	r1, .L740+124
 8230 4824 0400A0E3 		mov	r0, #4
 8231 4828 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8232              		.loc 1 2062 0
 8233 482c FA0FA0E3 		mov	r0, #1000
 8234 4830 FEFFFFEB 		bl	_tx_thread_sleep
 8235 4834 F9FFFFEA 		b	.L635
 8236              	.LVL728:
 8237              	.L715:
 8238              	.LBE240:
 8239              	.LBE239:
2668:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 8240              		.loc 1 2668 0
 8241 4838 0400A0E3 		mov	r0, #4
 8242              	.LVL729:
 8243 483c 54179FE5 		ldr	r1, .L740+132
 8244 4840 FEFFFFEB 		bl	CyU3PDebugPrint
 8245              	.LVL730:
 8246              	.L633:
 8247              	.LBB237:
 8248              	.LBB238:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8249              		.loc 1 2061 0
 8250 4844 44179FE5 		ldr	r1, .L740+124
 8251 4848 0400A0E3 		mov	r0, #4
 8252 484c FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8253              		.loc 1 2062 0
 8254 4850 FA0FA0E3 		mov	r0, #1000
 8255 4854 FEFFFFEB 		bl	_tx_thread_sleep
 8256 4858 F9FFFFEA 		b	.L633
 8257              	.LVL731:
 8258              	.L717:
 8259              	.LBE238:
 8260              	.LBE237:
2683:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 8261              		.loc 1 2683 0
 8262 485c 0400A0E3 		mov	r0, #4
 8263              	.LVL732:
 8264 4860 34179FE5 		ldr	r1, .L740+136
 8265 4864 FEFFFFEB 		bl	CyU3PDebugPrint
 8266              	.LVL733:
 8267              	.L637:
 8268              	.LBB235:
 8269              	.LBB236:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8270              		.loc 1 2061 0
 8271 4868 20179FE5 		ldr	r1, .L740+124
 8272 486c 0400A0E3 		mov	r0, #4
 8273 4870 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8274              		.loc 1 2062 0
 8275 4874 FA0FA0E3 		mov	r0, #1000
 8276 4878 FEFFFFEB 		bl	_tx_thread_sleep
 8277 487c F9FFFFEA 		b	.L637
 8278              	.LVL734:
 8279              	.L664:
 8280              	.LBE236:
 8281              	.LBE235:
 8282              	.LBE225:
 8283              	.LBE261:
3258:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 8284              		.loc 1 3258 0
 8285 4880 A0069FE5 		ldr	r0, .L740+20
 8286 4884 0210A0E3 		mov	r1, #2
 8287 4888 0320A0E3 		mov	r2, #3
 8288 488c B4308DE2 		add	r3, sp, #180
 8289 4890 00608DE5 		str	r6, [sp, #0]
 8290 4894 FEFFFFEB 		bl	_txe_event_flags_get
 8291 4898 000050E3 		cmp	r0, #0
 8292 489c 2900001A 		bne	.L687
3261:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
 8293              		.loc 1 3261 0
 8294 48a0 29C0D5E5 		ldrb	ip, [r5, #41]	@ zero_extendqisi2
3275:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 8295              		.loc 1 3275 0
 8296 48a4 C41095E5 		ldr	r1, [r5, #196]
3261:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
 8297              		.loc 1 3261 0
 8298 48a8 7F300CE2 		and	r3, ip, #127
3262:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x04;
 8299              		.loc 1 3262 0
 8300 48ac 040083E3 		orr	r0, r3, #4
3275:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 8301              		.loc 1 3275 0
 8302 48b0 000051E3 		cmp	r1, #0
3263:../uvc.c      ****             	hitFV     = CyFalse;
 8303              		.loc 1 3263 0
 8304 48b4 BC6085E5 		str	r6, [r5, #188]
3262:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x04;
 8305              		.loc 1 3262 0
 8306 48b8 2900C5E5 		strb	r0, [r5, #41]
3264:../uvc.c      ****                 prodCount = 0;
 8307              		.loc 1 3264 0
 8308 48bc B06CC5E1 		strh	r6, [r5, #192]	@ movhi
3271:../uvc.c      ****                 fb=0;
 8309              		.loc 1 3271 0
 8310 48c0 B46BC5E1 		strh	r6, [r5, #180]	@ movhi
3265:../uvc.c      ****                 consCount = 0;
 8311              		.loc 1 3265 0
 8312 48c4 B26CC5E1 		strh	r6, [r5, #194]	@ movhi
3272:../uvc.c      ****                 pb=0;
 8313              		.loc 1 3272 0
 8314 48c8 B66BC5E1 		strh	r6, [r5, #182]	@ movhi
3273:../uvc.c      ****                 pbc=0;
 8315              		.loc 1 3273 0
 8316 48cc B86BC5E1 		strh	r6, [r5, #184]	@ movhi
3275:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 8317              		.loc 1 3275 0
 8318 48d0 0A00000A 		beq	.L730
 8319              	.L688:
3287:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 8320              		.loc 1 3287 0
 8321 48d4 C46084E5 		str	r6, [r4, #196]
 8322 48d8 BEFFFFEA 		b	.L665
 8323              	.LVL735:
 8324              	.L711:
 8325              	.LBB262:
 8326              	.LBB259:
2977:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 8327              		.loc 1 2977 0
 8328 48dc 0400A0E3 		mov	r0, #4
 8329              	.LVL736:
 8330 48e0 B8169FE5 		ldr	r1, .L740+140
 8331 48e4 FEFFFFEB 		bl	CyU3PDebugPrint
 8332              	.LVL737:
 8333              	.L663:
 8334              	.LBB243:
 8335              	.LBB244:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8336              		.loc 1 2061 0
 8337 48e8 A0169FE5 		ldr	r1, .L740+124
 8338 48ec 0400A0E3 		mov	r0, #4
 8339 48f0 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8340              		.loc 1 2062 0
 8341 48f4 FA0FA0E3 		mov	r0, #1000
 8342 48f8 FEFFFFEB 		bl	_tx_thread_sleep
 8343 48fc F9FFFFEA 		b	.L663
 8344              	.LVL738:
 8345              	.L730:
 8346              	.LBE244:
 8347              	.LBE243:
 8348              	.LBE259:
 8349              	.LBE262:
3277:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 8350              		.loc 1 3277 0
 8351 4900 7C069FE5 		ldr	r0, .L740+112
 8352 4904 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 8353              	.LVL739:
3278:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 8354              		.loc 1 3278 0
 8355 4908 000050E3 		cmp	r0, #0
 8356 490c 0200001A 		bne	.L712
3284:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 8357              		.loc 1 3284 0
 8358 4910 8300A0E3 		mov	r0, #131
 8359              	.LVL740:
 8360 4914 FEFFFFEB 		bl	CyU3PUsbFlushEp
 8361 4918 EDFFFFEA 		b	.L688
 8362              	.L712:
 8363              	.LBB263:
 8364              	.LBB264:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8365              		.loc 1 2061 0
 8366 491c 6C169FE5 		ldr	r1, .L740+124
 8367 4920 0400A0E3 		mov	r0, #4
 8368 4924 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8369              		.loc 1 2062 0
 8370 4928 FA0FA0E3 		mov	r0, #1000
 8371 492c FEFFFFEB 		bl	_tx_thread_sleep
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8372              		.loc 1 2061 0
 8373 4930 58169FE5 		ldr	r1, .L740+124
 8374 4934 0400A0E3 		mov	r0, #4
 8375 4938 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8376              		.loc 1 2062 0
 8377 493c FA0FA0E3 		mov	r0, #1000
 8378 4940 FEFFFFEB 		bl	_tx_thread_sleep
 8379 4944 F4FFFFEA 		b	.L712
 8380              	.L687:
 8381              	.LBE264:
 8382              	.LBE263:
3311:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 8383              		.loc 1 3311 0
 8384 4948 0110A0E3 		mov	r1, #1
 8385 494c 0220A0E3 		mov	r2, #2
 8386 4950 B4308DE2 		add	r3, sp, #180
 8387 4954 CC059FE5 		ldr	r0, .L740+20
 8388 4958 00808DE5 		str	r8, [sp, #0]
 8389 495c FEFFFFEB 		bl	_txe_event_flags_get
3315:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 8390              		.loc 1 3315 0
 8391 4960 0620A0E1 		mov	r2, r6
 8392 4964 18069FE5 		ldr	r0, .L740+112
 8393 4968 0610A0E1 		mov	r1, r6
 8394 496c FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 8395              	.LVL741:
3316:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 8396              		.loc 1 3316 0
 8397 4970 002050E2 		subs	r2, r0, #0
 8398 4974 6900001A 		bne	.L731
3322:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
 8399              		.loc 1 3322 0
 8400 4978 2900D5E5 		ldrb	r0, [r5, #41]	@ zero_extendqisi2
 8401              	.LVL742:
3325:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 8402              		.loc 1 3325 0
 8403 497c A82095E5 		ldr	r2, [r5, #168]
 8404              	.LVL743:
3322:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
 8405              		.loc 1 3322 0
 8406 4980 7FA000E2 		and	sl, r0, #127
3323:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x08;
 8407              		.loc 1 3323 0
 8408 4984 08E08AE3 		orr	lr, sl, #8
3325:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 8409              		.loc 1 3325 0
 8410 4988 000052E3 		cmp	r2, #0
3323:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x08;
 8411              		.loc 1 3323 0
 8412 498c 29E0C5E5 		strb	lr, [r5, #41]
3325:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 8413              		.loc 1 3325 0
 8414 4990 5A00001A 		bne	.L693
 8415              	.LVL744:
 8416              	.LBB265:
 8417              	.LBB266:
3002:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 8418              		.loc 1 3002 0
 8419 4994 C830D5E5 		ldrb	r3, [r5, #200]	@ zero_extendqisi2
 8420 4998 030053E3 		cmp	r3, #3
 8421 499c 4700000A 		beq	.L732
3007:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 8422              		.loc 1 3007 0
 8423 49a0 020053E3 		cmp	r3, #2
 8424 49a4 2900000A 		beq	.L733
 8425              	.LVL745:
 8426              	.L696:
 8427              	.LBE266:
 8428              	.LBE265:
3373:../uvc.c      ****                     gpif_initialized = CyTrue;
 8429              		.loc 1 3373 0
 8430 49a8 0110A0E3 		mov	r1, #1
 8431 49ac A81084E5 		str	r1, [r4, #168]
3375:../uvc.c      ****                     CyU3PThreadSleep(200);
 8432              		.loc 1 3375 0
 8433 49b0 C800A0E3 		mov	r0, #200
 8434 49b4 FEFFFFEB 		bl	_tx_thread_sleep
 8435 49b8 86FFFFEA 		b	.L665
 8436              	.LVL746:
 8437              	.L728:
 8438              	.LBB272:
 8439              	.LBB224:
2952:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 8440              		.loc 1 2952 0
 8441 49bc 0400A0E3 		mov	r0, #4
 8442              	.LVL747:
 8443 49c0 DC159FE5 		ldr	r1, .L740+144
 8444 49c4 FEFFFFEB 		bl	CyU3PDebugPrint
 8445              	.LVL748:
 8446              	.L659:
 8447              	.LBB233:
 8448              	.LBB234:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8449              		.loc 1 2061 0
 8450 49c8 C0159FE5 		ldr	r1, .L740+124
 8451 49cc 0400A0E3 		mov	r0, #4
 8452 49d0 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8453              		.loc 1 2062 0
 8454 49d4 FA0FA0E3 		mov	r0, #1000
 8455 49d8 FEFFFFEB 		bl	_tx_thread_sleep
 8456 49dc F9FFFFEA 		b	.L659
 8457              	.LVL749:
 8458              	.L727:
 8459              	.LBE234:
 8460              	.LBE233:
2861:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 8461              		.loc 1 2861 0
 8462 49e0 0400A0E3 		mov	r0, #4
 8463              	.LVL750:
 8464 49e4 BC159FE5 		ldr	r1, .L740+148
 8465 49e8 FEFFFFEB 		bl	CyU3PDebugPrint
 8466              	.LVL751:
 8467              	.L657:
 8468              	.LBB231:
 8469              	.LBB232:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8470              		.loc 1 2061 0
 8471 49ec 9C159FE5 		ldr	r1, .L740+124
 8472 49f0 0400A0E3 		mov	r0, #4
 8473 49f4 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8474              		.loc 1 2062 0
 8475 49f8 FA0FA0E3 		mov	r0, #1000
 8476 49fc FEFFFFEB 		bl	_tx_thread_sleep
 8477 4a00 F9FFFFEA 		b	.L657
 8478              	.LVL752:
 8479              	.L726:
 8480              	.LBE232:
 8481              	.LBE231:
2837:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 8482              		.loc 1 2837 0
 8483 4a04 040080E2 		add	r0, r0, #4
 8484 4a08 9C159FE5 		ldr	r1, .L740+152
 8485 4a0c FEFFFFEB 		bl	CyU3PDebugPrint
 8486              	.LVL753:
 8487              	.L655:
 8488              	.LBB229:
 8489              	.LBB230:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8490              		.loc 1 2061 0
 8491 4a10 78159FE5 		ldr	r1, .L740+124
 8492 4a14 0400A0E3 		mov	r0, #4
 8493 4a18 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8494              		.loc 1 2062 0
 8495 4a1c FA0FA0E3 		mov	r0, #1000
 8496 4a20 FEFFFFEB 		bl	_tx_thread_sleep
 8497 4a24 F9FFFFEA 		b	.L655
 8498              	.LVL754:
 8499              	.L725:
 8500              	.LBE230:
 8501              	.LBE229:
2830:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 8502              		.loc 1 2830 0
 8503 4a28 0400A0E3 		mov	r0, #4
 8504 4a2c 7C159FE5 		ldr	r1, .L740+156
 8505 4a30 0620A0E1 		mov	r2, r6
 8506 4a34 FEFFFFEB 		bl	CyU3PDebugPrint
 8507              	.L653:
 8508              	.LBB227:
 8509              	.LBB228:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8510              		.loc 1 2061 0
 8511 4a38 50159FE5 		ldr	r1, .L740+124
 8512 4a3c 0400A0E3 		mov	r0, #4
 8513 4a40 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8514              		.loc 1 2062 0
 8515 4a44 FA0FA0E3 		mov	r0, #1000
 8516 4a48 FEFFFFEB 		bl	_tx_thread_sleep
 8517 4a4c F9FFFFEA 		b	.L653
 8518              	.LVL755:
 8519              	.L733:
 8520              	.LBE228:
 8521              	.LBE227:
 8522              	.LBE224:
 8523              	.LBE272:
 8524              	.LBB273:
 8525              	.LBB271:
3009:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 8526              		.loc 1 3009 0
 8527 4a50 5C159FE5 		ldr	r1, .L740+160
 8528 4a54 0100A0E3 		mov	r0, #1
 8529 4a58 FEFFFFEB 		bl	CyU3PDebugPrint
3010:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 8530              		.loc 1 3010 0
 8531 4a5c 54059FE5 		ldr	r0, .L740+164
 8532 4a60 FEFFFFEB 		bl	CyU3PGpifLoad
 8533 4a64 0020A0E1 		mov	r2, r0
 8534              	.LVL756:
 8535              	.L695:
3012:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8536              		.loc 1 3012 0
 8537 4a68 000052E3 		cmp	r2, #0
 8538 4a6c 1A00001A 		bne	.L734
3020:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 8539              		.loc 1 3020 0
 8540 4a70 C830D4E5 		ldrb	r3, [r4, #200]	@ zero_extendqisi2
 8541 4a74 030053E3 		cmp	r3, #3
 8542 4a78 0100000A 		beq	.L713
3024:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 8543              		.loc 1 3024 0
 8544 4a7c 020053E3 		cmp	r3, #2
 8545 4a80 C8FFFF1A 		bne	.L696
 8546              	.L713:
3026:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 8547              		.loc 1 3026 0
 8548 4a84 0200A0E1 		mov	r0, r2
 8549              	.LVL757:
 8550 4a88 0210A0E1 		mov	r1, r2
 8551 4a8c FEFFFFEB 		bl	CyU3PGpifSMStart
 8552              	.LVL758:
3028:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8553              		.loc 1 3028 0
 8554 4a90 000050E3 		cmp	r0, #0
3026:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 8555              		.loc 1 3026 0
 8556 4a94 0020A0E1 		mov	r2, r0
 8557              	.LVL759:
3028:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8558              		.loc 1 3028 0
 8559 4a98 C2FFFF0A 		beq	.L696
3031:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 8560              		.loc 1 3031 0
 8561 4a9c 0400A0E3 		mov	r0, #4
 8562              	.LVL760:
 8563 4aa0 14159FE5 		ldr	r1, .L740+168
 8564 4aa4 FEFFFFEB 		bl	CyU3PDebugPrint
 8565              	.LVL761:
 8566              	.L701:
 8567              	.LBB267:
 8568              	.LBB268:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8569              		.loc 1 2061 0
 8570 4aa8 E0149FE5 		ldr	r1, .L740+124
 8571 4aac 0400A0E3 		mov	r0, #4
 8572 4ab0 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8573              		.loc 1 2062 0
 8574 4ab4 FA0FA0E3 		mov	r0, #1000
 8575 4ab8 FEFFFFEB 		bl	_tx_thread_sleep
 8576 4abc F9FFFFEA 		b	.L701
 8577              	.LVL762:
 8578              	.L732:
 8579              	.LBE268:
 8580              	.LBE267:
3004:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 8581              		.loc 1 3004 0
 8582 4ac0 F8149FE5 		ldr	r1, .L740+172
 8583 4ac4 0100A0E3 		mov	r0, #1
 8584 4ac8 FEFFFFEB 		bl	CyU3PDebugPrint
3005:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 8585              		.loc 1 3005 0
 8586 4acc F0049FE5 		ldr	r0, .L740+176
 8587 4ad0 FEFFFFEB 		bl	CyU3PGpifLoad
 8588 4ad4 0020A0E1 		mov	r2, r0
 8589              	.LVL763:
 8590 4ad8 E2FFFFEA 		b	.L695
 8591              	.L734:
3015:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 8592              		.loc 1 3015 0
 8593 4adc 0400A0E3 		mov	r0, #4
 8594              	.LVL764:
 8595 4ae0 E0149FE5 		ldr	r1, .L740+180
 8596 4ae4 FEFFFFEB 		bl	CyU3PDebugPrint
 8597              	.LVL765:
 8598              	.L698:
 8599              	.LBB269:
 8600              	.LBB270:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8601              		.loc 1 2061 0
 8602 4ae8 A0149FE5 		ldr	r1, .L740+124
 8603 4aec 0400A0E3 		mov	r0, #4
 8604 4af0 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8605              		.loc 1 2062 0
 8606 4af4 FA0FA0E3 		mov	r0, #1000
 8607 4af8 FEFFFFEB 		bl	_tx_thread_sleep
 8608 4afc F9FFFFEA 		b	.L698
 8609              	.L693:
 8610              	.LBE270:
 8611              	.LBE269:
 8612              	.LBE271:
 8613              	.LBE273:
3382:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 8614              		.loc 1 3382 0
 8615 4b00 70049FE5 		ldr	r0, .L740+100
 8616 4b04 02C0A0E3 		mov	ip, #2
 8617 4b08 0610A0E1 		mov	r1, r6
 8618 4b0c 0020A0E1 		mov	r2, r0
 8619 4b10 0630A0E1 		mov	r3, r6
 8620 4b14 00C08DE5 		str	ip, [sp, #0]
 8621 4b18 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 8622 4b1c 2DFFFFEA 		b	.L665
 8623              	.LVL766:
 8624              	.L731:
3319:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 8625              		.loc 1 3319 0
 8626 4b20 0400A0E3 		mov	r0, #4
 8627              	.LVL767:
 8628 4b24 A0149FE5 		ldr	r1, .L740+184
 8629 4b28 FEFFFFEB 		bl	CyU3PDebugPrint
 8630              	.LVL768:
 8631              	.L692:
 8632              	.LBB274:
 8633              	.LBB275:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8634              		.loc 1 2061 0
 8635 4b2c 5C149FE5 		ldr	r1, .L740+124
 8636 4b30 0400A0E3 		mov	r0, #4
 8637 4b34 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8638              		.loc 1 2062 0
 8639 4b38 FA0FA0E3 		mov	r0, #1000
 8640 4b3c FEFFFFEB 		bl	_tx_thread_sleep
 8641 4b40 F9FFFFEA 		b	.L692
 8642              	.LVL769:
 8643              	.L724:
 8644              	.LBE275:
 8645              	.LBE274:
 8646              	.LBB276:
 8647              	.LBB260:
2809:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 8648              		.loc 1 2809 0
 8649 4b44 0400A0E3 		mov	r0, #4
 8650              	.LVL770:
 8651 4b48 50149FE5 		ldr	r1, .L740+140
 8652 4b4c 0320A0E1 		mov	r2, r3
 8653 4b50 FEFFFFEB 		bl	CyU3PDebugPrint
 8654              	.LVL771:
 8655              	.L651:
 8656              	.LBB245:
 8657              	.LBB246:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8658              		.loc 1 2061 0
 8659 4b54 34149FE5 		ldr	r1, .L740+124
 8660 4b58 0400A0E3 		mov	r0, #4
 8661 4b5c FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8662              		.loc 1 2062 0
 8663 4b60 FA0FA0E3 		mov	r0, #1000
 8664 4b64 FEFFFFEB 		bl	_tx_thread_sleep
 8665 4b68 F9FFFFEA 		b	.L651
 8666              	.LVL772:
 8667              	.L723:
 8668              	.LBE246:
 8669              	.LBE245:
2764:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 8670              		.loc 1 2764 0
 8671 4b6c 0400A0E3 		mov	r0, #4
 8672              	.LVL773:
 8673 4b70 58149FE5 		ldr	r1, .L740+188
 8674 4b74 FEFFFFEB 		bl	CyU3PDebugPrint
 8675              	.LVL774:
 8676              	.L649:
 8677              	.LBB247:
 8678              	.LBB248:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8679              		.loc 1 2061 0
 8680 4b78 10149FE5 		ldr	r1, .L740+124
 8681 4b7c 0400A0E3 		mov	r0, #4
 8682 4b80 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8683              		.loc 1 2062 0
 8684 4b84 FA0FA0E3 		mov	r0, #1000
 8685 4b88 FEFFFFEB 		bl	_tx_thread_sleep
 8686 4b8c F9FFFFEA 		b	.L649
 8687              	.LVL775:
 8688              	.L722:
 8689              	.LBE248:
 8690              	.LBE247:
2743:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 8691              		.loc 1 2743 0
 8692 4b90 0400A0E3 		mov	r0, #4
 8693              	.LVL776:
 8694 4b94 38149FE5 		ldr	r1, .L740+192
 8695 4b98 FEFFFFEB 		bl	CyU3PDebugPrint
 8696              	.LVL777:
 8697              	.L647:
 8698              	.LBB249:
 8699              	.LBB250:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8700              		.loc 1 2061 0
 8701 4b9c EC139FE5 		ldr	r1, .L740+124
 8702 4ba0 0400A0E3 		mov	r0, #4
 8703 4ba4 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8704              		.loc 1 2062 0
 8705 4ba8 FA0FA0E3 		mov	r0, #1000
 8706 4bac FEFFFFEB 		bl	_tx_thread_sleep
 8707 4bb0 F9FFFFEA 		b	.L647
 8708              	.LVL778:
 8709              	.L721:
 8710              	.LBE250:
 8711              	.LBE249:
2730:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 8712              		.loc 1 2730 0
 8713 4bb4 0400A0E3 		mov	r0, #4
 8714              	.LVL779:
 8715 4bb8 18149FE5 		ldr	r1, .L740+196
 8716 4bbc FEFFFFEB 		bl	CyU3PDebugPrint
 8717              	.LVL780:
 8718              	.L645:
 8719              	.LBB251:
 8720              	.LBB252:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8721              		.loc 1 2061 0
 8722 4bc0 C8139FE5 		ldr	r1, .L740+124
 8723 4bc4 0400A0E3 		mov	r0, #4
 8724 4bc8 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8725              		.loc 1 2062 0
 8726 4bcc FA0FA0E3 		mov	r0, #1000
 8727 4bd0 FEFFFFEB 		bl	_tx_thread_sleep
 8728 4bd4 F9FFFFEA 		b	.L645
 8729              	.LVL781:
 8730              	.L719:
 8731              	.LBE252:
 8732              	.LBE251:
2702:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 8733              		.loc 1 2702 0
 8734 4bd8 0400A0E3 		mov	r0, #4
 8735              	.LVL782:
 8736 4bdc F8139FE5 		ldr	r1, .L740+200
 8737 4be0 FEFFFFEB 		bl	CyU3PDebugPrint
 8738              	.LVL783:
 8739              	.L641:
 8740              	.LBB253:
 8741              	.LBB254:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8742              		.loc 1 2061 0
 8743 4be4 A4139FE5 		ldr	r1, .L740+124
 8744 4be8 0400A0E3 		mov	r0, #4
 8745 4bec FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8746              		.loc 1 2062 0
 8747 4bf0 FA0FA0E3 		mov	r0, #1000
 8748 4bf4 FEFFFFEB 		bl	_tx_thread_sleep
 8749 4bf8 F9FFFFEA 		b	.L641
 8750              	.LVL784:
 8751              	.L718:
 8752              	.LBE254:
 8753              	.LBE253:
2689:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 8754              		.loc 1 2689 0
 8755 4bfc 0400A0E3 		mov	r0, #4
 8756              	.LVL785:
 8757 4c00 D8139FE5 		ldr	r1, .L740+204
 8758 4c04 FEFFFFEB 		bl	CyU3PDebugPrint
 8759              	.LVL786:
 8760              	.L639:
 8761              	.LBB255:
 8762              	.LBB256:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8763              		.loc 1 2061 0
 8764 4c08 80139FE5 		ldr	r1, .L740+124
 8765 4c0c 0400A0E3 		mov	r0, #4
 8766 4c10 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8767              		.loc 1 2062 0
 8768 4c14 FA0FA0E3 		mov	r0, #1000
 8769 4c18 FEFFFFEB 		bl	_tx_thread_sleep
 8770 4c1c F9FFFFEA 		b	.L639
 8771              	.LVL787:
 8772              	.L720:
 8773              	.LBE256:
 8774              	.LBE255:
2716:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 8775              		.loc 1 2716 0
 8776 4c20 0400A0E3 		mov	r0, #4
 8777              	.LVL788:
 8778 4c24 B8139FE5 		ldr	r1, .L740+208
 8779 4c28 FEFFFFEB 		bl	CyU3PDebugPrint
 8780              	.LVL789:
 8781              	.L643:
 8782              	.LBB257:
 8783              	.LBB258:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8784              		.loc 1 2061 0
 8785 4c2c 5C139FE5 		ldr	r1, .L740+124
 8786 4c30 0400A0E3 		mov	r0, #4
 8787 4c34 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8788              		.loc 1 2062 0
 8789 4c38 FA0FA0E3 		mov	r0, #1000
 8790 4c3c FEFFFFEB 		bl	_tx_thread_sleep
 8791 4c40 F9FFFFEA 		b	.L643
 8792              	.LVL790:
 8793              	.L729:
 8794              	.LBE258:
 8795              	.LBE257:
 8796              	.LBE260:
 8797              	.LBE276:
3152:../uvc.c      ****             	debugData[0][0]++;
 8798              		.loc 1 3152 0
 8799 4c44 2820D5E5 		ldrb	r2, [r5, #40]	@ zero_extendqisi2
3153:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x82;
 8800              		.loc 1 3153 0
 8801 4c48 0330E0E1 		mvn	r3, r3
 8802 4c4c 7D1003E2 		and	r1, r3, #125
 8803 4c50 01E0E0E1 		mvn	lr, r1
3152:../uvc.c      ****             	debugData[0][0]++;
 8804              		.loc 1 3152 0
 8805 4c54 01C082E2 		add	ip, r2, #1
3157:../uvc.c      ****                 prodCount = 0;
 8806              		.loc 1 3157 0
 8807 4c58 B06CC5E1 		strh	r6, [r5, #192]	@ movhi
3172:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 8808              		.loc 1 3172 0
 8809 4c5c 10039FE5 		ldr	r0, .L740+96
3158:../uvc.c      ****                 consCount = 0;
 8810              		.loc 1 3158 0
 8811 4c60 B26CC5E1 		strh	r6, [r5, #194]	@ movhi
3172:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 8812              		.loc 1 3172 0
 8813 4c64 0010E0E3 		mvn	r1, #0
3152:../uvc.c      ****             	debugData[0][0]++;
 8814              		.loc 1 3152 0
 8815 4c68 28C0C5E5 		strb	ip, [r5, #40]
3153:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x82;
 8816              		.loc 1 3153 0
 8817 4c6c 29E0C5E5 		strb	lr, [r5, #41]
3154:../uvc.c      ****             	fb=0;
 8818              		.loc 1 3154 0
 8819 4c70 B46BC5E1 		strh	r6, [r5, #180]	@ movhi
3155:../uvc.c      ****             	pb=0;
 8820              		.loc 1 3155 0
 8821 4c74 B66BC5E1 		strh	r6, [r5, #182]	@ movhi
3156:../uvc.c      ****             	pbc=0;
 8822              		.loc 1 3156 0
 8823 4c78 B86BC5E1 		strh	r6, [r5, #184]	@ movhi
3159:../uvc.c      ****                 hitFV     = CyFalse;
 8824              		.loc 1 3159 0
 8825 4c7c BC6085E5 		str	r6, [r5, #188]
3172:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 8826              		.loc 1 3172 0
 8827 4c80 FEFFFFEB 		bl	_txe_mutex_get
3173:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 8828              		.loc 1 3173 0
 8829 4c84 81A4D7E5 		ldrb	sl, [r7, #1153]	@ zero_extendqisi2
 8830 4c88 01002AE2 		eor	r0, sl, #1
 8831 4c8c 8104C7E5 		strb	r0, [r7, #1153]
3175:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 8832              		.loc 1 3175 0
 8833 4c90 BA30D5E5 		ldrb	r3, [r5, #186]	@ zero_extendqisi2
 8834 4c94 F00053E3 		cmp	r3, #240
 8835 4c98 1800000A 		beq	.L735
 8836              	.L666:
3183:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
 8837              		.loc 1 3183 0
 8838 4c9c BA00D4E5 		ldrb	r0, [r4, #186]	@ zero_extendqisi2
 8839 4ca0 FF0050E3 		cmp	r0, #255
 8840 4ca4 4000000A 		beq	.L736
3195:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
 8841              		.loc 1 3195 0
 8842 4ca8 BA30D5E5 		ldrb	r3, [r5, #186]	@ zero_extendqisi2
 8843 4cac AA0053E3 		cmp	r3, #170
 8844 4cb0 2F00000A 		beq	.L737
 8845              	.L667:
3233:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
 8846              		.loc 1 3233 0
 8847 4cb4 B8029FE5 		ldr	r0, .L740+96
 8848 4cb8 FEFFFFEB 		bl	_txe_mutex_put
3235:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 8849              		.loc 1 3235 0
 8850 4cbc C0029FE5 		ldr	r0, .L740+112
 8851 4cc0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 8852              	.LVL791:
3236:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 8853              		.loc 1 3236 0
 8854 4cc4 002050E2 		subs	r2, r0, #0
 8855 4cc8 2000001A 		bne	.L738
3243:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 8856              		.loc 1 3243 0
 8857 4ccc 0210A0E1 		mov	r1, r2
 8858 4cd0 AC029FE5 		ldr	r0, .L740+112
 8859              	.LVL792:
 8860 4cd4 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 8861              	.LVL793:
3244:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 8862              		.loc 1 3244 0
 8863 4cd8 002050E2 		subs	r2, r0, #0
 8864 4cdc 1200001A 		bne	.L739
3252:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 8865              		.loc 1 3252 0
 8866 4ce0 90029FE5 		ldr	r0, .L740+100
 8867              	.LVL794:
 8868 4ce4 0210A0E1 		mov	r1, r2
 8869 4ce8 02A0A0E3 		mov	sl, #2
 8870 4cec 0020A0E1 		mov	r2, r0
 8871              	.LVL795:
 8872 4cf0 0130A0E1 		mov	r3, r1
 8873 4cf4 00A08DE5 		str	sl, [sp, #0]
 8874 4cf8 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 8875              	.LVL796:
 8876 4cfc B5FEFFEA 		b	.L665
 8877              	.L735:
3175:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 8878              		.loc 1 3175 0 discriminator 1
 8879 4d00 20029FE5 		ldr	r0, .L740+20
 8880 4d04 8010A0E3 		mov	r1, #128
 8881 4d08 0320A0E3 		mov	r2, #3
 8882 4d0c B4308DE2 		add	r3, sp, #180
 8883 4d10 00608DE5 		str	r6, [sp, #0]
 8884 4d14 FEFFFFEB 		bl	_txe_event_flags_get
 8885 4d18 000050E3 		cmp	r0, #0
3180:../uvc.c      ****                 		stiflag = 0xFF;
 8886              		.loc 1 3180 0 discriminator 1
 8887 4d1c BA80C505 		streqb	r8, [r5, #186]
3181:../uvc.c      ****                 		IMcount = 0;
 8888              		.loc 1 3181 0 discriminator 1
 8889 4d20 A161C505 		streqb	r6, [r5, #417]
3175:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 8890              		.loc 1 3175 0 discriminator 1
 8891 4d24 E2FFFF0A 		beq	.L667
 8892 4d28 DBFFFFEA 		b	.L666
 8893              	.LVL797:
 8894              	.L739:
3246:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 8895              		.loc 1 3246 0
 8896 4d2c 0400A0E3 		mov	r0, #4
 8897              	.LVL798:
 8898 4d30 B0129FE5 		ldr	r1, .L740+212
 8899 4d34 FEFFFFEB 		bl	CyU3PDebugPrint
 8900              	.LVL799:
 8901              	.L686:
 8902              	.LBB277:
 8903              	.LBB278:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8904              		.loc 1 2061 0
 8905 4d38 50129FE5 		ldr	r1, .L740+124
 8906 4d3c 0400A0E3 		mov	r0, #4
 8907 4d40 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8908              		.loc 1 2062 0
 8909 4d44 FA0FA0E3 		mov	r0, #1000
 8910 4d48 FEFFFFEB 		bl	_tx_thread_sleep
 8911 4d4c F9FFFFEA 		b	.L686
 8912              	.LVL800:
 8913              	.L738:
 8914              	.LBE278:
 8915              	.LBE277:
3238:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 8916              		.loc 1 3238 0
 8917 4d50 0400A0E3 		mov	r0, #4
 8918              	.LVL801:
 8919 4d54 90129FE5 		ldr	r1, .L740+216
 8920 4d58 FEFFFFEB 		bl	CyU3PDebugPrint
 8921              	.LVL802:
 8922              	.L684:
 8923              	.LBB279:
 8924              	.LBB280:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8925              		.loc 1 2061 0
 8926 4d5c 2C129FE5 		ldr	r1, .L740+124
 8927 4d60 0400A0E3 		mov	r0, #4
 8928 4d64 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8929              		.loc 1 2062 0
 8930 4d68 FA0FA0E3 		mov	r0, #1000
 8931 4d6c FEFFFFEB 		bl	_tx_thread_sleep
 8932 4d70 F9FFFFEA 		b	.L684
 8933              	.L737:
 8934              	.LBE280:
 8935              	.LBE279:
3201:../uvc.c      ****                 	if(IMcount++ >= 0x3)
 8936              		.loc 1 3201 0
 8937 4d74 A1A1D5E5 		ldrb	sl, [r5, #417]	@ zero_extendqisi2
 8938 4d78 01008AE2 		add	r0, sl, #1
 8939 4d7c 02005AE3 		cmp	sl, #2
 8940 4d80 A101C5E5 		strb	r0, [r5, #417]
 8941 4d84 CAFFFF9A 		bls	.L667
3203:../uvc.c      ****                     switch (setRes)
 8942              		.loc 1 3203 0
 8943 4d88 7DC1D5E5 		ldrb	ip, [r5, #381]	@ zero_extendqisi2
 8944 4d8c 01E04CE2 		sub	lr, ip, #1
 8945 4d90 03005EE3 		cmp	lr, #3
 8946 4d94 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 8947 4d98 230000EA 		b	.L669
 8948              	.L674:
 8949 4d9c 8C4E0000 		.word	.L670
 8950 4da0 D04E0000 		.word	.L671
 8951 4da4 384E0000 		.word	.L672
 8952 4da8 DC4D0000 		.word	.L673
 8953              	.L736:
3185:../uvc.c      ****                  		if(IMcount++ >= 0x3){
 8954              		.loc 1 3185 0
 8955 4dac A1E1D5E5 		ldrb	lr, [r5, #417]	@ zero_extendqisi2
 8956 4db0 01A08EE2 		add	sl, lr, #1
 8957 4db4 02005EE3 		cmp	lr, #2
 8958 4db8 A1A1C5E5 		strb	sl, [r5, #417]
 8959 4dbc BCFFFF9A 		bls	.L667
3186:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 8960              		.loc 1 3186 0
 8961 4dc0 8124D7E5 		ldrb	r2, [r7, #1153]	@ zero_extendqisi2
3187:../uvc.c      ****                 		stiflag = 0x0F;
 8962              		.loc 1 3187 0
 8963 4dc4 0FC0A0E3 		mov	ip, #15
3186:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 8964              		.loc 1 3186 0
 8965 4dc8 201082E3 		orr	r1, r2, #32
 8966 4dcc 8114C7E5 		strb	r1, [r7, #1153]
3188:../uvc.c      ****                 		IMcount = 0;
 8967              		.loc 1 3188 0
 8968 4dd0 A161C5E5 		strb	r6, [r5, #417]
3187:../uvc.c      ****                 		stiflag = 0x0F;
 8969              		.loc 1 3187 0
 8970 4dd4 BAC0C5E5 		strb	ip, [r5, #186]
 8971 4dd8 B5FFFFEA 		b	.L667
 8972              	.L673:
3221:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
 8973              		.loc 1 3221 0
 8974 4ddc D8E094E5 		ldr	lr, [r4, #216]
 8975 4de0 8D24D7E5 		ldrb	r2, [r7, #1165]	@ zero_extendqisi2
 8976 4de4 00005EE3 		cmp	lr, #0
 8977 4de8 F4E0A003 		moveq	lr, #244
 8978 4dec 74E0A013 		movne	lr, #116
 8979 4df0 3010A0E3 		mov	r1, #48
 8980 4df4 02208EE1 		orr	r2, lr, r2
 8981 4df8 5230A0E3 		mov	r3, #82
 8982 4dfc 0100A0E3 		mov	r0, #1
 8983 4e00 FEFFFFEB 		bl	SensorSetIrisControl
3223:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
 8984              		.loc 1 3223 0
 8985 4e04 D8C094E5 		ldr	ip, [r4, #216]
 8986 4e08 8DA4D7E5 		ldrb	sl, [r7, #1165]	@ zero_extendqisi2
 8987 4e0c 00005CE3 		cmp	ip, #0
 8988 4e10 F4C0A003 		moveq	ip, #244
 8989 4e14 74C0A013 		movne	ip, #116
 8990 4e18 D83094E5 		ldr	r3, [r4, #216]
 8991 4e1c 0400A0E3 		mov	r0, #4
 8992 4e20 C8119FE5 		ldr	r1, .L740+220
 8993 4e24 0A208CE1 		orr	r2, ip, sl
 8994 4e28 FEFFFFEB 		bl	CyU3PDebugPrint
 8995              	.L669:
3228:../uvc.c      ****                     IMcount = 0;
 8996              		.loc 1 3228 0
 8997 4e2c A161C4E5 		strb	r6, [r4, #417]
3230:../uvc.c      ****                 	stiflag = 0x0;
 8998              		.loc 1 3230 0
 8999 4e30 BA60C4E5 		strb	r6, [r4, #186]
 9000 4e34 9EFFFFEA 		b	.L667
 9001              	.L672:
3216:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
 9002              		.loc 1 3216 0
 9003 4e38 D81094E5 		ldr	r1, [r4, #216]
 9004 4e3c 8D34D7E5 		ldrb	r3, [r7, #1165]	@ zero_extendqisi2
 9005 4e40 000051E3 		cmp	r1, #0
 9006 4e44 C410A003 		moveq	r1, #196
 9007 4e48 4410A013 		movne	r1, #68
 9008 4e4c 032081E1 		orr	r2, r1, r3
 9009 4e50 0100A0E3 		mov	r0, #1
 9010 4e54 3010A0E3 		mov	r1, #48
 9011 4e58 5230A0E3 		mov	r3, #82
 9012 4e5c FEFFFFEB 		bl	SensorSetIrisControl
3218:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
 9013              		.loc 1 3218 0
 9014 4e60 D80094E5 		ldr	r0, [r4, #216]
 9015 4e64 8D24D7E5 		ldrb	r2, [r7, #1165]	@ zero_extendqisi2
 9016 4e68 000050E3 		cmp	r0, #0
 9017 4e6c C400A003 		moveq	r0, #196
 9018 4e70 4400A013 		movne	r0, #68
 9019 4e74 022080E1 		orr	r2, r0, r2
 9020 4e78 D83094E5 		ldr	r3, [r4, #216]
 9021 4e7c 6C119FE5 		ldr	r1, .L740+220
 9022 4e80 0400A0E3 		mov	r0, #4
 9023 4e84 FEFFFFEB 		bl	CyU3PDebugPrint
3219:../uvc.c      ****                  		break;
 9024              		.loc 1 3219 0
 9025 4e88 E7FFFFEA 		b	.L669
 9026              	.L670:
3206:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
 9027              		.loc 1 3206 0
 9028 4e8c D82094E5 		ldr	r2, [r4, #216]
 9029 4e90 3010A0E3 		mov	r1, #48
 9030 4e94 000052E3 		cmp	r2, #0
 9031 4e98 E420A003 		moveq	r2, #228
 9032 4e9c 6420A013 		movne	r2, #100
 9033 4ea0 5230A0E3 		mov	r3, #82
 9034 4ea4 0100A0E3 		mov	r0, #1
 9035 4ea8 FEFFFFEB 		bl	SensorSetIrisControl
3208:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
 9036              		.loc 1 3208 0
 9037 4eac D82094E5 		ldr	r2, [r4, #216]
 9038 4eb0 38119FE5 		ldr	r1, .L740+220
 9039 4eb4 000052E3 		cmp	r2, #0
 9040 4eb8 D83094E5 		ldr	r3, [r4, #216]
 9041 4ebc E420A003 		moveq	r2, #228
 9042 4ec0 6420A013 		movne	r2, #100
 9043 4ec4 0400A0E3 		mov	r0, #4
 9044 4ec8 FEFFFFEB 		bl	CyU3PDebugPrint
3209:../uvc.c      ****                  		break;
 9045              		.loc 1 3209 0
 9046 4ecc D6FFFFEA 		b	.L669
 9047              	.L671:
3211:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
 9048              		.loc 1 3211 0
 9049 4ed0 D82094E5 		ldr	r2, [r4, #216]
 9050 4ed4 3010A0E3 		mov	r1, #48
 9051 4ed8 000052E3 		cmp	r2, #0
 9052 4edc D420A003 		moveq	r2, #212
 9053 4ee0 5420A013 		movne	r2, #84
 9054 4ee4 5230A0E3 		mov	r3, #82
 9055 4ee8 0100A0E3 		mov	r0, #1
 9056 4eec FEFFFFEB 		bl	SensorSetIrisControl
3213:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
 9057              		.loc 1 3213 0
 9058 4ef0 D82094E5 		ldr	r2, [r4, #216]
 9059 4ef4 F4109FE5 		ldr	r1, .L740+220
 9060 4ef8 000052E3 		cmp	r2, #0
 9061 4efc D83094E5 		ldr	r3, [r4, #216]
 9062 4f00 D420A003 		moveq	r2, #212
 9063 4f04 5420A013 		movne	r2, #84
 9064 4f08 0400A0E3 		mov	r0, #4
 9065 4f0c FEFFFFEB 		bl	CyU3PDebugPrint
3214:../uvc.c      ****                  		break;
 9066              		.loc 1 3214 0
 9067 4f10 C5FFFFEA 		b	.L669
 9068              	.L741:
 9069              		.align	2
 9070              	.L740:
 9071 4f14 78080000 		.word	.LC49
 9072 4f18 00C20100 		.word	115200
 9073 4f1c 98080000 		.word	.LC50
 9074 4f20 A0860100 		.word	100000
 9075 4f24 B4080000 		.word	.LC51
 9076 4f28 00000000 		.word	.LANCHOR0
 9077 4f2c 00000000 		.word	CyFxGpifCB
 9078 4f30 88130000 		.word	5000
 9079 4f34 00000000 		.word	CyFxUVCApplnUSBSetupCB
 9080 4f38 00000000 		.word	CyFxUVCApplnUSBEventCB
 9081 4f3c 00000000 		.word	CyFxUSBDeviceDscr
 9082 4f40 00000000 		.word	CyFxUSBDeviceDscrSS
 9083 4f44 00000000 		.word	CyFxUSBDeviceQualDscr
 9084 4f48 00000000 		.word	CyFxUSBBOSDscr
 9085 4f4c 00000000 		.word	CyFxUSBHSConfigDscr
 9086 4f50 00000000 		.word	CyFxUSBFSConfigDscr
 9087 4f54 00000000 		.word	CyFxUSBSSConfigDscr
 9088 4f58 00000000 		.word	CyFxUSBStringLangIDDscr
 9089 4f5c 00000000 		.word	CyFxUSBManufactureDscr
 9090 4f60 00000000 		.word	CyFxUSBProductDscr
 9091 4f64 013F0000 		.word	16129
 9092 4f68 02030000 		.word	770
 9093 4f6c 00000000 		.word	glChHandleInterStat
 9094 4f70 00000000 		.word	glInterStaBuffer
 9095 4f74 00000000 		.word	imgHdMux
 9096 4f78 01010000 		.word	257
 9097 4f7c 03030000 		.word	771
 9098 4f80 00000000 		.word	CyFxUvcApplnDmaCallback
 9099 4f84 00000000 		.word	glChHandleUVCStream
 9100 4f88 00000000 		.word	.LANCHOR1
 9101 4f8c D0080000 		.word	.LC52
 9102 4f90 4C020000 		.word	.LC14
 9103 4f94 20090000 		.word	.LC54
 9104 4f98 FC080000 		.word	.LC53
 9105 4f9c 48090000 		.word	.LC55
 9106 4fa0 A00A0000 		.word	.LC62
 9107 4fa4 7C0B0000 		.word	.LC66
 9108 4fa8 4C0B0000 		.word	.LC65
 9109 4fac 140B0000 		.word	.LC64
 9110 4fb0 D40A0000 		.word	.LC63
 9111 4fb4 6C0C0000 		.word	.LC72
 9112 4fb8 3C000000 		.word	.LANCHOR2+60
 9113 4fbc B40C0000 		.word	.LC74
 9114 4fc0 5C0C0000 		.word	.LC71
 9115 4fc4 20000000 		.word	.LANCHOR2+32
 9116 4fc8 7C0C0000 		.word	.LC73
 9117 4fcc 280C0000 		.word	.LC70
 9118 4fd0 700A0000 		.word	.LC61
 9119 4fd4 400A0000 		.word	.LC60
 9120 4fd8 080A0000 		.word	.LC59
 9121 4fdc A0090000 		.word	.LC57
 9122 4fe0 74090000 		.word	.LC56
 9123 4fe4 D4090000 		.word	.LC58
 9124 4fe8 F40B0000 		.word	.LC69
 9125 4fec C80B0000 		.word	.LC68
 9126 4ff0 A40B0000 		.word	.LC67
 9127              		.cfi_endproc
 9128              	.LFE19:
 9130              		.align	2
 9131              		.global	CyFxApplicationDefine
 9133              	CyFxApplicationDefine:
 9134              	.LFB27:
4736:../uvc.c      **** }
4737:../uvc.c      **** 
4738:../uvc.c      **** 
4739:../uvc.c      **** /*
4740:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
4741:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
4742:../uvc.c      ****  */
4743:../uvc.c      **** void
4744:../uvc.c      **** CyFxApplicationDefine (
4745:../uvc.c      ****         void)
4746:../uvc.c      **** {
 9135              		.loc 1 4746 0
 9136              		.cfi_startproc
 9137              		@ args = 0, pretend = 0, frame = 32
 9138              		@ frame_needed = 0, uses_anonymous_args = 0
 9139              	.LVL803:
 9140 4ff4 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 9141              	.LCFI28:
 9142              		.cfi_def_cfa_offset 32
4747:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
4748:../uvc.c      ****     uint32_t retThrdCreate;
4749:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4750:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4751:../uvc.c      **** 
4752:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
4753:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 9143              		.loc 1 4753 0
 9144 4ff8 010AA0E3 		mov	r0, #4096
4746:../uvc.c      **** {
 9145              		.loc 1 4746 0
 9146 4ffc 40D04DE2 		sub	sp, sp, #64
 9147              	.LCFI29:
 9148              		.cfi_def_cfa_offset 96
 9149              		.loc 1 4753 0
 9150              		.cfi_offset 14, -4
 9151              		.cfi_offset 10, -8
 9152              		.cfi_offset 9, -12
 9153              		.cfi_offset 8, -16
 9154              		.cfi_offset 7, -20
 9155              		.cfi_offset 6, -24
 9156              		.cfi_offset 5, -28
 9157              		.cfi_offset 4, -32
 9158 5000 FEFFFFEB 		bl	CyU3PMemAlloc
 9159 5004 0080A0E1 		mov	r8, r0
 9160              	.LVL804:
4754:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 9161              		.loc 1 4754 0
 9162 5008 010AA0E3 		mov	r0, #4096
 9163              	.LVL805:
 9164 500c FEFFFFEB 		bl	CyU3PMemAlloc
 9165 5010 00A0A0E1 		mov	sl, r0
 9166              	.LVL806:
4755:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 9167              		.loc 1 4755 0
 9168 5014 010AA0E3 		mov	r0, #4096
 9169              	.LVL807:
 9170 5018 FEFFFFEB 		bl	CyU3PMemAlloc
4756:../uvc.c      **** 
4757:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 9171              		.loc 1 4757 0
 9172 501c 000058E3 		cmp	r8, #0
 9173 5020 00005A13 		cmpne	sl, #0
 9174 5024 0070A013 		movne	r7, #0
 9175 5028 0170A003 		moveq	r7, #1
4755:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 9176              		.loc 1 4755 0
 9177 502c 0090A0E1 		mov	r9, r0
 9178              	.LVL808:
 9179              		.loc 1 4757 0
 9180 5030 0000001A 		bne	.L746
 9181              	.LVL809:
 9182              	.L743:
 9183              	.L745:
 9184 5034 FEFFFFEA 		b	.L745
 9185              	.L746:
 9186              		.loc 1 4757 0 is_stmt 0 discriminator 1
 9187 5038 000050E3 		cmp	r0, #0
 9188 503c FCFFFF0A 		beq	.L743
 9189              	.LVL810:
4758:../uvc.c      ****         goto fatalErrorHandler;
4759:../uvc.c      **** 
4760:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
4761:../uvc.c      ****     char *cmdName = "I2CcmdQue";
4762:../uvc.c      ****     char *staName = "I2CstaQue";
4763:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 9190              		.loc 1 4763 0 is_stmt 1
 9191 5040 04619FE5 		ldr	r6, .L747
 9192 5044 20408DE2 		add	r4, sp, #32
 9193 5048 0400A0E1 		mov	r0, r4
 9194 504c 4010A0E3 		mov	r1, #64
 9195 5050 F8209FE5 		ldr	r2, .L747+4
 9196 5054 0730A0E1 		mov	r3, r7
 9197 5058 00608DE5 		str	r6, [sp, #0]
 9198 505c FEFFFFEB 		bl	cmdbufCreate
 9199 5060 04E0A0E1 		mov	lr, r4
 9200 5064 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 9201 5068 E4C09FE5 		ldr	ip, .L747+8
4764:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
4765:../uvc.c      **** 	//VdRingBuf  cmdbufCreate(uint16_t size, char * name, uint8_t id, CyU3PMutex *muxPtr);
4766:../uvc.c      **** 
4767:../uvc.c      **** 	/****** initialize command descriptor ***********/
4768:../uvc.c      **** 	cmdquInit(cmdQuptr);
4769:../uvc.c      **** 	cmdquInit(statQuptr);
4770:../uvc.c      **** 
4771:../uvc.c      ****     /* Create the UVC application thread. */
4772:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 9202              		.loc 1 4772 0
 9203 506c 0840A0E3 		mov	r4, #8
4763:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 9204              		.loc 1 4763 0
 9205 5070 0C50A0E1 		mov	r5, ip
 9206 5074 0F00A5E8 		stmia	r5!, {r0, r1, r2, r3}
 9207 5078 0F009EE8 		ldmia	lr, {r0, r1, r2, r3}
 9208              		.loc 1 4772 0
 9209 507c 0160A0E3 		mov	r6, #1
4763:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 9210              		.loc 1 4763 0
 9211 5080 0F0085E8 		stmia	r5, {r0, r1, r2, r3}
4768:../uvc.c      **** 	cmdquInit(cmdQuptr);
 9212              		.loc 1 4768 0
 9213 5084 0C00A0E1 		mov	r0, ip
 9214 5088 FEFFFFEB 		bl	cmdquInit
4769:../uvc.c      **** 	cmdquInit(statQuptr);
 9215              		.loc 1 4769 0
 9216 508c C4009FE5 		ldr	r0, .L747+12
 9217 5090 FEFFFFEB 		bl	cmdquInit
 9218              		.loc 1 4772 0
 9219 5094 A850A0E3 		mov	r5, #168
 9220 5098 01CAA0E3 		mov	ip, #4096
 9221 509c B8009FE5 		ldr	r0, .L747+16
 9222 50a0 B8109FE5 		ldr	r1, .L747+20
 9223 50a4 B8209FE5 		ldr	r2, .L747+24
 9224 50a8 0730A0E1 		mov	r3, r7
 9225 50ac 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 9226 50b0 08408DE5 		str	r4, [sp, #8]
 9227 50b4 0C408DE5 		str	r4, [sp, #12]
 9228 50b8 10708DE5 		str	r7, [sp, #16]
 9229 50bc 14608DE5 		str	r6, [sp, #20]
 9230 50c0 18508DE5 		str	r5, [sp, #24]
 9231 50c4 FEFFFFEB 		bl	_txe_thread_create
 9232              	.LVL811:
4773:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
4774:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
4775:../uvc.c      ****             0,                                          /* No input parameter to thread */
4776:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
4777:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
4778:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4779:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
4780:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4781:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4782:../uvc.c      ****             );
4783:../uvc.c      ****     if (retThrdCreate != 0)
 9233              		.loc 1 4783 0
 9234 50c8 00C050E2 		subs	ip, r0, #0
 9235 50cc D8FFFF1A 		bne	.L743
4784:../uvc.c      ****     {
4785:../uvc.c      ****         goto fatalErrorHandler;
4786:../uvc.c      ****     }
4787:../uvc.c      **** 
4788:../uvc.c      ****     /* Create the control request handling thread. */
4789:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 9236              		.loc 1 4789 0
 9237 50d0 0C30A0E1 		mov	r3, ip
 9238 50d4 027BA0E3 		mov	r7, #2048
 9239 50d8 88009FE5 		ldr	r0, .L747+28
 9240              	.LVL812:
 9241 50dc 88109FE5 		ldr	r1, .L747+32
 9242 50e0 88209FE5 		ldr	r2, .L747+36
 9243 50e4 10C08DE5 		str	ip, [sp, #16]
 9244 50e8 00A08DE5 		str	sl, [sp, #0]
 9245 50ec 04708DE5 		str	r7, [sp, #4]
 9246 50f0 08408DE5 		str	r4, [sp, #8]
 9247 50f4 0C408DE5 		str	r4, [sp, #12]
 9248 50f8 14608DE5 		str	r6, [sp, #20]
 9249 50fc 18508DE5 		str	r5, [sp, #24]
 9250 5100 FEFFFFEB 		bl	_txe_thread_create
 9251              	.LVL813:
4790:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
4791:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
4792:../uvc.c      ****             0,                                                  /* No input parameter to thread */
4793:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
4794:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
4795:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
4796:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
4797:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
4798:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
4799:../uvc.c      ****             );
4800:../uvc.c      ****     if (retThrdCreate != 0)
 9252              		.loc 1 4800 0
 9253 5104 00C050E2 		subs	ip, r0, #0
 9254 5108 C9FFFF1A 		bne	.L743
4801:../uvc.c      ****     {
4802:../uvc.c      ****         goto fatalErrorHandler;
4803:../uvc.c      ****     }
4804:../uvc.c      **** #if 1
4805:../uvc.c      ****     /* Create the I2C control command handling thread. */
4806:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 9255              		.loc 1 4806 0
 9256 510c 60009FE5 		ldr	r0, .L747+40
 9257              	.LVL814:
 9258 5110 60109FE5 		ldr	r1, .L747+44
 9259 5114 60209FE5 		ldr	r2, .L747+48
 9260 5118 0C30A0E1 		mov	r3, ip
 9261 511c 00908DE5 		str	r9, [sp, #0]
 9262 5120 04708DE5 		str	r7, [sp, #4]
 9263 5124 08408DE5 		str	r4, [sp, #8]
 9264 5128 0C408DE5 		str	r4, [sp, #12]
 9265 512c 10C08DE5 		str	ip, [sp, #16]
 9266 5130 14608DE5 		str	r6, [sp, #20]
 9267 5134 18508DE5 		str	r5, [sp, #24]
 9268 5138 FEFFFFEB 		bl	_txe_thread_create
 9269              	.LVL815:
4807:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
4808:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
4809:../uvc.c      ****             0,                                          /* No input parameter to thread */
4810:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
4811:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
4812:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4813:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
4814:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4815:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4816:../uvc.c      ****             );
4817:../uvc.c      ****     if (retThrdCreate != 0)
 9270              		.loc 1 4817 0
 9271 513c 000050E3 		cmp	r0, #0
 9272 5140 BBFFFF1A 		bne	.L743
4818:../uvc.c      ****     {
4819:../uvc.c      ****         goto fatalErrorHandler;
4820:../uvc.c      ****     }
4821:../uvc.c      **** #endif
4822:../uvc.c      **** 
4823:../uvc.c      ****     return;
4824:../uvc.c      **** 
4825:../uvc.c      **** fatalErrorHandler:
4826:../uvc.c      ****     /* Add custom recovery or debug actions here */
4827:../uvc.c      ****     /* Loop indefinitely */
4828:../uvc.c      ****     while (1);
4829:../uvc.c      **** }
 9273              		.loc 1 4829 0
 9274 5144 40D08DE2 		add	sp, sp, #64
 9275 5148 F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 9276              	.L748:
 9277              		.align	2
 9278              	.L747:
 9279 514c 00000000 		.word	cmdQuMux
 9280 5150 EC0C0000 		.word	.LC75
 9281 5154 00000000 		.word	cmdQu
 9282 5158 00000000 		.word	statQu
 9283 515c A4010000 		.word	.LANCHOR0+420
 9284 5160 F80C0000 		.word	.LC76
 9285 5164 00000000 		.word	UVCAppThread_Entry
 9286 5168 4C020000 		.word	.LANCHOR0+588
 9287 516c 0C0D0000 		.word	.LC77
 9288 5170 00000000 		.word	UVCAppEP0Thread_Entry
 9289 5174 F4020000 		.word	.LANCHOR0+756
 9290 5178 240D0000 		.word	.LC78
 9291 517c 00000000 		.word	I2cAppThread_Entry
 9292              		.cfi_endproc
 9293              	.LFE27:
 9295              		.align	2
 9296              		.global	main
 9298              	main:
 9299              	.LFB28:
4830:../uvc.c      **** 
4831:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
4832:../uvc.c      ****  * the ThreadX RTOS here.
4833:../uvc.c      ****  */
4834:../uvc.c      **** int
4835:../uvc.c      **** main (
4836:../uvc.c      ****         void)
4837:../uvc.c      **** {
 9300              		.loc 1 4837 0
 9301              		.cfi_startproc
 9302              		@ args = 0, pretend = 0, frame = 56
 9303              		@ frame_needed = 0, uses_anonymous_args = 0
 9304 5180 30402DE9 		stmfd	sp!, {r4, r5, lr}
 9305              	.LCFI30:
 9306              		.cfi_def_cfa_offset 12
4838:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4839:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
4840:../uvc.c      **** 
4841:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
4842:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
4843:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
4844:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
4845:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
4846:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 9307              		.loc 1 4846 0
 9308 5184 0010A0E3 		mov	r1, #0
4837:../uvc.c      **** {
 9309              		.loc 1 4837 0
 9310 5188 3CD04DE2 		sub	sp, sp, #60
 9311              	.LCFI31:
 9312              		.cfi_def_cfa_offset 72
4843:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 9313              		.loc 1 4843 0
 9314 518c 0220A0E3 		mov	r2, #2
4847:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 9315              		.loc 1 4847 0
 9316 5190 033081E2 		add	r3, r1, #3
4842:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 9317              		.loc 1 4842 0
 9318 5194 0150A0E3 		mov	r5, #1
 9319              		.cfi_offset 14, -4
 9320              		.cfi_offset 5, -8
 9321              		.cfi_offset 4, -12
4848:../uvc.c      **** 
4849:../uvc.c      ****     /* Initialize the device */
4850:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 9322              		.loc 1 4850 0
 9323 5198 28008DE2 		add	r0, sp, #40
4842:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 9324              		.loc 1 4842 0
 9325 519c 28508DE5 		str	r5, [sp, #40]
4843:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 9326              		.loc 1 4843 0
 9327 51a0 2C20CDE5 		strb	r2, [sp, #44]
4844:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 9328              		.loc 1 4844 0
 9329 51a4 2D20CDE5 		strb	r2, [sp, #45]
4845:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 9330              		.loc 1 4845 0
 9331 51a8 2E20CDE5 		strb	r2, [sp, #46]
4846:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 9332              		.loc 1 4846 0
 9333 51ac 30108DE5 		str	r1, [sp, #48]
4847:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 9334              		.loc 1 4847 0
 9335 51b0 3430CDE5 		strb	r3, [sp, #52]
 9336              		.loc 1 4850 0
 9337 51b4 FEFFFFEB 		bl	CyU3PDeviceInit
 9338              	.LVL816:
4851:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9339              		.loc 1 4851 0
 9340 51b8 004050E2 		subs	r4, r0, #0
 9341 51bc 0000000A 		beq	.L752
 9342              	.L750:
 9343              	.L751:
 9344 51c0 FEFFFFEA 		b	.L751
 9345              	.L752:
4852:../uvc.c      ****     {
4853:../uvc.c      ****         goto handle_fatal_error;
4854:../uvc.c      ****     }
4855:../uvc.c      **** 
4856:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
4857:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 9346              		.loc 1 4857 0
 9347 51c4 0410A0E1 		mov	r1, r4
 9348 51c8 0420A0E1 		mov	r2, r4
 9349 51cc 0500A0E1 		mov	r0, r5
 9350              	.LVL817:
 9351 51d0 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 9352              	.LVL818:
4858:../uvc.c      **** 
4859:../uvc.c      ****     /* Configure the IO matrix for the device. */
4860:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
4861:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
4862:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
4863:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
4864:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
4865:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
4866:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
4867:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
4868:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
4869:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
4870:../uvc.c      **** 
4871:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 9353              		.loc 1 4871 0
 9354 51d4 0D00A0E1 		mov	r0, sp
4861:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 9355              		.loc 1 4861 0
 9356 51d8 1640CDE5 		strb	r4, [sp, #22]
4862:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 9357              		.loc 1 4862 0
 9358 51dc 18408DE5 		str	r4, [sp, #24]
4863:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 9359              		.loc 1 4863 0
 9360 51e0 1C408DE5 		str	r4, [sp, #28]
4864:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 9361              		.loc 1 4864 0
 9362 51e4 20408DE5 		str	r4, [sp, #32]
4865:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 9363              		.loc 1 4865 0
 9364 51e8 24408DE5 		str	r4, [sp, #36]
4868:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 9365              		.loc 1 4868 0
 9366 51ec 0C408DE5 		str	r4, [sp, #12]
4869:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 9367              		.loc 1 4869 0
 9368 51f0 10408DE5 		str	r4, [sp, #16]
4860:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 9369              		.loc 1 4860 0
 9370 51f4 00508DE5 		str	r5, [sp, #0]
4866:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 9371              		.loc 1 4866 0
 9372 51f8 04508DE5 		str	r5, [sp, #4]
4867:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 9373              		.loc 1 4867 0
 9374 51fc 08508DE5 		str	r5, [sp, #8]
 9375              		.loc 1 4871 0
 9376 5200 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 9377              	.LVL819:
4872:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9378              		.loc 1 4872 0
 9379 5204 004050E2 		subs	r4, r0, #0
 9380 5208 ECFFFF1A 		bne	.L750
4873:../uvc.c      ****     {
4874:../uvc.c      ****         goto handle_fatal_error;
4875:../uvc.c      ****     }
4876:../uvc.c      **** 
4877:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
4878:../uvc.c      ****     CyU3PKernelEntry ();
 9381              		.loc 1 4878 0
 9382 520c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 9383              	.LVL820:
4879:../uvc.c      **** 
4880:../uvc.c      ****     /* Dummy return to make the compiler happy */
4881:../uvc.c      ****     return 0;
4882:../uvc.c      **** 
4883:../uvc.c      **** handle_fatal_error:
4884:../uvc.c      ****     /* Cannot recover from this error. */
4885:../uvc.c      ****     while (1);
4886:../uvc.c      **** }
 9384              		.loc 1 4886 0
 9385 5210 0400A0E1 		mov	r0, r4
 9386 5214 3CD08DE2 		add	sp, sp, #60
 9387 5218 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 9388              		.cfi_endproc
 9389              	.LFE28:
 9391              		.global	CyFxGpifTransition
 9392              		.global	CyFxGpifWavedata
 9393              		.global	CyFxGpifWavedataPosition
 9394              		.global	CyFxGpifRegValue
 9395              		.global	CyFxGpifConfig
 9396              		.global	CyFxGpifTransition_usb2
 9397              		.global	CyFxGpifWavedata_usb2
 9398              		.global	CyFxGpifWavedataPosition_usb2
 9399              		.global	CyFxGpifRegValue_usb2
 9400              		.global	CyFxGpifConfig_usb2
 9401              		.global	snapButFlag
 9402              		.global	testSnap
 9403              		.global	fb
 9404              		.global	pb
 9405              		.global	pbc
 9406              		.global	fbbak
 9407              		.global	pbbak
 9408              		.global	pbcbak
 9409              		.global	pbcpbak
 9410              		.global	isUsbConnected
 9411              		.global	usbSpeed
 9412              		.global	clearFeatureRqtReceived
 9413              		.global	streamingRecove
 9414              		.global	streamingStarted
 9415              		.global	glProbeCtrl
 9416              		.global	glProbeCtrlFull
 9417              		.global	glProbeStilCtrl
 9418              		.global	glProbeCtrl20
 9419              		.global	glProbeStilCtrl20
 9420              		.global	glUVCHeader
 9421              		.comm	glChHandleUVCStream,220,4
 9422              		.comm	glChHandleStillStream,220,4
 9423              		.comm	glChHandleInterStat,160,4
 9424              		.comm	glInterStaBuffer,4,4
 9425              		.comm	cmdQu,32,4
 9426              		.comm	statQu,32,4
 9427              		.comm	cmdQuMux,56,4
 9428              		.comm	staQuMux,56,4
 9429              		.comm	timMux,56,4
 9430              		.comm	imgHdMux,56,4
 9431              		.comm	bmReqType,1,1
 9432              		.comm	bRequest,1,1
 9433              		.comm	wValue,2,2
 9434              		.comm	wIndex,2,2
 9435              		.comm	wLength,2,2
 9436              		.comm	posTick,4,4
 9437              		.comm	I2CCmdTimer,44,4
 9438              		.section	.rodata
 9439              		.align	2
 9440              		.set	.LANCHOR2,. + 0
 9443              	ShutSp:
 9444 0000 3582     		.short	-32203
 9445 0002 1B41     		.short	16667
 9446 0004 8D20     		.short	8333
 9447 0006 A00F     		.short	4000
 9448 0008 D007     		.short	2000
 9449 000a E803     		.short	1000
 9450 000c F401     		.short	500
 9451 000e C800     		.short	200
 9452 0010 6400     		.short	100
 9453 0012 0A00     		.short	10
 9454 0014 0000     		.short	0
 9455 0016 00000000 		.space	10
 9455      00000000 
 9455      0000
 9458              	CyFxGpifConfig:
 9459 0020 0F00     		.short	15
 9460 0022 0000     		.space	2
 9461 0024 00000000 		.word	CyFxGpifWavedata
 9462 0028 00000000 		.word	CyFxGpifWavedataPosition
 9463 002c 0500     		.short	5
 9464 002e 0000     		.space	2
 9465 0030 00000000 		.word	CyFxGpifTransition
 9466 0034 4C00     		.short	76
 9467 0036 0000     		.space	2
 9468 0038 00000000 		.word	CyFxGpifRegValue
 9471              	CyFxGpifConfig_usb2:
 9472 003c 9300     		.short	147
 9473 003e 0000     		.space	2
 9474 0040 00000000 		.word	CyFxGpifWavedata_usb2
 9475 0044 00000000 		.word	CyFxGpifWavedataPosition_usb2
 9476 0048 0800     		.short	8
 9477 004a 0000     		.space	2
 9478 004c 00000000 		.word	CyFxGpifTransition_usb2
 9479 0050 4C00     		.short	76
 9480 0052 0000     		.space	2
 9481 0054 00000000 		.word	CyFxGpifRegValue_usb2
 9482              		.data
 9483              		.align	2
 9484              		.set	.LANCHOR1,. + 0
 9487              	ExUCtrlParArry:
 9488 0000 00       		.byte	0
 9489 0001 00       		.byte	0
 9490 0002 04       		.byte	4
 9491 0003 01       		.byte	1
 9492 0004 00       		.byte	0
 9493 0005 38       		.byte	56
 9494 0006 01       		.byte	1
 9495 0007 01       		.byte	1
 9496 0008 00       		.byte	0
 9497 0009 03       		.byte	3
 9498 000a 00       		.byte	0
 9499 000b 4E       		.byte	78
 9500 000c 00       		.byte	0
 9501 000d 4E       		.byte	78
 9502 000e 00       		.byte	0
 9503 000f 30       		.byte	48
 9504 0010 01       		.byte	1
 9505 0011 00       		.byte	0
 9506 0012 00       		.byte	0
 9507 0013 00000000 		.space	5
 9507      00
 9508 0018 00       		.byte	0
 9509 0019 00       		.byte	0
 9510 001a 01       		.byte	1
 9511 001b 00       		.byte	0
 9512 001c 00       		.byte	0
 9513 001d 00       		.byte	0
 9514 001e 00       		.byte	0
 9515 001f 01       		.byte	1
 9516 0020 00       		.byte	0
 9517 0021 03       		.byte	3
 9518 0022 00       		.byte	0
 9519 0023 00       		.byte	0
 9520 0024 00       		.byte	0
 9521 0025 00       		.byte	0
 9522 0026 00       		.byte	0
 9523 0027 30       		.byte	48
 9524 0028 01       		.byte	1
 9525 0029 00       		.byte	0
 9526 002a 00       		.byte	0
 9527 002b 00000000 		.space	5
 9527      00
 9528 0030 00       		.byte	0
 9529 0031 00       		.byte	0
 9530 0032 02       		.byte	2
 9531 0033 00       		.byte	0
 9532 0034 00       		.byte	0
 9533 0035 FF       		.byte	-1
 9534 0036 00       		.byte	0
 9535 0037 01       		.byte	1
 9536 0038 00       		.byte	0
 9537 0039 03       		.byte	3
 9538 003a 00       		.byte	0
 9539 003b 01       		.byte	1
 9540 003c 00       		.byte	0
 9541 003d 00       		.byte	0
 9542 003e 00       		.byte	0
 9543 003f 30       		.byte	48
 9544 0040 01       		.byte	1
 9545 0041 01       		.byte	1
 9546 0042 00       		.byte	0
 9547 0043 00000000 		.space	5
 9547      00
 9548 0048 00       		.byte	0
 9549 0049 00       		.byte	0
 9550 004a 02       		.byte	2
 9551 004b 00       		.byte	0
 9552 004c 00       		.byte	0
 9553 004d 00       		.byte	0
 9554 004e 00       		.byte	0
 9555 004f 00       		.byte	0
 9556 0050 00       		.byte	0
 9557 0051 03       		.byte	3
 9558 0052 00       		.byte	0
 9559 0053 00       		.byte	0
 9560 0054 00       		.byte	0
 9561 0055 00       		.byte	0
 9562 0056 00       		.byte	0
 9563 0057 30       		.byte	48
 9564 0058 01       		.byte	1
 9565 0059 01       		.byte	1
 9566 005a 00       		.byte	0
 9567 005b 00000000 		.space	5
 9567      00
 9568 0060 13       		.byte	19
 9569 0061 14       		.byte	20
 9570 0062 02       		.byte	2
 9571 0063 00       		.byte	0
 9572 0064 00       		.byte	0
 9573 0065 FF       		.byte	-1
 9574 0066 FF       		.byte	-1
 9575 0067 01       		.byte	1
 9576 0068 00       		.byte	0
 9577 0069 03       		.byte	3
 9578 006a 00       		.byte	0
 9579 006b 66       		.byte	102
 9580 006c 66       		.byte	102
 9581 006d 66       		.byte	102
 9582 006e 66       		.byte	102
 9583 006f 30       		.byte	48
 9584 0070 01       		.byte	1
 9585 0071 00       		.byte	0
 9586 0072 00       		.byte	0
 9587 0073 00000000 		.space	5
 9587      00
 9588 0078 11       		.byte	17
 9589 0079 00       		.byte	0
 9590 007a 02       		.byte	2
 9591 007b 01       		.byte	1
 9592 007c 00       		.byte	0
 9593 007d 03       		.byte	3
 9594 007e 00       		.byte	0
 9595 007f 01       		.byte	1
 9596 0080 00       		.byte	0
 9597 0081 03       		.byte	3
 9598 0082 00       		.byte	0
 9599 0083 80       		.byte	-128
 9600 0084 00       		.byte	0
 9601 0085 80       		.byte	-128
 9602 0086 00       		.byte	0
 9603 0087 30       		.byte	48
 9604 0088 01       		.byte	1
 9605 0089 01       		.byte	1
 9606 008a 00       		.byte	0
 9607 008b 00000000 		.space	5
 9607      00
 9608 0090 10       		.byte	16
 9609 0091 00       		.byte	0
 9610 0092 01       		.byte	1
 9611 0093 01       		.byte	1
 9612 0094 00       		.byte	0
 9613 0095 02       		.byte	2
 9614 0096 00       		.byte	0
 9615 0097 01       		.byte	1
 9616 0098 00       		.byte	0
 9617 0099 03       		.byte	3
 9618 009a 00       		.byte	0
 9619 009b 00       		.byte	0
 9620 009c 00       		.byte	0
 9621 009d 00       		.byte	0
 9622 009e 00       		.byte	0
 9623 009f 30       		.byte	48
 9624 00a0 01       		.byte	1
 9625 00a1 01       		.byte	1
 9626 00a2 00       		.byte	0
 9627 00a3 00000000 		.space	5
 9627      00
 9628 00a8 00       		.byte	0
 9629 00a9 00       		.byte	0
 9630 00aa 04       		.byte	4
 9631 00ab 01       		.byte	1
 9632 00ac 00       		.byte	0
 9633 00ad 38       		.byte	56
 9634 00ae 01       		.byte	1
 9635 00af 01       		.byte	1
 9636 00b0 00       		.byte	0
 9637 00b1 03       		.byte	3
 9638 00b2 00       		.byte	0
 9639 00b3 4E       		.byte	78
 9640 00b4 00       		.byte	0
 9641 00b5 4E       		.byte	78
 9642 00b6 00       		.byte	0
 9643 00b7 30       		.byte	48
 9644 00b8 01       		.byte	1
 9645 00b9 00       		.byte	0
 9646 00ba 00       		.byte	0
 9647 00bb 00000000 		.space	5
 9647      00
 9648 00c0 00       		.byte	0
 9649 00c1 00       		.byte	0
 9650 00c2 01       		.byte	1
 9651 00c3 00       		.byte	0
 9652 00c4 00       		.byte	0
 9653 00c5 00       		.byte	0
 9654 00c6 00       		.byte	0
 9655 00c7 01       		.byte	1
 9656 00c8 00       		.byte	0
 9657 00c9 03       		.byte	3
 9658 00ca 00       		.byte	0
 9659 00cb 00       		.byte	0
 9660 00cc 00       		.byte	0
 9661 00cd 00       		.byte	0
 9662 00ce 00       		.byte	0
 9663 00cf 30       		.byte	48
 9664 00d0 01       		.byte	1
 9665 00d1 00       		.byte	0
 9666 00d2 00       		.byte	0
 9667 00d3 00000000 		.space	5
 9667      00
 9668 00d8 00       		.byte	0
 9669 00d9 00       		.byte	0
 9670 00da 02       		.byte	2
 9671 00db 00       		.byte	0
 9672 00dc 00       		.byte	0
 9673 00dd 05       		.byte	5
 9674 00de 00       		.byte	0
 9675 00df 01       		.byte	1
 9676 00e0 00       		.byte	0
 9677 00e1 03       		.byte	3
 9678 00e2 00       		.byte	0
 9679 00e3 00       		.byte	0
 9680 00e4 00       		.byte	0
 9681 00e5 00       		.byte	0
 9682 00e6 00       		.byte	0
 9683 00e7 30       		.byte	48
 9684 00e8 01       		.byte	1
 9685 00e9 00       		.byte	0
 9686 00ea 00       		.byte	0
 9687 00eb 00000000 		.space	5
 9687      00
 9688 00f0 00       		.byte	0
 9689 00f1 00       		.byte	0
 9690 00f2 03       		.byte	3
 9691 00f3 00       		.byte	0
 9692 00f4 00       		.byte	0
 9693 00f5 0A       		.byte	10
 9694 00f6 00       		.byte	0
 9695 00f7 01       		.byte	1
 9696 00f8 00       		.byte	0
 9697 00f9 03       		.byte	3
 9698 00fa 00       		.byte	0
 9699 00fb 00       		.byte	0
 9700 00fc 00       		.byte	0
 9701 00fd 00       		.byte	0
 9702 00fe 00       		.byte	0
 9703 00ff 30       		.byte	48
 9704 0100 01       		.byte	1
 9705 0101 00       		.byte	0
 9706 0102 00       		.byte	0
 9707 0103 00000000 		.space	5
 9707      00
 9708 0108 00       		.byte	0
 9709 0109 00       		.byte	0
 9710 010a 02       		.byte	2
 9711 010b 00       		.byte	0
 9712 010c 00       		.byte	0
 9713 010d 40       		.byte	64
 9714 010e 00       		.byte	0
 9715 010f 01       		.byte	1
 9716 0110 00       		.byte	0
 9717 0111 03       		.byte	3
 9718 0112 00       		.byte	0
 9719 0113 0F       		.byte	15
 9720 0114 11       		.byte	17
 9721 0115 00       		.byte	0
 9722 0116 00       		.byte	0
 9723 0117 30       		.byte	48
 9724 0118 01       		.byte	1
 9725 0119 00       		.byte	0
 9726 011a 00       		.byte	0
 9727 011b 00000000 		.space	5
 9727      00
 9728 0120 00       		.byte	0
 9729 0121 00       		.byte	0
 9730 0122 02       		.byte	2
 9731 0123 00       		.byte	0
 9732 0124 00       		.byte	0
 9733 0125 64       		.byte	100
 9734 0126 00       		.byte	0
 9735 0127 01       		.byte	1
 9736 0128 00       		.byte	0
 9737 0129 03       		.byte	3
 9738 012a 00       		.byte	0
 9739 012b 00       		.byte	0
 9740 012c 00       		.byte	0
 9741 012d 00       		.byte	0
 9742 012e 00       		.byte	0
 9743 012f 30       		.byte	48
 9744 0130 01       		.byte	1
 9745 0131 00       		.byte	0
 9746 0132 00       		.byte	0
 9747 0133 00000000 		.space	5
 9747      00
 9748 0138 00       		.byte	0
 9749 0139 00       		.byte	0
 9750 013a 02       		.byte	2
 9751 013b 00       		.byte	0
 9752 013c 00       		.byte	0
 9753 013d 64       		.byte	100
 9754 013e 00       		.byte	0
 9755 013f 01       		.byte	1
 9756 0140 00       		.byte	0
 9757 0141 03       		.byte	3
 9758 0142 00       		.byte	0
 9759 0143 00       		.byte	0
 9760 0144 00       		.byte	0
 9761 0145 00       		.byte	0
 9762 0146 00       		.byte	0
 9763 0147 30       		.byte	48
 9764 0148 01       		.byte	1
 9765 0149 00       		.byte	0
 9766 014a 00       		.byte	0
 9767 014b 00000000 		.space	5
 9767      00
 9768 0150 00       		.byte	0
 9769 0151 00       		.byte	0
 9770 0152 02       		.byte	2
 9771 0153 00       		.byte	0
 9772 0154 00       		.byte	0
 9773 0155 64       		.byte	100
 9774 0156 00       		.byte	0
 9775 0157 01       		.byte	1
 9776 0158 00       		.byte	0
 9777 0159 03       		.byte	3
 9778 015a 00       		.byte	0
 9779 015b 00       		.byte	0
 9780 015c 00       		.byte	0
 9781 015d 00       		.byte	0
 9782 015e 00       		.byte	0
 9783 015f 30       		.byte	48
 9784 0160 01       		.byte	1
 9785 0161 00       		.byte	0
 9786 0162 00       		.byte	0
 9787 0163 00000000 		.space	5
 9787      00
 9788 0168 00       		.byte	0
 9789 0169 00       		.byte	0
 9790 016a 02       		.byte	2
 9791 016b 00       		.byte	0
 9792 016c 00       		.byte	0
 9793 016d 64       		.byte	100
 9794 016e 00       		.byte	0
 9795 016f 01       		.byte	1
 9796 0170 00       		.byte	0
 9797 0171 03       		.byte	3
 9798 0172 00       		.byte	0
 9799 0173 00       		.byte	0
 9800 0174 00       		.byte	0
 9801 0175 00       		.byte	0
 9802 0176 00       		.byte	0
 9803 0177 30       		.byte	48
 9804 0178 01       		.byte	1
 9805 0179 00       		.byte	0
 9806 017a 00       		.byte	0
 9807 017b 00000000 		.space	5
 9807      00
 9810              	CtrlParArry:
 9811 0180 10       		.byte	16
 9812 0181 10       		.byte	16
 9813 0182 02       		.byte	2
 9814 0183 00       		.byte	0
 9815 0184 00       		.byte	0
 9816 0185 03       		.byte	3
 9817 0186 00       		.byte	0
 9818 0187 01       		.byte	1
 9819 0188 00       		.byte	0
 9820 0189 03       		.byte	3
 9821 018a 00       		.byte	0
 9822 018b 03       		.byte	3
 9823 018c 00       		.byte	0
 9824 018d 03       		.byte	3
 9825 018e 00       		.byte	0
 9826 018f 30       		.byte	48
 9827 0190 01       		.byte	1
 9828 0191 00       		.byte	0
 9829 0192 00       		.byte	0
 9830 0193 00000000 		.space	5
 9830      00
 9831 0198 15       		.byte	21
 9832 0199 15       		.byte	21
 9833 019a 02       		.byte	2
 9834 019b 00       		.byte	0
 9835 019c 00       		.byte	0
 9836 019d FF       		.byte	-1
 9837 019e 00       		.byte	0
 9838 019f 01       		.byte	1
 9839 01a0 00       		.byte	0
 9840 01a1 03       		.byte	3
 9841 01a2 00       		.byte	0
 9842 01a3 76       		.byte	118
 9843 01a4 00       		.byte	0
 9844 01a5 76       		.byte	118
 9845 01a6 C7       		.byte	-57
 9846 01a7 30       		.byte	48
 9847 01a8 01       		.byte	1
 9848 01a9 01       		.byte	1
 9849 01aa 00       		.byte	0
 9850 01ab 00000000 		.space	5
 9850      00
 9851 01b0 04       		.byte	4
 9852 01b1 04       		.byte	4
 9853 01b2 02       		.byte	2
 9854 01b3 00       		.byte	0
 9855 01b4 00       		.byte	0
 9856 01b5 FF       		.byte	-1
 9857 01b6 00       		.byte	0
 9858 01b7 01       		.byte	1
 9859 01b8 00       		.byte	0
 9860 01b9 03       		.byte	3
 9861 01ba 00       		.byte	0
 9862 01bb 70       		.byte	112
 9863 01bc 00       		.byte	0
 9864 01bd 70       		.byte	112
 9865 01be 00       		.byte	0
 9866 01bf 30       		.byte	48
 9867 01c0 01       		.byte	1
 9868 01c1 01       		.byte	1
 9869 01c2 00       		.byte	0
 9870 01c3 00000000 		.space	5
 9870      00
 9871 01c8 00       		.byte	0
 9872 01c9 00       		.byte	0
 9873 01ca 02       		.byte	2
 9874 01cb 00       		.byte	0
 9875 01cc 00       		.byte	0
 9876 01cd 64       		.byte	100
 9877 01ce 00       		.byte	0
 9878 01cf 01       		.byte	1
 9879 01d0 00       		.byte	0
 9880 01d1 03       		.byte	3
 9881 01d2 00       		.byte	0
 9882 01d3 00       		.byte	0
 9883 01d4 00       		.byte	0
 9884 01d5 00       		.byte	0
 9885 01d6 00       		.byte	0
 9886 01d7 30       		.byte	48
 9887 01d8 01       		.byte	1
 9888 01d9 00       		.byte	0
 9889 01da 00       		.byte	0
 9890 01db 00000000 		.space	5
 9890      00
 9891 01e0 07       		.byte	7
 9892 01e1 07       		.byte	7
 9893 01e2 02       		.byte	2
 9894 01e3 00       		.byte	0
 9895 01e4 00       		.byte	0
 9896 01e5 01       		.byte	1
 9897 01e6 00       		.byte	0
 9898 01e7 01       		.byte	1
 9899 01e8 00       		.byte	0
 9900 01e9 03       		.byte	3
 9901 01ea 00       		.byte	0
 9902 01eb 01       		.byte	1
 9903 01ec 00       		.byte	0
 9904 01ed 01       		.byte	1
 9905 01ee 00       		.byte	0
 9906 01ef 30       		.byte	48
 9907 01f0 01       		.byte	1
 9908 01f1 00       		.byte	0
 9909 01f2 00       		.byte	0
 9910 01f3 00000000 		.space	5
 9910      00
 9911 01f8 DF       		.byte	-33
 9912 01f9 E1       		.byte	-31
 9913 01fa 02       		.byte	2
 9914 01fb 00       		.byte	0
 9915 01fc 00       		.byte	0
 9916 01fd FF       		.byte	-1
 9917 01fe 00       		.byte	0
 9918 01ff 01       		.byte	1
 9919 0200 00       		.byte	0
 9920 0201 03       		.byte	3
 9921 0202 00       		.byte	0
 9922 0203 80       		.byte	-128
 9923 0204 00       		.byte	0
 9924 0205 00       		.byte	0
 9925 0206 00       		.byte	0
 9926 0207 C6       		.byte	-58
 9927 0208 01       		.byte	1
 9928 0209 01       		.byte	1
 9929 020a 00       		.byte	0
 9930 020b 00000000 		.space	5
 9930      00
 9931 0210 85       		.byte	-123
 9932 0211 86       		.byte	-122
 9933 0212 02       		.byte	2
 9934 0213 00       		.byte	0
 9935 0214 00       		.byte	0
 9936 0215 64       		.byte	100
 9937 0216 00       		.byte	0
 9938 0217 01       		.byte	1
 9939 0218 00       		.byte	0
 9940 0219 03       		.byte	3
 9941 021a 00       		.byte	0
 9942 021b 32       		.byte	50
 9943 021c 00       		.byte	0
 9944 021d 32       		.byte	50
 9945 021e 00       		.byte	0
 9946 021f F2       		.byte	-14
 9947 0220 01       		.byte	1
 9948 0221 01       		.byte	1
 9949 0222 00       		.byte	0
 9950 0223 00000000 		.space	5
 9950      00
 9951 0228 06       		.byte	6
 9952 0229 06       		.byte	6
 9953 022a 02       		.byte	2
 9954 022b 00       		.byte	0
 9955 022c 00       		.byte	0
 9956 022d FF       		.byte	-1
 9957 022e 00       		.byte	0
 9958 022f 01       		.byte	1
 9959 0230 00       		.byte	0
 9960 0231 03       		.byte	3
 9961 0232 00       		.byte	0
 9962 0233 20       		.byte	32
 9963 0234 00       		.byte	0
 9964 0235 20       		.byte	32
 9965 0236 00       		.byte	0
 9966 0237 30       		.byte	48
 9967 0238 01       		.byte	1
 9968 0239 01       		.byte	1
 9969 023a 00       		.byte	0
 9970 023b 00000000 		.space	5
 9970      00
 9971 0240 00       		.byte	0
 9972 0241 00       		.byte	0
 9973 0242 02       		.byte	2
 9974 0243 00       		.byte	0
 9975 0244 00       		.byte	0
 9976 0245 64       		.byte	100
 9977 0246 00       		.byte	0
 9978 0247 01       		.byte	1
 9979 0248 00       		.byte	0
 9980 0249 03       		.byte	3
 9981 024a 00       		.byte	0
 9982 024b 00       		.byte	0
 9983 024c 00       		.byte	0
 9984 024d 00       		.byte	0
 9985 024e 00       		.byte	0
 9986 024f 30       		.byte	48
 9987 0250 01       		.byte	1
 9988 0251 00       		.byte	0
 9989 0252 00       		.byte	0
 9990 0253 00000000 		.space	5
 9990      00
 9991 0258 08       		.byte	8
 9992 0259 08       		.byte	8
 9993 025a 02       		.byte	2
 9994 025b 00       		.byte	0
 9995 025c 00       		.byte	0
 9996 025d 05       		.byte	5
 9997 025e 00       		.byte	0
 9998 025f 01       		.byte	1
 9999 0260 00       		.byte	0
 10000 0261 03       		.byte	3
 10001 0262 00       		.byte	0
 10002 0263 00       		.byte	0
 10003 0264 00       		.byte	0
 10004 0265 00       		.byte	0
 10005 0266 00       		.byte	0
 10006 0267 30       		.byte	48
 10007 0268 01       		.byte	1
 10008 0269 00       		.byte	0
 10009 026a 00       		.byte	0
 10010 026b 00000000 		.space	5
 10010      00
 10011 0270 00       		.byte	0
 10012 0271 00       		.byte	0
 10013 0272 02       		.byte	2
 10014 0273 00       		.byte	0
 10015 0274 00       		.byte	0
 10016 0275 40       		.byte	64
 10017 0276 00       		.byte	0
 10018 0277 01       		.byte	1
 10019 0278 00       		.byte	0
 10020 0279 03       		.byte	3
 10021 027a 00       		.byte	0
 10022 027b 00       		.byte	0
 10023 027c 00       		.byte	0
 10024 027d 00       		.byte	0
 10025 027e 00       		.byte	0
 10026 027f 30       		.byte	48
 10027 0280 01       		.byte	1
 10028 0281 00       		.byte	0
 10029 0282 00       		.byte	0
 10030 0283 00000000 		.space	5
 10030      00
 10031 0288 09       		.byte	9
 10032 0289 0A       		.byte	10
 10033 028a 04       		.byte	4
 10034 028b 00       		.byte	0
 10035 028c 00       		.byte	0
 10036 028d 40       		.byte	64
 10037 028e 00       		.byte	0
 10038 028f 01       		.byte	1
 10039 0290 00       		.byte	0
 10040 0291 03       		.byte	3
 10041 0292 00       		.byte	0
 10042 0293 20       		.byte	32
 10043 0294 38       		.byte	56
 10044 0295 20       		.byte	32
 10045 0296 38       		.byte	56
 10046 0297 30       		.byte	48
 10047 0298 01       		.byte	1
 10048 0299 00       		.byte	0
 10049 029a 00       		.byte	0
 10050 029b 00000000 		.space	5
 10050      00
 10051 02a0 00       		.byte	0
 10052 02a1 00       		.byte	0
 10053 02a2 02       		.byte	2
 10054 02a3 00       		.byte	0
 10055 02a4 00       		.byte	0
 10056 02a5 64       		.byte	100
 10057 02a6 00       		.byte	0
 10058 02a7 01       		.byte	1
 10059 02a8 00       		.byte	0
 10060 02a9 03       		.byte	3
 10061 02aa 00       		.byte	0
 10062 02ab 00       		.byte	0
 10063 02ac 00       		.byte	0
 10064 02ad 00       		.byte	0
 10065 02ae 00       		.byte	0
 10066 02af 30       		.byte	48
 10067 02b0 01       		.byte	1
 10068 02b1 00       		.byte	0
 10069 02b2 00       		.byte	0
 10070 02b3 00000000 		.space	5
 10070      00
 10071 02b8 00       		.byte	0
 10072 02b9 00       		.byte	0
 10073 02ba 02       		.byte	2
 10074 02bb 00       		.byte	0
 10075 02bc 00       		.byte	0
 10076 02bd 64       		.byte	100
 10077 02be 00       		.byte	0
 10078 02bf 01       		.byte	1
 10079 02c0 00       		.byte	0
 10080 02c1 03       		.byte	3
 10081 02c2 00       		.byte	0
 10082 02c3 00       		.byte	0
 10083 02c4 00       		.byte	0
 10084 02c5 00       		.byte	0
 10085 02c6 00       		.byte	0
 10086 02c7 30       		.byte	48
 10087 02c8 01       		.byte	1
 10088 02c9 00       		.byte	0
 10089 02ca 00       		.byte	0
 10090 02cb 00000000 		.space	5
 10090      00
 10091 02d0 2A       		.byte	42
 10092 02d1 2A       		.byte	42
 10093 02d2 02       		.byte	2
 10094 02d3 00       		.byte	0
 10095 02d4 00       		.byte	0
 10096 02d5 1B       		.byte	27
 10097 02d6 00       		.byte	0
 10098 02d7 01       		.byte	1
 10099 02d8 00       		.byte	0
 10100 02d9 03       		.byte	3
 10101 02da 00       		.byte	0
 10102 02db 00       		.byte	0
 10103 02dc 00       		.byte	0
 10104 02dd 00       		.byte	0
 10105 02de 00       		.byte	0
 10106 02df 30       		.byte	48
 10107 02e0 01       		.byte	1
 10108 02e1 00       		.byte	0
 10109 02e2 00       		.byte	0
 10110 02e3 00000000 		.space	5
 10110      00
 10111 02e8 00       		.byte	0
 10112 02e9 00       		.byte	0
 10113 02ea 02       		.byte	2
 10114 02eb 00       		.byte	0
 10115 02ec 00       		.byte	0
 10116 02ed 64       		.byte	100
 10117 02ee 00       		.byte	0
 10118 02ef 01       		.byte	1
 10119 02f0 00       		.byte	0
 10120 02f1 03       		.byte	3
 10121 02f2 00       		.byte	0
 10122 02f3 00       		.byte	0
 10123 02f4 00       		.byte	0
 10124 02f5 00       		.byte	0
 10125 02f6 00       		.byte	0
 10126 02f7 30       		.byte	48
 10127 02f8 01       		.byte	1
 10128 02f9 00       		.byte	0
 10129 02fa 00       		.byte	0
 10130 02fb 00000000 		.space	5
 10130      00
 10131 0300 00       		.byte	0
 10132 0301 00       		.byte	0
 10133 0302 02       		.byte	2
 10134 0303 00       		.byte	0
 10135 0304 00       		.byte	0
 10136 0305 12       		.byte	18
 10137 0306 00       		.byte	0
 10138 0307 01       		.byte	1
 10139 0308 00       		.byte	0
 10140 0309 03       		.byte	3
 10141 030a 00       		.byte	0
 10142 030b 00       		.byte	0
 10143 030c 00       		.byte	0
 10144 030d 00       		.byte	0
 10145 030e 00       		.byte	0
 10146 030f 30       		.byte	48
 10147 0310 01       		.byte	1
 10148 0311 00       		.byte	0
 10149 0312 00       		.byte	0
 10150 0313 00000000 		.space	5
 10150      00
 10151 0318 01       		.byte	1
 10152 0319 01       		.byte	1
 10153 031a 02       		.byte	2
 10154 031b 00       		.byte	0
 10155 031c 00       		.byte	0
 10156 031d 09       		.byte	9
 10157 031e 00       		.byte	0
 10158 031f 01       		.byte	1
 10159 0320 00       		.byte	0
 10160 0321 03       		.byte	3
 10161 0322 00       		.byte	0
 10162 0323 00       		.byte	0
 10163 0324 00       		.byte	0
 10164 0325 01       		.byte	1
 10165 0326 00       		.byte	0
 10166 0327 30       		.byte	48
 10167 0328 01       		.byte	1
 10168 0329 00       		.byte	0
 10169 032a 00       		.byte	0
 10170 032b 00000000 		.space	5
 10170      00
 10171 0330 05       		.byte	5
 10172 0331 05       		.byte	5
 10173 0332 02       		.byte	2
 10174 0333 00       		.byte	0
 10175 0334 00       		.byte	0
 10176 0335 03       		.byte	3
 10177 0336 00       		.byte	0
 10178 0337 01       		.byte	1
 10179 0338 00       		.byte	0
 10180 0339 03       		.byte	3
 10181 033a 00       		.byte	0
 10182 033b 00       		.byte	0
 10183 033c 00       		.byte	0
 10184 033d 00       		.byte	0
 10185 033e 00       		.byte	0
 10186 033f 30       		.byte	48
 10187 0340 01       		.byte	1
 10188 0341 00       		.byte	0
 10189 0342 00       		.byte	0
 10190 0343 00000000 		.space	5
 10190      00
 10191 0348 18       		.byte	24
 10192 0349 18       		.byte	24
 10193 034a 02       		.byte	2
 10194 034b 00       		.byte	0
 10195 034c 00       		.byte	0
 10196 034d 01       		.byte	1
 10197 034e 00       		.byte	0
 10198 034f 01       		.byte	1
 10199 0350 00       		.byte	0
 10200 0351 03       		.byte	3
 10201 0352 00       		.byte	0
 10202 0353 00       		.byte	0
 10203 0354 00       		.byte	0
 10204 0355 00       		.byte	0
 10205 0356 00       		.byte	0
 10206 0357 30       		.byte	48
 10207 0358 01       		.byte	1
 10208 0359 00       		.byte	0
 10209 035a 00       		.byte	0
 10210 035b 00000000 		.space	5
 10210      00
 10211 0360 19       		.byte	25
 10212 0361 19       		.byte	25
 10213 0362 01       		.byte	1
 10214 0363 00       		.byte	0
 10215 0364 00       		.byte	0
 10216 0365 40       		.byte	64
 10217 0366 00       		.byte	0
 10218 0367 01       		.byte	1
 10219 0368 00       		.byte	0
 10220 0369 03       		.byte	3
 10221 036a 00       		.byte	0
 10222 036b 20       		.byte	32
 10223 036c 00       		.byte	0
 10224 036d 20       		.byte	32
 10225 036e 00       		.byte	0
 10226 036f 30       		.byte	48
 10227 0370 01       		.byte	1
 10228 0371 00       		.byte	0
 10229 0372 00       		.byte	0
 10230 0373 00000000 		.space	5
 10230      00
 10231 0378 20       		.byte	32
 10232 0379 20       		.byte	32
 10233 037a 02       		.byte	2
 10234 037b 00       		.byte	0
 10235 037c 00       		.byte	0
 10236 037d 02       		.byte	2
 10237 037e 00       		.byte	0
 10238 037f 01       		.byte	1
 10239 0380 00       		.byte	0
 10240 0381 03       		.byte	3
 10241 0382 00       		.byte	0
 10242 0383 00       		.byte	0
 10243 0384 00       		.byte	0
 10244 0385 00       		.byte	0
 10245 0386 00       		.byte	0
 10246 0387 30       		.byte	48
 10247 0388 01       		.byte	1
 10248 0389 00       		.byte	0
 10249 038a 00       		.byte	0
 10250 038b 00000000 		.space	5
 10250      00
 10251 0390 22       		.byte	34
 10252 0391 22       		.byte	34
 10253 0392 02       		.byte	2
 10254 0393 00       		.byte	0
 10255 0394 00       		.byte	0
 10256 0395 3F       		.byte	63
 10257 0396 00       		.byte	0
 10258 0397 01       		.byte	1
 10259 0398 00       		.byte	0
 10260 0399 03       		.byte	3
 10261 039a 00       		.byte	0
 10262 039b 00       		.byte	0
 10263 039c 00       		.byte	0
 10264 039d 00       		.byte	0
 10265 039e 00       		.byte	0
 10266 039f 30       		.byte	48
 10267 03a0 01       		.byte	1
 10268 03a1 00       		.byte	0
 10269 03a2 00       		.byte	0
 10270 03a3 00000000 		.space	5
 10270      00
 10271 03a8 23       		.byte	35
 10272 03a9 23       		.byte	35
 10273 03aa 02       		.byte	2
 10274 03ab 00       		.byte	0
 10275 03ac 00       		.byte	0
 10276 03ad 64       		.byte	100
 10277 03ae 00       		.byte	0
 10278 03af 01       		.byte	1
 10279 03b0 00       		.byte	0
 10280 03b1 03       		.byte	3
 10281 03b2 00       		.byte	0
 10282 03b3 10       		.byte	16
 10283 03b4 00       		.byte	0
 10284 03b5 10       		.byte	16
 10285 03b6 00       		.byte	0
 10286 03b7 30       		.byte	48
 10287 03b8 01       		.byte	1
 10288 03b9 00       		.byte	0
 10289 03ba 00       		.byte	0
 10290 03bb 00000000 		.space	5
 10290      00
 10291 03c0 24       		.byte	36
 10292 03c1 24       		.byte	36
 10293 03c2 02       		.byte	2
 10294 03c3 00       		.byte	0
 10295 03c4 00       		.byte	0
 10296 03c5 64       		.byte	100
 10297 03c6 00       		.byte	0
 10298 03c7 01       		.byte	1
 10299 03c8 00       		.byte	0
 10300 03c9 03       		.byte	3
 10301 03ca 00       		.byte	0
 10302 03cb 10       		.byte	16
 10303 03cc 00       		.byte	0
 10304 03cd 10       		.byte	16
 10305 03ce 00       		.byte	0
 10306 03cf 30       		.byte	48
 10307 03d0 01       		.byte	1
 10308 03d1 00       		.byte	0
 10309 03d2 00       		.byte	0
 10310 03d3 00000000 		.space	5
 10310      00
 10311 03d8 02       		.byte	2
 10312 03d9 03       		.byte	3
 10313 03da 04       		.byte	4
 10314 03db 00       		.byte	0
 10315 03dc 00       		.byte	0
 10316 03dd 7F       		.byte	127
 10317 03de 00       		.byte	0
 10318 03df 01       		.byte	1
 10319 03e0 00       		.byte	0
 10320 03e1 03       		.byte	3
 10321 03e2 00       		.byte	0
 10322 03e3 00       		.byte	0
 10323 03e4 20       		.byte	32
 10324 03e5 00       		.byte	0
 10325 03e6 20       		.byte	32
 10326 03e7 30       		.byte	48
 10327 03e8 01       		.byte	1
 10328 03e9 00       		.byte	0
 10329 03ea 00       		.byte	0
 10330 03eb 00000000 		.space	5
 10330      00
 10331 03f0 04       		.byte	4
 10332 03f1 04       		.byte	4
 10333 03f2 02       		.byte	2
 10334 03f3 00       		.byte	0
 10335 03f4 00       		.byte	0
 10336 03f5 FF       		.byte	-1
 10337 03f6 00       		.byte	0
 10338 03f7 01       		.byte	1
 10339 03f8 00       		.byte	0
 10340 03f9 03       		.byte	3
 10341 03fa 00       		.byte	0
 10342 03fb 60       		.byte	96
 10343 03fc 00       		.byte	0
 10344 03fd 60       		.byte	96
 10345 03fe 00       		.byte	0
 10346 03ff 30       		.byte	48
 10347 0400 01       		.byte	1
 10348 0401 00       		.byte	0
 10349 0402 00       		.byte	0
 10350 0403 00000000 		.space	5
 10350      00
 10351 0408 00       		.byte	0
 10352 0409 00       		.byte	0
 10353 040a 02       		.byte	2
 10354 040b 00       		.byte	0
 10355 040c 00       		.byte	0
 10356 040d 19       		.byte	25
 10357 040e 00       		.byte	0
 10358 040f 01       		.byte	1
 10359 0410 00       		.byte	0
 10360 0411 03       		.byte	3
 10361 0412 00       		.byte	0
 10362 0413 00       		.byte	0
 10363 0414 00       		.byte	0
 10364 0415 00       		.byte	0
 10365 0416 00       		.byte	0
 10366 0417 30       		.byte	48
 10367 0418 01       		.byte	1
 10368 0419 00       		.byte	0
 10369 041a 00       		.byte	0
 10370 041b 00000000 		.space	5
 10370      00
 10371 0420 10       		.byte	16
 10372 0421 10       		.byte	16
 10373 0422 02       		.byte	2
 10374 0423 00       		.byte	0
 10375 0424 00       		.byte	0
 10376 0425 06       		.byte	6
 10377 0426 00       		.byte	0
 10378 0427 01       		.byte	1
 10379 0428 00       		.byte	0
 10380 0429 03       		.byte	3
 10381 042a 00       		.byte	0
 10382 042b 03       		.byte	3
 10383 042c 00       		.byte	0
 10384 042d 03       		.byte	3
 10385 042e 00       		.byte	0
 10386 042f 30       		.byte	48
 10387 0430 01       		.byte	1
 10388 0431 00       		.byte	0
 10389 0432 00       		.byte	0
 10390 0433 00000000 		.space	5
 10390      00
 10391 0438 00       		.byte	0
 10392 0439 00       		.byte	0
 10393 043a 02       		.byte	2
 10394 043b 00       		.byte	0
 10395 043c 00       		.byte	0
 10396 043d 03       		.byte	3
 10397 043e 00       		.byte	0
 10398 043f 01       		.byte	1
 10399 0440 00       		.byte	0
 10400 0441 03       		.byte	3
 10401 0442 00       		.byte	0
 10402 0443 00       		.byte	0
 10403 0444 00       		.byte	0
 10404 0445 00       		.byte	0
 10405 0446 00       		.byte	0
 10406 0447 30       		.byte	48
 10407 0448 01       		.byte	1
 10408 0449 00       		.byte	0
 10409 044a 00       		.byte	0
 10410 044b 00000000 		.space	5
 10410      00
 10411 0450 50       		.byte	80
 10412 0451 50       		.byte	80
 10413 0452 01       		.byte	1
 10414 0453 00       		.byte	0
 10415 0454 00       		.byte	0
 10416 0455 03       		.byte	3
 10417 0456 00       		.byte	0
 10418 0457 01       		.byte	1
 10419 0458 00       		.byte	0
 10420 0459 03       		.byte	3
 10421 045a 00       		.byte	0
 10422 045b 00       		.byte	0
 10423 045c 00       		.byte	0
 10424 045d 00       		.byte	0
 10425 045e 00       		.byte	0
 10426 045f 30       		.byte	48
 10427 0460 01       		.byte	1
 10428 0461 00       		.byte	0
 10429 0462 00       		.byte	0
 10430 0463 00000000 		.space	5
 10430      00
 10431 0468 00       		.byte	0
 10432 0469 00       		.byte	0
 10433 046a 0B       		.byte	11
 10434 046b 00       		.byte	0
 10435 046c 00       		.byte	0
 10436 046d FF       		.byte	-1
 10437 046e FF       		.byte	-1
 10438 046f 01       		.byte	1
 10439 0470 00       		.byte	0
 10440 0471 03       		.byte	3
 10441 0472 00       		.byte	0
 10442 0473 00       		.byte	0
 10443 0474 00       		.byte	0
 10444 0475 00       		.byte	0
 10445 0476 00       		.byte	0
 10446 0477 00       		.byte	0
 10447 0478 01       		.byte	1
 10448 0479 00       		.byte	0
 10449 047a 00       		.byte	0
 10450 047b 00000000 		.space	5
 10450      00
 10453              	glUVCHeader:
 10454 0480 0C       		.byte	12
 10455 0481 8C       		.byte	-116
 10456 0482 00       		.byte	0
 10457 0483 00       		.byte	0
 10458 0484 00       		.byte	0
 10459 0485 00       		.byte	0
 10460 0486 00       		.byte	0
 10461 0487 00       		.byte	0
 10462 0488 00       		.byte	0
 10463 0489 00       		.byte	0
 10464 048a 00       		.byte	0
 10465 048b 00       		.byte	0
 10468              	dbgIdx:
 10469 048c 02       		.byte	2
 10472              	ROIMode:
 10473 048d 01       		.byte	1
 10476              	valIdx:
 10477 048e 01       		.byte	1
 10478 048f 00       		.space	1
 10481              	EXTBLCWinPos:
 10482 0490 14       		.byte	20
 10483 0491 13       		.byte	19
 10484 0492 02       		.byte	2
 10485 0493 00       		.byte	0
 10486 0494 00       		.byte	0
 10487 0495 FF       		.byte	-1
 10488 0496 FF       		.byte	-1
 10489 0497 01       		.byte	1
 10490 0498 00       		.byte	0
 10491 0499 03       		.byte	3
 10492 049a 00       		.byte	0
 10493 049b 66       		.byte	102
 10494 049c 66       		.byte	102
 10495 049d 66       		.byte	102
 10496 049e 66       		.byte	102
 10497 049f 30       		.byte	48
 10498 04a0 01       		.byte	1
 10499 04a1 00       		.byte	0
 10500 04a2 0000     		.space	2
 10503              	EXTBLCWeight:
 10504 04a4 11       		.byte	17
 10505 04a5 11       		.byte	17
 10506 04a6 02       		.byte	2
 10507 04a7 00       		.byte	0
 10508 04a8 00       		.byte	0
 10509 04a9 FF       		.byte	-1
 10510 04aa 00       		.byte	0
 10511 04ab 01       		.byte	1
 10512 04ac 00       		.byte	0
 10513 04ad 03       		.byte	3
 10514 04ae 00       		.byte	0
 10515 04af 80       		.byte	-128
 10516 04b0 00       		.byte	0
 10517 04b1 80       		.byte	-128
 10518 04b2 00       		.byte	0
 10519 04b3 30       		.byte	48
 10520 04b4 01       		.byte	1
 10521 04b5 00       		.byte	0
 10522 04b6 0000     		.space	2
 10525              	EXTShutter:
 10526 04b8 00       		.byte	0
 10527 04b9 02       		.byte	2
 10528 04ba 02       		.byte	2
 10529 04bb 00       		.byte	0
 10530 04bc 00       		.byte	0
 10531 04bd 08       		.byte	8
 10532 04be 00       		.byte	0
 10533 04bf 01       		.byte	1
 10534 04c0 00       		.byte	0
 10535 04c1 03       		.byte	3
 10536 04c2 00       		.byte	0
 10537 04c3 00       		.byte	0
 10538 04c4 00       		.byte	0
 10539 04c5 00       		.byte	0
 10540 04c6 00       		.byte	0
 10541 04c7 30       		.byte	48
 10542 04c8 01       		.byte	1
 10543 04c9 00       		.byte	0
 10544 04ca 0000     		.space	2
 10547              	EXTShutlev:
 10548 04cc 02       		.byte	2
 10549 04cd 12       		.byte	18
 10550 04ce 02       		.byte	2
 10551 04cf 00       		.byte	0
 10552 04d0 00       		.byte	0
 10553 04d1 FF       		.byte	-1
 10554 04d2 7F       		.byte	127
 10555 04d3 01       		.byte	1
 10556 04d4 00       		.byte	0
 10557 04d5 03       		.byte	3
 10558 04d6 00       		.byte	0
 10559 04d7 3F       		.byte	63
 10560 04d8 00       		.byte	0
 10561 04d9 3F       		.byte	63
 10562 04da 00       		.byte	0
 10563 04db 30       		.byte	48
 10564 04dc 01       		.byte	1
 10565 04dd 00       		.byte	0
 10566 04de 0000     		.space	2
 10569              	EXTAexModGainlev:
 10570 04e0 00       		.byte	0
 10571 04e1 03       		.byte	3
 10572 04e2 04       		.byte	4
 10573 04e3 00       		.byte	0
 10574 04e4 00       		.byte	0
 10575 04e5 03       		.byte	3
 10576 04e6 7F       		.byte	127
 10577 04e7 01       		.byte	1
 10578 04e8 00       		.byte	0
 10579 04e9 03       		.byte	3
 10580 04ea 00       		.byte	0
 10581 04eb 00       		.byte	0
 10582 04ec 3F       		.byte	63
 10583 04ed 00       		.byte	0
 10584 04ee 3F       		.byte	63
 10585 04ef 30       		.byte	48
 10586 04f0 01       		.byte	1
 10587 04f1 00       		.byte	0
 10588 04f2 0000     		.space	2
 10591              	WBMenuCmpArry:
 10592 04f4 20       		.byte	32
 10593 04f5 0F       		.byte	15
 10594 04f6 38       		.byte	56
 10595 04f7 F0       		.byte	-16
 10598              	PUCBLC:
 10599 04f8 10       		.byte	16
 10600 04f9 11       		.byte	17
 10601 04fa 02       		.byte	2
 10602 04fb 00       		.byte	0
 10603 04fc 00       		.byte	0
 10604 04fd 03       		.byte	3
 10605 04fe 00       		.byte	0
 10606 04ff 01       		.byte	1
 10607 0500 00       		.byte	0
 10608 0501 03       		.byte	3
 10609 0502 00       		.byte	0
 10610 0503 03       		.byte	3
 10611 0504 00       		.byte	0
 10612 0505 03       		.byte	3
 10613 0506 00       		.byte	0
 10614 0507 30       		.byte	48
 10615 0508 01       		.byte	1
 10616 0509 00       		.byte	0
 10617 050a 0000     		.space	2
 10620              	PUCSharp:
 10621 050c 06       		.byte	6
 10622 050d 07       		.byte	7
 10623 050e 02       		.byte	2
 10624 050f 00       		.byte	0
 10625 0510 00       		.byte	0
 10626 0511 08       		.byte	8
 10627 0512 00       		.byte	0
 10628 0513 01       		.byte	1
 10629 0514 00       		.byte	0
 10630 0515 03       		.byte	3
 10631 0516 00       		.byte	0
 10632 0517 00       		.byte	0
 10633 0518 00       		.byte	0
 10634 0519 00       		.byte	0
 10635 051a 00       		.byte	0
 10636 051b 30       		.byte	48
 10637 051c 01       		.byte	1
 10638 051d 00       		.byte	0
 10639 051e 0000     		.space	2
 10642              	CTCtrlParArry:
 10643 0520 00       		.byte	0
 10644 0521 00       		.byte	0
 10645 0522 01       		.byte	1
 10646 0523 00       		.byte	0
 10647 0524 00       		.byte	0
 10648 0525 03       		.byte	3
 10649 0526 00       		.byte	0
 10650 0527 01       		.byte	1
 10651 0528 00       		.byte	0
 10652 0529 03       		.byte	3
 10653 052a 00       		.byte	0
 10654 052b 03       		.byte	3
 10655 052c 00       		.byte	0
 10656 052d 03       		.byte	3
 10657 052e 00       		.byte	0
 10658 052f 30       		.byte	48
 10659 0530 01       		.byte	1
 10660 0531 00       		.byte	0
 10661 0532 00       		.byte	0
 10662 0533 00000000 		.space	5
 10662      00
 10663 0538 00       		.byte	0
 10664 0539 00       		.byte	0
 10665 053a 01       		.byte	1
 10666 053b 01       		.byte	1
 10667 053c 00       		.byte	0
 10668 053d 0F       		.byte	15
 10669 053e 00       		.byte	0
 10670 053f 0F       		.byte	15
 10671 0540 00       		.byte	0
 10672 0541 03       		.byte	3
 10673 0542 00       		.byte	0
 10674 0543 02       		.byte	2
 10675 0544 00       		.byte	0
 10676 0545 02       		.byte	2
 10677 0546 00       		.byte	0
 10678 0547 30       		.byte	48
 10679 0548 01       		.byte	1
 10680 0549 01       		.byte	1
 10681 054a 00       		.byte	0
 10682 054b 00000000 		.space	5
 10682      00
 10683 0550 02       		.byte	2
 10684 0551 00       		.byte	0
 10685 0552 01       		.byte	1
 10686 0553 00       		.byte	0
 10687 0554 00       		.byte	0
 10688 0555 01       		.byte	1
 10689 0556 00       		.byte	0
 10690 0557 01       		.byte	1
 10691 0558 00       		.byte	0
 10692 0559 03       		.byte	3
 10693 055a 00       		.byte	0
 10694 055b 00       		.byte	0
 10695 055c 00       		.byte	0
 10696 055d 00       		.byte	0
 10697 055e 00       		.byte	0
 10698 055f 30       		.byte	48
 10699 0560 01       		.byte	1
 10700 0561 01       		.byte	1
 10701 0562 00       		.byte	0
 10702 0563 00000000 		.space	5
 10702      00
 10703 0568 00       		.byte	0
 10704 0569 00       		.byte	0
 10705 056a 04       		.byte	4
 10706 056b 01       		.byte	1
 10707 056c 00       		.byte	0
 10708 056d 38       		.byte	56
 10709 056e 01       		.byte	1
 10710 056f 01       		.byte	1
 10711 0570 00       		.byte	0
 10712 0571 03       		.byte	3
 10713 0572 00       		.byte	0
 10714 0573 4E       		.byte	78
 10715 0574 00       		.byte	0
 10716 0575 4E       		.byte	78
 10717 0576 00       		.byte	0
 10718 0577 30       		.byte	48
 10719 0578 01       		.byte	1
 10720 0579 00       		.byte	0
 10721 057a 00       		.byte	0
 10722 057b 00000000 		.space	5
 10722      00
 10723 0580 04       		.byte	4
 10724 0581 00       		.byte	0
 10725 0582 01       		.byte	1
 10726 0583 00       		.byte	0
 10727 0584 00       		.byte	0
 10728 0585 00       		.byte	0
 10729 0586 00       		.byte	0
 10730 0587 01       		.byte	1
 10731 0588 00       		.byte	0
 10732 0589 03       		.byte	3
 10733 058a 00       		.byte	0
 10734 058b 00       		.byte	0
 10735 058c 00       		.byte	0
 10736 058d 00       		.byte	0
 10737 058e 00       		.byte	0
 10738 058f 30       		.byte	48
 10739 0590 01       		.byte	1
 10740 0591 00       		.byte	0
 10741 0592 00       		.byte	0
 10742 0593 00000000 		.space	5
 10742      00
 10743 0598 05       		.byte	5
 10744 0599 00       		.byte	0
 10745 059a 02       		.byte	2
 10746 059b 00       		.byte	0
 10747 059c 00       		.byte	0
 10748 059d FF       		.byte	-1
 10749 059e 00       		.byte	0
 10750 059f 01       		.byte	1
 10751 05a0 00       		.byte	0
 10752 05a1 03       		.byte	3
 10753 05a2 00       		.byte	0
 10754 05a3 01       		.byte	1
 10755 05a4 00       		.byte	0
 10756 05a5 00       		.byte	0
 10757 05a6 00       		.byte	0
 10758 05a7 30       		.byte	48
 10759 05a8 01       		.byte	1
 10760 05a9 01       		.byte	1
 10761 05aa 00       		.byte	0
 10762 05ab 00000000 		.space	5
 10762      00
 10763 05b0 06       		.byte	6
 10764 05b1 00       		.byte	0
 10765 05b2 02       		.byte	2
 10766 05b3 00       		.byte	0
 10767 05b4 00       		.byte	0
 10768 05b5 00       		.byte	0
 10769 05b6 00       		.byte	0
 10770 05b7 00       		.byte	0
 10771 05b8 00       		.byte	0
 10772 05b9 03       		.byte	3
 10773 05ba 00       		.byte	0
 10774 05bb 00       		.byte	0
 10775 05bc 00       		.byte	0
 10776 05bd 00       		.byte	0
 10777 05be 00       		.byte	0
 10778 05bf 30       		.byte	48
 10779 05c0 01       		.byte	1
 10780 05c1 01       		.byte	1
 10781 05c2 00       		.byte	0
 10782 05c3 00000000 		.space	5
 10782      00
 10783 05c8 23       		.byte	35
 10784 05c9 00       		.byte	0
 10785 05ca 02       		.byte	2
 10786 05cb 00       		.byte	0
 10787 05cc 00       		.byte	0
 10788 05cd 30       		.byte	48
 10789 05ce 00       		.byte	0
 10790 05cf 01       		.byte	1
 10791 05d0 00       		.byte	0
 10792 05d1 03       		.byte	3
 10793 05d2 0A       		.byte	10
 10794 05d3 00       		.byte	0
 10795 05d4 00       		.byte	0
 10796 05d5 0A       		.byte	10
 10797 05d6 00       		.byte	0
 10798 05d7 30       		.byte	48
 10799 05d8 01       		.byte	1
 10800 05d9 01       		.byte	1
 10801 05da 00       		.byte	0
 10802 05db 00000000 		.space	5
 10802      00
 10803 05e0 08       		.byte	8
 10804 05e1 00       		.byte	0
 10805 05e2 01       		.byte	1
 10806 05e3 00       		.byte	0
 10807 05e4 00       		.byte	0
 10808 05e5 7F       		.byte	127
 10809 05e6 00       		.byte	0
 10810 05e7 01       		.byte	1
 10811 05e8 00       		.byte	0
 10812 05e9 03       		.byte	3
 10813 05ea 00       		.byte	0
 10814 05eb 00       		.byte	0
 10815 05ec 00       		.byte	0
 10816 05ed 00       		.byte	0
 10817 05ee 00       		.byte	0
 10818 05ef 30       		.byte	48
 10819 05f0 01       		.byte	1
 10820 05f1 00       		.byte	0
 10821 05f2 00       		.byte	0
 10822 05f3 00000000 		.space	5
 10822      00
 10823 05f8 09       		.byte	9
 10824 05f9 00       		.byte	0
 10825 05fa 02       		.byte	2
 10826 05fb 00       		.byte	0
 10827 05fc 00       		.byte	0
 10828 05fd 05       		.byte	5
 10829 05fe 00       		.byte	0
 10830 05ff 01       		.byte	1
 10831 0600 00       		.byte	0
 10832 0601 03       		.byte	3
 10833 0602 00       		.byte	0
 10834 0603 00       		.byte	0
 10835 0604 00       		.byte	0
 10836 0605 00       		.byte	0
 10837 0606 00       		.byte	0
 10838 0607 30       		.byte	48
 10839 0608 01       		.byte	1
 10840 0609 00       		.byte	0
 10841 060a 00       		.byte	0
 10842 060b 00000000 		.space	5
 10842      00
 10843 0610 10       		.byte	16
 10844 0611 00       		.byte	0
 10845 0612 03       		.byte	3
 10846 0613 00       		.byte	0
 10847 0614 00       		.byte	0
 10848 0615 00       		.byte	0
 10849 0616 00       		.byte	0
 10850 0617 00       		.byte	0
 10851 0618 00       		.byte	0
 10852 0619 03       		.byte	3
 10853 061a 00       		.byte	0
 10854 061b 00       		.byte	0
 10855 061c 00       		.byte	0
 10856 061d 00       		.byte	0
 10857 061e 00       		.byte	0
 10858 061f 30       		.byte	48
 10859 0620 01       		.byte	1
 10860 0621 00       		.byte	0
 10861 0622 00       		.byte	0
 10862 0623 00000000 		.space	5
 10862      00
 10863 0628 00       		.byte	0
 10864 0629 00       		.byte	0
 10865 062a 02       		.byte	2
 10866 062b 00       		.byte	0
 10867 062c 00       		.byte	0
 10868 062d 40       		.byte	64
 10869 062e 00       		.byte	0
 10870 062f 01       		.byte	1
 10871 0630 00       		.byte	0
 10872 0631 03       		.byte	3
 10873 0632 00       		.byte	0
 10874 0633 0F       		.byte	15
 10875 0634 11       		.byte	17
 10876 0635 00       		.byte	0
 10877 0636 00       		.byte	0
 10878 0637 30       		.byte	48
 10879 0638 01       		.byte	1
 10880 0639 00       		.byte	0
 10881 063a 00       		.byte	0
 10882 063b 00000000 		.space	5
 10882      00
 10883 0640 00       		.byte	0
 10884 0641 00       		.byte	0
 10885 0642 02       		.byte	2
 10886 0643 00       		.byte	0
 10887 0644 00       		.byte	0
 10888 0645 64       		.byte	100
 10889 0646 00       		.byte	0
 10890 0647 01       		.byte	1
 10891 0648 00       		.byte	0
 10892 0649 03       		.byte	3
 10893 064a 00       		.byte	0
 10894 064b 00       		.byte	0
 10895 064c 00       		.byte	0
 10896 064d 00       		.byte	0
 10897 064e 00       		.byte	0
 10898 064f 30       		.byte	48
 10899 0650 01       		.byte	1
 10900 0651 00       		.byte	0
 10901 0652 00       		.byte	0
 10902 0653 00000000 		.space	5
 10902      00
 10903 0658 00       		.byte	0
 10904 0659 00       		.byte	0
 10905 065a 02       		.byte	2
 10906 065b 00       		.byte	0
 10907 065c 00       		.byte	0
 10908 065d 64       		.byte	100
 10909 065e 00       		.byte	0
 10910 065f 01       		.byte	1
 10911 0660 00       		.byte	0
 10912 0661 03       		.byte	3
 10913 0662 00       		.byte	0
 10914 0663 00       		.byte	0
 10915 0664 00       		.byte	0
 10916 0665 00       		.byte	0
 10917 0666 00       		.byte	0
 10918 0667 30       		.byte	48
 10919 0668 01       		.byte	1
 10920 0669 00       		.byte	0
 10921 066a 00       		.byte	0
 10922 066b 00000000 		.space	5
 10922      00
 10923 0670 00       		.byte	0
 10924 0671 00       		.byte	0
 10925 0672 02       		.byte	2
 10926 0673 00       		.byte	0
 10927 0674 00       		.byte	0
 10928 0675 64       		.byte	100
 10929 0676 00       		.byte	0
 10930 0677 01       		.byte	1
 10931 0678 00       		.byte	0
 10932 0679 03       		.byte	3
 10933 067a 00       		.byte	0
 10934 067b 00       		.byte	0
 10935 067c 00       		.byte	0
 10936 067d 00       		.byte	0
 10937 067e 00       		.byte	0
 10938 067f 30       		.byte	48
 10939 0680 01       		.byte	1
 10940 0681 00       		.byte	0
 10941 0682 00       		.byte	0
 10942 0683 00000000 		.space	5
 10942      00
 10943 0688 00       		.byte	0
 10944 0689 00       		.byte	0
 10945 068a 02       		.byte	2
 10946 068b 00       		.byte	0
 10947 068c 00       		.byte	0
 10948 068d 64       		.byte	100
 10949 068e 00       		.byte	0
 10950 068f 01       		.byte	1
 10951 0690 00       		.byte	0
 10952 0691 03       		.byte	3
 10953 0692 00       		.byte	0
 10954 0693 00       		.byte	0
 10955 0694 00       		.byte	0
 10956 0695 00       		.byte	0
 10957 0696 00       		.byte	0
 10958 0697 30       		.byte	48
 10959 0698 01       		.byte	1
 10960 0699 00       		.byte	0
 10961 069a 00       		.byte	0
 10962 069b 00000000 		.space	5
 10962      00
 10965              	glProbeCtrlFull:
 10966 06a0 00       		.byte	0
 10967 06a1 00       		.byte	0
 10968 06a2 01       		.byte	1
 10969 06a3 01       		.byte	1
 10970 06a4 15       		.byte	21
 10971 06a5 16       		.byte	22
 10972 06a6 05       		.byte	5
 10973 06a7 00       		.byte	0
 10974 06a8 00       		.byte	0
 10975 06a9 00       		.byte	0
 10976 06aa 00       		.byte	0
 10977 06ab 00       		.byte	0
 10978 06ac 00       		.byte	0
 10979 06ad 00       		.byte	0
 10980 06ae 00       		.byte	0
 10981 06af 00       		.byte	0
 10982 06b0 00       		.byte	0
 10983 06b1 00       		.byte	0
 10984 06b2 00       		.byte	0
 10985 06b3 C6       		.byte	-58
 10986 06b4 99       		.byte	-103
 10987 06b5 00       		.byte	0
 10988 06b6 00       		.byte	0
 10989 06b7 40       		.byte	64
 10990 06b8 00       		.byte	0
 10991 06b9 00       		.byte	0
 10992 06ba 0000     		.space	2
 10995              	glProbeCtrl20:
 10996 06bc 00       		.byte	0
 10997 06bd 00       		.byte	0
 10998 06be 01       		.byte	1
 10999 06bf 01       		.byte	1
 11000 06c0 80       		.byte	-128
 11001 06c1 1A       		.byte	26
 11002 06c2 06       		.byte	6
 11003 06c3 00       		.byte	0
 11004 06c4 00       		.byte	0
 11005 06c5 00       		.byte	0
 11006 06c6 00       		.byte	0
 11007 06c7 00       		.byte	0
 11008 06c8 00       		.byte	0
 11009 06c9 00       		.byte	0
 11010 06ca 00       		.byte	0
 11011 06cb 00       		.byte	0
 11012 06cc 00       		.byte	0
 11013 06cd 00       		.byte	0
 11014 06ce 00       		.byte	0
 11015 06cf D2       		.byte	-46
 11016 06d0 0F       		.byte	15
 11017 06d1 00       		.byte	0
 11018 06d2 00       		.byte	0
 11019 06d3 40       		.byte	64
 11020 06d4 00       		.byte	0
 11021 06d5 00       		.byte	0
 11022 06d6 0000     		.space	2
 11025              	glProbeCtrl:
 11026 06d8 00       		.byte	0
 11027 06d9 00       		.byte	0
 11028 06da 01       		.byte	1
 11029 06db 01       		.byte	1
 11030 06dc 15       		.byte	21
 11031 06dd 16       		.byte	22
 11032 06de 05       		.byte	5
 11033 06df 00       		.byte	0
 11034 06e0 00       		.byte	0
 11035 06e1 00       		.byte	0
 11036 06e2 00       		.byte	0
 11037 06e3 00       		.byte	0
 11038 06e4 00       		.byte	0
 11039 06e5 00       		.byte	0
 11040 06e6 00       		.byte	0
 11041 06e7 00       		.byte	0
 11042 06e8 00       		.byte	0
 11043 06e9 00       		.byte	0
 11044 06ea 00       		.byte	0
 11045 06eb 48       		.byte	72
 11046 06ec 3F       		.byte	63
 11047 06ed 00       		.byte	0
 11048 06ee 00       		.byte	0
 11049 06ef 40       		.byte	64
 11050 06f0 00       		.byte	0
 11051 06f1 00       		.byte	0
 11052 06f2 0000     		.space	2
 11055              	glProbeStilCtrl:
 11056 06f4 01       		.byte	1
 11057 06f5 02       		.byte	2
 11058 06f6 00       		.byte	0
 11059 06f7 00       		.byte	0
 11060 06f8 C6       		.byte	-58
 11061 06f9 99       		.byte	-103
 11062 06fa 00       		.byte	0
 11063 06fb 00       		.byte	0
 11064 06fc 40       		.byte	64
 11065 06fd 00       		.byte	0
 11066 06fe 00       		.byte	0
 11067 06ff 00       		.space	1
 11070              	glProbeStilCtrl20:
 11071 0700 01       		.byte	1
 11072 0701 01       		.byte	1
 11073 0702 00       		.byte	0
 11074 0703 00       		.byte	0
 11075 0704 D2       		.byte	-46
 11076 0705 0F       		.byte	15
 11077 0706 00       		.byte	0
 11078 0707 00       		.byte	0
 11079 0708 40       		.byte	64
 11080 0709 00       		.byte	0
 11081 070a 00       		.byte	0
 11084              	snapButFlag:
 11085 070b 01       		.byte	1
 11088              	CyFxGpifTransition:
 11089 070c 0000     		.short	0
 11090 070e 5555     		.short	21845
 11091 0710 8888     		.short	-30584
 11092 0712 AAAA     		.short	-21846
 11093 0714 3333     		.short	13107
 11094 0716 0000     		.space	2
 11097              	CyFxGpifWavedata:
 11098 0718 0181731E 		.word	510886145
 11099 071c 00000000 		.word	0
 11100 0720 00000080 		.word	-2147483648
 11101 0724 00000000 		.word	0
 11102 0728 00000000 		.word	0
 11103 072c 00000000 		.word	0
 11104 0730 0201702E 		.word	779092226
 11105 0734 00010000 		.word	256
 11106 0738 A0000080 		.word	-2147483488
 11107 073c 00000000 		.word	0
 11108 0740 00000000 		.word	0
 11109 0744 00000000 		.word	0
 11110 0748 0380722E 		.word	779255811
 11111 074c 02010020 		.word	536871170
 11112 0750 60000080 		.word	-2147483552
 11113 0754 00000000 		.word	0
 11114 0758 00000000 		.word	0
 11115 075c 00000000 		.word	0
 11116 0760 0460722E 		.word	779247620
 11117 0764 02010024 		.word	603980034
 11118 0768 90000080 		.word	-2147483504
 11119 076c 0594731E 		.word	510891013
 11120 0770 06000000 		.word	6
 11121 0774 00000080 		.word	-2147483648
 11122 0778 0380722E 		.word	779255811
 11123 077c 02010020 		.word	536871170
 11124 0780 60000080 		.word	-2147483552
 11125 0784 0693731E 		.word	510890758
 11126 0788 06000000 		.word	6
 11127 078c 00000080 		.word	-2147483648
 11128 0790 0720703E 		.word	1047535623
 11129 0794 08010000 		.word	264
 11130 0798 00000080 		.word	-2147483648
 11131 079c 0820703E 		.word	1047535624
 11132 07a0 08010000 		.word	264
 11133 07a4 00000080 		.word	-2147483648
 11134 07a8 0920703E 		.word	1047535625
 11135 07ac 08010000 		.word	264
 11136 07b0 00000080 		.word	-2147483648
 11137 07b4 0A20703E 		.word	1047535626
 11138 07b8 08010000 		.word	264
 11139 07bc 00000080 		.word	-2147483648
 11140 07c0 0380722E 		.word	779255811
 11141 07c4 02010020 		.word	536871170
 11142 07c8 60000080 		.word	-2147483552
 11143 07cc 0B000000 		.word	11
 11144 07d0 00000000 		.word	0
 11145 07d4 00010080 		.word	-2147483392
 11146 07d8 0460722E 		.word	779247620
 11147 07dc 02010024 		.word	603980034
 11148 07e0 90000080 		.word	-2147483504
 11149 07e4 0D000000 		.word	13
 11150 07e8 00000000 		.word	0
 11151 07ec 00010080 		.word	-2147483392
 11152 07f0 0460722E 		.word	779247620
 11153 07f4 02010024 		.word	603980034
 11154 07f8 90000080 		.word	-2147483504
 11155 07fc 0C000000 		.word	12
 11156 0800 00000000 		.word	0
 11157 0804 00010080 		.word	-2147483392
 11158 0808 0380722E 		.word	779255811
 11159 080c 02010020 		.word	536871170
 11160 0810 60000080 		.word	-2147483552
 11161 0814 0E000000 		.word	14
 11162 0818 00000000 		.word	0
 11163 081c 00010080 		.word	-2147483392
 11164 0820 00000000 		.word	0
 11165 0824 00000000 		.word	0
 11166 0828 00000000 		.word	0
 11167 082c 00000000 		.word	0
 11168 0830 00000000 		.word	0
 11169 0834 00000000 		.word	0
 11172              	CyFxGpifWavedataPosition:
 11173 0838 00       		.byte	0
 11174 0839 01       		.byte	1
 11175 083a 02       		.byte	2
 11176 083b 03       		.byte	3
 11177 083c 04       		.byte	4
 11178 083d 05       		.byte	5
 11179 083e 06       		.byte	6
 11180 083f 07       		.byte	7
 11181 0840 08       		.byte	8
 11182 0841 09       		.byte	9
 11183 0842 0A       		.byte	10
 11184 0843 0B       		.byte	11
 11185 0844 0B       		.byte	11
 11186 0845 0B       		.byte	11
 11187 0846 0B       		.byte	11
 11188 0847 00       		.space	1
 11191              	CyFxGpifRegValue:
 11192 0848 08830080 		.word	-2147450104
 11193 084c 67000000 		.word	103
 11194 0850 00000000 		.word	0
 11195 0854 46000000 		.word	70
 11196 0858 00000000 		.word	0
 11197 085c 00000000 		.word	0
 11198 0860 02000000 		.word	2
 11199 0864 82000000 		.word	130
 11200 0868 82070000 		.word	1922
 11201 086c 40040000 		.word	1088
 11202 0870 FCFF0000 		.word	65532
 11203 0874 28000000 		.word	40
 11204 0878 00000000 		.word	0
 11205 087c 00000000 		.word	0
 11206 0880 00000000 		.word	0
 11207 0884 00000000 		.word	0
 11208 0888 01000000 		.word	1
 11209 088c 00000000 		.word	0
 11210 0890 00000000 		.word	0
 11211 0894 00000000 		.word	0
 11212 0898 00000000 		.word	0
 11213 089c 00000000 		.word	0
 11214 08a0 00000000 		.word	0
 11215 08a4 00000000 		.word	0
 11216 08a8 00000000 		.word	0
 11217 08ac 00000000 		.word	0
 11218 08b0 00000000 		.word	0
 11219 08b4 00000000 		.word	0
 11220 08b8 00000000 		.word	0
 11221 08bc 06000000 		.word	6
 11222 08c0 00000000 		.word	0
 11223 08c4 FFFF0000 		.word	65535
 11224 08c8 09010000 		.word	265
 11225 08cc 00000000 		.word	0
 11226 08d0 F71F0000 		.word	8183
 11227 08d4 00000000 		.word	0
 11228 08d8 FFFF0000 		.word	65535
 11229 08dc 09010000 		.word	265
 11230 08e0 00000000 		.word	0
 11231 08e4 F71F0000 		.word	8183
 11232 08e8 00000000 		.word	0
 11233 08ec 00000000 		.word	0
 11234 08f0 00000000 		.word	0
 11235 08f4 00000000 		.word	0
 11236 08f8 00000000 		.word	0
 11237 08fc 00000000 		.word	0
 11238 0900 00000000 		.word	0
 11239 0904 00000000 		.word	0
 11240 0908 00000000 		.word	0
 11241 090c 00000000 		.word	0
 11242 0910 00000000 		.word	0
 11243 0914 00000000 		.word	0
 11244 0918 00000000 		.word	0
 11245 091c 00000000 		.word	0
 11246 0920 00000000 		.word	0
 11247 0924 00000000 		.word	0
 11248 0928 00000000 		.word	0
 11249 092c 00000000 		.word	0
 11250 0930 00000000 		.word	0
 11251 0934 00000000 		.word	0
 11252 0938 00000000 		.word	0
 11253 093c 00000000 		.word	0
 11254 0940 00000000 		.word	0
 11255 0944 00040180 		.word	-2147417088
 11256 0948 01040180 		.word	-2147417087
 11257 094c 02040180 		.word	-2147417086
 11258 0950 03040180 		.word	-2147417085
 11259 0954 00000000 		.word	0
 11260 0958 00000000 		.word	0
 11261 095c 00000000 		.word	0
 11262 0960 00000000 		.word	0
 11263 0964 00000000 		.word	0
 11264 0968 00000000 		.word	0
 11265 096c 00000000 		.word	0
 11266 0970 00000000 		.word	0
 11267 0974 C1FFFFFF 		.word	-63
 11270              	CyFxGpifTransition_usb2:
 11271 0978 0000     		.short	0
 11272 097a 5555     		.short	21845
 11273 097c AAAA     		.short	-21846
 11274 097e 8888     		.short	-30584
 11275 0980 1111     		.short	4369
 11276 0982 4444     		.short	17476
 11277 0984 3333     		.short	13107
 11278 0986 CCCC     		.short	-13108
 11281              	CyFxGpifWavedata_usb2:
 11282 0988 0181731E 		.word	510886145
 11283 098c 00000000 		.word	0
 11284 0990 00000080 		.word	-2147483648
 11285 0994 00000000 		.word	0
 11286 0998 00000000 		.word	0
 11287 099c 00000000 		.word	0
 11288 09a0 0201703E 		.word	1047527682
 11289 09a4 00010000 		.word	256
 11290 09a8 A00000C0 		.word	-1073741664
 11291 09ac 00000000 		.word	0
 11292 09b0 00000000 		.word	0
 11293 09b4 00000000 		.word	0
 11294 09b8 0394731E 		.word	510891011
 11295 09bc 04000020 		.word	536870916
 11296 09c0 60004080 		.word	-2143289248
 11297 09c4 00000000 		.word	0
 11298 09c8 00000000 		.word	0
 11299 09cc 00000000 		.word	0
 11300 09d0 0620702E 		.word	779100166
 11301 09d4 0C000000 		.word	12
 11302 09d8 00000080 		.word	-2147483648
 11303 09dc 0620702E 		.word	779100166
 11304 09e0 0C000000 		.word	12
 11305 09e4 00000080 		.word	-2147483648
 11306 09e8 0394731E 		.word	510891011
 11307 09ec 04000020 		.word	536870916
 11308 09f0 60004080 		.word	-2143289248
 11309 09f4 0620702E 		.word	779100166
 11310 09f8 0C000000 		.word	12
 11311 09fc 00000080 		.word	-2147483648
 11312 0a00 0C93731E 		.word	510890764
 11313 0a04 04000024 		.word	603979780
 11314 0a08 90004080 		.word	-2143289200
 11315 0a0c 0D20702E 		.word	779100173
 11316 0a10 0C000000 		.word	12
 11317 0a14 00000080 		.word	-2147483648
 11318 0a18 0780724E 		.word	1316126727
 11319 0a1c 0A000000 		.word	10
 11320 0a20 00000080 		.word	-2147483648
 11321 0a24 08000000 		.word	8
 11322 0a28 00000000 		.word	0
 11323 0a2c 00010080 		.word	-2147483392
 11324 0a30 0920702E 		.word	779100169
 11325 0a34 0C010000 		.word	268
 11326 0a38 00000080 		.word	-2147483648
 11327 0a3c 0A01701E 		.word	510656778
 11328 0a40 0E000100 		.word	65550
 11329 0a44 00000080 		.word	-2147483648
 11330 0a48 00000000 		.word	0
 11331 0a4c 00000000 		.word	0
 11332 0a50 00000000 		.word	0
 11333 0a54 00000000 		.word	0
 11334 0a58 00000000 		.word	0
 11335 0a5c 00000000 		.word	0
 11336 0a60 0394731E 		.word	510891011
 11337 0a64 04000020 		.word	536870916
 11338 0a68 60004080 		.word	-2143289248
 11339 0a6c 08000000 		.word	8
 11340 0a70 00000000 		.word	0
 11341 0a74 00010080 		.word	-2147483392
 11342 0a78 0B000000 		.word	11
 11343 0a7c 00000000 		.word	0
 11344 0a80 00010080 		.word	-2147483392
 11345 0a84 0C93731E 		.word	510890764
 11346 0a88 04000024 		.word	603979780
 11347 0a8c 90004080 		.word	-2143289200
 11348 0a90 0D20702E 		.word	779100173
 11349 0a94 0C000000 		.word	12
 11350 0a98 00000080 		.word	-2147483648
 11351 0a9c 0D20702E 		.word	779100173
 11352 0aa0 0C000000 		.word	12
 11353 0aa4 00000080 		.word	-2147483648
 11354 0aa8 0E60724E 		.word	1316118542
 11355 0aac 0A000000 		.word	10
 11356 0ab0 00000080 		.word	-2147483648
 11357 0ab4 0F000000 		.word	15
 11358 0ab8 00000000 		.word	0
 11359 0abc 00010080 		.word	-2147483392
 11360 0ac0 1020702E 		.word	779100176
 11361 0ac4 0C010000 		.word	268
 11362 0ac8 00000080 		.word	-2147483648
 11363 0acc 1101701E 		.word	510656785
 11364 0ad0 0E000100 		.word	65550
 11365 0ad4 00000080 		.word	-2147483648
 11366 0ad8 0C93731E 		.word	510890764
 11367 0adc 04000024 		.word	603979780
 11368 0ae0 90004080 		.word	-2143289200
 11369 0ae4 0F000000 		.word	15
 11370 0ae8 00000000 		.word	0
 11371 0aec 00010080 		.word	-2147483392
 11372 0af0 12000000 		.word	18
 11373 0af4 00000000 		.word	0
 11374 0af8 00010080 		.word	-2147483392
 11375 0afc 0394731E 		.word	510891011
 11376 0b00 04000020 		.word	536870916
 11377 0b04 60004080 		.word	-2143289248
 11378 0b08 0480732E 		.word	779321348
 11379 0b0c 02010000 		.word	258
 11380 0b10 0000C0C0 		.word	-1061158912
 11381 0b14 0580732E 		.word	779321349
 11382 0b18 02010000 		.word	258
 11383 0b1c 0000C0C0 		.word	-1061158912
 11384 0b20 0580732E 		.word	779321349
 11385 0b24 02010000 		.word	258
 11386 0b28 0000C0C0 		.word	-1061158912
 11387 0b2c 0480732E 		.word	779321348
 11388 0b30 02010000 		.word	258
 11389 0b34 0000C0C0 		.word	-1061158912
 11392              	CyFxGpifWavedataPosition_usb2:
 11393 0b38 00       		.byte	0
 11394 0b39 01       		.byte	1
 11395 0b3a 02       		.byte	2
 11396 0b3b 03       		.byte	3
 11397 0b3c 04       		.byte	4
 11398 0b3d 05       		.byte	5
 11399 0b3e 06       		.byte	6
 11400 0b3f 07       		.byte	7
 11401 0b40 08       		.byte	8
 11402 0b41 09       		.byte	9
 11403 0b42 0A       		.byte	10
 11404 0b43 08       		.byte	8
 11405 0b44 0B       		.byte	11
 11406 0b45 0C       		.byte	12
 11407 0b46 0D       		.byte	13
 11408 0b47 08       		.byte	8
 11409 0b48 0E       		.byte	14
 11410 0b49 0F       		.byte	15
 11411 0b4a 08       		.byte	8
 11412 0b4b 08       		.byte	8
 11413 0b4c 08       		.byte	8
 11414 0b4d 08       		.byte	8
 11415 0b4e 08       		.byte	8
 11416 0b4f 08       		.byte	8
 11417 0b50 08       		.byte	8
 11418 0b51 08       		.byte	8
 11419 0b52 08       		.byte	8
 11420 0b53 08       		.byte	8
 11421 0b54 08       		.byte	8
 11422 0b55 08       		.byte	8
 11423 0b56 08       		.byte	8
 11424 0b57 08       		.byte	8
 11425 0b58 08       		.byte	8
 11426 0b59 08       		.byte	8
 11427 0b5a 08       		.byte	8
 11428 0b5b 08       		.byte	8
 11429 0b5c 08       		.byte	8
 11430 0b5d 08       		.byte	8
 11431 0b5e 08       		.byte	8
 11432 0b5f 08       		.byte	8
 11433 0b60 08       		.byte	8
 11434 0b61 08       		.byte	8
 11435 0b62 08       		.byte	8
 11436 0b63 08       		.byte	8
 11437 0b64 08       		.byte	8
 11438 0b65 08       		.byte	8
 11439 0b66 08       		.byte	8
 11440 0b67 08       		.byte	8
 11441 0b68 08       		.byte	8
 11442 0b69 08       		.byte	8
 11443 0b6a 08       		.byte	8
 11444 0b6b 08       		.byte	8
 11445 0b6c 08       		.byte	8
 11446 0b6d 08       		.byte	8
 11447 0b6e 08       		.byte	8
 11448 0b6f 08       		.byte	8
 11449 0b70 08       		.byte	8
 11450 0b71 08       		.byte	8
 11451 0b72 08       		.byte	8
 11452 0b73 08       		.byte	8
 11453 0b74 08       		.byte	8
 11454 0b75 08       		.byte	8
 11455 0b76 08       		.byte	8
 11456 0b77 08       		.byte	8
 11457 0b78 08       		.byte	8
 11458 0b79 08       		.byte	8
 11459 0b7a 08       		.byte	8
 11460 0b7b 08       		.byte	8
 11461 0b7c 08       		.byte	8
 11462 0b7d 08       		.byte	8
 11463 0b7e 08       		.byte	8
 11464 0b7f 08       		.byte	8
 11465 0b80 08       		.byte	8
 11466 0b81 08       		.byte	8
 11467 0b82 08       		.byte	8
 11468 0b83 08       		.byte	8
 11469 0b84 08       		.byte	8
 11470 0b85 08       		.byte	8
 11471 0b86 08       		.byte	8
 11472 0b87 08       		.byte	8
 11473 0b88 08       		.byte	8
 11474 0b89 08       		.byte	8
 11475 0b8a 08       		.byte	8
 11476 0b8b 08       		.byte	8
 11477 0b8c 08       		.byte	8
 11478 0b8d 08       		.byte	8
 11479 0b8e 08       		.byte	8
 11480 0b8f 08       		.byte	8
 11481 0b90 08       		.byte	8
 11482 0b91 08       		.byte	8
 11483 0b92 08       		.byte	8
 11484 0b93 08       		.byte	8
 11485 0b94 08       		.byte	8
 11486 0b95 08       		.byte	8
 11487 0b96 08       		.byte	8
 11488 0b97 08       		.byte	8
 11489 0b98 08       		.byte	8
 11490 0b99 08       		.byte	8
 11491 0b9a 08       		.byte	8
 11492 0b9b 08       		.byte	8
 11493 0b9c 08       		.byte	8
 11494 0b9d 08       		.byte	8
 11495 0b9e 08       		.byte	8
 11496 0b9f 08       		.byte	8
 11497 0ba0 08       		.byte	8
 11498 0ba1 08       		.byte	8
 11499 0ba2 08       		.byte	8
 11500 0ba3 08       		.byte	8
 11501 0ba4 08       		.byte	8
 11502 0ba5 08       		.byte	8
 11503 0ba6 08       		.byte	8
 11504 0ba7 08       		.byte	8
 11505 0ba8 08       		.byte	8
 11506 0ba9 08       		.byte	8
 11507 0baa 08       		.byte	8
 11508 0bab 08       		.byte	8
 11509 0bac 08       		.byte	8
 11510 0bad 08       		.byte	8
 11511 0bae 08       		.byte	8
 11512 0baf 08       		.byte	8
 11513 0bb0 08       		.byte	8
 11514 0bb1 08       		.byte	8
 11515 0bb2 08       		.byte	8
 11516 0bb3 08       		.byte	8
 11517 0bb4 08       		.byte	8
 11518 0bb5 08       		.byte	8
 11519 0bb6 08       		.byte	8
 11520 0bb7 08       		.byte	8
 11521 0bb8 00       		.byte	0
 11522 0bb9 01       		.byte	1
 11523 0bba 02       		.byte	2
 11524 0bbb 10       		.byte	16
 11525 0bbc 04       		.byte	4
 11526 0bbd 05       		.byte	5
 11527 0bbe 06       		.byte	6
 11528 0bbf 07       		.byte	7
 11529 0bc0 08       		.byte	8
 11530 0bc1 09       		.byte	9
 11531 0bc2 0A       		.byte	10
 11532 0bc3 08       		.byte	8
 11533 0bc4 11       		.byte	17
 11534 0bc5 0C       		.byte	12
 11535 0bc6 0D       		.byte	13
 11536 0bc7 08       		.byte	8
 11537 0bc8 0E       		.byte	14
 11538 0bc9 0F       		.byte	15
 11539 0bca 08       		.byte	8
 11540 0bcb 00       		.space	1
 11543              	CyFxGpifRegValue_usb2:
 11544 0bcc 08830080 		.word	-2147450104
 11545 0bd0 67000000 		.word	103
 11546 0bd4 01000000 		.word	1
 11547 0bd8 46000000 		.word	70
 11548 0bdc 00000000 		.word	0
 11549 0be0 00000000 		.word	0
 11550 0be4 02000000 		.word	2
 11551 0be8 82000000 		.word	130
 11552 0bec 82070000 		.word	1922
 11553 0bf0 40040000 		.word	1088
 11554 0bf4 FCFF0000 		.word	65532
 11555 0bf8 28000000 		.word	40
 11556 0bfc 00000000 		.word	0
 11557 0c00 00000000 		.word	0
 11558 0c04 00000000 		.word	0
 11559 0c08 00000000 		.word	0
 11560 0c0c 01000000 		.word	1
 11561 0c10 00000000 		.word	0
 11562 0c14 00000000 		.word	0
 11563 0c18 00000000 		.word	0
 11564 0c1c 00000000 		.word	0
 11565 0c20 00000000 		.word	0
 11566 0c24 00000000 		.word	0
 11567 0c28 00000000 		.word	0
 11568 0c2c 00000000 		.word	0
 11569 0c30 00000000 		.word	0
 11570 0c34 00000000 		.word	0
 11571 0c38 00000000 		.word	0
 11572 0c3c 00000000 		.word	0
 11573 0c40 06000000 		.word	6
 11574 0c44 00000000 		.word	0
 11575 0c48 FFFF0000 		.word	65535
 11576 0c4c 09010000 		.word	265
 11577 0c50 00000000 		.word	0
 11578 0c54 F71F0000 		.word	8183
 11579 0c58 00000000 		.word	0
 11580 0c5c FFFF0000 		.word	65535
 11581 0c60 09010000 		.word	265
 11582 0c64 00000000 		.word	0
 11583 0c68 F71F0000 		.word	8183
 11584 0c6c 00000000 		.word	0
 11585 0c70 00000000 		.word	0
 11586 0c74 00000000 		.word	0
 11587 0c78 00000000 		.word	0
 11588 0c7c 00000000 		.word	0
 11589 0c80 00000000 		.word	0
 11590 0c84 00000000 		.word	0
 11591 0c88 00000000 		.word	0
 11592 0c8c 00000000 		.word	0
 11593 0c90 00000000 		.word	0
 11594 0c94 00000000 		.word	0
 11595 0c98 00000000 		.word	0
 11596 0c9c 00000000 		.word	0
 11597 0ca0 00000000 		.word	0
 11598 0ca4 00000000 		.word	0
 11599 0ca8 00000000 		.word	0
 11600 0cac 00000000 		.word	0
 11601 0cb0 00000000 		.word	0
 11602 0cb4 00000000 		.word	0
 11603 0cb8 00000000 		.word	0
 11604 0cbc 00000000 		.word	0
 11605 0cc0 00000000 		.word	0
 11606 0cc4 00000000 		.word	0
 11607 0cc8 00040180 		.word	-2147417088
 11608 0ccc 01040180 		.word	-2147417087
 11609 0cd0 02040180 		.word	-2147417086
 11610 0cd4 03040180 		.word	-2147417085
 11611 0cd8 00000000 		.word	0
 11612 0cdc 00000000 		.word	0
 11613 0ce0 00000000 		.word	0
 11614 0ce4 00000000 		.word	0
 11615 0ce8 00000000 		.word	0
 11616 0cec 00000000 		.word	0
 11617 0cf0 00000000 		.word	0
 11618 0cf4 00000000 		.word	0
 11619 0cf8 C1FFFFFF 		.word	-63
 11620              		.section	.rodata.str1.4,"aMS",%progbits,1
 11621              		.align	2
 11622              	.LC0:
 11623 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 11623      7065722D 
 11623      74696D65 
 11623      72202564 
 11623      0D0A00
 11624 0013 00       		.space	1
 11625              	.LC1:
 11626 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 11626      636F6D6D 
 11626      616E6420 
 11626      71756575 
 11626      65206973 
 11627 0037 00       		.space	1
 11628              	.LC2:
 11629 0038 49324320 		.ascii	"I2C pos-timer %d %d\015\012\000"
 11629      706F732D 
 11629      74696D65 
 11629      72202564 
 11629      2025640D 
 11630 004e 0000     		.space	2
 11631              	.LC3:
 11632 0050 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 11632      5420656E 
 11632      636F756E 
 11632      74657265 
 11632      642E2E2E 
 11633              	.LC4:
 11634 0070 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 11634      454E4420 
 11634      656E636F 
 11634      756E7465 
 11634      7265642E 
 11635 0092 0000     		.space	2
 11636              	.LC5:
 11637 0094 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 11637      64697363 
 11637      6F6E6E65 
 11637      63746564 
 11637      2E2E2E30 
 11638 00b3 00       		.space	1
 11639              	.LC6:
 11640 00b4 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 11640      7220696E 
 11640      206D756C 
 11640      74696368 
 11640      616E6E65 
 11641 00e7 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 11641      2025782C 
 11641      20646D61 
 11641      446F6E65 
 11641      20256420 
 11642              	.LC7:
 11643 0100 626D5265 		.ascii	"bmReqType = 0x%x bRequest = 0x%x wValue = 0x%x wInd"
 11643      71547970 
 11643      65203D20 
 11643      30782578 
 11643      20625265 
 11644 0133 6578203D 		.ascii	"ex = 0x%x wLength = 0x%x isflag 0x%x\015\012\000"
 11644      20307825 
 11644      7820774C 
 11644      656E6774 
 11644      68203D20 
 11645 015a 0000     		.space	2
 11646              	.LC8:
 11647 015c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 11647      43595F46 
 11647      585F5556 
 11647      435F5649 
 11647      44454F5F 
 11648 018f 0A00     		.ascii	"\012\000"
 11649 0191 000000   		.space	3
 11650              	.LC9:
 11651 0194 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 11651      43595F46 
 11651      585F5556 
 11651      435F5649 
 11651      44454F5F 
 11652 01c7 00       		.ascii	"\000"
 11653              	.LC10:
 11654 01c8 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 11654      726E6174 
 11654      65207365 
 11654      7474696E 
 11654      6720302E 
 11655              	.LC11:
 11656 01e0 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 11656      72206665 
 11656      61747572 
 11656      65207265 
 11656      71756573 
 11657 0203 00       		.space	1
 11658              	.LC12:
 11659 0204 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 11659      6F6D6D69 
 11659      74656F66 
 11659      20737461 
 11659      7465203D 
 11660              	.LC13:
 11661 021c 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 11661      6E656C20 
 11661      53657420 
 11661      57726170 
 11661      55702066 
 11662 0249 000000   		.space	3
 11663              	.LC14:
 11664 024c 4572726F 		.ascii	"Error handler...\015\012\000"
 11664      72206861 
 11664      6E646C65 
 11664      722E2E2E 
 11664      0D0A00
 11665 025f 00       		.space	1
 11666              	.LC15:
 11667 0260 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 11667      69742045 
 11667      4F462066 
 11667      61696C65 
 11667      64210D0A 
 11668 0275 000000   		.space	3
 11669              	.LC16:
 11670 0278 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 11670      49324320 
 11670      636F6D6D 
 11670      616E6420 
 11670      69732030 
 11671 02ab 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 11671      78257820 
 11671      30782578 
 11671      20307825 
 11671      78203078 
 11672              	.LC17:
 11673 02c4 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 11673      49324320 
 11673      636F6D6D 
 11673      616E6420 
 11673      73657474 
 11674 02ea 0000     		.space	2
 11675              	.LC18:
 11676 02ec 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 11676      43595F46 
 11676      585F5556 
 11676      435F5354 
 11676      5245414D 
 11677 0312 0000     		.space	2
 11678              	.LC19:
 11679 0314 54686520 		.ascii	"The shutter set value %d 0x%x 0x%x 0x%x\015\012\000"
 11679      73687574 
 11679      74657220 
 11679      73657420 
 11679      76616C75 
 11680 033e 0000     		.space	2
 11681              	.LC20:
 11682 0340 74657374 		.ascii	"test shutter speed. 0x%x 0x%x 0x%x\015\012\000"
 11682      20736875 
 11682      74746572 
 11682      20737065 
 11682      65642E20 
 11683 0365 000000   		.space	3
 11684              	.LC21:
 11685 0368 74657374 		.ascii	"test shutter speed2. 0x%x 0x%x 0x%x\015\012\000"
 11685      20736875 
 11685      74746572 
 11685      20737065 
 11685      6564322E 
 11686 038e 0000     		.space	2
 11687              	.LC22:
 11688 0390 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 11688      206C6967 
 11688      68742063 
 11688      6F6D7065 
 11688      6E736174 
 11689 03c3 25640D0A 		.ascii	"%d\015\012\000"
 11689      00
 11690              	.LC23:
 11691 03c8 54686520 		.ascii	"The I2C current data is not available. try again. %"
 11691      49324320 
 11691      63757272 
 11691      656E7420 
 11691      64617461 
 11692 03fb 64202564 		.ascii	"d %d\015\012\000"
 11692      0D0A00
 11693 0402 0000     		.space	2
 11694              	.LC24:
 11695 0404 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 11695      26414743 
 11695      2073656E 
 11695      7420746F 
 11695      20686F73 
 11696 042a 0000     		.space	2
 11697              	.LC25:
 11698 042c 54686520 		.ascii	"The shutter&exposure 0x%x 0x%x 0x%x 0x%x\015\012\000"
 11698      73687574 
 11698      74657226 
 11698      6578706F 
 11698      73757265 
 11699 0457 00       		.space	1
 11700              	.LC26:
 11701 0458 4578704D 		.ascii	"ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\015"
 11701      26414743 
 11701      20676F74 
 11701      74656E20 
 11701      66726F6D 
 11702 0489 0A00     		.ascii	"\012\000"
 11703 048b 00       		.space	1
 11704              	.LC27:
 11705 048c 53687574 		.ascii	"Shutter level gotten from host. 0x%x %d; 0x%x 0x%x "
 11705      74657220 
 11705      6C657665 
 11705      6C20676F 
 11705      7474656E 
 11706 04bf 25640D0A 		.ascii	"%d\015\012\000"
 11706      00
 11707              	.LC28:
 11708 04c4 46726571 		.ascii	"Frequency setting is  %d %d\015\012\000"
 11708      75656E63 
 11708      79207365 
 11708      7474696E 
 11708      67206973 
 11709 04e2 0000     		.space	2
 11710              	.LC29:
 11711 04e4 46536574 		.ascii	"FSet the video mode format %x %d\012\000"
 11711      20746865 
 11711      20766964 
 11711      656F206D 
 11711      6F646520 
 11712 0506 0000     		.space	2
 11713              	.LC30:
 11714 0508 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 11714      67657420 
 11714      64617461 
 11714      2066726F 
 11714      6D20686F 
 11715 0535 000000   		.space	3
 11716              	.LC31:
 11717 0538 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 11717      52657175 
 11717      65737420 
 11717      30782578 
 11717      20706172 
 11718 056b 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 11718      6E642074 
 11718      6F20686F 
 11718      73742030 
 11718      78257820 
 11719 0586 0000     		.space	2
 11720              	.LC32:
 11721 0588 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 11721      204F7020 
 11721      72656365 
 11721      69766573 
 11721      20284354 
 11722 05af 00       		.space	1
 11723              	.LC33:
 11724 05b0 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 11724      756C7420 
 11724      73656C65 
 11724      63746F72 
 11724      20284354 
 11725 05d2 0000     		.space	2
 11726              	.LC34:
 11727 05d4 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 11727      756C7420 
 11727      72657175 
 11727      65737420 
 11727      28435429 
 11728 05f5 000000   		.space	3
 11729              	.LC35:
 11730 05f8 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 11730      52657175 
 11730      65737420 
 11730      30782578 
 11730      20706172 
 11731 062b 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 11731      20307825 
 11731      78202F20 
 11731      73656E64 
 11731      20746F20 
 11732 0658 00       		.ascii	"\000"
 11733 0659 000000   		.space	3
 11734              	.LC36:
 11735 065c 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 11735      64656661 
 11735      756C7420 
 11735      73657475 
 11735      70207265 
 11736              	.LC37:
 11737 0688 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 11737      6F207374 
 11737      7265616D 
 11737      20474554 
 11737      20726571 
 11738 06ad 000000   		.space	3
 11739              	.LC38:
 11740 06b0 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 11740      74686520 
 11740      76696465 
 11740      6F206D6F 
 11740      64652066 
 11741 06d1 000000   		.space	3
 11742              	.LC39:
 11743 06d4 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 11743      74686520 
 11743      76696465 
 11743      6F206D6F 
 11743      64652066 
 11744 06f9 000000   		.space	3
 11745              	.LC40:
 11746 06fc 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 11746      55564320 
 11746      7374696C 
 11746      6C205072 
 11746      6F622873 
 11747 0727 00       		.space	1
 11748              	.LC41:
 11749 0728 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 11749      74686520 
 11749      7374696C 
 11749      6C206D6F 
 11749      64652066 
 11750 0749 000000   		.space	3
 11751              	.LC42:
 11752 074c 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 11752      7374696C 
 11752      6C20636F 
 11752      6D6D6974 
 11752      20636F6E 
 11753              	.LC43:
 11754 0774 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 11754      43595F46 
 11754      585F5556 
 11754      435F5354 
 11754      494C5F45 
 11755              	.LC44:
 11756 0798 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 11756      55564320 
 11756      7374696C 
 11756      6C207472 
 11756      69676765 
 11757 07c1 000000   		.space	3
 11758              	.LC45:
 11759 07c4 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 11759      7374696C 
 11759      6C207472 
 11759      69676765 
 11759      7220636F 
 11760 07eb 00       		.space	1
 11761              	.LC46:
 11762 07ec 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 11762      65642074 
 11762      6F207365 
 11762      6E642069 
 11762      6E746572 
 11763 081d 0A00     		.ascii	"\012\000"
 11764 081f 00       		.space	1
 11765              	.LC47:
 11766 0820 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 11766      73657420 
 11766      64656620 
 11766      64617461 
 11766      20307825 
 11767 083f 00       		.space	1
 11768              	.LC48:
 11769 0840 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 11769      73657420 
 11769      64656620 
 11769      64617461 
 11769      20307825 
 11770 0873 2E0D0A00 		.ascii	".\015\012\000"
 11771 0877 00       		.space	1
 11772              	.LC49:
 11773 0878 55415254 		.ascii	"UART initialization failed!\012\000"
 11773      20696E69 
 11773      7469616C 
 11773      697A6174 
 11773      696F6E20 
 11774 0895 000000   		.space	3
 11775              	.LC50:
 11776 0898 49324320 		.ascii	"I2C initialization failed!\012\000"
 11776      696E6974 
 11776      69616C69 
 11776      7A617469 
 11776      6F6E2066 
 11777              	.LC51:
 11778 08b4 49324320 		.ascii	"I2C configuration failed!\012\000"
 11778      636F6E66 
 11778      69677572 
 11778      6174696F 
 11778      6E206661 
 11779 08cf 00       		.space	1
 11780              	.LC52:
 11781 08d0 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 11781      43726561 
 11781      74652045 
 11781      76656E74 
 11781      20666169 
 11782 08fa 0000     		.space	2
 11783              	.LC53:
 11784 08fc 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 11784      20496E69 
 11784      74206661 
 11784      696C6564 
 11784      2C204572 
 11785 091f 00       		.space	1
 11786              	.LC54:
 11787 0920 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 11787      204F7665 
 11787      72726964 
 11787      65206661 
 11787      696C6564 
 11788 0947 00       		.space	1
 11789              	.LC55:
 11790 0948 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 11790      28323029 
 11790      204F7665 
 11790      72726964 
 11790      65206661 
 11791 0973 00       		.space	1
 11792              	.LC56:
 11793 0974 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 11793      28323429 
 11793      204F7665 
 11793      72726964 
 11793      65206661 
 11794 099f 00       		.space	1
 11795              	.LC57:
 11796 09a0 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 11796      20536574 
 11796      20287265 
 11796      73657420 
 11796      32322920 
 11797 09d2 00       		.ascii	"\000"
 11798 09d3 00       		.space	1
 11799              	.LC58:
 11800 09d4 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 11800      20536574 
 11800      2028706F 
 11800      77657220 
 11800      32302920 
 11801 0a06 00       		.ascii	"\000"
 11802 0a07 00       		.space	1
 11803              	.LC59:
 11804 0a08 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 11804      20536574 
 11804      2028736E 
 11804      61702073 
 11804      686F7420 
 11805 0a3b 25640A00 		.ascii	"%d\012\000"
 11806 0a3f 00       		.space	1
 11807              	.LC60:
 11808 0a40 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 11808      46756E63 
 11808      74696F6E 
 11808      20466169 
 11808      6C656420 
 11809 0a6f 00       		.space	1
 11810              	.LC61:
 11811 0a70 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 11811      46756E63 
 11811      74696F6E 
 11811      20466169 
 11811      6C656420 
 11812 0a9f 00       		.space	1
 11813              	.LC62:
 11814 0aa0 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 11814      53657420 
 11814      456E6470 
 11814      6F696E74 
 11814      20636F6E 
 11815 0ad0 00       		.ascii	"\000"
 11816 0ad1 000000   		.space	3
 11817              	.LC63:
 11818 0ad4 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 11818      496E7465 
 11818      72727570 
 11818      74205374 
 11818      61747573 
 11819 0b07 20436F64 		.ascii	" Code = %d\012\000"
 11819      65203D20 
 11819      25640A00 
 11820 0b13 00       		.space	1
 11821              	.LC64:
 11822 0b14 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 11822      65642074 
 11822      6F20616C 
 11822      6C6F6361 
 11822      7465206D 
 11823 0b47 65720D0A 		.ascii	"er\015\012\000"
 11823      00
 11824              	.LC65:
 11825 0b4c 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 11825      4368616E 
 11825      6E656C20 
 11825      43726561 
 11825      74696F6E 
 11826 0b7a 0000     		.space	2
 11827              	.LC66:
 11828 0b7c 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 11828      436F6E6E 
 11828      65637420 
 11828      6661696C 
 11828      65642C20 
 11829 0ba1 000000   		.space	3
 11830              	.LC67:
 11831 0ba4 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 11831      74686520 
 11831      76696465 
 11831      6F206D6F 
 11831      64652066 
 11832 0bc6 0000     		.space	2
 11833              	.LC68:
 11834 0bc8 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 11834      4368616E 
 11834      6E656C20 
 11834      52657365 
 11834      74204661 
 11835 0bf3 00       		.space	1
 11836              	.LC69:
 11837 0bf4 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 11837      4368616E 
 11837      6E656C20 
 11837      53657420 
 11837      5472616E 
 11838 0c25 00       		.ascii	"\000"
 11839 0c26 0000     		.space	2
 11840              	.LC70:
 11841 0c28 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 11841      4368616E 
 11841      6E656C20 
 11841      53657420 
 11841      5472616E 
 11842 0c59 0A00     		.ascii	"\012\000"
 11843 0c5b 00       		.space	1
 11844              	.LC71:
 11845 0c5c 0D0A2073 		.ascii	"\015\012 super gpif\000"
 11845      75706572 
 11845      20677069 
 11845      6600
 11846 0c6a 0000     		.space	2
 11847              	.LC72:
 11848 0c6c 0D0A2068 		.ascii	"\015\012 high gpif\000"
 11848      69676820 
 11848      67706966 
 11848      00
 11849 0c79 000000   		.space	3
 11850              	.LC73:
 11851 0c7c 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 11851      696E6720 
 11851      47504946 
 11851      20436F6E 
 11851      66696775 
 11852 0caf 0A00     		.ascii	"\012\000"
 11853 0cb1 000000   		.space	3
 11854              	.LC74:
 11855 0cb4 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 11855      74696E67 
 11855      20475049 
 11855      46207374 
 11855      61746520 
 11856 0ce7 0D0A00   		.ascii	"\015\012\000"
 11857 0cea 0000     		.space	2
 11858              	.LC75:
 11859 0cec 49324363 		.ascii	"I2CcmdQue\000"
 11859      6D645175 
 11859      6500
 11860 0cf6 0000     		.space	2
 11861              	.LC76:
 11862 0cf8 33303A55 		.ascii	"30:UVC App Thread\000"
 11862      56432041 
 11862      70702054 
 11862      68726561 
 11862      6400
 11863 0d0a 0000     		.space	2
 11864              	.LC77:
 11865 0d0c 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 11865      56432041 
 11865      70702045 
 11865      50302054 
 11865      68726561 
 11866 0d22 0000     		.space	2
 11867              	.LC78:
 11868 0d24 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 11868      32432041 
 11868      70702043 
 11868      54524C20 
 11868      54687265 
 11869 0d3b 00       		.bss
 11870              		.align	2
 11871              		.set	.LANCHOR0,. + 0
 11874              	glFxUVCEvent:
 11875 0000 00000000 		.space	40
 11875      00000000 
 11875      00000000 
 11875      00000000 
 11875      00000000 
 11878              	debugData:
 11879 0028 00000000 		.space	128
 11879      00000000 
 11879      00000000 
 11879      00000000 
 11879      00000000 
 11882              	gpif_initialized:
 11883 00a8 00000000 		.space	4
 11886              	streamingStarted:
 11887 00ac 00000000 		.space	4
 11890              	isUsbConnected:
 11891 00b0 00000000 		.space	4
 11894              	fb:
 11895 00b4 0000     		.space	2
 11898              	pb:
 11899 00b6 0000     		.space	2
 11902              	pbc:
 11903 00b8 0000     		.space	2
 11906              	stiflag:
 11907 00ba 00       		.space	1
 11908 00bb 00       		.space	1
 11911              	hitFV:
 11912 00bc 00000000 		.space	4
 11915              	prodCount:
 11916 00c0 0000     		.space	2
 11919              	consCount:
 11920 00c2 0000     		.space	2
 11923              	clearFeatureRqtReceived:
 11924 00c4 00000000 		.space	4
 11927              	usbSpeed:
 11928 00c8 00       		.space	1
 11929 00c9 000000   		.space	3
 11932              	I2CCMDArry:
 11933 00cc 00000000 		.space	12
 11933      00000000 
 11933      00000000 
 11936              	is60Hz:
 11937 00d8 00000000 		.space	4
 11940              	value:
 11941 00dc 00000000 		.space	64
 11941      00000000 
 11941      00000000 
 11941      00000000 
 11941      00000000 
 11944              	glEp0Buffer:
 11945 011c 00000000 		.space	32
 11945      00000000 
 11945      00000000 
 11945      00000000 
 11945      00000000 
 11948              	curFlag:
 11949 013c 00000000 		.space	64
 11949      00000000 
 11949      00000000 
 11949      00000000 
 11949      00000000 
 11952              	CamMode:
 11953 017c 00       		.space	1
 11956              	setRes:
 11957 017d 00       		.space	1
 11958 017e 0000     		.space	2
 11961              	glCommitCtrl:
 11962 0180 00000000 		.space	32
 11962      00000000 
 11962      00000000 
 11962      00000000 
 11962      00000000 
 11965              	setstilRes:
 11966 01a0 00       		.space	1
 11969              	IMcount.7865:
 11970 01a1 00       		.space	1
 11971 01a2 0000     		.space	2
 11974              	uvcAppThread:
 11975 01a4 00000000 		.space	168
 11975      00000000 
 11975      00000000 
 11975      00000000 
 11975      00000000 
 11978              	uvcAppEP0Thread:
 11979 024c 00000000 		.space	168
 11979      00000000 
 11979      00000000 
 11979      00000000 
 11979      00000000 
 11982              	i2cAppThread:
 11983 02f4 00000000 		.space	168
 11983      00000000 
 11983      00000000 
 11983      00000000 
 11983      00000000 
 11986              	testSnap:
 11987 039c 00       		.space	1
 11988 039d 00       		.space	1
 11991              	fbbak:
 11992 039e 0000     		.space	2
 11995              	pbbak:
 11996 03a0 0000     		.space	2
 11999              	pbcbak:
 12000 03a2 0000     		.space	2
 12003              	pbcpbak:
 12004 03a4 0000     		.space	2
 12005 03a6 0000     		.space	2
 12008              	streamingRecove:
 12009 03a8 00000000 		.space	4
 12010              		.text
 12011              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:199    .text:00000168 $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:205    .text:00000178 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:306    .text:0000023c $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:320    .text:0000025c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:317    .text:0000025c $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:354    .text:0000028c $d
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:360    .text:00000298 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:362    .text:00000298 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:564    .text:0000041c $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:573    .text:0000042c $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:576    .text:0000042c CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:798    .text:000005cc $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:808    .text:000005e8 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:810    .text:000005e8 CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:1200   .text:00000960 $d
                            *COM*:00000001 bRequest
                            *COM*:00000001 bmReqType
                            *COM*:00000002 wLength
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:1218   .text:00000994 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:1221   .text:00000994 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:1258   .text:000009cc $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:1271   .text:000009f8 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:1318   .text:00000a4c $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:1325   .text:00000a5c $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:1343   .text:00000a78 $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:1352   .text:00000a90 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:1355   .text:00000a90 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:1700   .text:00000de0 $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:1709   .text:00000df8 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:1712   .text:00000df8 setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:1775   .text:00000e78 getShutCtrl
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:1798   .text:00000e90 $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:1811   .text:00000eb8 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:1917   .text:00000fac $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:1925   .text:00000fc0 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:1928   .text:00000fc0 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:2140   .text:0000115c $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:2182   .text:000011f8 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:2248   .text:00001278 $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:2289   .text:00001314 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:3648   .text:00001ef4 $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:3671   .text:00001f44 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:4076   .text:000022fc $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:4082   .text:0000230c $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:4685   .text:0000282c CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:4853   .text:00002988 $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:4866   .text:000029b0 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:5361   .text:00002ec0 $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:5372   .text:00002ee0 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:5634   .text:0000319c $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:5647   .text:000031c4 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:5650   .text:000031c4 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:5708   .text:00003238 $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:5716   .text:00003248 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:6180   .text:000036ac $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:6187   .text:000036bc $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:6656   .text:00003a9c $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:6663   .text:00003aac $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:7148   .text:00003f10 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:7180   .text:00003f7c $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:7183   .text:00003f7c CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:7476   .text:00004238 $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:7483   .text:00004248 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:7486   .text:00004248 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:7527   .text:0000428c $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:7532   .text:00004294 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:7535   .text:00004294 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:7560   .text:000042b0 $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:7564   .text:000042b4 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:7567   .text:000042b4 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:8949   .text:00004d9c $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:8955   .text:00004dac $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:9071   .text:00004f14 $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:9130   .text:00004ff4 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:9133   .text:00004ff4 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:9279   .text:0000514c $d
                            *COM*:00000038 cmdQuMux
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:9295   .text:00005180 $a
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:9298   .text:00005180 main
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11088  .data:0000070c CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11097  .data:00000718 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11172  .data:00000838 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11191  .data:00000848 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:9458   .rodata:00000020 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11270  .data:00000978 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11281  .data:00000988 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11392  .data:00000b38 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11543  .data:00000bcc CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:9471   .rodata:0000003c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11084  .data:0000070b snapButFlag
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11986  .bss:0000039c testSnap
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11894  .bss:000000b4 fb
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11898  .bss:000000b6 pb
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11902  .bss:000000b8 pbc
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11991  .bss:0000039e fbbak
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11995  .bss:000003a0 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11999  .bss:000003a2 pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:12003  .bss:000003a4 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11890  .bss:000000b0 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11927  .bss:000000c8 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11923  .bss:000000c4 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:12008  .bss:000003a8 streamingRecove
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11886  .bss:000000ac streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11025  .data:000006d8 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:10965  .data:000006a0 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11055  .data:000006f4 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:10995  .data:000006bc glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11070  .data:00000700 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:10453  .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 staQuMux
                            *COM*:00000038 timMux
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:9439   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:9443   .rodata:00000000 ShutSp
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:9483   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:9487   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:9810   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:10468  .data:0000048c dbgIdx
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:10472  .data:0000048d ROIMode
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:10476  .data:0000048e valIdx
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:10481  .data:00000490 EXTBLCWinPos
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:10503  .data:000004a4 EXTBLCWeight
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:10525  .data:000004b8 EXTShutter
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:10547  .data:000004cc EXTShutlev
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:10569  .data:000004e0 EXTAexModGainlev
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:10591  .data:000004f4 WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:10598  .data:000004f8 PUCBLC
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:10620  .data:0000050c PUCSharp
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:10642  .data:00000520 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11621  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11870  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11874  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11878  .bss:00000028 debugData
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11882  .bss:000000a8 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11906  .bss:000000ba stiflag
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11911  .bss:000000bc hitFV
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11915  .bss:000000c0 prodCount
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11919  .bss:000000c2 consCount
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11932  .bss:000000cc I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11936  .bss:000000d8 is60Hz
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11940  .bss:000000dc value
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11944  .bss:0000011c glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11948  .bss:0000013c curFlag
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11952  .bss:0000017c CamMode
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11956  .bss:0000017d setRes
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11961  .bss:00000180 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11965  .bss:000001a0 setstilRes
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11969  .bss:000001a1 IMcount.7865
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11974  .bss:000001a4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11978  .bss:0000024c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccaP7NNZ.s:11982  .bss:000002f4 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PGpifDisable
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PUsbAckSetup
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PDmaMultiChannelSetWrapUp
SensorRead2B
SensorWrite2B
cmdSet
SensorWrite2B2
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
SensorGetControl
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifLoad
CyU3PGpifSMStart
CyU3PGpifSMSwitch
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
