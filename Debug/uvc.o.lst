   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB26:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      ****                                                            received. */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 214:../uvc.c      ****                                                            the current video frame. */
 215:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 216:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 217:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 218:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 219:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 220:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 221:../uvc.c      **** 
 222:../uvc.c      **** /************ control parameters array ***********
 223:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 224:../uvc.c      ****  *    e.g.
 225:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 226:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 227:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 228:../uvc.c      ****  **************************************************/
 229:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 230:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 231:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 232:../uvc.c      **** 		{/*0*/BLCModeRegAct       , BLCModeRegAct        , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,
 233:../uvc.c      **** 		{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 234:../uvc.c      **** 		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1, 
 235:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 236:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 237:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 238:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 239:../uvc.c      **** 		{/*7*/SharpnessReg1       , SharpnessReg1        , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,
 240:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 241:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 242:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 243:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 244:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 245:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 246:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 247:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 248:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 253:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 254:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 255:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 256:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 257:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 258:../uvc.c      **** 		{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 259:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 260:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 261:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 262:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 263:../uvc.c      **** 		/**********************************
 264:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 265:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 266:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 267:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 268:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 269:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 270:../uvc.c      **** 		 *
 271:../uvc.c      **** 		 *********************************/
 272:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 273:../uvc.c      **** };
 274:../uvc.c      **** #if 1 // the new control structure
 275:../uvc.c      **** /* the processing unit control request */
 276:../uvc.c      **** //		{ 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,   0, I2C_EAGLESDP_ADDR,  CyTrue, CyFalse,
 277:../uvc.c      **** 
 278:../uvc.c      **** volatile static SensorCtrl PUCBLC =
 279:../uvc.c      **** 		{BLCModeRegAct,		//Reg1: the command register address1
 280:../uvc.c      **** 		 BLCModeRegGain,	//Reg2: the command register address2
 281:../uvc.c      **** 		 2,					//UVCLn: the command length
 282:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 283:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 284:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 285:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 286:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 287:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 288:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 289:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 290:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 291:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 292:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 293:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 294:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 295:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 296:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 297:../uvc.c      **** 		}; //
 298:../uvc.c      **** //volatile static SensorCtrl PUCBright;
 299:../uvc.c      **** //volatile static SensorCtrl PUCContrast;
 300:../uvc.c      **** //volatile static SensorCtrl PUCGain;
 301:../uvc.c      **** //volatile static SensorCtrl PUCPLFreq;
 302:../uvc.c      **** //volatile static SensorCtrl PUCHueC;
 303:../uvc.c      **** //volatile static SensorCtrl PUCSaturation;
 304:../uvc.c      **** volatile static SensorCtrl PUCSharp =
 305:../uvc.c      **** 		{SharpnessReg1,		//Reg1: the command register address1
 306:../uvc.c      **** 		 SharpnessReg2,		//Reg2: the command register address2
 307:../uvc.c      **** 		 2,					//UVCLn: the command length
 308:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 309:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 310:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 311:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 312:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 313:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 314:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 315:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 316:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 317:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 318:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 319:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 320:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 321:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 322:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 323:../uvc.c      **** 		}; //sharpness, Reg1: 0-disable & 1-enable; Reg2: 0x00~0xFF.
 324:../uvc.c      **** //volatile static SensorCtrl PUCWBLC; //?
 325:../uvc.c      **** //volatile static SensorCtrl PUCDZoom;
 326:../uvc.c      **** 
 327:../uvc.c      **** volatile static SensorCtrl *pPUCSenCtrl[0x10] = {
 328:../uvc.c      **** 	&PUCBLC,
 329:../uvc.c      **** 	0, //&PUCBright,
 330:../uvc.c      **** 	0, //&PUCContrast,
 331:../uvc.c      **** 	0, //&PUCGain (AGC?)
 332:../uvc.c      **** 	0, //&PUCPLFreq,
 333:../uvc.c      **** 	0, //&PUCHueC,
 334:../uvc.c      **** 	0, //&PUCSaturation,
 335:../uvc.c      **** 	&PUCSharp,
 336:../uvc.c      **** 	0, //&PUCGamGain,
 337:../uvc.c      **** 	0, //&PUCWBMd,
 338:../uvc.c      **** 	0, //UVCCtlID10,
 339:../uvc.c      **** 	0, //&PUCWBLC,
 340:../uvc.c      **** 	0, //UVCCtlID12,
 341:../uvc.c      **** 	0, //UVCCtlID13,
 342:../uvc.c      **** 	0, //&PUCDZoom,
 343:../uvc.c      **** 	0 //UVCCtlID15
 344:../uvc.c      **** };
 345:../uvc.c      **** 
 346:../uvc.c      **** /* the Camera terminal control request */
 347:../uvc.c      **** //volatile static SensorCtrl CTCAutoExMode;
 348:../uvc.c      **** //volatile static SensorCtrl CTCExposureTAbs;
 349:../uvc.c      **** //volatile static SensorCtrl CTCFocusRel;
 350:../uvc.c      **** //volatile static SensorCtrl CTCIrisAbs;
 351:../uvc.c      **** //volatile static SensorCtrl CTCOPZoomAbs;
 352:../uvc.c      **** 
 353:../uvc.c      **** /* the Extentsion control request */
 354:../uvc.c      **** volatile static SensorCtrl EXTShutter =
 355:../uvc.c      **** 		{ShutterReg,		//Reg1: the command register address1
 356:../uvc.c      **** 		 0x02/*ShutterReg*/,		//Reg2: the command register address2
 357:../uvc.c      **** 		 2,					//UVCLn: the command length
 358:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 359:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 360:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 361:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 362:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 363:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 364:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 365:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 366:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 367:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 368:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 369:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 370:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 371:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 372:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 373:../uvc.c      **** 		}; //shutter control 0 ~ 0x12
 374:../uvc.c      **** /*volatile static SensorCtrl EXTSensUp =
 375:../uvc.c      **** 		{SenseUpReg,		//Reg1: the command register address1
 376:../uvc.c      **** 		 SenseUpReg,		//Reg2: the command register address2
 377:../uvc.c      **** 		 2,					//UVCLn: the command length
 378:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 379:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 380:../uvc.c      **** 		 9,					//UVCMaxLo: the command maximum value low byte
 381:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 382:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 383:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 384:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 385:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 386:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 387:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 388:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 389:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 390:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 391:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 392:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 393:../uvc.c      **** 		};	// sense up control 0 ~ 0x09
 394:../uvc.c      **** */
 395:../uvc.c      **** /*volatile static SensorCtrl EXTMirror =
 396:../uvc.c      **** 		{MirrModeReg,		//Reg1: the command register address1
 397:../uvc.c      **** 		 MirrModeReg,		//Reg2: the command register address2
 398:../uvc.c      **** 		 2,					//UVCLn: the command length
 399:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 400:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 401:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 402:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 403:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 404:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 405:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 406:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 407:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 408:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 409:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 410:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 411:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 412:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 413:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 414:../uvc.c      **** 		};	// mirror mode control 0 ~ 0x03
 415:../uvc.c      **** */
 416:../uvc.c      **** //volatile static SensorCtrl EXT3DnoiseReduceMode;
 417:../uvc.c      **** //volatile static SensorCtrl EXT3DNoiseLev;
 418:../uvc.c      **** //volatile static SensorCtrl EXTDayNightMode;
 419:../uvc.c      **** //volatile static SensorCtrl EXTDayNightdely;
 420:../uvc.c      **** //volatile static SensorCtrl EXTDayNightlev;
 421:../uvc.c      **** //volatile static SensorCtrl EXTNightDaylev;
 422:../uvc.c      **** volatile static SensorCtrl EXTAexModGainlev =
 423:../uvc.c      **** 		{ShutterReg/*AExModeReg*/,		//Reg1: the command register address1
 424:../uvc.c      **** 		 0x03/*AExAGCReg*/,			//Reg2: the command register address2
 425:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 426:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 427:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 428:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 429:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 430:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 431:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 432:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 433:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 434:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 435:../uvc.c      **** 		 63, 				//UVCDefVHi: the command default data value high byte
 436:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 437:../uvc.c      **** 		 63,				//UVCCurVHi: the command current data value high byte
 438:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 439:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 440:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 441:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 442:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 443:../uvc.c      **** //volatile static SensorCtrl EXTExpReflev;
 444:../uvc.c      **** //volatile static SensorCtrl EXTCamMode;
 445:../uvc.c      **** //volatile static SensorCtrl EXTSnapshot;
 446:../uvc.c      **** //volatile static SensorCtrl EXTSensorPare;
 447:../uvc.c      **** //volatile static SensorCtrl EXTI2Ccmd;
 448:../uvc.c      **** volatile static SensorCtrl EXTBLCWinPos =
 449:../uvc.c      **** 		{BLCPosReg,			//Reg1: the command register address1
 450:../uvc.c      **** 		 BLCSizeReg,		//Reg2: the command register address2
 451:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 452:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 453:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 454:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 455:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 456:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 457:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 458:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 459:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 460:../uvc.c      **** 		 0x22,				//UVCDefVLo: the command default data value low byte
 461:../uvc.c      **** 		 0x22, 				//UVCDefVHi: the command default data value high byte
 462:../uvc.c      **** 		 0x22,				//UVCCurVLo: the command current data value low byte
 463:../uvc.c      **** 		 0x22,				//UVCCurVHi: the command current data value high byte
 464:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 465:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 466:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 467:../uvc.c      **** 		}; //BLC position: [7:4]:Top/bottom [3:0]:left/right; BLC size: [7:4]:height [3:0]:width.
 468:../uvc.c      **** //{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 469:../uvc.c      **** volatile static SensorCtrl EXTBLCWeight =
 470:../uvc.c      **** 		{BLCModeRegGain,			//Reg1: the command register address1
 471:../uvc.c      **** 		 BLCModeRegGain,			//Reg2: the command register address2
 472:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 473:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 474:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 475:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 476:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 477:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 478:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 479:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 480:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 481:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 482:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 483:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 484:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 485:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 486:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 487:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 488:../uvc.c      **** 		}; //
 489:../uvc.c      **** //volatile static SensorCtrl EXTBLCGrid;
 490:../uvc.c      **** //{/*26*/0x17/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,
 491:../uvc.c      **** 
 492:../uvc.c      **** volatile static SensorCtrl EXTShutlev =
 493:../uvc.c      **** 		{0x02/*AExModeReg2*/,		//Reg1: the command register address1
 494:../uvc.c      **** 		 0x12/*ShutterFineReg*/,			//Reg2: the command register address2
 495:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 496:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 497:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 498:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 499:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 500:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 501:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 502:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 503:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 504:../uvc.c      **** 		 63,				//UVCDefVLo: the command default data value low byte
 505:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 506:../uvc.c      **** 		 63,					//UVCCurVLo: the command current data value low byte
 507:../uvc.c      **** 		 0,				//UVCCurVHi: the command current data value high byte
 508:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 509:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 510:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 511:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 512:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 513:../uvc.c      **** 
 514:../uvc.c      **** volatile static SensorCtrl *pEXTSenCtrl[0x20] = {//Extension control
 515:../uvc.c      **** 		&EXTShutter,
 516:../uvc.c      **** 		0, //&EXTSensUp,
 517:../uvc.c      **** 		0, //&EXTMirror,
 518:../uvc.c      **** 		0, //&EXT3DnoiseReduceMode,
 519:../uvc.c      **** 		0, //&EXT3DNoiseLev,
 520:../uvc.c      **** 		0, //&EXTDayNightMode,
 521:../uvc.c      **** 		0, //&EXTDayNightdely,
 522:../uvc.c      **** 		0, //&EXTDayNightlev,
 523:../uvc.c      **** 		0, //&EXTNightDaylev,
 524:../uvc.c      **** 		&EXTAexModGainlev,
 525:../uvc.c      **** 		0, //&EXTExpReflev,
 526:../uvc.c      **** 		&EXTShutlev,
 527:../uvc.c      **** 		0, //&EXTCamMode,
 528:../uvc.c      **** 		0, //&EXTSnapshot,
 529:../uvc.c      **** 		0, //&EXTSensorPare,
 530:../uvc.c      **** 		0, //&EXTI2Ccmd,
 531:../uvc.c      **** 		0, //&Ext1CtlID0 = 0x20,
 532:../uvc.c      **** 		0, //&Ext1CtlID1,
 533:../uvc.c      **** 		0, //&Ext1CtlID2,
 534:../uvc.c      **** 		0, //&Ext1CtlID3,
 535:../uvc.c      **** 		&EXTBLCWinPos,   		// back light compensation range
 536:../uvc.c      **** 		&EXTBLCWeight,  	    // back light compensation weight (gain) factor
 537:../uvc.c      **** 		0, //&EXTBLCGrid,    	// back light compensation grid state
 538:../uvc.c      **** 		0
 539:../uvc.c      **** };
 540:../uvc.c      **** 
 541:../uvc.c      **** #endif //end of the new control structure
 542:../uvc.c      **** 
 543:../uvc.c      **** #ifndef CAM720
 544:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 545:../uvc.c      **** #else
 546:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 547:../uvc.c      **** #endif
 548:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
 549:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
 550:../uvc.c      **** 
 551:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 552:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 553:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 554:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 555:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 556:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    0,    0,    0xff, 0xff, 1, 0, 3
 557:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   0x80,
 558:../uvc.c      **** 		{/*26*/0x17/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,
 559:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 560:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 561:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 562:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 563:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 564:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 565:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 566:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 567:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 568:../uvc.c      **** };
 569:../uvc.c      **** 
 570:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 571:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 572:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 573:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 574:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 575:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 576:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 577:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 578:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 579:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 580:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 581:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 582:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 583:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 584:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 585:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 586:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 587:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 588:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 589:../uvc.c      **** };
 590:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 591:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 592:../uvc.c      **** static uint16_t ShutSp[16]={33333, 16667, 8333, 4000, 2000, 1000, 500, 200, 100, 10, 0}; // in micr
 593:../uvc.c      **** /*
 594:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 595:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 596:../uvc.c      ****  */
 597:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 598:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 599:../uvc.c      **** };
 600:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 601:../uvc.c      **** 		0
 602:../uvc.c      **** };
 603:../uvc.c      **** 
 604:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 605:../uvc.c      **** 
 606:../uvc.c      **** void I2CCmdHandler(){
 607:../uvc.c      **** 	uint8_t buf[2];
 608:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 609:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 610:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 611:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 612:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 613:../uvc.c      **** 	uint8_t i;
 614:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 615:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 616:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 617:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 618:../uvc.c      **** 	{
 619:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 620:../uvc.c      **** 		if(is60Hz==CyFalse)
 621:../uvc.c      **** 			{
 622:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 623:../uvc.c      **** 			}
 624:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 625:../uvc.c      **** 
 626:../uvc.c      **** 	}
 627:../uvc.c      **** 	if(CmdType == 0)//I2C read
 628:../uvc.c      **** 	{
 629:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 630:../uvc.c      **** #if 0 //for debugging
 631:../uvc.c      **** 		/* test still image operation */
 632:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 633:../uvc.c      **** 			snapButFlag = 0; //press
 634:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 635:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 636:../uvc.c      **** 			snapButFlag = 0xf; //release
 637:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 638:../uvc.c      **** 		}
 639:../uvc.c      **** 
 640:../uvc.c      **** 		/* end of the test */
 641:../uvc.c      **** #endif
 642:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 643:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 644:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 645:../uvc.c      **** 				if(CmdDataLen == 2){
 646:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 647:../uvc.c      **** 				}
 648:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 649:../uvc.c      **** 		}else{//not support currently
 650:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 651:../uvc.c      **** 		}
 652:../uvc.c      **** 	}else if(CmdType == 1){
 653:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 654:../uvc.c      **** 			if(CmdRegLen == 2){
 655:../uvc.c      **** 				for(i = 0; i<4; i++)
 656:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 657:../uvc.c      **** 			}
 658:../uvc.c      **** 			else{
 659:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 660:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 661:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 662:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 663:../uvc.c      **** 				}
 664:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 665:../uvc.c      **** 			}
 666:../uvc.c      **** 		}else{//not support currently
 667:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 668:../uvc.c      **** 		}
 669:../uvc.c      **** 
 670:../uvc.c      **** 	}
 671:../uvc.c      **** }
 672:../uvc.c      **** 
 673:../uvc.c      **** /************************************
 674:../uvc.c      ****  * set Iris mode
 675:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 676:../uvc.c      ****  */
 677:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 678:../uvc.c      **** 	uint8_t dataIdx = 0;
 679:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 683:../uvc.c      **** }
 684:../uvc.c      **** 
 685:../uvc.c      **** 
 686:../uvc.c      **** 
 687:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 688:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 689:../uvc.c      **** 	uint16_t NumLn;
 690:../uvc.c      **** 	uint16_t fRate, shutTm;
 691:../uvc.c      **** 	uint8_t LnVal;
 692:../uvc.c      **** 	switch (Data){
 693:../uvc.c      **** 	case 1:
 694:../uvc.c      **** 	case 2:
 695:../uvc.c      **** 	case 3:
 696:../uvc.c      **** 	case 4:
 697:../uvc.c      **** 	case 5:
 698:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 699:../uvc.c      **** 		fRate = 30;
 700:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 701:../uvc.c      **** 		if(NumLn > 1944)
 702:../uvc.c      **** 			NumLn =1944;
 703:../uvc.c      **** 		else if(NumLn < 8)
 704:../uvc.c      **** 			NumLn = 8;
 705:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 706:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 707:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 708:../uvc.c      **** 		break;
 709:../uvc.c      **** 	case 6:
 710:../uvc.c      **** 	case 7:
 711:../uvc.c      **** 	case 8:
 712:../uvc.c      **** 	case 9:
 713:../uvc.c      **** 	case 10:
 714:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 715:../uvc.c      **** 		fRate = 30;
 716:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 717:../uvc.c      **** 		if(NumLn > 1944)
 718:../uvc.c      **** 			NumLn =1944;
 719:../uvc.c      **** 		else if(NumLn < 8)
 720:../uvc.c      **** 			NumLn = 8;
 721:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 722:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 723:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 724:../uvc.c      **** 		break;
 725:../uvc.c      **** 	case 0: //auto
 726:../uvc.c      **** 	default:
 727:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 728:../uvc.c      **** 		LnVal = 1;
 729:../uvc.c      **** 		break;
 730:../uvc.c      **** 	}
 731:../uvc.c      **** 	return LnVal;
 732:../uvc.c      **** }
 733:../uvc.c      **** 
 734:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 735:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 736:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 737:../uvc.c      ****     uint16_t readCount;
 738:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID, AxMode;
 739:../uvc.c      ****     uint8_t devAdd;
 740:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 741:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 742:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 743:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 744:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 745:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 746:../uvc.c      ****     }else{
 747:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 748:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 749:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 750:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 751:../uvc.c      ****     }
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 754:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 755:../uvc.c      **** #endif
 756:../uvc.c      ****     reqData = bRequest;
 757:../uvc.c      ****     /*
 758:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 759:../uvc.c      ****      */
 760:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 761:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 762:../uvc.c      ****     	goto EndofSet;
 763:../uvc.c      ****     }
 764:../uvc.c      ****     switch (bRequest)
 765:../uvc.c      **** 		 {
 766:../uvc.c      **** 
 767:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 768:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 769:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 771:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 772:../uvc.c      **** 			  break;
 773:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 774:../uvc.c      **** 
 775:../uvc.c      **** 			 switch(CtrlID)
 776:../uvc.c      **** 			 {
 777:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 778:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 779:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 780:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 781:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 782:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 783:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 784:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 785:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 786:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 787:../uvc.c      **** 			 	 		 break;
 788:../uvc.c      **** 			 	 }
 789:../uvc.c      **** 			 	 case ExtShutCtlID0:
 790:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 791:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 792:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 793:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 794:../uvc.c      **** 			 		 break;
 795:../uvc.c      **** 			 	 case ExtCtlShutlevCtlID11:
 796:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 797:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 798:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 799:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 800:../uvc.c      **** 			 		 break;
 801:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 802:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 803:../uvc.c      **** 					 if(CamMode == 1){//720p
 804:../uvc.c      **** 						if(sendData >= 3){
 805:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 806:../uvc.c      **** 							sendData = 0; //set back to default
 807:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 808:../uvc.c      **** 						}
 809:../uvc.c      **** 						sendData += 4;
 810:../uvc.c      **** 					 }
 811:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 812:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 813:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 814:../uvc.c      **** 					 break;
 815:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 816:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 817:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 818:../uvc.c      **** 			 		 }
 819:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 820:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 821:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 822:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 823:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 824:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 825:../uvc.c      **** #endif
 826:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 827:../uvc.c      **** 			 		 {
 828:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 829:../uvc.c      **** 			 		 }
 830:../uvc.c      **** 			 		 break;
 831:../uvc.c      **** 				 case ExtAexModCtlID9:
 832:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 833:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 834:../uvc.c      **** 
 835:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 836:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 837:../uvc.c      **** 					 //glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 838:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 839:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 840:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 841:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 842:../uvc.c      **** 					 break;
 843:../uvc.c      **** 
 844:../uvc.c      **** 			 	 case BrgtCtlID1:
 845:../uvc.c      **** 			 		 /* cancel for 5MP w/b camera
 846:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 847:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 848:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 849:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 850:../uvc.c      **** 					 }else{
 851:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 852:../uvc.c      **** 					 }
 853:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 854:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 855:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 856:../uvc.c      **** 					 */
 857:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 858:../uvc.c      **** 					  if(Data0&0x80){
 859:../uvc.c      **** 						  Data0 = ~Data0;
 860:../uvc.c      **** 					  }else{
 861:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 862:../uvc.c      **** 					  }
 863:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 864:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 865:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 866:../uvc.c      **** 			 		 break;
 867:../uvc.c      **** 				 case HueCtlID5:
 868:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 869:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 870:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 871:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 872:../uvc.c      **** 					 break;
 873:../uvc.c      **** 				 case WBTLevCtlID11:
 874:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 875:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 876:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 877:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 878:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 879:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 880:../uvc.c      **** 					 break;
 881:../uvc.c      **** 				 case BLCCtlID0:
 882:../uvc.c      **** 				 case ShapCtlID7:
 883:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;
 884:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 885:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 886:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 887:../uvc.c      **** 					 break;
 888:../uvc.c      **** 				 case ExtExRefCtlID10:
 889:../uvc.c      **** 				 case ConsCtlID2:
 890:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[ExtExRefCtlID10][13];//SensorGetControl(RegAdd0, devAdd);
 891:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//SensorGetControl(RegAdd0, devAdd);
 892:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 893:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 894:../uvc.c      **** 					 break;
 895:../uvc.c      **** 				 case SaturCtlID6:
 896:../uvc.c      **** 				 default:
 897:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 898:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 899:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 900:../uvc.c      **** 					 break;
 901:../uvc.c      **** 			 }
 902:../uvc.c      **** 
 903:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 904:../uvc.c      **** 
 905:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 906:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 907:../uvc.c      **** #endif
 908:../uvc.c      **** 			  break;
 909:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 910:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 911:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 912:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 913:../uvc.c      **** 		 	 }
 914:../uvc.c      **** 
 915:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 916:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 917:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 918:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 919:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 920:../uvc.c      **** 			 }else
 921:../uvc.c      **** 			 {
 922:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 923:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 924:../uvc.c      **** 			 }
 925:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 926:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 927:../uvc.c      **** 			  break;
 928:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 929:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 930:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 931:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 932:../uvc.c      **** 		 	 }
 933:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 934:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 935:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 936:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 937:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 938:../uvc.c      **** 			 }else
 939:../uvc.c      **** 			 {
 940:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 941:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 942:../uvc.c      **** 			 }
 943:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 944:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 945:../uvc.c      **** 			  break;
 946:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 947:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 948:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 949:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 950:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 951:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 952:../uvc.c      **** 		 	 }
 953:../uvc.c      **** 		 	 else{
 954:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 955:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 956:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 957:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 958:../uvc.c      **** 		 	 }
 959:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 960:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 961:../uvc.c      **** 			  break;
 962:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 963:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 964:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 965:../uvc.c      **** 		 	 }
 966:../uvc.c      **** 		 	 else{
 967:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 968:../uvc.c      **** 		 	 }
 969:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 970:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 971:../uvc.c      **** 			  Len = 1;
 972:../uvc.c      **** 			  break;
 973:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 974:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 975:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 976:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 977:../uvc.c      **** 		 	 }
 978:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 979:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 980:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 981:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 982:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 983:../uvc.c      **** 			 }else{
 984:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 985:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 986:../uvc.c      **** 			 }
 987:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 988:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 989:../uvc.c      **** 			  break;
 990:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 991:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 992:../uvc.c      **** 				  glEp0Buffer, &readCount);
 993:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 994:../uvc.c      **** 			   {
 995:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 996:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 997:../uvc.c      **** 				  getData = glEp0Buffer[0];
 998:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 999:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1000:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
1001:../uvc.c      **** #endif
1002:../uvc.c      **** 				  switch(CtrlID)
1003:../uvc.c      **** 					 {
1004:../uvc.c      **** 						 case ExtShutCtlID0:
1005:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
1006:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
1007:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
1008:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
1009:../uvc.c      **** #if 1	// register setting directly
1010:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
1011:../uvc.c      **** 						     {
1012:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
1013:../uvc.c      **** 						    	 dataIdx = 0;
1014:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1015:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
1016:../uvc.c      **** 								 dataIdx++;
1017:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1018:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1019:../uvc.c      **** 						     }
1020:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
1021:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
1022:../uvc.c      **** 						     break;
1023:../uvc.c      **** #else	// old fashion
1024:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
1025:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
1026:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
1027:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
1028:../uvc.c      **** 									 }else{
1029:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
1030:../uvc.c      **** 									 }
1031:../uvc.c      **** 								 }
1032:../uvc.c      **** 							 }else{
1033:../uvc.c      **** 								 Data1 = Data0 - 1;
1034:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
1035:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
1036:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
1037:../uvc.c      **** 									 }else{
1038:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
1039:../uvc.c      **** 									 }
1040:../uvc.c      **** 								 }
1041:../uvc.c      **** 								 if(Data1 < 8){
1042:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
1043:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
1044:../uvc.c      **** 								 }else{
1045:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
1046:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
1047:../uvc.c      **** 								 }
1048:../uvc.c      **** 							 }
1049:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
1050:../uvc.c      **** 							 dataIdx = 0;
1051:../uvc.c      **** 							 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
1052:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1053:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
1054:../uvc.c      **** 							 if(AxMode){
1055:../uvc.c      **** 								 dataIdx++;
1056:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
1057:../uvc.c      **** 								 dataIdx++;
1058:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustme
1059:../uvc.c      **** 							 }
1060:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1061:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
1062:../uvc.c      **** 							 break;
1063:../uvc.c      **** #endif
1064:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
1065:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1066:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1067:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
1068:../uvc.c      **** 						     dataIdx = 0;
1069:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1070:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
1071:../uvc.c      **** 							 {
1072:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
1073:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1074:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1075:../uvc.c      **** 								 /*
1076:../uvc.c      **** 								 dataIdx++;
1077:../uvc.c      **** 								 if(getData == 1 || getData == 3){
1078:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x80, dataIdx);  //set AEX mode2 to 0x80 (fixed shu
1079:../uvc.c      **** 									 dataIdx++;
1080:../uvc.c      **** 								 }else{
1081:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x00, dataIdx);  //set AEX mode2 to 0x00
1082:../uvc.c      **** 									 dataIdx++;
1083:../uvc.c      **** 								 }
1084:../uvc.c      **** 								 */
1085:../uvc.c      **** 							 }
1086:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
1087:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
1088:../uvc.c      **** 								 if(getData == 2 || getData == 3){
1089:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
1090:../uvc.c      **** 								 }
1091:../uvc.c      **** 							 }
1092:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1093:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1094:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1095:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
1096:../uvc.c      **** 							 break;
1097:../uvc.c      **** 
1098:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level
1099:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1100:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1101:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
1102:../uvc.c      **** 						     dataIdx = 0;
1103:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1104:../uvc.c      **** 							 if(0&&EXTShutlev.UVCCurVLo != getData)
1105:../uvc.c      **** 							 {
1106:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). CtrlParArr
1107:../uvc.c      **** 								 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1108:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1109:../uvc.c      **** 								 dataIdx++;
1110:../uvc.c      **** 							 }
1111:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
1112:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
1113:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
1114:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
1115:../uvc.c      **** 									 dataIdx++;
1116:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
1117:../uvc.c      **** 								 }
1118:../uvc.c      **** 							 }
1119:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1120:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1121:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1122:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
1123:../uvc.c      **** 							 break;
1124:../uvc.c      **** 						 case ExtCamMCtlID12:
1125:../uvc.c      **** 							 dataIdx = 0;
1126:../uvc.c      **** 							 if(Data0 <= 3){
1127:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
1128:../uvc.c      **** 								 Data1 = Data0;
1129:../uvc.c      **** 							 }else{
1130:../uvc.c      **** 								 CamMode = 1; //set 720p flag
1131:../uvc.c      **** 								 Data1 = Data0-4;
1132:../uvc.c      **** 							 }
1133:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1134:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
1135:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1136:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1137:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1138:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1139:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
1140:../uvc.c      **** 							 break;
1141:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
1142:../uvc.c      **** 							 dataIdx = 0;
1143:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
1144:../uvc.c      **** 								 Data0 = 1;
1145:../uvc.c      **** 							 }else{ //save current sensor parameters.
1146:../uvc.c      **** 								 Data0 = 0;
1147:../uvc.c      **** 							 }
1148:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1149:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1150:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1151:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1152:../uvc.c      **** 							 break;
1153:../uvc.c      **** 						 case ExtI2CCtlID15:
1154:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
1155:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
1156:../uvc.c      **** 					 		 }
1157:../uvc.c      **** 					 		I2CCmdHandler();
1158:../uvc.c      **** 							 break;
1159:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
1160:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
1161:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
1162:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
1163:../uvc.c      **** 
1164:../uvc.c      **** 							 dataIdx = 0;
1165:../uvc.c      **** #if 0 //seperate version
1166:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
1167:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
1168:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1169:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
1170:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
1171:../uvc.c      **** 							 }else{ //disable BLD window
1172:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
1173:../uvc.c      **** 							 }
1174:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
1175:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
1176:../uvc.c      **** 							 dataIdx++;
1177:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
1178:../uvc.c      **** 							 dataIdx++;
1179:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
1180:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
1181:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
1182:../uvc.c      **** 							 dataIdx++;
1183:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
1184:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1185:../uvc.c      **** #else //combination version
1186:../uvc.c      **** 							 //Data0 = Data0&0x7F; //mask window show flag bit.
1187:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1188:../uvc.c      **** 						     /* end test */
1189:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
1190:../uvc.c      **** 							 dataIdx++;
1191:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
1192:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1193:../uvc.c      **** 							 getData1 = Data1;
1194:../uvc.c      **** #endif
1195:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
1196:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
1197:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1198:../uvc.c      **** 							 break;
1199:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
1200:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
1201:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
1202:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
1203:../uvc.c      **** 
1204:../uvc.c      **** 							 dataIdx = 0;
1205:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1206:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
1207:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1208:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
1209:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
1210:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1211:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1212:../uvc.c      **** 							 break;
1213:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
1214:../uvc.c      **** 							 dataIdx = 0;
1215:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1216:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
1217:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1218:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
1219:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
1220:../uvc.c      **** 							 break;
1221:../uvc.c      **** 				  	  	 case BrgtCtlID1:
1222:../uvc.c      **** #if 0 //cancel for 5MP w/b camera
1223:../uvc.c      **** 							 dataIdx = 0;
1224:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1225:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1226:../uvc.c      **** 							  if(Data0&0x80){
1227:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
1228:../uvc.c      **** 							  }else{
1229:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
1230:../uvc.c      **** 							  }
1231:../uvc.c      **** 							 Data1 |= ~0x03;
1232:../uvc.c      **** 							 Data1 &= 0xC7;
1233:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
1234:../uvc.c      **** 						  	 dataIdx++;
1235:../uvc.c      **** 
1236:../uvc.c      **** 							 Data0 = (Data0 << 2);
1237:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
1238:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1239:../uvc.c      **** 
1240:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1241:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
1242:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1243:../uvc.c      **** #endif
1244:../uvc.c      **** 							 dataIdx = 0;
1245:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1246:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1247:../uvc.c      **** 							  if(Data0&0x80){
1248:../uvc.c      **** 								  Data0 = Data0 - 0x80;
1249:../uvc.c      **** 							  }else{
1250:../uvc.c      **** 								  Data0 = ~Data0;
1251:../uvc.c      **** 							  }
1252:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
1253:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1254:../uvc.c      **** 
1255:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1256:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1257:../uvc.c      **** 
1258:../uvc.c      **** 
1259:../uvc.c      **** 							 break;
1260:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
1261:../uvc.c      **** 							 dataIdx = 0;
1262:../uvc.c      **** 
1263:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1264:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
1265:../uvc.c      **** 							 dataIdx++;
1266:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
1267:../uvc.c      **** 							 dataIdx++;
1268:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
1269:../uvc.c      **** 							 dataIdx++;
1270:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
1271:../uvc.c      **** 							 dataIdx++;
1272:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
1273:../uvc.c      **** 							 dataIdx++;
1274:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
1275:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1276:../uvc.c      **** 
1277:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
1278:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1279:../uvc.c      **** 							 break;
1280:../uvc.c      **** 						 case SaturCtlID6:
1281:../uvc.c      **** 							 dataIdx = 0;
1282:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
1283:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1284:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1285:../uvc.c      **** 							 dataIdx++;
1286:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
1287:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1288:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1289:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1290:../uvc.c      **** 							 break;
1291:../uvc.c      **** 
1292:../uvc.c      **** 						 case WBTLevCtlID11:
1293:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
1294:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
1295:../uvc.c      **** 							 dataIdx = 0;
1296:../uvc.c      **** 
1297:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1298:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1299:../uvc.c      **** 							 dataIdx++;
1300:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
1301:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1302:../uvc.c      **** 
1303:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
1304:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
1305:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1306:../uvc.c      **** 							 break;
1307:../uvc.c      **** 						 case MFreqCtlID4:
1308:../uvc.c      **** 							 dataIdx = 0;
1309:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1310:../uvc.c      **** 							 Data0 = Data0 - 1;
1311:../uvc.c      **** 							 is60Hz = Data0;
1312:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
1313:../uvc.c      **** 							 {
1314:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
1315:../uvc.c      **** 								 is60Hz = CyFalse;
1316:../uvc.c      **** 							 }
1317:../uvc.c      **** 							 else if(Data0 >2)
1318:../uvc.c      **** 							 {
1319:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
1320:../uvc.c      **** 								 is60Hz = CyTrue;
1321:../uvc.c      **** 							 }
1322:../uvc.c      **** 							 //CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
1323:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
1324:../uvc.c      **** 							 {
1325:../uvc.c      **** 								 //CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1326:../uvc.c      **** 			                       switch (setRes)
1327:../uvc.c      **** 			                         {
1328:../uvc.c      **** 			                         	case 1: //1944
1329:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
1330:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1331:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1332:../uvc.c      **** 			                         		break;
1333:../uvc.c      **** 			                         	case 2: //1080
1334:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
1335:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1336:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1337:../uvc.c      **** 			                         		break;
1338:../uvc.c      **** 			                         	case 3: //720
1339:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
1340:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1341:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1342:../uvc.c      **** 			                         		break;
1343:../uvc.c      **** 			                         	case 4: //VGA
1344:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
1345:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1346:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1347:../uvc.c      **** 			                         	default:
1348:../uvc.c      **** 			                         		break;
1349:../uvc.c      **** 			                         }
1350:../uvc.c      **** 								 //CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1351:../uvc.c      **** 							 }
1352:../uvc.c      **** 
1353:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1354:../uvc.c      **** 							 break;
1355:../uvc.c      **** 					 	 case BLCCtlID0:
1356:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1357:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1358:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1359:../uvc.c      **** 						     dataIdx = 0;
1360:../uvc.c      **** 
1361:../uvc.c      **** 							 //CtrlParArry[CtrlID][13] = Data0;
1362:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1363:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1364:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1365:../uvc.c      **** 
1366:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
1367:../uvc.c      **** 							 {
1368:../uvc.c      **** 								 if(Data0 < 3){
1369:../uvc.c      **** 					 				 Data0 += 4;
1370:../uvc.c      **** 					 			 }else{
1371:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1372:../uvc.c      **** 									Data0 = 4; //set to default.
1373:../uvc.c      **** 					 			 }
1374:../uvc.c      **** 					 		 }
1375:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0;
1376:../uvc.c      **** 							 dataIdx = 0;
1377:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1378:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1379:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1380:../uvc.c      **** 
1381:../uvc.c      **** 					 		 break;
1382:../uvc.c      **** 					 	 case ShapCtlID7:
1383:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1384:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1385:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1386:../uvc.c      **** 						     dataIdx = 0;
1387:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1388:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1389:../uvc.c      **** 							 if(Data0 != 0){
1390:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1391:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
1392:../uvc.c      **** 								 dataIdx++;
1393:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
1394:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1395:../uvc.c      **** 							 }else{
1396:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1397:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
1398:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1399:../uvc.c      **** 
1400:../uvc.c      **** 							 }
1401:../uvc.c      **** 							 break;
1402:../uvc.c      **** 						 case ExtExRefCtlID10:
1403:../uvc.c      **** 						 case ConsCtlID2:
1404:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1405:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1406:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1407:../uvc.c      **** 
1408:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
1409:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
1410:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][13] = Data0;  //it's canceled as the both is the same contro
1411:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][16] = CyTrue;
1412:../uvc.c      **** 
1413:../uvc.c      **** 							 break;
1414:../uvc.c      **** 						 default:
1415:../uvc.c      **** 							 dataIdx = 0;
1416:../uvc.c      **** 
1417:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1418:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1419:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1420:../uvc.c      **** 
1421:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1422:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1423:../uvc.c      **** 							 break;
1424:../uvc.c      **** 					 }
1425:../uvc.c      **** 			   }else{
1426:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
1427:../uvc.c      **** 			   }
1428:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1429:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
1430:../uvc.c      **** #endif
1431:../uvc.c      **** 
1432:../uvc.c      **** 			  break;
1433:../uvc.c      **** 		  default:
1434:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1435:../uvc.c      **** 			  break;
1436:../uvc.c      **** 		 }
1437:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
1438:../uvc.c      **** }
1439:../uvc.c      **** /************** CT control requests handler *************************/
1440:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
1441:../uvc.c      **** 
1442:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
1443:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
1444:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1445:../uvc.c      ****     uint16_t readCount;
1446:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
1447:../uvc.c      ****     uint16_t diff, value, diffRd;
1448:../uvc.c      ****     uint8_t i, shutter, index;
1449:../uvc.c      ****     diff = 0xffff;
1450:../uvc.c      ****     shutter = 1;
1451:../uvc.c      ****     index = 1;
1452:../uvc.c      **** 
1453:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
1454:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
1455:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
1456:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
1457:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
1458:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1459:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
1460:../uvc.c      **** #endif
1461:../uvc.c      ****     reqData = bRequest;
1462:../uvc.c      **** 
1463:../uvc.c      ****     switch (bRequest)
1464:../uvc.c      **** 		 {
1465:../uvc.c      **** 
1466:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
1467:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1468:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1469:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1470:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1471:../uvc.c      **** 			  break;
1472:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1473:../uvc.c      **** 
1474:../uvc.c      **** 			 switch(CtrlID)
1475:../uvc.c      **** 			 {
1476:../uvc.c      **** 				 default:
1477:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
1478:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
1479:../uvc.c      **** 					 glEp0Buffer[2] = 0;
1480:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1481:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1482:../uvc.c      **** 					 break;
1483:../uvc.c      **** 			 }
1484:../uvc.c      **** 
1485:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1486:../uvc.c      **** 
1487:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1488:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
1489:../uvc.c      **** #endif
1490:../uvc.c      **** 			  break;
1491:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
1492:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
1493:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
1494:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
1495:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1496:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1497:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1498:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1499:../uvc.c      **** 			  break;
1500:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1501:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
1502:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
1503:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1504:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1505:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1506:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1507:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1508:../uvc.c      **** 			  break;
1509:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1510:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1511:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1512:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1513:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1514:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1515:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1516:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1517:../uvc.c      **** 			  break;
1518:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1519:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1520:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1521:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1522:../uvc.c      **** 			  Len = 1;
1523:../uvc.c      **** 			  break;
1524:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1525:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1526:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1527:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1528:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1529:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1530:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1531:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1532:../uvc.c      **** 			  break;
1533:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1534:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1535:../uvc.c      **** 			  glEp0Buffer, &readCount);
1536:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1537:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1538:../uvc.c      **** 			  value = Data1;
1539:../uvc.c      **** 
1540:../uvc.c      **** 			  switch(CtrlID)
1541:../uvc.c      **** 			  {
1542:../uvc.c      **** 		  	      case AutoExMCtlID1:
1543:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1544:../uvc.c      **** 
1545:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1546:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1547:../uvc.c      **** 				    getData = glEp0Buffer[0];
1548:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1549:../uvc.c      **** 		  		    switch (getData){
1550:../uvc.c      **** 						case 1:
1551:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1552:../uvc.c      **** 							break;
1553:../uvc.c      **** 						case 2:
1554:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1555:../uvc.c      **** 							dataIdx = 0;
1556:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1557:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1558:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1559:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1560:../uvc.c      **** 
1561:../uvc.c      **** 							break;
1562:../uvc.c      **** 						case 4:
1563:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1564:../uvc.c      **** 							break;
1565:../uvc.c      **** 						case 8:
1566:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1567:../uvc.c      **** 			  		    	dataIdx = 0;
1568:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1569:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1570:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1571:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1572:../uvc.c      **** 							break;
1573:../uvc.c      **** 		  		    }
1574:../uvc.c      **** #if 0
1575:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1576:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1577:../uvc.c      **** 						  dataIdx = 0;
1578:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1579:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1580:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1581:../uvc.c      **** 		  		    }
1582:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1583:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1584:../uvc.c      **** 		  		    }
1585:../uvc.c      **** #endif
1586:../uvc.c      **** 				    break;
1587:../uvc.c      **** 
1588:../uvc.c      **** 			  	  case ExTmACtlID3:
1589:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1590:../uvc.c      **** 
1591:../uvc.c      **** 					  value = (value << 8)|Data0;
1592:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1593:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1594:../uvc.c      **** 					  {
1595:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1596:../uvc.c      **** 						  {
1597:../uvc.c      **** 							if(value > ShutValueArry[i]){
1598:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1599:../uvc.c      **** 							}else{
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1601:../uvc.c      **** 							}
1602:../uvc.c      **** 							  if(diff > diffRd){
1603:../uvc.c      **** 								  diff = diffRd;
1604:../uvc.c      **** 								  index = i;
1605:../uvc.c      **** 							  }
1606:../uvc.c      **** 						  }
1607:../uvc.c      **** 						  shutter = shutter+index;
1608:../uvc.c      **** 
1609:../uvc.c      **** 						  dataIdx = 0;
1610:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1611:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1612:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1613:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1614:../uvc.c      **** 
1615:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1616:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1617:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1618:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1619:../uvc.c      **** 					  }else{
1620:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1621:../uvc.c      **** 					  }
1622:../uvc.c      **** 					  getData = glEp0Buffer[0];
1623:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1624:../uvc.c      **** 					  break;
1625:../uvc.c      **** 			  	  case IriACtlID7:
1626:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1627:../uvc.c      **** 					  {
1628:../uvc.c      **** 							 dataIdx = 0;
1629:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1630:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
1631:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1632:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1633:../uvc.c      **** 
1634:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1635:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1636:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1637:../uvc.c      **** 					  }else{
1638:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1639:../uvc.c      **** 					  }
1640:../uvc.c      **** 					  getData = glEp0Buffer[0];
1641:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1642:../uvc.c      **** 
1643:../uvc.c      **** 					  break;
1644:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1645:../uvc.c      **** 					  getData = glEp0Buffer[0];
1646:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1647:../uvc.c      **** #if 1
1648:../uvc.c      **** 					  dataIdx = 0;
1649:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1650:../uvc.c      **** 					  if(getData == 1)
1651:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1652:../uvc.c      **** 					  else if(getData == 0xff)
1653:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1654:../uvc.c      **** 					  else
1655:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
1656:../uvc.c      **** 					  //dataIdx++;
1657:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1658:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1659:../uvc.c      **** #endif
1660:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1661:../uvc.c      **** 					  break;
1662:../uvc.c      **** 
1663:../uvc.c      **** 			  	  default:
1664:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1665:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1666:../uvc.c      **** 			  		 break;
1667:../uvc.c      **** 			  }
1668:../uvc.c      **** 			  break;
1669:../uvc.c      **** 		  default:
1670:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1671:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1672:../uvc.c      **** 			  break;
1673:../uvc.c      **** 		 }
1674:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1675:../uvc.c      **** 
1676:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1677:../uvc.c      **** }
1678:../uvc.c      **** 
1679:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1680:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1681:../uvc.c      **** {
1682:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1683:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1684:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1685:../uvc.c      **** 
1686:../uvc.c      ****     CtrlID = BrgtCtlID1;
1687:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1688:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1689:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1690:../uvc.c      ****     Data1 = Data0;
1691:../uvc.c      **** 
1692:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1693:../uvc.c      ****     if(Data1&0x80){
1694:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1695:../uvc.c      ****     }else{
1696:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1697:../uvc.c      ****     }
1698:../uvc.c      ****     Data0 = (Data0 << 2);
1699:../uvc.c      **** 
1700:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1701:../uvc.c      **** 
1702:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1703:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1704:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1705:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1706:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1707:../uvc.c      **** 
1708:../uvc.c      ****     CtrlID = ConsCtlID2;
1709:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1710:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1711:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1712:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1713:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1714:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1715:../uvc.c      **** 
1716:../uvc.c      ****     CtrlID = HueCtlID5;
1717:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1718:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1719:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1720:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1721:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1722:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1723:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1724:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1725:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1726:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1727:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1728:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1729:../uvc.c      **** 
1730:../uvc.c      ****     CtrlID = SaturCtlID6;
1731:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1732:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1733:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1734:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1735:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1736:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1737:../uvc.c      **** 
1738:../uvc.c      ****     CtrlID = ShapCtlID7;
1739:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1740:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1741:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1742:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1743:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1744:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1745:../uvc.c      **** 
1746:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1747:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1748:../uvc.c      **** 	return;
1749:../uvc.c      **** }
1750:../uvc.c      **** 
1751:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1752:../uvc.c      **** void
1753:../uvc.c      **** CyFxUVCAddHeader (
1754:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1755:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1756:../uvc.c      ****         )
1757:../uvc.c      **** {
1758:../uvc.c      ****     /* Copy header to buffer */
1759:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1760:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1761:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
1762:../uvc.c      **** 
1763:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1764:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1765:../uvc.c      ****     {
1766:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1767:../uvc.c      ****     }
1768:../uvc.c      **** }
1769:../uvc.c      **** 
1770:../uvc.c      **** 
1771:../uvc.c      **** /* Application Error Handler */
1772:../uvc.c      **** void
1773:../uvc.c      **** CyFxAppErrorHandler (
1774:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1775:../uvc.c      ****         )
1776:../uvc.c      **** {
1777:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1778:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1779:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1780:../uvc.c      **** 
1781:../uvc.c      ****        This function can be modified to take additional error handling actions such
1782:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1783:../uvc.c      ****      */
1784:../uvc.c      ****     for (;;)
1785:../uvc.c      ****     {
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
1788:../uvc.c      ****     }
1789:../uvc.c      **** }
1790:../uvc.c      **** 
1791:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1792:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1793:../uvc.c      ****  */
1794:../uvc.c      **** static void
1795:../uvc.c      **** CyFxUVCApplnAbortHandler (
1796:../uvc.c      ****         void)
1797:../uvc.c      **** {
1798:../uvc.c      **** 	uint32_t flag;
1799:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1800:../uvc.c      **** 	{
1801:../uvc.c      ****         /* Clear the Video Stream Request Event */
1802:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1803:../uvc.c      **** 
1804:../uvc.c      ****         /* Set Video Stream Abort Event */
1805:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1806:../uvc.c      **** 	}
1807:../uvc.c      **** }
1808:../uvc.c      **** 
1809:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1810:../uvc.c      **** static void
1811:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1812:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1813:../uvc.c      ****         uint16_t             evdata  /* Event data */
1814:../uvc.c      ****         )
1815:../uvc.c      **** {
1816:../uvc.c      ****     switch (evtype)
1817:../uvc.c      ****     {
1818:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1819:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1820:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1821:../uvc.c      ****             gpif_initialized = 0;
1822:../uvc.c      ****             streamingStarted = CyFalse;
1823:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1824:../uvc.c      ****             break;
1825:../uvc.c      **** 
1826:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1827:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1828:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1829:../uvc.c      ****             gpif_initialized = 0;
1830:../uvc.c      ****             streamingStarted = CyFalse;
1831:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1832:../uvc.c      ****             break;
1833:../uvc.c      **** 
1834:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1835:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1836:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1837:../uvc.c      ****             gpif_initialized = 0;
1838:../uvc.c      ****             isUsbConnected = CyFalse;
1839:../uvc.c      ****             streamingStarted = CyFalse;
1840:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1841:../uvc.c      ****             break;
1842:../uvc.c      **** 
1843:../uvc.c      **** #ifdef BACKFLOW_DETECT
1844:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1845:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1846:../uvc.c      ****             break;
1847:../uvc.c      **** #endif
1848:../uvc.c      **** 
1849:../uvc.c      ****         default:
1850:../uvc.c      ****             break;
1851:../uvc.c      ****     }
1852:../uvc.c      **** }
1853:../uvc.c      **** 
1854:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1855:../uvc.c      **** static CyBool_t
1856:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1857:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1858:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1859:../uvc.c      ****         )
1860:../uvc.c      **** {
1861:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1862:../uvc.c      ****     uint32_t status;
1863:../uvc.c      **** 
1864:../uvc.c      ****     /* Obtain Request Type and Request */
1865:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1866:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1867:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1868:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1869:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1870:../uvc.c      **** 
1871:../uvc.c      ****     /* Check for UVC Class Requests */
1872:../uvc.c      ****     switch (bmReqType)
1873:../uvc.c      ****     {
1874:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1875:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1876:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1877:../uvc.c      ****             switch (wIndex & 0xFF)
1878:../uvc.c      ****             {
1879:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1880:../uvc.c      ****                     {
1881:../uvc.c      ****                         uvcHandleReq = CyTrue;
1882:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1883:../uvc.c      ****                                 CYU3P_EVENT_OR);
1884:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1885:../uvc.c      ****                         {
1886:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1887:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1888:../uvc.c      ****                         }
1889:../uvc.c      ****                     }
1890:../uvc.c      ****                     break;
1891:../uvc.c      **** 
1892:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1893:../uvc.c      ****                     {
1894:../uvc.c      ****                         uvcHandleReq = CyTrue;
1895:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1896:../uvc.c      ****                                 CYU3P_EVENT_OR);
1897:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1898:../uvc.c      ****                         {
1899:../uvc.c      ****                             /* Error handling */
1900:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1901:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1902:../uvc.c      ****                         }
1903:../uvc.c      ****                     }
1904:../uvc.c      ****                     break;
1905:../uvc.c      **** 
1906:../uvc.c      ****                 default:
1907:../uvc.c      ****                     break;
1908:../uvc.c      ****             }
1909:../uvc.c      ****             break;
1910:../uvc.c      **** 
1911:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1912:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1913:../uvc.c      ****             {
1914:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1915:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1916:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1917:../uvc.c      ****                 {
1918:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1919:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1920:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1921:../uvc.c      ****                     gpif_initialized = 0;
1922:../uvc.c      ****                     streamingStarted = CyFalse;
1923:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1924:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1925:../uvc.c      ****                     CyU3PBusyWait (100);
1926:../uvc.c      **** 
1927:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1928:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1929:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1930:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1931:../uvc.c      ****                     CyU3PBusyWait (100);
1932:../uvc.c      **** 
1933:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1934:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1935:../uvc.c      ****                     uvcHandleReq = CyTrue;
1936:../uvc.c      ****                     /* Complete Control request handshake */
1937:../uvc.c      ****                     CyU3PUsbAckSetup ();
1938:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1939:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1940:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1941:../uvc.c      **** 
1942:../uvc.c      ****                 }
1943:../uvc.c      ****             }
1944:../uvc.c      ****             break;
1945:../uvc.c      **** 
1946:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1947:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1948:../uvc.c      ****             {
1949:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1950:../uvc.c      ****                 {
1951:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1952:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1953:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1954:../uvc.c      ****                 	 * has started. */
1955:../uvc.c      ****                     if (streamingStarted == CyTrue)
1956:../uvc.c      ****                     {
1957:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1958:../uvc.c      **** 
1959:../uvc.c      ****                         /* Disable the GPIF state machine. */
1960:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1961:../uvc.c      ****                         gpif_initialized = 0;
1962:../uvc.c      ****                         streamingStarted = CyFalse;
1963:../uvc.c      **** 
1964:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1965:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1966:../uvc.c      ****                         CyU3PBusyWait (100);
1967:../uvc.c      **** 
1968:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1969:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1970:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1971:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1972:../uvc.c      ****                         CyU3PBusyWait (100);
1973:../uvc.c      **** 
1974:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1975:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1976:../uvc.c      **** 
1977:../uvc.c      ****                         uvcHandleReq = CyTrue;
1978:../uvc.c      ****                         /* Complete Control request handshake */
1979:../uvc.c      ****                         CyU3PUsbAckSetup ();
1980:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1981:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1982:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1983:../uvc.c      ****                     }
1984:../uvc.c      ****                     else
1985:../uvc.c      ****                     {
1986:../uvc.c      ****                         uvcHandleReq = CyTrue;
1987:../uvc.c      ****                         CyU3PUsbAckSetup ();
1988:../uvc.c      ****                     }
1989:../uvc.c      ****                 }
1990:../uvc.c      ****             }
1991:../uvc.c      ****             break;
1992:../uvc.c      **** 
1993:../uvc.c      ****         default:
1994:../uvc.c      ****             break;
1995:../uvc.c      ****     }
1996:../uvc.c      **** 
1997:../uvc.c      ****     /* Return status of request handling to the USB driver */
1998:../uvc.c      ****     return uvcHandleReq;
1999:../uvc.c      **** }
2000:../uvc.c      **** 
2001:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
2002:../uvc.c      **** 
2003:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
2004:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
2005:../uvc.c      ****  */
2006:../uvc.c      **** void
2007:../uvc.c      **** CyFxUvcApplnDmaCallback (
2008:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
2009:../uvc.c      ****         CyU3PDmaCbType_t      type,
2010:../uvc.c      ****         CyU3PDmaCBInput_t    *input
2011:../uvc.c      ****         )
2012:../uvc.c      **** {
2013:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
2014:../uvc.c      **** #if 1
2015:../uvc.c      ****     CyU3PReturnStatus_t status;
2016:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
2017:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
2018:../uvc.c      **** 
2019:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2020:../uvc.c      ****     {
2021:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
2022:../uvc.c      ****             {
2023:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
2024:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
2025:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2026:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
2027:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2028:../uvc.c      ****                 	stiflag = 0x03;
2029:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
2030:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2031:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2032:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2033:../uvc.c      ****                 }
2034:../uvc.c      **** #endif
2035:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
2036:../uvc.c      ****                 fb++;
2037:../uvc.c      ****             }
2038:../uvc.c      ****             else
2039:../uvc.c      ****             {
2040:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
2041:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
2042:../uvc.c      ****                 pb++;
2043:../uvc.c      ****                 pbc = input->buffer_p.count;
2044:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
2045:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
2046:../uvc.c      ****                 //lineCount = 0; //res test
2047:../uvc.c      **** #if 1   //remove the still flag clearing here
2048:../uvc.c      ****                 if(stiflag == 0x0F){
2049:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2050:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2051:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2052:../uvc.c      ****                 	stiflag = 0xAA;
2053:../uvc.c      ****                 }
2054:../uvc.c      **** #endif
2055:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
2056:../uvc.c      ****             }
2057:../uvc.c      **** 
2058:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
2059:../uvc.c      ****             prodCount++;
2060:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2061:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
2062:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
2063:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
2064:../uvc.c      ****             {
2065:../uvc.c      ****                 prodCount--;
2066:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
2067:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
2068:../uvc.c      ****             }
2069:../uvc.c      ****     }
2070:../uvc.c      **** #endif
2071:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
2072:../uvc.c      ****     {
2073:../uvc.c      ****         consCount++;
2074:../uvc.c      ****         streamingStarted = CyTrue;
2075:../uvc.c      ****     }
2076:../uvc.c      **** }
2077:../uvc.c      **** 
2078:../uvc.c      **** /*
2079:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
2080:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
2081:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
2082:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
2083:../uvc.c      ****  * to commit the buffer.
2084:../uvc.c      ****  */
2085:../uvc.c      **** static uint8_t
2086:../uvc.c      **** CyFxUvcAppCommitEOF (
2087:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
2088:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
2089:../uvc.c      ****         )
2090:../uvc.c      **** {
2091:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2092:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
2093:../uvc.c      **** 
2094:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
2095:../uvc.c      **** 
2096:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2097:../uvc.c      ****     {
2098:../uvc.c      ****         switch (stateId)
2099:../uvc.c      ****         {
2100:../uvc.c      **** 
2101:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
2102:../uvc.c      ****             case FULL_BUF_IN_SCK1:
2103:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2104:../uvc.c      ****                 break;
2105:../uvc.c      **** 
2106:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
2107:../uvc.c      ****                 socket = 0;
2108:../uvc.c      ****                 break;
2109:../uvc.c      **** 
2110:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
2111:../uvc.c      ****                 socket = 1;
2112:../uvc.c      ****                 break;
2113:../uvc.c      **** 
2114:../uvc.c      ****             default:
2115:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2116:../uvc.c      ****                 /* Unexpected current state. Return error. */
2117:../uvc.c      ****             	//lineCount++;
2118:../uvc.c      ****             	return 1;
2119:../uvc.c      ****         }
2120:../uvc.c      ****     }
2121:../uvc.c      **** 
2122:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2123:../uvc.c      ****     {
2124:../uvc.c      ****         switch (stateId)
2125:../uvc.c      ****         {
2126:../uvc.c      **** #ifndef CAM720
2127:../uvc.c      **** #ifdef GPIFIIM
2128:../uvc.c      ****             case 13:
2129:../uvc.c      ****             case 24:
2130:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2131:../uvc.c      ****                 break;
2132:../uvc.c      **** 
2133:../uvc.c      ****             case 8:
2134:../uvc.c      ****                 socket = 0;
2135:../uvc.c      ****                 break;
2136:../uvc.c      **** 
2137:../uvc.c      ****             case 20:
2138:../uvc.c      ****                 socket = 1;
2139:../uvc.c      ****                 break;
2140:../uvc.c      **** #else
2141:../uvc.c      ****             case 11:
2142:../uvc.c      ****             case 18:
2143:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2144:../uvc.c      ****                 break;
2145:../uvc.c      **** 
2146:../uvc.c      ****             case 8:
2147:../uvc.c      ****                 socket = 0;
2148:../uvc.c      ****                 break;
2149:../uvc.c      **** 
2150:../uvc.c      ****             case 15:
2151:../uvc.c      ****                 socket = 1;
2152:../uvc.c      ****                 break;
2153:../uvc.c      **** #endif
2154:../uvc.c      **** #else
2155:../uvc.c      ****             case 11:
2156:../uvc.c      ****             case 18:
2157:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2158:../uvc.c      ****                 break;
2159:../uvc.c      **** 
2160:../uvc.c      ****             case 8:
2161:../uvc.c      ****                 socket = 0;
2162:../uvc.c      ****                 break;
2163:../uvc.c      **** 
2164:../uvc.c      ****             case 15:
2165:../uvc.c      ****                 socket = 1;
2166:../uvc.c      ****                 break;
2167:../uvc.c      **** 
2168:../uvc.c      **** #endif
2169:../uvc.c      ****              default:
2170:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2171:../uvc.c      ****                 /* Unexpected current state. Return error. */
2172:../uvc.c      ****                return 1;
2173:../uvc.c      ****         }
2174:../uvc.c      ****     }
2175:../uvc.c      **** 
2176:../uvc.c      ****     if (socket != 0xFF)
2177:../uvc.c      ****     {
2178:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
2179:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
2180:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
2181:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
2182:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
2183:../uvc.c      ****         {
2184:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
2185:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
2186:../uvc.c      ****         }
2187:../uvc.c      ****     }
2188:../uvc.c      **** 
2189:../uvc.c      ****     return 0;
2190:../uvc.c      **** }
2191:../uvc.c      **** 
2192:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
2193:../uvc.c      **** void
2194:../uvc.c      **** CyFxGpifCB (
2195:../uvc.c      ****         CyU3PGpifEventType event,
2196:../uvc.c      ****         uint8_t currentState
2197:../uvc.c      ****         )
2198:../uvc.c      **** {
2199:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
2200:../uvc.c      ****     {
2201:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
2202:../uvc.c      ****     	           in the UVC implementation. */
2203:../uvc.c      ****     	//hitFV = CyTrue;
2204:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
2205:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
2206:../uvc.c      ****     }
2207:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
2208:../uvc.c      **** }
2209:../uvc.c      **** 
2210:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
2211:../uvc.c      **** static void
2212:../uvc.c      **** CyFxUVCApplnDebugInit (
2213:../uvc.c      ****         void)
2214:../uvc.c      **** {
2215:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
2216:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
2217:../uvc.c      **** 
2218:../uvc.c      ****     /* Initialize the UART for printing debug messages */
2219:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
2220:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2221:../uvc.c      ****     {
2222:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
2223:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2224:../uvc.c      ****     }
2225:../uvc.c      **** 
2226:../uvc.c      ****     /* Set UART Configuration */
2227:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
2228:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
2229:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
2230:../uvc.c      ****     uartConfig.txEnable = CyTrue;
2231:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
2232:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
2233:../uvc.c      ****     uartConfig.isDma    = CyTrue;
2234:../uvc.c      **** 
2235:../uvc.c      ****     /* Set the UART configuration */
2236:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
2237:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2238:../uvc.c      ****     {
2239:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2240:../uvc.c      ****     }
2241:../uvc.c      **** 
2242:../uvc.c      ****     /* Set the UART transfer */
2243:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
2244:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2245:../uvc.c      ****     {
2246:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2247:../uvc.c      ****     }
2248:../uvc.c      **** 
2249:../uvc.c      ****     /* Initialize the Debug logger module. */
2250:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
2251:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2252:../uvc.c      ****     {
2253:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2254:../uvc.c      ****     }
2255:../uvc.c      **** 
2256:../uvc.c      ****     /* Disable log message headers. */
2257:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
2258:../uvc.c      **** }
2259:../uvc.c      **** 
2260:../uvc.c      **** /* I2C initialization. */
2261:../uvc.c      **** static void
2262:../uvc.c      **** CyFxUVCApplnI2CInit (void)
2263:../uvc.c      **** {
2264:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
2265:../uvc.c      ****     CyU3PReturnStatus_t status;
2266:../uvc.c      **** 
2267:../uvc.c      ****     status = CyU3PI2cInit ();
2268:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
2269:../uvc.c      ****     {
2270:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
2271:../uvc.c      ****         CyFxAppErrorHandler (status);
2272:../uvc.c      ****     }
2273:../uvc.c      **** 
2274:../uvc.c      ****     /*  Set I2C Configuration */
2275:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
2276:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
2277:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
2278:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
2279:../uvc.c      **** 
2280:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
2281:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
2282:../uvc.c      ****     {
2283:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
2284:../uvc.c      ****         CyFxAppErrorHandler (status);
2285:../uvc.c      ****     }
2286:../uvc.c      **** }
2287:../uvc.c      **** 
2288:../uvc.c      **** #ifdef BACKFLOW_DETECT
2289:../uvc.c      **** static void CyFxUvcAppPibCallback (
2290:../uvc.c      ****         CyU3PPibIntrType cbType,
2291:../uvc.c      ****         uint16_t cbArg)
2292:../uvc.c      **** {
2293:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
2294:../uvc.c      ****     {
2295:../uvc.c      ****         if (!back_flow_detected)
2296:../uvc.c      ****         {
2297:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
2298:../uvc.c      ****             back_flow_detected = 1;
2299:../uvc.c      ****         }
2300:../uvc.c      ****     }
2301:../uvc.c      **** }
2302:../uvc.c      **** #endif
2303:../uvc.c      **** 
2304:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2305:../uvc.c      **** static void
2306:../uvc.c      **** CyFxUvcAppDebugCallback (
2307:../uvc.c      ****         CyU3PDmaChannel   *handle,
2308:../uvc.c      ****         CyU3PDmaCbType_t   type,
2309:../uvc.c      ****         CyU3PDmaCBInput_t *input)
2310:../uvc.c      **** {
2311:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2312:../uvc.c      ****     {
2313:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
2314:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
2315:../uvc.c      ****     }
2316:../uvc.c      **** }
2317:../uvc.c      **** #endif
2318:../uvc.c      **** 
2319:../uvc.c      **** #if 0
2320:../uvc.c      **** static void CyFxAppIntEpCb(
2321:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
2322:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
2323:../uvc.c      **** 		uint8_t  ebNum)
2324:../uvc.c      **** 		{
2325:../uvc.c      **** 			//CyBool_t value;
2326:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
2327:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
2328:../uvc.c      **** 
2329:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
2330:../uvc.c      **** 		}
2331:../uvc.c      **** #endif
2332:../uvc.c      **** 
2333:../uvc.c      **** /* This function initializes the USB Module, creates event group,
2334:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
2335:../uvc.c      ****    configures the DMA module for the UVC Application */
2336:../uvc.c      **** static void
2337:../uvc.c      **** CyFxUVCApplnInit (void)
2338:../uvc.c      **** {
2339:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
2340:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
2341:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
2342:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
2343:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
2344:../uvc.c      ****     CyU3PPibClock_t              pibclock;
2345:../uvc.c      **** 
2346:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
2347:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
2348:../uvc.c      **** 
2349:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2350:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
2351:../uvc.c      **** #endif
2352:../uvc.c      **** 
2353:../uvc.c      ****     /* Create UVC event group */
2354:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
2355:../uvc.c      ****     if (apiRetStatus != 0)
2356:../uvc.c      ****     {
2357:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
2358:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2359:../uvc.c      ****     }
2360:../uvc.c      **** 
2361:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2362:../uvc.c      ****     CyFxUvcAppPTZInit ();
2363:../uvc.c      **** #endif
2364:../uvc.c      **** 
2365:../uvc.c      ****     isUsbConnected = CyFalse;
2366:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
2367:../uvc.c      **** 
2368:../uvc.c      ****     /* Init the GPIO module */
2369:../uvc.c      ****     gpioClock.fastClkDiv = 2;
2370:../uvc.c      ****     gpioClock.slowClkDiv = 2;
2371:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
2372:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
2373:../uvc.c      ****     gpioClock.halfDiv    = 0;
2374:../uvc.c      **** 
2375:../uvc.c      ****     /* Initialize Gpio interface */
2376:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
2377:../uvc.c      ****     if (apiRetStatus != 0)
2378:../uvc.c      ****     {
2379:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
2380:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2381:../uvc.c      ****     }
2382:../uvc.c      **** 
2383:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
2384:../uvc.c      ****      * must use GpioOverride to configure it */
2385:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
2386:../uvc.c      ****     if (apiRetStatus != 0)
2387:../uvc.c      ****     {
2388:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
2389:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2390:../uvc.c      ****     }
2391:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
2392:../uvc.c      ****     if (apiRetStatus != 0)
2393:../uvc.c      ****     {
2394:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
2395:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2396:../uvc.c      ****     }
2397:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
2398:../uvc.c      ****     if (apiRetStatus != 0)
2399:../uvc.c      ****     {
2400:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
2401:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2402:../uvc.c      ****     }
2403:../uvc.c      **** 
2404:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
2405:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2406:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2407:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2408:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2409:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2410:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
2411:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2412:../uvc.c      ****     {
2413:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
2414:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2415:../uvc.c      ****     }
2416:../uvc.c      **** 
2417:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
2418:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2419:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2420:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2421:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2422:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2423:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2424:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
2425:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2426:../uvc.c      ****     {
2427:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
2428:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2429:../uvc.c      ****     }
2430:../uvc.c      **** 
2431:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
2432:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2433:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
2434:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
2435:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
2436:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
2437:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2438:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
2439:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2440:../uvc.c      ****     {
2441:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
2442:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2443:../uvc.c      ****     }
2444:../uvc.c      **** 
2445:../uvc.c      ****     /* Initialize the P-port. */
2446:../uvc.c      ****     pibclock.clkDiv      = 2;
2447:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
2448:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
2449:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
2450:../uvc.c      **** 
2451:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
2452:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2453:../uvc.c      ****     {
2454:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2455:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2456:../uvc.c      ****     }
2457:../uvc.c      **** 
2458:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
2459:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
2460:../uvc.c      **** 
2461:../uvc.c      **** #ifdef BACKFLOW_DETECT
2462:../uvc.c      ****     back_flow_detected = 0;
2463:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
2464:../uvc.c      **** #endif
2465:../uvc.c      **** 
2466:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
2467:../uvc.c      ****     SensorReset ();
2468:../uvc.c      ****     CyU3PThreadSleep(5000);
2469:../uvc.c      ****     //SensorInit ();
2470:../uvc.c      **** 
2471:../uvc.c      ****     /* USB initialization. */
2472:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
2473:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2474:../uvc.c      ****     {
2475:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2476:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2477:../uvc.c      ****     }
2478:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
2479:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
2480:../uvc.c      **** 
2481:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
2482:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
2483:../uvc.c      **** 
2484:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
2485:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
2486:../uvc.c      **** 
2487:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
2488:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
2489:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
2490:../uvc.c      **** 
2491:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
2492:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
2493:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
2494:../uvc.c      **** 
2495:../uvc.c      ****     /* Configuration descriptors. */
2496:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
2497:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
2498:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
2499:../uvc.c      **** 
2500:../uvc.c      ****     /* String Descriptors */
2501:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
2502:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
2503:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
2504:../uvc.c      **** 
2505:../uvc.c      ****     /* Configure the status interrupt endpoint.
2506:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
2507:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
2508:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
2509:../uvc.c      ****      */
2510:../uvc.c      ****     endPointConfig.enable   = 1;
2511:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
2512:../uvc.c      ****     endPointConfig.pcktSize = 64;
2513:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2514:../uvc.c      ****     endPointConfig.streams  = 0;
2515:../uvc.c      ****     endPointConfig.burstLen = 1;
2516:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
2517:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2518:../uvc.c      ****     {
2519:../uvc.c      ****         /* Error Handling */
2520:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2521:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2522:../uvc.c      ****     }
2523:../uvc.c      **** 
2524:../uvc.c      ****     /* create a DMA for interrupt endpoint */
2525:../uvc.c      ****     dmaInterConfig.size           = 1024;
2526:../uvc.c      ****     dmaInterConfig.count          = 1;
2527:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2528:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
2529:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
2530:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
2531:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
2532:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2533:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2534:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2535:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2536:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2537:../uvc.c      ****             &dmaInterConfig);
2538:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2539:../uvc.c      ****     {
2540:../uvc.c      ****         /* Error handling */
2541:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2542:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2543:../uvc.c      ****     }
2544:../uvc.c      **** 
2545:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2546:../uvc.c      ****     if (glInterStaBuffer == 0)
2547:../uvc.c      ****     {
2548:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2549:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2550:../uvc.c      ****     }
2551:../uvc.c      **** 
2552:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2553:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
2554:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2555:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2556:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2557:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2558:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2559:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2560:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2561:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2562:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2563:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2564:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2565:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2566:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2567:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2568:../uvc.c      ****             &dmaMultiConfig);
2569:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2570:../uvc.c      ****     {
2571:../uvc.c      ****         /* Error handling */
2572:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2573:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2574:../uvc.c      ****     }
2575:../uvc.c      **** 
2576:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2577:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2578:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2579:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2580:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2581:../uvc.c      ****      */
2582:../uvc.c      **** 
2583:../uvc.c      ****     endPointConfig.enable   = 1;
2584:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2585:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2586:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2587:../uvc.c      ****     endPointConfig.streams  = 0;
2588:../uvc.c      ****     endPointConfig.burstLen = 1;
2589:../uvc.c      **** 
2590:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2591:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2592:../uvc.c      ****     {
2593:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2594:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2595:../uvc.c      ****     }
2596:../uvc.c      **** 
2597:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2598:../uvc.c      **** 
2599:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2600:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2601:../uvc.c      ****     {
2602:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2603:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2604:../uvc.c      ****     }
2605:../uvc.c      **** 
2606:../uvc.c      ****     channelConfig.size           = 1024;
2607:../uvc.c      ****     channelConfig.count          = 1;
2608:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2609:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2610:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2611:../uvc.c      ****     channelConfig.prodHeader     = 0;
2612:../uvc.c      ****     channelConfig.prodFooter     = 0;
2613:../uvc.c      ****     channelConfig.consHeader     = 0;
2614:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2615:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2616:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2617:../uvc.c      **** 
2618:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2619:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2620:../uvc.c      ****     {
2621:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2622:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2623:../uvc.c      ****     }
2624:../uvc.c      **** 
2625:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2626:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2627:../uvc.c      ****     {
2628:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2629:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2630:../uvc.c      ****     }
2631:../uvc.c      **** 
2632:../uvc.c      ****     channelConfig.size           = 1024;
2633:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2634:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2635:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2636:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2637:../uvc.c      ****     channelConfig.prodHeader     = 0;
2638:../uvc.c      ****     channelConfig.prodFooter     = 0;
2639:../uvc.c      ****     channelConfig.consHeader     = 0;
2640:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2641:../uvc.c      ****     channelConfig.notification   = 0;
2642:../uvc.c      ****     channelConfig.cb             = 0;
2643:../uvc.c      **** 
2644:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2645:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2646:../uvc.c      ****     {
2647:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2648:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2649:../uvc.c      ****     }
2650:../uvc.c      **** 
2651:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2652:../uvc.c      ****     if (glDebugRspBuffer == 0)
2653:../uvc.c      ****     {
2654:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2655:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2656:../uvc.c      ****     }
2657:../uvc.c      **** #endif
2658:../uvc.c      **** 
2659:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2660:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2661:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2662:../uvc.c      ****     {
2663:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2664:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2665:../uvc.c      ****     }
2666:../uvc.c      **** 
2667:../uvc.c      ****     CyU3PBusyWait(100);
2668:../uvc.c      **** 
2669:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2670:../uvc.c      **** 
2671:../uvc.c      ****     endPointConfig.enable   = 1;
2672:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2673:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2674:../uvc.c      ****     {
2675:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2676:../uvc.c      ****     	endPointConfig.burstLen = 16;
2677:../uvc.c      ****     }
2678:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2679:../uvc.c      ****     {
2680:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2681:../uvc.c      ****     	endPointConfig.burstLen = 1;
2682:../uvc.c      ****     }
2683:../uvc.c      ****     endPointConfig.streams  = 0;
2684:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2685:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2686:../uvc.c      ****     {
2687:../uvc.c      ****         /* Error Handling */
2688:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2689:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2690:../uvc.c      ****     }
2691:../uvc.c      **** #if 0    //for still image method 3 using
2692:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2693:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2694:../uvc.c      ****     {
2695:../uvc.c      ****         /* Error Handling */
2696:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2697:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2698:../uvc.c      ****     }
2699:../uvc.c      **** #endif
2700:../uvc.c      **** 
2701:../uvc.c      **** }
2702:../uvc.c      **** 
2703:../uvc.c      **** /*
2704:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2705:../uvc.c      ****  * streaming session is started.
2706:../uvc.c      ****  */
2707:../uvc.c      **** static void
2708:../uvc.c      **** CyFxUvcAppGpifInit (
2709:../uvc.c      ****         void)
2710:../uvc.c      **** {
2711:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2712:../uvc.c      **** 
2713:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2714:../uvc.c      ****     {
2715:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2716:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2717:../uvc.c      ****     }
2718:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2719:../uvc.c      ****     {
2720:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2721:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2722:../uvc.c      ****     }
2723:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2724:../uvc.c      ****     {
2725:../uvc.c      ****         /* Error Handling */
2726:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2727:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2728:../uvc.c      ****     }
2729:../uvc.c      **** 
2730:../uvc.c      ****     /* Start the state machine from the designated start state. */
2731:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2732:../uvc.c      ****     {
2733:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2734:../uvc.c      ****     }
2735:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2736:../uvc.c      ****     {
2737:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2738:../uvc.c      ****     }
2739:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2740:../uvc.c      ****     {
2741:../uvc.c      ****         /* Error Handling */
2742:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2743:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2744:../uvc.c      ****     }
2745:../uvc.c      **** }
2746:../uvc.c      **** 
2747:../uvc.c      **** /*
2748:../uvc.c      ****  * Entry function for the UVC Application Thread
2749:../uvc.c      ****  */
2750:../uvc.c      **** 
2751:../uvc.c      **** uint32_t posTick;
2752:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2753:../uvc.c      **** 
2754:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2755:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2756:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2757:../uvc.c      **** }
2758:../uvc.c      **** 
2759:../uvc.c      **** 
2760:../uvc.c      **** void
2761:../uvc.c      **** UVCAppThread_Entry (
2762:../uvc.c      ****         uint32_t input)
2763:../uvc.c      **** {
2764:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2765:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2766:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2767:../uvc.c      ****     uint8_t i = 0;
2768:../uvc.c      ****     uint32_t flag;
2769:../uvc.c      ****     uint32_t prinflag = 0;
2770:../uvc.c      **** static uint8_t IMcount = 0;
2771:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2772:../uvc.c      ****     uint32_t frameCnt = 0;
2773:../uvc.c      **** #endif
2774:../uvc.c      ****     /* Initialize the Uart Debug Module */
2775:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2776:../uvc.c      **** 
2777:../uvc.c      ****     /* Initialize the I2C interface */
2778:../uvc.c      **** 	while (i++ < 6){
2779:../uvc.c      **** 		CyU3PThreadSleep(500);
2780:../uvc.c      **** 	}
2781:../uvc.c      **** 
2782:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2783:../uvc.c      **** 
2784:../uvc.c      ****     /* Initialize the UVC Application */
2785:../uvc.c      ****     CyFxUVCApplnInit ();
2786:../uvc.c      ****     /*
2787:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2788:../uvc.c      **** 
2789:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2790:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2791:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2792:../uvc.c      **** 
2793:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2794:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2795:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2796:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2797:../uvc.c      **** 
2798:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2799:../uvc.c      ****        of handling the abort request.
2800:../uvc.c      ****      */
2801:../uvc.c      **** 
2802:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
2803:../uvc.c      ****     //CyU3PThreadSleep(1000);
2804:../uvc.c      **** 
2805:../uvc.c      ****     for (;;)
2806:../uvc.c      ****     {
2807:../uvc.c      ****         /* Waiting for the Video Stream Event */
2808:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2809:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2810:../uvc.c      ****         {
2811:../uvc.c      **** #if 0 //test for new firmware no video bring up
2812:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2813:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2814:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2815:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2816:../uvc.c      ****             {
2817:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2818:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2819:../uvc.c      ****                 {
2820:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2821:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2822:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2823:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2824:../uvc.c      **** #endif
2825:../uvc.c      **** #endif
2826:../uvc.c      ****                     }
2827:../uvc.c      ****                 else
2828:../uvc.c      ****                 {
2829:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2830:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2831:../uvc.c      **** #ifdef USB_LOWRES_IMG
2832:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2833:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2834:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2835:../uvc.c      **** #endif
2836:../uvc.c      **** #endif
2837:../uvc.c      ****                 }
2838:../uvc.c      **** 
2839:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2840:../uvc.c      ****                 prodCount++;
2841:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2842:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2843:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2844:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2845:../uvc.c      ****                 {
2846:../uvc.c      ****                     prodCount--;
2847:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2848:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2849:../uvc.c      ****                 }
2850:../uvc.c      ****             }
2851:../uvc.c      **** #endif
2852:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2853:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2854:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2855:../uvc.c      ****             {
2856:../uvc.c      ****             	if(0&&(prinflag == 0)){
2857:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2858:../uvc.c      ****             		prinflag = 1;
2859:../uvc.c      ****             	}
2860:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2861:../uvc.c      ****             	fb=0;
2862:../uvc.c      ****             	pb=0;
2863:../uvc.c      ****             	pbc=0;
2864:../uvc.c      ****                 prodCount = 0;
2865:../uvc.c      ****                 consCount = 0;
2866:../uvc.c      ****                 hitFV     = CyFalse;
2867:../uvc.c      **** 
2868:../uvc.c      **** #ifdef BACKFLOW_DETECT
2869:../uvc.c      ****                 back_flow_detected = 0;
2870:../uvc.c      **** #endif
2871:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2872:../uvc.c      ****                 frameCnt++;
2873:../uvc.c      **** #endif
2874:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2875:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2876:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2877:../uvc.c      ****                 //}
2878:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2879:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2880:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2881:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
2882:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
2883:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
2884:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
2885:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
2886:../uvc.c      ****                      	//CyU3PThreadSleep(100);
2887:../uvc.c      ****                 		stiflag = 0xFF;
2888:../uvc.c      ****                 		IMcount = 0;
2889:../uvc.c      ****                 	}
2890:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
2891:../uvc.c      **** 
2892:../uvc.c      ****                  		if(IMcount++ >= 0x3){
2893:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
2894:../uvc.c      ****                 		stiflag = 0x0F;
2895:../uvc.c      ****                 		IMcount = 0;
2896:../uvc.c      ****                 		}
2897:../uvc.c      ****                  		/*if(IMcount > 0x4){
2898:../uvc.c      ****                 			stiflag = 0x0F;
2899:../uvc.c      ****                 			IMcount = 0;
2900:../uvc.c      ****                 		}*/
2901:../uvc.c      **** 
2902:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
2903:../uvc.c      ****                     //CyU3PThreadSleep(400);
2904:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2905:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2906:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2907:../uvc.c      **** 
2908:../uvc.c      ****                 	if(IMcount++ >= 0x3)
2909:../uvc.c      ****                 	{
2910:../uvc.c      ****                     switch (setRes)
2911:../uvc.c      ****                      {
2912:../uvc.c      ****                  	case 1: //1944
2913:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
2914:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2915:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
2916:../uvc.c      ****                  		break;
2917:../uvc.c      ****                  	case 2: //1080
2918:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
2919:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2920:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
2921:../uvc.c      ****                  		break;
2922:../uvc.c      ****                  	case 3: //720
2923:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
2924:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2925:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
2926:../uvc.c      ****                  		break;
2927:../uvc.c      ****                  	case 4: //VGA
2928:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
2929:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2930:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
2931:../uvc.c      ****                  		break;
2932:../uvc.c      ****                  	default:
2933:../uvc.c      ****                  		break;
2934:../uvc.c      ****                      }
2935:../uvc.c      ****                     IMcount = 0;
2936:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2937:../uvc.c      ****                 	stiflag = 0x0;
2938:../uvc.c      ****                 	}
2939:../uvc.c      ****                 }
2940:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
2941:../uvc.c      ****                 /* Reset the DMA channel. */
2942:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2943:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2944:../uvc.c      ****                 {
2945:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2946:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2947:../uvc.c      ****                 }
2948:../uvc.c      **** 
2949:../uvc.c      ****                 /* Start Channel Immediately */
2950:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2951:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2952:../uvc.c      ****                 {
2953:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2954:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2955:../uvc.c      ****                 }
2956:../uvc.c      **** 
2957:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2958:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2959:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2960:../uvc.c      ****                 }
2961:../uvc.c      ****         }
2962:../uvc.c      ****         else
2963:../uvc.c      ****         {
2964:../uvc.c      ****             /* If we have a stream abort request pending. */
2965:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2966:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2967:../uvc.c      ****             {
2968:../uvc.c      ****                 hitFV     = CyFalse;
2969:../uvc.c      ****                 prodCount = 0;
2970:../uvc.c      ****                 consCount = 0;
2971:../uvc.c      ****                 if(0&&(prinflag == 0)){
2972:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2973:../uvc.c      ****                 	prinflag = 1;
2974:../uvc.c      ****                 }
2975:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2976:../uvc.c      ****                 fb=0;
2977:../uvc.c      ****                 pb=0;
2978:../uvc.c      ****                 pbc=0;
2979:../uvc.c      **** 
2980:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2981:../uvc.c      ****                 {
2982:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2983:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2984:../uvc.c      ****                     {
2985:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2986:../uvc.c      ****                     }
2987:../uvc.c      **** 
2988:../uvc.c      ****                     /* Flush the Endpoint memory */
2989:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2990:../uvc.c      ****                 }
2991:../uvc.c      **** 
2992:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2993:../uvc.c      ****             }
2994:../uvc.c      ****             else
2995:../uvc.c      ****             {
2996:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2997:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2998:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2999:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
3000:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
3001:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3002:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3003:../uvc.c      ****                 {
3004:../uvc.c      ****                     /* Error handling */
3005:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
3006:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3007:../uvc.c      ****                 }
3008:../uvc.c      **** 
3009:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
3010:../uvc.c      ****                 if (gpif_initialized == CyFalse)
3011:../uvc.c      ****                 {
3012:../uvc.c      **** #if 0
3013:../uvc.c      ****                 	//for start up of the AF Lens
3014:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3015:../uvc.c      ****                     CyU3PThreadSleep(500);
3016:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3017:../uvc.c      ****                     CyU3PThreadSleep(500);
3018:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
3019:../uvc.c      ****                    	CyU3PThreadSleep(300);
3020:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3021:../uvc.c      ****                     CyU3PThreadSleep(500);
3022:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3023:../uvc.c      ****                     CyU3PThreadSleep(500);
3024:../uvc.c      **** #endif
3025:../uvc.c      **** #if 0
3026:../uvc.c      ****                     switch (setRes)
3027:../uvc.c      ****                     {
3028:../uvc.c      ****                     	case 1: //1944
3029:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x64, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3030:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3031:../uvc.c      ****                     		break;
3032:../uvc.c      ****                     	case 2: //1080
3033:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x54, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3034:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3035:../uvc.c      ****                     		break;
3036:../uvc.c      ****                     	case 3: //720
3037:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x45, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3038:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3039:../uvc.c      ****                     		break;
3040:../uvc.c      ****                     	default:
3041:../uvc.c      ****                     		break;
3042:../uvc.c      ****                     }
3043:../uvc.c      **** #endif
3044:../uvc.c      ****                     CyFxUvcAppGpifInit ();
3045:../uvc.c      **** 
3046:../uvc.c      ****                     gpif_initialized = CyTrue;
3047:../uvc.c      ****                     CyU3PThreadSleep(200);
3048:../uvc.c      ****                     
3049:../uvc.c      ****                 }
3050:../uvc.c      ****                 else
3051:../uvc.c      ****                 {
3052:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
3053:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
3054:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3055:../uvc.c      ****                 }
3056:../uvc.c      ****             }
3057:../uvc.c      ****         }
3058:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
3059:../uvc.c      **** 
3060:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
3061:../uvc.c      ****         CyU3PThreadRelinquish ();
3062:../uvc.c      ****     }
3063:../uvc.c      **** }
3064:../uvc.c      **** 
3065:../uvc.c      **** /*
3066:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
3067:../uvc.c      ****  */
3068:../uvc.c      **** 
3069:../uvc.c      **** static void
3070:../uvc.c      **** UVCHandleProcessingUnitRqts (
3071:../uvc.c      ****         void)
3072:../uvc.c      **** {
3073:../uvc.c      ****     uint8_t CtrlAdd;
3074:../uvc.c      **** #ifdef DbgInfo
3075:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3076:../uvc.c      **** #endif
3077:../uvc.c      ****     switch (wValue)
3078:../uvc.c      ****     {
3079:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
3080:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
3081:../uvc.c      ****     		ControlHandle(BLCCtlID0);
3082:../uvc.c      ****     		break;
3083:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
3084:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
3085:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
3086:../uvc.c      ****     		break;
3087:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
3088:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
3089:../uvc.c      **** 			ControlHandle(ConsCtlID2);
3090:../uvc.c      **** 			break;
3091:../uvc.c      **** 
3092:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
3093:../uvc.c      **** 
3094:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
3095:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
3096:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
3097:../uvc.c      ****       		break;
3098:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
3099:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
3100:../uvc.c      ****      		ControlHandle(HueCtlID5);
3101:../uvc.c      ****      		break;
3102:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
3103:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
3104:../uvc.c      ****           		ControlHandle(SaturCtlID6);
3105:../uvc.c      ****           		break;
3106:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
3107:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
3108:../uvc.c      ****           		ControlHandle(ShapCtlID7);
3109:../uvc.c      ****           		break;
3110:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
3111:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
3112:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
3113:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
3114:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
3115:../uvc.c      ****     		break;
3116:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
3117:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
3118:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
3119:../uvc.c      ****     		break;
3120:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
3121:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
3122:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
3123:../uvc.c      ****     		break;
3124:../uvc.c      **** 
3125:../uvc.c      ****         default:
3126:../uvc.c      ****             /*
3127:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3128:../uvc.c      ****              * other controls.
3129:../uvc.c      ****              */
3130:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3131:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3132:../uvc.c      ****             break;
3133:../uvc.c      ****     }
3134:../uvc.c      **** }
3135:../uvc.c      **** 
3136:../uvc.c      **** /*
3137:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
3138:../uvc.c      ****  */
3139:../uvc.c      **** static void
3140:../uvc.c      **** UVCHandleCameraTerminalRqts (
3141:../uvc.c      ****         void)
3142:../uvc.c      **** {
3143:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3144:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3145:../uvc.c      ****     uint16_t readCount;
3146:../uvc.c      ****     uint16_t zoomVal;
3147:../uvc.c      ****     int32_t  panVal, tiltVal;
3148:../uvc.c      ****     CyBool_t sendData = CyFalse;
3149:../uvc.c      **** #endif
3150:../uvc.c      ****     uint8_t CtrlAdd;
3151:../uvc.c      **** 
3152:../uvc.c      ****     switch (wValue)
3153:../uvc.c      ****     {
3154:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
3155:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
3156:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
3157:../uvc.c      ****     		break;
3158:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
3159:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
3160:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
3161:../uvc.c      ****     		break;
3162:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
3163:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
3164:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
3165:../uvc.c      **** 			break;
3166:../uvc.c      **** 
3167:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
3168:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
3169:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
3170:../uvc.c      **** 			break;
3171:../uvc.c      **** 
3172:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
3173:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
3174:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
3175:../uvc.c      ****       		break;
3176:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
3177:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
3178:../uvc.c      ****      		CTControlHandle(FocACtlID5);
3179:../uvc.c      ****      		break;
3180:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
3181:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
3182:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
3183:../uvc.c      ****           		break;
3184:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
3185:../uvc.c      ****           		break;
3186:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
3187:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
3188:../uvc.c      ****      		CTControlHandle(IriACtlID7);
3189:../uvc.c      ****      		break;
3190:../uvc.c      **** 
3191:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
3192:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
3193:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
3194:../uvc.c      ****     		break;
3195:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3196:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
3197:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
3198:../uvc.c      ****     		break;
3199:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
3200:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
3201:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
3202:../uvc.c      ****     		break;
3203:../uvc.c      **** 
3204:../uvc.c      ****         default:
3205:../uvc.c      ****             /*
3206:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3207:../uvc.c      ****              * other controls.
3208:../uvc.c      ****              */
3209:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3210:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3211:../uvc.c      ****             break;
3212:../uvc.c      ****     }
3213:../uvc.c      **** 
3214:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3215:../uvc.c      ****     switch (wValue)
3216:../uvc.c      ****     {
3217:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3218:../uvc.c      ****             switch (bRequest)
3219:../uvc.c      ****             {
3220:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3221:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
3222:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3223:../uvc.c      ****                     break;
3224:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
3225:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
3226:../uvc.c      ****                     sendData = CyTrue;
3227:../uvc.c      ****                     break;
3228:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
3229:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
3230:../uvc.c      ****                     sendData = CyTrue;
3231:../uvc.c      ****                     break;
3232:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
3233:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
3234:../uvc.c      ****                     sendData = CyTrue;
3235:../uvc.c      ****                     break;
3236:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
3237:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
3238:../uvc.c      ****                     sendData = CyTrue;
3239:../uvc.c      ****                     break;
3240:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
3241:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
3242:../uvc.c      ****                     sendData = CyTrue;
3243:../uvc.c      ****                     break;
3244:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3245:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3246:../uvc.c      ****                             glEp0Buffer, &readCount);
3247:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3248:../uvc.c      ****                     {
3249:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
3250:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
3251:../uvc.c      ****                     }
3252:../uvc.c      ****                     break;
3253:../uvc.c      ****                 default:
3254:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3255:../uvc.c      ****                     break;
3256:../uvc.c      ****             }
3257:../uvc.c      **** 
3258:../uvc.c      ****             if (sendData)
3259:../uvc.c      ****             {
3260:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
3261:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
3262:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
3263:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3264:../uvc.c      ****             }
3265:../uvc.c      ****             break;
3266:../uvc.c      **** 
3267:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
3268:../uvc.c      ****             switch (bRequest)
3269:../uvc.c      ****             {
3270:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3271:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
3272:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3273:../uvc.c      ****                     break;
3274:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3275:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
3276:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
3277:../uvc.c      ****                     sendData = CyTrue;
3278:../uvc.c      ****                     break;
3279:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3280:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
3281:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
3282:../uvc.c      ****                     sendData = CyTrue;
3283:../uvc.c      ****                     break;
3284:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3285:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
3286:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
3287:../uvc.c      ****                     sendData = CyTrue;
3288:../uvc.c      ****                     break;
3289:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
3290:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
3291:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
3292:../uvc.c      ****                     sendData = CyTrue;
3293:../uvc.c      ****                     break;
3294:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
3295:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
3296:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
3297:../uvc.c      ****                     sendData = CyTrue;
3298:../uvc.c      ****                     break;
3299:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3300:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3301:../uvc.c      ****                             glEp0Buffer, &readCount);
3302:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3303:../uvc.c      ****                     {
3304:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
3305:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
3306:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
3307:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
3308:../uvc.c      **** 
3309:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
3310:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
3311:../uvc.c      ****                     }
3312:../uvc.c      ****                     break;
3313:../uvc.c      ****                 default:
3314:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3315:../uvc.c      ****                     break;
3316:../uvc.c      ****             }
3317:../uvc.c      **** 
3318:../uvc.c      ****             if (sendData)
3319:../uvc.c      ****             {
3320:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
3321:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
3322:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
3323:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
3324:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
3325:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
3326:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
3327:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
3328:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
3329:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3330:../uvc.c      ****             }
3331:../uvc.c      ****             break;
3332:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
3333:../uvc.c      ****         default:
3334:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
3335:../uvc.c      ****             break;
3336:../uvc.c      ****     }
3337:../uvc.c      **** #endif
3338:../uvc.c      **** }
3339:../uvc.c      **** 
3340:../uvc.c      **** /*
3341:../uvc.c      ****  * Handler for UVC Interface control requests.
3342:../uvc.c      ****  */
3343:../uvc.c      **** static void
3344:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
3345:../uvc.c      ****         void)
3346:../uvc.c      **** {
3347:../uvc.c      **** 
3348:../uvc.c      ****     switch (wValue)
3349:../uvc.c      ****     {
3350:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
3351:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3352:../uvc.c      ****     		break;
3353:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
3354:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
3355:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
3356:../uvc.c      ****     		break;
3357:../uvc.c      ****     	default:
3358:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
3359:../uvc.c      ****      		break;
3360:../uvc.c      ****     }
3361:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
3362:../uvc.c      **** 
3363:../uvc.c      **** }
3364:../uvc.c      **** 
3365:../uvc.c      **** /*
3366:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
3367:../uvc.c      ****  */
3368:../uvc.c      **** static void
3369:../uvc.c      **** UVCHandleExtensionUnitRqts (
3370:../uvc.c      ****         void)
3371:../uvc.c      **** {
3372:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
3373:../uvc.c      **** 
3374:../uvc.c      **** #ifdef DbgInfo
3375:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3376:../uvc.c      **** #endif
3377:../uvc.c      ****     switch (wValue)
3378:../uvc.c      ****     {
3379:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
3380:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
3381:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
3382:../uvc.c      ****     		break;
3383:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
3384:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
3385:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
3386:../uvc.c      ****     		break;
3387:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
3388:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
3389:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
3390:../uvc.c      ****      		break;
3391:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
3392:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
3393:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
3394:../uvc.c      ****     		break;
3395:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
3396:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
3397:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
3398:../uvc.c      ****     		break;
3399:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
3400:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
3401:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
3402:../uvc.c      ****      		break;
3403:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
3404:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
3405:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
3406:../uvc.c      ****     		break;
3407:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
3408:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
3409:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
3410:../uvc.c      ****     		break;
3411:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
3412:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
3413:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
3414:../uvc.c      ****      		break;
3415:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
3416:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
3417:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
3418:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
3419:../uvc.c      ****     		}else/* no support for 1080p camera */
3420:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
3421:../uvc.c      ****     		break;
3422:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
3423:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
3424:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
3425:../uvc.c      ****     		break;
3426:../uvc.c      **** 		case CY_FX_EXT_CONTROL_12: //AEx shutter level CONTROL12
3427:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCtlShutlevCtlID11][0];
3428:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
3429:../uvc.c      ****     		break;
3430:../uvc.c      **** 
3431:../uvc.c      ****     		//ExtCtlShutlevCtlID11
3432:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
3433:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
3434:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
3435:../uvc.c      ****     		break;
3436:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
3437:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
3438:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
3439:../uvc.c      ****     		//break;
3440:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
3441:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
3442:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
3443:../uvc.c      ****     		break;
3444:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
3445:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
3446:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
3447:../uvc.c      ****     		break;
3448:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
3449:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET][0];
3450:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
3451:../uvc.c      ****     		break;
3452:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
3453:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET][0];
3454:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
3455:../uvc.c      ****     		break;
3456:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
3457:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET][0];
3458:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
3459:../uvc.c      ****     		break;
3460:../uvc.c      ****    	default:
3461:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
3462:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3463:../uvc.c      ****     		break;
3464:../uvc.c      ****     }
3465:../uvc.c      **** 
3466:../uvc.c      **** }
3467:../uvc.c      **** 
3468:../uvc.c      **** /*
3469:../uvc.c      ****  * Handler for the video streaming control requests.
3470:../uvc.c      ****  */
3471:../uvc.c      **** static void
3472:../uvc.c      **** UVCHandleVideoStreamingRqts (
3473:../uvc.c      ****         void)
3474:../uvc.c      **** {
3475:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3476:../uvc.c      ****     uint16_t readCount;
3477:../uvc.c      **** 
3478:../uvc.c      ****     switch (wValue)
3479:../uvc.c      ****     {
3480:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
3481:../uvc.c      ****             switch (bRequest)
3482:../uvc.c      ****             {
3483:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3484:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3485:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3486:../uvc.c      ****                     break;
3487:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3488:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3489:../uvc.c      ****                     glEp0Buffer[1] = 0;
3490:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3491:../uvc.c      ****                     break;
3492:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3493:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3494:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3495:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3496:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3497:../uvc.c      ****                     {
3498:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
3499:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
3500:../uvc.c      **** 
3501:../uvc.c      ****                     }
3502:../uvc.c      ****                     else
3503:../uvc.c      ****                     {
3504:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3505:../uvc.c      ****                     }
3506:../uvc.c      ****                     break;
3507:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3508:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3509:../uvc.c      ****                             glCommitCtrl, &readCount);
3510:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3511:../uvc.c      ****                     {
3512:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3513:../uvc.c      ****                         {
3514:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
3515:../uvc.c      ****                                active data structure. */
3516:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
3517:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
3518:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
3519:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
3520:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
3521:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
3522:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
3523:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
3524:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
3525:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
3526:../uvc.c      **** #if 0
3527:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
3528:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
3529:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
3530:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
3531:../uvc.c      **** #endif
3532:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
3533:../uvc.c      ****                        }
3534:../uvc.c      ****                     }
3535:../uvc.c      ****                     break;
3536:../uvc.c      ****                 default:
3537:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3538:../uvc.c      ****                     break;
3539:../uvc.c      ****             }
3540:../uvc.c      ****             break;
3541:../uvc.c      **** 
3542:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
3543:../uvc.c      ****             switch (bRequest)
3544:../uvc.c      ****             {
3545:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3546:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
3547:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3548:../uvc.c      ****                     break;
3549:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3550:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3551:../uvc.c      ****                     glEp0Buffer[1] = 0;
3552:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3553:../uvc.c      ****                     break;
3554:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3555:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3556:../uvc.c      ****                     {
3557:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
3558:../uvc.c      ****                     }
3559:../uvc.c      ****                     else
3560:../uvc.c      ****                     {
3561:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3562:../uvc.c      ****                     }
3563:../uvc.c      ****                     break;
3564:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3565:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
3566:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
3567:../uvc.c      ****                        */
3568:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3569:../uvc.c      ****                             glCommitCtrl, &readCount);
3570:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3571:../uvc.c      ****                     {
3572:../uvc.c      ****                         switch (glCommitCtrl[3])
3573:../uvc.c      ****                          {
3574:../uvc.c      ****                          	case 1: //1944
3575:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
3576:../uvc.c      ****                          		CyU3PThreadSleep(500);
3577:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3578:../uvc.c      ****                          		break;
3579:../uvc.c      ****                          	case 2: //1080
3580:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
3581:../uvc.c      ****                          		CyU3PThreadSleep(500);
3582:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3583:../uvc.c      ****                          		break;
3584:../uvc.c      ****                          	case 3: //720
3585:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
3586:../uvc.c      ****                          		CyU3PThreadSleep(500);
3587:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3588:../uvc.c      ****                          		break;
3589:../uvc.c      ****                          	case 4: //VGA
3590:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
3591:../uvc.c      ****                          		CyU3PThreadSleep(500);
3592:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3593:../uvc.c      ****                          		break;
3594:../uvc.c      ****                          	default:
3595:../uvc.c      ****                          		break;
3596:../uvc.c      ****                          }
3597:../uvc.c      ****                         setRes = glCommitCtrl[3];
3598:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
3599:../uvc.c      **** 
3600:../uvc.c      **** #if 0
3601:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
3602:../uvc.c      ****                         {
3603:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
3604:../uvc.c      ****                         }
3605:../uvc.c      ****                         else
3606:../uvc.c      ****                         {
3607:../uvc.c      ****                             SensorScaling_VGA ();
3608:../uvc.c      ****                         }
3609:../uvc.c      **** #endif
3610:../uvc.c      ****                         /* We can start streaming video now. */
3611:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
3612:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
3613:../uvc.c      ****                         {
3614:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
3615:../uvc.c      ****                         }
3616:../uvc.c      ****                     }
3617:../uvc.c      ****                     break;
3618:../uvc.c      **** 
3619:../uvc.c      ****                 default:
3620:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3621:../uvc.c      ****                     break;
3622:../uvc.c      ****             }
3623:../uvc.c      ****             break;
3624:../uvc.c      **** 
3625:../uvc.c      **** /* still image streaming handler */
3626:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
3627:../uvc.c      ****                 switch (bRequest)
3628:../uvc.c      ****                 {
3629:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3630:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3631:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3632:../uvc.c      ****                         break;
3633:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3634:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3635:../uvc.c      ****                         glEp0Buffer[1] = 0;
3636:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3637:../uvc.c      ****                         break;
3638:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3639:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3640:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3641:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3642:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3643:../uvc.c      ****                         {
3644:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3645:../uvc.c      ****                         }
3646:../uvc.c      ****                         else
3647:../uvc.c      ****                         {
3648:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3649:../uvc.c      ****                         }
3650:../uvc.c      ****                         break;
3651:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3652:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3653:../uvc.c      ****                                 glCommitCtrl, &readCount);
3654:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3655:../uvc.c      ****                         {
3656:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
3657:../uvc.c      ****                             {
3658:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
3659:../uvc.c      ****                                    active data structure. */
3660:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3661:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3662:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
3663:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
3664:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
3665:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
3666:../uvc.c      ****                             }
3667:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
3668:../uvc.c      ****                         }
3669:../uvc.c      ****                         break;
3670:../uvc.c      ****                     default:
3671:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3672:../uvc.c      ****                         break;
3673:../uvc.c      ****                 }
3674:../uvc.c      ****                 break;
3675:../uvc.c      **** 
3676:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
3677:../uvc.c      ****                 switch (bRequest)
3678:../uvc.c      ****                 {
3679:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3680:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3681:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3682:../uvc.c      ****                         break;
3683:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3684:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3685:../uvc.c      ****                         glEp0Buffer[1] = 0;
3686:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3687:../uvc.c      ****                         break;
3688:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3689:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3690:../uvc.c      ****                         {
3691:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3692:../uvc.c      ****                         }
3693:../uvc.c      ****                         else
3694:../uvc.c      ****                         {
3695:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3696:../uvc.c      ****                         }
3697:../uvc.c      ****                         break;
3698:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3699:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3700:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3701:../uvc.c      ****                            */
3702:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3703:../uvc.c      ****                                 glCommitCtrl, &readCount);
3704:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3705:../uvc.c      ****                         {
3706:../uvc.c      ****     #if 0
3707:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3708:../uvc.c      ****                             {
3709:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3710:../uvc.c      ****                             }
3711:../uvc.c      ****                             else
3712:../uvc.c      ****                             {
3713:../uvc.c      ****                                 SensorScaling_VGA ();
3714:../uvc.c      ****                             }
3715:../uvc.c      ****                             /* We can start streaming video now. */
3716:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3717:../uvc.c      **** 
3718:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3719:../uvc.c      ****                             {
3720:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3721:../uvc.c      ****                             }
3722:../uvc.c      **** 	#endif
3723:../uvc.c      ****                            switch (glCommitCtrl[1])
3724:../uvc.c      ****                              {
3725:../uvc.c      ****                              	case 4: //1944
3726:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
3727:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3728:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
3729:../uvc.c      ****                              		break;
3730:../uvc.c      ****                              	case 3: //1080
3731:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
3732:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3733:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
3734:../uvc.c      ****                              		break;
3735:../uvc.c      ****                              	case 2: //720
3736:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
3737:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3738:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
3739:../uvc.c      ****                              		break;
3740:../uvc.c      ****                             	case 1: //VGA
3741:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
3742:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3743:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
3744:../uvc.c      ****                              		break;
3745:../uvc.c      ****                               	default:
3746:../uvc.c      ****                              		break;
3747:../uvc.c      ****                              }
3748:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
3749:../uvc.c      **** 
3750:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
3751:../uvc.c      **** 
3752:../uvc.c      ****                         }
3753:../uvc.c      ****                         break;
3754:../uvc.c      **** 
3755:../uvc.c      ****                     default:
3756:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3757:../uvc.c      ****                         break;
3758:../uvc.c      ****                 }
3759:../uvc.c      ****                 break;
3760:../uvc.c      **** 
3761:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3762:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
3763:../uvc.c      ****             	switch (bRequest)
3764:../uvc.c      ****                 {
3765:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3766:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3767:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3768:../uvc.c      ****                         break;
3769:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3770:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3771:../uvc.c      ****                         glEp0Buffer[1] = 0;
3772:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3773:../uvc.c      ****                         break;
3774:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3775:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3776:../uvc.c      ****                         {
3777:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3778:../uvc.c      ****                         }
3779:../uvc.c      ****                         else
3780:../uvc.c      ****                         {
3781:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3782:../uvc.c      ****                         }
3783:../uvc.c      ****                         break;
3784:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3785:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3786:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3787:../uvc.c      ****                            */
3788:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3789:../uvc.c      ****                                 glCommitCtrl, &readCount);
3790:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3791:../uvc.c      ****                         {
3792:../uvc.c      ****     #if 1
3793:../uvc.c      ****                             /* We can start still streaming video now. */
3794:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3795:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3796:../uvc.c      ****                             {
3797:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
3798:../uvc.c      ****                             }
3799:../uvc.c      ****     #endif
3800:../uvc.c      ****                             else{
3801:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
3802:../uvc.c      ****                             //stillcont = 0;
3803:../uvc.c      ****                             }
3804:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
3805:../uvc.c      ****                         }else{
3806:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3807:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3808:../uvc.c      ****                         }
3809:../uvc.c      ****                         break;
3810:../uvc.c      **** 
3811:../uvc.c      ****                     default:
3812:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3813:../uvc.c      ****                         break;
3814:../uvc.c      ****                 }
3815:../uvc.c      ****                 break;
3816:../uvc.c      **** 
3817:../uvc.c      ****         default:
3818:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3819:../uvc.c      ****             break;
3820:../uvc.c      ****     }
3821:../uvc.c      **** }
3822:../uvc.c      **** 
3823:../uvc.c      **** /*
3824:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3825:../uvc.c      ****  */
3826:../uvc.c      **** void
3827:../uvc.c      **** UVCAppEP0Thread_Entry (
3828:../uvc.c      ****         uint32_t input)
3829:../uvc.c      **** {
3830:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3831:../uvc.c      ****     uint32_t eventFlag;
3832:../uvc.c      **** 	CyBool_t value;
3833:../uvc.c      **** 	CyBool_t *valueptr = &value;
3834:../uvc.c      **** 
3835:../uvc.c      **** 
3836:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3837:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3838:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3839:../uvc.c      **** 
3840:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3841:../uvc.c      **** #endif
3842:../uvc.c      **** 
3843:../uvc.c      ****     /* for interrupt status test */
3844:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3845:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3846:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3847:../uvc.c      **** 
3848:../uvc.c      ****     for (;;)
3849:../uvc.c      ****     {
3850:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3851:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3852:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3853:../uvc.c      ****         {
3854:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3855:../uvc.c      ****             if (!isUsbConnected)
3856:../uvc.c      ****             {
3857:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3858:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3859:../uvc.c      ****                 {
3860:../uvc.c      ****                     isUsbConnected = CyTrue;
3861:../uvc.c      ****                 }
3862:../uvc.c      ****             }
3863:../uvc.c      **** //#ifdef DbgInfo
3864:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3865:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3866:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3867:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3868:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3869:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3870:../uvc.c      **** //#endif
3871:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3872:../uvc.c      ****             {
3873:../uvc.c      ****             	switch ((wIndex >> 8))
3874:../uvc.c      ****                 {
3875:../uvc.c      **** 
3876:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3877:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3878:../uvc.c      ****                         break;
3879:../uvc.c      **** 
3880:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3881:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3882:../uvc.c      ****                         break;
3883:../uvc.c      **** 
3884:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3885:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3886:../uvc.c      ****                         break;
3887:../uvc.c      **** 
3888:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3889:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3890:../uvc.c      ****                         break;
3891:../uvc.c      **** 
3892:../uvc.c      ****                     default:
3893:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3894:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3895:../uvc.c      ****                         break;
3896:../uvc.c      ****                 }
3897:../uvc.c      ****             }
3898:../uvc.c      **** 
3899:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3900:../uvc.c      ****             {
3901:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3902:../uvc.c      **** 
3903:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3904:../uvc.c      ****                 {
3905:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3906:../uvc.c      ****                 }
3907:../uvc.c      ****                 else
3908:../uvc.c      ****                 {
3909:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3910:../uvc.c      ****                 }
3911:../uvc.c      ****             }
3912:../uvc.c      **** 
3913:../uvc.c      ****             /* handle interrupt status event */
3914:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3915:../uvc.c      ****             {
3916:../uvc.c      **** 
3917:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3918:../uvc.c      ****             	/** preparing interrupt status data **/
3919:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3920:../uvc.c      **** 
3921:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3922:../uvc.c      **** 
3923:../uvc.c      **** #if 0 //for real button
3924:../uvc.c      **** 				if(value&&(!snapButFlag)){
3925:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3926:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3927:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3928:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3929:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3930:../uvc.c      **** 
3931:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3932:../uvc.c      **** 					interStabuf.size   = 1024;
3933:../uvc.c      **** 					interStabuf.status = 0;
3934:../uvc.c      **** 
3935:../uvc.c      **** 					interStabuf.count = 4;
3936:../uvc.c      **** 
3937:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3938:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3939:../uvc.c      **** 
3940:../uvc.c      **** 					/** send a interrupt status data **/
3941:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3942:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3943:../uvc.c      **** 					{
3944:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3945:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3946:../uvc.c      **** 					}
3947:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3948:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3949:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3950:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3951:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3952:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3953:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3954:../uvc.c      **** 
3955:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3956:../uvc.c      **** 					interStabuf.size   = 1024;
3957:../uvc.c      **** 					interStabuf.status = 0;
3958:../uvc.c      **** 
3959:../uvc.c      **** 					interStabuf.count = 4;
3960:../uvc.c      **** 
3961:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3962:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3963:../uvc.c      **** 
3964:../uvc.c      **** 					/** send a interrupt status data **/
3965:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3966:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3967:../uvc.c      **** 					{
3968:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3969:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3970:../uvc.c      **** 					}
3971:../uvc.c      **** 
3972:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3973:../uvc.c      **** 					stiflag = 0xFF;
3974:../uvc.c      **** 				}
3975:../uvc.c      **** #else			//for botton simulation
3976:../uvc.c      **** 				if(snapButFlag == 0x0f){
3977:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3978:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3979:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3980:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3981:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3982:../uvc.c      **** 
3983:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3984:../uvc.c      **** 					interStabuf.size   = 1024;
3985:../uvc.c      **** 					interStabuf.status = 0;
3986:../uvc.c      **** 
3987:../uvc.c      **** 					interStabuf.count = 4;
3988:../uvc.c      **** 
3989:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3990:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3991:../uvc.c      **** 
3992:../uvc.c      **** 					/** send a interrupt status data **/
3993:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3994:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3995:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3996:../uvc.c      **** 					{
3997:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3998:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3999:../uvc.c      **** 					}
4000:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
4001:../uvc.c      **** 
4002:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
4003:../uvc.c      **** 				}else if(!snapButFlag){
4004:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4005:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4006:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4007:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4008:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4009:../uvc.c      **** 
4010:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4011:../uvc.c      **** 					interStabuf.size   = 1024;
4012:../uvc.c      **** 					interStabuf.status = 0;
4013:../uvc.c      **** 
4014:../uvc.c      **** 					interStabuf.count = 4;
4015:../uvc.c      **** 
4016:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4017:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4018:../uvc.c      **** 
4019:../uvc.c      **** 					/** send a interrupt status data **/
4020:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4021:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4022:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4023:../uvc.c      **** 					{
4024:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4025:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4026:../uvc.c      **** 					}
4027:../uvc.c      **** 
4028:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
4029:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
4030:../uvc.c      **** 				}
4031:../uvc.c      **** #endif
4032:../uvc.c      **** 
4033:../uvc.c      ****             }
4034:../uvc.c      **** 
4035:../uvc.c      **** 
4036:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4037:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
4038:../uvc.c      ****             {
4039:../uvc.c      ****                 /* Get the command buffer */
4040:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
4041:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4042:../uvc.c      ****                 {
4043:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
4044:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4045:../uvc.c      ****                 }
4046:../uvc.c      **** 
4047:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
4048:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
4049:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
4050:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
4051:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
4052:../uvc.c      ****                  * register value high byte and register value low byte.
4053:../uvc.c      ****                  */
4054:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
4055:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
4056:../uvc.c      ****                 {
4057:../uvc.c      ****                     if (dmaInfo.count == 3)
4058:../uvc.c      ****                     {
4059:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
4060:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
4061:../uvc.c      ****                         dmaInfo.count = 3;
4062:../uvc.c      ****                     }
4063:../uvc.c      ****                     else if (dmaInfo.count == 4)
4064:../uvc.c      ****                     {
4065:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
4066:../uvc.c      ****                         {
4067:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
4068:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
4069:../uvc.c      ****                         }
4070:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
4071:../uvc.c      ****                     }
4072:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
4073:../uvc.c      ****                 }
4074:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
4075:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
4076:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
4077:../uvc.c      ****                  */
4078:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
4079:../uvc.c      ****                 {
4080:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4081:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
4082:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4083:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
4084:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
4085:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4086:../uvc.c      ****                         	break;
4087:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
4088:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
4089:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4090:../uvc.c      ****                         	break;*/
4091:../uvc.c      ****                     dmaInfo.count -= 2;
4092:../uvc.c      ****                 }
4093:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
4094:../uvc.c      ****                 else
4095:../uvc.c      ****                 {
4096:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
4097:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
4098:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
4099:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
4100:../uvc.c      ****                 }
4101:../uvc.c      **** 
4102:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
4103:../uvc.c      ****                 dmaInfo.size   = 1024;
4104:../uvc.c      ****                 dmaInfo.status = 0;
4105:../uvc.c      **** 
4106:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
4107:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
4108:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4109:../uvc.c      ****                 {
4110:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
4111:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4112:../uvc.c      ****                 }
4113:../uvc.c      **** 
4114:../uvc.c      ****                 /* Wait until the response has gone out. */
4115:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
4116:../uvc.c      **** 
4117:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
4118:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4119:../uvc.c      ****                 {
4120:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
4121:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4122:../uvc.c      ****                 }
4123:../uvc.c      ****             }
4124:../uvc.c      **** #endif
4125:../uvc.c      ****         }
4126:../uvc.c      ****         /* Allow other ready threads to run. */
4127:../uvc.c      ****         CyU3PThreadRelinquish ();
4128:../uvc.c      ****     }
4129:../uvc.c      **** }
4130:../uvc.c      **** 
4131:../uvc.c      **** /*
4132:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
4133:../uvc.c      ****  * added 10/2013
4134:../uvc.c      ****  */
4135:../uvc.c      **** /*
4136:../uvc.c      **** static uint8_t timeDelay[64] = {
4137:../uvc.c      **** 
4138:../uvc.c      **** };
4139:../uvc.c      **** */
4140:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 4140 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
4141:../uvc.c      **** 
4142:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
4143:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4144:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4145:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
4146:../uvc.c      **** 	VdstateDes *lcStaDes;
4147:../uvc.c      **** 	uint32_t flag = 0;
4148:../uvc.c      **** 	uint8_t  cmdFlag = 0;
4149:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
4150:../uvc.c      **** 	uint8_t i;
4151:../uvc.c      **** 	uint16_t delaytime;
4152:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
4153:../uvc.c      **** 
4154:../uvc.c      **** #if 0 //for test the command queue
4155:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
4156:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4157:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
4158:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4159:../uvc.c      **** 		lcCmdDes += 1;
4160:../uvc.c      **** 	}
4161:../uvc.c      **** #endif
4162:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
4163:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 4163 0
  36 0004 10229FE5 		ldr	r2, .L22
4147:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 4147 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
4140:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 4140 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 4163 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 F8019FE5 		ldr	r0, .L22+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
4147:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 4147 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 4163 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
4164:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 4164 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 DC119FE5 		ldr	r1, .L22+8
  71 0044 DC519FE5 		ldr	r5, .L22+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
4165:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 4165 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
4166:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 4166 0
  79 005c BC019FE5 		ldr	r0, .L22+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
4167:../uvc.c      **** 
4168:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 4168 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
4169:../uvc.c      ****         /* Allow other ready threads to run. */
4170:../uvc.c      **** 
4171:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 4171 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
4168:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 4168 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
4172:../uvc.c      **** 	}
4173:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 4173 0
  92 0078 A8019FE5 		ldr	r0, .L22+12
  93 007c A8119FE5 		ldr	r1, .L22+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 98719FE5 		ldr	r7, .L22+20
  99 0094 98B19FE5 		ldr	fp, .L22+24
4174:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
4175:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
4176:../uvc.c      **** 	//CyU3PThreadSleep(100);
4177:../uvc.c      **** 	//SetCurCmd();
4178:../uvc.c      **** 	/*********** the loop of the thread ***********/
4179:../uvc.c      **** 	for(;;){
4180:../uvc.c      **** 
4181:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 4181 0
 101 0098 0060E0E3 		mvn	r6, #0
4182:../uvc.c      **** /*  // for test GPIO output
4183:../uvc.c      **** 		if(trigger)
4184:../uvc.c      **** 		{
4185:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
4186:../uvc.c      **** 			{
4187:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
4188:../uvc.c      **** 			}
4189:../uvc.c      **** 
4190:../uvc.c      **** 		}else{
4191:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
4192:../uvc.c      **** 			{
4193:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
4194:../uvc.c      **** 			}
4195:../uvc.c      **** 
4196:../uvc.c      **** 		}
4197:../uvc.c      **** */
4198:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4199:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4200:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
4201:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
4202:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
4203:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
4204:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
4205:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
4206:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4207:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
4208:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
4209:../uvc.c      **** #endif
4210:../uvc.c      **** 				}
4211:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
4212:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
4213:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
4214:../uvc.c      **** 			}
4215:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
4216:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
4217:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4218:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
4219:../uvc.c      **** 
4220:../uvc.c      **** 				/*
4221:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4222:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4223:../uvc.c      **** 				*/
4224:../uvc.c      **** 
4225:../uvc.c      **** 				/* find a available command */
4226:../uvc.c      **** 				i = 0;
4227:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 4227 0
 103 009c 0090A0E3 		mov	r9, #0
4228:../uvc.c      **** 					i++;
4229:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
4230:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
4231:../uvc.c      **** 				}
4232:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
4233:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
4234:../uvc.c      **** 					i = lcCmdDes->curNum;
4235:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
4236:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
4237:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
4238:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
4239:../uvc.c      **** #if 1
4240:../uvc.c      **** 					switch(lcCmdDes->CmdID){
4241:../uvc.c      **** 						case 0x20:
4242:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
4243:../uvc.c      **** 							delaytime = 500;
4244:../uvc.c      **** 							break;
4245:../uvc.c      **** 						case 0x21:
4246:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
4247:../uvc.c      **** 							delaytime = 500;
4248:../uvc.c      **** 							break;
4249:../uvc.c      **** 						case 0x22:
4250:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4251:../uvc.c      **** 							delaytime = 300;
4252:../uvc.c      **** 							break;
4253:../uvc.c      **** 						case 0x23:
4254:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4255:../uvc.c      **** 							delaytime = 300;
4256:../uvc.c      **** 							break;
4257:../uvc.c      **** 						default:
4258:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
4259:../uvc.c      **** 							break;
4260:../uvc.c      **** 					}
4261:../uvc.c      **** #endif
4262:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
4263:../uvc.c      **** 					/** timer's ticket modify **/
4264:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
4265:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
4266:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
4267:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
4268:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
4269:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4270:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
4271:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
4272:../uvc.c      **** #endif
4273:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
4274:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
4275:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
4276:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
4277:../uvc.c      **** 						}else{
4278:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
4279:../uvc.c      **** 						}
4280:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
4281:../uvc.c      **** 					}else{
4282:../uvc.c      **** 						lcCmdDes->curNum ++;
4283:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 4283 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L18:
4181:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 4181 0
 108 00a4 0320A0E3 		mov	r2, #3
 109 00a8 14308DE2 		add	r3, sp, #20
 110 00ac 2010A0E3 		mov	r1, #32
 111 00b0 80019FE5 		ldr	r0, .L22+28
 112 00b4 00608DE5 		str	r6, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
4198:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 4198 0
 115 00bc 0610A0E1 		mov	r1, r6
 116 00c0 1C0097E5 		ldr	r0, [r7, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
4215:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 119              		.loc 1 4215 0
 120 00c8 1C0097E5 		ldr	r0, [r7, #28]
 121 00cc FEFFFFEB 		bl	_txe_mutex_put
 122              	.LVL4:
4217:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 123              		.loc 1 4217 0
 124 00d0 1C0095E5 		ldr	r0, [r5, #28]
 125 00d4 0610A0E1 		mov	r1, r6
 126 00d8 FEFFFFEB 		bl	_txe_mutex_get
4218:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 127              		.loc 1 4218 0
 128 00dc 104095E5 		ldr	r4, [r5, #16]
 129              	.LVL5:
4227:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 4227 0
 131 00e0 3C2094E5 		ldr	r2, [r4, #60]
 132 00e4 000052E3 		cmp	r2, #0
 133 00e8 0800001A 		bne	.L4
 134 00ec 0030A0E3 		mov	r3, #0
 135              	.LVL6:
 136              	.L5:
4229:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 137              		.loc 1 4229 0
 138 00f0 344094E5 		ldr	r4, [r4, #52]
 139              	.LVL7:
4228:../uvc.c      **** 					i++;
 140              		.loc 1 4228 0
 141 00f4 011083E2 		add	r1, r3, #1
4227:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 142              		.loc 1 4227 0
 143 00f8 3C2094E5 		ldr	r2, [r4, #60]
4228:../uvc.c      **** 					i++;
 144              		.loc 1 4228 0
 145 00fc FF3001E2 		and	r3, r1, #255
 146              	.LVL8:
4227:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 147              		.loc 1 4227 0
 148 0100 3F0053E3 		cmp	r3, #63
 149 0104 00005293 		cmpls	r2, #0
 150 0108 F8FFFF0A 		beq	.L5
 151 010c 104085E5 		str	r4, [r5, #16]
 152              	.LVL9:
 153              	.L4:
4233:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
 154              		.loc 1 4233 0
 155 0110 000052E3 		cmp	r2, #0
 156 0114 2D00000A 		beq	.L6
 157              	.LVL10:
4235:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 158              		.loc 1 4235 0
 159 0118 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
4240:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 160              		.loc 1 4240 0
 161 011c 0020D4E5 		ldrb	r2, [r4, #0]	@ zero_extendqisi2
4235:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 162              		.loc 1 4235 0
 163 0120 83E083E0 		add	lr, r3, r3, asl #1
 164 0124 8EA084E0 		add	sl, r4, lr, asl #1
4240:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 165              		.loc 1 4240 0
 166 0128 20C042E2 		sub	ip, r2, #32
4235:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 167              		.loc 1 4235 0
 168 012c 0400DAE5 		ldrb	r0, [sl, #4]	@ zero_extendqisi2
 169              	.LVL11:
4236:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 170              		.loc 1 4236 0
 171 0130 0510DAE5 		ldrb	r1, [sl, #5]	@ zero_extendqisi2
 172              	.LVL12:
4237:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 173              		.loc 1 4237 0
 174 0134 0620DAE5 		ldrb	r2, [sl, #6]	@ zero_extendqisi2
 175              	.LVL13:
4238:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 176              		.loc 1 4238 0
 177 0138 B8A0DAE1 		ldrh	sl, [sl, #8]
 178              	.LVL14:
4240:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 179              		.loc 1 4240 0
 180 013c 03005CE3 		cmp	ip, #3
 181 0140 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 182 0144 1A0000EA 		b	.L7
 183              	.L12:
 184 0148 C0010000 		.word	.L8
 185 014c A4010000 		.word	.L9
 186 0150 58010000 		.word	.L11
 187 0154 58010000 		.word	.L11
 188              	.L11:
4254:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 189              		.loc 1 4254 0
 190 0158 8230A0E3 		mov	r3, #130
 191 015c FEFFFFEB 		bl	SensorSetIrisControl
 192              	.LVL15:
4256:../uvc.c      **** 							break;
 193              		.loc 1 4256 0
 194 0160 4B1FA0E3 		mov	r1, #300
 195              	.LVL16:
 196              	.L13:
4265:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 197              		.loc 1 4265 0
 198 0164 0020A0E3 		mov	r2, #0
 199 0168 B0009FE5 		ldr	r0, .L22+4
 200 016c FEFFFFEB 		bl	_txe_timer_change
4266:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 201              		.loc 1 4266 0
 202 0170 A8009FE5 		ldr	r0, .L22+4
 203 0174 FEFFFFEB 		bl	_txe_timer_activate
 204              	.LVL17:
4273:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 205              		.loc 1 4273 0
 206 0178 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 207 017c 0210D4E5 		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 208 0180 000051E1 		cmp	r1, r0
4282:../uvc.c      **** 						lcCmdDes->curNum ++;
 209              		.loc 1 4282 0
 210 0184 01008012 		addne	r0, r0, #1
 211 0188 0100C415 		strneb	r0, [r4, #1]
 212              		.loc 1 4283 0
 213 018c 3C808415 		strne	r8, [r4, #60]
4273:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 214              		.loc 1 4273 0
 215 0190 1400000A 		beq	.L21
 216              	.LVL18:
 217              	.L17:
4284:../uvc.c      **** 					}
4285:../uvc.c      **** 				}else{
4286:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
4287:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
4288:../uvc.c      **** 				}
4289:../uvc.c      **** 			}
4290:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 218              		.loc 1 4290 0
 219 0194 1C0095E5 		ldr	r0, [r5, #28]
 220 0198 FEFFFFEB 		bl	_txe_mutex_put
 221              	.LVL19:
4291:../uvc.c      **** /*
4292:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4293:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4294:../uvc.c      **** */
4295:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4296:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
4297:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
4298:../uvc.c      **** #endif
4299:../uvc.c      **** 
4300:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
4301:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
4302:../uvc.c      **** #if 0
4303:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
4304:../uvc.c      **** 
4305:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
4306:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
4307:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
4308:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
4309:../uvc.c      **** 			    i = 0;
4310:../uvc.c      **** 				 switch(cmdCopyIdx)
4311:../uvc.c      **** 				 {
4312:../uvc.c      **** 					 case BrgtCtlID1:
4313:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
4314:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4315:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
4316:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4317:../uvc.c      **** 							 i++;
4318:../uvc.c      **** 						 }
4319:../uvc.c      **** 						 else{
4320:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4321:../uvc.c      **** 						 }
4322:../uvc.c      **** 
4323:../uvc.c      **** 						 CyU3PBusyWait(500);
4324:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
4325:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4326:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4327:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4328:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4329:../uvc.c      **** 						 }
4330:../uvc.c      **** 						 else{
4331:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4332:../uvc.c      **** 						 }
4333:../uvc.c      **** 						 break;
4334:../uvc.c      **** 					 case HueCtlID5:
4335:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4336:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4337:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4338:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4339:../uvc.c      **** 						 }
4340:../uvc.c      **** 						 else{
4341:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4342:../uvc.c      **** 						 }
4343:../uvc.c      **** 						 break;
4344:../uvc.c      **** 					 case SaturCtlID6:
4345:../uvc.c      **** 					 case WBTLevCtlID10:
4346:../uvc.c      **** 					 default:
4347:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
4348:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4349:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4350:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4351:../uvc.c      **** 						 }
4352:../uvc.c      **** 						 else{
4353:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4354:../uvc.c      **** 						 }
4355:../uvc.c      **** 						 break;
4356:../uvc.c      **** 				 }
4357:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
4358:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
4359:../uvc.c      **** 			}
4360:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
4361:../uvc.c      **** #endif
4362:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
4363:../uvc.c      **** 		/* Allow other ready threads to run. */
4364:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4365:../uvc.c      **** 			CyU3PThreadRelinquish ();
 222              		.loc 1 4365 0
 223 019c FEFFFFEB 		bl	_txe_thread_relinquish
4366:../uvc.c      **** 		}
 224              		.loc 1 4366 0
 225 01a0 BFFFFFEA 		b	.L18
 226              	.LVL20:
 227              	.L9:
4246:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 228              		.loc 1 4246 0
 229 01a4 5230A0E3 		mov	r3, #82
 230 01a8 FEFFFFEB 		bl	SensorSetIrisControl
 231              	.LVL21:
4248:../uvc.c      **** 							break;
 232              		.loc 1 4248 0
 233 01ac 7D1FA0E3 		mov	r1, #500
 234 01b0 EBFFFFEA 		b	.L13
 235              	.LVL22:
 236              	.L7:
4258:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 237              		.loc 1 4258 0
 238 01b4 FEFFFFEB 		bl	SensorSetControl
 239              	.LVL23:
 240 01b8 0A10A0E1 		mov	r1, sl
4259:../uvc.c      **** 							break;
 241              		.loc 1 4259 0
 242 01bc E8FFFFEA 		b	.L13
 243              	.LVL24:
 244              	.L8:
4242:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
 245              		.loc 1 4242 0
 246 01c0 8230A0E3 		mov	r3, #130
 247 01c4 FEFFFFEB 		bl	SensorSetIrisControl
 248              	.LVL25:
4244:../uvc.c      **** 							break;
 249              		.loc 1 4244 0
 250 01c8 7D1FA0E3 		mov	r1, #500
 251 01cc E4FFFFEA 		b	.L13
 252              	.LVL26:
 253              	.L6:
4286:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 254              		.loc 1 4286 0
 255 01d0 FA1FA0E3 		mov	r1, #1000
 256 01d4 44009FE5 		ldr	r0, .L22+4
 257 01d8 FEFFFFEB 		bl	_txe_timer_change
4287:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 258              		.loc 1 4287 0
 259 01dc 3C009FE5 		ldr	r0, .L22+4
 260 01e0 FEFFFFEB 		bl	_txe_timer_activate
 261 01e4 EAFFFFEA 		b	.L17
 262              	.LVL27:
 263              	.L21:
4275:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 264              		.loc 1 4275 0
 265 01e8 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
4274:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 266              		.loc 1 4274 0
 267 01ec 3C9084E5 		str	r9, [r4, #60]
4275:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 268              		.loc 1 4275 0
 269 01f0 23005CE3 		cmp	ip, #35
4276:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 270              		.loc 1 4276 0
 271 01f4 24C04C82 		subhi	ip, ip, #36
 272 01f8 8CC08C80 		addhi	ip, ip, ip, asl #1
4278:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 273              		.loc 1 4278 0
 274 01fc 8CC08C90 		addls	ip, ip, ip, asl #1
4276:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 275              		.loc 1 4276 0
 276 0200 8CC18B80 		addhi	ip, fp, ip, asl #3
4278:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 277              		.loc 1 4278 0
 278 0204 8CC18B90 		addls	ip, fp, ip, asl #3
4276:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 279              		.loc 1 4276 0
 280 0208 1090CC85 		strhib	r9, [ip, #16]
4278:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 281              		.loc 1 4278 0
 282 020c 9091CC95 		strlsb	r9, [ip, #400]
4280:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 283              		.loc 1 4280 0
 284 0210 344094E5 		ldr	r4, [r4, #52]
 285              	.LVL28:
 286 0214 104085E5 		str	r4, [r5, #16]
 287 0218 DDFFFFEA 		b	.L17
 288              	.L23:
 289              		.align	2
 290              	.L22:
 291 021c 00000000 		.word	I2CCmdCb
 292 0220 00000000 		.word	I2CCmdTimer
 293 0224 00000000 		.word	.LC0
 294 0228 00000000 		.word	cmdQu
 295 022c 14000000 		.word	.LC1
 296 0230 00000000 		.word	statQu
 297 0234 00000000 		.word	.LANCHOR1
 298 0238 00000000 		.word	.LANCHOR0
 299              		.cfi_endproc
 300              	.LFE26:
 302              		.align	2
 303              		.global	I2CCmdCb
 305              	I2CCmdCb:
 306              	.LFB18:
2754:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 307              		.loc 1 2754 0
 308              		.cfi_startproc
 309              		@ args = 0, pretend = 0, frame = 0
 310              		@ frame_needed = 0, uses_anonymous_args = 0
 311              		@ link register save eliminated.
 312              	.LVL29:
2756:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 313              		.loc 1 2756 0
 314 023c 08009FE5 		ldr	r0, .L25
 315              	.LVL30:
 316 0240 2010A0E3 		mov	r1, #32
 317 0244 0020A0E3 		mov	r2, #0
2757:../uvc.c      **** }
 318              		.loc 1 2757 0
2756:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 319              		.loc 1 2756 0
 320 0248 FEFFFFEA 		b	_txe_event_flags_set
 321              	.L26:
 322              		.align	2
 323              	.L25:
 324 024c 00000000 		.word	.LANCHOR0
 325              		.cfi_endproc
 326              	.LFE18:
 328              		.align	2
 330              	CyFxUVCApplnUSBEventCB:
 331              	.LFB9:
1815:../uvc.c      **** {
 332              		.loc 1 1815 0
 333              		.cfi_startproc
 334              		@ args = 0, pretend = 0, frame = 8
 335              		@ frame_needed = 0, uses_anonymous_args = 0
 336              	.LVL31:
1816:../uvc.c      ****     switch (evtype)
 337              		.loc 1 1816 0
 338 0250 020050E3 		cmp	r0, #2
1815:../uvc.c      **** {
 339              		.loc 1 1815 0
 340 0254 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 341              	.LCFI2:
 342              		.cfi_def_cfa_offset 16
 343 0258 0130A0E1 		mov	r3, r1
 344 025c 10D04DE2 		sub	sp, sp, #16
 345              	.LCFI3:
 346              		.cfi_def_cfa_offset 32
1815:../uvc.c      **** {
 347              		.loc 1 1815 0
 348 0260 0040A0E1 		mov	r4, r0
 349              		.cfi_offset 14, -4
 350              		.cfi_offset 6, -8
 351              		.cfi_offset 5, -12
 352              		.cfi_offset 4, -16
1816:../uvc.c      ****     switch (evtype)
 353              		.loc 1 1816 0
 354 0264 3600000A 		beq	.L30
 355 0268 040050E3 		cmp	r0, #4
 356 026c 1F00000A 		beq	.L31
 357 0270 010050E3 		cmp	r0, #1
 358 0274 0100000A 		beq	.L33
 359              	.LVL32:
 360              	.L27:
1852:../uvc.c      **** }
 361              		.loc 1 1852 0
 362 0278 10D08DE2 		add	sp, sp, #16
 363 027c 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 364              	.LVL33:
 365              	.L33:
1837:../uvc.c      ****             gpif_initialized = 0;
 366              		.loc 1 1837 0
 367 0280 28519FE5 		ldr	r5, .L34
1835:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 368              		.loc 1 1835 0
 369 0284 0020A0E1 		mov	r2, r0
 370 0288 24119FE5 		ldr	r1, .L34+4
 371              	.LVL34:
 372 028c 0400A0E3 		mov	r0, #4
 373              	.LVL35:
 374 0290 FEFFFFEB 		bl	CyU3PDebugPrint
1836:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 375              		.loc 1 1836 0
 376 0294 0400A0E1 		mov	r0, r4
 377 0298 FEFFFFEB 		bl	CyU3PGpifDisable
1837:../uvc.c      ****             gpif_initialized = 0;
 378              		.loc 1 1837 0
 379 029c 00C0A0E3 		mov	ip, #0
 380              	.LBB16:
 381              	.LBB17:
1799:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 382              		.loc 1 1799 0
 383 02a0 0410A0E1 		mov	r1, r4
 384 02a4 0500A0E1 		mov	r0, r5
 385 02a8 0220A0E3 		mov	r2, #2
 386 02ac 0C308DE2 		add	r3, sp, #12
 387              	.LBE17:
 388              	.LBE16:
1837:../uvc.c      ****             gpif_initialized = 0;
 389              		.loc 1 1837 0
 390 02b0 28C085E5 		str	ip, [r5, #40]
1838:../uvc.c      ****             isUsbConnected = CyFalse;
 391              		.loc 1 1838 0
 392 02b4 30C085E5 		str	ip, [r5, #48]
1839:../uvc.c      ****             streamingStarted = CyFalse;
 393              		.loc 1 1839 0
 394 02b8 2CC085E5 		str	ip, [r5, #44]
 395              	.LBB19:
 396              	.LBB18:
1799:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 397              		.loc 1 1799 0
 398 02bc 00C08DE5 		str	ip, [sp, #0]
 399 02c0 FEFFFFEB 		bl	_txe_event_flags_get
 400 02c4 004050E2 		subs	r4, r0, #0
 401 02c8 EAFFFF1A 		bne	.L27
1802:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 402              		.loc 1 1802 0
 403 02cc 0110E0E3 		mvn	r1, #1
 404 02d0 0220A0E3 		mov	r2, #2
 405 02d4 0500A0E1 		mov	r0, r5
 406              	.L32:
 407 02d8 FEFFFFEB 		bl	_txe_event_flags_set
1805:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 408              		.loc 1 1805 0
 409 02dc 0500A0E1 		mov	r0, r5
 410 02e0 0210A0E3 		mov	r1, #2
 411 02e4 0420A0E1 		mov	r2, r4
 412 02e8 FEFFFFEB 		bl	_txe_event_flags_set
 413 02ec E1FFFFEA 		b	.L27
 414              	.LVL36:
 415              	.L31:
 416              	.LBE18:
 417              	.LBE19:
1821:../uvc.c      ****             gpif_initialized = 0;
 418              		.loc 1 1821 0
 419 02f0 B8509FE5 		ldr	r5, .L34
1819:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 420              		.loc 1 1819 0
 421 02f4 BC109FE5 		ldr	r1, .L34+8
 422              	.LVL37:
 423 02f8 0020A0E1 		mov	r2, r0
 424 02fc FEFFFFEB 		bl	CyU3PDebugPrint
 425              	.LVL38:
1820:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 426              		.loc 1 1820 0
 427 0300 0100A0E3 		mov	r0, #1
 428 0304 FEFFFFEB 		bl	CyU3PGpifDisable
1821:../uvc.c      ****             gpif_initialized = 0;
 429              		.loc 1 1821 0
 430 0308 00C0A0E3 		mov	ip, #0
 431              	.LBB20:
 432              	.LBB21:
1799:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 433              		.loc 1 1799 0
 434 030c 0110A0E3 		mov	r1, #1
 435 0310 0220A0E3 		mov	r2, #2
 436 0314 0500A0E1 		mov	r0, r5
 437 0318 0C308DE2 		add	r3, sp, #12
 438              	.LBE21:
 439              	.LBE20:
1821:../uvc.c      ****             gpif_initialized = 0;
 440              		.loc 1 1821 0
 441 031c 28C085E5 		str	ip, [r5, #40]
1822:../uvc.c      ****             streamingStarted = CyFalse;
 442              		.loc 1 1822 0
 443 0320 2CC085E5 		str	ip, [r5, #44]
 444              	.LBB23:
 445              	.LBB22:
1799:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 446              		.loc 1 1799 0
 447 0324 00C08DE5 		str	ip, [sp, #0]
 448 0328 FEFFFFEB 		bl	_txe_event_flags_get
 449 032c 004050E2 		subs	r4, r0, #0
1802:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 450              		.loc 1 1802 0
 451 0330 0500A001 		moveq	r0, r5
 452 0334 0110E003 		mvneq	r1, #1
 453 0338 0220A003 		moveq	r2, #2
1799:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 454              		.loc 1 1799 0
 455 033c CDFFFF1A 		bne	.L27
 456 0340 E4FFFFEA 		b	.L32
 457              	.LVL39:
 458              	.L30:
 459              	.LBE22:
 460              	.LBE23:
1829:../uvc.c      ****             gpif_initialized = 0;
 461              		.loc 1 1829 0
 462 0344 64509FE5 		ldr	r5, .L34
1827:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 463              		.loc 1 1827 0
 464 0348 0020A0E1 		mov	r2, r0
 465 034c 68109FE5 		ldr	r1, .L34+12
 466              	.LVL40:
 467 0350 0400A0E3 		mov	r0, #4
 468              	.LVL41:
 469 0354 FEFFFFEB 		bl	CyU3PDebugPrint
1828:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 470              		.loc 1 1828 0
 471 0358 0100A0E3 		mov	r0, #1
 472 035c FEFFFFEB 		bl	CyU3PGpifDisable
1829:../uvc.c      ****             gpif_initialized = 0;
 473              		.loc 1 1829 0
 474 0360 0060A0E3 		mov	r6, #0
 475              	.LBB24:
 476              	.LBB25:
1799:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 477              		.loc 1 1799 0
 478 0364 0500A0E1 		mov	r0, r5
 479 0368 0110A0E3 		mov	r1, #1
 480 036c 0420A0E1 		mov	r2, r4
 481 0370 0C308DE2 		add	r3, sp, #12
 482              	.LBE25:
 483              	.LBE24:
1829:../uvc.c      ****             gpif_initialized = 0;
 484              		.loc 1 1829 0
 485 0374 286085E5 		str	r6, [r5, #40]
1830:../uvc.c      ****             streamingStarted = CyFalse;
 486              		.loc 1 1830 0
 487 0378 2C6085E5 		str	r6, [r5, #44]
 488              	.LBB27:
 489              	.LBB26:
1799:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 490              		.loc 1 1799 0
 491 037c 00608DE5 		str	r6, [sp, #0]
 492 0380 FEFFFFEB 		bl	_txe_event_flags_get
 493 0384 006050E2 		subs	r6, r0, #0
 494 0388 BAFFFF1A 		bne	.L27
1802:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 495              		.loc 1 1802 0
 496 038c 0420A0E1 		mov	r2, r4
 497 0390 0500A0E1 		mov	r0, r5
 498 0394 0110E0E3 		mvn	r1, #1
 499 0398 FEFFFFEB 		bl	_txe_event_flags_set
1805:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 500              		.loc 1 1805 0
 501 039c 0500A0E1 		mov	r0, r5
 502 03a0 0410A0E1 		mov	r1, r4
 503 03a4 0620A0E1 		mov	r2, r6
 504 03a8 FEFFFFEB 		bl	_txe_event_flags_set
 505 03ac B1FFFFEA 		b	.L27
 506              	.L35:
 507              		.align	2
 508              	.L34:
 509 03b0 00000000 		.word	.LANCHOR0
 510 03b4 7C000000 		.word	.LC4
 511 03b8 38000000 		.word	.LC2
 512 03bc 58000000 		.word	.LC3
 513              	.LBE26:
 514              	.LBE27:
 515              		.cfi_endproc
 516              	.LFE9:
 518              		.align	2
 519              		.global	CyFxUvcApplnDmaCallback
 521              	CyFxUvcApplnDmaCallback:
 522              	.LFB11:
2012:../uvc.c      **** {
 523              		.loc 1 2012 0
 524              		.cfi_startproc
 525              		@ args = 0, pretend = 0, frame = 0
 526              		@ frame_needed = 0, uses_anonymous_args = 0
 527              	.LVL42:
2019:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 528              		.loc 1 2019 0
 529 03c0 080051E3 		cmp	r1, #8
2012:../uvc.c      **** {
 530              		.loc 1 2012 0
 531 03c4 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 532              	.LCFI4:
 533              		.cfi_def_cfa_offset 20
 534 03c8 0250A0E1 		mov	r5, r2
 535              		.cfi_offset 14, -4
 536              		.cfi_offset 7, -8
 537              		.cfi_offset 6, -12
 538              		.cfi_offset 5, -16
 539              		.cfi_offset 4, -20
 540 03cc 0CD04DE2 		sub	sp, sp, #12
 541              	.LCFI5:
 542              		.cfi_def_cfa_offset 32
2019:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 543              		.loc 1 2019 0
 544 03d0 0B00000A 		beq	.L42
2071:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 545              		.loc 1 2071 0
 546 03d4 100051E3 		cmp	r1, #16
 547 03d8 0700001A 		bne	.L36
2073:../uvc.c      ****         consCount++;
 548              		.loc 1 2073 0
 549 03dc 7C319FE5 		ldr	r3, .L45
2074:../uvc.c      ****         streamingStarted = CyTrue;
 550              		.loc 1 2074 0
 551 03e0 0120A0E3 		mov	r2, #1
 552              	.LVL43:
2073:../uvc.c      ****         consCount++;
 553              		.loc 1 2073 0
 554 03e4 B204D3E1 		ldrh	r0, [r3, #66]
 555              	.LVL44:
2074:../uvc.c      ****         streamingStarted = CyTrue;
 556              		.loc 1 2074 0
 557 03e8 2C2083E5 		str	r2, [r3, #44]
2073:../uvc.c      ****         consCount++;
 558              		.loc 1 2073 0
 559 03ec 02C080E0 		add	ip, r0, r2
 560 03f0 0C18A0E1 		mov	r1, ip, asl #16
 561              	.LVL45:
 562 03f4 2128A0E1 		mov	r2, r1, lsr #16
 563 03f8 B224C3E1 		strh	r2, [r3, #66]	@ movhi
 564              	.L36:
2076:../uvc.c      **** }
 565              		.loc 1 2076 0
 566 03fc 0CD08DE2 		add	sp, sp, #12
 567 0400 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 568              	.LVL46:
 569              	.L42:
2021:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 570              		.loc 1 2021 0
 571 0404 B420D2E1 		ldrh	r2, [r2, #4]
 572 0408 54319FE5 		ldr	r3, .L45+4
 573 040c 030052E1 		cmp	r2, r3
 574 0410 3500000A 		beq	.L43
2041:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 575              		.loc 1 2041 0
 576 0414 006095E5 		ldr	r6, [r5, #0]
 577              	.LBB32:
 578              	.LBB34:
1760:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 579              		.loc 1 1760 0
 580 0418 48719FE5 		ldr	r7, .L45+8
1759:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 581              		.loc 1 1759 0
 582 041c 0010E0E3 		mvn	r1, #0
 583              	.LVL47:
 584              	.LBE34:
 585              	.LBE32:
2041:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 586              		.loc 1 2041 0
 587 0420 0C4046E2 		sub	r4, r6, #12
 588              	.LVL48:
 589              	.LBB36:
 590              	.LBB33:
1759:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 591              		.loc 1 1759 0
 592 0424 40019FE5 		ldr	r0, .L45+12
 593              	.LVL49:
 594 0428 FEFFFFEB 		bl	_txe_mutex_get
1760:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 595              		.loc 1 1760 0
 596 042c 0400A0E1 		mov	r0, r4
 597 0430 121D87E2 		add	r1, r7, #1152
 598 0434 0C20A0E3 		mov	r2, #12
 599 0438 FEFFFFEB 		bl	CyU3PMemCopy
1761:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 600              		.loc 1 1761 0
 601 043c 28019FE5 		ldr	r0, .L45+12
 602 0440 FEFFFFEB 		bl	_txe_mutex_put
1766:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 603              		.loc 1 1766 0
 604 0444 0BC056E5 		ldrb	ip, [r6, #-11]	@ zero_extendqisi2
 605              	.LBE33:
 606              	.LBE36:
2042:../uvc.c      ****                 pb++;
 607              		.loc 1 2042 0
 608 0448 10419FE5 		ldr	r4, .L45
 609              	.LVL50:
 610              	.LBB37:
 611              	.LBB35:
1766:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 612              		.loc 1 1766 0
 613 044c 02108CE3 		orr	r1, ip, #2
 614 0450 0B1046E5 		strb	r1, [r6, #-11]
 615              	.LBE35:
 616              	.LBE37:
2042:../uvc.c      ****                 pb++;
 617              		.loc 1 2042 0
 618 0454 B603D4E1 		ldrh	r0, [r4, #54]
2048:../uvc.c      ****                 if(stiflag == 0x0F){
 619              		.loc 1 2048 0
 620 0458 3A20D4E5 		ldrb	r2, [r4, #58]	@ zero_extendqisi2
2043:../uvc.c      ****                 pbc = input->buffer_p.count;
 621              		.loc 1 2043 0
 622 045c B410D5E1 		ldrh	r1, [r5, #4]
2042:../uvc.c      ****                 pb++;
 623              		.loc 1 2042 0
 624 0460 013080E2 		add	r3, r0, #1
2048:../uvc.c      ****                 if(stiflag == 0x0F){
 625              		.loc 1 2048 0
 626 0464 0F0052E3 		cmp	r2, #15
2042:../uvc.c      ****                 pb++;
 627              		.loc 1 2042 0
 628 0468 B633C4E1 		strh	r3, [r4, #54]	@ movhi
2043:../uvc.c      ****                 pbc = input->buffer_p.count;
 629              		.loc 1 2043 0
 630 046c B813C4E1 		strh	r1, [r4, #56]	@ movhi
2048:../uvc.c      ****                 if(stiflag == 0x0F){
 631              		.loc 1 2048 0
 632 0470 2E00000A 		beq	.L44
 633              	.L40:
2055:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
 634              		.loc 1 2055 0
 635 0474 01E0A0E3 		mov	lr, #1
 636 0478 3CE084E5 		str	lr, [r4, #60]
 637              	.LVL51:
 638              	.L39:
2059:../uvc.c      ****             prodCount++;
 639              		.loc 1 2059 0
 640 047c B0E4D4E1 		ldrh	lr, [r4, #64]
2060:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 641              		.loc 1 2060 0
 642 0480 0C1081E2 		add	r1, r1, #12
2059:../uvc.c      ****             prodCount++;
 643              		.loc 1 2059 0
 644 0484 01308EE2 		add	r3, lr, #1
 645 0488 0308A0E1 		mov	r0, r3, asl #16
 646 048c 20C8A0E1 		mov	ip, r0, lsr #16
2060:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 647              		.loc 1 2060 0
 648 0490 0128A0E1 		mov	r2, r1, asl #16
 649 0494 2218A0E1 		mov	r1, r2, lsr #16
 650 0498 D0009FE5 		ldr	r0, .L45+16
 651 049c 0020A0E3 		mov	r2, #0
2059:../uvc.c      ****             prodCount++;
 652              		.loc 1 2059 0
 653 04a0 B0C4C4E1 		strh	ip, [r4, #64]	@ movhi
2060:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 654              		.loc 1 2060 0
 655 04a4 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 656              	.LVL52:
2059:../uvc.c      ****             prodCount++;
 657              		.loc 1 2059 0
 658 04a8 B0109FE5 		ldr	r1, .L45
2063:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
 659              		.loc 1 2063 0
 660 04ac 002050E2 		subs	r2, r0, #0
 661 04b0 D1FFFF0A 		beq	.L36
2065:../uvc.c      ****                 prodCount--;
 662              		.loc 1 2065 0
 663 04b4 B004D1E1 		ldrh	r0, [r1, #64]
 664              	.LVL53:
2066:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 665              		.loc 1 2066 0
 666 04b8 B430D5E1 		ldrh	r3, [r5, #4]
2065:../uvc.c      ****                 prodCount--;
 667              		.loc 1 2065 0
 668 04bc 01E040E2 		sub	lr, r0, #1
 669 04c0 0EC8A0E1 		mov	ip, lr, asl #16
 670 04c4 2C08A0E1 		mov	r0, ip, lsr #16
 671 04c8 B004C1E1 		strh	r0, [r1, #64]	@ movhi
2066:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 672              		.loc 1 2066 0
 673 04cc B0E4D1E1 		ldrh	lr, [r1, #64]
 674 04d0 B2C4D1E1 		ldrh	ip, [r1, #66]
 675 04d4 0400A0E3 		mov	r0, #4
 676 04d8 94109FE5 		ldr	r1, .L45+20
 677 04dc 00E08DE5 		str	lr, [sp, #0]
 678 04e0 04C08DE5 		str	ip, [sp, #4]
 679 04e4 FEFFFFEB 		bl	CyU3PDebugPrint
 680              	.LVL54:
 681 04e8 C3FFFFEA 		b	.L36
 682              	.LVL55:
 683              	.L43:
2035:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 684              		.loc 1 2035 0
 685 04ec 006095E5 		ldr	r6, [r5, #0]
 686              	.LBB38:
 687              	.LBB39:
1759:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 688              		.loc 1 1759 0
 689 04f0 0010E0E3 		mvn	r1, #0
 690              	.LVL56:
 691              	.LBE39:
 692              	.LBE38:
2036:../uvc.c      ****                 fb++;
 693              		.loc 1 2036 0
 694 04f4 64409FE5 		ldr	r4, .L45
2035:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 695              		.loc 1 2035 0
 696 04f8 0C6046E2 		sub	r6, r6, #12
 697              	.LVL57:
 698              	.LBB41:
 699              	.LBB40:
1759:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 700              		.loc 1 1759 0
 701 04fc 68009FE5 		ldr	r0, .L45+12
 702              	.LVL58:
 703 0500 FEFFFFEB 		bl	_txe_mutex_get
1760:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 704              		.loc 1 1760 0
 705 0504 6C109FE5 		ldr	r1, .L45+24
 706 0508 0600A0E1 		mov	r0, r6
 707 050c 0C20A0E3 		mov	r2, #12
 708 0510 FEFFFFEB 		bl	CyU3PMemCopy
1761:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 709              		.loc 1 1761 0
 710 0514 50009FE5 		ldr	r0, .L45+12
 711 0518 FEFFFFEB 		bl	_txe_mutex_put
 712              	.LBE40:
 713              	.LBE41:
2036:../uvc.c      ****                 fb++;
 714              		.loc 1 2036 0
 715 051c B4C3D4E1 		ldrh	ip, [r4, #52]
 716 0520 B410D5E1 		ldrh	r1, [r5, #4]
 717 0524 01008CE2 		add	r0, ip, #1
 718 0528 B403C4E1 		strh	r0, [r4, #52]	@ movhi
 719 052c D2FFFFEA 		b	.L39
 720              	.LVL59:
 721              	.L44:
2049:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 722              		.loc 1 2049 0
 723 0530 0010E0E3 		mvn	r1, #0
 724 0534 30009FE5 		ldr	r0, .L45+12
 725 0538 FEFFFFEB 		bl	_txe_mutex_get
2050:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 726              		.loc 1 2050 0
 727 053c 8114D7E5 		ldrb	r1, [r7, #1153]	@ zero_extendqisi2
2051:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 728              		.loc 1 2051 0
 729 0540 24009FE5 		ldr	r0, .L45+12
2050:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 730              		.loc 1 2050 0
 731 0544 DF2001E2 		and	r2, r1, #223
 732 0548 8124C7E5 		strb	r2, [r7, #1153]
2051:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 733              		.loc 1 2051 0
 734 054c FEFFFFEB 		bl	_txe_mutex_put
2052:../uvc.c      ****                 	stiflag = 0xAA;
 735              		.loc 1 2052 0
 736 0550 5530E0E3 		mvn	r3, #85
 737 0554 3A30C4E5 		strb	r3, [r4, #58]
 738 0558 B410D5E1 		ldrh	r1, [r5, #4]
 739 055c C4FFFFEA 		b	.L40
 740              	.L46:
 741              		.align	2
 742              	.L45:
 743 0560 00000000 		.word	.LANCHOR0
 744 0564 F03F0000 		.word	16368
 745 0568 00000000 		.word	.LANCHOR1
 746 056c 00000000 		.word	imgHdMux
 747 0570 00000000 		.word	glChHandleUVCStream
 748 0574 9C000000 		.word	.LC5
 749 0578 80040000 		.word	.LANCHOR1+1152
 750              		.cfi_endproc
 751              	.LFE11:
 753              		.align	2
 755              	CyFxUVCApplnUSBSetupCB:
 756              	.LFB10:
1860:../uvc.c      **** {
 757              		.loc 1 1860 0
 758              		.cfi_startproc
 759              		@ args = 0, pretend = 0, frame = 8
 760              		@ frame_needed = 0, uses_anonymous_args = 0
 761              	.LVL60:
1865:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 762              		.loc 1 1865 0
 763 057c C0329FE5 		ldr	r3, .L72
1860:../uvc.c      **** {
 764              		.loc 1 1860 0
 765 0580 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 766              	.LCFI6:
 767              		.cfi_def_cfa_offset 24
1866:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 768              		.loc 1 1866 0
 769 0584 BCC29FE5 		ldr	ip, .L72+4
1865:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 770              		.loc 1 1865 0
 771 0588 FF4000E2 		and	r4, r0, #255
 772              		.cfi_offset 14, -4
 773              		.cfi_offset 8, -8
 774              		.cfi_offset 7, -12
 775              		.cfi_offset 6, -16
 776              		.cfi_offset 5, -20
 777              		.cfi_offset 4, -24
1866:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 778              		.loc 1 1866 0
 779 058c FF8C00E2 		and	r8, r0, #65280
1867:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 780              		.loc 1 1867 0
 781 0590 2078A0E1 		mov	r7, r0, lsr #16
1865:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 782              		.loc 1 1865 0
 783 0594 0040C3E5 		strb	r4, [r3, #0]
1867:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 784              		.loc 1 1867 0
 785 0598 AC229FE5 		ldr	r2, .L72+8
1868:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 786              		.loc 1 1868 0
 787 059c AC029FE5 		ldr	r0, .L72+12
 788              	.LVL61:
1869:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 789              		.loc 1 1869 0
 790 05a0 AC329FE5 		ldr	r3, .L72+16
1868:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 791              		.loc 1 1868 0
 792 05a4 0158A0E1 		mov	r5, r1, asl #16
1866:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 793              		.loc 1 1866 0
 794 05a8 2884A0E1 		mov	r8, r8, lsr #8
1868:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 795              		.loc 1 1868 0
 796 05ac 2558A0E1 		mov	r5, r5, lsr #16
1869:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 797              		.loc 1 1869 0
 798 05b0 2118A0E1 		mov	r1, r1, lsr #16
 799              	.LVL62:
1872:../uvc.c      ****     switch (bmReqType)
 800              		.loc 1 1872 0
 801 05b4 020054E3 		cmp	r4, #2
1860:../uvc.c      **** {
 802              		.loc 1 1860 0
 803 05b8 10D04DE2 		sub	sp, sp, #16
 804              	.LCFI7:
 805              		.cfi_def_cfa_offset 40
1866:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 806              		.loc 1 1866 0
 807 05bc 0080CCE5 		strb	r8, [ip, #0]
1867:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 808              		.loc 1 1867 0
 809 05c0 B070C2E1 		strh	r7, [r2, #0]	@ movhi
1868:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 810              		.loc 1 1868 0
 811 05c4 B050C0E1 		strh	r5, [r0, #0]	@ movhi
1869:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 812              		.loc 1 1869 0
 813 05c8 B010C3E1 		strh	r1, [r3, #0]	@ movhi
1872:../uvc.c      ****     switch (bmReqType)
 814              		.loc 1 1872 0
 815 05cc 4F00000A 		beq	.L50
 816 05d0 0600009A 		bls	.L68
 817 05d4 210054E3 		cmp	r4, #33
 818 05d8 3A00000A 		beq	.L51
 819 05dc A10054E3 		cmp	r4, #161
 820 05e0 3800000A 		beq	.L51
 821              	.L65:
1861:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 822              		.loc 1 1861 0
 823 05e4 0000A0E3 		mov	r0, #0
 824              	.LVL63:
 825              	.L48:
1999:../uvc.c      **** }
 826              		.loc 1 1999 0
 827 05e8 10D08DE2 		add	sp, sp, #16
 828 05ec F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 829              	.LVL64:
 830              	.L68:
1872:../uvc.c      ****     switch (bmReqType)
 831              		.loc 1 1872 0
 832 05f0 010054E3 		cmp	r4, #1
 833 05f4 FAFFFF1A 		bne	.L65
1912:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 834              		.loc 1 1912 0
 835 05f8 0B0058E3 		cmp	r8, #11
 836 05fc F8FFFF1A 		bne	.L65
1916:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 837              		.loc 1 1916 0
 838 0600 010055E3 		cmp	r5, #1
 839 0604 F6FFFF1A 		bne	.L65
1916:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 840              		.loc 1 1916 0 is_stmt 0 discriminator 1
 841 0608 000057E3 		cmp	r7, #0
 842 060c F4FFFF1A 		bne	.L65
1921:../uvc.c      ****                     gpif_initialized = 0;
 843              		.loc 1 1921 0 is_stmt 1
 844 0610 40429FE5 		ldr	r4, .L72+20
1919:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 845              		.loc 1 1919 0
 846 0614 40129FE5 		ldr	r1, .L72+24
 847 0618 0400A0E3 		mov	r0, #4
 848 061c FEFFFFEB 		bl	CyU3PDebugPrint
1920:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 849              		.loc 1 1920 0
 850 0620 0500A0E1 		mov	r0, r5
 851 0624 FEFFFFEB 		bl	CyU3PGpifDisable
1924:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 852              		.loc 1 1924 0
 853 0628 0510A0E1 		mov	r1, r5
 854 062c 8300A0E3 		mov	r0, #131
1921:../uvc.c      ****                     gpif_initialized = 0;
 855              		.loc 1 1921 0
 856 0630 287084E5 		str	r7, [r4, #40]
1922:../uvc.c      ****                     streamingStarted = CyFalse;
 857              		.loc 1 1922 0
 858 0634 2C7084E5 		str	r7, [r4, #44]
1924:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 859              		.loc 1 1924 0
 860 0638 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1925:../uvc.c      ****                     CyU3PBusyWait (100);
 861              		.loc 1 1925 0
 862 063c 6400A0E3 		mov	r0, #100
 863 0640 FEFFFFEB 		bl	CyU3PBusyWait
1928:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 864              		.loc 1 1928 0
 865 0644 14029FE5 		ldr	r0, .L72+28
 866 0648 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1929:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 867              		.loc 1 1929 0
 868 064c 8300A0E3 		mov	r0, #131
 869 0650 FEFFFFEB 		bl	CyU3PUsbFlushEp
1930:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 870              		.loc 1 1930 0
 871 0654 0710A0E1 		mov	r1, r7
 872 0658 8300A0E3 		mov	r0, #131
 873 065c FEFFFFEB 		bl	CyU3PUsbSetEpNak
1931:../uvc.c      ****                     CyU3PBusyWait (100);
 874              		.loc 1 1931 0
 875 0660 6400A0E3 		mov	r0, #100
 876 0664 FEFFFFEB 		bl	CyU3PBusyWait
1934:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 877              		.loc 1 1934 0
 878 0668 0710A0E1 		mov	r1, r7
 879 066c 0520A0E1 		mov	r2, r5
 880 0670 8300A0E3 		mov	r0, #131
 881 0674 FEFFFFEB 		bl	CyU3PUsbStall
 882              	.LVL65:
1937:../uvc.c      ****                     CyU3PUsbAckSetup ();
 883              		.loc 1 1937 0
 884 0678 FEFFFFEB 		bl	CyU3PUsbAckSetup
1939:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 885              		.loc 1 1939 0
 886 067c 445084E5 		str	r5, [r4, #68]
 887              	.LBB46:
 888              	.LBB47:
1799:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 889              		.loc 1 1799 0
 890 0680 0400A0E1 		mov	r0, r4
 891 0684 0510A0E1 		mov	r1, r5
 892 0688 0220A0E3 		mov	r2, #2
 893 068c 0C308DE2 		add	r3, sp, #12
 894 0690 00708DE5 		str	r7, [sp, #0]
 895 0694 FEFFFFEB 		bl	_txe_event_flags_get
 896 0698 006050E2 		subs	r6, r0, #0
 897 069c 2E00001A 		bne	.L63
1802:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 898              		.loc 1 1802 0
 899 06a0 0110E0E3 		mvn	r1, #1
 900 06a4 0220A0E3 		mov	r2, #2
 901 06a8 0400A0E1 		mov	r0, r4
 902 06ac FEFFFFEB 		bl	_txe_event_flags_set
1805:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 903              		.loc 1 1805 0
 904 06b0 0400A0E1 		mov	r0, r4
 905 06b4 0210A0E3 		mov	r1, #2
 906 06b8 0620A0E1 		mov	r2, r6
 907 06bc FEFFFFEB 		bl	_txe_event_flags_set
1935:../uvc.c      ****                     uvcHandleReq = CyTrue;
 908              		.loc 1 1935 0
 909 06c0 0500A0E1 		mov	r0, r5
 910 06c4 C7FFFFEA 		b	.L48
 911              	.LVL66:
 912              	.L51:
 913              	.LBE47:
 914              	.LBE46:
1877:../uvc.c      ****             switch (wIndex & 0xFF)
 915              		.loc 1 1877 0
 916 06c8 FF5015E2 		ands	r5, r5, #255
 917 06cc 1A00001A 		bne	.L69
 918              	.LVL67:
1882:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 919              		.loc 1 1882 0
 920 06d0 0520A0E1 		mov	r2, r5
 921 06d4 7C019FE5 		ldr	r0, .L72+20
 922 06d8 0410A0E3 		mov	r1, #4
 923 06dc FEFFFFEB 		bl	_txe_event_flags_set
 924              	.LVL68:
1884:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 925              		.loc 1 1884 0
 926 06e0 002050E2 		subs	r2, r0, #0
1881:../uvc.c      ****                         uvcHandleReq = CyTrue;
 927              		.loc 1 1881 0
 928 06e4 0100A003 		moveq	r0, #1
 929              	.LVL69:
1884:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 930              		.loc 1 1884 0
 931 06e8 BEFFFF0A 		beq	.L48
1886:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 932              		.loc 1 1886 0
 933 06ec 70119FE5 		ldr	r1, .L72+32
 934 06f0 0400A0E3 		mov	r0, #4
 935 06f4 FEFFFFEB 		bl	CyU3PDebugPrint
 936              	.LVL70:
1887:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 937              		.loc 1 1887 0
 938 06f8 0500A0E1 		mov	r0, r5
 939 06fc 0110A0E3 		mov	r1, #1
 940 0700 0520A0E1 		mov	r2, r5
 941 0704 FEFFFFEB 		bl	CyU3PUsbStall
1881:../uvc.c      ****                         uvcHandleReq = CyTrue;
 942              		.loc 1 1881 0
 943 0708 0100A0E3 		mov	r0, #1
 944 070c B5FFFFEA 		b	.L48
 945              	.LVL71:
 946              	.L50:
1947:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 947              		.loc 1 1947 0
 948 0710 010058E3 		cmp	r8, #1
 949 0714 B2FFFF1A 		bne	.L65
1949:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 950              		.loc 1 1949 0
 951 0718 830055E3 		cmp	r5, #131
 952 071c B0FFFF1A 		bne	.L65
1955:../uvc.c      ****                     if (streamingStarted == CyTrue)
 953              		.loc 1 1955 0
 954 0720 30719FE5 		ldr	r7, .L72+20
 955 0724 2C6097E5 		ldr	r6, [r7, #44]
 956 0728 010056E3 		cmp	r6, #1
 957 072c 1500000A 		beq	.L70
 958              	.LVL72:
1987:../uvc.c      ****                         CyU3PUsbAckSetup ();
 959              		.loc 1 1987 0
 960 0730 FEFFFFEB 		bl	CyU3PUsbAckSetup
1986:../uvc.c      ****                         uvcHandleReq = CyTrue;
 961              		.loc 1 1986 0
 962 0734 0800A0E1 		mov	r0, r8
 963 0738 AAFFFFEA 		b	.L48
 964              	.LVL73:
 965              	.L69:
1877:../uvc.c      ****             switch (wIndex & 0xFF)
 966              		.loc 1 1877 0
 967 073c 010055E3 		cmp	r5, #1
 968 0740 A7FFFF1A 		bne	.L65
 969              	.LVL74:
1895:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 970              		.loc 1 1895 0
 971 0744 0020A0E3 		mov	r2, #0
 972 0748 08019FE5 		ldr	r0, .L72+20
 973 074c 0810A0E3 		mov	r1, #8
 974 0750 FEFFFFEB 		bl	_txe_event_flags_set
 975              	.LVL75:
1897:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 976              		.loc 1 1897 0
 977 0754 002050E2 		subs	r2, r0, #0
 978 0758 0100001A 		bne	.L71
 979              	.LVL76:
 980              	.L63:
 981              	.LBB49:
 982              	.LBB48:
1935:../uvc.c      ****                     uvcHandleReq = CyTrue;
 983              		.loc 1 1935 0
 984 075c 0500A0E1 		mov	r0, r5
 985 0760 A0FFFFEA 		b	.L48
 986              	.LVL77:
 987              	.L71:
 988              	.LBE48:
 989              	.LBE49:
1900:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 990              		.loc 1 1900 0
 991 0764 FC109FE5 		ldr	r1, .L72+36
 992 0768 0400A0E3 		mov	r0, #4
 993              	.LVL78:
 994 076c FEFFFFEB 		bl	CyU3PDebugPrint
 995              	.LVL79:
1901:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 996              		.loc 1 1901 0
 997 0770 0000A0E3 		mov	r0, #0
 998 0774 0510A0E1 		mov	r1, r5
 999 0778 0020A0E1 		mov	r2, r0
 1000 077c FEFFFFEB 		bl	CyU3PUsbStall
1894:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1001              		.loc 1 1894 0
 1002 0780 0500A0E1 		mov	r0, r5
 1003 0784 97FFFFEA 		b	.L48
 1004              	.LVL80:
 1005              	.L70:
1957:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 1006              		.loc 1 1957 0
 1007 0788 DC109FE5 		ldr	r1, .L72+40
 1008 078c 0400A0E3 		mov	r0, #4
 1009 0790 FEFFFFEB 		bl	CyU3PDebugPrint
1961:../uvc.c      ****                         gpif_initialized = 0;
 1010              		.loc 1 1961 0
 1011 0794 0080A0E3 		mov	r8, #0
1960:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 1012              		.loc 1 1960 0
 1013 0798 0600A0E1 		mov	r0, r6
 1014 079c FEFFFFEB 		bl	CyU3PGpifDisable
1965:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1015              		.loc 1 1965 0
 1016 07a0 0610A0E1 		mov	r1, r6
 1017 07a4 0500A0E1 		mov	r0, r5
1961:../uvc.c      ****                         gpif_initialized = 0;
 1018              		.loc 1 1961 0
 1019 07a8 288087E5 		str	r8, [r7, #40]
1962:../uvc.c      ****                         streamingStarted = CyFalse;
 1020              		.loc 1 1962 0
 1021 07ac 2C8087E5 		str	r8, [r7, #44]
1965:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1022              		.loc 1 1965 0
 1023 07b0 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1966:../uvc.c      ****                         CyU3PBusyWait (100);
 1024              		.loc 1 1966 0
 1025 07b4 6400A0E3 		mov	r0, #100
 1026 07b8 FEFFFFEB 		bl	CyU3PBusyWait
1969:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 1027              		.loc 1 1969 0
 1028 07bc 9C009FE5 		ldr	r0, .L72+28
 1029 07c0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1970:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1030              		.loc 1 1970 0
 1031 07c4 0500A0E1 		mov	r0, r5
 1032 07c8 FEFFFFEB 		bl	CyU3PUsbFlushEp
1971:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1033              		.loc 1 1971 0
 1034 07cc 0810A0E1 		mov	r1, r8
 1035 07d0 0500A0E1 		mov	r0, r5
 1036 07d4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1972:../uvc.c      ****                         CyU3PBusyWait (100);
 1037              		.loc 1 1972 0
 1038 07d8 6400A0E3 		mov	r0, #100
 1039 07dc FEFFFFEB 		bl	CyU3PBusyWait
1975:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 1040              		.loc 1 1975 0
 1041 07e0 0810A0E1 		mov	r1, r8
 1042 07e4 0620A0E1 		mov	r2, r6
 1043 07e8 0500A0E1 		mov	r0, r5
 1044 07ec FEFFFFEB 		bl	CyU3PUsbStall
 1045              	.LVL81:
1979:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1046              		.loc 1 1979 0
 1047 07f0 FEFFFFEB 		bl	CyU3PUsbAckSetup
1981:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 1048              		.loc 1 1981 0
 1049 07f4 446087E5 		str	r6, [r7, #68]
 1050              	.LBB50:
 1051              	.LBB51:
1799:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1052              		.loc 1 1799 0
 1053 07f8 0700A0E1 		mov	r0, r7
 1054 07fc 0610A0E1 		mov	r1, r6
 1055 0800 0420A0E1 		mov	r2, r4
 1056 0804 0C308DE2 		add	r3, sp, #12
 1057 0808 00808DE5 		str	r8, [sp, #0]
 1058 080c FEFFFFEB 		bl	_txe_event_flags_get
 1059 0810 005050E2 		subs	r5, r0, #0
1977:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1060              		.loc 1 1977 0
 1061 0814 0600A011 		movne	r0, r6
1799:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1062              		.loc 1 1799 0
 1063 0818 72FFFF1A 		bne	.L48
1802:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1064              		.loc 1 1802 0
 1065 081c 0110E0E3 		mvn	r1, #1
 1066 0820 0420A0E1 		mov	r2, r4
 1067 0824 0700A0E1 		mov	r0, r7
 1068 0828 FEFFFFEB 		bl	_txe_event_flags_set
1805:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1069              		.loc 1 1805 0
 1070 082c 0700A0E1 		mov	r0, r7
 1071 0830 0410A0E1 		mov	r1, r4
 1072 0834 0520A0E1 		mov	r2, r5
 1073 0838 FEFFFFEB 		bl	_txe_event_flags_set
1977:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1074              		.loc 1 1977 0
 1075 083c 0600A0E1 		mov	r0, r6
 1076 0840 68FFFFEA 		b	.L48
 1077              	.L73:
 1078              		.align	2
 1079              	.L72:
 1080 0844 00000000 		.word	bmReqType
 1081 0848 00000000 		.word	bRequest
 1082 084c 00000000 		.word	wValue
 1083 0850 00000000 		.word	wIndex
 1084 0854 00000000 		.word	wLength
 1085 0858 00000000 		.word	.LANCHOR0
 1086 085c 54010000 		.word	.LC8
 1087 0860 00000000 		.word	glChHandleUVCStream
 1088 0864 E8000000 		.word	.LC6
 1089 0868 20010000 		.word	.LC7
 1090 086c 6C010000 		.word	.LC9
 1091              	.LBE51:
 1092              	.LBE50:
 1093              		.cfi_endproc
 1094              	.LFE10:
 1096              		.align	2
 1097              		.global	CyFxGpifCB
 1099              	CyFxGpifCB:
 1100              	.LFB13:
2198:../uvc.c      **** {
 1101              		.loc 1 2198 0
 1102              		.cfi_startproc
 1103              		@ args = 0, pretend = 0, frame = 0
 1104              		@ frame_needed = 0, uses_anonymous_args = 0
 1105              	.LVL82:
2199:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1106              		.loc 1 2199 0
 1107 0870 010050E3 		cmp	r0, #1
2198:../uvc.c      **** {
 1108              		.loc 1 2198 0
 1109 0874 10402DE9 		stmfd	sp!, {r4, lr}
 1110              	.LCFI8:
 1111              		.cfi_def_cfa_offset 8
2198:../uvc.c      **** {
 1112              		.loc 1 2198 0
 1113 0878 0120A0E1 		mov	r2, r1
2199:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1114              		.loc 1 2199 0
 1115 087c 1080BD18 		ldmnefd	sp!, {r4, pc}
 1116              		.cfi_offset 14, -4
 1117              		.cfi_offset 4, -8
 1118              	.LVL83:
 1119              	.LBB56:
 1120              	.LBB57:
2096:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1121              		.loc 1 2096 0
 1122 0880 CC309FE5 		ldr	r3, .L89
 1123 0884 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 1124 0888 030053E3 		cmp	r3, #3
 1125 088c 2100000A 		beq	.L88
2122:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1126              		.loc 1 2122 0
 1127 0890 020053E3 		cmp	r3, #2
 1128 0894 1080BD18 		ldmnefd	sp!, {r4, pc}
2124:../uvc.c      ****         switch (stateId)
 1129              		.loc 1 2124 0
 1130 0898 080041E2 		sub	r0, r1, #8
 1131              	.LVL84:
 1132 089c 0A0050E3 		cmp	r0, #10
 1133 08a0 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1134 08a4 230000EA 		b	.L81
 1135              	.L83:
 1136 08a8 D8080000 		.word	.L78
 1137 08ac 38090000 		.word	.L81
 1138 08b0 38090000 		.word	.L81
 1139 08b4 D4080000 		.word	.L74
 1140 08b8 38090000 		.word	.L81
 1141 08bc 38090000 		.word	.L81
 1142 08c0 38090000 		.word	.L81
 1143 08c4 10090000 		.word	.L87
 1144 08c8 38090000 		.word	.L81
 1145 08cc 38090000 		.word	.L81
 1146 08d0 D4080000 		.word	.L74
 1147              	.LVL85:
 1148              	.L74:
 1149 08d4 1080BDE8 		ldmfd	sp!, {r4, pc}
 1150              	.LVL86:
 1151              	.L78:
2107:../uvc.c      ****                 socket = 0;
 1152              		.loc 1 2107 0
 1153 08d8 0010A0E3 		mov	r1, #0
 1154              	.LVL87:
 1155              	.L79:
2181:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1156              		.loc 1 2181 0
 1157 08dc 74009FE5 		ldr	r0, .L89+4
 1158 08e0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1159              	.LVL88:
2182:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1160              		.loc 1 2182 0
 1161 08e4 002050E2 		subs	r2, r0, #0
 1162 08e8 F9FFFF0A 		beq	.L74
2184:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1163              		.loc 1 2184 0
 1164 08ec 0400A0E3 		mov	r0, #4
 1165              	.LVL89:
 1166 08f0 64109FE5 		ldr	r1, .L89+8
 1167 08f4 FEFFFFEB 		bl	CyU3PDebugPrint
 1168              	.LVL90:
 1169              	.L84:
 1170              	.LBB58:
 1171              	.LBB59:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1172              		.loc 1 1786 0
 1173 08f8 60109FE5 		ldr	r1, .L89+12
 1174 08fc 0400A0E3 		mov	r0, #4
 1175 0900 FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 1176              		.loc 1 1787 0
 1177 0904 FA0FA0E3 		mov	r0, #1000
 1178 0908 FEFFFFEB 		bl	_tx_thread_sleep
 1179 090c F9FFFFEA 		b	.L84
 1180              	.LVL91:
 1181              	.L87:
 1182              	.LBE59:
 1183              	.LBE58:
2151:../uvc.c      ****                 socket = 1;
 1184              		.loc 1 2151 0
 1185 0910 0110A0E3 		mov	r1, #1
 1186              	.LVL92:
 1187 0914 F0FFFFEA 		b	.L79
 1188              	.LVL93:
 1189              	.L88:
2098:../uvc.c      ****         switch (stateId)
 1190              		.loc 1 2098 0
 1191 0918 0B2041E2 		sub	r2, r1, #11
 1192 091c 030052E3 		cmp	r2, #3
 1193 0920 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 1194 0924 060000EA 		b	.L77
 1195              	.L80:
 1196 0928 D8080000 		.word	.L78
 1197 092c 10090000 		.word	.L87
 1198 0930 D4080000 		.word	.L74
 1199 0934 D4080000 		.word	.L74
 1200              	.LVL94:
 1201              	.L81:
2170:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1202              		.loc 1 2170 0
 1203 0938 24109FE5 		ldr	r1, .L89+16
 1204              	.LVL95:
 1205 093c 0100A0E3 		mov	r0, #1
 1206 0940 FEFFFFEB 		bl	CyU3PDebugPrint
 1207              	.LVL96:
 1208              	.L77:
 1209              	.LBE57:
 1210              	.LBE56:
2205:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1211              		.loc 1 2205 0
 1212 0944 1C109FE5 		ldr	r1, .L89+20
 1213 0948 0400A0E3 		mov	r0, #4
2208:../uvc.c      **** }
 1214              		.loc 1 2208 0
 1215 094c 1040BDE8 		ldmfd	sp!, {r4, lr}
2205:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1216              		.loc 1 2205 0
 1217 0950 FEFFFFEA 		b	CyU3PDebugPrint
 1218              	.L90:
 1219              		.align	2
 1220              	.L89:
 1221 0954 00000000 		.word	.LANCHOR0
 1222 0958 00000000 		.word	glChHandleUVCStream
 1223 095c A8010000 		.word	.LC11
 1224 0960 D8010000 		.word	.LC12
 1225 0964 90010000 		.word	.LC10
 1226 0968 EC010000 		.word	.LC13
 1227              		.cfi_endproc
 1228              	.LFE13:
 1230              		.align	2
 1231              		.global	I2CCmdHandler
 1233              	I2CCmdHandler:
 1234              	.LFB0:
 606:../uvc.c      **** void I2CCmdHandler(){
 1235              		.loc 1 606 0
 1236              		.cfi_startproc
 1237              		@ args = 0, pretend = 0, frame = 16
 1238              		@ frame_needed = 0, uses_anonymous_args = 0
 1239 096c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1240              	.LCFI9:
 1241              		.cfi_def_cfa_offset 36
 609:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1242              		.loc 1 609 0
 1243 0970 40429FE5 		ldr	r4, .L106
 1244              		.cfi_offset 14, -4
 1245              		.cfi_offset 11, -8
 1246              		.cfi_offset 10, -12
 1247              		.cfi_offset 9, -16
 1248              		.cfi_offset 8, -20
 1249              		.cfi_offset 7, -24
 1250              		.cfi_offset 6, -28
 1251              		.cfi_offset 5, -32
 1252              		.cfi_offset 4, -36
 606:../uvc.c      **** void I2CCmdHandler(){
 1253              		.loc 1 606 0
 1254 0974 3CD04DE2 		sub	sp, sp, #60
 1255              	.LCFI10:
 1256              		.cfi_def_cfa_offset 96
 614:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1257              		.loc 1 614 0
 1258 0978 5320D4E5 		ldrb	r2, [r4, #83]	@ zero_extendqisi2
 609:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1259              		.loc 1 609 0
 1260 097c 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1261              	.LVL97:
 610:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1262              		.loc 1 610 0
 1263 0980 4D70D4E5 		ldrb	r7, [r4, #77]	@ zero_extendqisi2
 1264              	.LVL98:
 611:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1265              		.loc 1 611 0
 1266 0984 5460D4E5 		ldrb	r6, [r4, #84]	@ zero_extendqisi2
 1267              	.LVL99:
 614:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1268              		.loc 1 614 0
 1269 0988 4EE0D4E5 		ldrb	lr, [r4, #78]	@ zero_extendqisi2
 1270 098c 4F80D4E5 		ldrb	r8, [r4, #79]	@ zero_extendqisi2
 1271 0990 50A0D4E5 		ldrb	sl, [r4, #80]	@ zero_extendqisi2
 1272 0994 5190D4E5 		ldrb	r9, [r4, #81]	@ zero_extendqisi2
 1273 0998 52B0D4E5 		ldrb	fp, [r4, #82]	@ zero_extendqisi2
 1274 099c 14208DE5 		str	r2, [sp, #20]
 1275 09a0 5510D4E5 		ldrb	r1, [r4, #85]	@ zero_extendqisi2
 1276 09a4 0730A0E1 		mov	r3, r7
 1277 09a8 1C108DE5 		str	r1, [sp, #28]
 1278 09ac 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1279 09b0 0400A0E3 		mov	r0, #4
 1280 09b4 00129FE5 		ldr	r1, .L106+4
 1281 09b8 0520A0E1 		mov	r2, r5
 1282 09bc 00E08DE5 		str	lr, [sp, #0]
 1283 09c0 00058DE9 		stmib	sp, {r8, sl}	@ phole stm
 1284 09c4 0C908DE5 		str	r9, [sp, #12]
 1285 09c8 10B08DE5 		str	fp, [sp, #16]
 1286 09cc 18608DE5 		str	r6, [sp, #24]
 1287 09d0 20C08DE5 		str	ip, [sp, #32]
 1288 09d4 FEFFFFEB 		bl	CyU3PDebugPrint
 617:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1289              		.loc 1 617 0
 1290 09d8 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 1291 09dc 520053E3 		cmp	r3, #82
 1292 09e0 2C00000A 		beq	.L102
 1293              	.L92:
 627:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1294              		.loc 1 627 0
 1295 09e4 000055E3 		cmp	r5, #0
 1296 09e8 1600000A 		beq	.L103
 652:../uvc.c      **** 	}else if(CmdType == 1){
 1297              		.loc 1 652 0
 1298 09ec 010055E3 		cmp	r5, #1
 1299 09f0 0100000A 		beq	.L104
 1300              	.LVL100:
 1301              	.L91:
 671:../uvc.c      **** }
 1302              		.loc 1 671 0
 1303 09f4 3CD08DE2 		add	sp, sp, #60
 1304 09f8 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1305              	.LVL101:
 1306              	.L104:
 654:../uvc.c      **** 			if(CmdRegLen == 2){
 1307              		.loc 1 654 0
 1308 09fc 020057E3 		cmp	r7, #2
 1309 0a00 3700000A 		beq	.L105
 659:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1310              		.loc 1 659 0
 1311 0a04 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1312 0a08 A8319FE5 		ldr	r3, .L106
 1313 0a0c FE1001E2 		and	r1, r1, #254
 1314 0a10 820051E3 		cmp	r1, #130
 662:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1315              		.loc 1 662 0
 1316 0a14 5050D315 		ldrneb	r5, [r3, #80]	@ zero_extendqisi2
 1317              	.LVL102:
 659:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1318              		.loc 1 659 0
 1319 0a18 0200001A 		bne	.L101
 659:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1320              		.loc 1 659 0 is_stmt 0 discriminator 1
 1321 0a1c 5050D3E5 		ldrb	r5, [r3, #80]	@ zero_extendqisi2
 1322 0a20 300055E3 		cmp	r5, #48
 1323 0a24 4F00000A 		beq	.L99
 1324              	.L101:
 662:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1325              		.loc 1 662 0 is_stmt 1
 1326 0a28 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1327              	.L100:
 664:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 1328              		.loc 1 664 0
 1329 0a2c 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1330 0a30 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1331 0a34 FE0002E2 		and	r0, r2, #254
 1332 0a38 0520A0E1 		mov	r2, r5
 1333 0a3c 00E08DE5 		str	lr, [sp, #0]
 1334 0a40 FEFFFFEB 		bl	SensorWrite2B
 1335 0a44 EAFFFFEA 		b	.L91
 1336              	.LVL103:
 1337              	.L103:
 643:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1338              		.loc 1 643 0
 1339 0a48 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1340 0a4c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 629:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1341              		.loc 1 629 0
 1342 0a50 0FE0A0E3 		mov	lr, #15
 643:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1343              		.loc 1 643 0
 1344 0a54 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1345 0a58 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 629:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1346              		.loc 1 629 0
 1347 0a5c 57E0C4E5 		strb	lr, [r4, #87]
 643:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1348              		.loc 1 643 0
 1349 0a60 34C08DE2 		add	ip, sp, #52
 1350 0a64 010080E3 		orr	r0, r0, #1
 1351 0a68 011081E3 		orr	r1, r1, #1
 1352 0a6c 00C08DE5 		str	ip, [sp, #0]
 1353 0a70 FEFFFFEB 		bl	SensorRead2B
 644:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1354              		.loc 1 644 0
 1355 0a74 3430DDE5 		ldrb	r3, [sp, #52]	@ zero_extendqisi2
 645:../uvc.c      **** 				if(CmdDataLen == 2){
 1356              		.loc 1 645 0
 1357 0a78 020056E3 		cmp	r6, #2
 644:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1358              		.loc 1 644 0
 1359 0a7c 5530C4E5 		strb	r3, [r4, #85]
 646:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1360              		.loc 1 646 0
 1361 0a80 3500DD05 		ldreqb	r0, [sp, #53]	@ zero_extendqisi2
 1362 0a84 2C319F05 		ldreq	r3, .L106
 648:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1363              		.loc 1 648 0
 1364 0a88 0020E0E3 		mvn	r2, #0
 1365 0a8c 5720C4E5 		strb	r2, [r4, #87]
 646:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1366              		.loc 1 646 0
 1367 0a90 5600C305 		streqb	r0, [r3, #86]
 1368 0a94 D6FFFFEA 		b	.L91
 1369              	.L102:
 617:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1370              		.loc 1 617 0 discriminator 1
 1371 0a98 5000D4E5 		ldrb	r0, [r4, #80]	@ zero_extendqisi2
 1372 0a9c 300050E3 		cmp	r0, #48
 1373 0aa0 CFFFFF1A 		bne	.L92
 1374 0aa4 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1375 0aa8 010053E3 		cmp	r3, #1
 1376 0aac CCFFFF1A 		bne	.L92
 619:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 1377              		.loc 1 619 0
 1378 0ab0 5520D4E5 		ldrb	r2, [r4, #85]	@ zero_extendqisi2
 1379 0ab4 04C19FE5 		ldr	ip, .L106+8
 1380 0ab8 031002E2 		and	r1, r2, #3
 1381 0abc 8C14CCE5 		strb	r1, [ip, #1164]
 620:../uvc.c      **** 		if(is60Hz==CyFalse)
 1382              		.loc 1 620 0
 1383 0ac0 58E094E5 		ldr	lr, [r4, #88]
 624:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1384              		.loc 1 624 0
 1385 0ac4 F8109FE5 		ldr	r1, .L106+12
 620:../uvc.c      **** 		if(is60Hz==CyFalse)
 1386              		.loc 1 620 0
 1387 0ac8 00005EE3 		cmp	lr, #0
 622:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 1388              		.loc 1 622 0
 1389 0acc 80208203 		orreq	r2, r2, #128
 1390 0ad0 5520C405 		streqb	r2, [r4, #85]
 624:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1391              		.loc 1 624 0
 1392 0ad4 8C34DCE5 		ldrb	r3, [ip, #1164]	@ zero_extendqisi2
 1393 0ad8 0400A0E3 		mov	r0, #4
 1394 0adc FEFFFFEB 		bl	CyU3PDebugPrint
 1395 0ae0 BFFFFFEA 		b	.L92
 1396              	.L105:
 656:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 1397              		.loc 1 656 0
 1398 0ae4 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1399 0ae8 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1400 0aec 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1401 0af0 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1402 0af4 0020A0E3 		mov	r2, #0
 1403 0af8 FE0000E2 		and	r0, r0, #254
 1404 0afc 00E08DE5 		str	lr, [sp, #0]
 1405 0b00 FEFFFFEB 		bl	SensorWrite2B2
 1406 0b04 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1407 0b08 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1408 0b0c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1409 0b10 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1410 0b14 FE0002E2 		and	r0, r2, #254
 1411 0b18 0020A0E3 		mov	r2, #0
 1412 0b1c 00C08DE5 		str	ip, [sp, #0]
 1413 0b20 FEFFFFEB 		bl	SensorWrite2B2
 1414              	.LVL104:
 1415 0b24 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1416 0b28 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1417 0b2c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1418 0b30 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1419 0b34 0020A0E3 		mov	r2, #0
 1420 0b38 FE0000E2 		and	r0, r0, #254
 1421 0b3c 00C08DE5 		str	ip, [sp, #0]
 1422 0b40 FEFFFFEB 		bl	SensorWrite2B2
 1423 0b44 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1424 0b48 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1425 0b4c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1426 0b50 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1427 0b54 FE0002E2 		and	r0, r2, #254
 1428 0b58 0020A0E3 		mov	r2, #0
 1429 0b5c 00C08DE5 		str	ip, [sp, #0]
 1430 0b60 FEFFFFEB 		bl	SensorWrite2B2
 1431 0b64 A2FFFFEA 		b	.L91
 1432              	.LVL105:
 1433              	.L99:
 659:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1434              		.loc 1 659 0 discriminator 1
 1435 0b68 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1436 0b6c 100053E3 		cmp	r3, #16
 1437 0b70 ADFFFF1A 		bne	.L100
 660:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 1438              		.loc 1 660 0
 1439 0b74 4C409FE5 		ldr	r4, .L106+16
 1440 0b78 0010E0E3 		mvn	r1, #0
 1441 0b7c 1C0094E5 		ldr	r0, [r4, #28]
 1442 0b80 2C308DE5 		str	r3, [sp, #44]
 1443 0b84 FEFFFFEB 		bl	_txe_mutex_get
 661:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 1444              		.loc 1 661 0
 1445 0b88 2C309DE5 		ldr	r3, [sp, #44]
 1446 0b8c 00C0A0E3 		mov	ip, #0
 1447 0b90 0320A0E1 		mov	r2, r3
 1448 0b94 0400A0E1 		mov	r0, r4
 1449 0b98 1710A0E3 		mov	r1, #23
 1450 0b9c 0530A0E1 		mov	r3, r5
 1451 0ba0 00C08DE5 		str	ip, [sp, #0]
 1452 0ba4 04C08DE5 		str	ip, [sp, #4]
 1453 0ba8 FEFFFFEB 		bl	cmdSet
 662:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1454              		.loc 1 662 0
 1455 0bac 1C0094E5 		ldr	r0, [r4, #28]
 1456 0bb0 FEFFFFEB 		bl	_txe_mutex_put
 1457 0bb4 8EFFFFEA 		b	.L91
 1458              	.L107:
 1459              		.align	2
 1460              	.L106:
 1461 0bb8 00000000 		.word	.LANCHOR0
 1462 0bbc 04020000 		.word	.LC14
 1463 0bc0 00000000 		.word	.LANCHOR1
 1464 0bc4 50020000 		.word	.LC15
 1465 0bc8 00000000 		.word	cmdQu
 1466              		.cfi_endproc
 1467              	.LFE0:
 1469              		.align	2
 1470              		.global	setIrisauto
 1472              	setIrisauto:
 1473              	.LFB1:
 677:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1474              		.loc 1 677 0
 1475              		.cfi_startproc
 1476              		@ args = 0, pretend = 0, frame = 0
 1477              		@ frame_needed = 0, uses_anonymous_args = 0
 1478              	.LVL106:
 1479 0bcc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1480              	.LCFI11:
 1481              		.cfi_def_cfa_offset 16
 1482 0bd0 0160A0E1 		mov	r6, r1
 1483              		.cfi_offset 14, -4
 1484              		.cfi_offset 6, -8
 1485              		.cfi_offset 5, -12
 1486              		.cfi_offset 4, -16
 1487 0bd4 08D04DE2 		sub	sp, sp, #8
 1488              	.LCFI12:
 1489              		.cfi_def_cfa_offset 24
 677:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1490              		.loc 1 677 0
 1491 0bd8 0040A0E1 		mov	r4, r0
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1492              		.loc 1 680 0
 1493 0bdc 0050A0E3 		mov	r5, #0
 679:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1494              		.loc 1 679 0
 1495 0be0 0010E0E3 		mvn	r1, #0
 1496              	.LVL107:
 1497 0be4 1C0090E5 		ldr	r0, [r0, #28]
 1498              	.LVL108:
 1499 0be8 FEFFFFEB 		bl	_txe_mutex_get
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1500              		.loc 1 680 0
 1501 0bec 060065E0 		rsb	r0, r5, r6
 1502 0bf0 00C070E2 		rsbs	ip, r0, #0
 1503 0bf4 00C0ACE0 		adc	ip, ip, r0
 1504 0bf8 2010A0E3 		mov	r1, #32
 1505 0bfc 2720A0E3 		mov	r2, #39
 1506 0c00 3030A0E3 		mov	r3, #48
 1507 0c04 0400A0E1 		mov	r0, r4
 1508 0c08 00C08DE5 		str	ip, [sp, #0]
 1509 0c0c 04508DE5 		str	r5, [sp, #4]
 1510 0c10 FEFFFFEB 		bl	cmdSet
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 1511              		.loc 1 681 0
 1512 0c14 050056E1 		cmp	r6, r5
 1513 0c18 0260A003 		moveq	r6, #2
 1514 0c1c 0160A013 		movne	r6, #1
 1515 0c20 0400A0E1 		mov	r0, r4
 1516 0c24 2110A0E3 		mov	r1, #33
 1517 0c28 2520A0E3 		mov	r2, #37
 1518 0c2c 3030A0E3 		mov	r3, #48
 1519 0c30 00608DE5 		str	r6, [sp, #0]
 1520 0c34 04508DE5 		str	r5, [sp, #4]
 1521 0c38 FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1522              		.loc 1 682 0
 1523 0c3c 1C0094E5 		ldr	r0, [r4, #28]
 683:../uvc.c      **** }
 1524              		.loc 1 683 0
 1525 0c40 08D08DE2 		add	sp, sp, #8
 1526 0c44 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1527              		.loc 1 682 0
 1528 0c48 FEFFFFEA 		b	_txe_mutex_put
 1529              		.cfi_endproc
 1530              	.LFE1:
 1532              		.align	2
 1533              		.global	getShutCtrl
 1535              	getShutCtrl:
 1536              	.LFB2:
 687:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 1537              		.loc 1 687 0
 1538              		.cfi_startproc
 1539              		@ args = 0, pretend = 0, frame = 0
 1540              		@ frame_needed = 0, uses_anonymous_args = 0
 1541              	.LVL109:
 692:../uvc.c      **** 	switch (Data){
 1542              		.loc 1 692 0
 1543 0c4c 013040E2 		sub	r3, r0, #1
 687:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 1544              		.loc 1 687 0
 1545 0c50 10402DE9 		stmfd	sp!, {r4, lr}
 1546              	.LCFI13:
 1547              		.cfi_def_cfa_offset 8
 1548 0c54 08D04DE2 		sub	sp, sp, #8
 1549              	.LCFI14:
 1550              		.cfi_def_cfa_offset 16
 692:../uvc.c      **** 	switch (Data){
 1551              		.loc 1 692 0
 1552 0c58 090053E3 		cmp	r3, #9
 1553 0c5c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1554 0c60 380000EA 		b	.L112
 1555              		.cfi_offset 14, -4
 1556              		.cfi_offset 4, -8
 1557              	.L115:
 1558 0c64 FC0C0000 		.word	.L113
 1559 0c68 FC0C0000 		.word	.L113
 1560 0c6c FC0C0000 		.word	.L113
 1561 0c70 FC0C0000 		.word	.L113
 1562 0c74 FC0C0000 		.word	.L113
 1563 0c78 8C0C0000 		.word	.L114
 1564 0c7c 8C0C0000 		.word	.L114
 1565 0c80 8C0C0000 		.word	.L114
 1566 0c84 8C0C0000 		.word	.L114
 1567 0c88 8C0C0000 		.word	.L114
 1568              	.L114:
 1569              	.LVL110:
 716:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1570              		.loc 1 716 0
 1571 0c8c ECC09FE5 		ldr	ip, .L124
 714:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 1572              		.loc 1 714 0
 1573 0c90 8330A0E1 		mov	r3, r3, asl #1
 716:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1574              		.loc 1 716 0
 1575 0c94 B3309CE1 		ldrh	r3, [ip, r3]
 1576 0c98 E4E09FE5 		ldr	lr, .L124+4
 1577 0c9c 032263E0 		rsb	r2, r3, r3, asl #4
 1578 0ca0 8240A0E1 		mov	r4, r2, asl #1
 1579 0ca4 94CECEE0 		smull	ip, lr, r4, lr
 1580 0ca8 C4CFA0E1 		mov	ip, r4, asr #31
 1581 0cac 4E246CE0 		rsb	r2, ip, lr, asr #8
 717:../uvc.c      **** 		if(NumLn > 1944)
 1582              		.loc 1 717 0
 1583 0cb0 D0E09FE5 		ldr	lr, .L124+8
 716:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1584              		.loc 1 716 0
 1585 0cb4 0228A0E1 		mov	r2, r2, asl #16
 1586 0cb8 22C8A0E1 		mov	ip, r2, lsr #16
 1587              	.LVL111:
 717:../uvc.c      **** 		if(NumLn > 1944)
 1588              		.loc 1 717 0
 1589 0cbc 0E005CE1 		cmp	ip, lr
 1590 0cc0 2600008A 		bhi	.L121
 719:../uvc.c      **** 		else if(NumLn < 8)
 1591              		.loc 1 719 0
 1592 0cc4 07005CE3 		cmp	ip, #7
 1593 0cc8 2700008A 		bhi	.L123
 1594              	.LVL112:
 1595              	.L122:
 1596 0ccc 01C0A0E3 		mov	ip, #1
 1597 0cd0 08E0A0E3 		mov	lr, #8
 1598 0cd4 0C40A0E1 		mov	r4, ip
 1599              	.L118:
 1600              	.LVL113:
 722:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 1601              		.loc 1 722 0
 1602 0cd8 0120A0E3 		mov	r2, #1
 1603 0cdc 0020C1E5 		strb	r2, [r1, #0]
 723:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 1604              		.loc 1 723 0
 1605 0ce0 0020A0E1 		mov	r2, r0
 1606 0ce4 A0109FE5 		ldr	r1, .L124+12
 1607              	.LVL114:
 1608 0ce8 0400A0E3 		mov	r0, #4
 1609              	.LVL115:
 1610 0cec 00E08DE5 		str	lr, [sp, #0]
 1611 0cf0 04C08DE5 		str	ip, [sp, #4]
 1612 0cf4 FEFFFFEB 		bl	CyU3PDebugPrint
 724:../uvc.c      **** 		break;
 1613              		.loc 1 724 0
 1614 0cf8 150000EA 		b	.L117
 1615              	.LVL116:
 1616              	.L113:
 698:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 1617              		.loc 1 698 0
 1618 0cfc 7CE09FE5 		ldr	lr, .L124
 1619 0d00 8330A0E1 		mov	r3, r3, asl #1
 1620 0d04 B3309EE1 		ldrh	r3, [lr, r3]
 1621              	.LVL117:
 700:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 1622              		.loc 1 700 0
 1623 0d08 80C09FE5 		ldr	ip, .L124+16
 701:../uvc.c      **** 		if(NumLn > 1944)
 1624              		.loc 1 701 0
 1625 0d0c 74E09FE5 		ldr	lr, .L124+8
 700:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 1626              		.loc 1 700 0
 1627 0d10 932C8CE0 		umull	r2, ip, r3, ip
 1628 0d14 AC24A0E1 		mov	r2, ip, lsr #9
 1629 0d18 024262E0 		rsb	r4, r2, r2, asl #4
 1630 0d1c 8448A0E1 		mov	r4, r4, asl #17
 1631 0d20 2428A0E1 		mov	r2, r4, lsr #16
 1632              	.LVL118:
 701:../uvc.c      **** 		if(NumLn > 1944)
 1633              		.loc 1 701 0
 1634 0d24 0E0052E1 		cmp	r2, lr
 1635 0d28 0C00008A 		bhi	.L121
 703:../uvc.c      **** 		else if(NumLn < 8)
 1636              		.loc 1 703 0
 1637 0d2c 070052E3 		cmp	r2, #7
 1638 0d30 E5FFFF9A 		bls	.L122
 1639 0d34 A449A0E1 		mov	r4, r4, lsr #19
 1640 0d38 FF4004E2 		and	r4, r4, #255
 1641 0d3c 02E0A0E1 		mov	lr, r2
 1642 0d40 04C0A0E1 		mov	ip, r4
 1643 0d44 E3FFFFEA 		b	.L118
 1644              	.LVL119:
 1645              	.L112:
 727:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 1646              		.loc 1 727 0
 1647 0d48 0000A0E3 		mov	r0, #0
 1648              	.LVL120:
 728:../uvc.c      **** 		LnVal = 1;
 1649              		.loc 1 728 0
 1650 0d4c 0140A0E3 		mov	r4, #1
 727:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 1651              		.loc 1 727 0
 1652 0d50 0000C1E5 		strb	r0, [r1, #0]
 1653              	.LVL121:
 1654              	.L117:
 732:../uvc.c      **** }
 1655              		.loc 1 732 0
 1656 0d54 0400A0E1 		mov	r0, r4
 1657 0d58 08D08DE2 		add	sp, sp, #8
 1658 0d5c 1080BDE8 		ldmfd	sp!, {r4, pc}
 1659              	.LVL122:
 1660              	.L121:
 717:../uvc.c      **** 		if(NumLn > 1944)
 1661              		.loc 1 717 0
 1662 0d60 F3C0A0E3 		mov	ip, #243
 1663 0d64 0C40A0E1 		mov	r4, ip
 1664 0d68 DAFFFFEA 		b	.L118
 1665              	.LVL123:
 1666              	.L123:
 719:../uvc.c      **** 		else if(NumLn < 8)
 1667              		.loc 1 719 0
 1668 0d6c A2E9A0E1 		mov	lr, r2, lsr #19
 1669 0d70 FF400EE2 		and	r4, lr, #255
 1670 0d74 0CE0A0E1 		mov	lr, ip
 1671 0d78 04C0A0E1 		mov	ip, r4
 1672              	.LVL124:
 1673 0d7c D5FFFFEA 		b	.L118
 1674              	.L125:
 1675              		.align	2
 1676              	.L124:
 1677 0d80 00000000 		.word	.LANCHOR2
 1678 0d84 817F807F 		.word	2139127681
 1679 0d88 98070000 		.word	1944
 1680 0d8c 78020000 		.word	.LC16
 1681 0d90 01FF00FF 		.word	-16711935
 1682              		.cfi_endproc
 1683              	.LFE2:
 1685              		.align	2
 1686              		.global	ControlHandle
 1688              	ControlHandle:
 1689              	.LFB3:
 734:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1690              		.loc 1 734 0
 1691              		.cfi_startproc
 1692              		@ args = 0, pretend = 0, frame = 24
 1693              		@ frame_needed = 0, uses_anonymous_args = 0
 1694              	.LVL125:
 1695 0d94 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1696              	.LCFI15:
 1697              		.cfi_def_cfa_offset 36
 741:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1698              		.loc 1 741 0
 1699 0d98 230050E3 		cmp	r0, #35
 740:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1700              		.loc 1 740 0
 1701 0d9c 207040E2 		sub	r7, r0, #32
 1702              		.cfi_offset 14, -4
 1703              		.cfi_offset 11, -8
 1704              		.cfi_offset 10, -12
 1705              		.cfi_offset 9, -16
 1706              		.cfi_offset 8, -20
 1707              		.cfi_offset 7, -24
 1708              		.cfi_offset 6, -28
 1709              		.cfi_offset 5, -32
 1710              		.cfi_offset 4, -36
 734:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1711              		.loc 1 734 0
 1712 0da0 2CD04DE2 		sub	sp, sp, #44
 1713              	.LCFI16:
 1714              		.cfi_def_cfa_offset 80
 734:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1715              		.loc 1 734 0
 1716 0da4 0040A0E1 		mov	r4, r0
 740:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1717              		.loc 1 740 0
 1718 0da8 FF7007E2 		and	r7, r7, #255
 1719              	.LVL126:
 741:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1720              		.loc 1 741 0
 1721 0dac 2400009A 		bls	.L127
 742:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1722              		.loc 1 742 0
 1723 0db0 2C6F9FE5 		ldr	r6, .L264
 1724 0db4 872087E0 		add	r2, r7, r7, asl #1
 1725 0db8 8221A0E1 		mov	r2, r2, asl #3
 1726 0dbc 023086E0 		add	r3, r6, r2
 743:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1727              		.loc 1 743 0
 1728 0dc0 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 744:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1729              		.loc 1 744 0
 1730 0dc4 0F90D3E5 		ldrb	r9, [r3, #15]	@ zero_extendqisi2
 745:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1731              		.loc 1 745 0
 1732 0dc8 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 756:../uvc.c      ****     reqData = bRequest;
 1733              		.loc 1 756 0
 1734 0dcc 143F9FE5 		ldr	r3, .L264+4
 742:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1735              		.loc 1 742 0
 1736 0dd0 02A0D6E7 		ldrb	sl, [r6, r2]	@ zero_extendqisi2
 1737              	.LVL127:
 756:../uvc.c      ****     reqData = bRequest;
 1738              		.loc 1 756 0
 1739 0dd4 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1740              	.LVL128:
 764:../uvc.c      ****     switch (bRequest)
 1741              		.loc 1 764 0
 1742 0dd8 830055E3 		cmp	r5, #131
 1743 0ddc 2300000A 		beq	.L133
 1744              	.LVL129:
 1745              	.L256:
 1746 0de0 2C00009A 		bls	.L254
 1747 0de4 850055E3 		cmp	r5, #133
 1748 0de8 8B00000A 		beq	.L135
 1749 0dec 7900003A 		bcc	.L134
 1750 0df0 860055E3 		cmp	r5, #134
 1751 0df4 C800000A 		beq	.L136
 1752 0df8 870055E3 		cmp	r5, #135
 1753 0dfc BC00000A 		beq	.L255
 1754              	.L129:
1434:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1755              		.loc 1 1434 0
 1756 0e00 0000A0E3 		mov	r0, #0
 1757 0e04 0110A0E3 		mov	r1, #1
 1758 0e08 0020A0E1 		mov	r2, r0
 1759 0e0c FEFFFFEB 		bl	CyU3PUsbStall
1435:../uvc.c      **** 			  break;
 1760              		.loc 1 1435 0
 1761 0e10 FFC0A0E3 		mov	ip, #255
 1762 0e14 0C40A0E1 		mov	r4, ip
 1763 0e18 0C70A0E1 		mov	r7, ip
 1764              	.LVL130:
 1765 0e1c 0C80A0E1 		mov	r8, ip
 1766              	.LVL131:
 1767              	.L139:
1437:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1768              		.loc 1 1437 0
 1769 0e20 C41E9FE5 		ldr	r1, .L264+8
 1770 0e24 0520A0E1 		mov	r2, r5
 1771 0e28 0830A0E1 		mov	r3, r8
 1772 0e2c 0400A0E3 		mov	r0, #4
 1773 0e30 00708DE5 		str	r7, [sp, #0]
 1774 0e34 10108DE9 		stmib	sp, {r4, ip}	@ phole stm
 1775 0e38 FEFFFFEB 		bl	CyU3PDebugPrint
1438:../uvc.c      **** }
 1776              		.loc 1 1438 0
 1777 0e3c 2CD08DE2 		add	sp, sp, #44
 1778 0e40 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1779              	.LVL132:
 1780              	.L127:
 747:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1781              		.loc 1 747 0
 1782 0e44 986E9FE5 		ldr	r6, .L264
 756:../uvc.c      ****     reqData = bRequest;
 1783              		.loc 1 756 0
 1784 0e48 983E9FE5 		ldr	r3, .L264+4
 747:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1785              		.loc 1 747 0
 1786 0e4c 805080E0 		add	r5, r0, r0, asl #1
 1787 0e50 850186E0 		add	r0, r6, r5, asl #3
 1788              	.LVL133:
 756:../uvc.c      ****     reqData = bRequest;
 1789              		.loc 1 756 0
 1790 0e54 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 747:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1791              		.loc 1 747 0
 1792 0e58 80A1D0E5 		ldrb	sl, [r0, #384]	@ zero_extendqisi2
 1793              	.LVL134:
 764:../uvc.c      ****     switch (bRequest)
 1794              		.loc 1 764 0
 1795 0e5c 830055E3 		cmp	r5, #131
 748:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1796              		.loc 1 748 0
 1797 0e60 81B1D0E5 		ldrb	fp, [r0, #385]	@ zero_extendqisi2
 1798              	.LVL135:
 749:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1799              		.loc 1 749 0
 1800 0e64 8F91D0E5 		ldrb	r9, [r0, #399]	@ zero_extendqisi2
 1801              	.LVL136:
 750:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1802              		.loc 1 750 0
 1803 0e68 8281D0E5 		ldrb	r8, [r0, #386]	@ zero_extendqisi2
 1804              	.LVL137:
 764:../uvc.c      ****     switch (bRequest)
 1805              		.loc 1 764 0
 1806 0e6c DBFFFF1A 		bne	.L256
 1807              	.LVL138:
 1808              	.L133:
 929:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1809              		.loc 1 929 0
 1810 0e70 230054E3 		cmp	r4, #35
 1811 0e74 C600009A 		bls	.L167
 930:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1812              		.loc 1 930 0
 1813 0e78 872087E0 		add	r2, r7, r7, asl #1
 1814 0e7c 826186E0 		add	r6, r6, r2, asl #3
 1815 0e80 A4AE9FE5 		ldr	sl, .L264+72
 1816 0e84 05C0D6E5 		ldrb	ip, [r6, #5]	@ zero_extendqisi2
 931:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1817              		.loc 1 931 0
 1818 0e88 0670D6E5 		ldrb	r7, [r6, #6]	@ zero_extendqisi2
 1819              	.LVL139:
 930:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1820              		.loc 1 930 0
 1821 0e8c 5CC0CAE5 		strb	ip, [sl, #92]
 931:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1822              		.loc 1 931 0
 1823 0e90 5D70CAE5 		strb	r7, [sl, #93]
 1824 0e94 0B0000EA 		b	.L175
 1825              	.LVL140:
 1826              	.L254:
 764:../uvc.c      ****     switch (bRequest)
 1827              		.loc 1 764 0
 1828 0e98 810055E3 		cmp	r5, #129
 1829 0e9c 6A00000A 		beq	.L131
 1830 0ea0 1000009A 		bls	.L257
 910:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1831              		.loc 1 910 0
 1832 0ea4 230054E3 		cmp	r4, #35
 1833 0ea8 AD00009A 		bls	.L164
 911:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1834              		.loc 1 911 0
 1835 0eac 87A087E0 		add	sl, r7, r7, asl #1
 1836 0eb0 8A6186E0 		add	r6, r6, sl, asl #3
 1837 0eb4 03E0D6E5 		ldrb	lr, [r6, #3]	@ zero_extendqisi2
 1838 0eb8 6CAE9FE5 		ldr	sl, .L264+72
 912:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1839              		.loc 1 912 0
 1840 0ebc 0440D6E5 		ldrb	r4, [r6, #4]	@ zero_extendqisi2
 911:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1841              		.loc 1 911 0
 1842 0ec0 5CE0CAE5 		strb	lr, [sl, #92]
 912:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1843              		.loc 1 912 0
 1844 0ec4 5D40CAE5 		strb	r4, [sl, #93]
 1845              	.LVL141:
 1846              	.L175:
 987:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1847              		.loc 1 987 0
 1848 0ec8 0800A0E1 		mov	r0, r8
 1849 0ecc 1C1E9FE5 		ldr	r1, .L264+12
 1850 0ed0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1851              	.LVL142:
 989:../uvc.c      **** 			  break;
 1852              		.loc 1 989 0
 1853 0ed4 FFC0A0E3 		mov	ip, #255
 987:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1854              		.loc 1 987 0
 1855 0ed8 5C40DAE5 		ldrb	r4, [sl, #92]	@ zero_extendqisi2
 989:../uvc.c      **** 			  break;
 1856              		.loc 1 989 0
 1857 0edc 0C70A0E1 		mov	r7, ip
 1858 0ee0 0C80A0E1 		mov	r8, ip
 1859 0ee4 CDFFFFEA 		b	.L139
 1860              	.LVL143:
 1861              	.L257:
 764:../uvc.c      ****     switch (bRequest)
 1862              		.loc 1 764 0
 1863 0ee8 010055E3 		cmp	r5, #1
 1864 0eec C3FFFF1A 		bne	.L129
 991:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1865              		.loc 1 991 0
 1866 0ef0 341E9FE5 		ldr	r1, .L264+72
 1867 0ef4 26208DE2 		add	r2, sp, #38
 1868 0ef8 2000A0E3 		mov	r0, #32
 1869 0efc 5C1081E2 		add	r1, r1, #92
 1870 0f00 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1871              	.LVL144:
 993:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1872              		.loc 1 993 0
 1873 0f04 002050E2 		subs	r2, r0, #0
 1874 0f08 DB03001A 		bne	.L177
 995:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1875              		.loc 1 995 0
 1876 0f0c 183E9FE5 		ldr	r3, .L264+72
 996:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1877              		.loc 1 996 0
 1878 0f10 14CE9FE5 		ldr	ip, .L264+72
 998:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1879              		.loc 1 998 0
 1880 0f14 10EE9FE5 		ldr	lr, .L264+72
 995:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1881              		.loc 1 995 0
 1882 0f18 5C30D3E5 		ldrb	r3, [r3, #92]	@ zero_extendqisi2
 996:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1883              		.loc 1 996 0
 1884 0f1c 5DC0DCE5 		ldrb	ip, [ip, #93]	@ zero_extendqisi2
 998:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1885              		.loc 1 998 0
 1886 0f20 5E00DEE5 		ldrb	r0, [lr, #94]	@ zero_extendqisi2
 1887              	.LVL145:
 995:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1888              		.loc 1 995 0
 1889 0f24 14308DE5 		str	r3, [sp, #20]
 1890              	.LVL146:
 996:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1891              		.loc 1 996 0
 1892 0f28 1CC08DE5 		str	ip, [sp, #28]
 1893              	.LVL147:
 998:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1894              		.loc 1 998 0
 1895 0f2c 18008DE5 		str	r0, [sp, #24]
 1896              	.LVL148:
1002:../uvc.c      **** 				  switch(CtrlID)
 1897              		.loc 1 1002 0
 1898 0f30 260054E3 		cmp	r4, #38
 1899 0f34 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1900 0f38 2F0300EA 		b	.L178
 1901              	.L196:
 1902 0f3c 901B0000 		.word	.L179
 1903 0f40 281B0000 		.word	.L180
 1904 0f44 FC190000 		.word	.L181
 1905 0f48 FC1B0000 		.word	.L178
 1906 0f4c AC190000 		.word	.L182
 1907 0f50 6C180000 		.word	.L183
 1908 0f54 F0170000 		.word	.L184
 1909 0f58 301D0000 		.word	.L185
 1910 0f5c FC1B0000 		.word	.L178
 1911 0f60 FC1B0000 		.word	.L178
 1912 0f64 FC1B0000 		.word	.L178
 1913 0f68 601C0000 		.word	.L186
 1914 0f6c FC1B0000 		.word	.L178
 1915 0f70 FC1B0000 		.word	.L178
 1916 0f74 FC1B0000 		.word	.L178
 1917 0f78 FC1B0000 		.word	.L178
 1918 0f7c B01D0000 		.word	.L187
 1919 0f80 FC1B0000 		.word	.L178
 1920 0f84 FC1B0000 		.word	.L178
 1921 0f88 FC1B0000 		.word	.L178
 1922 0f8c FC1B0000 		.word	.L178
 1923 0f90 FC1B0000 		.word	.L178
 1924 0f94 FC1B0000 		.word	.L178
 1925 0f98 FC1B0000 		.word	.L178
 1926 0f9c FC1B0000 		.word	.L178
 1927 0fa0 581A0000 		.word	.L188
 1928 0fa4 FC190000 		.word	.L181
 1929 0fa8 5C170000 		.word	.L189
 1930 0fac D0160000 		.word	.L190
 1931 0fb0 FC1B0000 		.word	.L178
 1932 0fb4 74160000 		.word	.L191
 1933 0fb8 F0150000 		.word	.L192
 1934 0fbc FC1B0000 		.word	.L178
 1935 0fc0 FC1B0000 		.word	.L178
 1936 0fc4 FC1B0000 		.word	.L178
 1937 0fc8 FC1B0000 		.word	.L178
 1938 0fcc 54150000 		.word	.L193
 1939 0fd0 E0140000 		.word	.L194
 1940 0fd4 78140000 		.word	.L195
 1941              	.LVL149:
 1942              	.L134:
 947:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1943              		.loc 1 947 0
 1944 0fd8 230054E3 		cmp	r4, #35
 948:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1945              		.loc 1 948 0
 1946 0fdc 87708780 		addhi	r7, r7, r7, asl #1
 1947              	.LVL150:
 954:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1948              		.loc 1 954 0
 1949 0fe0 84408490 		addls	r4, r4, r4, asl #1
 948:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1950              		.loc 1 948 0
 1951 0fe4 87618680 		addhi	r6, r6, r7, asl #3
 954:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1952              		.loc 1 954 0
 1953 0fe8 84618690 		addls	r6, r6, r4, asl #3
 948:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1954              		.loc 1 948 0
 1955 0fec 38AD9F85 		ldrhi	sl, .L264+72
 954:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1956              		.loc 1 954 0
 1957 0ff0 34AD9F95 		ldrls	sl, .L264+72
 948:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1958              		.loc 1 948 0
 1959 0ff4 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 949:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1960              		.loc 1 949 0
 1961 0ff8 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 954:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1962              		.loc 1 954 0
 1963 0ffc 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 955:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1964              		.loc 1 955 0
 1965 1000 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 956:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1966              		.loc 1 956 0
 1967 1004 0030A0E3 		mov	r3, #0
 954:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1968              		.loc 1 954 0
 1969 1008 5C10CAE5 		strb	r1, [sl, #92]
 955:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1970              		.loc 1 955 0
 1971 100c 5D20CAE5 		strb	r2, [sl, #93]
 956:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1972              		.loc 1 956 0
 1973 1010 5E30CAE5 		strb	r3, [sl, #94]
 957:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1974              		.loc 1 957 0
 1975 1014 5F30CAE5 		strb	r3, [sl, #95]
 1976 1018 AAFFFFEA 		b	.L175
 1977              	.LVL151:
 1978              	.L135:
 768:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1979              		.loc 1 768 0
 1980 101c 084D9FE5 		ldr	r4, .L264+72
 770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1981              		.loc 1 770 0
 1982 1020 0200A0E3 		mov	r0, #2
 768:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1983              		.loc 1 768 0
 1984 1024 5C80C4E5 		strb	r8, [r4, #92]
 769:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1985              		.loc 1 769 0
 1986 1028 0080A0E3 		mov	r8, #0
 1987 102c 5D80C4E5 		strb	r8, [r4, #93]
 770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1988              		.loc 1 770 0
 1989 1030 5C1084E2 		add	r1, r4, #92
 1990 1034 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1991              	.LVL152:
 772:../uvc.c      **** 			  break;
 1992              		.loc 1 772 0
 1993 1038 FFC0A0E3 		mov	ip, #255
 770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1994              		.loc 1 770 0
 1995 103c 5C40D4E5 		ldrb	r4, [r4, #92]	@ zero_extendqisi2
 772:../uvc.c      **** 			  break;
 1996              		.loc 1 772 0
 1997 1040 0C70A0E1 		mov	r7, ip
 1998              	.LVL153:
 1999 1044 0C80A0E1 		mov	r8, ip
 2000 1048 74FFFFEA 		b	.L139
 2001              	.LVL154:
 2002              	.L131:
 775:../uvc.c      **** 			 switch(CtrlID)
 2003              		.loc 1 775 0
 2004 104c 260054E3 		cmp	r4, #38
 2005 1050 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2006 1054 D70000EA 		b	.L140
 2007              	.L152:
 2008 1058 8C130000 		.word	.L141
 2009 105c 60130000 		.word	.L142
 2010 1060 44130000 		.word	.L143
 2011 1064 B8130000 		.word	.L140
 2012 1068 B8130000 		.word	.L140
 2013 106c 24130000 		.word	.L144
 2014 1070 B8130000 		.word	.L140
 2015 1074 8C130000 		.word	.L141
 2016 1078 B8130000 		.word	.L140
 2017 107c B8130000 		.word	.L140
 2018 1080 B8130000 		.word	.L140
 2019 1084 BC120000 		.word	.L145
 2020 1088 B8130000 		.word	.L140
 2021 108c B8130000 		.word	.L140
 2022 1090 B8130000 		.word	.L140
 2023 1094 B8130000 		.word	.L140
 2024 1098 9C120000 		.word	.L146
 2025 109c B8130000 		.word	.L140
 2026 10a0 B8130000 		.word	.L140
 2027 10a4 B8130000 		.word	.L140
 2028 10a8 B8130000 		.word	.L140
 2029 10ac B8130000 		.word	.L140
 2030 10b0 B8130000 		.word	.L140
 2031 10b4 B8130000 		.word	.L140
 2032 10b8 B8130000 		.word	.L140
 2033 10bc E0120000 		.word	.L147
 2034 10c0 44130000 		.word	.L143
 2035 10c4 7C120000 		.word	.L148
 2036 10c8 54120000 		.word	.L149
 2037 10cc B8130000 		.word	.L140
 2038 10d0 B8130000 		.word	.L140
 2039 10d4 DC130000 		.word	.L150
 2040 10d8 B8130000 		.word	.L140
 2041 10dc B8130000 		.word	.L140
 2042 10e0 B8130000 		.word	.L140
 2043 10e4 B8130000 		.word	.L140
 2044 10e8 10120000 		.word	.L151
 2045 10ec 10120000 		.word	.L151
 2046 10f0 10120000 		.word	.L151
 2047              	.L255:
 974:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2048              		.loc 1 974 0
 2049 10f4 230054E3 		cmp	r4, #35
 2050 10f8 3100009A 		bls	.L174
 975:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2051              		.loc 1 975 0
 2052 10fc 874087E0 		add	r4, r7, r7, asl #1
 2053 1100 846186E0 		add	r6, r6, r4, asl #3
 2054 1104 20AC9FE5 		ldr	sl, .L264+72
 2055 1108 0B10D6E5 		ldrb	r1, [r6, #11]	@ zero_extendqisi2
 976:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2056              		.loc 1 976 0
 2057 110c 0C00D6E5 		ldrb	r0, [r6, #12]	@ zero_extendqisi2
 975:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2058              		.loc 1 975 0
 2059 1110 5C10CAE5 		strb	r1, [sl, #92]
 976:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2060              		.loc 1 976 0
 2061 1114 5D00CAE5 		strb	r0, [sl, #93]
 2062 1118 6AFFFFEA 		b	.L175
 2063              	.L136:
 963:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2064              		.loc 1 963 0
 2065 111c 230054E3 		cmp	r4, #35
 964:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2066              		.loc 1 964 0
 2067 1120 87708780 		addhi	r7, r7, r7, asl #1
 2068              	.LVL155:
 967:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2069              		.loc 1 967 0
 2070 1124 84408490 		addls	r4, r4, r4, asl #1
 964:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2071              		.loc 1 964 0
 2072 1128 87618680 		addhi	r6, r6, r7, asl #3
 967:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2073              		.loc 1 967 0
 2074 112c 84618690 		addls	r6, r6, r4, asl #3
 964:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2075              		.loc 1 964 0
 2076 1130 F48B9F85 		ldrhi	r8, .L264+72
 967:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2077              		.loc 1 967 0
 2078 1134 F08B9F95 		ldrls	r8, .L264+72
 964:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2079              		.loc 1 964 0
 2080 1138 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 967:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2081              		.loc 1 967 0
 2082 113c 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 969:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2083              		.loc 1 969 0
 2084 1140 0100A0E3 		mov	r0, #1
 967:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2085              		.loc 1 967 0
 2086 1144 5C30C8E5 		strb	r3, [r8, #92]
 969:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2087              		.loc 1 969 0
 2088 1148 A01B9FE5 		ldr	r1, .L264+12
 2089 114c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2090              	.LVL156:
 972:../uvc.c      **** 			  break;
 2091              		.loc 1 972 0
 2092 1150 FFC0A0E3 		mov	ip, #255
 969:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2093              		.loc 1 969 0
 2094 1154 5C40D8E5 		ldrb	r4, [r8, #92]	@ zero_extendqisi2
 972:../uvc.c      **** 			  break;
 2095              		.loc 1 972 0
 2096 1158 0C70A0E1 		mov	r7, ip
 2097 115c 0C80A0E1 		mov	r8, ip
 2098 1160 2EFFFFEA 		b	.L139
 2099              	.LVL157:
 2100              	.L164:
 915:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2101              		.loc 1 915 0
 2102 1164 0B0054E3 		cmp	r4, #11
 922:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2103              		.loc 1 922 0
 2104 1168 84408410 		addne	r4, r4, r4, asl #1
 2105 116c 84618610 		addne	r6, r6, r4, asl #3
 2106 1170 B4AB9F15 		ldrne	sl, .L264+72
 916:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2107              		.loc 1 916 0
 2108 1174 B0AB9F05 		ldreq	sl, .L264+72
 2109 1178 743B9F05 		ldreq	r3, .L264+16
 922:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2110              		.loc 1 922 0
 2111 117c 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 923:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2112              		.loc 1 923 0
 2113 1180 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 916:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2114              		.loc 1 916 0
 2115 1184 5C308A05 		streq	r3, [sl, #92]
 922:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2116              		.loc 1 922 0
 2117 1188 5C20CA15 		strneb	r2, [sl, #92]
 923:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2118              		.loc 1 923 0
 2119 118c 5D30CA15 		strneb	r3, [sl, #93]
 2120 1190 4CFFFFEA 		b	.L175
 2121              	.L167:
 933:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2122              		.loc 1 933 0
 2123 1194 0B0054E3 		cmp	r4, #11
 940:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2124              		.loc 1 940 0
 2125 1198 84408410 		addne	r4, r4, r4, asl #1
 2126 119c 84618610 		addne	r6, r6, r4, asl #3
 2127 11a0 84AB9F15 		ldrne	sl, .L264+72
 934:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2128              		.loc 1 934 0
 2129 11a4 80AB9F05 		ldreq	sl, .L264+72
 2130 11a8 483B9F05 		ldreq	r3, .L264+20
 940:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2131              		.loc 1 940 0
 2132 11ac 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 941:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2133              		.loc 1 941 0
 2134 11b0 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 934:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2135              		.loc 1 934 0
 2136 11b4 5C308A05 		streq	r3, [sl, #92]
 940:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2137              		.loc 1 940 0
 2138 11b8 5C20CA15 		strneb	r2, [sl, #92]
 941:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2139              		.loc 1 941 0
 2140 11bc 5D30CA15 		strneb	r3, [sl, #93]
 2141 11c0 40FFFFEA 		b	.L175
 2142              	.L174:
 978:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2143              		.loc 1 978 0
 2144 11c4 0B0054E3 		cmp	r4, #11
 2145 11c8 0700000A 		beq	.L258
 984:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2146              		.loc 1 984 0
 2147 11cc 84A084E0 		add	sl, r4, r4, asl #1
 2148 11d0 8A6186E0 		add	r6, r6, sl, asl #3
 2149 11d4 8B21D6E5 		ldrb	r2, [r6, #395]	@ zero_extendqisi2
 2150 11d8 4CAB9FE5 		ldr	sl, .L264+72
 985:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2151              		.loc 1 985 0
 2152 11dc 8C31D6E5 		ldrb	r3, [r6, #396]	@ zero_extendqisi2
 984:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2153              		.loc 1 984 0
 2154 11e0 5C20CAE5 		strb	r2, [sl, #92]
 985:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2155              		.loc 1 985 0
 2156 11e4 5D30CAE5 		strb	r3, [sl, #93]
 2157 11e8 36FFFFEA 		b	.L175
 2158              	.L258:
 979:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2159              		.loc 1 979 0
 2160 11ec 38AB9FE5 		ldr	sl, .L264+72
 2161 11f0 93C2D6E5 		ldrb	ip, [r6, #659]	@ zero_extendqisi2
 981:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2162              		.loc 1 981 0
 2163 11f4 9472D6E5 		ldrb	r7, [r6, #660]	@ zero_extendqisi2
 2164              	.LVL158:
 980:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2165              		.loc 1 980 0
 2166 11f8 00E0A0E3 		mov	lr, #0
 979:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2167              		.loc 1 979 0
 2168 11fc 5CC0CAE5 		strb	ip, [sl, #92]
 980:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2169              		.loc 1 980 0
 2170 1200 5DE0CAE5 		strb	lr, [sl, #93]
 981:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2171              		.loc 1 981 0
 2172 1204 5E70CAE5 		strb	r7, [sl, #94]
 982:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2173              		.loc 1 982 0
 2174 1208 5FE0CAE5 		strb	lr, [sl, #95]
 2175 120c 2DFFFFEA 		b	.L175
 2176              	.LVL159:
 2177              	.L151:
 783:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2178              		.loc 1 783 0
 2179 1210 E43A9FE5 		ldr	r3, .L264+24
 2180 1214 101B9FE5 		ldr	r1, .L264+72
 2181 1218 047183E0 		add	r7, r3, r4, asl #2
 2182              	.LVL160:
 2183 121c 20C017E5 		ldr	ip, [r7, #-32]
 2184 1220 0DE0DCE5 		ldrb	lr, [ip, #13]	@ zero_extendqisi2
 2185 1224 FF400EE2 		and	r4, lr, #255
 2186 1228 5C40C1E5 		strb	r4, [r1, #92]
 784:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2187              		.loc 1 784 0
 2188 122c 0E60DCE5 		ldrb	r6, [ip, #14]	@ zero_extendqisi2
 2189 1230 FF6006E2 		and	r6, r6, #255
 2190 1234 5D60C1E5 		strb	r6, [r1, #93]
 2191              	.LVL161:
 2192              	.L155:
 903:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2193              		.loc 1 903 0
 2194 1238 0800A0E1 		mov	r0, r8
 2195 123c AC1A9FE5 		ldr	r1, .L264+12
 2196 1240 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 908:../uvc.c      **** 			  break;
 2197              		.loc 1 908 0
 2198 1244 FF70A0E3 		mov	r7, #255
 903:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2199              		.loc 1 903 0
 2200 1248 06C0A0E1 		mov	ip, r6
 908:../uvc.c      **** 			  break;
 2201              		.loc 1 908 0
 2202 124c 0780A0E1 		mov	r8, r7
 2203 1250 F2FEFFEA 		b	.L139
 2204              	.LVL162:
 2205              	.L149:
 803:../uvc.c      **** 					 if(CamMode == 1){//720p
 2206              		.loc 1 803 0
 2207 1254 D07A9FE5 		ldr	r7, .L264+72
 2208              	.LVL163:
 802:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 2209              		.loc 1 802 0
 2210 1258 2D44D6E5 		ldrb	r4, [r6, #1069]	@ zero_extendqisi2
 2211              	.LVL164:
 803:../uvc.c      **** 					 if(CamMode == 1){//720p
 2212              		.loc 1 803 0
 2213 125c 7C20D7E5 		ldrb	r2, [r7, #124]	@ zero_extendqisi2
 2214 1260 010052E3 		cmp	r2, #1
 2215 1264 0C03000A 		beq	.L259
 2216              	.LVL165:
 2217              	.L156:
 813:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2218              		.loc 1 813 0
 2219 1268 0000A0E3 		mov	r0, #0
 812:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 2220              		.loc 1 812 0
 2221 126c 5C40C7E5 		strb	r4, [r7, #92]
 813:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2222              		.loc 1 813 0
 2223 1270 5D00C7E5 		strb	r0, [r7, #93]
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2224              		.loc 1 752 0
 2225 1274 FF60A0E3 		mov	r6, #255
 814:../uvc.c      **** 					 break;
 2226              		.loc 1 814 0
 2227 1278 EEFFFFEA 		b	.L155
 2228              	.LVL166:
 2229              	.L148:
 796:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2230              		.loc 1 796 0
 2231 127c B1E4D6E5 		ldrb	lr, [r6, #1201]	@ zero_extendqisi2
 2232 1280 A4CA9FE5 		ldr	ip, .L264+72
 798:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2233              		.loc 1 798 0
 2234 1284 B214D6E5 		ldrb	r1, [r6, #1202]	@ zero_extendqisi2
 796:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2235              		.loc 1 796 0
 2236 1288 FF400EE2 		and	r4, lr, #255
 2237 128c 5C40CCE5 		strb	r4, [ip, #92]
 798:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2238              		.loc 1 798 0
 2239 1290 5D10CCE5 		strb	r1, [ip, #93]
 2240              	.LVL167:
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2241              		.loc 1 752 0
 2242 1294 FF60A0E3 		mov	r6, #255
 800:../uvc.c      **** 			 		 break;
 2243              		.loc 1 800 0
 2244 1298 E6FFFFEA 		b	.L155
 2245              	.LVL168:
 2246              	.L146:
 790:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2247              		.loc 1 790 0
 2248 129c 9D44D6E5 		ldrb	r4, [r6, #1181]	@ zero_extendqisi2
 2249 12a0 840A9FE5 		ldr	r0, .L264+72
 792:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2250              		.loc 1 792 0
 2251 12a4 9E24D6E5 		ldrb	r2, [r6, #1182]	@ zero_extendqisi2
 790:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2252              		.loc 1 790 0
 2253 12a8 FF4004E2 		and	r4, r4, #255
 2254 12ac 5C40C0E5 		strb	r4, [r0, #92]
 792:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2255              		.loc 1 792 0
 2256 12b0 5D20C0E5 		strb	r2, [r0, #93]
 2257              	.LVL169:
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2258              		.loc 1 752 0
 2259 12b4 FF60A0E3 		mov	r6, #255
 794:../uvc.c      **** 			 		 break;
 2260              		.loc 1 794 0
 2261 12b8 DEFFFFEA 		b	.L155
 2262              	.LVL170:
 2263              	.L145:
 874:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2264              		.loc 1 874 0
 2265 12bc 683A9FE5 		ldr	r3, .L264+72
 2266 12c0 CC44D6E5 		ldrb	r4, [r6, #1228]	@ zero_extendqisi2
 876:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2267              		.loc 1 876 0
 2268 12c4 CE64D6E5 		ldrb	r6, [r6, #1230]	@ zero_extendqisi2
 875:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2269              		.loc 1 875 0
 2270 12c8 00C0A0E3 		mov	ip, #0
 874:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2271              		.loc 1 874 0
 2272 12cc 5C40C3E5 		strb	r4, [r3, #92]
 875:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2273              		.loc 1 875 0
 2274 12d0 5DC0C3E5 		strb	ip, [r3, #93]
 876:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2275              		.loc 1 876 0
 2276 12d4 5E60C3E5 		strb	r6, [r3, #94]
 877:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2277              		.loc 1 877 0
 2278 12d8 5FC0C3E5 		strb	ip, [r3, #95]
 2279              	.LVL171:
 880:../uvc.c      **** 					 break;
 2280              		.loc 1 880 0
 2281 12dc D5FFFFEA 		b	.L155
 2282              	.LVL172:
 2283              	.L147:
 832:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2284              		.loc 1 832 0
 2285 12e0 C524D6E5 		ldrb	r2, [r6, #1221]	@ zero_extendqisi2
 833:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2286              		.loc 1 833 0
 2287 12e4 C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
 832:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2288              		.loc 1 832 0
 2289 12e8 3CCA9FE5 		ldr	ip, .L264+72
 836:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2290              		.loc 1 836 0
 2291 12ec 0070A0E3 		mov	r7, #0
 2292              	.LVL173:
 833:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2293              		.loc 1 833 0
 2294 12f0 FF6003E2 		and	r6, r3, #255
 832:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2295              		.loc 1 832 0
 2296 12f4 FF4002E2 		and	r4, r2, #255
 2297 12f8 5C40CCE5 		strb	r4, [ip, #92]
 833:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2298              		.loc 1 833 0
 2299 12fc 5E60CCE5 		strb	r6, [ip, #94]
 836:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2300              		.loc 1 836 0
 2301 1300 5D70CCE5 		strb	r7, [ip, #93]
 838:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2302              		.loc 1 838 0
 2303 1304 5F70CCE5 		strb	r7, [ip, #95]
 2304              	.LVL174:
 841:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 2305              		.loc 1 841 0
 2306 1308 F0199FE5 		ldr	r1, .L264+28
 2307 130c 0420A0E1 		mov	r2, r4
 2308 1310 0730A0E1 		mov	r3, r7
 2309 1314 0400A0E3 		mov	r0, #4
 2310 1318 C0008DE8 		stmia	sp, {r6, r7}	@ phole stm
 2311 131c FEFFFFEB 		bl	CyU3PDebugPrint
 842:../uvc.c      **** 					 break;
 2312              		.loc 1 842 0
 2313 1320 C4FFFFEA 		b	.L155
 2314              	.LVL175:
 2315              	.L144:
 869:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2316              		.loc 1 869 0
 2317 1324 0572D6E5 		ldrb	r7, [r6, #517]	@ zero_extendqisi2
 2318              	.LVL176:
 2319 1328 FC699FE5 		ldr	r6, .L264+72
 2320 132c 804027E2 		eor	r4, r7, #128
 870:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2321              		.loc 1 870 0
 2322 1330 00E0A0E3 		mov	lr, #0
 869:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2323              		.loc 1 869 0
 2324 1334 5C40C6E5 		strb	r4, [r6, #92]
 870:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2325              		.loc 1 870 0
 2326 1338 5DE0C6E5 		strb	lr, [r6, #93]
 2327              	.LVL177:
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2328              		.loc 1 752 0
 2329 133c FF60A0E3 		mov	r6, #255
 872:../uvc.c      **** 					 break;
 2330              		.loc 1 872 0
 2331 1340 BCFFFFEA 		b	.L155
 2332              	.LVL178:
 2333              	.L143:
 891:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//SensorGetControl(RegAdd0, devAdd);
 2334              		.loc 1 891 0
 2335 1344 E0C99FE5 		ldr	ip, .L264+72
 2336 1348 BD41D6E5 		ldrb	r4, [r6, #445]	@ zero_extendqisi2
 892:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2337              		.loc 1 892 0
 2338 134c 0070A0E3 		mov	r7, #0
 2339              	.LVL179:
 891:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//SensorGetControl(RegAdd0, devAdd);
 2340              		.loc 1 891 0
 2341 1350 5C40CCE5 		strb	r4, [ip, #92]
 892:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2342              		.loc 1 892 0
 2343 1354 5D70CCE5 		strb	r7, [ip, #93]
 2344              	.LVL180:
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2345              		.loc 1 752 0
 2346 1358 FF60A0E3 		mov	r6, #255
 894:../uvc.c      **** 					 break;
 2347              		.loc 1 894 0
 2348 135c B5FFFFEA 		b	.L155
 2349              	.LVL181:
 2350              	.L142:
 857:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 2351              		.loc 1 857 0
 2352 1360 A541D6E5 		ldrb	r4, [r6, #421]	@ zero_extendqisi2
 2353              	.LVL182:
 863:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 2354              		.loc 1 863 0
 2355 1364 C0199FE5 		ldr	r1, .L264+72
 858:../uvc.c      **** 					  if(Data0&0x80){
 2356              		.loc 1 858 0
 2357 1368 800014E3 		tst	r4, #128
 859:../uvc.c      **** 						  Data0 = ~Data0;
 2358              		.loc 1 859 0
 2359 136c 0440E011 		mvnne	r4, r4
 2360              	.LVL183:
 861:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 2361              		.loc 1 861 0
 2362 1370 80404402 		subeq	r4, r4, #128
 2363 1374 FF4004E2 		and	r4, r4, #255
 2364              	.LVL184:
 864:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2365              		.loc 1 864 0
 2366 1378 0000A0E3 		mov	r0, #0
 863:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 2367              		.loc 1 863 0
 2368 137c 5C40C1E5 		strb	r4, [r1, #92]
 864:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2369              		.loc 1 864 0
 2370 1380 5D00C1E5 		strb	r0, [r1, #93]
 2371              	.LVL185:
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2372              		.loc 1 752 0
 2373 1384 FF60A0E3 		mov	r6, #255
 866:../uvc.c      **** 			 		 break;
 2374              		.loc 1 866 0
 2375 1388 AAFFFFEA 		b	.L155
 2376              	.LVL186:
 2377              	.L141:
 883:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;
 2378              		.loc 1 883 0
 2379 138c 68699FE5 		ldr	r6, .L264+24
 2380 1390 94099FE5 		ldr	r0, .L264+72
 2381 1394 04E186E0 		add	lr, r6, r4, asl #2
 2382 1398 A0109EE5 		ldr	r1, [lr, #160]
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2383              		.loc 1 752 0
 2384 139c FF60A0E3 		mov	r6, #255
 883:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;
 2385              		.loc 1 883 0
 2386 13a0 0D40D1E5 		ldrb	r4, [r1, #13]	@ zero_extendqisi2
 2387 13a4 064004E0 		and	r4, r4, r6
 2388 13a8 5C40C0E5 		strb	r4, [r0, #92]
 885:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2389              		.loc 1 885 0
 2390 13ac 0E20D1E5 		ldrb	r2, [r1, #14]	@ zero_extendqisi2
 2391 13b0 5D20C0E5 		strb	r2, [r0, #93]
 2392              	.LVL187:
 887:../uvc.c      **** 					 break;
 2393              		.loc 1 887 0
 2394 13b4 9FFFFFEA 		b	.L155
 2395              	.LVL188:
 2396              	.L140:
 897:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2397              		.loc 1 897 0
 2398 13b8 841084E0 		add	r1, r4, r4, asl #1
 2399 13bc 810186E0 		add	r0, r6, r1, asl #3
 2400 13c0 64399FE5 		ldr	r3, .L264+72
 2401 13c4 8D41D0E5 		ldrb	r4, [r0, #397]	@ zero_extendqisi2
 898:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2402              		.loc 1 898 0
 2403 13c8 0020A0E3 		mov	r2, #0
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2404              		.loc 1 752 0
 2405 13cc FF60A0E3 		mov	r6, #255
 897:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2406              		.loc 1 897 0
 2407 13d0 5C40C3E5 		strb	r4, [r3, #92]
 898:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2408              		.loc 1 898 0
 2409 13d4 5D20C3E5 		strb	r2, [r3, #93]
 2410              	.LVL189:
 900:../uvc.c      **** 					 break;
 2411              		.loc 1 900 0
 2412 13d8 96FFFFEA 		b	.L155
 2413              	.LVL190:
 2414              	.L150:
 816:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2415              		.loc 1 816 0 discriminator 1
 2416 13dc 000058E3 		cmp	r8, #0
 2417 13e0 5903000A 		beq	.L251
 814:../uvc.c      **** 					 break;
 2418              		.loc 1 814 0
 2419 13e4 28E1A0E1 		mov	lr, r8, lsr #2
 2420 13e8 00005EE3 		cmp	lr, #0
 2421 13ec 03005813 		cmpne	r8, #3
 2422 13f0 0020A083 		movhi	r2, #0
 2423 13f4 0120A093 		movls	r2, #1
 734:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2424              		.loc 1 734 0
 2425 13f8 0E31A0E1 		mov	r3, lr, asl #2
 814:../uvc.c      **** 					 break;
 2426              		.loc 1 814 0
 2427 13fc 5603009A 		bls	.L231
 2428 1400 E8189FE5 		ldr	r1, .L264+12
 2429 1404 100041E2 		sub	r0, r1, #16
 2430              	.LVL191:
 2431              	.L159:
 817:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2432              		.loc 1 817 0 discriminator 2
 2433 1408 047090E4 		ldr	r7, [r0], #4
 2434 140c 014082E2 		add	r4, r2, #1
 2435 1410 FF2004E2 		and	r2, r4, #255
 2436 1414 0E0052E1 		cmp	r2, lr
 2437 1418 047081E4 		str	r7, [r1], #4
 2438 141c F9FFFF3A 		bcc	.L159
 817:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2439              		.loc 1 817 0 is_stmt 0
 2440 1420 030058E1 		cmp	r8, r3
 2441 1424 00099F15 		ldrne	r0, .L264+72
 2442 1428 4703000A 		beq	.L251
 2443              	.L244:
 2444 142c 03C080E0 		add	ip, r0, r3
 2445 1430 4C10DCE5 		ldrb	r1, [ip, #76]	@ zero_extendqisi2
 816:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2446              		.loc 1 816 0 is_stmt 1
 2447 1434 01E083E2 		add	lr, r3, #1
 2448 1438 FF300EE2 		and	r3, lr, #255
 2449              	.LVL192:
 2450 143c 030058E1 		cmp	r8, r3
 817:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2451              		.loc 1 817 0
 2452 1440 5C10CCE5 		strb	r1, [ip, #92]
 816:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2453              		.loc 1 816 0
 2454 1444 F8FFFF8A 		bhi	.L244
 2455              	.LVL193:
 2456              	.L154:
 826:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2457              		.loc 1 826 0
 2458 1448 5760D0E5 		ldrb	r6, [r0, #87]	@ zero_extendqisi2
 819:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2459              		.loc 1 819 0
 2460 144c D8389FE5 		ldr	r3, .L264+72
 826:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2461              		.loc 1 826 0
 2462 1450 FF0056E3 		cmp	r6, #255
 819:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2463              		.loc 1 819 0
 2464 1454 6540D0E5 		ldrb	r4, [r0, #101]	@ zero_extendqisi2
 2465              	.LVL194:
 820:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 2466              		.loc 1 820 0
 2467 1458 6660D0E5 		ldrb	r6, [r0, #102]	@ zero_extendqisi2
 2468              	.LVL195:
 826:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2469              		.loc 1 826 0
 2470 145c 75FFFF0A 		beq	.L155
 828:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 2471              		.loc 1 828 0
 2472 1460 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 2473 1464 98189FE5 		ldr	r1, .L264+32
 2474 1468 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 2475 146c 0400A0E3 		mov	r0, #4
 2476 1470 FEFFFFEB 		bl	CyU3PDebugPrint
 2477 1474 6FFFFFEA 		b	.L155
 2478              	.LVL196:
 2479              	.L195:
1215:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2480              		.loc 1 1215 0
 2481 1478 A8489FE5 		ldr	r4, .L264+68
 2482 147c 0010E0E3 		mvn	r1, #0
 2483 1480 1C0094E5 		ldr	r0, [r4, #28]
 2484 1484 FEFFFFEB 		bl	_txe_mutex_get
 2485              	.LVL197:
1216:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2486              		.loc 1 1216 0
 2487 1488 14C09DE5 		ldr	ip, [sp, #20]
 2488 148c 2610A0E3 		mov	r1, #38
 2489 1490 0930A0E1 		mov	r3, r9
 2490 1494 0A20A0E1 		mov	r2, sl
 2491 1498 0400A0E1 		mov	r0, r4
 2492 149c 0080A0E3 		mov	r8, #0
 2493 14a0 00C08DE5 		str	ip, [sp, #0]
 2494 14a4 04808DE5 		str	r8, [sp, #4]
 2495 14a8 FEFFFFEB 		bl	cmdSet
1217:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2496              		.loc 1 1217 0
 2497 14ac 1C0094E5 		ldr	r0, [r4, #28]
 2498 14b0 FEFFFFEB 		bl	_txe_mutex_put
1218:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2499              		.loc 1 1218 0
 2500 14b4 14109DE5 		ldr	r1, [sp, #20]
 2501 14b8 873087E0 		add	r3, r7, r7, asl #1
 2502 14bc 836186E0 		add	r6, r6, r3, asl #3
1220:../uvc.c      **** 							 break;
 2503              		.loc 1 1220 0
 2504 14c0 FFC0A0E3 		mov	ip, #255
1219:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2505              		.loc 1 1219 0
 2506 14c4 0100A0E3 		mov	r0, #1
1218:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2507              		.loc 1 1218 0
 2508 14c8 0D10C6E5 		strb	r1, [r6, #13]
1219:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2509              		.loc 1 1219 0
 2510 14cc 1000C6E5 		strb	r0, [r6, #16]
 2511 14d0 0180A0E1 		mov	r8, r1
 2512 14d4 18709DE5 		ldr	r7, [sp, #24]
 2513              	.LVL198:
1220:../uvc.c      **** 							 break;
 2514              		.loc 1 1220 0
 2515 14d8 0C40A0E1 		mov	r4, ip
 2516 14dc 4FFEFFEA 		b	.L139
 2517              	.LVL199:
 2518              	.L194:
1200:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2519              		.loc 1 1200 0
 2520 14e0 E424D6E5 		ldrb	r2, [r6, #1252]	@ zero_extendqisi2
 2521              	.LVL200:
1205:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2522              		.loc 1 1205 0
 2523 14e4 3C489FE5 		ldr	r4, .L264+68
1201:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
 2524              		.loc 1 1201 0
 2525 14e8 E534D6E5 		ldrb	r3, [r6, #1253]	@ zero_extendqisi2
1202:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
 2526              		.loc 1 1202 0
 2527 14ec F3C4D6E5 		ldrb	ip, [r6, #1267]	@ zero_extendqisi2
1200:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2528              		.loc 1 1200 0
 2529 14f0 FF8002E2 		and	r8, r2, #255
 2530              	.LVL201:
1205:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2531              		.loc 1 1205 0
 2532 14f4 0010E0E3 		mvn	r1, #0
 2533 14f8 1C0094E5 		ldr	r0, [r4, #28]
1202:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
 2534              		.loc 1 1202 0
 2535 14fc FF700CE2 		and	r7, ip, #255
 2536              	.LVL202:
1205:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2537              		.loc 1 1205 0
 2538 1500 FEFFFFEB 		bl	_txe_mutex_get
1206:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2539              		.loc 1 1206 0
 2540 1504 0820A0E1 		mov	r2, r8
 2541 1508 14809DE5 		ldr	r8, [sp, #20]
 2542              	.LVL203:
 2543 150c 0730A0E1 		mov	r3, r7
 2544 1510 2510A0E3 		mov	r1, #37
 2545 1514 0400A0E1 		mov	r0, r4
 2546 1518 0070A0E3 		mov	r7, #0
 2547              	.LVL204:
 2548 151c 00808DE5 		str	r8, [sp, #0]
 2549 1520 04708DE5 		str	r7, [sp, #4]
 2550 1524 FEFFFFEB 		bl	cmdSet
 2551              	.LVL205:
1207:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2552              		.loc 1 1207 0
 2553 1528 1C0094E5 		ldr	r0, [r4, #28]
 2554 152c FEFFFFEB 		bl	_txe_mutex_put
1208:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
 2555              		.loc 1 1208 0
 2556 1530 14309DE5 		ldr	r3, [sp, #20]
1212:../uvc.c      **** 							 break;
 2557              		.loc 1 1212 0
 2558 1534 FFC0A0E3 		mov	ip, #255
1209:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 2559              		.loc 1 1209 0
 2560 1538 0100A0E3 		mov	r0, #1
1208:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
 2561              		.loc 1 1208 0
 2562 153c F134C6E5 		strb	r3, [r6, #1265]
1209:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 2563              		.loc 1 1209 0
 2564 1540 0380A0E1 		mov	r8, r3
 2565 1544 F504C6E5 		strb	r0, [r6, #1269]
 2566 1548 18709DE5 		ldr	r7, [sp, #24]
1212:../uvc.c      **** 							 break;
 2567              		.loc 1 1212 0
 2568 154c 0C40A0E1 		mov	r4, ip
 2569 1550 32FEFFEA 		b	.L139
 2570              	.LVL206:
 2571              	.L193:
1160:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2572              		.loc 1 1160 0
 2573 1554 D0E4D6E5 		ldrb	lr, [r6, #1232]	@ zero_extendqisi2
1187:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2574              		.loc 1 1187 0
 2575 1558 C8479FE5 		ldr	r4, .L264+68
1161:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 2576              		.loc 1 1161 0
 2577 155c D124D6E5 		ldrb	r2, [r6, #1233]	@ zero_extendqisi2
 2578              	.LVL207:
1162:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 2579              		.loc 1 1162 0
 2580 1560 DF14D6E5 		ldrb	r1, [r6, #1247]	@ zero_extendqisi2
1187:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2581              		.loc 1 1187 0
 2582 1564 1C0094E5 		ldr	r0, [r4, #28]
1162:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 2583              		.loc 1 1162 0
 2584 1568 FF7001E2 		and	r7, r1, #255
 2585              	.LVL208:
1187:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2586              		.loc 1 1187 0
 2587 156c 0010E0E3 		mvn	r1, #0
1160:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2588              		.loc 1 1160 0
 2589 1570 FFA00EE2 		and	sl, lr, #255
 2590              	.LVL209:
1161:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 2591              		.loc 1 1161 0
 2592 1574 FF8002E2 		and	r8, r2, #255
 2593              	.LVL210:
1187:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2594              		.loc 1 1187 0
 2595 1578 FEFFFFEB 		bl	_txe_mutex_get
1189:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2596              		.loc 1 1189 0
 2597 157c 14C09DE5 		ldr	ip, [sp, #20]
 2598 1580 0A20A0E1 		mov	r2, sl
 2599 1584 0730A0E1 		mov	r3, r7
 2600 1588 2410A0E3 		mov	r1, #36
 2601 158c 0400A0E1 		mov	r0, r4
 2602 1590 00C08DE5 		str	ip, [sp, #0]
 2603 1594 00C0A0E3 		mov	ip, #0
 2604 1598 04C08DE5 		str	ip, [sp, #4]
 2605 159c FEFFFFEB 		bl	cmdSet
 2606              	.LVL211:
1191:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2607              		.loc 1 1191 0
 2608 15a0 1CC09DE5 		ldr	ip, [sp, #28]
 2609 15a4 0730A0E1 		mov	r3, r7
 2610 15a8 0820A0E1 		mov	r2, r8
 2611 15ac 01A0A0E3 		mov	sl, #1
 2612              	.LVL212:
 2613 15b0 2410A0E3 		mov	r1, #36
 2614 15b4 0400A0E1 		mov	r0, r4
 2615 15b8 00C08DE5 		str	ip, [sp, #0]
 2616 15bc 04A08DE5 		str	sl, [sp, #4]
 2617 15c0 FEFFFFEB 		bl	cmdSet
1192:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2618              		.loc 1 1192 0
 2619 15c4 1C0094E5 		ldr	r0, [r4, #28]
 2620 15c8 FEFFFFEB 		bl	_txe_mutex_put
 2621              	.LVL213:
1196:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 2622              		.loc 1 1196 0
 2623 15cc 1C309DE5 		ldr	r3, [sp, #28]
1195:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
 2624              		.loc 1 1195 0
 2625 15d0 14809DE5 		ldr	r8, [sp, #20]
 2626              	.LVL214:
1198:../uvc.c      **** 							 break;
 2627              		.loc 1 1198 0
 2628 15d4 FFC0A0E3 		mov	ip, #255
1195:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
 2629              		.loc 1 1195 0
 2630 15d8 DD84C6E5 		strb	r8, [r6, #1245]
1197:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2631              		.loc 1 1197 0
 2632 15dc 0370A0E1 		mov	r7, r3
 2633              	.LVL215:
1196:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 2634              		.loc 1 1196 0
 2635 15e0 DE34C6E5 		strb	r3, [r6, #1246]
1198:../uvc.c      **** 							 break;
 2636              		.loc 1 1198 0
 2637 15e4 0C40A0E1 		mov	r4, ip
1197:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2638              		.loc 1 1197 0
 2639 15e8 E1A4C6E5 		strb	sl, [r6, #1249]
1198:../uvc.c      **** 							 break;
 2640              		.loc 1 1198 0
 2641 15ec 0BFEFFEA 		b	.L139
 2642              	.LVL216:
 2643              	.L192:
1154:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2644              		.loc 1 1154 0 discriminator 1
 2645 15f0 000058E3 		cmp	r8, #0
 2646 15f4 1800000A 		beq	.L198
1152:../uvc.c      **** 							 break;
 2647              		.loc 1 1152 0
 2648 15f8 28E1A0E1 		mov	lr, r8, lsr #2
 2649 15fc 00005EE3 		cmp	lr, #0
 2650 1600 03005813 		cmpne	r8, #3
 2651 1604 0020A083 		movhi	r2, #0
 2652 1608 0120A093 		movls	r2, #1
 2653              	.LVL217:
 734:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2654              		.loc 1 734 0
 2655 160c 0E31A0E1 		mov	r3, lr, asl #2
1152:../uvc.c      **** 							 break;
 2656              		.loc 1 1152 0
 2657 1610 CF02009A 		bls	.L233
 2658 1614 EC169FE5 		ldr	r1, .L264+36
 2659 1618 100081E2 		add	r0, r1, #16
 2660              	.LVL218:
 2661              	.L208:
1155:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2662              		.loc 1 1155 0 discriminator 2
 2663 161c 044090E4 		ldr	r4, [r0], #4
 2664 1620 012082E2 		add	r2, r2, #1
 2665 1624 FF2002E2 		and	r2, r2, #255
 2666 1628 02005EE1 		cmp	lr, r2
 2667 162c 044081E4 		str	r4, [r1], #4
 2668 1630 F9FFFF8A 		bhi	.L208
1155:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2669              		.loc 1 1155 0 is_stmt 0
 2670 1634 030058E1 		cmp	r8, r3
 2671 1638 0700000A 		beq	.L198
 2672              	.LVL219:
 2673              	.L245:
 2674 163c E8769FE5 		ldr	r7, .L264+72
1154:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2675              		.loc 1 1154 0 is_stmt 1
 2676 1640 010083E2 		add	r0, r3, #1
1155:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2677              		.loc 1 1155 0
 2678 1644 03E087E0 		add	lr, r7, r3
 2679 1648 5C10DEE5 		ldrb	r1, [lr, #92]	@ zero_extendqisi2
1154:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2680              		.loc 1 1154 0
 2681 164c FF3000E2 		and	r3, r0, #255
 2682              	.LVL220:
 2683 1650 030058E1 		cmp	r8, r3
1155:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2684              		.loc 1 1155 0
 2685 1654 4C10CEE5 		strb	r1, [lr, #76]
1154:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2686              		.loc 1 1154 0
 2687 1658 F7FFFF8A 		bhi	.L245
 2688              	.LVL221:
 2689              	.L198:
1157:../uvc.c      **** 					 		I2CCmdHandler();
 2690              		.loc 1 1157 0
 2691 165c FEFFFFEB 		bl	I2CCmdHandler
1158:../uvc.c      **** 							 break;
 2692              		.loc 1 1158 0
 2693 1660 FFC0A0E3 		mov	ip, #255
1157:../uvc.c      **** 					 		I2CCmdHandler();
 2694              		.loc 1 1157 0
 2695 1664 14809DE5 		ldr	r8, [sp, #20]
 2696 1668 18709DE5 		ldr	r7, [sp, #24]
1158:../uvc.c      **** 							 break;
 2697              		.loc 1 1158 0
 2698 166c 0C40A0E1 		mov	r4, ip
 2699 1670 EAFDFFEA 		b	.L139
 2700              	.LVL222:
 2701              	.L191:
1148:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2702              		.loc 1 1148 0
 2703 1674 AC469FE5 		ldr	r4, .L264+68
 2704 1678 0010E0E3 		mvn	r1, #0
 2705 167c 1C0094E5 		ldr	r0, [r4, #28]
 2706 1680 FEFFFFEB 		bl	_txe_mutex_get
 2707              	.LVL223:
1149:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2708              		.loc 1 1149 0
 2709 1684 14C09DE5 		ldr	ip, [sp, #20]
 2710 1688 0930A0E1 		mov	r3, r9
 2711 168c 01707CE2 		rsbs	r7, ip, #1
 2712              	.LVL224:
 2713 1690 0070A033 		movcc	r7, #0
 2714 1694 1E10A0E3 		mov	r1, #30
 2715 1698 0A20A0E1 		mov	r2, sl
 2716 169c 0400A0E1 		mov	r0, r4
 2717 16a0 0080A0E3 		mov	r8, #0
 2718 16a4 80018DE8 		stmia	sp, {r7, r8}	@ phole stm
 2719 16a8 FEFFFFEB 		bl	cmdSet
1150:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2720              		.loc 1 1150 0
 2721 16ac 1C0094E5 		ldr	r0, [r4, #28]
 2722 16b0 FEFFFFEB 		bl	_txe_mutex_put
1152:../uvc.c      **** 							 break;
 2723              		.loc 1 1152 0
 2724 16b4 FFC0A0E3 		mov	ip, #255
1151:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2725              		.loc 1 1151 0
 2726 16b8 0130A0E3 		mov	r3, #1
 2727 16bc 6034C6E5 		strb	r3, [r6, #1120]
 2728 16c0 14809DE5 		ldr	r8, [sp, #20]
 2729 16c4 18709DE5 		ldr	r7, [sp, #24]
1152:../uvc.c      **** 							 break;
 2730              		.loc 1 1152 0
 2731 16c8 0C40A0E1 		mov	r4, ip
 2732 16cc D3FDFFEA 		b	.L139
 2733              	.LVL225:
 2734              	.L190:
1126:../uvc.c      **** 							 if(Data0 <= 3){
 2735              		.loc 1 1126 0
 2736 16d0 030053E3 		cmp	r3, #3
1127:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2737              		.loc 1 1127 0
 2738 16d4 50169F95 		ldrls	r1, .L264+72
1130:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2739              		.loc 1 1130 0
 2740 16d8 4CC69F85 		ldrhi	ip, .L264+72
1136:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2741              		.loc 1 1136 0
 2742 16dc 44869FE5 		ldr	r8, .L264+68
1133:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2743              		.loc 1 1133 0
 2744 16e0 14E09DE5 		ldr	lr, [sp, #20]
 2745 16e4 0300A0E1 		mov	r0, r3
 2746              	.LVL226:
1130:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2747              		.loc 1 1130 0
 2748 16e8 0120A083 		movhi	r2, #1
 2749              	.LVL227:
1127:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2750              		.loc 1 1127 0
 2751 16ec 0030A093 		movls	r3, #0
 2752 16f0 7C30C195 		strlsb	r3, [r1, #124]
 2753              	.LVL228:
1131:../uvc.c      **** 								 Data1 = Data0-4;
 2754              		.loc 1 1131 0
 2755 16f4 04304382 		subhi	r3, r3, #4
1127:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2756              		.loc 1 1127 0
 2757 16f8 0030A091 		movls	r3, r0
1130:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2758              		.loc 1 1130 0
 2759 16fc 7C20CC85 		strhib	r2, [ip, #124]
 2760              	.LVL229:
1135:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2761              		.loc 1 1135 0
 2762 1700 0120A0E3 		mov	r2, #1
1136:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2763              		.loc 1 1136 0
 2764 1704 0010E0E3 		mvn	r1, #0
1133:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2765              		.loc 1 1133 0
 2766 1708 2DE4C6E5 		strb	lr, [r6, #1069]
1134:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 2767              		.loc 1 1134 0
 2768 170c 8D31C6E5 		strb	r3, [r6, #397]
1135:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2769              		.loc 1 1135 0
 2770 1710 3024C6E5 		strb	r2, [r6, #1072]
1136:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2771              		.loc 1 1136 0
 2772 1714 1C0098E5 		ldr	r0, [r8, #28]
 2773 1718 FEFFFFEB 		bl	_txe_mutex_get
 2774              	.LVL230:
1137:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2775              		.loc 1 1137 0
 2776 171c 14C09DE5 		ldr	ip, [sp, #20]
 2777 1720 1C10A0E3 		mov	r1, #28
 2778 1724 0A20A0E1 		mov	r2, sl
 2779 1728 0930A0E1 		mov	r3, r9
 2780 172c 0800A0E1 		mov	r0, r8
 2781 1730 0070A0E3 		mov	r7, #0
 2782              	.LVL231:
 2783 1734 00C08DE5 		str	ip, [sp, #0]
 2784 1738 04708DE5 		str	r7, [sp, #4]
 2785 173c FEFFFFEB 		bl	cmdSet
1138:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2786              		.loc 1 1138 0
 2787 1740 1C0098E5 		ldr	r0, [r8, #28]
 2788              	.LVL232:
 2789              	.L253:
1394:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2790              		.loc 1 1394 0
 2791 1744 FEFFFFEB 		bl	_txe_mutex_put
 2792 1748 FFC0A0E3 		mov	ip, #255
 2793 174c 14809DE5 		ldr	r8, [sp, #20]
 2794 1750 18709DE5 		ldr	r7, [sp, #24]
 2795 1754 0C40A0E1 		mov	r4, ip
 2796 1758 B0FDFFEA 		b	.L139
 2797              	.LVL233:
 2798              	.L189:
1103:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2799              		.loc 1 1103 0
 2800 175c C4459FE5 		ldr	r4, .L264+68
1099:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2801              		.loc 1 1099 0
 2802 1760 A4A4D6E5 		ldrb	sl, [r6, #1188]	@ zero_extendqisi2
1100:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 2803              		.loc 1 1100 0
 2804 1764 A584D6E5 		ldrb	r8, [r6, #1189]	@ zero_extendqisi2
1101:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 2805              		.loc 1 1101 0
 2806 1768 B334D6E5 		ldrb	r3, [r6, #1203]	@ zero_extendqisi2
1103:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2807              		.loc 1 1103 0
 2808 176c 1C0094E5 		ldr	r0, [r4, #28]
 2809 1770 0010E0E3 		mvn	r1, #0
1101:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 2810              		.loc 1 1101 0
 2811 1774 FF7003E2 		and	r7, r3, #255
 2812              	.LVL234:
1103:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2813              		.loc 1 1103 0
 2814 1778 FEFFFFEB 		bl	_txe_mutex_get
 2815              	.LVL235:
1111:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 2816              		.loc 1 1111 0
 2817 177c B124D6E5 		ldrb	r2, [r6, #1201]	@ zero_extendqisi2
 2818 1780 14009DE5 		ldr	r0, [sp, #20]
1099:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2819              		.loc 1 1099 0
 2820 1784 FFA00AE2 		and	sl, sl, #255
 2821              	.LVL236:
1111:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 2822              		.loc 1 1111 0
 2823 1788 020050E1 		cmp	r0, r2
1100:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 2824              		.loc 1 1100 0
 2825 178c FF8008E2 		and	r8, r8, #255
 2826              	.LVL237:
1099:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2827              		.loc 1 1099 0
 2828 1790 4C359FE5 		ldr	r3, .L264
1111:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 2829              		.loc 1 1111 0
 2830 1794 0600000A 		beq	.L203
1112:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 2831              		.loc 1 1112 0
 2832 1798 B104C3E5 		strb	r0, [r3, #1201]
1113:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 2833              		.loc 1 1113 0
 2834 179c C504D3E5 		ldrb	r0, [r3, #1221]	@ zero_extendqisi2
 2835 17a0 010050E3 		cmp	r0, #1
 2836 17a4 4402000A 		beq	.L204
1113:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 2837              		.loc 1 1113 0 is_stmt 0 discriminator 1
 2838 17a8 C514D3E5 		ldrb	r1, [r3, #1221]	@ zero_extendqisi2
 2839 17ac 030051E3 		cmp	r1, #3
 2840 17b0 4102000A 		beq	.L204
 2841              	.LVL238:
 2842              	.L203:
1120:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2843              		.loc 1 1120 0 is_stmt 1
 2844 17b4 1C0094E5 		ldr	r0, [r4, #28]
 2845 17b8 FEFFFFEB 		bl	_txe_mutex_put
1122:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 2846              		.loc 1 1122 0
 2847 17bc C524D6E5 		ldrb	r2, [r6, #1221]	@ zero_extendqisi2
1121:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 2848              		.loc 1 1121 0
 2849 17c0 14809DE5 		ldr	r8, [sp, #20]
 2850              	.LVL239:
1122:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 2851              		.loc 1 1122 0
 2852 17c4 C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
1121:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 2853              		.loc 1 1121 0
 2854 17c8 18709DE5 		ldr	r7, [sp, #24]
1122:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 2855              		.loc 1 1122 0
 2856 17cc B144D6E5 		ldrb	r4, [r6, #1201]	@ zero_extendqisi2
1121:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 2857              		.loc 1 1121 0
 2858 17d0 0400A0E3 		mov	r0, #4
 2859 17d4 30159FE5 		ldr	r1, .L264+40
 2860 17d8 10018DE8 		stmia	sp, {r4, r8}	@ phole stm
 2861 17dc 08708DE5 		str	r7, [sp, #8]
 2862 17e0 FEFFFFEB 		bl	CyU3PDebugPrint
1123:../uvc.c      **** 							 break;
 2863              		.loc 1 1123 0
 2864 17e4 FFC0A0E3 		mov	ip, #255
 2865 17e8 0C40A0E1 		mov	r4, ip
 2866 17ec 8BFDFFEA 		b	.L139
 2867              	.LVL240:
 2868              	.L184:
1283:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2869              		.loc 1 1283 0
 2870 17f0 30459FE5 		ldr	r4, .L264+68
 2871 17f4 0010E0E3 		mvn	r1, #0
 2872 17f8 1C0094E5 		ldr	r0, [r4, #28]
 2873 17fc FEFFFFEB 		bl	_txe_mutex_get
 2874              	.LVL241:
1284:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2875              		.loc 1 1284 0
 2876 1800 14C09DE5 		ldr	ip, [sp, #20]
 2877 1804 0610A0E3 		mov	r1, #6
 2878 1808 0A20A0E1 		mov	r2, sl
 2879 180c 0930A0E1 		mov	r3, r9
 2880 1810 0400A0E1 		mov	r0, r4
 2881 1814 0080A0E3 		mov	r8, #0
 2882 1818 00C08DE5 		str	ip, [sp, #0]
 2883 181c 04808DE5 		str	r8, [sp, #4]
 2884 1820 FEFFFFEB 		bl	cmdSet
 2885              	.LVL242:
1286:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 2886              		.loc 1 1286 0
 2887 1824 14C09DE5 		ldr	ip, [sp, #20]
 2888 1828 0170A0E3 		mov	r7, #1
 2889              	.LVL243:
 2890 182c 0610A0E3 		mov	r1, #6
 2891 1830 0B20A0E1 		mov	r2, fp
 2892 1834 0930A0E1 		mov	r3, r9
 2893 1838 0400A0E1 		mov	r0, r4
 2894 183c 00C08DE5 		str	ip, [sp, #0]
 2895 1840 04708DE5 		str	r7, [sp, #4]
 2896 1844 FEFFFFEB 		bl	cmdSet
1287:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2897              		.loc 1 1287 0
 2898 1848 1C0094E5 		ldr	r0, [r4, #28]
 2899 184c FEFFFFEB 		bl	_txe_mutex_put
1288:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2900              		.loc 1 1288 0
 2901 1850 14809DE5 		ldr	r8, [sp, #20]
1290:../uvc.c      **** 							 break;
 2902              		.loc 1 1290 0
 2903 1854 FFC0A0E3 		mov	ip, #255
1289:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2904              		.loc 1 1289 0
 2905 1858 2072C6E5 		strb	r7, [r6, #544]
1288:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2906              		.loc 1 1288 0
 2907 185c 1D82C6E5 		strb	r8, [r6, #541]
1289:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2908              		.loc 1 1289 0
 2909 1860 18709DE5 		ldr	r7, [sp, #24]
1290:../uvc.c      **** 							 break;
 2910              		.loc 1 1290 0
 2911 1864 0C40A0E1 		mov	r4, ip
 2912 1868 6CFDFFEA 		b	.L139
 2913              	.LVL244:
 2914              	.L183:
1263:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2915              		.loc 1 1263 0
 2916 186c B4849FE5 		ldr	r8, .L264+68
 2917 1870 0010E0E3 		mvn	r1, #0
 2918 1874 1C0098E5 		ldr	r0, [r8, #28]
 2919 1878 FEFFFFEB 		bl	_txe_mutex_get
 2920              	.LVL245:
1264:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2921              		.loc 1 1264 0
 2922 187c 14009DE5 		ldr	r0, [sp, #20]
 2923 1880 00C0A0E3 		mov	ip, #0
 2924 1884 801040E2 		sub	r1, r0, #128
 2925 1888 FF4001E2 		and	r4, r1, #255
 2926 188c 0A20A0E1 		mov	r2, sl
 2927 1890 0510A0E3 		mov	r1, #5
 2928 1894 0930A0E1 		mov	r3, r9
 2929 1898 0800A0E1 		mov	r0, r8
 2930 189c 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 2931 18a0 FEFFFFEB 		bl	cmdSet
 2932              	.LVL246:
1266:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 2933              		.loc 1 1266 0
 2934 18a4 14209DE5 		ldr	r2, [sp, #20]
 2935 18a8 0510A0E3 		mov	r1, #5
 2936 18ac 767042E2 		sub	r7, r2, #118
 2937              	.LVL247:
 2938 18b0 FF4007E2 		and	r4, r7, #255
 2939 18b4 DC20A0E3 		mov	r2, #220
 2940 18b8 0170A0E3 		mov	r7, #1
 2941 18bc 0930A0E1 		mov	r3, r9
 2942 18c0 0800A0E1 		mov	r0, r8
 2943 18c4 90008DE8 		stmia	sp, {r4, r7}	@ phole stm
 2944 18c8 FEFFFFEB 		bl	cmdSet
 2945              	.LVL248:
1268:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 2946              		.loc 1 1268 0
 2947 18cc 14309DE5 		ldr	r3, [sp, #20]
 2948 18d0 0510A0E3 		mov	r1, #5
 2949 18d4 7E0083E2 		add	r0, r3, #126
 2950 18d8 FFC000E2 		and	ip, r0, #255
 2951 18dc DE20A0E3 		mov	r2, #222
 2952 18e0 0930A0E1 		mov	r3, r9
 2953 18e4 0800A0E1 		mov	r0, r8
 2954 18e8 0240A0E3 		mov	r4, #2
 2955 18ec 00C08DE5 		str	ip, [sp, #0]
 2956 18f0 04408DE5 		str	r4, [sp, #4]
 2957 18f4 FEFFFFEB 		bl	cmdSet
 2958              	.LVL249:
1270:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 2959              		.loc 1 1270 0
 2960 18f8 14109DE5 		ldr	r1, [sp, #20]
 2961 18fc 0930A0E1 		mov	r3, r9
 2962 1900 722081E2 		add	r2, r1, #114
 2963 1904 FFC002E2 		and	ip, r2, #255
 2964 1908 0510A0E3 		mov	r1, #5
 2965 190c E020A0E3 		mov	r2, #224
 2966 1910 0800A0E1 		mov	r0, r8
 2967 1914 0340A0E3 		mov	r4, #3
 2968 1918 00C08DE5 		str	ip, [sp, #0]
 2969 191c 04408DE5 		str	r4, [sp, #4]
 2970 1920 FEFFFFEB 		bl	cmdSet
 2971              	.LVL250:
1272:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 2972              		.loc 1 1272 0
 2973 1924 14309DE5 		ldr	r3, [sp, #20]
 2974 1928 0510A0E3 		mov	r1, #5
 2975 192c 6F0043E2 		sub	r0, r3, #111
 2976 1930 FFC000E2 		and	ip, r0, #255
 2977 1934 DD20A0E3 		mov	r2, #221
 2978 1938 0930A0E1 		mov	r3, r9
 2979 193c 0800A0E1 		mov	r0, r8
 2980 1940 0440A0E3 		mov	r4, #4
 2981 1944 00C08DE5 		str	ip, [sp, #0]
 2982 1948 04408DE5 		str	r4, [sp, #4]
 2983 194c FEFFFFEB 		bl	cmdSet
 2984              	.LVL251:
1274:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 2985              		.loc 1 1274 0
 2986 1950 D4139FE5 		ldr	r1, .L264+72
 2987 1954 05E0A0E3 		mov	lr, #5
 2988 1958 5C20D1E5 		ldrb	r2, [r1, #92]	@ zero_extendqisi2
 2989 195c 0930A0E1 		mov	r3, r9
 2990 1960 7FC082E2 		add	ip, r2, #127
 2991 1964 FF400CE2 		and	r4, ip, #255
 2992 1968 0E10A0E1 		mov	r1, lr
 2993 196c 0B20A0E1 		mov	r2, fp
 2994 1970 0800A0E1 		mov	r0, r8
 2995 1974 10408DE8 		stmia	sp, {r4, lr}	@ phole stm
 2996 1978 FEFFFFEB 		bl	cmdSet
1275:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2997              		.loc 1 1275 0
 2998 197c 1C0098E5 		ldr	r0, [r8, #28]
 2999 1980 FEFFFFEB 		bl	_txe_mutex_put
1277:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3000              		.loc 1 1277 0
 3001 1984 A0339FE5 		ldr	r3, .L264+72
1279:../uvc.c      **** 							 break;
 3002              		.loc 1 1279 0
 3003 1988 FFC0A0E3 		mov	ip, #255
1277:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3004              		.loc 1 1277 0
 3005 198c 5C00D3E5 		ldrb	r0, [r3, #92]	@ zero_extendqisi2
1278:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3006              		.loc 1 1278 0
 3007 1990 0872C6E5 		strb	r7, [r6, #520]
1277:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3008              		.loc 1 1277 0
 3009 1994 801040E2 		sub	r1, r0, #128
 3010 1998 0512C6E5 		strb	r1, [r6, #517]
1278:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3011              		.loc 1 1278 0
 3012 199c 14809DE5 		ldr	r8, [sp, #20]
 3013 19a0 18709DE5 		ldr	r7, [sp, #24]
1279:../uvc.c      **** 							 break;
 3014              		.loc 1 1279 0
 3015 19a4 0C40A0E1 		mov	r4, ip
 3016 19a8 1CFDFFEA 		b	.L139
 3017              	.LVL252:
 3018              	.L182:
1310:../uvc.c      **** 							 Data0 = Data0 - 1;
 3019              		.loc 1 1310 0
 3020 19ac 012043E2 		sub	r2, r3, #1
 3021              	.LVL253:
 3022 19b0 0310A0E1 		mov	r1, r3
 3023              	.LVL254:
1311:../uvc.c      **** 							 is60Hz = Data0;
 3024              		.loc 1 1311 0
 3025 19b4 70039FE5 		ldr	r0, .L264+72
1310:../uvc.c      **** 							 Data0 = Data0 - 1;
 3026              		.loc 1 1310 0
 3027 19b8 FF3002E2 		and	r3, r2, #255
 3028              	.LVL255:
1317:../uvc.c      **** 							 else if(Data0 >2)
 3029              		.loc 1 1317 0
 3030 19bc 020053E3 		cmp	r3, #2
1309:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3031              		.loc 1 1309 0
 3032 19c0 ED11C6E5 		strb	r1, [r6, #493]
1320:../uvc.c      **** 								 is60Hz = CyTrue;
 3033              		.loc 1 1320 0
 3034 19c4 0110A083 		movhi	r1, #1
1311:../uvc.c      **** 							 is60Hz = Data0;
 3035              		.loc 1 1311 0
 3036 19c8 583080E5 		str	r3, [r0, #88]
 3037              	.LVL256:
1320:../uvc.c      **** 								 is60Hz = CyTrue;
 3038              		.loc 1 1320 0
 3039 19cc 58108085 		strhi	r1, [r0, #88]
1323:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3040              		.loc 1 1323 0
 3041 19d0 54039FE5 		ldr	r0, .L264+72
 3042 19d4 28E090E5 		ldr	lr, [r0, #40]
 3043 19d8 01005EE3 		cmp	lr, #1
 3044 19dc 4601000A 		beq	.L260
 3045              	.LVL257:
 3046              	.L214:
1353:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3047              		.loc 1 1353 0
 3048 19e0 0140A0E3 		mov	r4, #1
1354:../uvc.c      **** 							 break;
 3049              		.loc 1 1354 0
 3050 19e4 FFC0A0E3 		mov	ip, #255
1353:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3051              		.loc 1 1353 0
 3052 19e8 F041C6E5 		strb	r4, [r6, #496]
 3053 19ec 14809DE5 		ldr	r8, [sp, #20]
 3054 19f0 18709DE5 		ldr	r7, [sp, #24]
1354:../uvc.c      **** 							 break;
 3055              		.loc 1 1354 0
 3056 19f4 0C40A0E1 		mov	r4, ip
 3057 19f8 08FDFFEA 		b	.L139
 3058              	.LVL258:
 3059              	.L181:
1404:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3060              		.loc 1 1404 0
 3061 19fc 24839FE5 		ldr	r8, .L264+68
 3062 1a00 0010E0E3 		mvn	r1, #0
 3063 1a04 1C0098E5 		ldr	r0, [r8, #28]
 3064 1a08 FEFFFFEB 		bl	_txe_mutex_get
 3065              	.LVL259:
1405:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3066              		.loc 1 1405 0
 3067 1a0c 0410A0E1 		mov	r1, r4
 3068 1a10 14409DE5 		ldr	r4, [sp, #20]
 3069 1a14 00C0A0E3 		mov	ip, #0
 3070 1a18 0930A0E1 		mov	r3, r9
 3071 1a1c 0A20A0E1 		mov	r2, sl
 3072 1a20 0800A0E1 		mov	r0, r8
 3073 1a24 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3074 1a28 FEFFFFEB 		bl	cmdSet
1406:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3075              		.loc 1 1406 0
 3076 1a2c 1C0098E5 		ldr	r0, [r8, #28]
 3077 1a30 FEFFFFEB 		bl	_txe_mutex_put
1408:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
 3078              		.loc 1 1408 0
 3079 1a34 14109DE5 		ldr	r1, [sp, #20]
1413:../uvc.c      **** 							 break;
 3080              		.loc 1 1413 0
 3081 1a38 FFC0A0E3 		mov	ip, #255
1409:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 3082              		.loc 1 1409 0
 3083 1a3c 0130A0E3 		mov	r3, #1
1408:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
 3084              		.loc 1 1408 0
 3085 1a40 BD11C6E5 		strb	r1, [r6, #445]
1409:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 3086              		.loc 1 1409 0
 3087 1a44 C031C6E5 		strb	r3, [r6, #448]
 3088 1a48 0180A0E1 		mov	r8, r1
 3089 1a4c 18709DE5 		ldr	r7, [sp, #24]
 3090              	.LVL260:
1413:../uvc.c      **** 							 break;
 3091              		.loc 1 1413 0
 3092 1a50 0C40A0E1 		mov	r4, ip
 3093 1a54 F1FCFFEA 		b	.L139
 3094              	.LVL261:
 3095              	.L188:
1069:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3096              		.loc 1 1069 0
 3097 1a58 C8429FE5 		ldr	r4, .L264+68
1065:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3098              		.loc 1 1065 0
 3099 1a5c B8A4D6E5 		ldrb	sl, [r6, #1208]	@ zero_extendqisi2
1066:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3100              		.loc 1 1066 0
 3101 1a60 B974D6E5 		ldrb	r7, [r6, #1209]	@ zero_extendqisi2
 3102              	.LVL262:
1067:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 3103              		.loc 1 1067 0
 3104 1a64 C734D6E5 		ldrb	r3, [r6, #1223]	@ zero_extendqisi2
1069:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3105              		.loc 1 1069 0
 3106 1a68 1C0094E5 		ldr	r0, [r4, #28]
 3107 1a6c 0010E0E3 		mvn	r1, #0
1066:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3108              		.loc 1 1066 0
 3109 1a70 FF9007E2 		and	r9, r7, #255
1067:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 3110              		.loc 1 1067 0
 3111 1a74 FF7003E2 		and	r7, r3, #255
1069:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3112              		.loc 1 1069 0
 3113 1a78 FEFFFFEB 		bl	_txe_mutex_get
 3114              	.LVL263:
1070:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3115              		.loc 1 1070 0
 3116 1a7c 14C09DE5 		ldr	ip, [sp, #20]
 3117 1a80 C504D6E5 		ldrb	r0, [r6, #1221]	@ zero_extendqisi2
1065:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3118              		.loc 1 1065 0
 3119 1a84 FFA00AE2 		and	sl, sl, #255
 3120              	.LVL264:
1070:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3121              		.loc 1 1070 0
 3122 1a88 00005CE1 		cmp	ip, r0
1065:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3123              		.loc 1 1065 0
 3124 1a8c 50329FE5 		ldr	r3, .L264
 3125 1a90 0C80A001 		moveq	r8, ip
1070:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3126              		.loc 1 1070 0
 3127 1a94 0A00000A 		beq	.L201
1072:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
 3128              		.loc 1 1072 0
 3129 1a98 C5C4C3E5 		strb	ip, [r3, #1221]
1073:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 3130              		.loc 1 1073 0
 3131 1a9c 9D24D3E5 		ldrb	r2, [r3, #1181]	@ zero_extendqisi2
1074:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3132              		.loc 1 1074 0
 3133 1aa0 0400A0E1 		mov	r0, r4
1073:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 3134              		.loc 1 1073 0
 3135 1aa4 02828CE1 		orr	r8, ip, r2, asl #4
 3136 1aa8 FF8008E2 		and	r8, r8, #255
 3137              	.LVL265:
1074:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3138              		.loc 1 1074 0
 3139 1aac 00C0A0E3 		mov	ip, #0
 3140 1ab0 1910A0E3 		mov	r1, #25
 3141 1ab4 0A20A0E1 		mov	r2, sl
 3142 1ab8 0730A0E1 		mov	r3, r7
 3143 1abc 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 3144 1ac0 FEFFFFEB 		bl	cmdSet
 3145              	.LVL266:
 3146              	.L201:
1086:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
 3147              		.loc 1 1086 0
 3148 1ac4 C614D6E5 		ldrb	r1, [r6, #1222]	@ zero_extendqisi2
 3149 1ac8 18009DE5 		ldr	r0, [sp, #24]
 3150 1acc 000051E1 		cmp	r1, r0
 3151 1ad0 0500000A 		beq	.L202
1088:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3152              		.loc 1 1088 0
 3153 1ad4 14C09DE5 		ldr	ip, [sp, #20]
1087:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 3154              		.loc 1 1087 0
 3155 1ad8 04E29FE5 		ldr	lr, .L264
1088:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3156              		.loc 1 1088 0
 3157 1adc 02304CE2 		sub	r3, ip, #2
 3158 1ae0 010053E3 		cmp	r3, #1
1087:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 3159              		.loc 1 1087 0
 3160 1ae4 C604CEE5 		strb	r0, [lr, #1222]
1088:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3161              		.loc 1 1088 0
 3162 1ae8 8D01009A 		bls	.L261
 3163              	.LVL267:
 3164              	.L202:
1093:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3165              		.loc 1 1093 0
 3166 1aec 1C0094E5 		ldr	r0, [r4, #28]
 3167 1af0 FEFFFFEB 		bl	_txe_mutex_put
1095:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3168              		.loc 1 1095 0
 3169 1af4 C524D6E5 		ldrb	r2, [r6, #1221]	@ zero_extendqisi2
1094:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3170              		.loc 1 1094 0
 3171 1af8 18709DE5 		ldr	r7, [sp, #24]
1095:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3172              		.loc 1 1095 0
 3173 1afc C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
 3174 1b00 9D44D6E5 		ldrb	r4, [r6, #1181]	@ zero_extendqisi2
1094:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3175              		.loc 1 1094 0
 3176 1b04 0400A0E3 		mov	r0, #4
 3177 1b08 00129FE5 		ldr	r1, .L264+44
 3178 1b0c 10018DE8 		stmia	sp, {r4, r8}	@ phole stm
 3179 1b10 08708DE5 		str	r7, [sp, #8]
 3180 1b14 FEFFFFEB 		bl	CyU3PDebugPrint
1096:../uvc.c      **** 							 break;
 3181              		.loc 1 1096 0
 3182 1b18 FFC0A0E3 		mov	ip, #255
1094:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3183              		.loc 1 1094 0
 3184 1b1c 14809DE5 		ldr	r8, [sp, #20]
 3185              	.LVL268:
1096:../uvc.c      **** 							 break;
 3186              		.loc 1 1096 0
 3187 1b20 0C40A0E1 		mov	r4, ip
 3188 1b24 BDFCFFEA 		b	.L139
 3189              	.LVL269:
 3190              	.L180:
1245:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3191              		.loc 1 1245 0
 3192 1b28 F8419FE5 		ldr	r4, .L264+68
 3193 1b2c 0010E0E3 		mvn	r1, #0
 3194 1b30 1C0094E5 		ldr	r0, [r4, #28]
 3195 1b34 FEFFFFEB 		bl	_txe_mutex_get
 3196              	.LVL270:
1247:../uvc.c      **** 							  if(Data0&0x80){
 3197              		.loc 1 1247 0
 3198 1b38 14209DE5 		ldr	r2, [sp, #20]
1252:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 3199              		.loc 1 1252 0
 3200 1b3c 00C0A0E3 		mov	ip, #0
1247:../uvc.c      **** 							  if(Data0&0x80){
 3201              		.loc 1 1247 0
 3202 1b40 800012E3 		tst	r2, #128
1248:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 3203              		.loc 1 1248 0
 3204 1b44 80704212 		subne	r7, r2, #128
 3205              	.LVL271:
1250:../uvc.c      **** 								  Data0 = ~Data0;
 3206              		.loc 1 1250 0
 3207 1b48 0270E001 		mvneq	r7, r2
 3208 1b4c FF8007E2 		and	r8, r7, #255
 3209              	.LVL272:
1252:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 3210              		.loc 1 1252 0
 3211 1b50 0110A0E3 		mov	r1, #1
 3212 1b54 0B20A0E1 		mov	r2, fp
 3213 1b58 0930A0E1 		mov	r3, r9
 3214 1b5c C4019FE5 		ldr	r0, .L264+68
 3215 1b60 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 3216 1b64 FEFFFFEB 		bl	cmdSet
1253:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3217              		.loc 1 1253 0
 3218 1b68 1C0094E5 		ldr	r0, [r4, #28]
 3219 1b6c FEFFFFEB 		bl	_txe_mutex_put
1256:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3220              		.loc 1 1256 0
 3221 1b70 0170A0E3 		mov	r7, #1
1259:../uvc.c      **** 							 break;
 3222              		.loc 1 1259 0
 3223 1b74 FFC0A0E3 		mov	ip, #255
1255:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3224              		.loc 1 1255 0
 3225 1b78 A581C6E5 		strb	r8, [r6, #421]
1256:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3226              		.loc 1 1256 0
 3227 1b7c A871C6E5 		strb	r7, [r6, #424]
 3228 1b80 14809DE5 		ldr	r8, [sp, #20]
 3229              	.LVL273:
 3230 1b84 18709DE5 		ldr	r7, [sp, #24]
1259:../uvc.c      **** 							 break;
 3231              		.loc 1 1259 0
 3232 1b88 0C40A0E1 		mov	r4, ip
 3233 1b8c A3FCFFEA 		b	.L139
 3234              	.LVL274:
 3235              	.L179:
1366:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3236              		.loc 1 1366 0
 3237 1b90 94219FE5 		ldr	r2, .L264+72
 3238              	.LVL275:
1356:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3239              		.loc 1 1356 0
 3240 1b94 F874D6E5 		ldrb	r7, [r6, #1272]	@ zero_extendqisi2
 3241              	.LVL276:
1366:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3242              		.loc 1 1366 0
 3243 1b98 7C20D2E5 		ldrb	r2, [r2, #124]	@ zero_extendqisi2
 3244 1b9c 03C0A0E1 		mov	ip, r3
1357:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3245              		.loc 1 1357 0
 3246 1ba0 F934D6E5 		ldrb	r3, [r6, #1273]	@ zero_extendqisi2
1358:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3247              		.loc 1 1358 0
 3248 1ba4 0785D6E5 		ldrb	r8, [r6, #1287]	@ zero_extendqisi2
1366:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3249              		.loc 1 1366 0
 3250 1ba8 010052E3 		cmp	r2, #1
1364:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3251              		.loc 1 1364 0
 3252 1bac 0110A0E3 		mov	r1, #1
1363:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3253              		.loc 1 1363 0
 3254 1bb0 05C5C6E5 		strb	ip, [r6, #1285]
1356:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3255              		.loc 1 1356 0
 3256 1bb4 FF7007E2 		and	r7, r7, #255
 3257              	.LVL277:
1364:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3258              		.loc 1 1364 0
 3259 1bb8 0915C6E5 		strb	r1, [r6, #1289]
1358:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3260              		.loc 1 1358 0
 3261 1bbc FF8008E2 		and	r8, r8, #255
 3262              	.LVL278:
 3263 1bc0 0C60A011 		movne	r6, ip
1366:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3264              		.loc 1 1366 0
 3265 1bc4 3201000A 		beq	.L262
 3266              	.LVL279:
 3267              	.L228:
1377:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3268              		.loc 1 1377 0
 3269 1bc8 58419FE5 		ldr	r4, .L264+68
 3270 1bcc 0010E0E3 		mvn	r1, #0
 3271 1bd0 1C0094E5 		ldr	r0, [r4, #28]
 3272 1bd4 FEFFFFEB 		bl	_txe_mutex_get
1378:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3273              		.loc 1 1378 0
 3274 1bd8 00C0A0E3 		mov	ip, #0
 3275 1bdc 0C10A0E1 		mov	r1, ip
 3276 1be0 0720A0E1 		mov	r2, r7
 3277 1be4 0830A0E1 		mov	r3, r8
 3278 1be8 0400A0E1 		mov	r0, r4
 3279 1bec 40108DE8 		stmia	sp, {r6, ip}	@ phole stm
 3280 1bf0 FEFFFFEB 		bl	cmdSet
1379:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3281              		.loc 1 1379 0
 3282 1bf4 1C0094E5 		ldr	r0, [r4, #28]
 3283 1bf8 D1FEFFEA 		b	.L253
 3284              	.LVL280:
 3285              	.L178:
1417:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3286              		.loc 1 1417 0
 3287 1bfc 24819FE5 		ldr	r8, .L264+68
 3288 1c00 0010E0E3 		mvn	r1, #0
 3289 1c04 1C0098E5 		ldr	r0, [r8, #28]
 3290 1c08 FEFFFFEB 		bl	_txe_mutex_get
 3291              	.LVL281:
1418:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3292              		.loc 1 1418 0
 3293 1c0c 14709DE5 		ldr	r7, [sp, #20]
 3294              	.LVL282:
 3295 1c10 00C0A0E3 		mov	ip, #0
 3296 1c14 0410A0E1 		mov	r1, r4
 3297 1c18 0A20A0E1 		mov	r2, sl
 3298 1c1c 0930A0E1 		mov	r3, r9
 3299 1c20 0800A0E1 		mov	r0, r8
 3300 1c24 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 3301 1c28 FEFFFFEB 		bl	cmdSet
1419:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3302              		.loc 1 1419 0
 3303 1c2c 1C0098E5 		ldr	r0, [r8, #28]
 3304 1c30 FEFFFFEB 		bl	_txe_mutex_put
1421:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3305              		.loc 1 1421 0
 3306 1c34 14209DE5 		ldr	r2, [sp, #20]
 3307 1c38 847084E0 		add	r7, r4, r4, asl #1
 3308 1c3c 876186E0 		add	r6, r6, r7, asl #3
1423:../uvc.c      **** 							 break;
 3309              		.loc 1 1423 0
 3310 1c40 FFC0A0E3 		mov	ip, #255
1422:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3311              		.loc 1 1422 0
 3312 1c44 0100A0E3 		mov	r0, #1
1421:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3313              		.loc 1 1421 0
 3314 1c48 8D21C6E5 		strb	r2, [r6, #397]
1422:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3315              		.loc 1 1422 0
 3316 1c4c 9001C6E5 		strb	r0, [r6, #400]
 3317 1c50 0280A0E1 		mov	r8, r2
 3318 1c54 18709DE5 		ldr	r7, [sp, #24]
1423:../uvc.c      **** 							 break;
 3319              		.loc 1 1423 0
 3320 1c58 0C40A0E1 		mov	r4, ip
 3321 1c5c 6FFCFFEA 		b	.L139
 3322              	.LVL283:
 3323              	.L186:
1297:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3324              		.loc 1 1297 0
 3325 1c60 C0409FE5 		ldr	r4, .L264+68
 3326 1c64 0010E0E3 		mvn	r1, #0
 3327 1c68 1C0094E5 		ldr	r0, [r4, #28]
 3328 1c6c FEFFFFEB 		bl	_txe_mutex_get
 3329              	.LVL284:
1298:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3330              		.loc 1 1298 0
 3331 1c70 14809DE5 		ldr	r8, [sp, #20]
 3332 1c74 00C0A0E3 		mov	ip, #0
 3333 1c78 0B10A0E3 		mov	r1, #11
 3334 1c7c 0A20A0E1 		mov	r2, sl
 3335 1c80 0930A0E1 		mov	r3, r9
 3336 1c84 0400A0E1 		mov	r0, r4
 3337 1c88 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 3338 1c8c FEFFFFEB 		bl	cmdSet
 3339              	.LVL285:
1300:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 3340              		.loc 1 1300 0
 3341 1c90 18809DE5 		ldr	r8, [sp, #24]
 3342 1c94 0170A0E3 		mov	r7, #1
 3343              	.LVL286:
 3344 1c98 0B20A0E1 		mov	r2, fp
 3345 1c9c 0930A0E1 		mov	r3, r9
 3346 1ca0 0B10A0E3 		mov	r1, #11
 3347 1ca4 0400A0E1 		mov	r0, r4
 3348 1ca8 00808DE5 		str	r8, [sp, #0]
 3349 1cac 04708DE5 		str	r7, [sp, #4]
 3350 1cb0 FEFFFFEB 		bl	cmdSet
1301:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3351              		.loc 1 1301 0
 3352 1cb4 1C0094E5 		ldr	r0, [r4, #28]
 3353 1cb8 FEFFFFEB 		bl	_txe_mutex_put
1303:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 3354              		.loc 1 1303 0
 3355 1cbc 14209DE5 		ldr	r2, [sp, #20]
1304:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3356              		.loc 1 1304 0
 3357 1cc0 18309DE5 		ldr	r3, [sp, #24]
1306:../uvc.c      **** 							 break;
 3358              		.loc 1 1306 0
 3359 1cc4 FFC0A0E3 		mov	ip, #255
1305:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3360              		.loc 1 1305 0
 3361 1cc8 9872C6E5 		strb	r7, [r6, #664]
1303:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 3362              		.loc 1 1303 0
 3363 1ccc CC24C6E5 		strb	r2, [r6, #1228]
1304:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3364              		.loc 1 1304 0
 3365 1cd0 CE34C6E5 		strb	r3, [r6, #1230]
1305:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3366              		.loc 1 1305 0
 3367 1cd4 0280A0E1 		mov	r8, r2
 3368 1cd8 0370A0E1 		mov	r7, r3
1306:../uvc.c      **** 							 break;
 3369              		.loc 1 1306 0
 3370 1cdc 0C40A0E1 		mov	r4, ip
 3371 1ce0 4EFCFFEA 		b	.L139
 3372              	.L265:
 3373              		.align	2
 3374              	.L264:
 3375 1ce4 00000000 		.word	.LANCHOR1
 3376 1ce8 00000000 		.word	bRequest
 3377 1cec 2C040000 		.word	.LC25
 3378 1cf0 5C000000 		.word	.LANCHOR0+92
 3379 1cf4 01000100 		.word	65537
 3380 1cf8 FF00FF00 		.word	16711935
 3381 1cfc 00000000 		.word	.LANCHOR2
 3382 1d00 18030000 		.word	.LC19
 3383 1d04 DC020000 		.word	.LC18
 3384 1d08 4C000000 		.word	.LANCHOR0+76
 3385 1d0c A0030000 		.word	.LC22
 3386 1d10 6C030000 		.word	.LC21
 3387 1d14 40030000 		.word	.LC20
 3388 1d18 FC030000 		.word	.LC24
 3389 1d1c D8030000 		.word	.LC23
 3390 1d20 00000000 		.word	.LANCHOR1
 3391 1d24 A4020000 		.word	.LC17
 3392 1d28 00000000 		.word	cmdQu
 3393 1d2c 00000000 		.word	.LANCHOR0
 3394              	.LVL287:
 3395              	.L185:
1383:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3396              		.loc 1 1383 0
 3397 1d30 0C05D6E5 		ldrb	r0, [r6, #1292]	@ zero_extendqisi2
1384:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3398              		.loc 1 1384 0
 3399 1d34 0DA5D6E5 		ldrb	sl, [r6, #1293]	@ zero_extendqisi2
1385:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3400              		.loc 1 1385 0
 3401 1d38 1BE5D6E5 		ldrb	lr, [r6, #1307]	@ zero_extendqisi2
1388:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3402              		.loc 1 1388 0
 3403 1d3c 0140A0E3 		mov	r4, #1
1389:../uvc.c      **** 							 if(Data0 != 0){
 3404              		.loc 1 1389 0
 3405 1d40 000053E3 		cmp	r3, #0
1387:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3406              		.loc 1 1387 0
 3407 1d44 1935C6E5 		strb	r3, [r6, #1305]
1383:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3408              		.loc 1 1383 0
 3409 1d48 FF8000E2 		and	r8, r0, #255
 3410              	.LVL288:
1384:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3411              		.loc 1 1384 0
 3412 1d4c FFA00AE2 		and	sl, sl, #255
 3413              	.LVL289:
1385:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3414              		.loc 1 1385 0
 3415 1d50 FF700EE2 		and	r7, lr, #255
 3416              	.LVL290:
1388:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3417              		.loc 1 1388 0
 3418 1d54 1D45C6E5 		strb	r4, [r6, #1309]
1389:../uvc.c      **** 							 if(Data0 != 0){
 3419              		.loc 1 1389 0
 3420 1d58 5400000A 		beq	.L230
1390:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3421              		.loc 1 1390 0
 3422 1d5c 3C601FE5 		ldr	r6, .L264+68
 3423 1d60 0010E0E3 		mvn	r1, #0
 3424 1d64 1C0096E5 		ldr	r0, [r6, #28]
 3425 1d68 FEFFFFEB 		bl	_txe_mutex_get
 3426              	.LVL291:
1391:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
 3427              		.loc 1 1391 0
 3428 1d6c 0820A0E1 		mov	r2, r8
 3429 1d70 00C0A0E3 		mov	ip, #0
 3430 1d74 0710A0E3 		mov	r1, #7
 3431 1d78 0730A0E1 		mov	r3, r7
 3432 1d7c 0600A0E1 		mov	r0, r6
 3433 1d80 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3434 1d84 FEFFFFEB 		bl	cmdSet
 3435              	.LVL292:
1393:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
 3436              		.loc 1 1393 0
 3437 1d88 14809DE5 		ldr	r8, [sp, #20]
 3438              	.LVL293:
 3439 1d8c 0710A0E3 		mov	r1, #7
 3440 1d90 0A20A0E1 		mov	r2, sl
 3441 1d94 0730A0E1 		mov	r3, r7
 3442 1d98 0600A0E1 		mov	r0, r6
 3443 1d9c 00808DE5 		str	r8, [sp, #0]
 3444 1da0 04408DE5 		str	r4, [sp, #4]
 3445 1da4 FEFFFFEB 		bl	cmdSet
1394:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3446              		.loc 1 1394 0
 3447 1da8 1C0096E5 		ldr	r0, [r6, #28]
 3448 1dac 64FEFFEA 		b	.L253
 3449              	.LVL294:
 3450              	.L187:
1005:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3451              		.loc 1 1005 0
 3452 1db0 9074D6E5 		ldrb	r7, [r6, #1168]	@ zero_extendqisi2
 3453              	.LVL295:
 3454 1db4 0310A0E1 		mov	r1, r3
1006:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3455              		.loc 1 1006 0
 3456 1db8 9184D6E5 		ldrb	r8, [r6, #1169]	@ zero_extendqisi2
1007:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3457              		.loc 1 1007 0
 3458 1dbc 9F44D6E5 		ldrb	r4, [r6, #1183]	@ zero_extendqisi2
1008:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
 3459              		.loc 1 1008 0
 3460 1dc0 9D34C6E5 		strb	r3, [r6, #1181]
1010:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3461              		.loc 1 1010 0
 3462 1dc4 C534D6E5 		ldrb	r3, [r6, #1221]	@ zero_extendqisi2
1005:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3463              		.loc 1 1005 0
 3464 1dc8 FF7007E2 		and	r7, r7, #255
 3465              	.LVL296:
1010:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3466              		.loc 1 1010 0
 3467 1dcc 030013E3 		tst	r3, #3
1006:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3468              		.loc 1 1006 0
 3469 1dd0 FF8008E2 		and	r8, r8, #255
 3470              	.LVL297:
1007:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3471              		.loc 1 1007 0
 3472 1dd4 FF4004E2 		and	r4, r4, #255
 3473              	.LVL298:
1010:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3474              		.loc 1 1010 0
 3475 1dd8 0130A001 		moveq	r3, r1
 3476 1ddc 1A00000A 		beq	.L200
 3477 1de0 0120A0E1 		mov	r2, r1
 3478              	.LVL299:
1012:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3479              		.loc 1 1012 0
 3480 1de4 CC101FE5 		ldr	r1, .L264+60
1014:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3481              		.loc 1 1014 0
 3482 1de8 C8A01FE5 		ldr	sl, .L264+68
1012:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3483              		.loc 1 1012 0
 3484 1dec C504D1E5 		ldrb	r0, [r1, #1221]	@ zero_extendqisi2
1014:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3485              		.loc 1 1014 0
 3486 1df0 0010E0E3 		mvn	r1, #0
1012:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3487              		.loc 1 1012 0
 3488 1df4 029280E1 		orr	r9, r0, r2, asl #4
1014:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3489              		.loc 1 1014 0
 3490 1df8 1C009AE5 		ldr	r0, [sl, #28]
 3491 1dfc FEFFFFEB 		bl	_txe_mutex_get
1015:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3492              		.loc 1 1015 0
 3493 1e00 00C0A0E3 		mov	ip, #0
 3494 1e04 1010A0E3 		mov	r1, #16
 3495 1e08 0820A0E1 		mov	r2, r8
 3496 1e0c 0430A0E1 		mov	r3, r4
 3497 1e10 0A00A0E1 		mov	r0, sl
1012:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3498              		.loc 1 1012 0
 3499 1e14 FF9009E2 		and	r9, r9, #255
 3500              	.LVL300:
1015:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3501              		.loc 1 1015 0
 3502 1e18 00C08DE5 		str	ip, [sp, #0]
 3503 1e1c 04C08DE5 		str	ip, [sp, #4]
 3504 1e20 FEFFFFEB 		bl	cmdSet
 3505              	.LVL301:
1017:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3506              		.loc 1 1017 0
 3507 1e24 0430A0E1 		mov	r3, r4
 3508 1e28 01C0A0E3 		mov	ip, #1
 3509 1e2c 1010A0E3 		mov	r1, #16
 3510 1e30 0720A0E1 		mov	r2, r7
 3511 1e34 0A00A0E1 		mov	r0, sl
 3512 1e38 00128DE8 		stmia	sp, {r9, ip}	@ phole stm
 3513 1e3c FEFFFFEB 		bl	cmdSet
1018:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3514              		.loc 1 1018 0
 3515 1e40 1C009AE5 		ldr	r0, [sl, #28]
 3516 1e44 FEFFFFEB 		bl	_txe_mutex_put
 3517 1e48 0930A0E1 		mov	r3, r9
 3518              	.LVL302:
 3519              	.L200:
1021:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 3520              		.loc 1 1021 0
 3521 1e4c C544D6E5 		ldrb	r4, [r6, #1221]	@ zero_extendqisi2
 3522              	.LVL303:
 3523 1e50 9DE4D6E5 		ldrb	lr, [r6, #1181]	@ zero_extendqisi2
1020:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3524              		.loc 1 1020 0
 3525 1e54 0400A0E3 		mov	r0, #4
 3526 1e58 4C111FE5 		ldr	r1, .L264+48
 3527 1e5c 1C209DE5 		ldr	r2, [sp, #28]
 3528 1e60 10408DE8 		stmia	sp, {r4, lr}	@ phole stm
 3529 1e64 FEFFFFEB 		bl	CyU3PDebugPrint
1022:../uvc.c      **** 						     break;
 3530              		.loc 1 1022 0
 3531 1e68 FFC0A0E3 		mov	ip, #255
1020:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3532              		.loc 1 1020 0
 3533 1e6c 14809DE5 		ldr	r8, [sp, #20]
 3534              	.LVL304:
 3535 1e70 18709DE5 		ldr	r7, [sp, #24]
 3536              	.LVL305:
1022:../uvc.c      **** 						     break;
 3537              		.loc 1 1022 0
 3538 1e74 0C40A0E1 		mov	r4, ip
 3539 1e78 E8FBFFEA 		b	.L139
 3540              	.LVL306:
 3541              	.L177:
1426:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 3542              		.loc 1 1426 0
 3543 1e7c 0400A0E3 		mov	r0, #4
 3544              	.LVL307:
 3545 1e80 70111FE5 		ldr	r1, .L264+52
 3546 1e84 FEFFFFEB 		bl	CyU3PDebugPrint
 3547              	.LVL308:
 3548 1e88 FFC0A0E3 		mov	ip, #255
 3549 1e8c 0C40A0E1 		mov	r4, ip
 3550 1e90 0C70A0E1 		mov	r7, ip
 3551              	.LVL309:
 3552 1e94 0C80A0E1 		mov	r8, ip
 3553 1e98 E0FBFFEA 		b	.L139
 3554              	.LVL310:
 3555              	.L259:
 804:../uvc.c      **** 						if(sendData >= 3){
 3556              		.loc 1 804 0
 3557 1e9c 020054E3 		cmp	r4, #2
 3558 1ea0 9600008A 		bhi	.L263
 3559              	.LVL311:
 3560              	.L157:
 809:../uvc.c      **** 						sendData += 4;
 3561              		.loc 1 809 0
 3562 1ea4 042084E2 		add	r2, r4, #4
 3563 1ea8 FF4002E2 		and	r4, r2, #255
 3564              	.LVL312:
 3565 1eac EDFCFFEA 		b	.L156
 3566              	.LVL313:
 3567              	.L230:
1396:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3568              		.loc 1 1396 0
 3569 1eb0 90411FE5 		ldr	r4, .L264+68
 3570 1eb4 0010E0E3 		mvn	r1, #0
 3571 1eb8 1C0094E5 		ldr	r0, [r4, #28]
 3572 1ebc FEFFFFEB 		bl	_txe_mutex_get
 3573              	.LVL314:
1397:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 3574              		.loc 1 1397 0
 3575 1ec0 0730A0E1 		mov	r3, r7
 3576 1ec4 14709DE5 		ldr	r7, [sp, #20]
 3577              	.LVL315:
 3578 1ec8 0820A0E1 		mov	r2, r8
 3579 1ecc 0710A0E3 		mov	r1, #7
 3580 1ed0 0400A0E1 		mov	r0, r4
 3581 1ed4 00708DE5 		str	r7, [sp, #0]
 3582 1ed8 04708DE5 		str	r7, [sp, #4]
 3583 1edc FEFFFFEB 		bl	cmdSet
 3584              	.LVL316:
1398:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3585              		.loc 1 1398 0
 3586 1ee0 1C0094E5 		ldr	r0, [r4, #28]
 3587 1ee4 FEFFFFEB 		bl	_txe_mutex_put
 3588 1ee8 FFC0A0E3 		mov	ip, #255
 3589 1eec 18709DE5 		ldr	r7, [sp, #24]
 3590 1ef0 0C40A0E1 		mov	r4, ip
 3591 1ef4 14809DE5 		ldr	r8, [sp, #20]
 3592              	.LVL317:
 3593 1ef8 C8FBFFEA 		b	.L139
 3594              	.LVL318:
 3595              	.L260:
1326:../uvc.c      **** 			                       switch (setRes)
 3596              		.loc 1 1326 0
 3597 1efc 7D40D0E5 		ldrb	r4, [r0, #125]	@ zero_extendqisi2
 3598 1f00 017044E2 		sub	r7, r4, #1
 3599              	.LVL319:
 3600 1f04 030057E3 		cmp	r7, #3
 3601 1f08 07F19F97 		ldrls	pc, [pc, r7, asl #2]
 3602 1f0c B3FEFFEA 		b	.L214
 3603              	.L219:
 3604 1f10 40200000 		.word	.L215
 3605 1f14 EC1F0000 		.word	.L216
 3606 1f18 841F0000 		.word	.L217
 3607 1f1c 201F0000 		.word	.L218
 3608              	.L218:
1344:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
 3609              		.loc 1 1344 0
 3610 1f20 FC311FE5 		ldr	r3, .L264+72
 3611 1f24 3010A0E3 		mov	r1, #48
 3612 1f28 58E093E5 		ldr	lr, [r3, #88]
 3613 1f2c 8C04D6E5 		ldrb	r0, [r6, #1164]	@ zero_extendqisi2
 3614 1f30 00005EE3 		cmp	lr, #0
 3615 1f34 F4E0A003 		moveq	lr, #244
 3616 1f38 74E0A013 		movne	lr, #116
 3617 1f3c 00208EE1 		orr	r2, lr, r0
 3618 1f40 5230A0E3 		mov	r3, #82
 3619 1f44 0100A0E3 		mov	r0, #1
 3620 1f48 FEFFFFEB 		bl	SensorSetIrisControl
1345:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3621              		.loc 1 1345 0
 3622 1f4c 7D0FA0E3 		mov	r0, #500
 3623 1f50 FEFFFFEB 		bl	_tx_thread_sleep
1346:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 3624              		.loc 1 1346 0
 3625 1f54 30121FE5 		ldr	r1, .L264+72
 3626 1f58 0400A0E3 		mov	r0, #4
 3627 1f5c 587091E5 		ldr	r7, [r1, #88]
 3628 1f60 8C24D6E5 		ldrb	r2, [r6, #1164]	@ zero_extendqisi2
 3629 1f64 000057E3 		cmp	r7, #0
 3630 1f68 F470A003 		moveq	r7, #244
 3631 1f6c 7470A013 		movne	r7, #116
 3632 1f70 583091E5 		ldr	r3, [r1, #88]
 3633 1f74 022087E1 		orr	r2, r7, r2
 3634 1f78 64121FE5 		ldr	r1, .L264+56
 3635 1f7c FEFFFFEB 		bl	CyU3PDebugPrint
 3636 1f80 96FEFFEA 		b	.L214
 3637              	.L217:
1339:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
 3638              		.loc 1 1339 0
 3639 1f84 60821FE5 		ldr	r8, .L264+72
1341:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 3640              		.loc 1 1341 0
 3641 1f88 64721FE5 		ldr	r7, .L264+72
1339:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
 3642              		.loc 1 1339 0
 3643 1f8c 584098E5 		ldr	r4, [r8, #88]
 3644 1f90 8CC4D6E5 		ldrb	ip, [r6, #1164]	@ zero_extendqisi2
 3645 1f94 000054E3 		cmp	r4, #0
 3646 1f98 C440A003 		moveq	r4, #196
 3647 1f9c 4440A013 		movne	r4, #68
 3648 1fa0 0C2084E1 		orr	r2, r4, ip
 3649 1fa4 3010A0E3 		mov	r1, #48
 3650 1fa8 5230A0E3 		mov	r3, #82
 3651 1fac 0100A0E3 		mov	r0, #1
 3652 1fb0 FEFFFFEB 		bl	SensorSetIrisControl
1340:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3653              		.loc 1 1340 0
 3654 1fb4 7D0FA0E3 		mov	r0, #500
 3655 1fb8 FEFFFFEB 		bl	_tx_thread_sleep
1341:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 3656              		.loc 1 1341 0
 3657 1fbc 580097E5 		ldr	r0, [r7, #88]
 3658 1fc0 9C321FE5 		ldr	r3, .L264+72
 3659 1fc4 8C24D6E5 		ldrb	r2, [r6, #1164]	@ zero_extendqisi2
 3660 1fc8 000050E3 		cmp	r0, #0
 3661 1fcc C400A003 		moveq	r0, #196
 3662 1fd0 4400A013 		movne	r0, #68
 3663 1fd4 022080E1 		orr	r2, r0, r2
 3664 1fd8 583093E5 		ldr	r3, [r3, #88]
 3665 1fdc C8121FE5 		ldr	r1, .L264+56
 3666 1fe0 0400A0E3 		mov	r0, #4
 3667 1fe4 FEFFFFEB 		bl	CyU3PDebugPrint
1342:../uvc.c      **** 			                         		break;
 3668              		.loc 1 1342 0
 3669 1fe8 7CFEFFEA 		b	.L214
 3670              	.L216:
1334:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 3671              		.loc 1 1334 0
 3672 1fec C8E21FE5 		ldr	lr, .L264+72
 3673 1ff0 3010A0E3 		mov	r1, #48
 3674 1ff4 58209EE5 		ldr	r2, [lr, #88]
 3675 1ff8 5230A0E3 		mov	r3, #82
 3676 1ffc 000052E3 		cmp	r2, #0
 3677 2000 D420A003 		moveq	r2, #212
 3678 2004 5420A013 		movne	r2, #84
 3679 2008 0100A0E3 		mov	r0, #1
 3680 200c FEFFFFEB 		bl	SensorSetIrisControl
1335:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3681              		.loc 1 1335 0
 3682 2010 7D0FA0E3 		mov	r0, #500
 3683 2014 FEFFFFEB 		bl	_tx_thread_sleep
1336:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 3684              		.loc 1 1336 0
 3685 2018 F4121FE5 		ldr	r1, .L264+72
 3686 201c 0400A0E3 		mov	r0, #4
 3687 2020 582091E5 		ldr	r2, [r1, #88]
 3688 2024 583091E5 		ldr	r3, [r1, #88]
 3689 2028 000052E3 		cmp	r2, #0
 3690 202c 18131FE5 		ldr	r1, .L264+56
 3691 2030 D420A003 		moveq	r2, #212
 3692 2034 5420A013 		movne	r2, #84
 3693 2038 FEFFFFEB 		bl	CyU3PDebugPrint
1337:../uvc.c      **** 			                         		break;
 3694              		.loc 1 1337 0
 3695 203c 67FEFFEA 		b	.L214
 3696              	.L215:
1329:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 3697              		.loc 1 1329 0
 3698 2040 1C831FE5 		ldr	r8, .L264+72
 3699 2044 3010A0E3 		mov	r1, #48
 3700 2048 582098E5 		ldr	r2, [r8, #88]
 3701 204c 5230A0E3 		mov	r3, #82
 3702 2050 000052E3 		cmp	r2, #0
 3703 2054 E420A003 		moveq	r2, #228
 3704 2058 6420A013 		movne	r2, #100
 3705 205c 0100A0E3 		mov	r0, #1
 3706 2060 FEFFFFEB 		bl	SensorSetIrisControl
1330:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3707              		.loc 1 1330 0
 3708 2064 7D0FA0E3 		mov	r0, #500
 3709 2068 FEFFFFEB 		bl	_tx_thread_sleep
1331:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 3710              		.loc 1 1331 0
 3711 206c 48C31FE5 		ldr	ip, .L264+72
 3712 2070 5C131FE5 		ldr	r1, .L264+56
 3713 2074 58209CE5 		ldr	r2, [ip, #88]
 3714 2078 0400A0E3 		mov	r0, #4
 3715 207c 000052E3 		cmp	r2, #0
 3716 2080 58309CE5 		ldr	r3, [ip, #88]
 3717 2084 E420A003 		moveq	r2, #228
 3718 2088 6420A013 		movne	r2, #100
 3719 208c FEFFFFEB 		bl	CyU3PDebugPrint
1332:../uvc.c      **** 			                         		break;
 3720              		.loc 1 1332 0
 3721 2090 52FEFFEA 		b	.L214
 3722              	.LVL320:
 3723              	.L262:
1368:../uvc.c      **** 								 if(Data0 < 3){
 3724              		.loc 1 1368 0
 3725 2094 02005CE3 		cmp	ip, #2
1369:../uvc.c      **** 					 				 Data0 += 4;
 3726              		.loc 1 1369 0
 3727 2098 04608C92 		addls	r6, ip, #4
 3728 209c FF600692 		andls	r6, r6, #255
1368:../uvc.c      **** 								 if(Data0 < 3){
 3729              		.loc 1 1368 0
 3730 20a0 C8FEFF9A 		bls	.L228
1371:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 3731              		.loc 1 1371 0
 3732 20a4 0400A0E3 		mov	r0, #4
 3733 20a8 8C131FE5 		ldr	r1, .L264+64
 3734 20ac 14309DE5 		ldr	r3, [sp, #20]
 3735 20b0 FEFFFFEB 		bl	CyU3PDebugPrint
 3736              	.LVL321:
1372:../uvc.c      **** 									Data0 = 4; //set to default.
 3737              		.loc 1 1372 0
 3738 20b4 0460A0E3 		mov	r6, #4
 3739 20b8 C2FEFFEA 		b	.L228
 3740              	.LVL322:
 3741              	.L204:
1114:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 3742              		.loc 1 1114 0
 3743 20bc 0A20A0E1 		mov	r2, sl
 3744 20c0 0730A0E1 		mov	r3, r7
 3745 20c4 80C0A0E3 		mov	ip, #128
 3746 20c8 00E0A0E3 		mov	lr, #0
 3747 20cc 1B10A0E3 		mov	r1, #27
 3748 20d0 B0031FE5 		ldr	r0, .L264+68
 3749 20d4 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 3750 20d8 FEFFFFEB 		bl	cmdSet
 3751              	.LVL323:
1116:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
 3752              		.loc 1 1116 0
 3753 20dc 0730A0E1 		mov	r3, r7
 3754 20e0 14709DE5 		ldr	r7, [sp, #20]
 3755              	.LVL324:
 3756 20e4 01C0A0E3 		mov	ip, #1
 3757 20e8 1B10A0E3 		mov	r1, #27
 3758 20ec 0820A0E1 		mov	r2, r8
 3759 20f0 D0031FE5 		ldr	r0, .L264+68
 3760 20f4 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 3761 20f8 FEFFFFEB 		bl	cmdSet
 3762              	.LVL325:
 3763 20fc ACFDFFEA 		b	.L203
 3764              	.LVL326:
 3765              	.L263:
 807:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 3766              		.loc 1 807 0
 3767 2100 E8631FE5 		ldr	r6, .L264+60
 805:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 3768              		.loc 1 805 0
 3769 2104 0430A0E1 		mov	r3, r4
 3770 2108 0400A0E3 		mov	r0, #4
 3771 210c F0131FE5 		ldr	r1, .L264+64
 3772 2110 FEFFFFEB 		bl	CyU3PDebugPrint
 3773              	.LVL327:
 807:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 3774              		.loc 1 807 0
 3775 2114 0030A0E3 		mov	r3, #0
 806:../uvc.c      **** 							sendData = 0; //set back to default
 3776              		.loc 1 806 0
 3777 2118 0340A0E1 		mov	r4, r3
 807:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 3778              		.loc 1 807 0
 3779 211c 2D34C6E5 		strb	r3, [r6, #1069]
 3780 2120 5FFFFFEA 		b	.L157
 3781              	.LVL328:
 3782              	.L261:
1089:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 3783              		.loc 1 1089 0
 3784 2124 18E09DE5 		ldr	lr, [sp, #24]
 3785 2128 0730A0E1 		mov	r3, r7
 3786 212c 1910A0E3 		mov	r1, #25
 3787 2130 0070A0E3 		mov	r7, #0
 3788              	.LVL329:
 3789 2134 0920A0E1 		mov	r2, r9
 3790 2138 18041FE5 		ldr	r0, .L264+68
 3791 213c 00E08DE5 		str	lr, [sp, #0]
 3792 2140 04708DE5 		str	r7, [sp, #4]
 3793 2144 FEFFFFEB 		bl	cmdSet
 3794              	.LVL330:
 3795 2148 67FEFFEA 		b	.L202
 3796              	.LVL331:
 3797              	.L251:
 3798 214c 28041FE5 		ldr	r0, .L264+72
 3799 2150 BCFCFFEA 		b	.L154
 3800              	.LVL332:
 3801              	.L233:
 734:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 3802              		.loc 1 734 0
 3803 2154 0030A0E3 		mov	r3, #0
 3804 2158 37FDFFEA 		b	.L245
 3805              	.LVL333:
 3806              	.L231:
 3807 215c 38041FE5 		ldr	r0, .L264+72
 3808 2160 0030A0E3 		mov	r3, #0
 3809 2164 B0FCFFEA 		b	.L244
 3810              		.cfi_endproc
 3811              	.LFE3:
 3813              		.align	2
 3814              		.global	CTControlHandle
 3816              	CTControlHandle:
 3817              	.LFB4:
1442:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3818              		.loc 1 1442 0
 3819              		.cfi_startproc
 3820              		@ args = 0, pretend = 0, frame = 64
 3821              		@ frame_needed = 0, uses_anonymous_args = 0
 3822              	.LVL334:
 3823 2168 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3824              	.LCFI17:
 3825              		.cfi_def_cfa_offset 36
1461:../uvc.c      ****     reqData = bRequest;
 3826              		.loc 1 1461 0
 3827 216c 64A99FE5 		ldr	sl, .L351
 3828              		.cfi_offset 14, -4
 3829              		.cfi_offset 11, -8
 3830              		.cfi_offset 10, -12
 3831              		.cfi_offset 9, -16
 3832              		.cfi_offset 8, -20
 3833              		.cfi_offset 7, -24
 3834              		.cfi_offset 6, -28
 3835              		.cfi_offset 5, -32
 3836              		.cfi_offset 4, -36
1453:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3837              		.loc 1 1453 0
 3838 2170 64899FE5 		ldr	r8, .L351+4
1461:../uvc.c      ****     reqData = bRequest;
 3839              		.loc 1 1461 0
 3840 2174 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
1453:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3841              		.loc 1 1453 0
 3842 2178 8090A0E1 		mov	r9, r0, asl #1
 3843 217c 002089E0 		add	r2, r9, r0
 3844 2180 822188E0 		add	r2, r8, r2, asl #3
1463:../uvc.c      ****     switch (bRequest)
 3845              		.loc 1 1463 0
 3846 2184 830055E3 		cmp	r5, #131
1442:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3847              		.loc 1 1442 0
 3848 2188 5CD04DE2 		sub	sp, sp, #92
 3849              	.LCFI18:
 3850              		.cfi_def_cfa_offset 128
1442:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3851              		.loc 1 1442 0
 3852 218c 0060A0E1 		mov	r6, r0
1453:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3853              		.loc 1 1453 0
 3854 2190 2F35D2E5 		ldrb	r3, [r2, #1327]	@ zero_extendqisi2
 3855              	.LVL335:
1454:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3856              		.loc 1 1454 0
 3857 2194 20B5D2E5 		ldrb	fp, [r2, #1312]	@ zero_extendqisi2
 3858              	.LVL336:
1456:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 3859              		.loc 1 1456 0
 3860 2198 2275D2E5 		ldrb	r7, [r2, #1314]	@ zero_extendqisi2
 3861              	.LVL337:
1463:../uvc.c      ****     switch (bRequest)
 3862              		.loc 1 1463 0
 3863 219c 7600000A 		beq	.L271
 3864 21a0 2100009A 		bls	.L346
 3865 21a4 850055E3 		cmp	r5, #133
 3866 21a8 5900000A 		beq	.L273
 3867 21ac 4E00003A 		bcc	.L272
 3868 21b0 860055E3 		cmp	r5, #134
 3869 21b4 8000000A 		beq	.L274
 3870 21b8 870055E3 		cmp	r5, #135
 3871 21bc 7600000A 		beq	.L347
 3872              	.L267:
1670:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 3873              		.loc 1 1670 0
 3874 21c0 0000A0E3 		mov	r0, #0
 3875              	.LVL338:
 3876 21c4 0110A0E3 		mov	r1, #1
 3877 21c8 0020A0E1 		mov	r2, r0
 3878 21cc FEFFFFEB 		bl	CyU3PUsbStall
 3879              	.LVL339:
 3880 21d0 08499FE5 		ldr	r4, .L351+8
1671:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3881              		.loc 1 1671 0
 3882 21d4 0620A0E1 		mov	r2, r6
 3883 21d8 0400A0E3 		mov	r0, #4
 3884 21dc 00199FE5 		ldr	r1, .L351+12
 3885 21e0 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 3886 21e4 FEFFFFEB 		bl	CyU3PDebugPrint
1672:../uvc.c      **** 			  break;
 3887              		.loc 1 1672 0
 3888 21e8 FFC0A0E3 		mov	ip, #255
 3889 21ec 0C60A0E1 		mov	r6, ip
 3890 21f0 0C80A0E1 		mov	r8, ip
 3891              	.LVL340:
 3892              	.L277:
1676:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 3893              		.loc 1 1676 0
 3894 21f4 5EE0D4E5 		ldrb	lr, [r4, #94]	@ zero_extendqisi2
 3895 21f8 08C08DE5 		str	ip, [sp, #8]
 3896 21fc E4189FE5 		ldr	r1, .L351+16
 3897 2200 FFC0A0E3 		mov	ip, #255
 3898 2204 0520A0E1 		mov	r2, r5
 3899 2208 0830A0E1 		mov	r3, r8
 3900 220c 0400A0E3 		mov	r0, #4
 3901 2210 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 3902 2214 0CC08DE5 		str	ip, [sp, #12]
 3903 2218 10E08DE5 		str	lr, [sp, #16]
 3904 221c 14708DE5 		str	r7, [sp, #20]
 3905 2220 FEFFFFEB 		bl	CyU3PDebugPrint
1677:../uvc.c      **** }
 3906              		.loc 1 1677 0
 3907 2224 5CD08DE2 		add	sp, sp, #92
 3908 2228 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3909              	.LVL341:
 3910              	.L346:
1463:../uvc.c      ****     switch (bRequest)
 3911              		.loc 1 1463 0
 3912 222c 810055E3 		cmp	r5, #129
 3913 2230 4200000A 		beq	.L269
 3914 2234 1100009A 		bls	.L348
1492:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3915              		.loc 1 1492 0
 3916 2238 A0489FE5 		ldr	r4, .L351+8
 3917 223c 2315D2E5 		ldrb	r1, [r2, #1315]	@ zero_extendqisi2
1493:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3918              		.loc 1 1493 0
 3919 2240 2465D2E5 		ldrb	r6, [r2, #1316]	@ zero_extendqisi2
1494:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3920              		.loc 1 1494 0
 3921 2244 0A0050E3 		cmp	r0, #10
1492:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3922              		.loc 1 1492 0
 3923 2248 5C10C4E5 		strb	r1, [r4, #92]
1493:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3924              		.loc 1 1493 0
 3925 224c 5D60C4E5 		strb	r6, [r4, #93]
1494:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3926              		.loc 1 1494 0
 3927 2250 2C00000A 		beq	.L345
 3928              	.LVL342:
 3929              	.L284:
1528:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3930              		.loc 1 1528 0
 3931 2254 00E0A0E3 		mov	lr, #0
 3932 2258 5EE0C4E5 		strb	lr, [r4, #94]
 3933              	.L285:
1529:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3934              		.loc 1 1529 0
 3935 225c 0030A0E3 		mov	r3, #0
1530:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3936              		.loc 1 1530 0
 3937 2260 0700A0E1 		mov	r0, r7
 3938              	.LVL343:
 3939 2264 80189FE5 		ldr	r1, .L351+20
1532:../uvc.c      **** 			  break;
 3940              		.loc 1 1532 0
 3941 2268 FF60A0E3 		mov	r6, #255
1529:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3942              		.loc 1 1529 0
 3943 226c 5F30C4E5 		strb	r3, [r4, #95]
1532:../uvc.c      **** 			  break;
 3944              		.loc 1 1532 0
 3945 2270 0680A0E1 		mov	r8, r6
1530:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3946              		.loc 1 1530 0
 3947 2274 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3948              	.LVL344:
 3949 2278 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1532:../uvc.c      **** 			  break;
 3950              		.loc 1 1532 0
 3951 227c DCFFFFEA 		b	.L277
 3952              	.LVL345:
 3953              	.L348:
1463:../uvc.c      ****     switch (bRequest)
 3954              		.loc 1 1463 0
 3955 2280 010055E3 		cmp	r5, #1
 3956 2284 CDFFFF1A 		bne	.L267
1534:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 3957              		.loc 1 1534 0
 3958 2288 50489FE5 		ldr	r4, .L351+8
 3959 228c 56208DE2 		add	r2, sp, #86
 3960 2290 2000A0E3 		mov	r0, #32
 3961              	.LVL346:
 3962 2294 5C1084E2 		add	r1, r4, #92
 3963 2298 2C308DE5 		str	r3, [sp, #44]
 3964 229c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3965              	.LVL347:
1536:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3966              		.loc 1 1536 0
 3967 22a0 5C00D4E5 		ldrb	r0, [r4, #92]	@ zero_extendqisi2
1537:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3968              		.loc 1 1537 0
 3969 22a4 5DC0D4E5 		ldrb	ip, [r4, #93]	@ zero_extendqisi2
1540:../uvc.c      **** 			  switch(CtrlID)
 3970              		.loc 1 1540 0
 3971 22a8 012046E2 		sub	r2, r6, #1
1536:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3972              		.loc 1 1536 0
 3973 22ac 30008DE5 		str	r0, [sp, #48]
 3974              	.LVL348:
1537:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3975              		.loc 1 1537 0
 3976 22b0 34C08DE5 		str	ip, [sp, #52]
 3977              	.LVL349:
1540:../uvc.c      **** 			  switch(CtrlID)
 3978              		.loc 1 1540 0
 3979 22b4 2C309DE5 		ldr	r3, [sp, #44]
 3980 22b8 090052E3 		cmp	r2, #9
 3981 22bc 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3982 22c0 550100EA 		b	.L286
 3983              	.L291:
 3984 22c4 D8270000 		.word	.L287
 3985 22c8 1C280000 		.word	.L286
 3986 22cc E8240000 		.word	.L288
 3987 22d0 1C280000 		.word	.L286
 3988 22d4 1C280000 		.word	.L286
 3989 22d8 1C280000 		.word	.L286
 3990 22dc 64240000 		.word	.L289
 3991 22e0 1C280000 		.word	.L286
 3992 22e4 1C280000 		.word	.L286
 3993 22e8 E8230000 		.word	.L290
 3994              	.LVL350:
 3995              	.L272:
1510:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3996              		.loc 1 1510 0
 3997 22ec EC479FE5 		ldr	r4, .L351+8
 3998 22f0 2785D2E5 		ldrb	r8, [r2, #1319]	@ zero_extendqisi2
1511:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3999              		.loc 1 1511 0
 4000 22f4 2825D2E5 		ldrb	r2, [r2, #1320]	@ zero_extendqisi2
1512:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4001              		.loc 1 1512 0
 4002 22f8 0A0050E3 		cmp	r0, #10
1510:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 4003              		.loc 1 1510 0
 4004 22fc 5C80C4E5 		strb	r8, [r4, #92]
1511:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4005              		.loc 1 1511 0
 4006 2300 5D20C4E5 		strb	r2, [r4, #93]
1512:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4007              		.loc 1 1512 0
 4008 2304 D2FFFF1A 		bne	.L284
 4009              	.LVL351:
 4010              	.L345:
1527:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4011              		.loc 1 1527 0 discriminator 1
 4012 2308 0110A0E3 		mov	r1, #1
 4013 230c 5E10C4E5 		strb	r1, [r4, #94]
 4014 2310 D1FFFFEA 		b	.L285
 4015              	.LVL352:
 4016              	.L273:
1467:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 4017              		.loc 1 1467 0
 4018 2314 C4479FE5 		ldr	r4, .L351+8
1468:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 4019              		.loc 1 1468 0
 4020 2318 0030A0E3 		mov	r3, #0
 4021              	.LVL353:
1469:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4022              		.loc 1 1469 0
 4023 231c 0200A0E3 		mov	r0, #2
 4024              	.LVL354:
 4025 2320 5C1084E2 		add	r1, r4, #92
1471:../uvc.c      **** 			  break;
 4026              		.loc 1 1471 0
 4027 2324 FF60A0E3 		mov	r6, #255
1467:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 4028              		.loc 1 1467 0
 4029 2328 5C70C4E5 		strb	r7, [r4, #92]
1468:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 4030              		.loc 1 1468 0
 4031 232c 5D30C4E5 		strb	r3, [r4, #93]
1471:../uvc.c      **** 			  break;
 4032              		.loc 1 1471 0
 4033 2330 0680A0E1 		mov	r8, r6
1469:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4034              		.loc 1 1469 0
 4035 2334 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4036              	.LVL355:
 4037 2338 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1471:../uvc.c      **** 			  break;
 4038              		.loc 1 1471 0
 4039 233c ACFFFFEA 		b	.L277
 4040              	.LVL356:
 4041              	.L269:
1477:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 4042              		.loc 1 1477 0
 4043 2340 98479FE5 		ldr	r4, .L351+8
 4044 2344 2DA5D2E5 		ldrb	sl, [r2, #1325]	@ zero_extendqisi2
1478:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4045              		.loc 1 1478 0
 4046 2348 2EC5D2E5 		ldrb	ip, [r2, #1326]	@ zero_extendqisi2
1479:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4047              		.loc 1 1479 0
 4048 234c 0080A0E3 		mov	r8, #0
1485:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4049              		.loc 1 1485 0
 4050 2350 0700A0E1 		mov	r0, r7
 4051              	.LVL357:
 4052 2354 5C1084E2 		add	r1, r4, #92
1490:../uvc.c      **** 			  break;
 4053              		.loc 1 1490 0
 4054 2358 FF60A0E3 		mov	r6, #255
1478:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4055              		.loc 1 1478 0
 4056 235c 5DC0C4E5 		strb	ip, [r4, #93]
1479:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4057              		.loc 1 1479 0
 4058 2360 5E80C4E5 		strb	r8, [r4, #94]
1480:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4059              		.loc 1 1480 0
 4060 2364 5F80C4E5 		strb	r8, [r4, #95]
 4061              	.LVL358:
1477:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 4062              		.loc 1 1477 0
 4063 2368 5CA0C4E5 		strb	sl, [r4, #92]
1490:../uvc.c      **** 			  break;
 4064              		.loc 1 1490 0
 4065 236c 0680A0E1 		mov	r8, r6
1485:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4066              		.loc 1 1485 0
 4067 2370 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4068              	.LVL359:
 4069 2374 0AC0A0E1 		mov	ip, sl
1490:../uvc.c      **** 			  break;
 4070              		.loc 1 1490 0
 4071 2378 9DFFFFEA 		b	.L277
 4072              	.LVL360:
 4073              	.L271:
1501:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 4074              		.loc 1 1501 0
 4075 237c 5C479FE5 		ldr	r4, .L351+8
 4076 2380 2535D2E5 		ldrb	r3, [r2, #1317]	@ zero_extendqisi2
 4077              	.LVL361:
1502:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4078              		.loc 1 1502 0
 4079 2384 26E5D2E5 		ldrb	lr, [r2, #1318]	@ zero_extendqisi2
1503:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4080              		.loc 1 1503 0
 4081 2388 0A0050E3 		cmp	r0, #10
1501:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 4082              		.loc 1 1501 0
 4083 238c 5C30C4E5 		strb	r3, [r4, #92]
1502:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4084              		.loc 1 1502 0
 4085 2390 5DE0C4E5 		strb	lr, [r4, #93]
1503:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4086              		.loc 1 1503 0
 4087 2394 AEFFFF1A 		bne	.L284
 4088 2398 DAFFFFEA 		b	.L345
 4089              	.LVL362:
 4090              	.L347:
1525:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 4091              		.loc 1 1525 0
 4092 239c 3C479FE5 		ldr	r4, .L351+8
 4093 23a0 2B65D2E5 		ldrb	r6, [r2, #1323]	@ zero_extendqisi2
1526:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4094              		.loc 1 1526 0
 4095 23a4 2CC5D2E5 		ldrb	ip, [r2, #1324]	@ zero_extendqisi2
1527:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4096              		.loc 1 1527 0
 4097 23a8 0A0050E3 		cmp	r0, #10
1525:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 4098              		.loc 1 1525 0
 4099 23ac 5C60C4E5 		strb	r6, [r4, #92]
1526:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4100              		.loc 1 1526 0
 4101 23b0 5DC0C4E5 		strb	ip, [r4, #93]
1527:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4102              		.loc 1 1527 0
 4103 23b4 A6FFFF1A 		bne	.L284
 4104 23b8 D2FFFFEA 		b	.L345
 4105              	.L274:
1519:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 4106              		.loc 1 1519 0
 4107 23bc 1C479FE5 		ldr	r4, .L351+8
 4108 23c0 2905D2E5 		ldrb	r0, [r2, #1321]	@ zero_extendqisi2
 4109              	.LVL363:
 4110 23c4 0410A0E1 		mov	r1, r4
 4111 23c8 5C00E1E5 		strb	r0, [r1, #92]!
1523:../uvc.c      **** 			  break;
 4112              		.loc 1 1523 0
 4113 23cc FF60A0E3 		mov	r6, #255
1520:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4114              		.loc 1 1520 0
 4115 23d0 0100A0E3 		mov	r0, #1
 4116 23d4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4117              	.LVL364:
1523:../uvc.c      **** 			  break;
 4118              		.loc 1 1523 0
 4119 23d8 0680A0E1 		mov	r8, r6
1520:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4120              		.loc 1 1520 0
 4121 23dc 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1523:../uvc.c      **** 			  break;
 4122              		.loc 1 1523 0
 4123 23e0 0170A0E3 		mov	r7, #1
 4124 23e4 82FFFFEA 		b	.L277
 4125              	.LVL365:
 4126              	.L290:
1649:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4127              		.loc 1 1649 0
 4128 23e8 00679FE5 		ldr	r6, .L351+24
 4129 23ec 0010E0E3 		mvn	r1, #0
 4130 23f0 1C0096E5 		ldr	r0, [r6, #28]
 4131 23f4 2C308DE5 		str	r3, [sp, #44]
 4132 23f8 FEFFFFEB 		bl	_txe_mutex_get
1650:../uvc.c      **** 					  if(getData == 1)
 4133              		.loc 1 1650 0
 4134 23fc 30E09DE5 		ldr	lr, [sp, #48]
 4135 2400 2C309DE5 		ldr	r3, [sp, #44]
 4136 2404 01005EE3 		cmp	lr, #1
 4137 2408 AA01000A 		beq	.L349
1652:../uvc.c      **** 					  else if(getData == 0xff)
 4138              		.loc 1 1652 0
 4139 240c FF005EE3 		cmp	lr, #255
 4140 2410 9F01000A 		beq	.L350
1655:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
 4141              		.loc 1 1655 0
 4142 2414 0080A0E3 		mov	r8, #0
 4143 2418 0600A0E1 		mov	r0, r6
 4144 241c 2310A0E3 		mov	r1, #35
 4145 2420 0B20A0E1 		mov	r2, fp
 4146 2424 00808DE5 		str	r8, [sp, #0]
 4147 2428 04808DE5 		str	r8, [sp, #4]
 4148 242c FEFFFFEB 		bl	cmdSet
 4149              	.L343:
1658:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4150              		.loc 1 1658 0
 4151 2430 1C0096E5 		ldr	r0, [r6, #28]
 4152 2434 FEFFFFEB 		bl	_txe_mutex_put
1660:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 4153              		.loc 1 1660 0
 4154 2438 30809DE5 		ldr	r8, [sp, #48]
 4155 243c 34609DE5 		ldr	r6, [sp, #52]
 4156 2440 5EC0D4E5 		ldrb	ip, [r4, #94]	@ zero_extendqisi2
 4157 2444 0400A0E3 		mov	r0, #4
 4158 2448 A4169FE5 		ldr	r1, .L351+28
 4159 244c 0820A0E1 		mov	r2, r8
 4160 2450 0630A0E1 		mov	r3, r6
 4161 2454 00C08DE5 		str	ip, [sp, #0]
 4162 2458 FEFFFFEB 		bl	CyU3PDebugPrint
1661:../uvc.c      **** 					  break;
 4163              		.loc 1 1661 0
 4164 245c FFC0A0E3 		mov	ip, #255
 4165 2460 63FFFFEA 		b	.L277
 4166              	.LVL366:
 4167              	.L289:
1626:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 4168              		.loc 1 1626 0
 4169 2464 4585D8E5 		ldrb	r8, [r8, #1349]	@ zero_extendqisi2
 4170 2468 010058E3 		cmp	r8, #1
 4171 246c 08005813 		cmpne	r8, #8
 4172 2470 0000A013 		movne	r0, #0
 4173 2474 0100A003 		moveq	r0, #1
 4174 2478 8101001A 		bne	.L340
 4175              	.LVL367:
1629:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4176              		.loc 1 1629 0
 4177 247c 6C869FE5 		ldr	r8, .L351+24
 4178 2480 0010E0E3 		mvn	r1, #0
 4179 2484 1C0098E5 		ldr	r0, [r8, #28]
 4180 2488 2C308DE5 		str	r3, [sp, #44]
 4181 248c FEFFFFEB 		bl	_txe_mutex_get
1630:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 4182              		.loc 1 1630 0
 4183 2490 30A09DE5 		ldr	sl, [sp, #48]
 4184 2494 2210A0E3 		mov	r1, #34
 4185 2498 0B20A0E1 		mov	r2, fp
 4186 249c 2C309DE5 		ldr	r3, [sp, #44]
 4187 24a0 00C0A0E3 		mov	ip, #0
 4188 24a4 0800A0E1 		mov	r0, r8
 4189 24a8 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 4190 24ac FEFFFFEB 		bl	cmdSet
1631:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4191              		.loc 1 1631 0
 4192 24b0 1C0098E5 		ldr	r0, [r8, #28]
 4193 24b4 FEFFFFEB 		bl	_txe_mutex_put
1634:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 4194              		.loc 1 1634 0
 4195 24b8 1C069FE5 		ldr	r0, .L351+4
1635:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 4196              		.loc 1 1635 0
 4197 24bc 34209DE5 		ldr	r2, [sp, #52]
1634:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 4198              		.loc 1 1634 0
 4199 24c0 061089E0 		add	r1, r9, r6
 4200 24c4 813180E0 		add	r3, r0, r1, asl #3
1636:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 4201              		.loc 1 1636 0
 4202 24c8 0160A0E3 		mov	r6, #1
1634:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 4203              		.loc 1 1634 0
 4204 24cc 2DA5C3E5 		strb	sl, [r3, #1325]
1635:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 4205              		.loc 1 1635 0
 4206 24d0 2E25C3E5 		strb	r2, [r3, #1326]
1636:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 4207              		.loc 1 1636 0
 4208 24d4 3065C3E5 		strb	r6, [r3, #1328]
 4209              	.LVL368:
 4210              	.L341:
1638:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4211              		.loc 1 1638 0
 4212 24d8 5C80D4E5 		ldrb	r8, [r4, #92]	@ zero_extendqisi2
 4213 24dc 5D60D4E5 		ldrb	r6, [r4, #93]	@ zero_extendqisi2
1643:../uvc.c      **** 					  break;
 4214              		.loc 1 1643 0
 4215 24e0 FFC0A0E3 		mov	ip, #255
 4216 24e4 42FFFFEA 		b	.L277
 4217              	.LVL369:
 4218              	.L288:
1592:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 4219              		.loc 1 1592 0
 4220 24e8 4505D8E5 		ldrb	r0, [r8, #1349]	@ zero_extendqisi2
 4221 24ec 010050E3 		cmp	r0, #1
 4222 24f0 04005013 		cmpne	r0, #4
 4223 24f4 5D01001A 		bne	.L298
1591:../uvc.c      **** 					  value = (value << 8)|Data0;
 4224              		.loc 1 1591 0
 4225 24f8 30109DE5 		ldr	r1, [sp, #48]
 4226 24fc 34E09DE5 		ldr	lr, [sp, #52]
 4227 2500 0E2481E1 		orr	r2, r1, lr, asl #8
1593:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 4228              		.loc 1 1593 0
 4229 2504 F90052E3 		cmp	r2, #249
 4230 2508 5801008A 		bhi	.L298
1598:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4231              		.loc 1 1598 0
 4232 250c C8A042E2 		sub	sl, r2, #200
 4233 2510 0AC8A0E1 		mov	ip, sl, asl #16
 4234 2514 3CC08DE5 		str	ip, [sp, #60]
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4235              		.loc 1 1600 0
 4236 2518 27A062E2 		rsb	sl, r2, #39
 4237 251c 38A08DE5 		str	sl, [sp, #56]
 4238 2520 3CA09DE5 		ldr	sl, [sp, #60]
 4239 2524 C81062E2 		rsb	r1, r2, #200
 4240 2528 C80052E3 		cmp	r2, #200
1598:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4241              		.loc 1 1598 0
 4242 252c 640042E2 		sub	r0, r2, #100
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4243              		.loc 1 1600 0
 4244 2530 0118A0E1 		mov	r1, r1, asl #16
 4245 2534 64E062E2 		rsb	lr, r2, #100
 4246 2538 2A18A081 		movhi	r1, sl, lsr #16
 4247 253c 2118A091 		movls	r1, r1, lsr #16
1598:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4248              		.loc 1 1598 0
 4249 2540 00C8A0E1 		mov	ip, r0, asl #16
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4250              		.loc 1 1600 0
 4251 2544 640052E3 		cmp	r2, #100
 4252 2548 0E08A0E1 		mov	r0, lr, asl #16
 4253 254c 2C08A081 		movhi	r0, ip, lsr #16
 4254 2550 38C09DE5 		ldr	ip, [sp, #56]
1598:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4255              		.loc 1 1598 0
 4256 2554 14A042E2 		sub	sl, r2, #20
 4257 2558 38A08DE5 		str	sl, [sp, #56]
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4258              		.loc 1 1600 0
 4259 255c 2008A091 		movls	r0, r0, lsr #16
 4260 2560 14A062E2 		rsb	sl, r2, #20
 4261 2564 3CA08DE5 		str	sl, [sp, #60]
1598:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4262              		.loc 1 1598 0
 4263 2568 27E042E2 		sub	lr, r2, #39
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4264              		.loc 1 1600 0
 4265 256c 000051E1 		cmp	r1, r0
 4266 2570 01A0A031 		movcc	sl, r1
 4267 2574 00A0A021 		movcs	sl, r0
 4268 2578 0CC8A0E1 		mov	ip, ip, asl #16
 4269 257c 270052E3 		cmp	r2, #39
1598:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4270              		.loc 1 1598 0
 4271 2580 0EE8A0E1 		mov	lr, lr, asl #16
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4272              		.loc 1 1600 0
 4273 2584 2CE8A091 		movls	lr, ip, lsr #16
 4274 2588 68C59FE5 		ldr	ip, .L351+32
 4275 258c 20A08DE5 		str	sl, [sp, #32]
 4276 2590 01A06CE0 		rsb	sl, ip, r1
 4277 2594 2EE8A081 		movhi	lr, lr, lsr #16
 4278 2598 00C07AE2 		rsbs	ip, sl, #0
 4279 259c 0AC0ACE0 		adc	ip, ip, sl
1598:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4280              		.loc 1 1598 0
 4281 25a0 38A09DE5 		ldr	sl, [sp, #56]
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4282              		.loc 1 1600 0
 4283 25a4 44C08DE5 		str	ip, [sp, #68]
 4284              	.LVL370:
1598:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4285              		.loc 1 1598 0
 4286 25a8 0AC8A0E1 		mov	ip, sl, asl #16
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4287              		.loc 1 1600 0
 4288 25ac 3CA09DE5 		ldr	sl, [sp, #60]
1598:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4289              		.loc 1 1598 0
 4290 25b0 4CC08DE5 		str	ip, [sp, #76]
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4291              		.loc 1 1600 0
 4292 25b4 0AC8A0E1 		mov	ip, sl, asl #16
1598:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4293              		.loc 1 1598 0
 4294 25b8 0AA042E2 		sub	sl, r2, #10
 4295 25bc 48A08DE5 		str	sl, [sp, #72]
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4296              		.loc 1 1600 0
 4297 25c0 20A09DE5 		ldr	sl, [sp, #32]
 4298 25c4 3CC08DE5 		str	ip, [sp, #60]
 4299 25c8 0A005EE1 		cmp	lr, sl
 4300 25cc 0EA0A031 		movcc	sl, lr
 4301 25d0 0AC062E2 		rsb	ip, r2, #10
 4302 25d4 40C08DE5 		str	ip, [sp, #64]
 4303 25d8 38A08DE5 		str	sl, [sp, #56]
 4304 25dc 3CC09DE5 		ldr	ip, [sp, #60]
 4305 25e0 4CA09DE5 		ldr	sl, [sp, #76]
 4306 25e4 140052E3 		cmp	r2, #20
 4307 25e8 2CA8A091 		movls	sl, ip, lsr #16
 4308 25ec 2AA8A081 		movhi	sl, sl, lsr #16
 4309 25f0 44C09DE5 		ldr	ip, [sp, #68]
 4310 25f4 010050E1 		cmp	r0, r1
1598:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4311              		.loc 1 1598 0
 4312 25f8 48109DE5 		ldr	r1, [sp, #72]
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4313              		.loc 1 1600 0
 4314 25fc 01C0A033 		movcc	ip, #1
 4315 2600 3CA08DE5 		str	sl, [sp, #60]
 4316 2604 24C08DE5 		str	ip, [sp, #36]
1598:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4317              		.loc 1 1598 0
 4318 2608 01A8A0E1 		mov	sl, r1, asl #16
 4319 260c 05C042E2 		sub	ip, r2, #5
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4320              		.loc 1 1600 0
 4321 2610 051062E2 		rsb	r1, r2, #5
1598:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4322              		.loc 1 1598 0
 4323 2614 48A08DE5 		str	sl, [sp, #72]
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4324              		.loc 1 1600 0
 4325 2618 40009DE5 		ldr	r0, [sp, #64]
 4326 261c 38A09DE5 		ldr	sl, [sp, #56]
1598:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4327              		.loc 1 1598 0
 4328 2620 40C08DE5 		str	ip, [sp, #64]
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4329              		.loc 1 1600 0
 4330 2624 3CC09DE5 		ldr	ip, [sp, #60]
 4331 2628 4C108DE5 		str	r1, [sp, #76]
 4332 262c 48109DE5 		ldr	r1, [sp, #72]
 4333 2630 0008A0E1 		mov	r0, r0, asl #16
 4334 2634 0A005CE1 		cmp	ip, sl
 4335 2638 0AC0A021 		movcs	ip, sl
 4336 263c 0A0052E3 		cmp	r2, #10
 4337 2640 20A09DE5 		ldr	sl, [sp, #32]
 4338 2644 2108A081 		movhi	r0, r1, lsr #16
 4339 2648 2008A091 		movls	r0, r0, lsr #16
 4340 264c 48008DE5 		str	r0, [sp, #72]
 4341 2650 24009DE5 		ldr	r0, [sp, #36]
 4342 2654 0A005EE1 		cmp	lr, sl
 4343 2658 0200A033 		movcc	r0, #2
1598:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4344              		.loc 1 1598 0
 4345 265c 02E042E2 		sub	lr, r2, #2
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4346              		.loc 1 1600 0
 4347 2660 44C08DE5 		str	ip, [sp, #68]
 4348 2664 24008DE5 		str	r0, [sp, #36]
1598:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4349              		.loc 1 1598 0
 4350 2668 40C09DE5 		ldr	ip, [sp, #64]
 4351 266c 1CE08DE5 		str	lr, [sp, #28]
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4352              		.loc 1 1600 0
 4353 2670 44009DE5 		ldr	r0, [sp, #68]
 4354 2674 48E09DE5 		ldr	lr, [sp, #72]
 4355 2678 4C109DE5 		ldr	r1, [sp, #76]
 4356 267c 02A062E2 		rsb	sl, r2, #2
 4357 2680 00005EE1 		cmp	lr, r0
 4358 2684 00E0A021 		movcs	lr, r0
1598:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4359              		.loc 1 1598 0
 4360 2688 0CC8A0E1 		mov	ip, ip, asl #16
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4361              		.loc 1 1600 0
 4362 268c 050052E3 		cmp	r2, #5
 4363 2690 40A08DE5 		str	sl, [sp, #64]
 4364 2694 0118A0E1 		mov	r1, r1, asl #16
 4365 2698 3CA09DE5 		ldr	sl, [sp, #60]
 4366 269c 2C18A081 		movhi	r1, ip, lsr #16
 4367 26a0 38C09DE5 		ldr	ip, [sp, #56]
 4368 26a4 4CE08DE5 		str	lr, [sp, #76]
 4369 26a8 24009DE5 		ldr	r0, [sp, #36]
 4370 26ac 40E09DE5 		ldr	lr, [sp, #64]
 4371 26b0 2118A091 		movls	r1, r1, lsr #16
 4372 26b4 0C005AE1 		cmp	sl, ip
 4373 26b8 20108DE5 		str	r1, [sp, #32]
 4374 26bc 0300A033 		movcc	r0, #3
 4375 26c0 38008DE5 		str	r0, [sp, #56]
 4376 26c4 4CA09DE5 		ldr	sl, [sp, #76]
 4377 26c8 0E08A0E1 		mov	r0, lr, asl #16
 4378 26cc 20E09DE5 		ldr	lr, [sp, #32]
1598:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4379              		.loc 1 1598 0
 4380 26d0 1C109DE5 		ldr	r1, [sp, #28]
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4381              		.loc 1 1600 0
 4382 26d4 0A005EE1 		cmp	lr, sl
 4383 26d8 0AE0A021 		movcs	lr, sl
 4384 26dc 44C09DE5 		ldr	ip, [sp, #68]
 4385 26e0 48A09DE5 		ldr	sl, [sp, #72]
 4386 26e4 020052E3 		cmp	r2, #2
1598:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4387              		.loc 1 1598 0
 4388 26e8 0118A0E1 		mov	r1, r1, asl #16
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4389              		.loc 1 1600 0
 4390 26ec 2018A091 		movls	r1, r0, lsr #16
 4391 26f0 38009DE5 		ldr	r0, [sp, #56]
 4392 26f4 2118A081 		movhi	r1, r1, lsr #16
 4393 26f8 0C005AE1 		cmp	sl, ip
 4394 26fc 0400A033 		movcc	r0, #4
 4395 2700 40008DE5 		str	r0, [sp, #64]
1598:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4396              		.loc 1 1598 0
 4397 2704 010042E2 		sub	r0, r2, #1
 4398 2708 38008DE5 		str	r0, [sp, #56]
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4399              		.loc 1 1600 0
 4400 270c 4CA09DE5 		ldr	sl, [sp, #76]
 4401 2710 20009DE5 		ldr	r0, [sp, #32]
 4402 2714 01C062E2 		rsb	ip, r2, #1
 4403 2718 3CC08DE5 		str	ip, [sp, #60]
 4404 271c 0A0050E1 		cmp	r0, sl
1607:../uvc.c      **** 						  shutter = shutter+index;
 4405              		.loc 1 1607 0
 4406 2720 38A09DE5 		ldr	sl, [sp, #56]
 4407 2724 3C009DE5 		ldr	r0, [sp, #60]
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4408              		.loc 1 1600 0
 4409 2728 40C09DE5 		ldr	ip, [sp, #64]
 4410 272c 05C0A033 		movcc	ip, #5
1607:../uvc.c      **** 						  shutter = shutter+index;
 4411              		.loc 1 1607 0
 4412 2730 010052E3 		cmp	r2, #1
 4413 2734 0028A091 		movls	r2, r0, asl #16
 4414 2738 0A28A081 		movhi	r2, sl, asl #16
 4415 273c 0E0051E1 		cmp	r1, lr
 4416 2740 01A0A031 		movcc	sl, r1
 4417 2744 0EA0A021 		movcs	sl, lr
1600:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4418              		.loc 1 1600 0
 4419 2748 0E0051E1 		cmp	r1, lr
 4420 274c 0C10A021 		movcs	r1, ip
 4421 2750 0610A033 		movcc	r1, #6
1607:../uvc.c      **** 						  shutter = shutter+index;
 4422              		.loc 1 1607 0
 4423 2754 22085AE1 		cmp	sl, r2, lsr #16
1610:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4424              		.loc 1 1610 0
 4425 2758 90A39FE5 		ldr	sl, .L351+24
1607:../uvc.c      **** 						  shutter = shutter+index;
 4426              		.loc 1 1607 0
 4427 275c 0120A091 		movls	r2, r1
 4428 2760 0720A083 		movhi	r2, #7
 4429 2764 012082E2 		add	r2, r2, #1
 4430 2768 FFE002E2 		and	lr, r2, #255
1610:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4431              		.loc 1 1610 0
 4432 276c 0010E0E3 		mvn	r1, #0
 4433 2770 1C009AE5 		ldr	r0, [sl, #28]
1607:../uvc.c      **** 						  shutter = shutter+index;
 4434              		.loc 1 1607 0
 4435 2774 38E08DE5 		str	lr, [sp, #56]
 4436              	.LVL371:
1610:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4437              		.loc 1 1610 0
 4438 2778 2C308DE5 		str	r3, [sp, #44]
 4439 277c FEFFFFEB 		bl	_txe_mutex_get
1611:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 4440              		.loc 1 1611 0
 4441 2780 38C09DE5 		ldr	ip, [sp, #56]
 4442 2784 0310A0E3 		mov	r1, #3
 4443 2788 0B20A0E1 		mov	r2, fp
 4444 278c 2C309DE5 		ldr	r3, [sp, #44]
 4445 2790 00C08DE5 		str	ip, [sp, #0]
 4446 2794 0A00A0E1 		mov	r0, sl
 4447 2798 00C0A0E3 		mov	ip, #0
 4448 279c 04C08DE5 		str	ip, [sp, #4]
 4449 27a0 FEFFFFEB 		bl	cmdSet
1612:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4450              		.loc 1 1612 0
 4451 27a4 1C009AE5 		ldr	r0, [sl, #28]
 4452 27a8 FEFFFFEB 		bl	_txe_mutex_put
1615:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 4453              		.loc 1 1615 0
 4454 27ac 30009DE5 		ldr	r0, [sp, #48]
1616:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 4455              		.loc 1 1616 0
 4456 27b0 34C09DE5 		ldr	ip, [sp, #52]
1618:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 4457              		.loc 1 1618 0
 4458 27b4 38309DE5 		ldr	r3, [sp, #56]
1615:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 4459              		.loc 1 1615 0
 4460 27b8 061089E0 		add	r1, r9, r6
 4461 27bc 816188E0 		add	r6, r8, r1, asl #3
1617:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 4462              		.loc 1 1617 0
 4463 27c0 0120A0E3 		mov	r2, #1
1615:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 4464              		.loc 1 1615 0
 4465 27c4 2D05C6E5 		strb	r0, [r6, #1325]
1616:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 4466              		.loc 1 1616 0
 4467 27c8 2EC5C6E5 		strb	ip, [r6, #1326]
1617:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 4468              		.loc 1 1617 0
 4469 27cc 3025C6E5 		strb	r2, [r6, #1328]
1618:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 4470              		.loc 1 1618 0
 4471 27d0 0D33C8E5 		strb	r3, [r8, #781]
 4472 27d4 3FFFFFEA 		b	.L341
 4473              	.LVL372:
 4474              	.L287:
1545:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 4475              		.loc 1 1545 0
 4476 27d8 062089E0 		add	r2, r9, r6
 4477 27dc 826188E0 		add	r6, r8, r2, asl #3
1546:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 4478              		.loc 1 1546 0
 4479 27e0 0110A0E3 		mov	r1, #1
1549:../uvc.c      **** 		  		    switch (getData){
 4480              		.loc 1 1549 0
 4481 27e4 01E040E2 		sub	lr, r0, #1
1545:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 4482              		.loc 1 1545 0
 4483 27e8 2D05C6E5 		strb	r0, [r6, #1325]
1546:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 4484              		.loc 1 1546 0
 4485 27ec 3015C6E5 		strb	r1, [r6, #1328]
 4486              	.LVL373:
1549:../uvc.c      **** 		  		    switch (getData){
 4487              		.loc 1 1549 0
 4488 27f0 07005EE3 		cmp	lr, #7
 4489 27f4 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 4490 27f8 980000EA 		b	.L292
 4491              	.L297:
 4492 27fc F4290000 		.word	.L293
 4493 2800 58290000 		.word	.L294
 4494 2804 602A0000 		.word	.L292
 4495 2808 F0280000 		.word	.L295
 4496 280c 602A0000 		.word	.L292
 4497 2810 602A0000 		.word	.L292
 4498 2814 602A0000 		.word	.L292
 4499 2818 50280000 		.word	.L296
 4500              	.LVL374:
 4501              	.L286:
1665:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 4502              		.loc 1 1665 0
 4503 281c 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1664:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4504              		.loc 1 1664 0
 4505 2820 30A09DE5 		ldr	sl, [sp, #48]
 4506 2824 069089E0 		add	r9, r9, r6
 4507 2828 89E188E0 		add	lr, r8, r9, asl #3
1665:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 4508              		.loc 1 1665 0
 4509 282c 0620A0E1 		mov	r2, r6
 4510 2830 0400A0E3 		mov	r0, #4
 4511 2834 C0129FE5 		ldr	r1, .L351+36
1664:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4512              		.loc 1 1664 0
 4513 2838 2DA5CEE5 		strb	sl, [lr, #1325]
1665:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 4514              		.loc 1 1665 0
 4515 283c FEFFFFEB 		bl	CyU3PDebugPrint
1666:../uvc.c      **** 			  		 break;
 4516              		.loc 1 1666 0
 4517 2840 FFC0A0E3 		mov	ip, #255
 4518 2844 0C60A0E1 		mov	r6, ip
 4519 2848 0C80A0E1 		mov	r8, ip
 4520 284c 68FEFFEA 		b	.L277
 4521              	.LVL375:
 4522              	.L296:
1568:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4523              		.loc 1 1568 0
 4524 2850 98629FE5 		ldr	r6, .L351+24
1566:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 4525              		.loc 1 1566 0
 4526 2854 00A0A0E3 		mov	sl, #0
1568:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4527              		.loc 1 1568 0
 4528 2858 1C0096E5 		ldr	r0, [r6, #28]
1566:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 4529              		.loc 1 1566 0
 4530 285c 0DA3C8E5 		strb	sl, [r8, #781]
 4531              	.LVL376:
1568:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4532              		.loc 1 1568 0
 4533 2860 0010E0E3 		mvn	r1, #0
 4534 2864 2C308DE5 		str	r3, [sp, #44]
 4535 2868 FEFFFFEB 		bl	_txe_mutex_get
1569:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 4536              		.loc 1 1569 0
 4537 286c 0B20A0E1 		mov	r2, fp
 4538 2870 2C309DE5 		ldr	r3, [sp, #44]
 4539 2874 1010A0E3 		mov	r1, #16
 4540 2878 0600A0E1 		mov	r0, r6
 4541 287c 00A08DE5 		str	sl, [sp, #0]
 4542 2880 04A08DE5 		str	sl, [sp, #4]
 4543 2884 FEFFFFEB 		bl	cmdSet
1570:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4544              		.loc 1 1570 0
 4545 2888 1C0096E5 		ldr	r0, [r6, #28]
 4546 288c FEFFFFEB 		bl	_txe_mutex_put
 4547              	.LVL377:
 4548              	.LBB68:
 4549              	.LBB69:
 679:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4550              		.loc 1 679 0
 4551 2890 0010E0E3 		mvn	r1, #0
 4552 2894 1C0096E5 		ldr	r0, [r6, #28]
 4553 2898 FEFFFFEB 		bl	_txe_mutex_get
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 4554              		.loc 1 680 0
 4555 289c 01C0A0E3 		mov	ip, #1
 4556 28a0 2010A0E3 		mov	r1, #32
 4557 28a4 2720A0E3 		mov	r2, #39
 4558 28a8 3030A0E3 		mov	r3, #48
 4559 28ac 0600A0E1 		mov	r0, r6
 4560 28b0 00C08DE5 		str	ip, [sp, #0]
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 4561              		.loc 1 681 0
 4562 28b4 0280A0E3 		mov	r8, #2
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 4563              		.loc 1 680 0
 4564 28b8 04A08DE5 		str	sl, [sp, #4]
 4565 28bc FEFFFFEB 		bl	cmdSet
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 4566              		.loc 1 681 0
 4567 28c0 2110A0E3 		mov	r1, #33
 4568 28c4 2520A0E3 		mov	r2, #37
 4569 28c8 3030A0E3 		mov	r3, #48
 4570 28cc 0600A0E1 		mov	r0, r6
 4571 28d0 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 4572 28d4 FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4573              		.loc 1 682 0
 4574 28d8 1C0096E5 		ldr	r0, [r6, #28]
 4575 28dc FEFFFFEB 		bl	_txe_mutex_put
 4576              	.LBE69:
 4577              	.LBE68:
1572:../uvc.c      **** 							break;
 4578              		.loc 1 1572 0
 4579 28e0 FFC0A0E3 		mov	ip, #255
 4580 28e4 0C60A0E1 		mov	r6, ip
 4581 28e8 0880A0E3 		mov	r8, #8
 4582 28ec 40FEFFEA 		b	.L277
 4583              	.LVL378:
 4584              	.L295:
 4585              	.LBB70:
 4586              	.LBB71:
 679:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4587              		.loc 1 679 0
 4588 28f0 F8619FE5 		ldr	r6, .L351+24
 4589 28f4 0010E0E3 		mvn	r1, #0
 4590 28f8 1C0096E5 		ldr	r0, [r6, #28]
 4591 28fc FEFFFFEB 		bl	_txe_mutex_get
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 4592              		.loc 1 680 0
 4593 2900 0080A0E3 		mov	r8, #0
 4594 2904 2010A0E3 		mov	r1, #32
 4595 2908 2720A0E3 		mov	r2, #39
 4596 290c 3030A0E3 		mov	r3, #48
 4597 2910 0600A0E1 		mov	r0, r6
 4598 2914 00808DE5 		str	r8, [sp, #0]
 4599 2918 04808DE5 		str	r8, [sp, #4]
 4600 291c FEFFFFEB 		bl	cmdSet
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 4601              		.loc 1 681 0
 4602 2920 01C0A0E3 		mov	ip, #1
 4603 2924 2110A0E3 		mov	r1, #33
 4604 2928 2520A0E3 		mov	r2, #37
 4605 292c 3030A0E3 		mov	r3, #48
 4606 2930 0600A0E1 		mov	r0, r6
 4607 2934 00C08DE5 		str	ip, [sp, #0]
 4608 2938 04808DE5 		str	r8, [sp, #4]
 4609 293c FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4610              		.loc 1 682 0
 4611 2940 1C0096E5 		ldr	r0, [r6, #28]
 4612 2944 FEFFFFEB 		bl	_txe_mutex_put
 4613 2948 FFC0A0E3 		mov	ip, #255
 4614 294c 0C60A0E1 		mov	r6, ip
 4615 2950 0480A0E3 		mov	r8, #4
 4616 2954 26FEFFEA 		b	.L277
 4617              	.LVL379:
 4618              	.L294:
 4619              	.LBE71:
 4620              	.LBE70:
1556:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4621              		.loc 1 1556 0
 4622 2958 90619FE5 		ldr	r6, .L351+24
1554:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 4623              		.loc 1 1554 0
 4624 295c 00A0A0E3 		mov	sl, #0
1556:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4625              		.loc 1 1556 0
 4626 2960 1C0096E5 		ldr	r0, [r6, #28]
1554:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 4627              		.loc 1 1554 0
 4628 2964 0DA3C8E5 		strb	sl, [r8, #781]
 4629              	.LVL380:
1556:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4630              		.loc 1 1556 0
 4631 2968 0010E0E3 		mvn	r1, #0
 4632 296c 2C308DE5 		str	r3, [sp, #44]
 4633 2970 FEFFFFEB 		bl	_txe_mutex_get
1557:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 4634              		.loc 1 1557 0
 4635 2974 0B20A0E1 		mov	r2, fp
 4636 2978 2C309DE5 		ldr	r3, [sp, #44]
 4637 297c 1010A0E3 		mov	r1, #16
 4638 2980 0600A0E1 		mov	r0, r6
 4639 2984 00A08DE5 		str	sl, [sp, #0]
 4640 2988 04A08DE5 		str	sl, [sp, #4]
 4641 298c FEFFFFEB 		bl	cmdSet
1558:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4642              		.loc 1 1558 0
 4643 2990 1C0096E5 		ldr	r0, [r6, #28]
 4644 2994 FEFFFFEB 		bl	_txe_mutex_put
 4645              	.LVL381:
 4646              	.LBB72:
 4647              	.LBB73:
 679:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4648              		.loc 1 679 0
 4649 2998 0010E0E3 		mvn	r1, #0
 4650 299c 1C0096E5 		ldr	r0, [r6, #28]
 4651 29a0 FEFFFFEB 		bl	_txe_mutex_get
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 4652              		.loc 1 680 0
 4653 29a4 2010A0E3 		mov	r1, #32
 4654 29a8 2720A0E3 		mov	r2, #39
 4655 29ac 3030A0E3 		mov	r3, #48
 4656 29b0 0600A0E1 		mov	r0, r6
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 4657              		.loc 1 681 0
 4658 29b4 0180A0E3 		mov	r8, #1
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 4659              		.loc 1 680 0
 4660 29b8 00A08DE5 		str	sl, [sp, #0]
 4661 29bc 04A08DE5 		str	sl, [sp, #4]
 4662 29c0 FEFFFFEB 		bl	cmdSet
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 4663              		.loc 1 681 0
 4664 29c4 2110A0E3 		mov	r1, #33
 4665 29c8 2520A0E3 		mov	r2, #37
 4666 29cc 3030A0E3 		mov	r3, #48
 4667 29d0 0600A0E1 		mov	r0, r6
 4668 29d4 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 4669 29d8 FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4670              		.loc 1 682 0
 4671 29dc 1C0096E5 		ldr	r0, [r6, #28]
 4672 29e0 FEFFFFEB 		bl	_txe_mutex_put
 4673 29e4 FFC0A0E3 		mov	ip, #255
 4674 29e8 0C60A0E1 		mov	r6, ip
 4675 29ec 0280A0E3 		mov	r8, #2
 4676 29f0 FFFDFFEA 		b	.L277
 4677              	.LVL382:
 4678              	.L293:
 4679              	.LBE73:
 4680              	.LBE72:
 4681              	.LBB74:
 4682              	.LBB75:
 679:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4683              		.loc 1 679 0
 4684 29f4 F4609FE5 		ldr	r6, .L351+24
 4685 29f8 0010E0E3 		mvn	r1, #0
 4686 29fc 1C0096E5 		ldr	r0, [r6, #28]
 4687 2a00 FEFFFFEB 		bl	_txe_mutex_get
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 4688              		.loc 1 680 0
 4689 2a04 0080A0E3 		mov	r8, #0
 4690 2a08 01A0A0E3 		mov	sl, #1
 4691 2a0c 2010A0E3 		mov	r1, #32
 4692 2a10 2720A0E3 		mov	r2, #39
 4693 2a14 3030A0E3 		mov	r3, #48
 4694 2a18 0600A0E1 		mov	r0, r6
 4695 2a1c 04808DE5 		str	r8, [sp, #4]
 4696 2a20 00A08DE5 		str	sl, [sp, #0]
 4697 2a24 FEFFFFEB 		bl	cmdSet
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 4698              		.loc 1 681 0
 4699 2a28 02C0A0E3 		mov	ip, #2
 4700 2a2c 2110A0E3 		mov	r1, #33
 4701 2a30 2520A0E3 		mov	r2, #37
 4702 2a34 3030A0E3 		mov	r3, #48
 4703 2a38 0600A0E1 		mov	r0, r6
 4704 2a3c 00C08DE5 		str	ip, [sp, #0]
 4705 2a40 04808DE5 		str	r8, [sp, #4]
 4706 2a44 FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4707              		.loc 1 682 0
 4708 2a48 1C0096E5 		ldr	r0, [r6, #28]
 4709 2a4c FEFFFFEB 		bl	_txe_mutex_put
 4710              	.LBE75:
 4711              	.LBE74:
1552:../uvc.c      **** 							break;
 4712              		.loc 1 1552 0
 4713 2a50 FFC0A0E3 		mov	ip, #255
 4714 2a54 0C60A0E1 		mov	r6, ip
 4715 2a58 0A80A0E1 		mov	r8, sl
 4716 2a5c E4FDFFEA 		b	.L277
 4717              	.LVL383:
 4718              	.L292:
1549:../uvc.c      **** 		  		    switch (getData){
 4719              		.loc 1 1549 0
 4720 2a60 FFC0A0E3 		mov	ip, #255
 4721 2a64 0080A0E1 		mov	r8, r0
 4722 2a68 0C60A0E1 		mov	r6, ip
 4723 2a6c E0FDFFEA 		b	.L277
 4724              	.LVL384:
 4725              	.L298:
1620:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4726              		.loc 1 1620 0
 4727 2a70 0000A0E3 		mov	r0, #0
 4728 2a74 0110A0E3 		mov	r1, #1
 4729 2a78 0020A0E1 		mov	r2, r0
 4730 2a7c FEFFFFEB 		bl	CyU3PUsbStall
 4731              	.LVL385:
 4732 2a80 94FEFFEA 		b	.L341
 4733              	.LVL386:
 4734              	.L340:
1638:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4735              		.loc 1 1638 0
 4736 2a84 0110A0E3 		mov	r1, #1
 4737 2a88 0020A0E1 		mov	r2, r0
 4738 2a8c FEFFFFEB 		bl	CyU3PUsbStall
 4739 2a90 90FEFFEA 		b	.L341
 4740              	.LVL387:
 4741              	.L350:
1653:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 4742              		.loc 1 1653 0
 4743 2a94 08E0A0E3 		mov	lr, #8
 4744 2a98 00C0A0E3 		mov	ip, #0
 4745 2a9c 0600A0E1 		mov	r0, r6
 4746 2aa0 2310A0E3 		mov	r1, #35
 4747 2aa4 0B20A0E1 		mov	r2, fp
 4748 2aa8 00E08DE5 		str	lr, [sp, #0]
 4749 2aac 04C08DE5 		str	ip, [sp, #4]
 4750 2ab0 FEFFFFEB 		bl	cmdSet
 4751 2ab4 5DFEFFEA 		b	.L343
 4752              	.L349:
1651:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 4753              		.loc 1 1651 0
 4754 2ab8 0480A0E3 		mov	r8, #4
 4755 2abc 00E0A0E3 		mov	lr, #0
 4756 2ac0 0600A0E1 		mov	r0, r6
 4757 2ac4 2310A0E3 		mov	r1, #35
 4758 2ac8 0B20A0E1 		mov	r2, fp
 4759 2acc 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 4760 2ad0 FEFFFFEB 		bl	cmdSet
 4761 2ad4 55FEFFEA 		b	.L343
 4762              	.L352:
 4763              		.align	2
 4764              	.L351:
 4765 2ad8 00000000 		.word	bRequest
 4766 2adc 00000000 		.word	.LANCHOR1
 4767 2ae0 00000000 		.word	.LANCHOR0
 4768 2ae4 C8040000 		.word	.LC28
 4769 2ae8 EC040000 		.word	.LC29
 4770 2aec 5C000000 		.word	.LANCHOR0+92
 4771 2af0 00000000 		.word	cmdQu
 4772 2af4 7C040000 		.word	.LC26
 4773 2af8 FFFF0000 		.word	65535
 4774 2afc A4040000 		.word	.LC27
 4775              		.cfi_endproc
 4776              	.LFE4:
 4778              		.align	2
 4779              		.global	UVCAppEP0Thread_Entry
 4781              	UVCAppEP0Thread_Entry:
 4782              	.LFB25:
3829:../uvc.c      **** {
 4783              		.loc 1 3829 0
 4784              		.cfi_startproc
 4785              		@ args = 0, pretend = 0, frame = 24
 4786              		@ frame_needed = 0, uses_anonymous_args = 0
 4787              	.LVL388:
 4788 2b00 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4789              	.LCFI19:
 4790              		.cfi_def_cfa_offset 36
 4791 2b04 644D9FE5 		ldr	r4, .L548
 4792              		.cfi_offset 14, -4
 4793              		.cfi_offset 11, -8
 4794              		.cfi_offset 10, -12
 4795              		.cfi_offset 9, -16
 4796              		.cfi_offset 8, -20
 4797              		.cfi_offset 7, -24
 4798              		.cfi_offset 6, -28
 4799              		.cfi_offset 5, -32
 4800              		.cfi_offset 4, -36
 4801 2b08 645D9FE5 		ldr	r5, .L548+4
 4802 2b0c 648D9FE5 		ldr	r8, .L548+8
 4803 2b10 64AD9FE5 		ldr	sl, .L548+12
 4804 2b14 64BD9FE5 		ldr	fp, .L548+16
 4805 2b18 647D9FE5 		ldr	r7, .L548+20
 4806 2b1c 34D04DE2 		sub	sp, sp, #52
 4807              	.LCFI20:
 4808              		.cfi_def_cfa_offset 88
 4809              	.LVL389:
3851:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 4810              		.loc 1 3851 0
 4811 2b20 0460A0E1 		mov	r6, r4
 4812              	.LVL390:
 4813              	.L508:
 4814 2b24 00C0E0E3 		mvn	ip, #0
 4815 2b28 400D9FE5 		ldr	r0, .L548
 4816 2b2c 4C10A0E3 		mov	r1, #76
 4817 2b30 0120A0E3 		mov	r2, #1
 4818 2b34 28308DE2 		add	r3, sp, #40
 4819 2b38 00C08DE5 		str	ip, [sp, #0]
 4820 2b3c FEFFFFEB 		bl	_txe_event_flags_get
 4821 2b40 000050E3 		cmp	r0, #0
 4822 2b44 3000001A 		bne	.L354
3855:../uvc.c      ****             if (!isUsbConnected)
 4823              		.loc 1 3855 0
 4824 2b48 303096E5 		ldr	r3, [r6, #48]
 4825 2b4c 000053E3 		cmp	r3, #0
 4826 2b50 8C00000A 		beq	.L537
 4827              	.L355:
3864:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 4828              		.loc 1 3864 0
 4829 2b54 28309DE5 		ldr	r3, [sp, #40]
 4830 2b58 0C0013E3 		tst	r3, #12
 4831 2b5c 7500001A 		bne	.L538
 4832              	.L356:
3871:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 4833              		.loc 1 3871 0
 4834 2b60 040013E3 		tst	r3, #4
 4835 2b64 1C00000A 		beq	.L357
3873:../uvc.c      ****             	switch ((wIndex >> 8))
 4836              		.loc 1 3873 0
 4837 2b68 B0E0DBE1 		ldrh	lr, [fp, #0]
 4838 2b6c 2E24A0E1 		mov	r2, lr, lsr #8
 4839 2b70 030052E3 		cmp	r2, #3
 4840 2b74 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4841 2b78 120000EA 		b	.L358
 4842              	.L363:
 4843 2b7c C82B0000 		.word	.L358
 4844 2b80 B82C0000 		.word	.L360
 4845 2b84 8C2B0000 		.word	.L361
 4846 2b88 F42C0000 		.word	.L362
 4847              	.L361:
 4848              	.LBB90:
 4849              	.LBB94:
3077:../uvc.c      ****     switch (wValue)
 4850              		.loc 1 3077 0
 4851 2b8c B020DAE1 		ldrh	r2, [sl, #0]
 4852 2b90 060C52E3 		cmp	r2, #1536
 4853 2b94 9902000A 		beq	.L369
 4854 2b98 D900008A 		bhi	.L375
 4855 2b9c 030C52E3 		cmp	r2, #768
 4856 2ba0 9202000A 		beq	.L367
 4857 2ba4 A001008A 		bhi	.L376
 4858 2ba8 010C52E3 		cmp	r2, #256
 4859 2bac B602000A 		beq	.L365
 4860 2bb0 020C52E3 		cmp	r2, #512
 4861 2bb4 B002000A 		beq	.L539
 4862              	.L378:
 4863              	.LBE94:
 4864              	.LBE90:
 4865              	.LBB98:
 4866              	.LBB103:
3209:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 4867              		.loc 1 3209 0
 4868 2bb8 C81C9FE5 		ldr	r1, .L548+24
 4869 2bbc 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4870 2bc0 0400A0E3 		mov	r0, #4
 4871 2bc4 FEFFFFEB 		bl	CyU3PDebugPrint
 4872              	.L358:
 4873              	.LBE103:
 4874              	.LBE98:
3894:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4875              		.loc 1 3894 0
 4876 2bc8 0000A0E3 		mov	r0, #0
 4877 2bcc 0110A0E3 		mov	r1, #1
 4878 2bd0 0020A0E1 		mov	r2, r0
 4879 2bd4 FEFFFFEB 		bl	CyU3PUsbStall
 4880 2bd8 28309DE5 		ldr	r3, [sp, #40]
 4881              	.L357:
3899:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 4882              		.loc 1 3899 0
 4883 2bdc 080013E3 		tst	r3, #8
 4884 2be0 0700000A 		beq	.L421
3903:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 4885              		.loc 1 3903 0
 4886 2be4 B030DBE1 		ldrh	r3, [fp, #0]
 4887 2be8 010053E3 		cmp	r3, #1
 4888 2bec 6B00000A 		beq	.L422
 4889              	.L423:
 4890              	.LBB109:
 4891              	.LBB113:
3818:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4892              		.loc 1 3818 0
 4893 2bf0 0000A0E3 		mov	r0, #0
 4894 2bf4 0110A0E3 		mov	r1, #1
 4895 2bf8 0020A0E1 		mov	r2, r0
 4896 2bfc FEFFFFEB 		bl	CyU3PUsbStall
 4897              	.L527:
 4898 2c00 28309DE5 		ldr	r3, [sp, #40]
 4899              	.L421:
 4900              	.LBE113:
 4901              	.LBE109:
3914:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 4902              		.loc 1 3914 0
 4903 2c04 400013E3 		tst	r3, #64
 4904 2c08 0100001A 		bne	.L540
 4905              	.L354:
4127:../uvc.c      ****         CyU3PThreadRelinquish ();
 4906              		.loc 1 4127 0
 4907 2c0c FEFFFFEB 		bl	_txe_thread_relinquish
4128:../uvc.c      ****     }
 4908              		.loc 1 4128 0
 4909 2c10 C3FFFFEA 		b	.L508
 4910              	.L540:
3919:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 4911              		.loc 1 3919 0
 4912 2c14 1800A0E3 		mov	r0, #24
 4913 2c18 24108DE2 		add	r1, sp, #36
 4914 2c1c FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
3976:../uvc.c      **** 				if(snapButFlag == 0x0f){
 4915              		.loc 1 3976 0
 4916 2c20 0B37D5E5 		ldrb	r3, [r5, #1803]	@ zero_extendqisi2
 4917 2c24 0F0053E3 		cmp	r3, #15
 4918 2c28 9400000A 		beq	.L541
4003:../uvc.c      **** 				}else if(!snapButFlag){
 4919              		.loc 1 4003 0
 4920 2c2c 000053E3 		cmp	r3, #0
 4921 2c30 F5FFFF1A 		bne	.L354
4005:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4922              		.loc 1 4005 0
 4923 2c34 002097E5 		ldr	r2, [r7, #0]
 4924 2c38 0290A0E3 		mov	r9, #2
 4925 2c3c 0090C2E5 		strb	r9, [r2, #0]
4006:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4926              		.loc 1 4006 0
 4927 2c40 001097E5 		ldr	r1, [r7, #0]
 4928 2c44 0190A0E3 		mov	r9, #1
 4929 2c48 0190C1E5 		strb	r9, [r1, #1]
4007:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4930              		.loc 1 4007 0
 4931 2c4c 000097E5 		ldr	r0, [r7, #0]
4011:../uvc.c      **** 					interStabuf.size   = 1024;
 4932              		.loc 1 4011 0
 4933 2c50 01CBA0E3 		mov	ip, #1024	@ movhi
4007:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4934              		.loc 1 4007 0
 4935 2c54 0230C0E5 		strb	r3, [r0, #2]
4008:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4936              		.loc 1 4008 0
 4937 2c58 00E097E5 		ldr	lr, [r7, #0]
4017:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4938              		.loc 1 4017 0
 4939 2c5c 0010E0E3 		mvn	r1, #0
4008:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4940              		.loc 1 4008 0
 4941 2c60 0390CEE5 		strb	r9, [lr, #3]
4010:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4942              		.loc 1 4010 0
 4943 2c64 002097E5 		ldr	r2, [r7, #0]
4014:../uvc.c      **** 					interStabuf.count = 4;
 4944              		.loc 1 4014 0
 4945 2c68 04E0A0E3 		mov	lr, #4	@ movhi
4017:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4946              		.loc 1 4017 0
 4947 2c6c 180C9FE5 		ldr	r0, .L548+28
4010:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4948              		.loc 1 4010 0
 4949 2c70 18208DE5 		str	r2, [sp, #24]
4011:../uvc.c      **** 					interStabuf.size   = 1024;
 4950              		.loc 1 4011 0
 4951 2c74 BEC1CDE1 		strh	ip, [sp, #30]	@ movhi
4012:../uvc.c      **** 					interStabuf.status = 0;
 4952              		.loc 1 4012 0
 4953 2c78 B032CDE1 		strh	r3, [sp, #32]	@ movhi
4014:../uvc.c      **** 					interStabuf.count = 4;
 4954              		.loc 1 4014 0
 4955 2c7c BCE1CDE1 		strh	lr, [sp, #28]	@ movhi
4017:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4956              		.loc 1 4017 0
 4957 2c80 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
4020:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4958              		.loc 1 4020 0
 4959 2c84 000C9FE5 		ldr	r0, .L548+28
 4960 2c88 18108DE2 		add	r1, sp, #24
 4961 2c8c FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4962              	.LVL391:
4022:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4963              		.loc 1 4022 0
 4964 2c90 002050E2 		subs	r2, r0, #0
 4965 2c94 5B01001A 		bne	.L542
4028:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
 4966              		.loc 1 4028 0
 4967 2c98 3010A0E3 		mov	r1, #48
 4968 2c9c 0920A0E1 		mov	r2, r9
 4969 2ca0 0500A0E3 		mov	r0, #5
 4970              	.LVL392:
 4971 2ca4 FEFFFFEB 		bl	SensorSetControl
4029:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 4972              		.loc 1 4029 0
 4973 2ca8 C43B9FE5 		ldr	r3, .L548+4
 4974 2cac 0B97C3E5 		strb	r9, [r3, #1803]
4127:../uvc.c      ****         CyU3PThreadRelinquish ();
 4975              		.loc 1 4127 0
 4976 2cb0 FEFFFFEB 		bl	_txe_thread_relinquish
 4977 2cb4 9AFFFFEA 		b	.L508
 4978              	.L360:
 4979              	.LBB118:
 4980              	.LBB104:
3152:../uvc.c      ****     switch (wValue)
 4981              		.loc 1 3152 0
 4982 2cb8 B020DAE1 		ldrh	r2, [sl, #0]
 4983 2cbc 060C52E3 		cmp	r2, #1536
 4984 2cc0 7502000A 		beq	.L384
 4985 2cc4 9900008A 		bhi	.L390
 4986 2cc8 030C52E3 		cmp	r2, #768
 4987 2ccc 5B02000A 		beq	.L381
 4988 2cd0 8101008A 		bhi	.L391
 4989 2cd4 010C52E3 		cmp	r2, #256
 4990 2cd8 5402000A 		beq	.L379
 4991 2cdc 020C52E3 		cmp	r2, #512
 4992 2ce0 B4FFFF1A 		bne	.L378
 4993              	.LVL393:
3160:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 4994              		.loc 1 3160 0
 4995 2ce4 0100A0E3 		mov	r0, #1
 4996 2ce8 FEFFFFEB 		bl	CTControlHandle
 4997              	.LVL394:
 4998 2cec 28309DE5 		ldr	r3, [sp, #40]
 4999 2cf0 B9FFFFEA 		b	.L357
 5000              	.L362:
 5001              	.LBE104:
 5002              	.LBE118:
 5003              	.LBB119:
 5004              	.LBB125:
3377:../uvc.c      ****     switch (wValue)
 5005              		.loc 1 3377 0
 5006 2cf4 B030DAE1 		ldrh	r3, [sl, #0]
 5007 2cf8 090C53E3 		cmp	r3, #2304
 5008 2cfc 4702000A 		beq	.L405
 5009 2d00 9200008A 		bhi	.L415
 5010 2d04 010B53E3 		cmp	r3, #1024
 5011 2d08 4002000A 		beq	.L400
 5012 2d0c 5701008A 		bhi	.L416
 5013 2d10 020C53E3 		cmp	r3, #512
 5014 2d14 C101000A 		beq	.L398
 5015 2d18 030C53E3 		cmp	r3, #768
 5016 2d1c BB01000A 		beq	.L399
 5017 2d20 010C53E3 		cmp	r3, #256
 5018 2d24 A7FFFF1A 		bne	.L358
 5019              	.LVL395:
3381:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 5020              		.loc 1 3381 0
 5021 2d28 1000A0E3 		mov	r0, #16
 5022 2d2c FEFFFFEB 		bl	ControlHandle
 5023              	.LVL396:
 5024 2d30 28309DE5 		ldr	r3, [sp, #40]
 5025 2d34 A8FFFFEA 		b	.L357
 5026              	.L538:
 5027              	.LBE125:
 5028              	.LBE119:
3865:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 5029              		.loc 1 3865 0
 5030 2d38 B0C0DAE1 		ldrh	ip, [sl, #0]
 5031 2d3c 4C9B9FE5 		ldr	r9, .L548+32
 5032 2d40 4C1B9FE5 		ldr	r1, .L548+36
 5033 2d44 00E0D9E5 		ldrb	lr, [r9, #0]	@ zero_extendqisi2
 5034 2d48 08C08DE5 		str	ip, [sp, #8]
 5035 2d4c B000DBE1 		ldrh	r0, [fp, #0]
 5036 2d50 0090D8E5 		ldrb	r9, [r8, #0]	@ zero_extendqisi2
 5037 2d54 0C008DE5 		str	r0, [sp, #12]
 5038 2d58 B0C0D1E1 		ldrh	ip, [r1, #0]
 5039 2d5c 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
 5040 2d60 04908DE5 		str	r9, [sp, #4]
 5041 2d64 0400A0E3 		mov	r0, #4
 5042 2d68 281B9FE5 		ldr	r1, .L548+40
 5043 2d6c 0090A0E3 		mov	r9, #0
 5044 2d70 00E08DE5 		str	lr, [sp, #0]
 5045 2d74 10C08DE5 		str	ip, [sp, #16]
 5046 2d78 14908DE5 		str	r9, [sp, #20]
 5047 2d7c FEFFFFEB 		bl	CyU3PDebugPrint
 5048 2d80 28309DE5 		ldr	r3, [sp, #40]
 5049 2d84 75FFFFEA 		b	.L356
 5050              	.L537:
3857:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 5051              		.loc 1 3857 0
 5052 2d88 FEFFFFEB 		bl	CyU3PUsbGetSpeed
3858:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 5053              		.loc 1 3858 0
 5054 2d8c 000050E3 		cmp	r0, #0
3857:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 5055              		.loc 1 3857 0
 5056 2d90 4800C6E5 		strb	r0, [r6, #72]
3860:../uvc.c      ****                     isUsbConnected = CyTrue;
 5057              		.loc 1 3860 0
 5058 2d94 0100A013 		movne	r0, #1
 5059 2d98 30008615 		strne	r0, [r6, #48]
 5060 2d9c 6CFFFFEA 		b	.L355
 5061              	.L422:
 5062              	.LVL397:
 5063              	.LBB132:
 5064              	.LBB114:
3478:../uvc.c      ****     switch (wValue)
 5065              		.loc 1 3478 0
 5066 2da0 B020DAE1 		ldrh	r2, [sl, #0]
 5067 2da4 030C52E3 		cmp	r2, #768
 5068 2da8 CD00000A 		beq	.L426
 5069 2dac 0F00008A 		bhi	.L429
 5070 2db0 010C52E3 		cmp	r2, #256
 5071 2db4 8600000A 		beq	.L424
 5072 2db8 020C52E3 		cmp	r2, #512
 5073 2dbc 8BFFFF1A 		bne	.L423
3543:../uvc.c      ****             switch (bRequest)
 5074              		.loc 1 3543 0
 5075 2dc0 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 5076 2dc4 810053E3 		cmp	r3, #129
 5077 2dc8 8301000A 		beq	.L495
 5078 2dcc D100008A 		bhi	.L444
 5079 2dd0 010053E3 		cmp	r3, #1
 5080 2dd4 7101000A 		beq	.L543
 5081              	.L471:
3756:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 5082              		.loc 1 3756 0
 5083 2dd8 0000A0E3 		mov	r0, #0
 5084 2ddc 0110A0E3 		mov	r1, #1
 5085 2de0 0020A0E1 		mov	r2, r0
 5086 2de4 FEFFFFEB 		bl	CyU3PUsbStall
 5087 2de8 28309DE5 		ldr	r3, [sp, #40]
 5088 2dec 84FFFFEA 		b	.L421
 5089              	.L429:
3478:../uvc.c      ****     switch (wValue)
 5090              		.loc 1 3478 0
 5091 2df0 010B52E3 		cmp	r2, #1024
 5092 2df4 6100000A 		beq	.L427
 5093 2df8 050C52E3 		cmp	r2, #1280
 5094 2dfc 7BFFFF1A 		bne	.L423
3763:../uvc.c      ****             	switch (bRequest)
 5095              		.loc 1 3763 0
 5096 2e00 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5097 2e04 810052E3 		cmp	r2, #129
 5098 2e08 7301000A 		beq	.L495
 5099 2e0c 4401008A 		bhi	.L498
 5100 2e10 010052E3 		cmp	r2, #1
 5101 2e14 75FFFF1A 		bne	.L423
3788:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5102              		.loc 1 3788 0
 5103 2e18 2000A0E3 		mov	r0, #32
 5104 2e1c 781A9FE5 		ldr	r1, .L548+44
 5105 2e20 2E208DE2 		add	r2, sp, #46
 5106 2e24 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5107              	.LVL398:
3790:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 5108              		.loc 1 3790 0
 5109 2e28 000050E3 		cmp	r0, #0
 5110 2e2c 5501001A 		bne	.L500
3794:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 5111              		.loc 1 3794 0
 5112 2e30 0020A0E3 		mov	r2, #0
 5113 2e34 340A9FE5 		ldr	r0, .L548
 5114              	.LVL399:
 5115 2e38 8010A0E3 		mov	r1, #128
 5116 2e3c FEFFFFEB 		bl	_txe_event_flags_set
 5117              	.LVL400:
3795:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 5118              		.loc 1 3795 0
 5119 2e40 002050E2 		subs	r2, r0, #0
3801:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
 5120              		.loc 1 3801 0
 5121 2e44 0FC0E003 		mvneq	ip, #15
 5122 2e48 3AC0C605 		streqb	ip, [r6, #58]
3795:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 5123              		.loc 1 3795 0
 5124 2e4c 0200000A 		beq	.L502
3797:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
 5125              		.loc 1 3797 0
 5126 2e50 481A9FE5 		ldr	r1, .L548+48
 5127 2e54 0400A0E3 		mov	r0, #4
 5128              	.LVL401:
 5129 2e58 FEFFFFEB 		bl	CyU3PDebugPrint
 5130              	.LVL402:
 5131              	.L502:
3804:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
 5132              		.loc 1 3804 0
 5133 2e5c 81E0D4E5 		ldrb	lr, [r4, #129]	@ zero_extendqisi2
 5134 2e60 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 5135 2e64 BE22DDE1 		ldrh	r2, [sp, #46]
 5136              	.LVL403:
 5137 2e68 0400A0E3 		mov	r0, #4
 5138 2e6c 301A9FE5 		ldr	r1, .L548+52
 5139 2e70 00E08DE5 		str	lr, [sp, #0]
 5140 2e74 FEFFFFEB 		bl	CyU3PDebugPrint
 5141 2e78 28309DE5 		ldr	r3, [sp, #40]
 5142 2e7c 60FFFFEA 		b	.L421
 5143              	.LVL404:
 5144              	.L541:
 5145              	.LBE114:
 5146              	.LBE132:
3978:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 5147              		.loc 1 3978 0
 5148 2e80 003097E5 		ldr	r3, [r7, #0]
 5149 2e84 0290A0E3 		mov	r9, #2
 5150 2e88 0090C3E5 		strb	r9, [r3, #0]
3979:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 5151              		.loc 1 3979 0
 5152 2e8c 002097E5 		ldr	r2, [r7, #0]
 5153 2e90 0190A0E3 		mov	r9, #1
 5154 2e94 0190C2E5 		strb	r9, [r2, #1]
3980:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 5155              		.loc 1 3980 0
 5156 2e98 001097E5 		ldr	r1, [r7, #0]
 5157 2e9c 0030A0E3 		mov	r3, #0
 5158 2ea0 0230C1E5 		strb	r3, [r1, #2]
3981:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 5159              		.loc 1 3981 0
 5160 2ea4 000097E5 		ldr	r0, [r7, #0]
3987:../uvc.c      **** 					interStabuf.count = 4;
 5161              		.loc 1 3987 0
 5162 2ea8 0420A0E3 		mov	r2, #4	@ movhi
3981:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 5163              		.loc 1 3981 0
 5164 2eac 0330C0E5 		strb	r3, [r0, #3]
3983:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5165              		.loc 1 3983 0
 5166 2eb0 00E097E5 		ldr	lr, [r7, #0]
3984:../uvc.c      **** 					interStabuf.size   = 1024;
 5167              		.loc 1 3984 0
 5168 2eb4 01CBA0E3 		mov	ip, #1024	@ movhi
3990:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5169              		.loc 1 3990 0
 5170 2eb8 0010E0E3 		mvn	r1, #0
 5171 2ebc C8099FE5 		ldr	r0, .L548+28
3987:../uvc.c      **** 					interStabuf.count = 4;
 5172              		.loc 1 3987 0
 5173 2ec0 BC21CDE1 		strh	r2, [sp, #28]	@ movhi
3983:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5174              		.loc 1 3983 0
 5175 2ec4 18E08DE5 		str	lr, [sp, #24]
3984:../uvc.c      **** 					interStabuf.size   = 1024;
 5176              		.loc 1 3984 0
 5177 2ec8 BEC1CDE1 		strh	ip, [sp, #30]	@ movhi
3985:../uvc.c      **** 					interStabuf.status = 0;
 5178              		.loc 1 3985 0
 5179 2ecc B032CDE1 		strh	r3, [sp, #32]	@ movhi
3990:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5180              		.loc 1 3990 0
 5181 2ed0 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3993:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 5182              		.loc 1 3993 0
 5183 2ed4 B0099FE5 		ldr	r0, .L548+28
 5184 2ed8 18108DE2 		add	r1, sp, #24
 5185 2edc FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 5186              	.LVL405:
3995:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 5187              		.loc 1 3995 0
 5188 2ee0 002050E2 		subs	r2, r0, #0
 5189 2ee4 D800001A 		bne	.L544
4000:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
 5190              		.loc 1 4000 0
 5191 2ee8 3010A0E3 		mov	r1, #48
 5192 2eec 0500A0E3 		mov	r0, #5
 5193              	.LVL406:
 5194 2ef0 FEFFFFEB 		bl	SensorSetControl
 5195              	.LVL407:
4002:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
 5196              		.loc 1 4002 0
 5197 2ef4 78C99FE5 		ldr	ip, .L548+4
 5198 2ef8 0B97CCE5 		strb	r9, [ip, #1803]
4127:../uvc.c      ****         CyU3PThreadRelinquish ();
 5199              		.loc 1 4127 0
 5200 2efc FEFFFFEB 		bl	_txe_thread_relinquish
 5201 2f00 07FFFFEA 		b	.L508
 5202              	.L375:
 5203              	.LBB133:
 5204              	.LBB93:
3077:../uvc.c      ****     switch (wValue)
 5205              		.loc 1 3077 0
 5206 2f04 0A0C52E3 		cmp	r2, #2560
 5207 2f08 1A01000A 		beq	.L372
 5208 2f0c FA00008A 		bhi	.L377
 5209 2f10 070C52E3 		cmp	r2, #1792
 5210 2f14 1301000A 		beq	.L370
 5211 2f18 020B52E3 		cmp	r2, #2048
 5212 2f1c 25FFFF1A 		bne	.L378
 5213              	.LVL408:
3108:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 5214              		.loc 1 3108 0
 5215 2f20 0700A0E3 		mov	r0, #7
 5216 2f24 FEFFFFEB 		bl	ControlHandle
 5217              	.LVL409:
 5218 2f28 28309DE5 		ldr	r3, [sp, #40]
 5219 2f2c 2AFFFFEA 		b	.L357
 5220              	.L390:
 5221              	.LBE93:
 5222              	.LBE133:
 5223              	.LBB134:
 5224              	.LBB102:
3152:../uvc.c      ****     switch (wValue)
 5225              		.loc 1 3152 0
 5226 2f30 090C52E3 		cmp	r2, #2304
 5227 2f34 A901000A 		beq	.L386
 5228 2f38 D500008A 		bhi	.L392
 5229 2f3c 070C52E3 		cmp	r2, #1792
 5230 2f40 A201000A 		beq	.L385
 5231 2f44 020B52E3 		cmp	r2, #2048
 5232 2f48 1AFFFF1A 		bne	.L378
 5233 2f4c 22FFFFEA 		b	.L357
 5234              	.L415:
 5235              	.LBE102:
 5236              	.LBE134:
 5237              	.LBB135:
 5238              	.LBB126:
3377:../uvc.c      ****     switch (wValue)
 5239              		.loc 1 3377 0
 5240 2f50 0F0C53E3 		cmp	r3, #3840
 5241 2f54 9901000A 		beq	.L410
 5242 2f58 A100008A 		bhi	.L418
 5243 2f5c 0B0C53E3 		cmp	r3, #2816
 5244 2f60 FC00000A 		beq	.L407
 5245 2f64 9600008A 		bhi	.L419
 5246 2f68 0A0C53E3 		cmp	r3, #2560
 5247 2f6c 15FFFF1A 		bne	.L358
 5248              	.LVL410:
3418:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 5249              		.loc 1 3418 0
 5250 2f70 1900A0E3 		mov	r0, #25
 5251 2f74 FEFFFFEB 		bl	ControlHandle
 5252              	.LVL411:
 5253 2f78 28309DE5 		ldr	r3, [sp, #40]
 5254 2f7c 16FFFFEA 		b	.L357
 5255              	.LVL412:
 5256              	.L427:
 5257              	.LBE126:
 5258              	.LBE135:
 5259              	.LBB136:
 5260              	.LBB112:
3677:../uvc.c      ****                 switch (bRequest)
 5261              		.loc 1 3677 0
 5262 2f80 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5263 2f84 810052E3 		cmp	r2, #129
 5264 2f88 5A00000A 		beq	.L473
 5265 2f8c 2100008A 		bhi	.L476
 5266 2f90 010052E3 		cmp	r2, #1
 5267 2f94 8FFFFF1A 		bne	.L471
3702:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5268              		.loc 1 3702 0
 5269 2f98 2000A0E3 		mov	r0, #32
 5270 2f9c F8189FE5 		ldr	r1, .L548+44
 5271 2fa0 2E208DE2 		add	r2, sp, #46
 5272 2fa4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5273              	.LVL413:
3704:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 5274              		.loc 1 3704 0
 5275 2fa8 000050E3 		cmp	r0, #0
 5276 2fac 13FFFF1A 		bne	.L527
3723:../uvc.c      ****                            switch (glCommitCtrl[1])
 5277              		.loc 1 3723 0
 5278 2fb0 8120D6E5 		ldrb	r2, [r6, #129]	@ zero_extendqisi2
 5279 2fb4 011042E2 		sub	r1, r2, #1
 5280 2fb8 030051E3 		cmp	r1, #3
 5281 2fbc 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 5282 2fc0 C90100EA 		b	.L479
 5283              	.L484:
 5284 2fc4 58370000 		.word	.L480
 5285 2fc8 AC370000 		.word	.L481
 5286 2fcc 14370000 		.word	.L482
 5287 2fd0 AC360000 		.word	.L483
 5288              	.LVL414:
 5289              	.L424:
3481:../uvc.c      ****             switch (bRequest)
 5290              		.loc 1 3481 0
 5291 2fd4 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5292 2fd8 830052E3 		cmp	r2, #131
 5293 2fdc 3100008A 		bhi	.L435
 5294 2fe0 810052E3 		cmp	r2, #129
 5295 2fe4 1600003A 		bcc	.L545
 5296              	.L432:
3496:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
 5297              		.loc 1 3496 0
 5298 2fe8 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 5299 2fec 030053E3 		cmp	r3, #3
 5300 2ff0 FC00001A 		bne	.L499
3498:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
 5301              		.loc 1 3498 0
 5302 2ff4 AC189FE5 		ldr	r1, .L548+56
 5303 2ff8 1A00A0E3 		mov	r0, #26
 5304 2ffc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
3499:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 5305              		.loc 1 3499 0
 5306 3000 0400A0E3 		mov	r0, #4
 5307 3004 A0189FE5 		ldr	r1, .L548+60
 5308 3008 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5309 300c FEFFFFEB 		bl	CyU3PDebugPrint
 5310 3010 28309DE5 		ldr	r3, [sp, #40]
 5311 3014 FAFEFFEA 		b	.L421
 5312              	.L476:
3677:../uvc.c      ****                 switch (bRequest)
 5313              		.loc 1 3677 0
 5314 3018 850052E3 		cmp	r2, #133
 5315 301c 2700000A 		beq	.L474
 5316 3020 860052E3 		cmp	r2, #134
 5317 3024 6BFFFF1A 		bne	.L471
 5318              	.L531:
3681:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5319              		.loc 1 3681 0
 5320 3028 0300A0E1 		mov	r0, r3
 5321              	.L526:
3547:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5322              		.loc 1 3547 0
 5323 302c 7C189FE5 		ldr	r1, .L548+64
3546:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 5324              		.loc 1 3546 0
 5325 3030 0390A0E3 		mov	r9, #3
 5326 3034 5C90C4E5 		strb	r9, [r4, #92]
3547:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5327              		.loc 1 3547 0
 5328 3038 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5329 303c 28309DE5 		ldr	r3, [sp, #40]
 5330 3040 EFFEFFEA 		b	.L421
 5331              	.L545:
3481:../uvc.c      ****             switch (bRequest)
 5332              		.loc 1 3481 0
 5333 3044 010052E3 		cmp	r2, #1
 5334 3048 62FFFF1A 		bne	.L471
3508:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5335              		.loc 1 3508 0
 5336 304c 2000A0E3 		mov	r0, #32
 5337 3050 44189FE5 		ldr	r1, .L548+44
 5338 3054 2E208DE2 		add	r2, sp, #46
 5339 3058 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5340              	.LVL415:
3510:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5341              		.loc 1 3510 0
 5342 305c 000050E3 		cmp	r0, #0
 5343 3060 E6FEFF1A 		bne	.L527
3512:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5344              		.loc 1 3512 0
 5345 3064 4810D6E5 		ldrb	r1, [r6, #72]	@ zero_extendqisi2
 5346 3068 030051E3 		cmp	r1, #3
 5347 306c E3FEFF1A 		bne	.L527
3519:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 5348              		.loc 1 3519 0
 5349 3070 8530D4E5 		ldrb	r3, [r4, #133]	@ zero_extendqisi2
3516:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 5350              		.loc 1 3516 0
 5351 3074 82E0D4E5 		ldrb	lr, [r4, #130]	@ zero_extendqisi2
3517:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 5352              		.loc 1 3517 0
 5353 3078 83C0D4E5 		ldrb	ip, [r4, #131]	@ zero_extendqisi2
3518:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 5354              		.loc 1 3518 0
 5355 307c 8400D4E5 		ldrb	r0, [r4, #132]	@ zero_extendqisi2
 5356              	.LVL416:
3520:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 5357              		.loc 1 3520 0
 5358 3080 8620D4E5 		ldrb	r2, [r4, #134]	@ zero_extendqisi2
3521:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 5359              		.loc 1 3521 0
 5360 3084 8790D4E5 		ldrb	r9, [r4, #135]	@ zero_extendqisi2
3519:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 5361              		.loc 1 3519 0
 5362 3088 A536C5E5 		strb	r3, [r5, #1701]
3516:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 5363              		.loc 1 3516 0
 5364 308c A2E6C5E5 		strb	lr, [r5, #1698]
3517:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 5365              		.loc 1 3517 0
 5366 3090 A3C6C5E5 		strb	ip, [r5, #1699]
3518:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 5367              		.loc 1 3518 0
 5368 3094 A406C5E5 		strb	r0, [r5, #1700]
3520:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 5369              		.loc 1 3520 0
 5370 3098 A626C5E5 		strb	r2, [r5, #1702]
3521:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 5371              		.loc 1 3521 0
 5372 309c A796C5E5 		strb	r9, [r5, #1703]
 5373 30a0 28309DE5 		ldr	r3, [sp, #40]
 5374 30a4 D6FEFFEA 		b	.L421
 5375              	.LVL417:
 5376              	.L435:
3481:../uvc.c      ****             switch (bRequest)
 5377              		.loc 1 3481 0
 5378 30a8 860052E3 		cmp	r2, #134
 5379 30ac DDFFFF0A 		beq	.L531
 5380 30b0 870052E3 		cmp	r2, #135
 5381 30b4 CBFFFF0A 		beq	.L432
 5382              	.L536:
3627:../uvc.c      ****                 switch (bRequest)
 5383              		.loc 1 3627 0
 5384 30b8 850052E3 		cmp	r2, #133
 5385 30bc 45FFFF1A 		bne	.L471
 5386              	.L474:
3686:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5387              		.loc 1 3686 0
 5388 30c0 E8179FE5 		ldr	r1, .L548+64
 5389 30c4 0200A0E3 		mov	r0, #2
3684:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 5390              		.loc 1 3684 0
 5391 30c8 1A30A0E3 		mov	r3, #26
 5392              	.L528:
3771:../uvc.c      ****                         glEp0Buffer[1] = 0;
 5393              		.loc 1 3771 0
 5394 30cc 0090A0E3 		mov	r9, #0
3770:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 5395              		.loc 1 3770 0
 5396 30d0 5C30C4E5 		strb	r3, [r4, #92]
3771:../uvc.c      ****                         glEp0Buffer[1] = 0;
 5397              		.loc 1 3771 0
 5398 30d4 5D90C4E5 		strb	r9, [r4, #93]
3772:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5399              		.loc 1 3772 0
 5400 30d8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5401 30dc 28309DE5 		ldr	r3, [sp, #40]
 5402 30e0 C7FEFFEA 		b	.L421
 5403              	.L426:
3627:../uvc.c      ****                 switch (bRequest)
 5404              		.loc 1 3627 0
 5405 30e4 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5406 30e8 830052E3 		cmp	r2, #131
 5407 30ec 2F00008A 		bhi	.L467
 5408 30f0 810052E3 		cmp	r2, #129
 5409 30f4 0D00003A 		bcc	.L546
 5410              	.L473:
3689:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5411              		.loc 1 3689 0
 5412 30f8 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
3691:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 5413              		.loc 1 3691 0
 5414 30fc 0B00A0E3 		mov	r0, #11
3689:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5415              		.loc 1 3689 0
 5416 3100 030053E3 		cmp	r3, #3
3691:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 5417              		.loc 1 3691 0
 5418 3104 A8179F05 		ldreq	r1, .L548+68
3695:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 5419              		.loc 1 3695 0
 5420 3108 A8179F15 		ldrne	r1, .L548+72
 5421 310c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5422 3110 28309DE5 		ldr	r3, [sp, #40]
 5423 3114 BAFEFFEA 		b	.L421
 5424              	.L444:
3543:../uvc.c      ****             switch (bRequest)
 5425              		.loc 1 3543 0
 5426 3118 850053E3 		cmp	r3, #133
 5427 311c E7FFFF0A 		beq	.L474
 5428 3120 860053E3 		cmp	r3, #134
 5429 3124 2BFFFF1A 		bne	.L471
 5430              	.L532:
3547:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5431              		.loc 1 3547 0
 5432 3128 0100A0E3 		mov	r0, #1
 5433 312c BEFFFFEA 		b	.L526
 5434              	.L546:
3627:../uvc.c      ****                 switch (bRequest)
 5435              		.loc 1 3627 0
 5436 3130 010052E3 		cmp	r2, #1
 5437 3134 27FFFF1A 		bne	.L471
3652:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5438              		.loc 1 3652 0
 5439 3138 2000A0E3 		mov	r0, #32
 5440 313c 58179FE5 		ldr	r1, .L548+44
 5441 3140 2E208DE2 		add	r2, sp, #46
 5442 3144 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5443              	.LVL418:
3654:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 5444              		.loc 1 3654 0
 5445 3148 000050E3 		cmp	r0, #0
 5446 314c ABFEFF1A 		bne	.L527
3656:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 5447              		.loc 1 3656 0
 5448 3150 4810D6E5 		ldrb	r1, [r6, #72]	@ zero_extendqisi2
 5449 3154 030051E3 		cmp	r1, #3
 5450 3158 0B00001A 		bne	.L470
3660:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 5451              		.loc 1 3660 0
 5452 315c 81E0D6E5 		ldrb	lr, [r6, #129]	@ zero_extendqisi2
3661:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 5453              		.loc 1 3661 0
 5454 3160 82C0D6E5 		ldrb	ip, [r6, #130]	@ zero_extendqisi2
3662:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 5455              		.loc 1 3662 0
 5456 3164 8300D6E5 		ldrb	r0, [r6, #131]	@ zero_extendqisi2
 5457              	.LVL419:
3663:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 5458              		.loc 1 3663 0
 5459 3168 8420D6E5 		ldrb	r2, [r6, #132]	@ zero_extendqisi2
3664:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 5460              		.loc 1 3664 0
 5461 316c 8590D6E5 		ldrb	r9, [r6, #133]	@ zero_extendqisi2
3665:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 5462              		.loc 1 3665 0
 5463 3170 8630D6E5 		ldrb	r3, [r6, #134]	@ zero_extendqisi2
3660:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 5464              		.loc 1 3660 0
 5465 3174 F5E6C5E5 		strb	lr, [r5, #1781]
3661:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 5466              		.loc 1 3661 0
 5467 3178 F6C6C5E5 		strb	ip, [r5, #1782]
3662:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 5468              		.loc 1 3662 0
 5469 317c F706C5E5 		strb	r0, [r5, #1783]
3663:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 5470              		.loc 1 3663 0
 5471 3180 F826C5E5 		strb	r2, [r5, #1784]
3664:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 5472              		.loc 1 3664 0
 5473 3184 F996C5E5 		strb	r9, [r5, #1785]
3665:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 5474              		.loc 1 3665 0
 5475 3188 FA36C5E5 		strb	r3, [r5, #1786]
 5476              	.L470:
3667:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
 5477              		.loc 1 3667 0
 5478 318c 8190D4E5 		ldrb	r9, [r4, #129]	@ zero_extendqisi2
 5479 3190 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 5480 3194 BE22DDE1 		ldrh	r2, [sp, #46]
 5481              	.LVL420:
 5482 3198 0400A0E3 		mov	r0, #4
 5483 319c 18179FE5 		ldr	r1, .L548+76
 5484 31a0 00908DE5 		str	r9, [sp, #0]
 5485 31a4 FEFFFFEB 		bl	CyU3PDebugPrint
 5486 31a8 28309DE5 		ldr	r3, [sp, #40]
 5487 31ac 94FEFFEA 		b	.L421
 5488              	.LVL421:
 5489              	.L467:
3627:../uvc.c      ****                 switch (bRequest)
 5490              		.loc 1 3627 0
 5491 31b0 860052E3 		cmp	r2, #134
 5492 31b4 9BFFFF0A 		beq	.L531
 5493 31b8 870052E3 		cmp	r2, #135
 5494 31bc BDFFFF1A 		bne	.L536
 5495 31c0 CCFFFFEA 		b	.L473
 5496              	.LVL422:
 5497              	.L419:
 5498              	.LBE112:
 5499              	.LBE136:
 5500              	.LBB137:
 5501              	.LBB124:
3377:../uvc.c      ****     switch (wValue)
 5502              		.loc 1 3377 0
 5503 31c4 030B53E3 		cmp	r3, #3072
 5504 31c8 A401000A 		beq	.L408
 5505 31cc 0D0C53E3 		cmp	r3, #3328
 5506 31d0 7CFEFF1A 		bne	.L358
 5507              	.LVL423:
3434:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 5508              		.loc 1 3434 0
 5509 31d4 1C00A0E3 		mov	r0, #28
 5510 31d8 FEFFFFEB 		bl	ControlHandle
 5511              	.LVL424:
 5512 31dc 28309DE5 		ldr	r3, [sp, #40]
 5513 31e0 7DFEFFEA 		b	.L357
 5514              	.L418:
3377:../uvc.c      ****     switch (wValue)
 5515              		.loc 1 3377 0
 5516 31e4 110C53E3 		cmp	r3, #4352
 5517 31e8 9801000A 		beq	.L412
 5518 31ec 5100008A 		bhi	.L420
 5519 31f0 010A53E3 		cmp	r3, #4096
 5520 31f4 73FEFF1A 		bne	.L358
 5521              	.LVL425:
3446:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 5522              		.loc 1 3446 0
 5523 31f8 1F00A0E3 		mov	r0, #31
 5524 31fc FEFFFFEB 		bl	ControlHandle
 5525              	.LVL426:
 5526 3200 28309DE5 		ldr	r3, [sp, #40]
 5527 3204 74FEFFEA 		b	.L357
 5528              	.LVL427:
 5529              	.L542:
 5530              	.LBE124:
 5531              	.LBE137:
4024:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 5532              		.loc 1 4024 0
 5533 3208 0400A0E3 		mov	r0, #4
 5534              	.LVL428:
 5535 320c AC169FE5 		ldr	r1, .L548+80
 5536 3210 FEFFFFEB 		bl	CyU3PDebugPrint
 5537              	.LVL429:
 5538              	.L507:
 5539              	.LBB138:
 5540              	.LBB139:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5541              		.loc 1 1786 0
 5542 3214 A8169FE5 		ldr	r1, .L548+84
 5543 3218 0400A0E3 		mov	r0, #4
 5544 321c FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 5545              		.loc 1 1787 0
 5546 3220 FA0FA0E3 		mov	r0, #1000
 5547 3224 FEFFFFEB 		bl	_tx_thread_sleep
 5548 3228 F9FFFFEA 		b	.L507
 5549              	.L376:
 5550              	.LBE139:
 5551              	.LBE138:
 5552              	.LBB140:
 5553              	.LBB95:
3077:../uvc.c      ****     switch (wValue)
 5554              		.loc 1 3077 0
 5555 322c 010B52E3 		cmp	r2, #1024
 5556 3230 69FEFF0A 		beq	.L357
 5557 3234 050C52E3 		cmp	r2, #1280
 5558 3238 5EFEFF1A 		bne	.L378
 5559              	.LVL430:
3096:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 5560              		.loc 1 3096 0
 5561 323c 0400A0E3 		mov	r0, #4
 5562 3240 FEFFFFEB 		bl	ControlHandle
 5563              	.LVL431:
 5564 3244 28309DE5 		ldr	r3, [sp, #40]
 5565 3248 63FEFFEA 		b	.L357
 5566              	.LVL432:
 5567              	.L544:
 5568              	.LBE95:
 5569              	.LBE140:
3997:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 5570              		.loc 1 3997 0
 5571 324c 0400A0E3 		mov	r0, #4
 5572              	.LVL433:
 5573 3250 68169FE5 		ldr	r1, .L548+80
 5574 3254 FEFFFFEB 		bl	CyU3PDebugPrint
 5575              	.LVL434:
 5576              	.L505:
 5577              	.LBB141:
 5578              	.LBB142:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5579              		.loc 1 1786 0
 5580 3258 64169FE5 		ldr	r1, .L548+84
 5581 325c 0400A0E3 		mov	r0, #4
 5582 3260 FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 5583              		.loc 1 1787 0
 5584 3264 FA0FA0E3 		mov	r0, #1000
 5585 3268 FEFFFFEB 		bl	_tx_thread_sleep
 5586 326c F9FFFFEA 		b	.L505
 5587              	.L416:
 5588              	.LBE142:
 5589              	.LBE141:
 5590              	.LBB143:
 5591              	.LBB127:
3377:../uvc.c      ****     switch (wValue)
 5592              		.loc 1 3377 0
 5593 3270 060C53E3 		cmp	r3, #1536
 5594 3274 7101000A 		beq	.L402
 5595 3278 0F00008A 		bhi	.L417
 5596 327c 050C53E3 		cmp	r3, #1280
 5597 3280 50FEFF1A 		bne	.L358
 5598              	.LVL435:
3397:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 5599              		.loc 1 3397 0
 5600 3284 1400A0E3 		mov	r0, #20
 5601 3288 FEFFFFEB 		bl	ControlHandle
 5602              	.LVL436:
 5603 328c 28309DE5 		ldr	r3, [sp, #40]
 5604 3290 51FEFFEA 		b	.L357
 5605              	.L392:
 5606              	.LBE127:
 5607              	.LBE143:
 5608              	.LBB144:
 5609              	.LBB105:
3152:../uvc.c      ****     switch (wValue)
 5610              		.loc 1 3152 0
 5611 3294 0B0C52E3 		cmp	r2, #2816
 5612 3298 6401000A 		beq	.L388
 5613 329c 030B52E3 		cmp	r2, #3072
 5614 32a0 5E01000A 		beq	.L389
 5615 32a4 0A0C52E3 		cmp	r2, #2560
 5616 32a8 42FEFF1A 		bne	.L378
 5617              	.LVL437:
3193:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 5618              		.loc 1 3193 0
 5619 32ac 0800A0E3 		mov	r0, #8
 5620 32b0 FEFFFFEB 		bl	CTControlHandle
 5621              	.LVL438:
 5622 32b4 28309DE5 		ldr	r3, [sp, #40]
 5623 32b8 47FEFFEA 		b	.L357
 5624              	.L417:
 5625              	.LBE105:
 5626              	.LBE144:
 5627              	.LBB145:
 5628              	.LBB123:
3377:../uvc.c      ****     switch (wValue)
 5629              		.loc 1 3377 0
 5630 32bc 070C53E3 		cmp	r3, #1792
 5631 32c0 5201000A 		beq	.L403
 5632 32c4 020B53E3 		cmp	r3, #2048
 5633 32c8 3EFEFF1A 		bne	.L358
 5634              	.LVL439:
3409:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 5635              		.loc 1 3409 0
 5636 32cc 1700A0E3 		mov	r0, #23
 5637 32d0 FEFFFFEB 		bl	ControlHandle
 5638              	.LVL440:
 5639 32d4 28309DE5 		ldr	r3, [sp, #40]
 5640 32d8 3FFEFFEA 		b	.L357
 5641              	.L391:
 5642              	.LBE123:
 5643              	.LBE145:
 5644              	.LBB146:
 5645              	.LBB101:
3152:../uvc.c      ****     switch (wValue)
 5646              		.loc 1 3152 0
 5647 32dc 010B52E3 		cmp	r2, #1024
 5648 32e0 4601000A 		beq	.L382
 5649 32e4 050C52E3 		cmp	r2, #1280
 5650 32e8 32FEFF1A 		bne	.L378
 5651              	.LVL441:
3174:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 5652              		.loc 1 3174 0
 5653 32ec 0400A0E3 		mov	r0, #4
 5654 32f0 FEFFFFEB 		bl	CTControlHandle
 5655              	.LVL442:
 5656 32f4 28309DE5 		ldr	r3, [sp, #40]
 5657 32f8 37FEFFEA 		b	.L357
 5658              	.L377:
 5659              	.LBE101:
 5660              	.LBE146:
 5661              	.LBB147:
 5662              	.LBB92:
3077:../uvc.c      ****     switch (wValue)
 5663              		.loc 1 3077 0
 5664 32fc 0D0C52E3 		cmp	r2, #3328
 5665 3300 1C00000A 		beq	.L372
 5666 3304 0E0C52E3 		cmp	r2, #3584
 5667 3308 D700000A 		beq	.L374
 5668 330c 030B52E3 		cmp	r2, #3072
 5669 3310 28FEFF1A 		bne	.L378
 5670              	.LVL443:
3118:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 5671              		.loc 1 3118 0
 5672 3314 0B00A0E3 		mov	r0, #11
 5673 3318 FEFFFFEB 		bl	ControlHandle
 5674              	.LVL444:
 5675 331c 28309DE5 		ldr	r3, [sp, #40]
 5676 3320 2DFEFFEA 		b	.L357
 5677              	.LVL445:
 5678              	.L498:
 5679              	.LBE92:
 5680              	.LBE147:
 5681              	.LBB148:
 5682              	.LBB115:
3763:../uvc.c      ****             	switch (bRequest)
 5683              		.loc 1 3763 0
 5684 3324 850052E3 		cmp	r2, #133
 5685 3328 CC00000A 		beq	.L496
 5686 332c 860052E3 		cmp	r2, #134
 5687 3330 2EFEFF1A 		bne	.L423
 5688 3334 7BFFFFEA 		b	.L532
 5689              	.LVL446:
 5690              	.L420:
 5691              	.LBE115:
 5692              	.LBE148:
 5693              	.LBB149:
 5694              	.LBB128:
3377:../uvc.c      ****     switch (wValue)
 5695              		.loc 1 3377 0
 5696 3338 120C53E3 		cmp	r3, #4608
 5697 333c C300000A 		beq	.L413
 5698 3340 130C53E3 		cmp	r3, #4864
 5699 3344 1FFEFF1A 		bne	.L358
 5700              	.LVL447:
3458:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
 5701              		.loc 1 3458 0
 5702 3348 2600A0E3 		mov	r0, #38
 5703 334c FEFFFFEB 		bl	ControlHandle
 5704              	.LVL448:
 5705 3350 28309DE5 		ldr	r3, [sp, #40]
 5706 3354 20FEFFEA 		b	.L357
 5707              	.L407:
 5708              	.LVL449:
3424:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 5709              		.loc 1 3424 0
 5710 3358 1A00A0E3 		mov	r0, #26
 5711 335c FEFFFFEB 		bl	ControlHandle
 5712              	.LVL450:
 5713 3360 28309DE5 		ldr	r3, [sp, #40]
 5714 3364 1CFEFFEA 		b	.L357
 5715              	.L370:
 5716              	.LVL451:
 5717              	.LBE128:
 5718              	.LBE149:
 5719              	.LBB150:
 5720              	.LBB96:
3104:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 5721              		.loc 1 3104 0
 5722 3368 0600A0E3 		mov	r0, #6
 5723 336c FEFFFFEB 		bl	ControlHandle
 5724              	.LVL452:
 5725 3370 28309DE5 		ldr	r3, [sp, #40]
 5726 3374 18FEFFEA 		b	.L357
 5727              	.L372:
 5728              	.LVL453:
3114:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 5729              		.loc 1 3114 0
 5730 3378 0900A0E3 		mov	r0, #9
 5731 337c FEFFFFEB 		bl	ControlHandle
 5732              	.LVL454:
 5733 3380 28309DE5 		ldr	r3, [sp, #40]
 5734 3384 14FEFFEA 		b	.L357
 5735              	.LVL455:
 5736              	.L500:
 5737              	.LBE96:
 5738              	.LBE150:
 5739              	.LBB151:
 5740              	.LBB111:
3806:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 5741              		.loc 1 3806 0
 5742 3388 38159FE5 		ldr	r1, .L548+88
 5743 338c BE22DDE1 		ldrh	r2, [sp, #46]
 5744 3390 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 5745 3394 0400A0E3 		mov	r0, #4
 5746              	.LVL456:
 5747 3398 FEFFFFEB 		bl	CyU3PDebugPrint
 5748 339c 13FEFFEA 		b	.L423
 5749              	.LVL457:
 5750              	.L543:
3568:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5751              		.loc 1 3568 0
 5752 33a0 2000A0E3 		mov	r0, #32
 5753 33a4 F0149FE5 		ldr	r1, .L548+44
 5754 33a8 2E208DE2 		add	r2, sp, #46
 5755 33ac FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5756              	.LVL458:
3570:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5757              		.loc 1 3570 0
 5758 33b0 000050E3 		cmp	r0, #0
 5759 33b4 11FEFF1A 		bne	.L527
3572:../uvc.c      ****                         switch (glCommitCtrl[3])
 5760              		.loc 1 3572 0
 5761 33b8 8320D4E5 		ldrb	r2, [r4, #131]	@ zero_extendqisi2
 5762 33bc 011042E2 		sub	r1, r2, #1
 5763 33c0 030051E3 		cmp	r1, #3
 5764 33c4 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 5765 33c8 2E0000EA 		b	.L447
 5766              	.L452:
 5767 33cc 28350000 		.word	.L448
 5768 33d0 74350000 		.word	.L449
 5769 33d4 CC340000 		.word	.L450
 5770 33d8 30340000 		.word	.L451
 5771              	.LVL459:
 5772              	.L495:
3775:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5773              		.loc 1 3775 0
 5774 33dc 4810D4E5 		ldrb	r1, [r4, #72]	@ zero_extendqisi2
 5775 33e0 030051E3 		cmp	r1, #3
 5776 33e4 0400000A 		beq	.L547
 5777              	.L499:
3781:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 5778              		.loc 1 3781 0
 5779 33e8 1A00A0E3 		mov	r0, #26
 5780 33ec D8149FE5 		ldr	r1, .L548+92
 5781 33f0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5782 33f4 28309DE5 		ldr	r3, [sp, #40]
 5783 33f8 01FEFFEA 		b	.L421
 5784              	.L547:
3777:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 5785              		.loc 1 3777 0
 5786 33fc 1A00A0E3 		mov	r0, #26
 5787 3400 C8149FE5 		ldr	r1, .L548+96
 5788 3404 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5789 3408 28309DE5 		ldr	r3, [sp, #40]
 5790 340c FCFDFFEA 		b	.L421
 5791              	.LVL460:
 5792              	.L399:
 5793              	.LBE111:
 5794              	.LBE151:
 5795              	.LBB152:
 5796              	.LBB122:
3389:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 5797              		.loc 1 3389 0
 5798 3410 1200A0E3 		mov	r0, #18
 5799 3414 FEFFFFEB 		bl	ControlHandle
 5800              	.LVL461:
 5801 3418 28309DE5 		ldr	r3, [sp, #40]
 5802 341c EEFDFFEA 		b	.L357
 5803              	.L398:
 5804              	.LVL462:
3385:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 5805              		.loc 1 3385 0
 5806 3420 1100A0E3 		mov	r0, #17
 5807 3424 FEFFFFEB 		bl	ControlHandle
 5808              	.LVL463:
 5809 3428 28309DE5 		ldr	r3, [sp, #40]
 5810 342c EAFDFFEA 		b	.L357
 5811              	.LVL464:
 5812              	.L451:
 5813              	.LBE122:
 5814              	.LBE152:
 5815              	.LBB153:
 5816              	.LBB116:
3590:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
 5817              		.loc 1 3590 0
 5818 3430 58C094E5 		ldr	ip, [r4, #88]
 5819 3434 8C04D5E5 		ldrb	r0, [r5, #1164]	@ zero_extendqisi2
 5820              	.LVL465:
 5821 3438 00005CE3 		cmp	ip, #0
 5822 343c F4C0A003 		moveq	ip, #244
 5823 3440 74C0A013 		movne	ip, #116
 5824 3444 00208CE1 		orr	r2, ip, r0
 5825 3448 3010A0E3 		mov	r1, #48
 5826 344c 5230A0E3 		mov	r3, #82
 5827 3450 0100A0E3 		mov	r0, #1
 5828 3454 FEFFFFEB 		bl	SensorSetIrisControl
3591:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5829              		.loc 1 3591 0
 5830 3458 7D0FA0E3 		mov	r0, #500
 5831 345c FEFFFFEB 		bl	_tx_thread_sleep
3592:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 5832              		.loc 1 3592 0
 5833 3460 582094E5 		ldr	r2, [r4, #88]
 5834 3464 8C94D5E5 		ldrb	r9, [r5, #1164]	@ zero_extendqisi2
 5835 3468 000052E3 		cmp	r2, #0
 5836 346c F420A003 		moveq	r2, #244
 5837 3470 7420A013 		movne	r2, #116
 5838 3474 583094E5 		ldr	r3, [r4, #88]
 5839 3478 0400A0E3 		mov	r0, #4
 5840 347c 50149FE5 		ldr	r1, .L548+100
 5841 3480 092082E1 		orr	r2, r2, r9
 5842 3484 FEFFFFEB 		bl	CyU3PDebugPrint
 5843              	.L447:
3597:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5844              		.loc 1 3597 0
 5845 3488 83E0D4E5 		ldrb	lr, [r4, #131]	@ zero_extendqisi2
3598:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 5846              		.loc 1 3598 0
 5847 348c 44149FE5 		ldr	r1, .L548+104
 5848 3490 0E20A0E1 		mov	r2, lr
 5849 3494 0400A0E3 		mov	r0, #4
3597:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5850              		.loc 1 3597 0
 5851 3498 7DE0C4E5 		strb	lr, [r4, #125]
3598:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 5852              		.loc 1 3598 0
 5853 349c FEFFFFEB 		bl	CyU3PDebugPrint
3611:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5854              		.loc 1 3611 0
 5855 34a0 0020A0E3 		mov	r2, #0
 5856 34a4 C4039FE5 		ldr	r0, .L548
 5857 34a8 0110A0E3 		mov	r1, #1
 5858 34ac FEFFFFEB 		bl	_txe_event_flags_set
 5859              	.LVL466:
3612:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5860              		.loc 1 3612 0
 5861 34b0 002050E2 		subs	r2, r0, #0
 5862 34b4 D1FDFF0A 		beq	.L527
3614:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
 5863              		.loc 1 3614 0
 5864 34b8 0400A0E3 		mov	r0, #4
 5865              	.LVL467:
 5866 34bc 18149FE5 		ldr	r1, .L548+108
 5867 34c0 FEFFFFEB 		bl	CyU3PDebugPrint
 5868              	.LVL468:
 5869 34c4 28309DE5 		ldr	r3, [sp, #40]
 5870 34c8 CDFDFFEA 		b	.L421
 5871              	.LVL469:
 5872              	.L450:
3585:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
 5873              		.loc 1 3585 0
 5874 34cc 58E094E5 		ldr	lr, [r4, #88]
 5875 34d0 8C34D5E5 		ldrb	r3, [r5, #1164]	@ zero_extendqisi2
 5876 34d4 00005EE3 		cmp	lr, #0
 5877 34d8 C4E0A003 		moveq	lr, #196
 5878 34dc 44E0A013 		movne	lr, #68
 5879 34e0 03208EE1 		orr	r2, lr, r3
 5880 34e4 3010A0E3 		mov	r1, #48
 5881 34e8 5230A0E3 		mov	r3, #82
 5882 34ec 0100A0E3 		mov	r0, #1
 5883              	.LVL470:
 5884 34f0 FEFFFFEB 		bl	SensorSetIrisControl
3586:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5885              		.loc 1 3586 0
 5886 34f4 7D0FA0E3 		mov	r0, #500
 5887 34f8 FEFFFFEB 		bl	_tx_thread_sleep
3587:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 5888              		.loc 1 3587 0
 5889 34fc 580094E5 		ldr	r0, [r4, #88]
 5890 3500 8CC4D5E5 		ldrb	ip, [r5, #1164]	@ zero_extendqisi2
 5891 3504 000050E3 		cmp	r0, #0
 5892 3508 C400A003 		moveq	r0, #196
 5893 350c 4400A013 		movne	r0, #68
 5894 3510 0C2080E1 		orr	r2, r0, ip
 5895 3514 583094E5 		ldr	r3, [r4, #88]
 5896 3518 B4139FE5 		ldr	r1, .L548+100
 5897 351c 0400A0E3 		mov	r0, #4
 5898 3520 FEFFFFEB 		bl	CyU3PDebugPrint
 5899 3524 D7FFFFEA 		b	.L447
 5900              	.LVL471:
 5901              	.L448:
3575:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
 5902              		.loc 1 3575 0
 5903 3528 582094E5 		ldr	r2, [r4, #88]
 5904 352c 3010A0E3 		mov	r1, #48
 5905 3530 000052E3 		cmp	r2, #0
 5906 3534 E420A003 		moveq	r2, #228
 5907 3538 6420A013 		movne	r2, #100
 5908 353c 5230A0E3 		mov	r3, #82
 5909 3540 0100A0E3 		mov	r0, #1
 5910              	.LVL472:
 5911 3544 FEFFFFEB 		bl	SensorSetIrisControl
3576:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5912              		.loc 1 3576 0
 5913 3548 7D0FA0E3 		mov	r0, #500
 5914 354c FEFFFFEB 		bl	_tx_thread_sleep
3577:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 5915              		.loc 1 3577 0
 5916 3550 582094E5 		ldr	r2, [r4, #88]
 5917 3554 78139FE5 		ldr	r1, .L548+100
 5918 3558 000052E3 		cmp	r2, #0
 5919 355c 583094E5 		ldr	r3, [r4, #88]
 5920 3560 E420A003 		moveq	r2, #228
 5921 3564 6420A013 		movne	r2, #100
 5922 3568 0400A0E3 		mov	r0, #4
 5923 356c FEFFFFEB 		bl	CyU3PDebugPrint
 5924 3570 C4FFFFEA 		b	.L447
 5925              	.LVL473:
 5926              	.L449:
3580:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
 5927              		.loc 1 3580 0
 5928 3574 582094E5 		ldr	r2, [r4, #88]
 5929 3578 3010A0E3 		mov	r1, #48
 5930 357c 000052E3 		cmp	r2, #0
 5931 3580 D420A003 		moveq	r2, #212
 5932 3584 5420A013 		movne	r2, #84
 5933 3588 5230A0E3 		mov	r3, #82
 5934 358c 0100A0E3 		mov	r0, #1
 5935              	.LVL474:
 5936 3590 FEFFFFEB 		bl	SensorSetIrisControl
3581:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5937              		.loc 1 3581 0
 5938 3594 7D0FA0E3 		mov	r0, #500
 5939 3598 FEFFFFEB 		bl	_tx_thread_sleep
3582:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 5940              		.loc 1 3582 0
 5941 359c 582094E5 		ldr	r2, [r4, #88]
 5942 35a0 2C139FE5 		ldr	r1, .L548+100
 5943 35a4 000052E3 		cmp	r2, #0
 5944 35a8 583094E5 		ldr	r3, [r4, #88]
 5945 35ac D420A003 		moveq	r2, #212
 5946 35b0 5420A013 		movne	r2, #84
 5947 35b4 0400A0E3 		mov	r0, #4
 5948 35b8 FEFFFFEB 		bl	CyU3PDebugPrint
 5949 35bc B1FFFFEA 		b	.L447
 5950              	.L410:
 5951              	.LVL475:
 5952              	.LBE116:
 5953              	.LBE153:
 5954              	.LBB154:
 5955              	.LBB129:
3442:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 5956              		.loc 1 3442 0
 5957 35c0 1E00A0E3 		mov	r0, #30
 5958 35c4 FEFFFFEB 		bl	ControlHandle
 5959              	.LVL476:
 5960 35c8 28309DE5 		ldr	r3, [sp, #40]
 5961 35cc 82FDFFEA 		b	.L357
 5962              	.L385:
 5963              	.LVL477:
 5964              	.LBE129:
 5965              	.LBE154:
 5966              	.LBB155:
 5967              	.LBB106:
3182:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 5968              		.loc 1 3182 0
 5969 35d0 0600A0E3 		mov	r0, #6
 5970 35d4 FEFFFFEB 		bl	CTControlHandle
 5971              	.LVL478:
 5972 35d8 28309DE5 		ldr	r3, [sp, #40]
 5973 35dc 7EFDFFEA 		b	.L357
 5974              	.L386:
 5975              	.LVL479:
3188:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 5976              		.loc 1 3188 0
 5977 35e0 0700A0E3 		mov	r0, #7
 5978 35e4 FEFFFFEB 		bl	CTControlHandle
 5979              	.LVL480:
 5980 35e8 28309DE5 		ldr	r3, [sp, #40]
 5981 35ec 7AFDFFEA 		b	.L357
 5982              	.L367:
 5983              	.LVL481:
 5984              	.LBE106:
 5985              	.LBE155:
 5986              	.LBB156:
 5987              	.LBB91:
3089:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 5988              		.loc 1 3089 0
 5989 35f0 0200A0E3 		mov	r0, #2
 5990 35f4 FEFFFFEB 		bl	ControlHandle
 5991              	.LVL482:
 5992 35f8 28309DE5 		ldr	r3, [sp, #40]
 5993 35fc 76FDFFEA 		b	.L357
 5994              	.L369:
 5995              	.LVL483:
3100:../uvc.c      ****      		ControlHandle(HueCtlID5);
 5996              		.loc 1 3100 0
 5997 3600 0500A0E3 		mov	r0, #5
 5998 3604 FEFFFFEB 		bl	ControlHandle
 5999              	.LVL484:
 6000 3608 28309DE5 		ldr	r3, [sp, #40]
 6001 360c 72FDFFEA 		b	.L357
 6002              	.L400:
 6003              	.LVL485:
 6004              	.LBE91:
 6005              	.LBE156:
 6006              	.LBB157:
 6007              	.LBB121:
3393:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 6008              		.loc 1 3393 0
 6009 3610 1300A0E3 		mov	r0, #19
 6010 3614 FEFFFFEB 		bl	ControlHandle
 6011              	.LVL486:
 6012 3618 28309DE5 		ldr	r3, [sp, #40]
 6013 361c 6EFDFFEA 		b	.L357
 6014              	.L405:
 6015              	.LVL487:
3413:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 6016              		.loc 1 3413 0
 6017 3620 1800A0E3 		mov	r0, #24
 6018 3624 FEFFFFEB 		bl	ControlHandle
 6019              	.LVL488:
 6020 3628 28309DE5 		ldr	r3, [sp, #40]
 6021 362c 6AFDFFEA 		b	.L357
 6022              	.L379:
 6023              	.LVL489:
 6024              	.LBE121:
 6025              	.LBE157:
 6026              	.LBB158:
 6027              	.LBB100:
3156:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 6028              		.loc 1 3156 0
 6029 3630 0000A0E3 		mov	r0, #0
 6030 3634 FEFFFFEB 		bl	CTControlHandle
 6031              	.LVL490:
 6032 3638 28309DE5 		ldr	r3, [sp, #40]
 6033 363c 66FDFFEA 		b	.L357
 6034              	.L381:
 6035              	.LVL491:
3164:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 6036              		.loc 1 3164 0
 6037 3640 0200A0E3 		mov	r0, #2
 6038 3644 FEFFFFEB 		bl	CTControlHandle
 6039              	.LVL492:
 6040 3648 28309DE5 		ldr	r3, [sp, #40]
 6041 364c 62FDFFEA 		b	.L357
 6042              	.L413:
 6043              	.LVL493:
 6044              	.LBE100:
 6045              	.LBE158:
 6046              	.LBB159:
 6047              	.LBB130:
3454:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
 6048              		.loc 1 3454 0
 6049 3650 2500A0E3 		mov	r0, #37
 6050 3654 FEFFFFEB 		bl	ControlHandle
 6051              	.LVL494:
 6052 3658 28309DE5 		ldr	r3, [sp, #40]
 6053 365c 5EFDFFEA 		b	.L357
 6054              	.LVL495:
 6055              	.L496:
 6056              	.LBE130:
 6057              	.LBE159:
 6058              	.LBB160:
 6059              	.LBB110:
3772:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6060              		.loc 1 3772 0
 6061 3660 0200A0E3 		mov	r0, #2
 6062 3664 44129FE5 		ldr	r1, .L548+64
 6063 3668 97FEFFEA 		b	.L528
 6064              	.LVL496:
 6065              	.L374:
 6066              	.LBE110:
 6067              	.LBE160:
 6068              	.LBB161:
 6069              	.LBB97:
3122:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 6070              		.loc 1 3122 0
 6071 366c 0E00A0E3 		mov	r0, #14
 6072 3670 FEFFFFEB 		bl	ControlHandle
 6073              	.LVL497:
 6074 3674 28309DE5 		ldr	r3, [sp, #40]
 6075 3678 57FDFFEA 		b	.L357
 6076              	.L539:
 6077              	.LVL498:
3085:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 6078              		.loc 1 3085 0
 6079 367c 0100A0E3 		mov	r0, #1
 6080 3680 FEFFFFEB 		bl	ControlHandle
 6081              	.LVL499:
 6082 3684 28309DE5 		ldr	r3, [sp, #40]
 6083 3688 53FDFFEA 		b	.L357
 6084              	.L365:
 6085              	.LVL500:
3081:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 6086              		.loc 1 3081 0
 6087 368c 0000A0E3 		mov	r0, #0
 6088 3690 FEFFFFEB 		bl	ControlHandle
 6089              	.LVL501:
 6090 3694 28309DE5 		ldr	r3, [sp, #40]
 6091 3698 4FFDFFEA 		b	.L357
 6092              	.L384:
 6093              	.LVL502:
 6094              	.LBE97:
 6095              	.LBE161:
 6096              	.LBB162:
 6097              	.LBB107:
3178:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 6098              		.loc 1 3178 0
 6099 369c 0500A0E3 		mov	r0, #5
 6100 36a0 FEFFFFEB 		bl	CTControlHandle
 6101              	.LVL503:
 6102 36a4 28309DE5 		ldr	r3, [sp, #40]
 6103 36a8 4BFDFFEA 		b	.L357
 6104              	.LVL504:
 6105              	.L483:
 6106              	.LBE107:
 6107              	.LBE162:
 6108              	.LBB163:
 6109              	.LBB117:
3726:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
 6110              		.loc 1 3726 0
 6111 36ac 582094E5 		ldr	r2, [r4, #88]
 6112 36b0 3010A0E3 		mov	r1, #48
 6113 36b4 000052E3 		cmp	r2, #0
 6114 36b8 E420A003 		moveq	r2, #228
 6115 36bc 6420A013 		movne	r2, #100
 6116 36c0 5230A0E3 		mov	r3, #82
 6117 36c4 0100A0E3 		mov	r0, #1
 6118              	.LVL505:
 6119 36c8 FEFFFFEB 		bl	SensorSetIrisControl
3728:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
 6120              		.loc 1 3728 0
 6121 36cc 582094E5 		ldr	r2, [r4, #88]
 6122 36d0 08129FE5 		ldr	r1, .L548+112
 6123 36d4 000052E3 		cmp	r2, #0
 6124 36d8 583094E5 		ldr	r3, [r4, #88]
 6125 36dc E420A003 		moveq	r2, #228
 6126 36e0 6420A013 		movne	r2, #100
 6127 36e4 0400A0E3 		mov	r0, #4
 6128 36e8 FEFFFFEB 		bl	CyU3PDebugPrint
 6129              	.L479:
3748:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 6130              		.loc 1 3748 0
 6131 36ec 81E0D4E5 		ldrb	lr, [r4, #129]	@ zero_extendqisi2
3750:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 6132              		.loc 1 3750 0
 6133 36f0 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 6134 36f4 BE22DDE1 		ldrh	r2, [sp, #46]
 6135              	.LVL506:
 6136 36f8 0400A0E3 		mov	r0, #4
 6137 36fc E0119FE5 		ldr	r1, .L548+116
3748:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 6138              		.loc 1 3748 0
 6139 3700 A0E0C4E5 		strb	lr, [r4, #160]
3750:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 6140              		.loc 1 3750 0
 6141 3704 00E08DE5 		str	lr, [sp, #0]
 6142 3708 FEFFFFEB 		bl	CyU3PDebugPrint
 6143 370c 28309DE5 		ldr	r3, [sp, #40]
 6144 3710 3BFDFFEA 		b	.L421
 6145              	.LVL507:
 6146              	.L482:
3731:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
 6147              		.loc 1 3731 0
 6148 3714 582094E5 		ldr	r2, [r4, #88]
 6149 3718 3010A0E3 		mov	r1, #48
 6150 371c 000052E3 		cmp	r2, #0
 6151 3720 D420A003 		moveq	r2, #212
 6152 3724 5420A013 		movne	r2, #84
 6153 3728 5230A0E3 		mov	r3, #82
 6154 372c 0100A0E3 		mov	r0, #1
 6155              	.LVL508:
 6156 3730 FEFFFFEB 		bl	SensorSetIrisControl
3733:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
 6157              		.loc 1 3733 0
 6158 3734 582094E5 		ldr	r2, [r4, #88]
 6159 3738 A0119FE5 		ldr	r1, .L548+112
 6160 373c 000052E3 		cmp	r2, #0
 6161 3740 583094E5 		ldr	r3, [r4, #88]
 6162 3744 D420A003 		moveq	r2, #212
 6163 3748 5420A013 		movne	r2, #84
 6164 374c 0400A0E3 		mov	r0, #4
 6165 3750 FEFFFFEB 		bl	CyU3PDebugPrint
 6166 3754 E4FFFFEA 		b	.L479
 6167              	.LVL509:
 6168              	.L480:
3741:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
 6169              		.loc 1 3741 0
 6170 3758 580094E5 		ldr	r0, [r4, #88]
 6171              	.LVL510:
 6172 375c 8C34D5E5 		ldrb	r3, [r5, #1164]	@ zero_extendqisi2
 6173 3760 000050E3 		cmp	r0, #0
 6174 3764 F400A003 		moveq	r0, #244
 6175 3768 7400A013 		movne	r0, #116
 6176 376c 032080E1 		orr	r2, r0, r3
 6177 3770 3010A0E3 		mov	r1, #48
 6178 3774 5230A0E3 		mov	r3, #82
 6179 3778 0100A0E3 		mov	r0, #1
 6180 377c FEFFFFEB 		bl	SensorSetIrisControl
3743:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
 6181              		.loc 1 3743 0
 6182 3780 58C094E5 		ldr	ip, [r4, #88]
 6183 3784 8C24D5E5 		ldrb	r2, [r5, #1164]	@ zero_extendqisi2
 6184 3788 00005CE3 		cmp	ip, #0
 6185 378c F4C0A003 		moveq	ip, #244
 6186 3790 74C0A013 		movne	ip, #116
 6187 3794 583094E5 		ldr	r3, [r4, #88]
 6188 3798 40119FE5 		ldr	r1, .L548+112
 6189 379c 02208CE1 		orr	r2, ip, r2
 6190 37a0 0400A0E3 		mov	r0, #4
 6191 37a4 FEFFFFEB 		bl	CyU3PDebugPrint
 6192 37a8 CFFFFFEA 		b	.L479
 6193              	.LVL511:
 6194              	.L481:
3736:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
 6195              		.loc 1 3736 0
 6196 37ac 58E094E5 		ldr	lr, [r4, #88]
 6197 37b0 8C94D5E5 		ldrb	r9, [r5, #1164]	@ zero_extendqisi2
 6198 37b4 00005EE3 		cmp	lr, #0
 6199 37b8 C4E0A003 		moveq	lr, #196
 6200 37bc 44E0A013 		movne	lr, #68
 6201 37c0 09208EE1 		orr	r2, lr, r9
 6202 37c4 3010A0E3 		mov	r1, #48
 6203 37c8 5230A0E3 		mov	r3, #82
 6204 37cc 0100A0E3 		mov	r0, #1
 6205              	.LVL512:
 6206 37d0 FEFFFFEB 		bl	SensorSetIrisControl
3738:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
 6207              		.loc 1 3738 0
 6208 37d4 580094E5 		ldr	r0, [r4, #88]
 6209 37d8 8CC4D5E5 		ldrb	ip, [r5, #1164]	@ zero_extendqisi2
 6210 37dc 000050E3 		cmp	r0, #0
 6211 37e0 C400A003 		moveq	r0, #196
 6212 37e4 4400A013 		movne	r0, #68
 6213 37e8 0C2080E1 		orr	r2, r0, ip
 6214 37ec 583094E5 		ldr	r3, [r4, #88]
 6215 37f0 E8109FE5 		ldr	r1, .L548+112
 6216 37f4 0400A0E3 		mov	r0, #4
 6217 37f8 FEFFFFEB 		bl	CyU3PDebugPrint
 6218 37fc BAFFFFEA 		b	.L479
 6219              	.L382:
 6220              	.LVL513:
 6221              	.LBE117:
 6222              	.LBE163:
 6223              	.LBB164:
 6224              	.LBB99:
3169:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 6225              		.loc 1 3169 0
 6226 3800 0300A0E3 		mov	r0, #3
 6227 3804 FEFFFFEB 		bl	CTControlHandle
 6228              	.LVL514:
 6229 3808 28309DE5 		ldr	r3, [sp, #40]
 6230 380c F2FCFFEA 		b	.L357
 6231              	.L403:
 6232              	.LVL515:
 6233              	.LBE99:
 6234              	.LBE164:
 6235              	.LBB165:
 6236              	.LBB120:
3405:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 6237              		.loc 1 3405 0
 6238 3810 1600A0E3 		mov	r0, #22
 6239 3814 FEFFFFEB 		bl	ControlHandle
 6240              	.LVL516:
 6241 3818 28309DE5 		ldr	r3, [sp, #40]
 6242 381c EEFCFFEA 		b	.L357
 6243              	.L389:
 6244              	.LVL517:
 6245              	.LBE120:
 6246              	.LBE165:
 6247              	.LBB166:
 6248              	.LBB108:
3201:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 6249              		.loc 1 3201 0
 6250 3820 0A00A0E3 		mov	r0, #10
 6251 3824 FEFFFFEB 		bl	CTControlHandle
 6252              	.LVL518:
 6253 3828 28309DE5 		ldr	r3, [sp, #40]
 6254 382c EAFCFFEA 		b	.L357
 6255              	.L388:
 6256              	.LVL519:
3197:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 6257              		.loc 1 3197 0
 6258 3830 0900A0E3 		mov	r0, #9
 6259 3834 FEFFFFEB 		bl	CTControlHandle
 6260              	.LVL520:
 6261 3838 28309DE5 		ldr	r3, [sp, #40]
 6262 383c E6FCFFEA 		b	.L357
 6263              	.L402:
 6264              	.LVL521:
 6265              	.LBE108:
 6266              	.LBE166:
 6267              	.LBB167:
 6268              	.LBB131:
3401:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 6269              		.loc 1 3401 0
 6270 3840 1500A0E3 		mov	r0, #21
 6271 3844 FEFFFFEB 		bl	ControlHandle
 6272              	.LVL522:
 6273 3848 28309DE5 		ldr	r3, [sp, #40]
 6274 384c E2FCFFEA 		b	.L357
 6275              	.L412:
 6276              	.LVL523:
3450:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
 6277              		.loc 1 3450 0
 6278 3850 2400A0E3 		mov	r0, #36
 6279 3854 FEFFFFEB 		bl	ControlHandle
 6280              	.LVL524:
 6281 3858 28309DE5 		ldr	r3, [sp, #40]
 6282 385c DEFCFFEA 		b	.L357
 6283              	.L408:
 6284              	.LVL525:
3428:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
 6285              		.loc 1 3428 0
 6286 3860 1B00A0E3 		mov	r0, #27
 6287 3864 FEFFFFEB 		bl	ControlHandle
 6288              	.LVL526:
 6289 3868 28309DE5 		ldr	r3, [sp, #40]
 6290 386c DAFCFFEA 		b	.L357
 6291              	.L549:
 6292              		.align	2
 6293              	.L548:
 6294 3870 00000000 		.word	.LANCHOR0
 6295 3874 00000000 		.word	.LANCHOR1
 6296 3878 00000000 		.word	bRequest
 6297 387c 00000000 		.word	wValue
 6298 3880 00000000 		.word	wIndex
 6299 3884 00000000 		.word	glInterStaBuffer
 6300 3888 CC050000 		.word	.LC31
 6301 388c 00000000 		.word	glChHandleInterStat
 6302 3890 00000000 		.word	bmReqType
 6303 3894 00000000 		.word	wLength
 6304 3898 50050000 		.word	.LC30
 6305 389c 80000000 		.word	.LANCHOR0+128
 6306 38a0 0C070000 		.word	.LC39
 6307 38a4 30070000 		.word	.LC40
 6308 38a8 A0060000 		.word	.LANCHOR1+1696
 6309 38ac F8050000 		.word	.LC32
 6310 38b0 5C000000 		.word	.LANCHOR0+92
 6311 38b4 F4060000 		.word	.LANCHOR1+1780
 6312 38b8 00070000 		.word	.LANCHOR1+1792
 6313 38bc 94060000 		.word	.LC36
 6314 38c0 84070000 		.word	.LC42
 6315 38c4 D8010000 		.word	.LC12
 6316 38c8 5C070000 		.word	.LC41
 6317 38cc BC060000 		.word	.LANCHOR1+1724
 6318 38d0 D8060000 		.word	.LANCHOR1+1752
 6319 38d4 20060000 		.word	.LC33
 6320 38d8 44060000 		.word	.LC34
 6321 38dc 6C060000 		.word	.LC35
 6322 38e0 C0060000 		.word	.LC37
 6323 38e4 E4060000 		.word	.LC38
 6324              	.LBE131:
 6325              	.LBE167:
 6326              		.cfi_endproc
 6327              	.LFE25:
 6329              		.align	2
 6330              		.global	CamDefSet
 6332              	CamDefSet:
 6333              	.LFB5:
1681:../uvc.c      **** {
 6334              		.loc 1 1681 0
 6335              		.cfi_startproc
 6336              		@ args = 0, pretend = 0, frame = 24
 6337              		@ frame_needed = 0, uses_anonymous_args = 0
 6338              	.LVL527:
 6339 38e8 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 6340              	.LCFI21:
 6341              		.cfi_def_cfa_offset 36
1687:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 6342              		.loc 1 1687 0
 6343 38ec AC429FE5 		ldr	r4, .L553
 6344              		.cfi_offset 14, -4
 6345              		.cfi_offset 11, -8
 6346              		.cfi_offset 10, -12
 6347              		.cfi_offset 9, -16
 6348              		.cfi_offset 8, -20
 6349              		.cfi_offset 7, -24
 6350              		.cfi_offset 6, -28
 6351              		.cfi_offset 5, -32
 6352              		.cfi_offset 4, -36
1692:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 6353              		.loc 1 1692 0
 6354 38f0 AC229FE5 		ldr	r2, .L553+4
1689:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 6355              		.loc 1 1689 0
 6356 38f4 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1681:../uvc.c      **** {
 6357              		.loc 1 1681 0
 6358 38f8 2CD04DE2 		sub	sp, sp, #44
 6359              	.LCFI22:
 6360              		.cfi_def_cfa_offset 80
1692:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 6361              		.loc 1 1692 0
 6362 38fc 1C0092E5 		ldr	r0, [r2, #28]
 6363 3900 0010E0E3 		mvn	r1, #0
1694:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 6364              		.loc 1 1694 0
 6365 3904 2963A0E1 		mov	r6, r9, lsr #6
1688:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 6366              		.loc 1 1688 0
 6367 3908 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1687:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 6368              		.loc 1 1687 0
 6369 390c 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 6370              	.LVL528:
1692:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 6371              		.loc 1 1692 0
 6372 3910 FEFFFFEB 		bl	_txe_mutex_get
1693:../uvc.c      ****     if(Data1&0x80){
 6373              		.loc 1 1693 0
 6374 3914 800019E3 		tst	r9, #128
1694:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 6375              		.loc 1 1694 0
 6376 3918 01600612 		andne	r6, r6, #1
 6377 391c 0660E011 		mvnne	r6, r6
 6378 3920 3B600612 		andne	r6, r6, #59
 6379 3924 0660E011 		mvnne	r6, r6
 6380 3928 FF600612 		andne	r6, r6, #255
 6381              	.LVL529:
1696:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 6382              		.loc 1 1696 0
 6383 392c C6608603 		orreq	r6, r6, #198
 6384              	.LVL530:
1700:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 6385              		.loc 1 1700 0
 6386 3930 0080A0E3 		mov	r8, #0
 6387 3934 0A20A0E1 		mov	r2, sl
 6388 3938 0730A0E1 		mov	r3, r7
 6389 393c 0110A0E3 		mov	r1, #1
1698:../uvc.c      ****     Data0 = (Data0 << 2);
 6390              		.loc 1 1698 0
 6391 3940 0951A0E1 		mov	r5, r9, asl #2
1700:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 6392              		.loc 1 1700 0
 6393 3944 58029FE5 		ldr	r0, .L553+4
1703:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 6394              		.loc 1 1703 0
 6395 3948 0190A0E3 		mov	r9, #1
 6396              	.LVL531:
1698:../uvc.c      ****     Data0 = (Data0 << 2);
 6397              		.loc 1 1698 0
 6398 394c FF5005E2 		and	r5, r5, #255
 6399              	.LVL532:
1700:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 6400              		.loc 1 1700 0
 6401 3950 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 6402 3954 FEFFFFEB 		bl	cmdSet
 6403              	.LVL533:
1703:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 6404              		.loc 1 1703 0
 6405 3958 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 6406 395c 0910A0E1 		mov	r1, r9
 6407 3960 0730A0E1 		mov	r3, r7
 6408 3964 38029FE5 		ldr	r0, .L553+4
 6409 3968 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 6410 396c FEFFFFEB 		bl	cmdSet
 6411              	.LVL534:
1706:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 6412              		.loc 1 1706 0
 6413 3970 0620A0E1 		mov	r2, r6
 6414 3974 0530A0E1 		mov	r3, r5
 6415 3978 28129FE5 		ldr	r1, .L553+8
 6416 397c 0400A0E3 		mov	r0, #4
1705:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 6417              		.loc 1 1705 0
 6418 3980 A661C4E5 		strb	r6, [r4, #422]
1704:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6419              		.loc 1 1704 0
 6420 3984 A551C4E5 		strb	r5, [r4, #421]
1706:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 6421              		.loc 1 1706 0
 6422 3988 FEFFFFEB 		bl	CyU3PDebugPrint
 6423              	.LVL535:
1711:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6424              		.loc 1 1711 0
 6425 398c BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 6426              	.LVL536:
1712:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 6427              		.loc 1 1712 0
 6428 3990 B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 6429 3994 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 6430 3998 0210A0E3 		mov	r1, #2
 6431 399c 00029FE5 		ldr	r0, .L553+4
 6432 39a0 00B08DE5 		str	fp, [sp, #0]
 6433 39a4 04808DE5 		str	r8, [sp, #4]
 6434 39a8 FEFFFFEB 		bl	cmdSet
 6435              	.LVL537:
1714:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6436              		.loc 1 1714 0
 6437 39ac 0B20A0E1 		mov	r2, fp
 6438 39b0 0530A0E1 		mov	r3, r5
 6439 39b4 EC119FE5 		ldr	r1, .L553+8
 6440 39b8 0400A0E3 		mov	r0, #4
1713:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6441              		.loc 1 1713 0
 6442 39bc BD51C4E5 		strb	r5, [r4, #445]
1714:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6443              		.loc 1 1714 0
 6444 39c0 FEFFFFEB 		bl	CyU3PDebugPrint
 6445              	.LVL538:
1719:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6446              		.loc 1 1719 0
 6447 39c4 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1718:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 6448              		.loc 1 1718 0
 6449 39c8 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 6450              	.LVL539:
1720:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 6451              		.loc 1 1720 0
 6452 39cc 80B047E2 		sub	fp, r7, #128
 6453 39d0 FF100BE2 		and	r1, fp, #255
 6454 39d4 14108DE5 		str	r1, [sp, #20]
 6455 39d8 14C09DE5 		ldr	ip, [sp, #20]
1721:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6456              		.loc 1 1721 0
 6457 39dc 760047E2 		sub	r0, r7, #118
1722:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6458              		.loc 1 1722 0
 6459 39e0 7EE087E2 		add	lr, r7, #126
1720:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 6460              		.loc 1 1720 0
 6461 39e4 0630A0E1 		mov	r3, r6
1721:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6462              		.loc 1 1721 0
 6463 39e8 18008DE5 		str	r0, [sp, #24]
1720:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 6464              		.loc 1 1720 0
 6465 39ec 0510A0E3 		mov	r1, #5
 6466 39f0 DF20A0E3 		mov	r2, #223
 6467 39f4 A8019FE5 		ldr	r0, .L553+4
1722:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6468              		.loc 1 1722 0
 6469 39f8 1CE08DE5 		str	lr, [sp, #28]
1720:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 6470              		.loc 1 1720 0
 6471 39fc 00C08DE5 		str	ip, [sp, #0]
 6472 3a00 04808DE5 		str	r8, [sp, #4]
 6473 3a04 FEFFFFEB 		bl	cmdSet
 6474              	.LVL540:
1721:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6475              		.loc 1 1721 0
 6476 3a08 18A09DE5 		ldr	sl, [sp, #24]
1723:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6477              		.loc 1 1723 0
 6478 3a0c 72E087E2 		add	lr, r7, #114
1721:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6479              		.loc 1 1721 0
 6480 3a10 FFC00AE2 		and	ip, sl, #255
 6481 3a14 0630A0E1 		mov	r3, r6
 6482 3a18 0510A0E3 		mov	r1, #5
 6483 3a1c DC20A0E3 		mov	r2, #220
 6484 3a20 7C019FE5 		ldr	r0, .L553+4
1723:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6485              		.loc 1 1723 0
 6486 3a24 20E08DE5 		str	lr, [sp, #32]
1721:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6487              		.loc 1 1721 0
 6488 3a28 00C08DE5 		str	ip, [sp, #0]
 6489 3a2c 04908DE5 		str	r9, [sp, #4]
 6490 3a30 FEFFFFEB 		bl	cmdSet
1722:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6491              		.loc 1 1722 0
 6492 3a34 1C009DE5 		ldr	r0, [sp, #28]
 6493 3a38 02E0A0E3 		mov	lr, #2
 6494 3a3c FFC000E2 		and	ip, r0, #255
 6495 3a40 0630A0E1 		mov	r3, r6
1724:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6496              		.loc 1 1724 0
 6497 3a44 6FA047E2 		sub	sl, r7, #111
1722:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6498              		.loc 1 1722 0
 6499 3a48 0510A0E3 		mov	r1, #5
 6500 3a4c DE20A0E3 		mov	r2, #222
 6501 3a50 4C019FE5 		ldr	r0, .L553+4
 6502 3a54 04E08DE5 		str	lr, [sp, #4]
1724:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6503              		.loc 1 1724 0
 6504 3a58 24A08DE5 		str	sl, [sp, #36]
1722:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6505              		.loc 1 1722 0
 6506 3a5c 00C08DE5 		str	ip, [sp, #0]
 6507 3a60 FEFFFFEB 		bl	cmdSet
1723:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6508              		.loc 1 1723 0
 6509 3a64 20A09DE5 		ldr	sl, [sp, #32]
 6510 3a68 0630A0E1 		mov	r3, r6
 6511 3a6c FFC00AE2 		and	ip, sl, #255
 6512 3a70 00C08DE5 		str	ip, [sp, #0]
 6513 3a74 0510A0E3 		mov	r1, #5
 6514 3a78 03C0A0E3 		mov	ip, #3
 6515 3a7c E020A0E3 		mov	r2, #224
 6516 3a80 1C019FE5 		ldr	r0, .L553+4
 6517 3a84 04C08DE5 		str	ip, [sp, #4]
 6518 3a88 FEFFFFEB 		bl	cmdSet
1724:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6519              		.loc 1 1724 0
 6520 3a8c 24009DE5 		ldr	r0, [sp, #36]
 6521 3a90 04A0A0E3 		mov	sl, #4
 6522 3a94 FFC000E2 		and	ip, r0, #255
 6523 3a98 0630A0E1 		mov	r3, r6
 6524 3a9c 0510A0E3 		mov	r1, #5
 6525 3aa0 DD20A0E3 		mov	r2, #221
 6526 3aa4 F8009FE5 		ldr	r0, .L553+4
 6527 3aa8 00C08DE5 		str	ip, [sp, #0]
1725:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 6528              		.loc 1 1725 0
 6529 3aac 7F7087E2 		add	r7, r7, #127
 6530              	.LVL541:
1724:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6531              		.loc 1 1724 0
 6532 3ab0 04A08DE5 		str	sl, [sp, #4]
 6533 3ab4 FEFFFFEB 		bl	cmdSet
1725:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 6534              		.loc 1 1725 0
 6535 3ab8 05E0A0E3 		mov	lr, #5
 6536 3abc 0E10A0E1 		mov	r1, lr
 6537 3ac0 0630A0E1 		mov	r3, r6
 6538 3ac4 E120A0E3 		mov	r2, #225
 6539 3ac8 FF6007E2 		and	r6, r7, #255
 6540              	.LVL542:
 6541 3acc D0009FE5 		ldr	r0, .L553+4
 6542 3ad0 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 6543 3ad4 FEFFFFEB 		bl	cmdSet
 6544              	.LVL543:
1726:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 6545              		.loc 1 1726 0
 6546 3ad8 14C09DE5 		ldr	ip, [sp, #20]
1727:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 6547              		.loc 1 1727 0
 6548 3adc 24E09DE5 		ldr	lr, [sp, #36]
 6549 3ae0 1C609DE5 		ldr	r6, [sp, #28]
1726:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 6550              		.loc 1 1726 0
 6551 3ae4 05C2C4E5 		strb	ip, [r4, #517]
1727:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 6552              		.loc 1 1727 0
 6553 3ae8 20C09DE5 		ldr	ip, [sp, #32]
 6554 3aec 0B20A0E1 		mov	r2, fp
 6555 3af0 18309DE5 		ldr	r3, [sp, #24]
 6556 3af4 B0109FE5 		ldr	r1, .L553+12
 6557 3af8 0A00A0E1 		mov	r0, sl
 6558 3afc 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 6559 3b00 0C708DE5 		str	r7, [sp, #12]
 6560 3b04 FEFFFFEB 		bl	CyU3PDebugPrint
 6561              	.LVL544:
1731:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 6562              		.loc 1 1731 0
 6563 3b08 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 6564              	.LVL545:
1732:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6565              		.loc 1 1732 0
 6566 3b0c 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 6567              	.LVL546:
1733:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 6568              		.loc 1 1733 0
 6569 3b10 0730A0E1 		mov	r3, r7
 6570 3b14 0610A0E3 		mov	r1, #6
 6571 3b18 8520A0E3 		mov	r2, #133
 6572 3b1c 80009FE5 		ldr	r0, .L553+4
 6573 3b20 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 6574 3b24 FEFFFFEB 		bl	cmdSet
1734:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 6575              		.loc 1 1734 0
 6576 3b28 0730A0E1 		mov	r3, r7
 6577 3b2c 0610A0E3 		mov	r1, #6
 6578 3b30 8620A0E3 		mov	r2, #134
 6579 3b34 68009FE5 		ldr	r0, .L553+4
 6580 3b38 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 6581 3b3c FEFFFFEB 		bl	cmdSet
1736:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6582              		.loc 1 1736 0
 6583 3b40 0620A0E1 		mov	r2, r6
 6584 3b44 0530A0E1 		mov	r3, r5
 6585 3b48 58109FE5 		ldr	r1, .L553+8
 6586 3b4c 0A00A0E1 		mov	r0, sl
1735:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 6587              		.loc 1 1735 0
 6588 3b50 1D62C4E5 		strb	r6, [r4, #541]
1736:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6589              		.loc 1 1736 0
 6590 3b54 FEFFFFEB 		bl	CyU3PDebugPrint
 6591              	.LVL547:
1741:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6592              		.loc 1 1741 0
 6593 3b58 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 6594              	.LVL548:
1742:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 6595              		.loc 1 1742 0
 6596 3b5c 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 6597 3b60 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 6598 3b64 0710A0E3 		mov	r1, #7
 6599 3b68 34009FE5 		ldr	r0, .L553+4
 6600 3b6c 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 6601 3b70 FEFFFFEB 		bl	cmdSet
 6602              	.LVL549:
1744:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6603              		.loc 1 1744 0
 6604 3b74 0530A0E1 		mov	r3, r5
 6605 3b78 0A00A0E1 		mov	r0, sl
 6606 3b7c 24109FE5 		ldr	r1, .L553+8
 6607 3b80 0620A0E1 		mov	r2, r6
1743:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6608              		.loc 1 1743 0
 6609 3b84 3552C4E5 		strb	r5, [r4, #565]
1744:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6610              		.loc 1 1744 0
 6611 3b88 FEFFFFEB 		bl	CyU3PDebugPrint
1746:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6612              		.loc 1 1746 0
 6613 3b8c 10309FE5 		ldr	r3, .L553+4
 6614 3b90 1C0093E5 		ldr	r0, [r3, #28]
1749:../uvc.c      **** }
 6615              		.loc 1 1749 0
 6616 3b94 2CD08DE2 		add	sp, sp, #44
 6617 3b98 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1746:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6618              		.loc 1 1746 0
 6619 3b9c FEFFFFEA 		b	_txe_mutex_put
 6620              	.L554:
 6621              		.align	2
 6622              	.L553:
 6623 3ba0 00000000 		.word	.LANCHOR1
 6624 3ba4 00000000 		.word	cmdQu
 6625 3ba8 B8070000 		.word	.LC43
 6626 3bac D8070000 		.word	.LC44
 6627              		.cfi_endproc
 6628              	.LFE5:
 6630              		.align	2
 6631              		.global	CyFxUVCAddHeader
 6633              	CyFxUVCAddHeader:
 6634              	.LFB6:
1757:../uvc.c      **** {
 6635              		.loc 1 1757 0
 6636              		.cfi_startproc
 6637              		@ args = 0, pretend = 0, frame = 0
 6638              		@ frame_needed = 0, uses_anonymous_args = 0
 6639              	.LVL550:
 6640 3bb0 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 6641              	.LCFI23:
 6642              		.cfi_def_cfa_offset 16
1757:../uvc.c      **** {
 6643              		.loc 1 1757 0
 6644 3bb4 0040A0E1 		mov	r4, r0
 6645              		.cfi_offset 14, -4
 6646              		.cfi_offset 5, -8
 6647              		.cfi_offset 4, -12
 6648              		.cfi_offset 3, -16
 6649 3bb8 0150A0E1 		mov	r5, r1
1759:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 6650              		.loc 1 1759 0
 6651 3bbc 30009FE5 		ldr	r0, .L557
 6652              	.LVL551:
 6653 3bc0 0010E0E3 		mvn	r1, #0
 6654              	.LVL552:
 6655 3bc4 FEFFFFEB 		bl	_txe_mutex_get
1760:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 6656              		.loc 1 1760 0
 6657 3bc8 0400A0E1 		mov	r0, r4
 6658 3bcc 24109FE5 		ldr	r1, .L557+4
 6659 3bd0 0C20A0E3 		mov	r2, #12
 6660 3bd4 FEFFFFEB 		bl	CyU3PMemCopy
1761:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 6661              		.loc 1 1761 0
 6662 3bd8 14009FE5 		ldr	r0, .L557
 6663 3bdc FEFFFFEB 		bl	_txe_mutex_put
1764:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 6664              		.loc 1 1764 0
 6665 3be0 020015E3 		tst	r5, #2
1766:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 6666              		.loc 1 1766 0
 6667 3be4 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 6668 3be8 02308313 		orrne	r3, r3, #2
 6669 3bec 0130C415 		strneb	r3, [r4, #1]
 6670 3bf0 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 6671              	.L558:
 6672              		.align	2
 6673              	.L557:
 6674 3bf4 00000000 		.word	imgHdMux
 6675 3bf8 80040000 		.word	.LANCHOR1+1152
 6676              		.cfi_endproc
 6677              	.LFE6:
 6679              		.align	2
 6680              		.global	CyFxAppErrorHandler
 6682              	CyFxAppErrorHandler:
 6683              	.LFB7:
1776:../uvc.c      **** {
 6684              		.loc 1 1776 0
 6685              		.cfi_startproc
 6686              		@ args = 0, pretend = 0, frame = 0
 6687              		@ frame_needed = 0, uses_anonymous_args = 0
 6688              	.LVL553:
 6689 3bfc 08402DE9 		stmfd	sp!, {r3, lr}
 6690              	.LCFI24:
 6691              		.cfi_def_cfa_offset 8
 6692              	.LVL554:
 6693              	.L560:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6694              		.loc 1 1786 0 discriminator 1
 6695 3c00 10109FE5 		ldr	r1, .L561
 6696 3c04 0400A0E3 		mov	r0, #4
 6697              		.cfi_offset 14, -4
 6698              		.cfi_offset 3, -8
 6699 3c08 FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 6700              		.loc 1 1787 0 discriminator 1
 6701 3c0c FA0FA0E3 		mov	r0, #1000
 6702 3c10 FEFFFFEB 		bl	_tx_thread_sleep
 6703 3c14 F9FFFFEA 		b	.L560
 6704              	.L562:
 6705              		.align	2
 6706              	.L561:
 6707 3c18 D8010000 		.word	.LC12
 6708              		.cfi_endproc
 6709              	.LFE7:
 6711              		.align	2
 6712              		.global	UVCAppThread_Entry
 6714              	UVCAppThread_Entry:
 6715              	.LFB19:
2763:../uvc.c      **** {
 6716              		.loc 1 2763 0
 6717              		.cfi_startproc
 6718              		@ args = 0, pretend = 0, frame = 176
 6719              		@ frame_needed = 0, uses_anonymous_args = 0
 6720              	.LVL555:
 6721 3c1c F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 6722              	.LCFI25:
 6723              		.cfi_def_cfa_offset 28
 6724 3c20 BCD04DE2 		sub	sp, sp, #188
 6725              	.LCFI26:
 6726              		.cfi_def_cfa_offset 216
 6727              	.LBB220:
 6728              	.LBB221:
2219:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 6729              		.loc 1 2219 0
 6730              		.cfi_offset 14, -4
 6731              		.cfi_offset 10, -8
 6732              		.cfi_offset 8, -12
 6733              		.cfi_offset 7, -16
 6734              		.cfi_offset 6, -20
 6735              		.cfi_offset 5, -24
 6736              		.cfi_offset 4, -28
 6737 3c24 FEFFFFEB 		bl	CyU3PUartInit
 6738              	.LVL556:
2220:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6739              		.loc 1 2220 0
 6740 3c28 004050E2 		subs	r4, r0, #0
 6741 3c2c 0400000A 		beq	.L564
2222:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 6742              		.loc 1 2222 0
 6743 3c30 0400A0E3 		mov	r0, #4
 6744              	.LVL557:
 6745 3c34 F81B9FE5 		ldr	r1, .L680
 6746 3c38 FEFFFFEB 		bl	CyU3PDebugPrint
2223:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6747              		.loc 1 2223 0
 6748 3c3c 0400A0E1 		mov	r0, r4
 6749 3c40 FEFFFFEB 		bl	CyFxAppErrorHandler
 6750              	.L564:
2227:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 6751              		.loc 1 2227 0
 6752 3c44 ECCB9FE5 		ldr	ip, .L680+4
2229:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6753              		.loc 1 2229 0
 6754 3c48 0030A0E3 		mov	r3, #0
2228:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6755              		.loc 1 2228 0
 6756 3c4c 0120A0E3 		mov	r2, #1
2236:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 6757              		.loc 1 2236 0
 6758 3c50 50008DE2 		add	r0, sp, #80
 6759 3c54 0310A0E1 		mov	r1, r3
2227:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 6760              		.loc 1 2227 0
 6761 3c58 60C08DE5 		str	ip, [sp, #96]
2228:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6762              		.loc 1 2228 0
 6763 3c5c 6420CDE5 		strb	r2, [sp, #100]
2229:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6764              		.loc 1 2229 0
 6765 3c60 6530CDE5 		strb	r3, [sp, #101]
2230:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 6766              		.loc 1 2230 0
 6767 3c64 50208DE5 		str	r2, [sp, #80]
2231:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 6768              		.loc 1 2231 0
 6769 3c68 54308DE5 		str	r3, [sp, #84]
2232:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 6770              		.loc 1 2232 0
 6771 3c6c 58308DE5 		str	r3, [sp, #88]
2233:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 6772              		.loc 1 2233 0
 6773 3c70 5C208DE5 		str	r2, [sp, #92]
2236:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 6774              		.loc 1 2236 0
 6775 3c74 FEFFFFEB 		bl	CyU3PUartSetConfig
 6776              	.LVL558:
2237:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6777              		.loc 1 2237 0
 6778 3c78 000050E3 		cmp	r0, #0
 6779 3c7c 0000000A 		beq	.L565
2239:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6780              		.loc 1 2239 0
 6781 3c80 FEFFFFEB 		bl	CyFxAppErrorHandler
 6782              	.LVL559:
 6783              	.L565:
2243:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 6784              		.loc 1 2243 0
 6785 3c84 0000E0E3 		mvn	r0, #0
 6786 3c88 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 6787              	.LVL560:
2244:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6788              		.loc 1 2244 0
 6789 3c8c 000050E3 		cmp	r0, #0
 6790 3c90 0000000A 		beq	.L566
2246:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6791              		.loc 1 2246 0
 6792 3c94 FEFFFFEB 		bl	CyFxAppErrorHandler
 6793              	.LVL561:
 6794              	.L566:
2250:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 6795              		.loc 1 2250 0
 6796 3c98 0300A0E3 		mov	r0, #3
 6797 3c9c 0410A0E3 		mov	r1, #4
 6798 3ca0 FEFFFFEB 		bl	CyU3PDebugInit
 6799              	.LVL562:
2251:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6800              		.loc 1 2251 0
 6801 3ca4 000050E3 		cmp	r0, #0
 6802 3ca8 0000000A 		beq	.L567
2253:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6803              		.loc 1 2253 0
 6804 3cac FEFFFFEB 		bl	CyFxAppErrorHandler
 6805              	.LVL563:
 6806              	.L567:
2257:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 6807              		.loc 1 2257 0
 6808 3cb0 0000A0E3 		mov	r0, #0
 6809 3cb4 FEFFFFEB 		bl	CyU3PDebugPreamble
 6810              	.LVL564:
 6811              	.LBE221:
 6812              	.LBE220:
2779:../uvc.c      **** 		CyU3PThreadSleep(500);
 6813              		.loc 1 2779 0
 6814 3cb8 7D0FA0E3 		mov	r0, #500
 6815 3cbc FEFFFFEB 		bl	_tx_thread_sleep
 6816              	.LVL565:
 6817 3cc0 7D0FA0E3 		mov	r0, #500
 6818 3cc4 FEFFFFEB 		bl	_tx_thread_sleep
 6819 3cc8 7D0FA0E3 		mov	r0, #500
 6820 3ccc FEFFFFEB 		bl	_tx_thread_sleep
 6821 3cd0 7D0FA0E3 		mov	r0, #500
 6822 3cd4 FEFFFFEB 		bl	_tx_thread_sleep
 6823 3cd8 7D0FA0E3 		mov	r0, #500
 6824 3cdc FEFFFFEB 		bl	_tx_thread_sleep
 6825 3ce0 7D0FA0E3 		mov	r0, #500
 6826 3ce4 FEFFFFEB 		bl	_tx_thread_sleep
 6827              	.LBB222:
 6828              	.LBB223:
2267:../uvc.c      ****     status = CyU3PI2cInit ();
 6829              		.loc 1 2267 0
 6830 3ce8 FEFFFFEB 		bl	CyU3PI2cInit
 6831              	.LVL566:
2268:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 6832              		.loc 1 2268 0
 6833 3cec 004050E2 		subs	r4, r0, #0
 6834 3cf0 0400000A 		beq	.L568
2270:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 6835              		.loc 1 2270 0
 6836 3cf4 0400A0E3 		mov	r0, #4
 6837              	.LVL567:
 6838 3cf8 3C1B9FE5 		ldr	r1, .L680+8
 6839 3cfc FEFFFFEB 		bl	CyU3PDebugPrint
2271:../uvc.c      ****         CyFxAppErrorHandler (status);
 6840              		.loc 1 2271 0
 6841 3d00 0400A0E1 		mov	r0, r4
 6842 3d04 FEFFFFEB 		bl	CyFxAppErrorHandler
 6843              	.L568:
2275:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 6844              		.loc 1 2275 0
 6845 3d08 306B9FE5 		ldr	r6, .L680+12
2276:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6846              		.loc 1 2276 0
 6847 3d0c 0050A0E3 		mov	r5, #0
2277:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6848              		.loc 1 2277 0
 6849 3d10 0040E0E3 		mvn	r4, #0
 6850              	.LVL568:
2280:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 6851              		.loc 1 2280 0
 6852 3d14 8C008DE2 		add	r0, sp, #140
 6853 3d18 0510A0E1 		mov	r1, r5
2277:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6854              		.loc 1 2277 0
 6855 3d1c 94408DE5 		str	r4, [sp, #148]
2278:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6856              		.loc 1 2278 0
 6857 3d20 B849CDE1 		strh	r4, [sp, #152]	@ movhi
2275:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 6858              		.loc 1 2275 0
 6859 3d24 8C608DE5 		str	r6, [sp, #140]
2276:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6860              		.loc 1 2276 0
 6861 3d28 90508DE5 		str	r5, [sp, #144]
2280:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 6862              		.loc 1 2280 0
 6863 3d2c FEFFFFEB 		bl	CyU3PI2cSetConfig
 6864              	.LVL569:
2281:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6865              		.loc 1 2281 0
 6866 3d30 004050E2 		subs	r4, r0, #0
 6867 3d34 0400000A 		beq	.L569
2283:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 6868              		.loc 1 2283 0
 6869 3d38 0400A0E3 		mov	r0, #4
 6870              	.LVL570:
 6871 3d3c 001B9FE5 		ldr	r1, .L680+16
 6872 3d40 FEFFFFEB 		bl	CyU3PDebugPrint
2284:../uvc.c      ****         CyFxAppErrorHandler (status);
 6873              		.loc 1 2284 0
 6874 3d44 0400A0E1 		mov	r0, r4
 6875 3d48 FEFFFFEB 		bl	CyFxAppErrorHandler
 6876              	.L569:
 6877              	.LBE223:
 6878              	.LBE222:
 6879              	.LBB224:
 6880              	.LBB227:
2354:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 6881              		.loc 1 2354 0
 6882 3d4c F44A9FE5 		ldr	r4, .L680+20
 6883              	.LVL571:
 6884 3d50 2820A0E3 		mov	r2, #40
 6885 3d54 0010A0E3 		mov	r1, #0
 6886 3d58 0400A0E1 		mov	r0, r4
 6887 3d5c FEFFFFEB 		bl	_txe_event_flags_create
 6888              	.LVL572:
2355:../uvc.c      ****     if (apiRetStatus != 0)
 6889              		.loc 1 2355 0
 6890 3d60 002050E2 		subs	r2, r0, #0
 6891 3d64 F800001A 		bne	.L654
2369:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 6892              		.loc 1 2369 0
 6893 3d68 0260A0E3 		mov	r6, #2
2376:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6894              		.loc 1 2376 0
 6895 3d6c 0210A0E1 		mov	r1, r2
2365:../uvc.c      ****     isUsbConnected = CyFalse;
 6896              		.loc 1 2365 0
 6897 3d70 302084E5 		str	r2, [r4, #48]
2366:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 6898              		.loc 1 2366 0
 6899 3d74 442084E5 		str	r2, [r4, #68]
2372:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6900              		.loc 1 2372 0
 6901 3d78 0370A0E3 		mov	r7, #3
2376:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6902              		.loc 1 2376 0
 6903 3d7c 9C008DE2 		add	r0, sp, #156
 6904              	.LVL573:
2371:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 6905              		.loc 1 2371 0
 6906 3d80 A420CDE5 		strb	r2, [sp, #164]
2373:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6907              		.loc 1 2373 0
 6908 3d84 A0208DE5 		str	r2, [sp, #160]
2369:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 6909              		.loc 1 2369 0
 6910 3d88 9C60CDE5 		strb	r6, [sp, #156]
2370:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6911              		.loc 1 2370 0
 6912 3d8c 9D60CDE5 		strb	r6, [sp, #157]
2372:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6913              		.loc 1 2372 0
 6914 3d90 A570CDE5 		strb	r7, [sp, #165]
2376:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6915              		.loc 1 2376 0
 6916 3d94 FEFFFFEB 		bl	CyU3PGpioInit
 6917              	.LVL574:
2377:../uvc.c      ****     if (apiRetStatus != 0)
 6918              		.loc 1 2377 0
 6919 3d98 002050E2 		subs	r2, r0, #0
 6920 3d9c FC00001A 		bne	.L655
2385:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 6921              		.loc 1 2385 0
 6922 3da0 1600A0E3 		mov	r0, #22
 6923              	.LVL575:
 6924 3da4 0110A0E3 		mov	r1, #1
 6925 3da8 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6926              	.LVL576:
2386:../uvc.c      ****     if (apiRetStatus != 0)
 6927              		.loc 1 2386 0
 6928 3dac 002050E2 		subs	r2, r0, #0
 6929 3db0 EE00001A 		bne	.L656
2391:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 6930              		.loc 1 2391 0
 6931 3db4 1400A0E3 		mov	r0, #20
 6932              	.LVL577:
 6933 3db8 0110A0E3 		mov	r1, #1
 6934 3dbc FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6935              	.LVL578:
2392:../uvc.c      ****     if (apiRetStatus != 0)
 6936              		.loc 1 2392 0
 6937 3dc0 002050E2 		subs	r2, r0, #0
 6938 3dc4 FB00001A 		bne	.L657
2397:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 6939              		.loc 1 2397 0
 6940 3dc8 1800A0E3 		mov	r0, #24
 6941              	.LVL579:
 6942 3dcc 0110A0E3 		mov	r1, #1
 6943 3dd0 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6944              	.LVL580:
2398:../uvc.c      ****     if (apiRetStatus != 0)
 6945              		.loc 1 2398 0
 6946 3dd4 002050E2 		subs	r2, r0, #0
 6947 3dd8 D601001A 		bne	.L658
2405:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6948              		.loc 1 2405 0
 6949 3ddc 0150A0E3 		mov	r5, #1
2410:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6950              		.loc 1 2410 0
 6951 3de0 1600A0E3 		mov	r0, #22
 6952              	.LVL581:
 6953 3de4 68108DE2 		add	r1, sp, #104
2408:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6954              		.loc 1 2408 0
 6955 3de8 74208DE5 		str	r2, [sp, #116]
2409:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6956              		.loc 1 2409 0
 6957 3dec 7820CDE5 		strb	r2, [sp, #120]
2405:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6958              		.loc 1 2405 0
 6959 3df0 68508DE5 		str	r5, [sp, #104]
2406:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6960              		.loc 1 2406 0
 6961 3df4 6C508DE5 		str	r5, [sp, #108]
2407:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6962              		.loc 1 2407 0
 6963 3df8 70508DE5 		str	r5, [sp, #112]
2410:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6964              		.loc 1 2410 0
 6965 3dfc FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6966              	.LVL582:
2411:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6967              		.loc 1 2411 0
 6968 3e00 002050E2 		subs	r2, r0, #0
 6969 3e04 C201001A 		bne	.L659
2424:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6970              		.loc 1 2424 0
 6971 3e08 1400A0E3 		mov	r0, #20
 6972              	.LVL583:
 6973 3e0c 68108DE2 		add	r1, sp, #104
2422:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6974              		.loc 1 2422 0
 6975 3e10 74208DE5 		str	r2, [sp, #116]
2423:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6976              		.loc 1 2423 0
 6977 3e14 7820CDE5 		strb	r2, [sp, #120]
2419:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6978              		.loc 1 2419 0
 6979 3e18 68508DE5 		str	r5, [sp, #104]
2420:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6980              		.loc 1 2420 0
 6981 3e1c 6C508DE5 		str	r5, [sp, #108]
2421:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6982              		.loc 1 2421 0
 6983 3e20 70508DE5 		str	r5, [sp, #112]
2424:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6984              		.loc 1 2424 0
 6985 3e24 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6986              	.LVL584:
2425:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6987              		.loc 1 2425 0
 6988 3e28 002050E2 		subs	r2, r0, #0
 6989 3e2c CA01001A 		bne	.L660
2438:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6990              		.loc 1 2438 0
 6991 3e30 1800A0E3 		mov	r0, #24
 6992              	.LVL585:
 6993 3e34 68108DE2 		add	r1, sp, #104
2433:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 6994              		.loc 1 2433 0
 6995 3e38 68208DE5 		str	r2, [sp, #104]
2434:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6996              		.loc 1 2434 0
 6997 3e3c 6C208DE5 		str	r2, [sp, #108]
2435:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 6998              		.loc 1 2435 0
 6999 3e40 70208DE5 		str	r2, [sp, #112]
2437:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 7000              		.loc 1 2437 0
 7001 3e44 7820CDE5 		strb	r2, [sp, #120]
2436:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 7002              		.loc 1 2436 0
 7003 3e48 74508DE5 		str	r5, [sp, #116]
2438:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 7004              		.loc 1 2438 0
 7005 3e4c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 7006              	.LVL586:
2439:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7007              		.loc 1 2439 0
 7008 3e50 002050E2 		subs	r2, r0, #0
 7009 3e54 A501001A 		bne	.L661
2451:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 7010              		.loc 1 2451 0
 7011 3e58 0500A0E1 		mov	r0, r5
 7012              	.LVL587:
 7013 3e5c 7C108DE2 		add	r1, sp, #124
2448:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 7014              		.loc 1 2448 0
 7015 3e60 84208DE5 		str	r2, [sp, #132]
2449:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 7016              		.loc 1 2449 0
 7017 3e64 80208DE5 		str	r2, [sp, #128]
2446:../uvc.c      ****     pibclock.clkDiv      = 2;
 7018              		.loc 1 2446 0
 7019 3e68 BC67CDE1 		strh	r6, [sp, #124]	@ movhi
2447:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 7020              		.loc 1 2447 0
 7021 3e6c 8870CDE5 		strb	r7, [sp, #136]
2451:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 7022              		.loc 1 2451 0
 7023 3e70 FEFFFFEB 		bl	CyU3PPibInit
 7024              	.LVL588:
2452:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7025              		.loc 1 2452 0
 7026 3e74 002050E2 		subs	r2, r0, #0
 7027 3e78 9301001A 		bne	.L662
2459:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 7028              		.loc 1 2459 0
 7029 3e7c C8099FE5 		ldr	r0, .L680+24
 7030              	.LVL589:
 7031 3e80 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 7032              	.LVL590:
2467:../uvc.c      ****     SensorReset ();
 7033              		.loc 1 2467 0
 7034 3e84 FEFFFFEB 		bl	SensorReset
2468:../uvc.c      ****     CyU3PThreadSleep(5000);
 7035              		.loc 1 2468 0
 7036 3e88 C0099FE5 		ldr	r0, .L680+28
 7037 3e8c FEFFFFEB 		bl	_tx_thread_sleep
2472:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 7038              		.loc 1 2472 0
 7039 3e90 FEFFFFEB 		bl	CyU3PUsbStart
 7040              	.LVL591:
2473:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7041              		.loc 1 2473 0
 7042 3e94 002050E2 		subs	r2, r0, #0
 7043 3e98 8201001A 		bne	.L663
2479:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 7044              		.loc 1 2479 0
 7045 3e9c 0010A0E3 		mov	r1, #0
 7046 3ea0 AC099FE5 		ldr	r0, .L680+32
 7047              	.LVL592:
 7048 3ea4 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 7049              	.LVL593:
2482:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 7050              		.loc 1 2482 0
 7051 3ea8 A8099FE5 		ldr	r0, .L680+36
 7052 3eac FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
2488:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 7053              		.loc 1 2488 0
 7054 3eb0 0010A0E3 		mov	r1, #0
 7055 3eb4 A0299FE5 		ldr	r2, .L680+40
 7056 3eb8 0100A0E3 		mov	r0, #1
 7057 3ebc FEFFFFEB 		bl	CyU3PUsbSetDesc
2489:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 7058              		.loc 1 2489 0
 7059 3ec0 0000A0E3 		mov	r0, #0
 7060 3ec4 0010A0E1 		mov	r1, r0
 7061 3ec8 90299FE5 		ldr	r2, .L680+44
 7062 3ecc FEFFFFEB 		bl	CyU3PUsbSetDesc
2492:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 7063              		.loc 1 2492 0
 7064 3ed0 0010A0E3 		mov	r1, #0
 7065 3ed4 88299FE5 		ldr	r2, .L680+48
 7066 3ed8 0200A0E3 		mov	r0, #2
 7067 3edc FEFFFFEB 		bl	CyU3PUsbSetDesc
2493:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 7068              		.loc 1 2493 0
 7069 3ee0 0010A0E3 		mov	r1, #0
 7070 3ee4 7C299FE5 		ldr	r2, .L680+52
 7071 3ee8 0700A0E3 		mov	r0, #7
 7072 3eec FEFFFFEB 		bl	CyU3PUsbSetDesc
2496:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 7073              		.loc 1 2496 0
 7074 3ef0 0010A0E3 		mov	r1, #0
 7075 3ef4 70299FE5 		ldr	r2, .L680+56
 7076 3ef8 0400A0E3 		mov	r0, #4
 7077 3efc FEFFFFEB 		bl	CyU3PUsbSetDesc
2497:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 7078              		.loc 1 2497 0
 7079 3f00 0010A0E3 		mov	r1, #0
 7080 3f04 64299FE5 		ldr	r2, .L680+60
 7081 3f08 0300A0E3 		mov	r0, #3
 7082 3f0c FEFFFFEB 		bl	CyU3PUsbSetDesc
2498:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 7083              		.loc 1 2498 0
 7084 3f10 0010A0E3 		mov	r1, #0
 7085 3f14 58299FE5 		ldr	r2, .L680+64
 7086 3f18 0600A0E3 		mov	r0, #6
 7087 3f1c FEFFFFEB 		bl	CyU3PUsbSetDesc
2501:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 7088              		.loc 1 2501 0
 7089 3f20 0010A0E3 		mov	r1, #0
 7090 3f24 4C299FE5 		ldr	r2, .L680+68
 7091 3f28 0500A0E3 		mov	r0, #5
 7092 3f2c FEFFFFEB 		bl	CyU3PUsbSetDesc
2502:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 7093              		.loc 1 2502 0
 7094 3f30 0110A0E3 		mov	r1, #1
 7095 3f34 40299FE5 		ldr	r2, .L680+72
 7096 3f38 0500A0E3 		mov	r0, #5
 7097 3f3c FEFFFFEB 		bl	CyU3PUsbSetDesc
2503:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 7098              		.loc 1 2503 0
 7099 3f40 0210A0E3 		mov	r1, #2
 7100 3f44 34299FE5 		ldr	r2, .L680+76
 7101 3f48 0500A0E3 		mov	r0, #5
 7102 3f4c FEFFFFEB 		bl	CyU3PUsbSetDesc
2513:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 7103              		.loc 1 2513 0
 7104 3f50 0080A0E3 		mov	r8, #0
2510:../uvc.c      ****     endPointConfig.enable   = 1;
 7105              		.loc 1 2510 0
 7106 3f54 0150A0E3 		mov	r5, #1
2512:../uvc.c      ****     endPointConfig.pcktSize = 64;
 7107              		.loc 1 2512 0
 7108 3f58 4070A0E3 		mov	r7, #64	@ movhi
2516:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 7109              		.loc 1 2516 0
 7110 3f5c 8200A0E3 		mov	r0, #130
 7111 3f60 A8108DE2 		add	r1, sp, #168
2511:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 7112              		.loc 1 2511 0
 7113 3f64 03A0A0E3 		mov	sl, #3
2512:../uvc.c      ****     endPointConfig.pcktSize = 64;
 7114              		.loc 1 2512 0
 7115 3f68 B07BCDE1 		strh	r7, [sp, #176]	@ movhi
2510:../uvc.c      ****     endPointConfig.enable   = 1;
 7116              		.loc 1 2510 0
 7117 3f6c A8508DE5 		str	r5, [sp, #168]
2511:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 7118              		.loc 1 2511 0
 7119 3f70 ACA0CDE5 		strb	sl, [sp, #172]
2513:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 7120              		.loc 1 2513 0
 7121 3f74 B380CDE5 		strb	r8, [sp, #179]
2514:../uvc.c      ****     endPointConfig.streams  = 0;
 7122              		.loc 1 2514 0
 7123 3f78 BE8ACDE1 		strh	r8, [sp, #174]	@ movhi
2515:../uvc.c      ****     endPointConfig.burstLen = 1;
 7124              		.loc 1 2515 0
 7125 3f7c B250CDE5 		strb	r5, [sp, #178]
2516:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 7126              		.loc 1 2516 0
 7127 3f80 FEFFFFEB 		bl	CyU3PSetEpConfig
 7128              	.LVL594:
2514:../uvc.c      ****     endPointConfig.streams  = 0;
 7129              		.loc 1 2514 0
 7130 3f84 0870A0E1 		mov	r7, r8	@ movhi
2517:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7131              		.loc 1 2517 0
 7132 3f88 003050E2 		subs	r3, r0, #0
 7133 3f8c 3B01001A 		bne	.L664
2527:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 7134              		.loc 1 2527 0
 7135 3f90 ECC89FE5 		ldr	ip, .L680+80
2528:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 7136              		.loc 1 2528 0
 7137 3f94 ECE89FE5 		ldr	lr, .L680+84
2525:../uvc.c      ****     dmaInterConfig.size           = 1024;
 7138              		.loc 1 2525 0
 7139 3f98 016BA0E3 		mov	r6, #1024	@ movhi
2534:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 7140              		.loc 1 2534 0
 7141 3f9c 1080A0E3 		mov	r8, #16
2536:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 7142              		.loc 1 2536 0
 7143 3fa0 E4089FE5 		ldr	r0, .L680+88
 7144              	.LVL595:
 7145 3fa4 0410A0E3 		mov	r1, #4
 7146 3fa8 34208DE2 		add	r2, sp, #52
2525:../uvc.c      ****     dmaInterConfig.size           = 1024;
 7147              		.loc 1 2525 0
 7148 3fac B463CDE1 		strh	r6, [sp, #52]	@ movhi
2526:../uvc.c      ****     dmaInterConfig.count          = 1;
 7149              		.loc 1 2526 0
 7150 3fb0 B653CDE1 		strh	r5, [sp, #54]	@ movhi
2527:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 7151              		.loc 1 2527 0
 7152 3fb4 B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
2528:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 7153              		.loc 1 2528 0
 7154 3fb8 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
2529:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 7155              		.loc 1 2529 0
 7156 3fbc BC33CDE1 		strh	r3, [sp, #60]	@ movhi
2530:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 7157              		.loc 1 2530 0
 7158 3fc0 BE33CDE1 		strh	r3, [sp, #62]	@ movhi
2531:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 7159              		.loc 1 2531 0
 7160 3fc4 B034CDE1 		strh	r3, [sp, #64]	@ movhi
2532:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 7161              		.loc 1 2532 0
 7162 3fc8 B234CDE1 		strh	r3, [sp, #66]	@ movhi
2533:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 7163              		.loc 1 2533 0
 7164 3fcc 4470CDE5 		strb	r7, [sp, #68]
2534:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 7165              		.loc 1 2534 0
 7166 3fd0 48808DE5 		str	r8, [sp, #72]
2535:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 7167              		.loc 1 2535 0
 7168 3fd4 4C308DE5 		str	r3, [sp, #76]
2536:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 7169              		.loc 1 2536 0
 7170 3fd8 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 7171              	.LVL596:
2538:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7172              		.loc 1 2538 0
 7173 3fdc 006050E2 		subs	r6, r0, #0
 7174 3fe0 DF00001A 		bne	.L665
2545:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 7175              		.loc 1 2545 0
 7176 3fe4 010BA0E3 		mov	r0, #1024
 7177              	.LVL597:
 7178 3fe8 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 7179 3fec 9C189FE5 		ldr	r1, .L680+92
2546:../uvc.c      ****     if (glInterStaBuffer == 0)
 7180              		.loc 1 2546 0
 7181 3ff0 000050E3 		cmp	r0, #0
2545:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 7182              		.loc 1 2545 0
 7183 3ff4 000081E5 		str	r0, [r1, #0]
2546:../uvc.c      ****     if (glInterStaBuffer == 0)
 7184              		.loc 1 2546 0
 7185 3ff8 D000000A 		beq	.L666
2553:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
 7186              		.loc 1 2553 0
 7187 3ffc 0610A0E1 		mov	r1, r6
 7188 4000 0620A0E1 		mov	r2, r6
 7189 4004 3830A0E3 		mov	r3, #56
 7190 4008 84089FE5 		ldr	r0, .L680+96
 7191 400c FEFFFFEB 		bl	_txe_mutex_create
2555:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 7192              		.loc 1 2555 0
 7193 4010 0430A0E3 		mov	r3, #4	@ movhi
 7194 4014 BE30CDE1 		strh	r3, [sp, #14]	@ movhi
2558:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 7195              		.loc 1 2558 0
 7196 4018 78389FE5 		ldr	r3, .L680+100
2554:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 7197              		.loc 1 2554 0
 7198 401c 01C9A0E3 		mov	ip, #16384	@ movhi
 7199 4020 BCC0CDE1 		strh	ip, [sp, #12]	@ movhi
2557:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 7200              		.loc 1 2557 0
 7201 4024 01CCA0E3 		mov	ip, #256	@ movhi
 7202 4028 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
2558:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 7203              		.loc 1 2558 0
 7204 402c B431CDE1 		strh	r3, [sp, #20]	@ movhi
2559:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 7205              		.loc 1 2559 0
 7206 4030 64C89FE5 		ldr	ip, .L680+104
2561:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 7207              		.loc 1 2561 0
 7208 4034 0C30A0E3 		mov	r3, #12	@ movhi
 7209 4038 B432CDE1 		strh	r3, [sp, #36]	@ movhi
2566:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 7210              		.loc 1 2566 0
 7211 403c 5C389FE5 		ldr	r3, .L680+108
2567:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 7212              		.loc 1 2567 0
 7213 4040 0C208DE2 		add	r2, sp, #12
2559:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 7214              		.loc 1 2559 0
 7215 4044 BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
2564:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 7216              		.loc 1 2564 0
 7217 4048 2A70CDE5 		strb	r7, [sp, #42]
2562:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 7218              		.loc 1 2562 0
 7219 404c 04C0A0E3 		mov	ip, #4	@ movhi
2556:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 7220              		.loc 1 2556 0
 7221 4050 02A0A0E3 		mov	sl, #2	@ movhi
2567:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 7222              		.loc 1 2567 0
 7223 4054 48089FE5 		ldr	r0, .L680+112
 7224 4058 0710A0E3 		mov	r1, #7
2565:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 7225              		.loc 1 2565 0
 7226 405c 1870A0E3 		mov	r7, #24
2556:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 7227              		.loc 1 2556 0
 7228 4060 B0A1CDE1 		strh	sl, [sp, #16]	@ movhi
2560:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 7229              		.loc 1 2560 0
 7230 4064 B262CDE1 		strh	r6, [sp, #34]	@ movhi
2562:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 7231              		.loc 1 2562 0
 7232 4068 B6C2CDE1 		strh	ip, [sp, #38]	@ movhi
2563:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 7233              		.loc 1 2563 0
 7234 406c B862CDE1 		strh	r6, [sp, #40]	@ movhi
2565:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 7235              		.loc 1 2565 0
 7236 4070 2C708DE5 		str	r7, [sp, #44]
2566:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 7237              		.loc 1 2566 0
 7238 4074 30308DE5 		str	r3, [sp, #48]
2567:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 7239              		.loc 1 2567 0
 7240 4078 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 7241              	.LVL598:
2569:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7242              		.loc 1 2569 0
 7243 407c 002050E2 		subs	r2, r0, #0
 7244 4080 A500001A 		bne	.L667
2660:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 7245              		.loc 1 2660 0
 7246 4084 0500A0E1 		mov	r0, r5
 7247              	.LVL599:
 7248 4088 0510A0E1 		mov	r1, r5
 7249 408c FEFFFFEB 		bl	CyU3PConnectState
 7250              	.LVL600:
2661:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7251              		.loc 1 2661 0
 7252 4090 002050E2 		subs	r2, r0, #0
 7253 4094 9700001A 		bne	.L668
2667:../uvc.c      ****     CyU3PBusyWait(100);
 7254              		.loc 1 2667 0
 7255 4098 6400A0E3 		mov	r0, #100
 7256              	.LVL601:
 7257 409c FEFFFFEB 		bl	CyU3PBusyWait
 7258              	.LVL602:
2669:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 7259              		.loc 1 2669 0
 7260 40a0 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2683:../uvc.c      ****     endPointConfig.streams  = 0;
 7261              		.loc 1 2683 0
 7262 40a4 0020A0E3 		mov	r2, #0	@ movhi
2672:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 7263              		.loc 1 2672 0
 7264 40a8 ACA0CDE5 		strb	sl, [sp, #172]
2684:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 7265              		.loc 1 2684 0
 7266 40ac A8108DE2 		add	r1, sp, #168
2683:../uvc.c      ****     endPointConfig.streams  = 0;
 7267              		.loc 1 2683 0
 7268 40b0 BE2ACDE1 		strh	r2, [sp, #174]	@ movhi
2671:../uvc.c      ****     endPointConfig.enable   = 1;
 7269              		.loc 1 2671 0
 7270 40b4 A8508DE5 		str	r5, [sp, #168]
2673:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 7271              		.loc 1 2673 0
 7272 40b8 030050E3 		cmp	r0, #3
2669:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 7273              		.loc 1 2669 0
 7274 40bc 4800C4E5 		strb	r0, [r4, #72]
2680:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 7275              		.loc 1 2680 0
 7276 40c0 020CA013 		movne	r0, #512	@ movhi
2675:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 7277              		.loc 1 2675 0
 7278 40c4 01ABA003 		moveq	sl, #1024	@ movhi
2680:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 7279              		.loc 1 2680 0
 7280 40c8 B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2684:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 7281              		.loc 1 2684 0
 7282 40cc 8300A0E3 		mov	r0, #131
2675:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 7283              		.loc 1 2675 0
 7284 40d0 B0ABCD01 		streqh	sl, [sp, #176]	@ movhi
2676:../uvc.c      ****     	endPointConfig.burstLen = 16;
 7285              		.loc 1 2676 0
 7286 40d4 B280CD05 		streqb	r8, [sp, #178]
2681:../uvc.c      ****     	endPointConfig.burstLen = 1;
 7287              		.loc 1 2681 0
 7288 40d8 B250CD15 		strneb	r5, [sp, #178]
2684:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 7289              		.loc 1 2684 0
 7290 40dc FEFFFFEB 		bl	CyU3PSetEpConfig
 7291              	.LVL603:
2685:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7292              		.loc 1 2685 0
 7293 40e0 002050E2 		subs	r2, r0, #0
 7294 40e4 4F00001A 		bne	.L651
 7295 40e8 B8779FE5 		ldr	r7, .L680+116
 7296              	.LBE227:
 7297              	.LBE224:
2808:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 7298              		.loc 1 2808 0
 7299 40ec 54579FE5 		ldr	r5, .L680+20
 7300 40f0 0260A0E1 		mov	r6, r2
2997:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 7301              		.loc 1 2997 0
 7302 40f4 0080E0E3 		mvn	r8, #0
 7303              	.LVL604:
 7304              	.L602:
2808:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 7305              		.loc 1 2808 0
 7306 40f8 48079FE5 		ldr	r0, .L680+20
 7307 40fc 0110A0E3 		mov	r1, #1
 7308 4100 0220A0E3 		mov	r2, #2
 7309 4104 B4308DE2 		add	r3, sp, #180
 7310 4108 00608DE5 		str	r6, [sp, #0]
 7311 410c FEFFFFEB 		bl	_txe_event_flags_get
 7312 4110 000050E3 		cmp	r0, #0
 7313 4114 3000001A 		bne	.L604
2854:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 7314              		.loc 1 2854 0
 7315 4118 3CE095E5 		ldr	lr, [r5, #60]
 7316 411c 00005EE3 		cmp	lr, #0
 7317 4120 0300000A 		beq	.L605
2854:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 7318              		.loc 1 2854 0 is_stmt 0 discriminator 1
 7319 4124 B014D5E1 		ldrh	r1, [r5, #64]
 7320 4128 B234D5E1 		ldrh	r3, [r5, #66]
 7321 412c 030051E1 		cmp	r1, r3
 7322 4130 1201000A 		beq	.L669
 7323              	.L605:
3058:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 7324              		.loc 1 3058 0 is_stmt 1
 7325 4134 4010A0E3 		mov	r1, #64
 7326 4138 0020A0E3 		mov	r2, #0
 7327 413c 04079FE5 		ldr	r0, .L680+20
 7328 4140 FEFFFFEB 		bl	_txe_event_flags_set
3061:../uvc.c      ****         CyU3PThreadRelinquish ();
 7329              		.loc 1 3061 0
 7330 4144 FEFFFFEB 		bl	_txe_thread_relinquish
3062:../uvc.c      ****     }
 7331              		.loc 1 3062 0
 7332 4148 EAFFFFEA 		b	.L602
 7333              	.LVL605:
 7334              	.L654:
 7335              	.LBB262:
 7336              	.LBB226:
2357:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 7337              		.loc 1 2357 0
 7338 414c 0400A0E3 		mov	r0, #4
 7339              	.LVL606:
 7340 4150 54179FE5 		ldr	r1, .L680+120
 7341 4154 FEFFFFEB 		bl	CyU3PDebugPrint
 7342              	.LVL607:
 7343              	.L571:
 7344              	.LBB242:
 7345              	.LBB243:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7346              		.loc 1 1786 0
 7347 4158 50179FE5 		ldr	r1, .L680+124
 7348 415c 0400A0E3 		mov	r0, #4
 7349 4160 FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 7350              		.loc 1 1787 0
 7351 4164 FA0FA0E3 		mov	r0, #1000
 7352 4168 FEFFFFEB 		bl	_tx_thread_sleep
 7353 416c F9FFFFEA 		b	.L571
 7354              	.LVL608:
 7355              	.L656:
 7356              	.LBE243:
 7357              	.LBE242:
2388:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 7358              		.loc 1 2388 0
 7359 4170 0400A0E3 		mov	r0, #4
 7360              	.LVL609:
 7361 4174 38179FE5 		ldr	r1, .L680+128
 7362 4178 FEFFFFEB 		bl	CyU3PDebugPrint
 7363              	.LVL610:
 7364              	.L575:
 7365              	.LBB240:
 7366              	.LBB241:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7367              		.loc 1 1786 0
 7368 417c 2C179FE5 		ldr	r1, .L680+124
 7369 4180 0400A0E3 		mov	r0, #4
 7370 4184 FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 7371              		.loc 1 1787 0
 7372 4188 FA0FA0E3 		mov	r0, #1000
 7373 418c FEFFFFEB 		bl	_tx_thread_sleep
 7374 4190 F9FFFFEA 		b	.L575
 7375              	.LVL611:
 7376              	.L655:
 7377              	.LBE241:
 7378              	.LBE240:
2379:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 7379              		.loc 1 2379 0
 7380 4194 0400A0E3 		mov	r0, #4
 7381              	.LVL612:
 7382 4198 18179FE5 		ldr	r1, .L680+132
 7383 419c FEFFFFEB 		bl	CyU3PDebugPrint
 7384              	.LVL613:
 7385              	.L573:
 7386              	.LBB238:
 7387              	.LBB239:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7388              		.loc 1 1786 0
 7389 41a0 08179FE5 		ldr	r1, .L680+124
 7390 41a4 0400A0E3 		mov	r0, #4
 7391 41a8 FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 7392              		.loc 1 1787 0
 7393 41ac FA0FA0E3 		mov	r0, #1000
 7394 41b0 FEFFFFEB 		bl	_tx_thread_sleep
 7395 41b4 F9FFFFEA 		b	.L573
 7396              	.LVL614:
 7397              	.L657:
 7398              	.LBE239:
 7399              	.LBE238:
2394:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 7400              		.loc 1 2394 0
 7401 41b8 0400A0E3 		mov	r0, #4
 7402              	.LVL615:
 7403 41bc F8169FE5 		ldr	r1, .L680+136
 7404 41c0 FEFFFFEB 		bl	CyU3PDebugPrint
 7405              	.LVL616:
 7406              	.L577:
 7407              	.LBB236:
 7408              	.LBB237:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7409              		.loc 1 1786 0
 7410 41c4 E4169FE5 		ldr	r1, .L680+124
 7411 41c8 0400A0E3 		mov	r0, #4
 7412 41cc FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 7413              		.loc 1 1787 0
 7414 41d0 FA0FA0E3 		mov	r0, #1000
 7415 41d4 FEFFFFEB 		bl	_tx_thread_sleep
 7416 41d8 F9FFFFEA 		b	.L577
 7417              	.LVL617:
 7418              	.L604:
 7419              	.LBE237:
 7420              	.LBE236:
 7421              	.LBE226:
 7422              	.LBE262:
2965:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 7423              		.loc 1 2965 0
 7424 41dc 64069FE5 		ldr	r0, .L680+20
 7425 41e0 0210A0E3 		mov	r1, #2
 7426 41e4 0320A0E3 		mov	r2, #3
 7427 41e8 B4308DE2 		add	r3, sp, #180
 7428 41ec 00608DE5 		str	r6, [sp, #0]
 7429 41f0 FEFFFFEB 		bl	_txe_event_flags_get
 7430 41f4 000050E3 		cmp	r0, #0
 7431 41f8 2500001A 		bne	.L627
2980:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 7432              		.loc 1 2980 0
 7433 41fc 441095E5 		ldr	r1, [r5, #68]
2968:../uvc.c      ****                 hitFV     = CyFalse;
 7434              		.loc 1 2968 0
 7435 4200 3C6085E5 		str	r6, [r5, #60]
2980:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 7436              		.loc 1 2980 0
 7437 4204 000051E3 		cmp	r1, #0
2969:../uvc.c      ****                 prodCount = 0;
 7438              		.loc 1 2969 0
 7439 4208 B064C5E1 		strh	r6, [r5, #64]	@ movhi
2976:../uvc.c      ****                 fb=0;
 7440              		.loc 1 2976 0
 7441 420c B463C5E1 		strh	r6, [r5, #52]	@ movhi
2970:../uvc.c      ****                 consCount = 0;
 7442              		.loc 1 2970 0
 7443 4210 B264C5E1 		strh	r6, [r5, #66]	@ movhi
2977:../uvc.c      ****                 pb=0;
 7444              		.loc 1 2977 0
 7445 4214 B663C5E1 		strh	r6, [r5, #54]	@ movhi
2978:../uvc.c      ****                 pbc=0;
 7446              		.loc 1 2978 0
 7447 4218 B863C5E1 		strh	r6, [r5, #56]	@ movhi
2980:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 7448              		.loc 1 2980 0
 7449 421c 0A00000A 		beq	.L670
 7450              	.L628:
2992:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 7451              		.loc 1 2992 0
 7452 4220 446084E5 		str	r6, [r4, #68]
 7453 4224 C2FFFFEA 		b	.L605
 7454              	.LVL618:
 7455              	.L651:
 7456              	.LBB263:
 7457              	.LBB260:
2688:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 7458              		.loc 1 2688 0
 7459 4228 0400A0E3 		mov	r0, #4
 7460              	.LVL619:
 7461 422c 8C169FE5 		ldr	r1, .L680+140
 7462 4230 FEFFFFEB 		bl	CyU3PDebugPrint
 7463              	.LVL620:
 7464              	.L603:
 7465              	.LBB244:
 7466              	.LBB245:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7467              		.loc 1 1786 0
 7468 4234 74169FE5 		ldr	r1, .L680+124
 7469 4238 0400A0E3 		mov	r0, #4
 7470 423c FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 7471              		.loc 1 1787 0
 7472 4240 FA0FA0E3 		mov	r0, #1000
 7473 4244 FEFFFFEB 		bl	_tx_thread_sleep
 7474 4248 F9FFFFEA 		b	.L603
 7475              	.LVL621:
 7476              	.L670:
 7477              	.LBE245:
 7478              	.LBE244:
 7479              	.LBE260:
 7480              	.LBE263:
2982:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 7481              		.loc 1 2982 0
 7482 424c 50069FE5 		ldr	r0, .L680+112
 7483 4250 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 7484              	.LVL622:
2983:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 7485              		.loc 1 2983 0
 7486 4254 000050E3 		cmp	r0, #0
 7487 4258 0200001A 		bne	.L652
2989:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 7488              		.loc 1 2989 0
 7489 425c 8300A0E3 		mov	r0, #131
 7490              	.LVL623:
 7491 4260 FEFFFFEB 		bl	CyU3PUsbFlushEp
 7492 4264 EDFFFFEA 		b	.L628
 7493              	.L652:
 7494              	.LBB264:
 7495              	.LBB265:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7496              		.loc 1 1786 0
 7497 4268 40169FE5 		ldr	r1, .L680+124
 7498 426c 0400A0E3 		mov	r0, #4
 7499 4270 FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 7500              		.loc 1 1787 0
 7501 4274 FA0FA0E3 		mov	r0, #1000
 7502 4278 FEFFFFEB 		bl	_tx_thread_sleep
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7503              		.loc 1 1786 0
 7504 427c 2C169FE5 		ldr	r1, .L680+124
 7505 4280 0400A0E3 		mov	r0, #4
 7506 4284 FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 7507              		.loc 1 1787 0
 7508 4288 FA0FA0E3 		mov	r0, #1000
 7509 428c FEFFFFEB 		bl	_tx_thread_sleep
 7510 4290 F4FFFFEA 		b	.L652
 7511              	.L627:
 7512              	.LBE265:
 7513              	.LBE264:
2997:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 7514              		.loc 1 2997 0
 7515 4294 0110A0E3 		mov	r1, #1
 7516 4298 0220A0E3 		mov	r2, #2
 7517 429c B4308DE2 		add	r3, sp, #180
 7518 42a0 A0059FE5 		ldr	r0, .L680+20
 7519 42a4 00808DE5 		str	r8, [sp, #0]
 7520 42a8 FEFFFFEB 		bl	_txe_event_flags_get
3001:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 7521              		.loc 1 3001 0
 7522 42ac 0620A0E1 		mov	r2, r6
 7523 42b0 EC059FE5 		ldr	r0, .L680+112
 7524 42b4 0610A0E1 		mov	r1, r6
 7525 42b8 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 7526              	.LVL624:
3002:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7527              		.loc 1 3002 0
 7528 42bc 002050E2 		subs	r2, r0, #0
 7529 42c0 6500001A 		bne	.L671
3010:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 7530              		.loc 1 3010 0
 7531 42c4 280095E5 		ldr	r0, [r5, #40]
 7532              	.LVL625:
 7533 42c8 000050E3 		cmp	r0, #0
 7534 42cc 5A00001A 		bne	.L633
 7535              	.LVL626:
 7536              	.LBB266:
 7537              	.LBB267:
2713:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 7538              		.loc 1 2713 0
 7539 42d0 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 7540 42d4 030053E3 		cmp	r3, #3
 7541 42d8 4700000A 		beq	.L672
2718:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 7542              		.loc 1 2718 0
 7543 42dc 020053E3 		cmp	r3, #2
 7544 42e0 2900000A 		beq	.L673
 7545              	.LVL627:
 7546              	.L636:
 7547              	.LBE267:
 7548              	.LBE266:
3046:../uvc.c      ****                     gpif_initialized = CyTrue;
 7549              		.loc 1 3046 0
 7550 42e4 0120A0E3 		mov	r2, #1
 7551 42e8 282084E5 		str	r2, [r4, #40]
3047:../uvc.c      ****                     CyU3PThreadSleep(200);
 7552              		.loc 1 3047 0
 7553 42ec C800A0E3 		mov	r0, #200
 7554 42f0 FEFFFFEB 		bl	_tx_thread_sleep
 7555 42f4 8EFFFFEA 		b	.L605
 7556              	.LVL628:
 7557              	.L668:
 7558              	.LBB273:
 7559              	.LBB225:
2663:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 7560              		.loc 1 2663 0
 7561 42f8 0400A0E3 		mov	r0, #4
 7562              	.LVL629:
 7563 42fc C0159FE5 		ldr	r1, .L680+144
 7564 4300 FEFFFFEB 		bl	CyU3PDebugPrint
 7565              	.LVL630:
 7566              	.L599:
 7567              	.LBB234:
 7568              	.LBB235:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7569              		.loc 1 1786 0
 7570 4304 A4159FE5 		ldr	r1, .L680+124
 7571 4308 0400A0E3 		mov	r0, #4
 7572 430c FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 7573              		.loc 1 1787 0
 7574 4310 FA0FA0E3 		mov	r0, #1000
 7575 4314 FEFFFFEB 		bl	_tx_thread_sleep
 7576 4318 F9FFFFEA 		b	.L599
 7577              	.LVL631:
 7578              	.L667:
 7579              	.LBE235:
 7580              	.LBE234:
2572:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 7581              		.loc 1 2572 0
 7582 431c 0400A0E3 		mov	r0, #4
 7583              	.LVL632:
 7584 4320 A0159FE5 		ldr	r1, .L680+148
 7585 4324 FEFFFFEB 		bl	CyU3PDebugPrint
 7586              	.LVL633:
 7587              	.L597:
 7588              	.LBB232:
 7589              	.LBB233:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7590              		.loc 1 1786 0
 7591 4328 80159FE5 		ldr	r1, .L680+124
 7592 432c 0400A0E3 		mov	r0, #4
 7593 4330 FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 7594              		.loc 1 1787 0
 7595 4334 FA0FA0E3 		mov	r0, #1000
 7596 4338 FEFFFFEB 		bl	_tx_thread_sleep
 7597 433c F9FFFFEA 		b	.L597
 7598              	.LVL634:
 7599              	.L666:
 7600              	.LBE233:
 7601              	.LBE232:
2548:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 7602              		.loc 1 2548 0
 7603 4340 040080E2 		add	r0, r0, #4
 7604 4344 80159FE5 		ldr	r1, .L680+152
 7605 4348 FEFFFFEB 		bl	CyU3PDebugPrint
 7606              	.LVL635:
 7607              	.L595:
 7608              	.LBB230:
 7609              	.LBB231:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7610              		.loc 1 1786 0
 7611 434c 5C159FE5 		ldr	r1, .L680+124
 7612 4350 0400A0E3 		mov	r0, #4
 7613 4354 FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 7614              		.loc 1 1787 0
 7615 4358 FA0FA0E3 		mov	r0, #1000
 7616 435c FEFFFFEB 		bl	_tx_thread_sleep
 7617 4360 F9FFFFEA 		b	.L595
 7618              	.LVL636:
 7619              	.L665:
 7620              	.LBE231:
 7621              	.LBE230:
2541:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 7622              		.loc 1 2541 0
 7623 4364 0400A0E3 		mov	r0, #4
 7624 4368 60159FE5 		ldr	r1, .L680+156
 7625 436c 0620A0E1 		mov	r2, r6
 7626 4370 FEFFFFEB 		bl	CyU3PDebugPrint
 7627              	.L593:
 7628              	.LBB228:
 7629              	.LBB229:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7630              		.loc 1 1786 0
 7631 4374 34159FE5 		ldr	r1, .L680+124
 7632 4378 0400A0E3 		mov	r0, #4
 7633 437c FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 7634              		.loc 1 1787 0
 7635 4380 FA0FA0E3 		mov	r0, #1000
 7636 4384 FEFFFFEB 		bl	_tx_thread_sleep
 7637 4388 F9FFFFEA 		b	.L593
 7638              	.LVL637:
 7639              	.L673:
 7640              	.LBE229:
 7641              	.LBE228:
 7642              	.LBE225:
 7643              	.LBE273:
 7644              	.LBB274:
 7645              	.LBB272:
2720:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 7646              		.loc 1 2720 0
 7647 438c 40159FE5 		ldr	r1, .L680+160
 7648 4390 0100A0E3 		mov	r0, #1
 7649 4394 FEFFFFEB 		bl	CyU3PDebugPrint
 7650              	.LVL638:
2721:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 7651              		.loc 1 2721 0
 7652 4398 38059FE5 		ldr	r0, .L680+164
 7653 439c FEFFFFEB 		bl	CyU3PGpifLoad
 7654 43a0 0020A0E1 		mov	r2, r0
 7655              	.LVL639:
 7656              	.L635:
2723:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7657              		.loc 1 2723 0
 7658 43a4 000052E3 		cmp	r2, #0
 7659 43a8 1A00001A 		bne	.L674
2731:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 7660              		.loc 1 2731 0
 7661 43ac 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 7662 43b0 030053E3 		cmp	r3, #3
 7663 43b4 0100000A 		beq	.L653
2735:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 7664              		.loc 1 2735 0
 7665 43b8 020053E3 		cmp	r3, #2
 7666 43bc C8FFFF1A 		bne	.L636
 7667              	.L653:
2737:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 7668              		.loc 1 2737 0
 7669 43c0 0200A0E1 		mov	r0, r2
 7670              	.LVL640:
 7671 43c4 0210A0E1 		mov	r1, r2
 7672 43c8 FEFFFFEB 		bl	CyU3PGpifSMStart
 7673              	.LVL641:
2739:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7674              		.loc 1 2739 0
 7675 43cc 000050E3 		cmp	r0, #0
2737:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 7676              		.loc 1 2737 0
 7677 43d0 0020A0E1 		mov	r2, r0
 7678              	.LVL642:
2739:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7679              		.loc 1 2739 0
 7680 43d4 C2FFFF0A 		beq	.L636
2742:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 7681              		.loc 1 2742 0
 7682 43d8 0400A0E3 		mov	r0, #4
 7683              	.LVL643:
 7684 43dc F8149FE5 		ldr	r1, .L680+168
 7685 43e0 FEFFFFEB 		bl	CyU3PDebugPrint
 7686              	.LVL644:
 7687              	.L641:
 7688              	.LBB268:
 7689              	.LBB269:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7690              		.loc 1 1786 0
 7691 43e4 C4149FE5 		ldr	r1, .L680+124
 7692 43e8 0400A0E3 		mov	r0, #4
 7693 43ec FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 7694              		.loc 1 1787 0
 7695 43f0 FA0FA0E3 		mov	r0, #1000
 7696 43f4 FEFFFFEB 		bl	_tx_thread_sleep
 7697 43f8 F9FFFFEA 		b	.L641
 7698              	.LVL645:
 7699              	.L672:
 7700              	.LBE269:
 7701              	.LBE268:
2715:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 7702              		.loc 1 2715 0
 7703 43fc DC149FE5 		ldr	r1, .L680+172
 7704 4400 0100A0E3 		mov	r0, #1
 7705 4404 FEFFFFEB 		bl	CyU3PDebugPrint
 7706              	.LVL646:
2716:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 7707              		.loc 1 2716 0
 7708 4408 D4049FE5 		ldr	r0, .L680+176
 7709 440c FEFFFFEB 		bl	CyU3PGpifLoad
 7710 4410 0020A0E1 		mov	r2, r0
 7711              	.LVL647:
 7712 4414 E2FFFFEA 		b	.L635
 7713              	.L674:
2726:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 7714              		.loc 1 2726 0
 7715 4418 0400A0E3 		mov	r0, #4
 7716              	.LVL648:
 7717 441c C4149FE5 		ldr	r1, .L680+180
 7718 4420 FEFFFFEB 		bl	CyU3PDebugPrint
 7719              	.LVL649:
 7720              	.L638:
 7721              	.LBB270:
 7722              	.LBB271:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7723              		.loc 1 1786 0
 7724 4424 84149FE5 		ldr	r1, .L680+124
 7725 4428 0400A0E3 		mov	r0, #4
 7726 442c FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 7727              		.loc 1 1787 0
 7728 4430 FA0FA0E3 		mov	r0, #1000
 7729 4434 FEFFFFEB 		bl	_tx_thread_sleep
 7730 4438 F9FFFFEA 		b	.L638
 7731              	.LVL650:
 7732              	.L633:
 7733              	.LBE271:
 7734              	.LBE270:
 7735              	.LBE272:
 7736              	.LBE274:
3054:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 7737              		.loc 1 3054 0
 7738 443c 54049FE5 		ldr	r0, .L680+100
 7739 4440 02C0A0E3 		mov	ip, #2
 7740 4444 0610A0E1 		mov	r1, r6
 7741 4448 0020A0E1 		mov	r2, r0
 7742              	.LVL651:
 7743 444c 0630A0E1 		mov	r3, r6
 7744 4450 00C08DE5 		str	ip, [sp, #0]
 7745 4454 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 7746 4458 35FFFFEA 		b	.L605
 7747              	.LVL652:
 7748              	.L671:
3005:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 7749              		.loc 1 3005 0
 7750 445c 0400A0E3 		mov	r0, #4
 7751              	.LVL653:
 7752 4460 84149FE5 		ldr	r1, .L680+184
 7753 4464 FEFFFFEB 		bl	CyU3PDebugPrint
 7754              	.LVL654:
 7755              	.L632:
 7756              	.LBB275:
 7757              	.LBB276:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7758              		.loc 1 1786 0
 7759 4468 40149FE5 		ldr	r1, .L680+124
 7760 446c 0400A0E3 		mov	r0, #4
 7761 4470 FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 7762              		.loc 1 1787 0
 7763 4474 FA0FA0E3 		mov	r0, #1000
 7764 4478 FEFFFFEB 		bl	_tx_thread_sleep
 7765 447c F9FFFFEA 		b	.L632
 7766              	.LVL655:
 7767              	.L664:
 7768              	.LBE276:
 7769              	.LBE275:
 7770              	.LBB277:
 7771              	.LBB261:
2520:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 7772              		.loc 1 2520 0
 7773 4480 0400A0E3 		mov	r0, #4
 7774              	.LVL656:
 7775 4484 34149FE5 		ldr	r1, .L680+140
 7776 4488 0320A0E1 		mov	r2, r3
 7777 448c FEFFFFEB 		bl	CyU3PDebugPrint
 7778              	.LVL657:
 7779              	.L591:
 7780              	.LBB246:
 7781              	.LBB247:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7782              		.loc 1 1786 0
 7783 4490 18149FE5 		ldr	r1, .L680+124
 7784 4494 0400A0E3 		mov	r0, #4
 7785 4498 FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 7786              		.loc 1 1787 0
 7787 449c FA0FA0E3 		mov	r0, #1000
 7788 44a0 FEFFFFEB 		bl	_tx_thread_sleep
 7789 44a4 F9FFFFEA 		b	.L591
 7790              	.LVL658:
 7791              	.L663:
 7792              	.LBE247:
 7793              	.LBE246:
2475:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 7794              		.loc 1 2475 0
 7795 44a8 0400A0E3 		mov	r0, #4
 7796              	.LVL659:
 7797 44ac 3C149FE5 		ldr	r1, .L680+188
 7798 44b0 FEFFFFEB 		bl	CyU3PDebugPrint
 7799              	.LVL660:
 7800              	.L589:
 7801              	.LBB248:
 7802              	.LBB249:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7803              		.loc 1 1786 0
 7804 44b4 F4139FE5 		ldr	r1, .L680+124
 7805 44b8 0400A0E3 		mov	r0, #4
 7806 44bc FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 7807              		.loc 1 1787 0
 7808 44c0 FA0FA0E3 		mov	r0, #1000
 7809 44c4 FEFFFFEB 		bl	_tx_thread_sleep
 7810 44c8 F9FFFFEA 		b	.L589
 7811              	.LVL661:
 7812              	.L662:
 7813              	.LBE249:
 7814              	.LBE248:
2454:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 7815              		.loc 1 2454 0
 7816 44cc 0400A0E3 		mov	r0, #4
 7817              	.LVL662:
 7818 44d0 1C149FE5 		ldr	r1, .L680+192
 7819 44d4 FEFFFFEB 		bl	CyU3PDebugPrint
 7820              	.LVL663:
 7821              	.L587:
 7822              	.LBB250:
 7823              	.LBB251:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7824              		.loc 1 1786 0
 7825 44d8 D0139FE5 		ldr	r1, .L680+124
 7826 44dc 0400A0E3 		mov	r0, #4
 7827 44e0 FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 7828              		.loc 1 1787 0
 7829 44e4 FA0FA0E3 		mov	r0, #1000
 7830 44e8 FEFFFFEB 		bl	_tx_thread_sleep
 7831 44ec F9FFFFEA 		b	.L587
 7832              	.LVL664:
 7833              	.L661:
 7834              	.LBE251:
 7835              	.LBE250:
2441:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 7836              		.loc 1 2441 0
 7837 44f0 0400A0E3 		mov	r0, #4
 7838              	.LVL665:
 7839 44f4 FC139FE5 		ldr	r1, .L680+196
 7840 44f8 FEFFFFEB 		bl	CyU3PDebugPrint
 7841              	.LVL666:
 7842              	.L585:
 7843              	.LBB252:
 7844              	.LBB253:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7845              		.loc 1 1786 0
 7846 44fc AC139FE5 		ldr	r1, .L680+124
 7847 4500 0400A0E3 		mov	r0, #4
 7848 4504 FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 7849              		.loc 1 1787 0
 7850 4508 FA0FA0E3 		mov	r0, #1000
 7851 450c FEFFFFEB 		bl	_tx_thread_sleep
 7852 4510 F9FFFFEA 		b	.L585
 7853              	.LVL667:
 7854              	.L659:
 7855              	.LBE253:
 7856              	.LBE252:
2413:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 7857              		.loc 1 2413 0
 7858 4514 0400A0E3 		mov	r0, #4
 7859              	.LVL668:
 7860 4518 DC139FE5 		ldr	r1, .L680+200
 7861 451c FEFFFFEB 		bl	CyU3PDebugPrint
 7862              	.LVL669:
 7863              	.L581:
 7864              	.LBB254:
 7865              	.LBB255:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7866              		.loc 1 1786 0
 7867 4520 88139FE5 		ldr	r1, .L680+124
 7868 4524 0400A0E3 		mov	r0, #4
 7869 4528 FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 7870              		.loc 1 1787 0
 7871 452c FA0FA0E3 		mov	r0, #1000
 7872 4530 FEFFFFEB 		bl	_tx_thread_sleep
 7873 4534 F9FFFFEA 		b	.L581
 7874              	.LVL670:
 7875              	.L658:
 7876              	.LBE255:
 7877              	.LBE254:
2400:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 7878              		.loc 1 2400 0
 7879 4538 0400A0E3 		mov	r0, #4
 7880              	.LVL671:
 7881 453c BC139FE5 		ldr	r1, .L680+204
 7882 4540 FEFFFFEB 		bl	CyU3PDebugPrint
 7883              	.LVL672:
 7884              	.L579:
 7885              	.LBB256:
 7886              	.LBB257:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7887              		.loc 1 1786 0
 7888 4544 64139FE5 		ldr	r1, .L680+124
 7889 4548 0400A0E3 		mov	r0, #4
 7890 454c FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 7891              		.loc 1 1787 0
 7892 4550 FA0FA0E3 		mov	r0, #1000
 7893 4554 FEFFFFEB 		bl	_tx_thread_sleep
 7894 4558 F9FFFFEA 		b	.L579
 7895              	.LVL673:
 7896              	.L660:
 7897              	.LBE257:
 7898              	.LBE256:
2427:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 7899              		.loc 1 2427 0
 7900 455c 0400A0E3 		mov	r0, #4
 7901              	.LVL674:
 7902 4560 9C139FE5 		ldr	r1, .L680+208
 7903 4564 FEFFFFEB 		bl	CyU3PDebugPrint
 7904              	.LVL675:
 7905              	.L583:
 7906              	.LBB258:
 7907              	.LBB259:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7908              		.loc 1 1786 0
 7909 4568 40139FE5 		ldr	r1, .L680+124
 7910 456c 0400A0E3 		mov	r0, #4
 7911 4570 FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 7912              		.loc 1 1787 0
 7913 4574 FA0FA0E3 		mov	r0, #1000
 7914 4578 FEFFFFEB 		bl	_tx_thread_sleep
 7915 457c F9FFFFEA 		b	.L583
 7916              	.LVL676:
 7917              	.L669:
 7918              	.LBE259:
 7919              	.LBE258:
 7920              	.LBE261:
 7921              	.LBE277:
2864:../uvc.c      ****                 prodCount = 0;
 7922              		.loc 1 2864 0
 7923 4580 B064C5E1 		strh	r6, [r5, #64]	@ movhi
2879:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7924              		.loc 1 2879 0
 7925 4584 08039FE5 		ldr	r0, .L680+96
2865:../uvc.c      ****                 consCount = 0;
 7926              		.loc 1 2865 0
 7927 4588 B264C5E1 		strh	r6, [r5, #66]	@ movhi
2879:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7928              		.loc 1 2879 0
 7929 458c 0010E0E3 		mvn	r1, #0
2861:../uvc.c      ****             	fb=0;
 7930              		.loc 1 2861 0
 7931 4590 B463C5E1 		strh	r6, [r5, #52]	@ movhi
2862:../uvc.c      ****             	pb=0;
 7932              		.loc 1 2862 0
 7933 4594 B663C5E1 		strh	r6, [r5, #54]	@ movhi
2863:../uvc.c      ****             	pbc=0;
 7934              		.loc 1 2863 0
 7935 4598 B863C5E1 		strh	r6, [r5, #56]	@ movhi
2866:../uvc.c      ****                 hitFV     = CyFalse;
 7936              		.loc 1 2866 0
 7937 459c 3C6085E5 		str	r6, [r5, #60]
2879:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7938              		.loc 1 2879 0
 7939 45a0 FEFFFFEB 		bl	_txe_mutex_get
2880:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 7940              		.loc 1 2880 0
 7941 45a4 8104D7E5 		ldrb	r0, [r7, #1153]	@ zero_extendqisi2
 7942 45a8 012020E2 		eor	r2, r0, #1
 7943 45ac 8124C7E5 		strb	r2, [r7, #1153]
2882:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 7944              		.loc 1 2882 0
 7945 45b0 3AC0D5E5 		ldrb	ip, [r5, #58]	@ zero_extendqisi2
 7946 45b4 F0005CE3 		cmp	ip, #240
 7947 45b8 1800000A 		beq	.L675
 7948              	.L606:
2890:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
 7949              		.loc 1 2890 0
 7950 45bc 3AA0D4E5 		ldrb	sl, [r4, #58]	@ zero_extendqisi2
 7951 45c0 FF005AE3 		cmp	sl, #255
 7952 45c4 4000000A 		beq	.L676
2902:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
 7953              		.loc 1 2902 0
 7954 45c8 3A00D5E5 		ldrb	r0, [r5, #58]	@ zero_extendqisi2
 7955 45cc AA0050E3 		cmp	r0, #170
 7956 45d0 2F00000A 		beq	.L677
 7957              	.L607:
2940:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
 7958              		.loc 1 2940 0
 7959 45d4 B8029FE5 		ldr	r0, .L680+96
 7960 45d8 FEFFFFEB 		bl	_txe_mutex_put
2942:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 7961              		.loc 1 2942 0
 7962 45dc C0029FE5 		ldr	r0, .L680+112
 7963 45e0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 7964              	.LVL677:
2943:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7965              		.loc 1 2943 0
 7966 45e4 002050E2 		subs	r2, r0, #0
 7967 45e8 2000001A 		bne	.L678
2950:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 7968              		.loc 1 2950 0
 7969 45ec 0210A0E1 		mov	r1, r2
 7970 45f0 AC029FE5 		ldr	r0, .L680+112
 7971              	.LVL678:
 7972 45f4 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 7973              	.LVL679:
2951:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7974              		.loc 1 2951 0
 7975 45f8 002050E2 		subs	r2, r0, #0
 7976 45fc 1200001A 		bne	.L679
2959:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 7977              		.loc 1 2959 0
 7978 4600 90029FE5 		ldr	r0, .L680+100
 7979              	.LVL680:
 7980 4604 0210A0E1 		mov	r1, r2
 7981 4608 02A0A0E3 		mov	sl, #2
 7982 460c 0020A0E1 		mov	r2, r0
 7983              	.LVL681:
 7984 4610 0130A0E1 		mov	r3, r1
 7985 4614 00A08DE5 		str	sl, [sp, #0]
 7986 4618 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 7987              	.LVL682:
 7988 461c C4FEFFEA 		b	.L605
 7989              	.L675:
2882:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 7990              		.loc 1 2882 0 discriminator 1
 7991 4620 20029FE5 		ldr	r0, .L680+20
 7992 4624 8010A0E3 		mov	r1, #128
 7993 4628 0320A0E3 		mov	r2, #3
 7994 462c B4308DE2 		add	r3, sp, #180
 7995 4630 00608DE5 		str	r6, [sp, #0]
 7996 4634 FEFFFFEB 		bl	_txe_event_flags_get
 7997 4638 000050E3 		cmp	r0, #0
2887:../uvc.c      ****                 		stiflag = 0xFF;
 7998              		.loc 1 2887 0 discriminator 1
 7999 463c 3A80C505 		streqb	r8, [r5, #58]
2888:../uvc.c      ****                 		IMcount = 0;
 8000              		.loc 1 2888 0 discriminator 1
 8001 4640 A160C505 		streqb	r6, [r5, #161]
2882:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 8002              		.loc 1 2882 0 discriminator 1
 8003 4644 E2FFFF0A 		beq	.L607
 8004 4648 DBFFFFEA 		b	.L606
 8005              	.LVL683:
 8006              	.L679:
2953:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 8007              		.loc 1 2953 0
 8008 464c 0400A0E3 		mov	r0, #4
 8009              	.LVL684:
 8010 4650 B0129FE5 		ldr	r1, .L680+212
 8011 4654 FEFFFFEB 		bl	CyU3PDebugPrint
 8012              	.LVL685:
 8013              	.L626:
 8014              	.LBB278:
 8015              	.LBB279:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8016              		.loc 1 1786 0
 8017 4658 50129FE5 		ldr	r1, .L680+124
 8018 465c 0400A0E3 		mov	r0, #4
 8019 4660 FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 8020              		.loc 1 1787 0
 8021 4664 FA0FA0E3 		mov	r0, #1000
 8022 4668 FEFFFFEB 		bl	_tx_thread_sleep
 8023 466c F9FFFFEA 		b	.L626
 8024              	.LVL686:
 8025              	.L678:
 8026              	.LBE279:
 8027              	.LBE278:
2945:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 8028              		.loc 1 2945 0
 8029 4670 0400A0E3 		mov	r0, #4
 8030              	.LVL687:
 8031 4674 90129FE5 		ldr	r1, .L680+216
 8032 4678 FEFFFFEB 		bl	CyU3PDebugPrint
 8033              	.LVL688:
 8034              	.L624:
 8035              	.LBB280:
 8036              	.LBB281:
1786:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8037              		.loc 1 1786 0
 8038 467c 2C129FE5 		ldr	r1, .L680+124
 8039 4680 0400A0E3 		mov	r0, #4
 8040 4684 FEFFFFEB 		bl	CyU3PDebugPrint
1787:../uvc.c      ****         CyU3PThreadSleep (1000);
 8041              		.loc 1 1787 0
 8042 4688 FA0FA0E3 		mov	r0, #1000
 8043 468c FEFFFFEB 		bl	_tx_thread_sleep
 8044 4690 F9FFFFEA 		b	.L624
 8045              	.L677:
 8046              	.LBE281:
 8047              	.LBE280:
2908:../uvc.c      ****                 	if(IMcount++ >= 0x3)
 8048              		.loc 1 2908 0
 8049 4694 A1E0D5E5 		ldrb	lr, [r5, #161]	@ zero_extendqisi2
 8050 4698 01A08EE2 		add	sl, lr, #1
 8051 469c 02005EE3 		cmp	lr, #2
 8052 46a0 A1A0C5E5 		strb	sl, [r5, #161]
 8053 46a4 CAFFFF9A 		bls	.L607
2910:../uvc.c      ****                     switch (setRes)
 8054              		.loc 1 2910 0
 8055 46a8 7D30D5E5 		ldrb	r3, [r5, #125]	@ zero_extendqisi2
 8056 46ac 011043E2 		sub	r1, r3, #1
 8057 46b0 030051E3 		cmp	r1, #3
 8058 46b4 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 8059 46b8 230000EA 		b	.L609
 8060              	.L614:
 8061 46bc AC470000 		.word	.L610
 8062 46c0 F0470000 		.word	.L611
 8063 46c4 58470000 		.word	.L612
 8064 46c8 FC460000 		.word	.L613
 8065              	.L676:
2892:../uvc.c      ****                  		if(IMcount++ >= 0x3){
 8066              		.loc 1 2892 0
 8067 46cc A110D5E5 		ldrb	r1, [r5, #161]	@ zero_extendqisi2
 8068 46d0 01E081E2 		add	lr, r1, #1
 8069 46d4 020051E3 		cmp	r1, #2
 8070 46d8 A1E0C5E5 		strb	lr, [r5, #161]
 8071 46dc BCFFFF9A 		bls	.L607
2893:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 8072              		.loc 1 2893 0
 8073 46e0 8124D7E5 		ldrb	r2, [r7, #1153]	@ zero_extendqisi2
2894:../uvc.c      ****                 		stiflag = 0x0F;
 8074              		.loc 1 2894 0
 8075 46e4 0F30A0E3 		mov	r3, #15
2893:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 8076              		.loc 1 2893 0
 8077 46e8 20C082E3 		orr	ip, r2, #32
 8078 46ec 81C4C7E5 		strb	ip, [r7, #1153]
2895:../uvc.c      ****                 		IMcount = 0;
 8079              		.loc 1 2895 0
 8080 46f0 A160C5E5 		strb	r6, [r5, #161]
2894:../uvc.c      ****                 		stiflag = 0x0F;
 8081              		.loc 1 2894 0
 8082 46f4 3A30C5E5 		strb	r3, [r5, #58]
 8083 46f8 B5FFFFEA 		b	.L607
 8084              	.L613:
2928:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
 8085              		.loc 1 2928 0
 8086 46fc 58E094E5 		ldr	lr, [r4, #88]
 8087 4700 8C34D7E5 		ldrb	r3, [r7, #1164]	@ zero_extendqisi2
 8088 4704 00005EE3 		cmp	lr, #0
 8089 4708 F4E0A003 		moveq	lr, #244
 8090 470c 74E0A013 		movne	lr, #116
 8091 4710 03208EE1 		orr	r2, lr, r3
 8092 4714 3010A0E3 		mov	r1, #48
 8093 4718 5230A0E3 		mov	r3, #82
 8094 471c 0100A0E3 		mov	r0, #1
 8095 4720 FEFFFFEB 		bl	SensorSetIrisControl
2930:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
 8096              		.loc 1 2930 0
 8097 4724 58C094E5 		ldr	ip, [r4, #88]
 8098 4728 8C24D7E5 		ldrb	r2, [r7, #1164]	@ zero_extendqisi2
 8099 472c 00005CE3 		cmp	ip, #0
 8100 4730 F4C0A003 		moveq	ip, #244
 8101 4734 74C0A013 		movne	ip, #116
 8102 4738 583094E5 		ldr	r3, [r4, #88]
 8103 473c 0400A0E3 		mov	r0, #4
 8104 4740 C8119FE5 		ldr	r1, .L680+220
 8105 4744 02208CE1 		orr	r2, ip, r2
 8106 4748 FEFFFFEB 		bl	CyU3PDebugPrint
 8107              	.L609:
2935:../uvc.c      ****                     IMcount = 0;
 8108              		.loc 1 2935 0
 8109 474c A160C4E5 		strb	r6, [r4, #161]
2937:../uvc.c      ****                 	stiflag = 0x0;
 8110              		.loc 1 2937 0
 8111 4750 3A60C4E5 		strb	r6, [r4, #58]
 8112 4754 9EFFFFEA 		b	.L607
 8113              	.L612:
2923:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
 8114              		.loc 1 2923 0
 8115 4758 580094E5 		ldr	r0, [r4, #88]
 8116 475c 8CA4D7E5 		ldrb	sl, [r7, #1164]	@ zero_extendqisi2
 8117 4760 000050E3 		cmp	r0, #0
 8118 4764 C400A003 		moveq	r0, #196
 8119 4768 4400A013 		movne	r0, #68
 8120 476c 0A2080E1 		orr	r2, r0, sl
 8121 4770 3010A0E3 		mov	r1, #48
 8122 4774 5230A0E3 		mov	r3, #82
 8123 4778 0100A0E3 		mov	r0, #1
 8124 477c FEFFFFEB 		bl	SensorSetIrisControl
2925:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
 8125              		.loc 1 2925 0
 8126 4780 582094E5 		ldr	r2, [r4, #88]
 8127 4784 8CC4D7E5 		ldrb	ip, [r7, #1164]	@ zero_extendqisi2
 8128 4788 000052E3 		cmp	r2, #0
 8129 478c C420A003 		moveq	r2, #196
 8130 4790 4420A013 		movne	r2, #68
 8131 4794 583094E5 		ldr	r3, [r4, #88]
 8132 4798 70119FE5 		ldr	r1, .L680+220
 8133 479c 0C2082E1 		orr	r2, r2, ip
 8134 47a0 0400A0E3 		mov	r0, #4
 8135 47a4 FEFFFFEB 		bl	CyU3PDebugPrint
2926:../uvc.c      ****                  		break;
 8136              		.loc 1 2926 0
 8137 47a8 E7FFFFEA 		b	.L609
 8138              	.L610:
2913:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
 8139              		.loc 1 2913 0
 8140 47ac 582094E5 		ldr	r2, [r4, #88]
 8141 47b0 3010A0E3 		mov	r1, #48
 8142 47b4 000052E3 		cmp	r2, #0
 8143 47b8 E420A003 		moveq	r2, #228
 8144 47bc 6420A013 		movne	r2, #100
 8145 47c0 5230A0E3 		mov	r3, #82
 8146 47c4 0100A0E3 		mov	r0, #1
 8147 47c8 FEFFFFEB 		bl	SensorSetIrisControl
2915:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
 8148              		.loc 1 2915 0
 8149 47cc 582094E5 		ldr	r2, [r4, #88]
 8150 47d0 38119FE5 		ldr	r1, .L680+220
 8151 47d4 000052E3 		cmp	r2, #0
 8152 47d8 583094E5 		ldr	r3, [r4, #88]
 8153 47dc E420A003 		moveq	r2, #228
 8154 47e0 6420A013 		movne	r2, #100
 8155 47e4 0400A0E3 		mov	r0, #4
 8156 47e8 FEFFFFEB 		bl	CyU3PDebugPrint
2916:../uvc.c      ****                  		break;
 8157              		.loc 1 2916 0
 8158 47ec D6FFFFEA 		b	.L609
 8159              	.L611:
2918:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
 8160              		.loc 1 2918 0
 8161 47f0 582094E5 		ldr	r2, [r4, #88]
 8162 47f4 3010A0E3 		mov	r1, #48
 8163 47f8 000052E3 		cmp	r2, #0
 8164 47fc D420A003 		moveq	r2, #212
 8165 4800 5420A013 		movne	r2, #84
 8166 4804 5230A0E3 		mov	r3, #82
 8167 4808 0100A0E3 		mov	r0, #1
 8168 480c FEFFFFEB 		bl	SensorSetIrisControl
2920:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
 8169              		.loc 1 2920 0
 8170 4810 582094E5 		ldr	r2, [r4, #88]
 8171 4814 F4109FE5 		ldr	r1, .L680+220
 8172 4818 000052E3 		cmp	r2, #0
 8173 481c 583094E5 		ldr	r3, [r4, #88]
 8174 4820 D420A003 		moveq	r2, #212
 8175 4824 5420A013 		movne	r2, #84
 8176 4828 0400A0E3 		mov	r0, #4
 8177 482c FEFFFFEB 		bl	CyU3PDebugPrint
2921:../uvc.c      ****                  		break;
 8178              		.loc 1 2921 0
 8179 4830 C5FFFFEA 		b	.L609
 8180              	.L681:
 8181              		.align	2
 8182              	.L680:
 8183 4834 10080000 		.word	.LC45
 8184 4838 00C20100 		.word	115200
 8185 483c 30080000 		.word	.LC46
 8186 4840 A0860100 		.word	100000
 8187 4844 4C080000 		.word	.LC47
 8188 4848 00000000 		.word	.LANCHOR0
 8189 484c 00000000 		.word	CyFxGpifCB
 8190 4850 88130000 		.word	5000
 8191 4854 00000000 		.word	CyFxUVCApplnUSBSetupCB
 8192 4858 00000000 		.word	CyFxUVCApplnUSBEventCB
 8193 485c 00000000 		.word	CyFxUSBDeviceDscr
 8194 4860 00000000 		.word	CyFxUSBDeviceDscrSS
 8195 4864 00000000 		.word	CyFxUSBDeviceQualDscr
 8196 4868 00000000 		.word	CyFxUSBBOSDscr
 8197 486c 00000000 		.word	CyFxUSBHSConfigDscr
 8198 4870 00000000 		.word	CyFxUSBFSConfigDscr
 8199 4874 00000000 		.word	CyFxUSBSSConfigDscr
 8200 4878 00000000 		.word	CyFxUSBStringLangIDDscr
 8201 487c 00000000 		.word	CyFxUSBManufactureDscr
 8202 4880 00000000 		.word	CyFxUSBProductDscr
 8203 4884 013F0000 		.word	16129
 8204 4888 02030000 		.word	770
 8205 488c 00000000 		.word	glChHandleInterStat
 8206 4890 00000000 		.word	glInterStaBuffer
 8207 4894 00000000 		.word	imgHdMux
 8208 4898 01010000 		.word	257
 8209 489c 03030000 		.word	771
 8210 48a0 00000000 		.word	CyFxUvcApplnDmaCallback
 8211 48a4 00000000 		.word	glChHandleUVCStream
 8212 48a8 00000000 		.word	.LANCHOR1
 8213 48ac 68080000 		.word	.LC48
 8214 48b0 D8010000 		.word	.LC12
 8215 48b4 B8080000 		.word	.LC50
 8216 48b8 94080000 		.word	.LC49
 8217 48bc E0080000 		.word	.LC51
 8218 48c0 380A0000 		.word	.LC58
 8219 48c4 140B0000 		.word	.LC62
 8220 48c8 E40A0000 		.word	.LC61
 8221 48cc AC0A0000 		.word	.LC60
 8222 48d0 6C0A0000 		.word	.LC59
 8223 48d4 040C0000 		.word	.LC68
 8224 48d8 FC000000 		.word	.LANCHOR2+252
 8225 48dc 4C0C0000 		.word	.LC70
 8226 48e0 F40B0000 		.word	.LC67
 8227 48e4 E0000000 		.word	.LANCHOR2+224
 8228 48e8 140C0000 		.word	.LC69
 8229 48ec C00B0000 		.word	.LC66
 8230 48f0 080A0000 		.word	.LC57
 8231 48f4 D8090000 		.word	.LC56
 8232 48f8 A0090000 		.word	.LC55
 8233 48fc 38090000 		.word	.LC53
 8234 4900 0C090000 		.word	.LC52
 8235 4904 6C090000 		.word	.LC54
 8236 4908 8C0B0000 		.word	.LC65
 8237 490c 600B0000 		.word	.LC64
 8238 4910 3C0B0000 		.word	.LC63
 8239              		.cfi_endproc
 8240              	.LFE19:
 8242              		.align	2
 8243              		.global	CyFxApplicationDefine
 8245              	CyFxApplicationDefine:
 8246              	.LFB27:
4367:../uvc.c      **** }
4368:../uvc.c      **** 
4369:../uvc.c      **** 
4370:../uvc.c      **** /*
4371:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
4372:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
4373:../uvc.c      ****  */
4374:../uvc.c      **** void
4375:../uvc.c      **** CyFxApplicationDefine (
4376:../uvc.c      ****         void)
4377:../uvc.c      **** {
 8247              		.loc 1 4377 0
 8248              		.cfi_startproc
 8249              		@ args = 0, pretend = 0, frame = 40
 8250              		@ frame_needed = 0, uses_anonymous_args = 0
 8251              	.LVL689:
 8252 4914 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8253              	.LCFI27:
 8254              		.cfi_def_cfa_offset 36
4378:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
4379:../uvc.c      ****     uint32_t retThrdCreate;
4380:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4381:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4382:../uvc.c      **** 
4383:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
4384:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 8255              		.loc 1 4384 0
 8256 4918 010AA0E3 		mov	r0, #4096
4377:../uvc.c      **** {
 8257              		.loc 1 4377 0
 8258 491c 4CD04DE2 		sub	sp, sp, #76
 8259              	.LCFI28:
 8260              		.cfi_def_cfa_offset 112
 8261              		.loc 1 4384 0
 8262              		.cfi_offset 14, -4
 8263              		.cfi_offset 11, -8
 8264              		.cfi_offset 10, -12
 8265              		.cfi_offset 9, -16
 8266              		.cfi_offset 8, -20
 8267              		.cfi_offset 7, -24
 8268              		.cfi_offset 6, -28
 8269              		.cfi_offset 5, -32
 8270              		.cfi_offset 4, -36
 8271 4920 FEFFFFEB 		bl	CyU3PMemAlloc
 8272 4924 00A0A0E1 		mov	sl, r0
 8273              	.LVL690:
4385:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 8274              		.loc 1 4385 0
 8275 4928 010AA0E3 		mov	r0, #4096
 8276              	.LVL691:
 8277 492c FEFFFFEB 		bl	CyU3PMemAlloc
 8278 4930 00B0A0E1 		mov	fp, r0
 8279              	.LVL692:
4386:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 8280              		.loc 1 4386 0
 8281 4934 010AA0E3 		mov	r0, #4096
 8282              	.LVL693:
 8283 4938 FEFFFFEB 		bl	CyU3PMemAlloc
4387:../uvc.c      **** 
4388:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 8284              		.loc 1 4388 0
 8285 493c 00005AE3 		cmp	sl, #0
 8286 4940 00005B13 		cmpne	fp, #0
 8287 4944 0090A013 		movne	r9, #0
 8288 4948 0190A003 		moveq	r9, #1
4386:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 8289              		.loc 1 4386 0
 8290 494c 24008DE5 		str	r0, [sp, #36]
 8291              	.LVL694:
 8292              		.loc 1 4388 0
 8293 4950 0000001A 		bne	.L686
 8294              	.LVL695:
 8295              	.L683:
 8296              	.L685:
 8297 4954 FEFFFFEA 		b	.L685
 8298              	.L686:
 8299              		.loc 1 4388 0 is_stmt 0 discriminator 1
 8300 4958 000050E3 		cmp	r0, #0
 8301 495c FCFFFF0A 		beq	.L683
4389:../uvc.c      ****         goto fatalErrorHandler;
4390:../uvc.c      **** 
4391:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
4392:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 8302              		.loc 1 4392 0 is_stmt 1
 8303 4960 28408DE2 		add	r4, sp, #40
 8304 4964 0400A0E1 		mov	r0, r4
 8305 4968 4010A0E3 		mov	r1, #64
 8306 496c 18219FE5 		ldr	r2, .L687
 8307 4970 FEFFFFEB 		bl	cmdbufCreate
 8308 4974 0450A0E1 		mov	r5, r4
 8309 4978 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 8310 497c 0C719FE5 		ldr	r7, .L687+4
4393:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 8311              		.loc 1 4393 0
 8312 4980 0C819FE5 		ldr	r8, .L687+8
4392:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 8313              		.loc 1 4392 0
 8314 4984 07C0A0E1 		mov	ip, r7
 8315 4988 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 8316 498c 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
4394:../uvc.c      **** 
4395:../uvc.c      **** 	/****** initialize command descriptor ***********/
4396:../uvc.c      **** 	cmdquInit(cmdQuptr);
4397:../uvc.c      **** 	cmdquInit(statQuptr);
4398:../uvc.c      **** 
4399:../uvc.c      ****     /* Create the UVC application thread. */
4400:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 8317              		.loc 1 4400 0
 8318 4990 0860A0E3 		mov	r6, #8
4392:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 8319              		.loc 1 4392 0
 8320 4994 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
4393:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 8321              		.loc 1 4393 0
 8322 4998 F8209FE5 		ldr	r2, .L687+12
 8323 499c 0400A0E1 		mov	r0, r4
 8324 49a0 2010A0E3 		mov	r1, #32
 8325 49a4 FEFFFFEB 		bl	cmdbufCreate
 8326 49a8 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 8327 49ac 08C0A0E1 		mov	ip, r8
 8328 49b0 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 8329 49b4 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 8330              		.loc 1 4400 0
 8331 49b8 0140A0E3 		mov	r4, #1
4393:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 8332              		.loc 1 4393 0
 8333 49bc 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
4396:../uvc.c      **** 	cmdquInit(cmdQuptr);
 8334              		.loc 1 4396 0
 8335 49c0 0700A0E1 		mov	r0, r7
 8336 49c4 FEFFFFEB 		bl	cmdquInit
4397:../uvc.c      **** 	cmdquInit(statQuptr);
 8337              		.loc 1 4397 0
 8338 49c8 0800A0E1 		mov	r0, r8
 8339 49cc FEFFFFEB 		bl	cmdquInit
 8340              		.loc 1 4400 0
 8341 49d0 A850A0E3 		mov	r5, #168
 8342 49d4 01CAA0E3 		mov	ip, #4096
 8343 49d8 BC009FE5 		ldr	r0, .L687+16
 8344 49dc BC109FE5 		ldr	r1, .L687+20
 8345 49e0 BC209FE5 		ldr	r2, .L687+24
 8346 49e4 0930A0E1 		mov	r3, r9
 8347 49e8 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 8348 49ec 08608DE5 		str	r6, [sp, #8]
 8349 49f0 0C608DE5 		str	r6, [sp, #12]
 8350 49f4 10908DE5 		str	r9, [sp, #16]
 8351 49f8 14408DE5 		str	r4, [sp, #20]
 8352 49fc 18508DE5 		str	r5, [sp, #24]
 8353 4a00 FEFFFFEB 		bl	_txe_thread_create
 8354              	.LVL696:
4401:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
4402:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
4403:../uvc.c      ****             0,                                          /* No input parameter to thread */
4404:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
4405:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
4406:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4407:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
4408:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4409:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4410:../uvc.c      ****             );
4411:../uvc.c      ****     if (retThrdCreate != 0)
 8355              		.loc 1 4411 0
 8356 4a04 00C050E2 		subs	ip, r0, #0
 8357 4a08 D1FFFF1A 		bne	.L683
4412:../uvc.c      ****     {
4413:../uvc.c      ****         goto fatalErrorHandler;
4414:../uvc.c      ****     }
4415:../uvc.c      **** 
4416:../uvc.c      ****     /* Create the control request handling thread. */
4417:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 8358              		.loc 1 4417 0
 8359 4a0c 0C30A0E1 		mov	r3, ip
 8360 4a10 027BA0E3 		mov	r7, #2048
 8361 4a14 8C009FE5 		ldr	r0, .L687+28
 8362              	.LVL697:
 8363 4a18 8C109FE5 		ldr	r1, .L687+32
 8364 4a1c 8C209FE5 		ldr	r2, .L687+36
 8365 4a20 10C08DE5 		str	ip, [sp, #16]
 8366 4a24 00B08DE5 		str	fp, [sp, #0]
 8367 4a28 04708DE5 		str	r7, [sp, #4]
 8368 4a2c 08608DE5 		str	r6, [sp, #8]
 8369 4a30 0C608DE5 		str	r6, [sp, #12]
 8370 4a34 14408DE5 		str	r4, [sp, #20]
 8371 4a38 18508DE5 		str	r5, [sp, #24]
 8372 4a3c FEFFFFEB 		bl	_txe_thread_create
 8373              	.LVL698:
4418:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
4419:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
4420:../uvc.c      ****             0,                                                  /* No input parameter to thread */
4421:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
4422:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
4423:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
4424:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
4425:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
4426:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
4427:../uvc.c      ****             );
4428:../uvc.c      ****     if (retThrdCreate != 0)
 8374              		.loc 1 4428 0
 8375 4a40 00C050E2 		subs	ip, r0, #0
 8376 4a44 C2FFFF1A 		bne	.L683
4429:../uvc.c      ****     {
4430:../uvc.c      ****         goto fatalErrorHandler;
4431:../uvc.c      ****     }
4432:../uvc.c      **** #if 1
4433:../uvc.c      ****     /* Create the I2C control command handling thread. */
4434:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 8377              		.loc 1 4434 0
 8378 4a48 24E09DE5 		ldr	lr, [sp, #36]
 8379 4a4c 60009FE5 		ldr	r0, .L687+40
 8380              	.LVL699:
 8381 4a50 60109FE5 		ldr	r1, .L687+44
 8382 4a54 60209FE5 		ldr	r2, .L687+48
 8383 4a58 0C30A0E1 		mov	r3, ip
 8384 4a5c 00E08DE5 		str	lr, [sp, #0]
 8385 4a60 04708DE5 		str	r7, [sp, #4]
 8386 4a64 08608DE5 		str	r6, [sp, #8]
 8387 4a68 0C608DE5 		str	r6, [sp, #12]
 8388 4a6c 10C08DE5 		str	ip, [sp, #16]
 8389 4a70 14408DE5 		str	r4, [sp, #20]
 8390 4a74 18508DE5 		str	r5, [sp, #24]
 8391 4a78 FEFFFFEB 		bl	_txe_thread_create
 8392              	.LVL700:
4435:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
4436:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
4437:../uvc.c      ****             0,                                          /* No input parameter to thread */
4438:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
4439:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
4440:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4441:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
4442:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4443:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4444:../uvc.c      ****             );
4445:../uvc.c      ****     if (retThrdCreate != 0)
 8393              		.loc 1 4445 0
 8394 4a7c 000050E3 		cmp	r0, #0
 8395 4a80 B3FFFF1A 		bne	.L683
4446:../uvc.c      ****     {
4447:../uvc.c      ****         goto fatalErrorHandler;
4448:../uvc.c      ****     }
4449:../uvc.c      **** #endif
4450:../uvc.c      **** 
4451:../uvc.c      ****     return;
4452:../uvc.c      **** 
4453:../uvc.c      **** fatalErrorHandler:
4454:../uvc.c      ****     /* Add custom recovery or debug actions here */
4455:../uvc.c      ****     /* Loop indefinitely */
4456:../uvc.c      ****     while (1);
4457:../uvc.c      **** }
 8396              		.loc 1 4457 0
 8397 4a84 4CD08DE2 		add	sp, sp, #76
 8398 4a88 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8399              	.L688:
 8400              		.align	2
 8401              	.L687:
 8402 4a8c 00000000 		.word	cmdQuMux
 8403 4a90 00000000 		.word	cmdQu
 8404 4a94 00000000 		.word	statQu
 8405 4a98 00000000 		.word	staQuMux
 8406 4a9c A4000000 		.word	.LANCHOR0+164
 8407 4aa0 840C0000 		.word	.LC71
 8408 4aa4 00000000 		.word	UVCAppThread_Entry
 8409 4aa8 4C010000 		.word	.LANCHOR0+332
 8410 4aac 980C0000 		.word	.LC72
 8411 4ab0 00000000 		.word	UVCAppEP0Thread_Entry
 8412 4ab4 F4010000 		.word	.LANCHOR0+500
 8413 4ab8 B00C0000 		.word	.LC73
 8414 4abc 00000000 		.word	I2cAppThread_Entry
 8415              		.cfi_endproc
 8416              	.LFE27:
 8418              		.align	2
 8419              		.global	main
 8421              	main:
 8422              	.LFB28:
4458:../uvc.c      **** 
4459:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
4460:../uvc.c      ****  * the ThreadX RTOS here.
4461:../uvc.c      ****  */
4462:../uvc.c      **** int
4463:../uvc.c      **** main (
4464:../uvc.c      ****         void)
4465:../uvc.c      **** {
 8423              		.loc 1 4465 0
 8424              		.cfi_startproc
 8425              		@ args = 0, pretend = 0, frame = 56
 8426              		@ frame_needed = 0, uses_anonymous_args = 0
 8427 4ac0 30402DE9 		stmfd	sp!, {r4, r5, lr}
 8428              	.LCFI29:
 8429              		.cfi_def_cfa_offset 12
4466:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4467:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
4468:../uvc.c      **** 
4469:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
4470:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
4471:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
4472:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
4473:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
4474:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 8430              		.loc 1 4474 0
 8431 4ac4 0010A0E3 		mov	r1, #0
4465:../uvc.c      **** {
 8432              		.loc 1 4465 0
 8433 4ac8 3CD04DE2 		sub	sp, sp, #60
 8434              	.LCFI30:
 8435              		.cfi_def_cfa_offset 72
4471:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 8436              		.loc 1 4471 0
 8437 4acc 0220A0E3 		mov	r2, #2
4475:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 8438              		.loc 1 4475 0
 8439 4ad0 033081E2 		add	r3, r1, #3
4470:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 8440              		.loc 1 4470 0
 8441 4ad4 0150A0E3 		mov	r5, #1
 8442              		.cfi_offset 14, -4
 8443              		.cfi_offset 5, -8
 8444              		.cfi_offset 4, -12
4476:../uvc.c      **** 
4477:../uvc.c      ****     /* Initialize the device */
4478:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 8445              		.loc 1 4478 0
 8446 4ad8 28008DE2 		add	r0, sp, #40
4470:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 8447              		.loc 1 4470 0
 8448 4adc 28508DE5 		str	r5, [sp, #40]
4471:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 8449              		.loc 1 4471 0
 8450 4ae0 2C20CDE5 		strb	r2, [sp, #44]
4472:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 8451              		.loc 1 4472 0
 8452 4ae4 2D20CDE5 		strb	r2, [sp, #45]
4473:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 8453              		.loc 1 4473 0
 8454 4ae8 2E20CDE5 		strb	r2, [sp, #46]
4474:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 8455              		.loc 1 4474 0
 8456 4aec 30108DE5 		str	r1, [sp, #48]
4475:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 8457              		.loc 1 4475 0
 8458 4af0 3430CDE5 		strb	r3, [sp, #52]
 8459              		.loc 1 4478 0
 8460 4af4 FEFFFFEB 		bl	CyU3PDeviceInit
 8461              	.LVL701:
4479:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8462              		.loc 1 4479 0
 8463 4af8 004050E2 		subs	r4, r0, #0
 8464 4afc 0000000A 		beq	.L692
 8465              	.L690:
 8466              	.L691:
 8467 4b00 FEFFFFEA 		b	.L691
 8468              	.L692:
4480:../uvc.c      ****     {
4481:../uvc.c      ****         goto handle_fatal_error;
4482:../uvc.c      ****     }
4483:../uvc.c      **** 
4484:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
4485:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 8469              		.loc 1 4485 0
 8470 4b04 0410A0E1 		mov	r1, r4
 8471 4b08 0420A0E1 		mov	r2, r4
 8472 4b0c 0500A0E1 		mov	r0, r5
 8473              	.LVL702:
 8474 4b10 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 8475              	.LVL703:
4486:../uvc.c      **** 
4487:../uvc.c      ****     /* Configure the IO matrix for the device. */
4488:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
4489:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
4490:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
4491:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
4492:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
4493:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
4494:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
4495:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
4496:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
4497:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
4498:../uvc.c      **** 
4499:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 8476              		.loc 1 4499 0
 8477 4b14 0D00A0E1 		mov	r0, sp
4489:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 8478              		.loc 1 4489 0
 8479 4b18 1640CDE5 		strb	r4, [sp, #22]
4490:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 8480              		.loc 1 4490 0
 8481 4b1c 18408DE5 		str	r4, [sp, #24]
4491:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 8482              		.loc 1 4491 0
 8483 4b20 1C408DE5 		str	r4, [sp, #28]
4492:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 8484              		.loc 1 4492 0
 8485 4b24 20408DE5 		str	r4, [sp, #32]
4493:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 8486              		.loc 1 4493 0
 8487 4b28 24408DE5 		str	r4, [sp, #36]
4496:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 8488              		.loc 1 4496 0
 8489 4b2c 0C408DE5 		str	r4, [sp, #12]
4497:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 8490              		.loc 1 4497 0
 8491 4b30 10408DE5 		str	r4, [sp, #16]
4488:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 8492              		.loc 1 4488 0
 8493 4b34 00508DE5 		str	r5, [sp, #0]
4494:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 8494              		.loc 1 4494 0
 8495 4b38 04508DE5 		str	r5, [sp, #4]
4495:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 8496              		.loc 1 4495 0
 8497 4b3c 08508DE5 		str	r5, [sp, #8]
 8498              		.loc 1 4499 0
 8499 4b40 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 8500              	.LVL704:
4500:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8501              		.loc 1 4500 0
 8502 4b44 004050E2 		subs	r4, r0, #0
 8503 4b48 ECFFFF1A 		bne	.L690
4501:../uvc.c      ****     {
4502:../uvc.c      ****         goto handle_fatal_error;
4503:../uvc.c      ****     }
4504:../uvc.c      **** 
4505:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
4506:../uvc.c      ****     CyU3PKernelEntry ();
 8504              		.loc 1 4506 0
 8505 4b4c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 8506              	.LVL705:
4507:../uvc.c      **** 
4508:../uvc.c      ****     /* Dummy return to make the compiler happy */
4509:../uvc.c      ****     return 0;
4510:../uvc.c      **** 
4511:../uvc.c      **** handle_fatal_error:
4512:../uvc.c      ****     /* Cannot recover from this error. */
4513:../uvc.c      ****     while (1);
4514:../uvc.c      **** }
 8507              		.loc 1 4514 0
 8508 4b50 0400A0E1 		mov	r0, r4
 8509 4b54 3CD08DE2 		add	sp, sp, #60
 8510 4b58 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 8511              		.cfi_endproc
 8512              	.LFE28:
 8514              		.global	CyFxGpifTransition
 8515              		.global	CyFxGpifWavedata
 8516              		.global	CyFxGpifWavedataPosition
 8517              		.global	CyFxGpifRegValue
 8518              		.global	CyFxGpifConfig
 8519              		.global	CyFxGpifTransition_usb2
 8520              		.global	CyFxGpifWavedata_usb2
 8521              		.global	CyFxGpifWavedataPosition_usb2
 8522              		.global	CyFxGpifRegValue_usb2
 8523              		.global	CyFxGpifConfig_usb2
 8524              		.global	snapButFlag
 8525              		.global	testSnap
 8526              		.global	fb
 8527              		.global	pb
 8528              		.global	pbc
 8529              		.global	fbbak
 8530              		.global	pbbak
 8531              		.global	pbcbak
 8532              		.global	pbcpbak
 8533              		.global	isUsbConnected
 8534              		.global	usbSpeed
 8535              		.global	clearFeatureRqtReceived
 8536              		.global	streamingStarted
 8537              		.global	glProbeCtrl
 8538              		.global	glProbeCtrlFull
 8539              		.global	glProbeStilCtrl
 8540              		.global	glProbeCtrl20
 8541              		.global	glProbeStilCtrl20
 8542              		.global	glUVCHeader
 8543              		.comm	glChHandleUVCStream,220,4
 8544              		.comm	glChHandleStillStream,220,4
 8545              		.comm	glChHandleInterStat,160,4
 8546              		.comm	glInterStaBuffer,4,4
 8547              		.comm	cmdQu,32,4
 8548              		.comm	statQu,32,4
 8549              		.comm	cmdQuMux,56,4
 8550              		.comm	staQuMux,56,4
 8551              		.comm	timMux,56,4
 8552              		.comm	imgHdMux,56,4
 8553              		.comm	bmReqType,1,1
 8554              		.comm	bRequest,1,1
 8555              		.comm	wValue,2,2
 8556              		.comm	wIndex,2,2
 8557              		.comm	wLength,2,2
 8558              		.comm	posTick,4,4
 8559              		.comm	I2CCmdTimer,44,4
 8560              		.section	.rodata
 8561              		.align	2
 8562              		.set	.LANCHOR2,. + 0
 8565              	ShutSp:
 8566 0000 3582     		.short	-32203
 8567 0002 1B41     		.short	16667
 8568 0004 8D20     		.short	8333
 8569 0006 A00F     		.short	4000
 8570 0008 D007     		.short	2000
 8571 000a E803     		.short	1000
 8572 000c F401     		.short	500
 8573 000e C800     		.short	200
 8574 0010 6400     		.short	100
 8575 0012 0A00     		.short	10
 8576 0014 0000     		.short	0
 8577 0016 00000000 		.space	10
 8577      00000000 
 8577      0000
 8580              	pEXTSenCtrl:
 8581 0020 90040000 		.word	EXTShutter
 8582 0024 00000000 		.word	0
 8583 0028 00000000 		.word	0
 8584 002c 00000000 		.word	0
 8585 0030 00000000 		.word	0
 8586 0034 00000000 		.word	0
 8587 0038 00000000 		.word	0
 8588 003c 00000000 		.word	0
 8589 0040 00000000 		.word	0
 8590 0044 B8040000 		.word	EXTAexModGainlev
 8591 0048 00000000 		.word	0
 8592 004c A4040000 		.word	EXTShutlev
 8593 0050 00000000 		.word	0
 8594 0054 00000000 		.word	0
 8595 0058 00000000 		.word	0
 8596 005c 00000000 		.word	0
 8597 0060 00000000 		.word	0
 8598 0064 00000000 		.word	0
 8599 0068 00000000 		.word	0
 8600 006c 00000000 		.word	0
 8601 0070 D0040000 		.word	EXTBLCWinPos
 8602 0074 E4040000 		.word	EXTBLCWeight
 8603 0078 00000000 		.word	0
 8604 007c 00000000 		.word	0
 8605 0080 00000000 		.space	32
 8605      00000000 
 8605      00000000 
 8605      00000000 
 8605      00000000 
 8608              	pPUCSenCtrl:
 8609 00a0 F8040000 		.word	PUCBLC
 8610 00a4 00000000 		.word	0
 8611 00a8 00000000 		.word	0
 8612 00ac 00000000 		.word	0
 8613 00b0 00000000 		.word	0
 8614 00b4 00000000 		.word	0
 8615 00b8 00000000 		.word	0
 8616 00bc 0C050000 		.word	PUCSharp
 8617 00c0 00000000 		.word	0
 8618 00c4 00000000 		.word	0
 8619 00c8 00000000 		.word	0
 8620 00cc 00000000 		.word	0
 8621 00d0 00000000 		.word	0
 8622 00d4 00000000 		.word	0
 8623 00d8 00000000 		.word	0
 8624 00dc 00000000 		.word	0
 8627              	CyFxGpifConfig:
 8628 00e0 0F00     		.short	15
 8629 00e2 0000     		.space	2
 8630 00e4 00000000 		.word	CyFxGpifWavedata
 8631 00e8 00000000 		.word	CyFxGpifWavedataPosition
 8632 00ec 0500     		.short	5
 8633 00ee 0000     		.space	2
 8634 00f0 00000000 		.word	CyFxGpifTransition
 8635 00f4 4C00     		.short	76
 8636 00f6 0000     		.space	2
 8637 00f8 00000000 		.word	CyFxGpifRegValue
 8640              	CyFxGpifConfig_usb2:
 8641 00fc 9300     		.short	147
 8642 00fe 0000     		.space	2
 8643 0100 00000000 		.word	CyFxGpifWavedata_usb2
 8644 0104 00000000 		.word	CyFxGpifWavedataPosition_usb2
 8645 0108 0800     		.short	8
 8646 010a 0000     		.space	2
 8647 010c 00000000 		.word	CyFxGpifTransition_usb2
 8648 0110 4C00     		.short	76
 8649 0112 0000     		.space	2
 8650 0114 00000000 		.word	CyFxGpifRegValue_usb2
 8651              		.data
 8652              		.align	2
 8653              		.set	.LANCHOR1,. + 0
 8656              	ExUCtrlParArry:
 8657 0000 00       		.byte	0
 8658 0001 00       		.byte	0
 8659 0002 04       		.byte	4
 8660 0003 01       		.byte	1
 8661 0004 00       		.byte	0
 8662 0005 38       		.byte	56
 8663 0006 01       		.byte	1
 8664 0007 01       		.byte	1
 8665 0008 00       		.byte	0
 8666 0009 03       		.byte	3
 8667 000a 00       		.byte	0
 8668 000b 4E       		.byte	78
 8669 000c 00       		.byte	0
 8670 000d 4E       		.byte	78
 8671 000e 00       		.byte	0
 8672 000f 30       		.byte	48
 8673 0010 01       		.byte	1
 8674 0011 00       		.byte	0
 8675 0012 00       		.byte	0
 8676 0013 00000000 		.space	5
 8676      00
 8677 0018 00       		.byte	0
 8678 0019 00       		.byte	0
 8679 001a 01       		.byte	1
 8680 001b 00       		.byte	0
 8681 001c 00       		.byte	0
 8682 001d 00       		.byte	0
 8683 001e 00       		.byte	0
 8684 001f 01       		.byte	1
 8685 0020 00       		.byte	0
 8686 0021 03       		.byte	3
 8687 0022 00       		.byte	0
 8688 0023 00       		.byte	0
 8689 0024 00       		.byte	0
 8690 0025 00       		.byte	0
 8691 0026 00       		.byte	0
 8692 0027 30       		.byte	48
 8693 0028 01       		.byte	1
 8694 0029 00       		.byte	0
 8695 002a 00       		.byte	0
 8696 002b 00000000 		.space	5
 8696      00
 8697 0030 00       		.byte	0
 8698 0031 00       		.byte	0
 8699 0032 02       		.byte	2
 8700 0033 00       		.byte	0
 8701 0034 00       		.byte	0
 8702 0035 FF       		.byte	-1
 8703 0036 00       		.byte	0
 8704 0037 01       		.byte	1
 8705 0038 00       		.byte	0
 8706 0039 03       		.byte	3
 8707 003a 00       		.byte	0
 8708 003b 01       		.byte	1
 8709 003c 00       		.byte	0
 8710 003d 00       		.byte	0
 8711 003e 00       		.byte	0
 8712 003f 30       		.byte	48
 8713 0040 01       		.byte	1
 8714 0041 01       		.byte	1
 8715 0042 00       		.byte	0
 8716 0043 00000000 		.space	5
 8716      00
 8717 0048 00       		.byte	0
 8718 0049 00       		.byte	0
 8719 004a 02       		.byte	2
 8720 004b 00       		.byte	0
 8721 004c 00       		.byte	0
 8722 004d 00       		.byte	0
 8723 004e 00       		.byte	0
 8724 004f 00       		.byte	0
 8725 0050 00       		.byte	0
 8726 0051 03       		.byte	3
 8727 0052 00       		.byte	0
 8728 0053 00       		.byte	0
 8729 0054 00       		.byte	0
 8730 0055 00       		.byte	0
 8731 0056 00       		.byte	0
 8732 0057 30       		.byte	48
 8733 0058 01       		.byte	1
 8734 0059 01       		.byte	1
 8735 005a 00       		.byte	0
 8736 005b 00000000 		.space	5
 8736      00
 8737 0060 13       		.byte	19
 8738 0061 14       		.byte	20
 8739 0062 02       		.byte	2
 8740 0063 00       		.byte	0
 8741 0064 00       		.byte	0
 8742 0065 FF       		.byte	-1
 8743 0066 FF       		.byte	-1
 8744 0067 01       		.byte	1
 8745 0068 00       		.byte	0
 8746 0069 03       		.byte	3
 8747 006a 00       		.byte	0
 8748 006b 22       		.byte	34
 8749 006c 22       		.byte	34
 8750 006d 22       		.byte	34
 8751 006e 22       		.byte	34
 8752 006f 30       		.byte	48
 8753 0070 01       		.byte	1
 8754 0071 00       		.byte	0
 8755 0072 00       		.byte	0
 8756 0073 00000000 		.space	5
 8756      00
 8757 0078 11       		.byte	17
 8758 0079 00       		.byte	0
 8759 007a 02       		.byte	2
 8760 007b 01       		.byte	1
 8761 007c 00       		.byte	0
 8762 007d 03       		.byte	3
 8763 007e 00       		.byte	0
 8764 007f 01       		.byte	1
 8765 0080 00       		.byte	0
 8766 0081 03       		.byte	3
 8767 0082 00       		.byte	0
 8768 0083 80       		.byte	-128
 8769 0084 00       		.byte	0
 8770 0085 80       		.byte	-128
 8771 0086 00       		.byte	0
 8772 0087 30       		.byte	48
 8773 0088 01       		.byte	1
 8774 0089 01       		.byte	1
 8775 008a 00       		.byte	0
 8776 008b 00000000 		.space	5
 8776      00
 8777 0090 17       		.byte	23
 8778 0091 00       		.byte	0
 8779 0092 01       		.byte	1
 8780 0093 01       		.byte	1
 8781 0094 00       		.byte	0
 8782 0095 02       		.byte	2
 8783 0096 00       		.byte	0
 8784 0097 01       		.byte	1
 8785 0098 00       		.byte	0
 8786 0099 03       		.byte	3
 8787 009a 00       		.byte	0
 8788 009b 00       		.byte	0
 8789 009c 00       		.byte	0
 8790 009d 00       		.byte	0
 8791 009e 00       		.byte	0
 8792 009f 30       		.byte	48
 8793 00a0 01       		.byte	1
 8794 00a1 01       		.byte	1
 8795 00a2 00       		.byte	0
 8796 00a3 00000000 		.space	5
 8796      00
 8797 00a8 00       		.byte	0
 8798 00a9 00       		.byte	0
 8799 00aa 04       		.byte	4
 8800 00ab 01       		.byte	1
 8801 00ac 00       		.byte	0
 8802 00ad 38       		.byte	56
 8803 00ae 01       		.byte	1
 8804 00af 01       		.byte	1
 8805 00b0 00       		.byte	0
 8806 00b1 03       		.byte	3
 8807 00b2 00       		.byte	0
 8808 00b3 4E       		.byte	78
 8809 00b4 00       		.byte	0
 8810 00b5 4E       		.byte	78
 8811 00b6 00       		.byte	0
 8812 00b7 30       		.byte	48
 8813 00b8 01       		.byte	1
 8814 00b9 00       		.byte	0
 8815 00ba 00       		.byte	0
 8816 00bb 00000000 		.space	5
 8816      00
 8817 00c0 00       		.byte	0
 8818 00c1 00       		.byte	0
 8819 00c2 01       		.byte	1
 8820 00c3 00       		.byte	0
 8821 00c4 00       		.byte	0
 8822 00c5 00       		.byte	0
 8823 00c6 00       		.byte	0
 8824 00c7 01       		.byte	1
 8825 00c8 00       		.byte	0
 8826 00c9 03       		.byte	3
 8827 00ca 00       		.byte	0
 8828 00cb 00       		.byte	0
 8829 00cc 00       		.byte	0
 8830 00cd 00       		.byte	0
 8831 00ce 00       		.byte	0
 8832 00cf 30       		.byte	48
 8833 00d0 01       		.byte	1
 8834 00d1 00       		.byte	0
 8835 00d2 00       		.byte	0
 8836 00d3 00000000 		.space	5
 8836      00
 8837 00d8 00       		.byte	0
 8838 00d9 00       		.byte	0
 8839 00da 02       		.byte	2
 8840 00db 00       		.byte	0
 8841 00dc 00       		.byte	0
 8842 00dd 05       		.byte	5
 8843 00de 00       		.byte	0
 8844 00df 01       		.byte	1
 8845 00e0 00       		.byte	0
 8846 00e1 03       		.byte	3
 8847 00e2 00       		.byte	0
 8848 00e3 00       		.byte	0
 8849 00e4 00       		.byte	0
 8850 00e5 00       		.byte	0
 8851 00e6 00       		.byte	0
 8852 00e7 30       		.byte	48
 8853 00e8 01       		.byte	1
 8854 00e9 00       		.byte	0
 8855 00ea 00       		.byte	0
 8856 00eb 00000000 		.space	5
 8856      00
 8857 00f0 00       		.byte	0
 8858 00f1 00       		.byte	0
 8859 00f2 03       		.byte	3
 8860 00f3 00       		.byte	0
 8861 00f4 00       		.byte	0
 8862 00f5 0A       		.byte	10
 8863 00f6 00       		.byte	0
 8864 00f7 01       		.byte	1
 8865 00f8 00       		.byte	0
 8866 00f9 03       		.byte	3
 8867 00fa 00       		.byte	0
 8868 00fb 00       		.byte	0
 8869 00fc 00       		.byte	0
 8870 00fd 00       		.byte	0
 8871 00fe 00       		.byte	0
 8872 00ff 30       		.byte	48
 8873 0100 01       		.byte	1
 8874 0101 00       		.byte	0
 8875 0102 00       		.byte	0
 8876 0103 00000000 		.space	5
 8876      00
 8877 0108 00       		.byte	0
 8878 0109 00       		.byte	0
 8879 010a 02       		.byte	2
 8880 010b 00       		.byte	0
 8881 010c 00       		.byte	0
 8882 010d 40       		.byte	64
 8883 010e 00       		.byte	0
 8884 010f 01       		.byte	1
 8885 0110 00       		.byte	0
 8886 0111 03       		.byte	3
 8887 0112 00       		.byte	0
 8888 0113 0F       		.byte	15
 8889 0114 11       		.byte	17
 8890 0115 00       		.byte	0
 8891 0116 00       		.byte	0
 8892 0117 30       		.byte	48
 8893 0118 01       		.byte	1
 8894 0119 00       		.byte	0
 8895 011a 00       		.byte	0
 8896 011b 00000000 		.space	5
 8896      00
 8897 0120 00       		.byte	0
 8898 0121 00       		.byte	0
 8899 0122 02       		.byte	2
 8900 0123 00       		.byte	0
 8901 0124 00       		.byte	0
 8902 0125 64       		.byte	100
 8903 0126 00       		.byte	0
 8904 0127 01       		.byte	1
 8905 0128 00       		.byte	0
 8906 0129 03       		.byte	3
 8907 012a 00       		.byte	0
 8908 012b 00       		.byte	0
 8909 012c 00       		.byte	0
 8910 012d 00       		.byte	0
 8911 012e 00       		.byte	0
 8912 012f 30       		.byte	48
 8913 0130 01       		.byte	1
 8914 0131 00       		.byte	0
 8915 0132 00       		.byte	0
 8916 0133 00000000 		.space	5
 8916      00
 8917 0138 00       		.byte	0
 8918 0139 00       		.byte	0
 8919 013a 02       		.byte	2
 8920 013b 00       		.byte	0
 8921 013c 00       		.byte	0
 8922 013d 64       		.byte	100
 8923 013e 00       		.byte	0
 8924 013f 01       		.byte	1
 8925 0140 00       		.byte	0
 8926 0141 03       		.byte	3
 8927 0142 00       		.byte	0
 8928 0143 00       		.byte	0
 8929 0144 00       		.byte	0
 8930 0145 00       		.byte	0
 8931 0146 00       		.byte	0
 8932 0147 30       		.byte	48
 8933 0148 01       		.byte	1
 8934 0149 00       		.byte	0
 8935 014a 00       		.byte	0
 8936 014b 00000000 		.space	5
 8936      00
 8937 0150 00       		.byte	0
 8938 0151 00       		.byte	0
 8939 0152 02       		.byte	2
 8940 0153 00       		.byte	0
 8941 0154 00       		.byte	0
 8942 0155 64       		.byte	100
 8943 0156 00       		.byte	0
 8944 0157 01       		.byte	1
 8945 0158 00       		.byte	0
 8946 0159 03       		.byte	3
 8947 015a 00       		.byte	0
 8948 015b 00       		.byte	0
 8949 015c 00       		.byte	0
 8950 015d 00       		.byte	0
 8951 015e 00       		.byte	0
 8952 015f 30       		.byte	48
 8953 0160 01       		.byte	1
 8954 0161 00       		.byte	0
 8955 0162 00       		.byte	0
 8956 0163 00000000 		.space	5
 8956      00
 8957 0168 00       		.byte	0
 8958 0169 00       		.byte	0
 8959 016a 02       		.byte	2
 8960 016b 00       		.byte	0
 8961 016c 00       		.byte	0
 8962 016d 64       		.byte	100
 8963 016e 00       		.byte	0
 8964 016f 01       		.byte	1
 8965 0170 00       		.byte	0
 8966 0171 03       		.byte	3
 8967 0172 00       		.byte	0
 8968 0173 00       		.byte	0
 8969 0174 00       		.byte	0
 8970 0175 00       		.byte	0
 8971 0176 00       		.byte	0
 8972 0177 30       		.byte	48
 8973 0178 01       		.byte	1
 8974 0179 00       		.byte	0
 8975 017a 00       		.byte	0
 8976 017b 00000000 		.space	5
 8976      00
 8979              	CtrlParArry:
 8980 0180 10       		.byte	16
 8981 0181 10       		.byte	16
 8982 0182 02       		.byte	2
 8983 0183 00       		.byte	0
 8984 0184 00       		.byte	0
 8985 0185 03       		.byte	3
 8986 0186 00       		.byte	0
 8987 0187 01       		.byte	1
 8988 0188 00       		.byte	0
 8989 0189 03       		.byte	3
 8990 018a 00       		.byte	0
 8991 018b 03       		.byte	3
 8992 018c 00       		.byte	0
 8993 018d 03       		.byte	3
 8994 018e 00       		.byte	0
 8995 018f 30       		.byte	48
 8996 0190 01       		.byte	1
 8997 0191 00       		.byte	0
 8998 0192 00       		.byte	0
 8999 0193 00000000 		.space	5
 8999      00
 9000 0198 15       		.byte	21
 9001 0199 15       		.byte	21
 9002 019a 02       		.byte	2
 9003 019b 00       		.byte	0
 9004 019c 00       		.byte	0
 9005 019d FF       		.byte	-1
 9006 019e 00       		.byte	0
 9007 019f 01       		.byte	1
 9008 01a0 00       		.byte	0
 9009 01a1 03       		.byte	3
 9010 01a2 00       		.byte	0
 9011 01a3 76       		.byte	118
 9012 01a4 00       		.byte	0
 9013 01a5 76       		.byte	118
 9014 01a6 C7       		.byte	-57
 9015 01a7 30       		.byte	48
 9016 01a8 01       		.byte	1
 9017 01a9 01       		.byte	1
 9018 01aa 00       		.byte	0
 9019 01ab 00000000 		.space	5
 9019      00
 9020 01b0 04       		.byte	4
 9021 01b1 04       		.byte	4
 9022 01b2 02       		.byte	2
 9023 01b3 00       		.byte	0
 9024 01b4 00       		.byte	0
 9025 01b5 FF       		.byte	-1
 9026 01b6 00       		.byte	0
 9027 01b7 01       		.byte	1
 9028 01b8 00       		.byte	0
 9029 01b9 03       		.byte	3
 9030 01ba 00       		.byte	0
 9031 01bb 70       		.byte	112
 9032 01bc 00       		.byte	0
 9033 01bd 70       		.byte	112
 9034 01be 00       		.byte	0
 9035 01bf 30       		.byte	48
 9036 01c0 01       		.byte	1
 9037 01c1 01       		.byte	1
 9038 01c2 00       		.byte	0
 9039 01c3 00000000 		.space	5
 9039      00
 9040 01c8 00       		.byte	0
 9041 01c9 00       		.byte	0
 9042 01ca 02       		.byte	2
 9043 01cb 00       		.byte	0
 9044 01cc 00       		.byte	0
 9045 01cd 64       		.byte	100
 9046 01ce 00       		.byte	0
 9047 01cf 01       		.byte	1
 9048 01d0 00       		.byte	0
 9049 01d1 03       		.byte	3
 9050 01d2 00       		.byte	0
 9051 01d3 00       		.byte	0
 9052 01d4 00       		.byte	0
 9053 01d5 00       		.byte	0
 9054 01d6 00       		.byte	0
 9055 01d7 30       		.byte	48
 9056 01d8 01       		.byte	1
 9057 01d9 00       		.byte	0
 9058 01da 00       		.byte	0
 9059 01db 00000000 		.space	5
 9059      00
 9060 01e0 07       		.byte	7
 9061 01e1 07       		.byte	7
 9062 01e2 02       		.byte	2
 9063 01e3 00       		.byte	0
 9064 01e4 00       		.byte	0
 9065 01e5 01       		.byte	1
 9066 01e6 00       		.byte	0
 9067 01e7 01       		.byte	1
 9068 01e8 00       		.byte	0
 9069 01e9 03       		.byte	3
 9070 01ea 00       		.byte	0
 9071 01eb 01       		.byte	1
 9072 01ec 00       		.byte	0
 9073 01ed 01       		.byte	1
 9074 01ee 00       		.byte	0
 9075 01ef 30       		.byte	48
 9076 01f0 01       		.byte	1
 9077 01f1 00       		.byte	0
 9078 01f2 00       		.byte	0
 9079 01f3 00000000 		.space	5
 9079      00
 9080 01f8 DF       		.byte	-33
 9081 01f9 E1       		.byte	-31
 9082 01fa 02       		.byte	2
 9083 01fb 00       		.byte	0
 9084 01fc 00       		.byte	0
 9085 01fd FF       		.byte	-1
 9086 01fe 00       		.byte	0
 9087 01ff 01       		.byte	1
 9088 0200 00       		.byte	0
 9089 0201 03       		.byte	3
 9090 0202 00       		.byte	0
 9091 0203 80       		.byte	-128
 9092 0204 00       		.byte	0
 9093 0205 00       		.byte	0
 9094 0206 00       		.byte	0
 9095 0207 C6       		.byte	-58
 9096 0208 01       		.byte	1
 9097 0209 01       		.byte	1
 9098 020a 00       		.byte	0
 9099 020b 00000000 		.space	5
 9099      00
 9100 0210 85       		.byte	-123
 9101 0211 86       		.byte	-122
 9102 0212 02       		.byte	2
 9103 0213 00       		.byte	0
 9104 0214 00       		.byte	0
 9105 0215 64       		.byte	100
 9106 0216 00       		.byte	0
 9107 0217 01       		.byte	1
 9108 0218 00       		.byte	0
 9109 0219 03       		.byte	3
 9110 021a 00       		.byte	0
 9111 021b 32       		.byte	50
 9112 021c 00       		.byte	0
 9113 021d 32       		.byte	50
 9114 021e 00       		.byte	0
 9115 021f F2       		.byte	-14
 9116 0220 01       		.byte	1
 9117 0221 01       		.byte	1
 9118 0222 00       		.byte	0
 9119 0223 00000000 		.space	5
 9119      00
 9120 0228 06       		.byte	6
 9121 0229 06       		.byte	6
 9122 022a 02       		.byte	2
 9123 022b 00       		.byte	0
 9124 022c 00       		.byte	0
 9125 022d 40       		.byte	64
 9126 022e 00       		.byte	0
 9127 022f 01       		.byte	1
 9128 0230 00       		.byte	0
 9129 0231 03       		.byte	3
 9130 0232 00       		.byte	0
 9131 0233 20       		.byte	32
 9132 0234 00       		.byte	0
 9133 0235 20       		.byte	32
 9134 0236 00       		.byte	0
 9135 0237 30       		.byte	48
 9136 0238 01       		.byte	1
 9137 0239 01       		.byte	1
 9138 023a 00       		.byte	0
 9139 023b 00000000 		.space	5
 9139      00
 9140 0240 00       		.byte	0
 9141 0241 00       		.byte	0
 9142 0242 02       		.byte	2
 9143 0243 00       		.byte	0
 9144 0244 00       		.byte	0
 9145 0245 64       		.byte	100
 9146 0246 00       		.byte	0
 9147 0247 01       		.byte	1
 9148 0248 00       		.byte	0
 9149 0249 03       		.byte	3
 9150 024a 00       		.byte	0
 9151 024b 00       		.byte	0
 9152 024c 00       		.byte	0
 9153 024d 00       		.byte	0
 9154 024e 00       		.byte	0
 9155 024f 30       		.byte	48
 9156 0250 01       		.byte	1
 9157 0251 00       		.byte	0
 9158 0252 00       		.byte	0
 9159 0253 00000000 		.space	5
 9159      00
 9160 0258 08       		.byte	8
 9161 0259 08       		.byte	8
 9162 025a 02       		.byte	2
 9163 025b 00       		.byte	0
 9164 025c 00       		.byte	0
 9165 025d 05       		.byte	5
 9166 025e 00       		.byte	0
 9167 025f 01       		.byte	1
 9168 0260 00       		.byte	0
 9169 0261 03       		.byte	3
 9170 0262 00       		.byte	0
 9171 0263 00       		.byte	0
 9172 0264 00       		.byte	0
 9173 0265 00       		.byte	0
 9174 0266 00       		.byte	0
 9175 0267 30       		.byte	48
 9176 0268 01       		.byte	1
 9177 0269 00       		.byte	0
 9178 026a 00       		.byte	0
 9179 026b 00000000 		.space	5
 9179      00
 9180 0270 00       		.byte	0
 9181 0271 00       		.byte	0
 9182 0272 02       		.byte	2
 9183 0273 00       		.byte	0
 9184 0274 00       		.byte	0
 9185 0275 40       		.byte	64
 9186 0276 00       		.byte	0
 9187 0277 01       		.byte	1
 9188 0278 00       		.byte	0
 9189 0279 03       		.byte	3
 9190 027a 00       		.byte	0
 9191 027b 00       		.byte	0
 9192 027c 00       		.byte	0
 9193 027d 00       		.byte	0
 9194 027e 00       		.byte	0
 9195 027f 30       		.byte	48
 9196 0280 01       		.byte	1
 9197 0281 00       		.byte	0
 9198 0282 00       		.byte	0
 9199 0283 00000000 		.space	5
 9199      00
 9200 0288 09       		.byte	9
 9201 0289 0A       		.byte	10
 9202 028a 04       		.byte	4
 9203 028b 00       		.byte	0
 9204 028c 00       		.byte	0
 9205 028d 40       		.byte	64
 9206 028e 00       		.byte	0
 9207 028f 01       		.byte	1
 9208 0290 00       		.byte	0
 9209 0291 03       		.byte	3
 9210 0292 00       		.byte	0
 9211 0293 20       		.byte	32
 9212 0294 38       		.byte	56
 9213 0295 20       		.byte	32
 9214 0296 38       		.byte	56
 9215 0297 30       		.byte	48
 9216 0298 01       		.byte	1
 9217 0299 00       		.byte	0
 9218 029a 00       		.byte	0
 9219 029b 00000000 		.space	5
 9219      00
 9220 02a0 00       		.byte	0
 9221 02a1 00       		.byte	0
 9222 02a2 02       		.byte	2
 9223 02a3 00       		.byte	0
 9224 02a4 00       		.byte	0
 9225 02a5 64       		.byte	100
 9226 02a6 00       		.byte	0
 9227 02a7 01       		.byte	1
 9228 02a8 00       		.byte	0
 9229 02a9 03       		.byte	3
 9230 02aa 00       		.byte	0
 9231 02ab 00       		.byte	0
 9232 02ac 00       		.byte	0
 9233 02ad 00       		.byte	0
 9234 02ae 00       		.byte	0
 9235 02af 30       		.byte	48
 9236 02b0 01       		.byte	1
 9237 02b1 00       		.byte	0
 9238 02b2 00       		.byte	0
 9239 02b3 00000000 		.space	5
 9239      00
 9240 02b8 00       		.byte	0
 9241 02b9 00       		.byte	0
 9242 02ba 02       		.byte	2
 9243 02bb 00       		.byte	0
 9244 02bc 00       		.byte	0
 9245 02bd 64       		.byte	100
 9246 02be 00       		.byte	0
 9247 02bf 01       		.byte	1
 9248 02c0 00       		.byte	0
 9249 02c1 03       		.byte	3
 9250 02c2 00       		.byte	0
 9251 02c3 00       		.byte	0
 9252 02c4 00       		.byte	0
 9253 02c5 00       		.byte	0
 9254 02c6 00       		.byte	0
 9255 02c7 30       		.byte	48
 9256 02c8 01       		.byte	1
 9257 02c9 00       		.byte	0
 9258 02ca 00       		.byte	0
 9259 02cb 00000000 		.space	5
 9259      00
 9260 02d0 2A       		.byte	42
 9261 02d1 2A       		.byte	42
 9262 02d2 02       		.byte	2
 9263 02d3 00       		.byte	0
 9264 02d4 00       		.byte	0
 9265 02d5 1B       		.byte	27
 9266 02d6 00       		.byte	0
 9267 02d7 01       		.byte	1
 9268 02d8 00       		.byte	0
 9269 02d9 03       		.byte	3
 9270 02da 00       		.byte	0
 9271 02db 00       		.byte	0
 9272 02dc 00       		.byte	0
 9273 02dd 00       		.byte	0
 9274 02de 00       		.byte	0
 9275 02df 30       		.byte	48
 9276 02e0 01       		.byte	1
 9277 02e1 00       		.byte	0
 9278 02e2 00       		.byte	0
 9279 02e3 00000000 		.space	5
 9279      00
 9280 02e8 00       		.byte	0
 9281 02e9 00       		.byte	0
 9282 02ea 02       		.byte	2
 9283 02eb 00       		.byte	0
 9284 02ec 00       		.byte	0
 9285 02ed 64       		.byte	100
 9286 02ee 00       		.byte	0
 9287 02ef 01       		.byte	1
 9288 02f0 00       		.byte	0
 9289 02f1 03       		.byte	3
 9290 02f2 00       		.byte	0
 9291 02f3 00       		.byte	0
 9292 02f4 00       		.byte	0
 9293 02f5 00       		.byte	0
 9294 02f6 00       		.byte	0
 9295 02f7 30       		.byte	48
 9296 02f8 01       		.byte	1
 9297 02f9 00       		.byte	0
 9298 02fa 00       		.byte	0
 9299 02fb 00000000 		.space	5
 9299      00
 9300 0300 00       		.byte	0
 9301 0301 00       		.byte	0
 9302 0302 02       		.byte	2
 9303 0303 00       		.byte	0
 9304 0304 00       		.byte	0
 9305 0305 12       		.byte	18
 9306 0306 00       		.byte	0
 9307 0307 01       		.byte	1
 9308 0308 00       		.byte	0
 9309 0309 03       		.byte	3
 9310 030a 00       		.byte	0
 9311 030b 00       		.byte	0
 9312 030c 00       		.byte	0
 9313 030d 00       		.byte	0
 9314 030e 00       		.byte	0
 9315 030f 30       		.byte	48
 9316 0310 01       		.byte	1
 9317 0311 00       		.byte	0
 9318 0312 00       		.byte	0
 9319 0313 00000000 		.space	5
 9319      00
 9320 0318 01       		.byte	1
 9321 0319 01       		.byte	1
 9322 031a 02       		.byte	2
 9323 031b 00       		.byte	0
 9324 031c 00       		.byte	0
 9325 031d 09       		.byte	9
 9326 031e 00       		.byte	0
 9327 031f 01       		.byte	1
 9328 0320 00       		.byte	0
 9329 0321 03       		.byte	3
 9330 0322 00       		.byte	0
 9331 0323 00       		.byte	0
 9332 0324 00       		.byte	0
 9333 0325 01       		.byte	1
 9334 0326 00       		.byte	0
 9335 0327 30       		.byte	48
 9336 0328 01       		.byte	1
 9337 0329 00       		.byte	0
 9338 032a 00       		.byte	0
 9339 032b 00000000 		.space	5
 9339      00
 9340 0330 05       		.byte	5
 9341 0331 05       		.byte	5
 9342 0332 02       		.byte	2
 9343 0333 00       		.byte	0
 9344 0334 00       		.byte	0
 9345 0335 03       		.byte	3
 9346 0336 00       		.byte	0
 9347 0337 01       		.byte	1
 9348 0338 00       		.byte	0
 9349 0339 03       		.byte	3
 9350 033a 00       		.byte	0
 9351 033b 00       		.byte	0
 9352 033c 00       		.byte	0
 9353 033d 00       		.byte	0
 9354 033e 00       		.byte	0
 9355 033f 30       		.byte	48
 9356 0340 01       		.byte	1
 9357 0341 00       		.byte	0
 9358 0342 00       		.byte	0
 9359 0343 00000000 		.space	5
 9359      00
 9360 0348 18       		.byte	24
 9361 0349 18       		.byte	24
 9362 034a 02       		.byte	2
 9363 034b 00       		.byte	0
 9364 034c 00       		.byte	0
 9365 034d 01       		.byte	1
 9366 034e 00       		.byte	0
 9367 034f 01       		.byte	1
 9368 0350 00       		.byte	0
 9369 0351 03       		.byte	3
 9370 0352 00       		.byte	0
 9371 0353 00       		.byte	0
 9372 0354 00       		.byte	0
 9373 0355 00       		.byte	0
 9374 0356 00       		.byte	0
 9375 0357 30       		.byte	48
 9376 0358 01       		.byte	1
 9377 0359 00       		.byte	0
 9378 035a 00       		.byte	0
 9379 035b 00000000 		.space	5
 9379      00
 9380 0360 19       		.byte	25
 9381 0361 19       		.byte	25
 9382 0362 01       		.byte	1
 9383 0363 00       		.byte	0
 9384 0364 00       		.byte	0
 9385 0365 40       		.byte	64
 9386 0366 00       		.byte	0
 9387 0367 01       		.byte	1
 9388 0368 00       		.byte	0
 9389 0369 03       		.byte	3
 9390 036a 00       		.byte	0
 9391 036b 20       		.byte	32
 9392 036c 00       		.byte	0
 9393 036d 20       		.byte	32
 9394 036e 00       		.byte	0
 9395 036f 30       		.byte	48
 9396 0370 01       		.byte	1
 9397 0371 00       		.byte	0
 9398 0372 00       		.byte	0
 9399 0373 00000000 		.space	5
 9399      00
 9400 0378 20       		.byte	32
 9401 0379 20       		.byte	32
 9402 037a 02       		.byte	2
 9403 037b 00       		.byte	0
 9404 037c 00       		.byte	0
 9405 037d 02       		.byte	2
 9406 037e 00       		.byte	0
 9407 037f 01       		.byte	1
 9408 0380 00       		.byte	0
 9409 0381 03       		.byte	3
 9410 0382 00       		.byte	0
 9411 0383 00       		.byte	0
 9412 0384 00       		.byte	0
 9413 0385 00       		.byte	0
 9414 0386 00       		.byte	0
 9415 0387 30       		.byte	48
 9416 0388 01       		.byte	1
 9417 0389 00       		.byte	0
 9418 038a 00       		.byte	0
 9419 038b 00000000 		.space	5
 9419      00
 9420 0390 22       		.byte	34
 9421 0391 22       		.byte	34
 9422 0392 02       		.byte	2
 9423 0393 00       		.byte	0
 9424 0394 00       		.byte	0
 9425 0395 3F       		.byte	63
 9426 0396 00       		.byte	0
 9427 0397 01       		.byte	1
 9428 0398 00       		.byte	0
 9429 0399 03       		.byte	3
 9430 039a 00       		.byte	0
 9431 039b 00       		.byte	0
 9432 039c 00       		.byte	0
 9433 039d 00       		.byte	0
 9434 039e 00       		.byte	0
 9435 039f 30       		.byte	48
 9436 03a0 01       		.byte	1
 9437 03a1 00       		.byte	0
 9438 03a2 00       		.byte	0
 9439 03a3 00000000 		.space	5
 9439      00
 9440 03a8 23       		.byte	35
 9441 03a9 23       		.byte	35
 9442 03aa 02       		.byte	2
 9443 03ab 00       		.byte	0
 9444 03ac 00       		.byte	0
 9445 03ad 64       		.byte	100
 9446 03ae 00       		.byte	0
 9447 03af 01       		.byte	1
 9448 03b0 00       		.byte	0
 9449 03b1 03       		.byte	3
 9450 03b2 00       		.byte	0
 9451 03b3 10       		.byte	16
 9452 03b4 00       		.byte	0
 9453 03b5 10       		.byte	16
 9454 03b6 00       		.byte	0
 9455 03b7 30       		.byte	48
 9456 03b8 01       		.byte	1
 9457 03b9 00       		.byte	0
 9458 03ba 00       		.byte	0
 9459 03bb 00000000 		.space	5
 9459      00
 9460 03c0 24       		.byte	36
 9461 03c1 24       		.byte	36
 9462 03c2 02       		.byte	2
 9463 03c3 00       		.byte	0
 9464 03c4 00       		.byte	0
 9465 03c5 64       		.byte	100
 9466 03c6 00       		.byte	0
 9467 03c7 01       		.byte	1
 9468 03c8 00       		.byte	0
 9469 03c9 03       		.byte	3
 9470 03ca 00       		.byte	0
 9471 03cb 10       		.byte	16
 9472 03cc 00       		.byte	0
 9473 03cd 10       		.byte	16
 9474 03ce 00       		.byte	0
 9475 03cf 30       		.byte	48
 9476 03d0 01       		.byte	1
 9477 03d1 00       		.byte	0
 9478 03d2 00       		.byte	0
 9479 03d3 00000000 		.space	5
 9479      00
 9480 03d8 02       		.byte	2
 9481 03d9 03       		.byte	3
 9482 03da 04       		.byte	4
 9483 03db 00       		.byte	0
 9484 03dc 00       		.byte	0
 9485 03dd 7F       		.byte	127
 9486 03de 00       		.byte	0
 9487 03df 01       		.byte	1
 9488 03e0 00       		.byte	0
 9489 03e1 03       		.byte	3
 9490 03e2 00       		.byte	0
 9491 03e3 00       		.byte	0
 9492 03e4 20       		.byte	32
 9493 03e5 00       		.byte	0
 9494 03e6 20       		.byte	32
 9495 03e7 30       		.byte	48
 9496 03e8 01       		.byte	1
 9497 03e9 00       		.byte	0
 9498 03ea 00       		.byte	0
 9499 03eb 00000000 		.space	5
 9499      00
 9500 03f0 04       		.byte	4
 9501 03f1 04       		.byte	4
 9502 03f2 02       		.byte	2
 9503 03f3 00       		.byte	0
 9504 03f4 00       		.byte	0
 9505 03f5 FF       		.byte	-1
 9506 03f6 00       		.byte	0
 9507 03f7 01       		.byte	1
 9508 03f8 00       		.byte	0
 9509 03f9 03       		.byte	3
 9510 03fa 00       		.byte	0
 9511 03fb 60       		.byte	96
 9512 03fc 00       		.byte	0
 9513 03fd 60       		.byte	96
 9514 03fe 00       		.byte	0
 9515 03ff 30       		.byte	48
 9516 0400 01       		.byte	1
 9517 0401 00       		.byte	0
 9518 0402 00       		.byte	0
 9519 0403 00000000 		.space	5
 9519      00
 9520 0408 00       		.byte	0
 9521 0409 00       		.byte	0
 9522 040a 02       		.byte	2
 9523 040b 00       		.byte	0
 9524 040c 00       		.byte	0
 9525 040d 19       		.byte	25
 9526 040e 00       		.byte	0
 9527 040f 01       		.byte	1
 9528 0410 00       		.byte	0
 9529 0411 03       		.byte	3
 9530 0412 00       		.byte	0
 9531 0413 00       		.byte	0
 9532 0414 00       		.byte	0
 9533 0415 00       		.byte	0
 9534 0416 00       		.byte	0
 9535 0417 30       		.byte	48
 9536 0418 01       		.byte	1
 9537 0419 00       		.byte	0
 9538 041a 00       		.byte	0
 9539 041b 00000000 		.space	5
 9539      00
 9540 0420 10       		.byte	16
 9541 0421 10       		.byte	16
 9542 0422 02       		.byte	2
 9543 0423 00       		.byte	0
 9544 0424 00       		.byte	0
 9545 0425 06       		.byte	6
 9546 0426 00       		.byte	0
 9547 0427 01       		.byte	1
 9548 0428 00       		.byte	0
 9549 0429 03       		.byte	3
 9550 042a 00       		.byte	0
 9551 042b 03       		.byte	3
 9552 042c 00       		.byte	0
 9553 042d 03       		.byte	3
 9554 042e 00       		.byte	0
 9555 042f 30       		.byte	48
 9556 0430 01       		.byte	1
 9557 0431 00       		.byte	0
 9558 0432 00       		.byte	0
 9559 0433 00000000 		.space	5
 9559      00
 9560 0438 00       		.byte	0
 9561 0439 00       		.byte	0
 9562 043a 02       		.byte	2
 9563 043b 00       		.byte	0
 9564 043c 00       		.byte	0
 9565 043d 03       		.byte	3
 9566 043e 00       		.byte	0
 9567 043f 01       		.byte	1
 9568 0440 00       		.byte	0
 9569 0441 03       		.byte	3
 9570 0442 00       		.byte	0
 9571 0443 00       		.byte	0
 9572 0444 00       		.byte	0
 9573 0445 00       		.byte	0
 9574 0446 00       		.byte	0
 9575 0447 30       		.byte	48
 9576 0448 01       		.byte	1
 9577 0449 00       		.byte	0
 9578 044a 00       		.byte	0
 9579 044b 00000000 		.space	5
 9579      00
 9580 0450 50       		.byte	80
 9581 0451 50       		.byte	80
 9582 0452 01       		.byte	1
 9583 0453 00       		.byte	0
 9584 0454 00       		.byte	0
 9585 0455 03       		.byte	3
 9586 0456 00       		.byte	0
 9587 0457 01       		.byte	1
 9588 0458 00       		.byte	0
 9589 0459 03       		.byte	3
 9590 045a 00       		.byte	0
 9591 045b 00       		.byte	0
 9592 045c 00       		.byte	0
 9593 045d 00       		.byte	0
 9594 045e 00       		.byte	0
 9595 045f 30       		.byte	48
 9596 0460 01       		.byte	1
 9597 0461 00       		.byte	0
 9598 0462 00       		.byte	0
 9599 0463 00000000 		.space	5
 9599      00
 9600 0468 00       		.byte	0
 9601 0469 00       		.byte	0
 9602 046a 0B       		.byte	11
 9603 046b 00       		.byte	0
 9604 046c 00       		.byte	0
 9605 046d FF       		.byte	-1
 9606 046e FF       		.byte	-1
 9607 046f 01       		.byte	1
 9608 0470 00       		.byte	0
 9609 0471 03       		.byte	3
 9610 0472 00       		.byte	0
 9611 0473 00       		.byte	0
 9612 0474 00       		.byte	0
 9613 0475 00       		.byte	0
 9614 0476 00       		.byte	0
 9615 0477 00       		.byte	0
 9616 0478 01       		.byte	1
 9617 0479 00       		.byte	0
 9618 047a 00       		.byte	0
 9619 047b 00000000 		.space	5
 9619      00
 9622              	glUVCHeader:
 9623 0480 0C       		.byte	12
 9624 0481 8C       		.byte	-116
 9625 0482 00       		.byte	0
 9626 0483 00       		.byte	0
 9627 0484 00       		.byte	0
 9628 0485 00       		.byte	0
 9629 0486 00       		.byte	0
 9630 0487 00       		.byte	0
 9631 0488 00       		.byte	0
 9632 0489 00       		.byte	0
 9633 048a 00       		.byte	0
 9634 048b 00       		.byte	0
 9637              	ROIMode:
 9638 048c 01       		.byte	1
 9639 048d 000000   		.space	3
 9642              	EXTShutter:
 9643 0490 00       		.byte	0
 9644 0491 02       		.byte	2
 9645 0492 02       		.byte	2
 9646 0493 00       		.byte	0
 9647 0494 00       		.byte	0
 9648 0495 08       		.byte	8
 9649 0496 00       		.byte	0
 9650 0497 01       		.byte	1
 9651 0498 00       		.byte	0
 9652 0499 03       		.byte	3
 9653 049a 00       		.byte	0
 9654 049b 00       		.byte	0
 9655 049c 00       		.byte	0
 9656 049d 00       		.byte	0
 9657 049e 00       		.byte	0
 9658 049f 30       		.byte	48
 9659 04a0 01       		.byte	1
 9660 04a1 00       		.byte	0
 9661 04a2 0000     		.space	2
 9664              	EXTShutlev:
 9665 04a4 02       		.byte	2
 9666 04a5 12       		.byte	18
 9667 04a6 02       		.byte	2
 9668 04a7 00       		.byte	0
 9669 04a8 00       		.byte	0
 9670 04a9 FF       		.byte	-1
 9671 04aa 7F       		.byte	127
 9672 04ab 01       		.byte	1
 9673 04ac 00       		.byte	0
 9674 04ad 03       		.byte	3
 9675 04ae 00       		.byte	0
 9676 04af 3F       		.byte	63
 9677 04b0 00       		.byte	0
 9678 04b1 3F       		.byte	63
 9679 04b2 00       		.byte	0
 9680 04b3 30       		.byte	48
 9681 04b4 01       		.byte	1
 9682 04b5 00       		.byte	0
 9683 04b6 0000     		.space	2
 9686              	EXTAexModGainlev:
 9687 04b8 00       		.byte	0
 9688 04b9 03       		.byte	3
 9689 04ba 04       		.byte	4
 9690 04bb 00       		.byte	0
 9691 04bc 00       		.byte	0
 9692 04bd 03       		.byte	3
 9693 04be 7F       		.byte	127
 9694 04bf 01       		.byte	1
 9695 04c0 00       		.byte	0
 9696 04c1 03       		.byte	3
 9697 04c2 00       		.byte	0
 9698 04c3 00       		.byte	0
 9699 04c4 3F       		.byte	63
 9700 04c5 00       		.byte	0
 9701 04c6 3F       		.byte	63
 9702 04c7 30       		.byte	48
 9703 04c8 01       		.byte	1
 9704 04c9 00       		.byte	0
 9705 04ca 0000     		.space	2
 9708              	WBMenuCmpArry:
 9709 04cc 20       		.byte	32
 9710 04cd 0F       		.byte	15
 9711 04ce 38       		.byte	56
 9712 04cf F0       		.byte	-16
 9715              	EXTBLCWinPos:
 9716 04d0 13       		.byte	19
 9717 04d1 14       		.byte	20
 9718 04d2 02       		.byte	2
 9719 04d3 00       		.byte	0
 9720 04d4 00       		.byte	0
 9721 04d5 FF       		.byte	-1
 9722 04d6 FF       		.byte	-1
 9723 04d7 01       		.byte	1
 9724 04d8 00       		.byte	0
 9725 04d9 03       		.byte	3
 9726 04da 00       		.byte	0
 9727 04db 22       		.byte	34
 9728 04dc 22       		.byte	34
 9729 04dd 22       		.byte	34
 9730 04de 22       		.byte	34
 9731 04df 30       		.byte	48
 9732 04e0 01       		.byte	1
 9733 04e1 00       		.byte	0
 9734 04e2 0000     		.space	2
 9737              	EXTBLCWeight:
 9738 04e4 11       		.byte	17
 9739 04e5 11       		.byte	17
 9740 04e6 02       		.byte	2
 9741 04e7 00       		.byte	0
 9742 04e8 00       		.byte	0
 9743 04e9 FF       		.byte	-1
 9744 04ea 00       		.byte	0
 9745 04eb 01       		.byte	1
 9746 04ec 00       		.byte	0
 9747 04ed 03       		.byte	3
 9748 04ee 00       		.byte	0
 9749 04ef 80       		.byte	-128
 9750 04f0 00       		.byte	0
 9751 04f1 80       		.byte	-128
 9752 04f2 00       		.byte	0
 9753 04f3 30       		.byte	48
 9754 04f4 01       		.byte	1
 9755 04f5 00       		.byte	0
 9756 04f6 0000     		.space	2
 9759              	PUCBLC:
 9760 04f8 10       		.byte	16
 9761 04f9 11       		.byte	17
 9762 04fa 02       		.byte	2
 9763 04fb 00       		.byte	0
 9764 04fc 00       		.byte	0
 9765 04fd 03       		.byte	3
 9766 04fe 00       		.byte	0
 9767 04ff 01       		.byte	1
 9768 0500 00       		.byte	0
 9769 0501 03       		.byte	3
 9770 0502 00       		.byte	0
 9771 0503 03       		.byte	3
 9772 0504 00       		.byte	0
 9773 0505 03       		.byte	3
 9774 0506 00       		.byte	0
 9775 0507 30       		.byte	48
 9776 0508 01       		.byte	1
 9777 0509 00       		.byte	0
 9778 050a 0000     		.space	2
 9781              	PUCSharp:
 9782 050c 06       		.byte	6
 9783 050d 07       		.byte	7
 9784 050e 02       		.byte	2
 9785 050f 00       		.byte	0
 9786 0510 00       		.byte	0
 9787 0511 08       		.byte	8
 9788 0512 00       		.byte	0
 9789 0513 01       		.byte	1
 9790 0514 00       		.byte	0
 9791 0515 03       		.byte	3
 9792 0516 00       		.byte	0
 9793 0517 00       		.byte	0
 9794 0518 00       		.byte	0
 9795 0519 00       		.byte	0
 9796 051a 00       		.byte	0
 9797 051b 30       		.byte	48
 9798 051c 01       		.byte	1
 9799 051d 00       		.byte	0
 9800 051e 0000     		.space	2
 9803              	CTCtrlParArry:
 9804 0520 00       		.byte	0
 9805 0521 00       		.byte	0
 9806 0522 01       		.byte	1
 9807 0523 00       		.byte	0
 9808 0524 00       		.byte	0
 9809 0525 03       		.byte	3
 9810 0526 00       		.byte	0
 9811 0527 01       		.byte	1
 9812 0528 00       		.byte	0
 9813 0529 03       		.byte	3
 9814 052a 00       		.byte	0
 9815 052b 03       		.byte	3
 9816 052c 00       		.byte	0
 9817 052d 03       		.byte	3
 9818 052e 00       		.byte	0
 9819 052f 30       		.byte	48
 9820 0530 01       		.byte	1
 9821 0531 00       		.byte	0
 9822 0532 00       		.byte	0
 9823 0533 00000000 		.space	5
 9823      00
 9824 0538 00       		.byte	0
 9825 0539 00       		.byte	0
 9826 053a 01       		.byte	1
 9827 053b 01       		.byte	1
 9828 053c 00       		.byte	0
 9829 053d 0F       		.byte	15
 9830 053e 00       		.byte	0
 9831 053f 0F       		.byte	15
 9832 0540 00       		.byte	0
 9833 0541 03       		.byte	3
 9834 0542 00       		.byte	0
 9835 0543 02       		.byte	2
 9836 0544 00       		.byte	0
 9837 0545 02       		.byte	2
 9838 0546 00       		.byte	0
 9839 0547 30       		.byte	48
 9840 0548 01       		.byte	1
 9841 0549 01       		.byte	1
 9842 054a 00       		.byte	0
 9843 054b 00000000 		.space	5
 9843      00
 9844 0550 02       		.byte	2
 9845 0551 00       		.byte	0
 9846 0552 01       		.byte	1
 9847 0553 00       		.byte	0
 9848 0554 00       		.byte	0
 9849 0555 01       		.byte	1
 9850 0556 00       		.byte	0
 9851 0557 01       		.byte	1
 9852 0558 00       		.byte	0
 9853 0559 03       		.byte	3
 9854 055a 00       		.byte	0
 9855 055b 00       		.byte	0
 9856 055c 00       		.byte	0
 9857 055d 00       		.byte	0
 9858 055e 00       		.byte	0
 9859 055f 30       		.byte	48
 9860 0560 01       		.byte	1
 9861 0561 01       		.byte	1
 9862 0562 00       		.byte	0
 9863 0563 00000000 		.space	5
 9863      00
 9864 0568 00       		.byte	0
 9865 0569 00       		.byte	0
 9866 056a 04       		.byte	4
 9867 056b 01       		.byte	1
 9868 056c 00       		.byte	0
 9869 056d 38       		.byte	56
 9870 056e 01       		.byte	1
 9871 056f 01       		.byte	1
 9872 0570 00       		.byte	0
 9873 0571 03       		.byte	3
 9874 0572 00       		.byte	0
 9875 0573 4E       		.byte	78
 9876 0574 00       		.byte	0
 9877 0575 4E       		.byte	78
 9878 0576 00       		.byte	0
 9879 0577 30       		.byte	48
 9880 0578 01       		.byte	1
 9881 0579 00       		.byte	0
 9882 057a 00       		.byte	0
 9883 057b 00000000 		.space	5
 9883      00
 9884 0580 04       		.byte	4
 9885 0581 00       		.byte	0
 9886 0582 01       		.byte	1
 9887 0583 00       		.byte	0
 9888 0584 00       		.byte	0
 9889 0585 00       		.byte	0
 9890 0586 00       		.byte	0
 9891 0587 01       		.byte	1
 9892 0588 00       		.byte	0
 9893 0589 03       		.byte	3
 9894 058a 00       		.byte	0
 9895 058b 00       		.byte	0
 9896 058c 00       		.byte	0
 9897 058d 00       		.byte	0
 9898 058e 00       		.byte	0
 9899 058f 30       		.byte	48
 9900 0590 01       		.byte	1
 9901 0591 00       		.byte	0
 9902 0592 00       		.byte	0
 9903 0593 00000000 		.space	5
 9903      00
 9904 0598 05       		.byte	5
 9905 0599 00       		.byte	0
 9906 059a 02       		.byte	2
 9907 059b 00       		.byte	0
 9908 059c 00       		.byte	0
 9909 059d FF       		.byte	-1
 9910 059e 00       		.byte	0
 9911 059f 01       		.byte	1
 9912 05a0 00       		.byte	0
 9913 05a1 03       		.byte	3
 9914 05a2 00       		.byte	0
 9915 05a3 01       		.byte	1
 9916 05a4 00       		.byte	0
 9917 05a5 00       		.byte	0
 9918 05a6 00       		.byte	0
 9919 05a7 30       		.byte	48
 9920 05a8 01       		.byte	1
 9921 05a9 01       		.byte	1
 9922 05aa 00       		.byte	0
 9923 05ab 00000000 		.space	5
 9923      00
 9924 05b0 06       		.byte	6
 9925 05b1 00       		.byte	0
 9926 05b2 02       		.byte	2
 9927 05b3 00       		.byte	0
 9928 05b4 00       		.byte	0
 9929 05b5 00       		.byte	0
 9930 05b6 00       		.byte	0
 9931 05b7 00       		.byte	0
 9932 05b8 00       		.byte	0
 9933 05b9 03       		.byte	3
 9934 05ba 00       		.byte	0
 9935 05bb 00       		.byte	0
 9936 05bc 00       		.byte	0
 9937 05bd 00       		.byte	0
 9938 05be 00       		.byte	0
 9939 05bf 30       		.byte	48
 9940 05c0 01       		.byte	1
 9941 05c1 01       		.byte	1
 9942 05c2 00       		.byte	0
 9943 05c3 00000000 		.space	5
 9943      00
 9944 05c8 23       		.byte	35
 9945 05c9 00       		.byte	0
 9946 05ca 02       		.byte	2
 9947 05cb 00       		.byte	0
 9948 05cc 00       		.byte	0
 9949 05cd 30       		.byte	48
 9950 05ce 00       		.byte	0
 9951 05cf 01       		.byte	1
 9952 05d0 00       		.byte	0
 9953 05d1 03       		.byte	3
 9954 05d2 0A       		.byte	10
 9955 05d3 00       		.byte	0
 9956 05d4 00       		.byte	0
 9957 05d5 0A       		.byte	10
 9958 05d6 00       		.byte	0
 9959 05d7 30       		.byte	48
 9960 05d8 01       		.byte	1
 9961 05d9 01       		.byte	1
 9962 05da 00       		.byte	0
 9963 05db 00000000 		.space	5
 9963      00
 9964 05e0 08       		.byte	8
 9965 05e1 00       		.byte	0
 9966 05e2 01       		.byte	1
 9967 05e3 00       		.byte	0
 9968 05e4 00       		.byte	0
 9969 05e5 7F       		.byte	127
 9970 05e6 00       		.byte	0
 9971 05e7 01       		.byte	1
 9972 05e8 00       		.byte	0
 9973 05e9 03       		.byte	3
 9974 05ea 00       		.byte	0
 9975 05eb 00       		.byte	0
 9976 05ec 00       		.byte	0
 9977 05ed 00       		.byte	0
 9978 05ee 00       		.byte	0
 9979 05ef 30       		.byte	48
 9980 05f0 01       		.byte	1
 9981 05f1 00       		.byte	0
 9982 05f2 00       		.byte	0
 9983 05f3 00000000 		.space	5
 9983      00
 9984 05f8 09       		.byte	9
 9985 05f9 00       		.byte	0
 9986 05fa 02       		.byte	2
 9987 05fb 00       		.byte	0
 9988 05fc 00       		.byte	0
 9989 05fd 05       		.byte	5
 9990 05fe 00       		.byte	0
 9991 05ff 01       		.byte	1
 9992 0600 00       		.byte	0
 9993 0601 03       		.byte	3
 9994 0602 00       		.byte	0
 9995 0603 00       		.byte	0
 9996 0604 00       		.byte	0
 9997 0605 00       		.byte	0
 9998 0606 00       		.byte	0
 9999 0607 30       		.byte	48
 10000 0608 01       		.byte	1
 10001 0609 00       		.byte	0
 10002 060a 00       		.byte	0
 10003 060b 00000000 		.space	5
 10003      00
 10004 0610 10       		.byte	16
 10005 0611 00       		.byte	0
 10006 0612 03       		.byte	3
 10007 0613 00       		.byte	0
 10008 0614 00       		.byte	0
 10009 0615 00       		.byte	0
 10010 0616 00       		.byte	0
 10011 0617 00       		.byte	0
 10012 0618 00       		.byte	0
 10013 0619 03       		.byte	3
 10014 061a 00       		.byte	0
 10015 061b 00       		.byte	0
 10016 061c 00       		.byte	0
 10017 061d 00       		.byte	0
 10018 061e 00       		.byte	0
 10019 061f 30       		.byte	48
 10020 0620 01       		.byte	1
 10021 0621 00       		.byte	0
 10022 0622 00       		.byte	0
 10023 0623 00000000 		.space	5
 10023      00
 10024 0628 00       		.byte	0
 10025 0629 00       		.byte	0
 10026 062a 02       		.byte	2
 10027 062b 00       		.byte	0
 10028 062c 00       		.byte	0
 10029 062d 40       		.byte	64
 10030 062e 00       		.byte	0
 10031 062f 01       		.byte	1
 10032 0630 00       		.byte	0
 10033 0631 03       		.byte	3
 10034 0632 00       		.byte	0
 10035 0633 0F       		.byte	15
 10036 0634 11       		.byte	17
 10037 0635 00       		.byte	0
 10038 0636 00       		.byte	0
 10039 0637 30       		.byte	48
 10040 0638 01       		.byte	1
 10041 0639 00       		.byte	0
 10042 063a 00       		.byte	0
 10043 063b 00000000 		.space	5
 10043      00
 10044 0640 00       		.byte	0
 10045 0641 00       		.byte	0
 10046 0642 02       		.byte	2
 10047 0643 00       		.byte	0
 10048 0644 00       		.byte	0
 10049 0645 64       		.byte	100
 10050 0646 00       		.byte	0
 10051 0647 01       		.byte	1
 10052 0648 00       		.byte	0
 10053 0649 03       		.byte	3
 10054 064a 00       		.byte	0
 10055 064b 00       		.byte	0
 10056 064c 00       		.byte	0
 10057 064d 00       		.byte	0
 10058 064e 00       		.byte	0
 10059 064f 30       		.byte	48
 10060 0650 01       		.byte	1
 10061 0651 00       		.byte	0
 10062 0652 00       		.byte	0
 10063 0653 00000000 		.space	5
 10063      00
 10064 0658 00       		.byte	0
 10065 0659 00       		.byte	0
 10066 065a 02       		.byte	2
 10067 065b 00       		.byte	0
 10068 065c 00       		.byte	0
 10069 065d 64       		.byte	100
 10070 065e 00       		.byte	0
 10071 065f 01       		.byte	1
 10072 0660 00       		.byte	0
 10073 0661 03       		.byte	3
 10074 0662 00       		.byte	0
 10075 0663 00       		.byte	0
 10076 0664 00       		.byte	0
 10077 0665 00       		.byte	0
 10078 0666 00       		.byte	0
 10079 0667 30       		.byte	48
 10080 0668 01       		.byte	1
 10081 0669 00       		.byte	0
 10082 066a 00       		.byte	0
 10083 066b 00000000 		.space	5
 10083      00
 10084 0670 00       		.byte	0
 10085 0671 00       		.byte	0
 10086 0672 02       		.byte	2
 10087 0673 00       		.byte	0
 10088 0674 00       		.byte	0
 10089 0675 64       		.byte	100
 10090 0676 00       		.byte	0
 10091 0677 01       		.byte	1
 10092 0678 00       		.byte	0
 10093 0679 03       		.byte	3
 10094 067a 00       		.byte	0
 10095 067b 00       		.byte	0
 10096 067c 00       		.byte	0
 10097 067d 00       		.byte	0
 10098 067e 00       		.byte	0
 10099 067f 30       		.byte	48
 10100 0680 01       		.byte	1
 10101 0681 00       		.byte	0
 10102 0682 00       		.byte	0
 10103 0683 00000000 		.space	5
 10103      00
 10104 0688 00       		.byte	0
 10105 0689 00       		.byte	0
 10106 068a 02       		.byte	2
 10107 068b 00       		.byte	0
 10108 068c 00       		.byte	0
 10109 068d 64       		.byte	100
 10110 068e 00       		.byte	0
 10111 068f 01       		.byte	1
 10112 0690 00       		.byte	0
 10113 0691 03       		.byte	3
 10114 0692 00       		.byte	0
 10115 0693 00       		.byte	0
 10116 0694 00       		.byte	0
 10117 0695 00       		.byte	0
 10118 0696 00       		.byte	0
 10119 0697 30       		.byte	48
 10120 0698 01       		.byte	1
 10121 0699 00       		.byte	0
 10122 069a 00       		.byte	0
 10123 069b 00000000 		.space	5
 10123      00
 10126              	glProbeCtrlFull:
 10127 06a0 00       		.byte	0
 10128 06a1 00       		.byte	0
 10129 06a2 01       		.byte	1
 10130 06a3 01       		.byte	1
 10131 06a4 15       		.byte	21
 10132 06a5 16       		.byte	22
 10133 06a6 05       		.byte	5
 10134 06a7 00       		.byte	0
 10135 06a8 00       		.byte	0
 10136 06a9 00       		.byte	0
 10137 06aa 00       		.byte	0
 10138 06ab 00       		.byte	0
 10139 06ac 00       		.byte	0
 10140 06ad 00       		.byte	0
 10141 06ae 00       		.byte	0
 10142 06af 00       		.byte	0
 10143 06b0 00       		.byte	0
 10144 06b1 00       		.byte	0
 10145 06b2 00       		.byte	0
 10146 06b3 C6       		.byte	-58
 10147 06b4 99       		.byte	-103
 10148 06b5 00       		.byte	0
 10149 06b6 00       		.byte	0
 10150 06b7 40       		.byte	64
 10151 06b8 00       		.byte	0
 10152 06b9 00       		.byte	0
 10153 06ba 0000     		.space	2
 10156              	glProbeCtrl20:
 10157 06bc 00       		.byte	0
 10158 06bd 00       		.byte	0
 10159 06be 01       		.byte	1
 10160 06bf 01       		.byte	1
 10161 06c0 80       		.byte	-128
 10162 06c1 1A       		.byte	26
 10163 06c2 06       		.byte	6
 10164 06c3 00       		.byte	0
 10165 06c4 00       		.byte	0
 10166 06c5 00       		.byte	0
 10167 06c6 00       		.byte	0
 10168 06c7 00       		.byte	0
 10169 06c8 00       		.byte	0
 10170 06c9 00       		.byte	0
 10171 06ca 00       		.byte	0
 10172 06cb 00       		.byte	0
 10173 06cc 00       		.byte	0
 10174 06cd 00       		.byte	0
 10175 06ce 00       		.byte	0
 10176 06cf D2       		.byte	-46
 10177 06d0 0F       		.byte	15
 10178 06d1 00       		.byte	0
 10179 06d2 00       		.byte	0
 10180 06d3 40       		.byte	64
 10181 06d4 00       		.byte	0
 10182 06d5 00       		.byte	0
 10183 06d6 0000     		.space	2
 10186              	glProbeCtrl:
 10187 06d8 00       		.byte	0
 10188 06d9 00       		.byte	0
 10189 06da 01       		.byte	1
 10190 06db 01       		.byte	1
 10191 06dc 15       		.byte	21
 10192 06dd 16       		.byte	22
 10193 06de 05       		.byte	5
 10194 06df 00       		.byte	0
 10195 06e0 00       		.byte	0
 10196 06e1 00       		.byte	0
 10197 06e2 00       		.byte	0
 10198 06e3 00       		.byte	0
 10199 06e4 00       		.byte	0
 10200 06e5 00       		.byte	0
 10201 06e6 00       		.byte	0
 10202 06e7 00       		.byte	0
 10203 06e8 00       		.byte	0
 10204 06e9 00       		.byte	0
 10205 06ea 00       		.byte	0
 10206 06eb 48       		.byte	72
 10207 06ec 3F       		.byte	63
 10208 06ed 00       		.byte	0
 10209 06ee 00       		.byte	0
 10210 06ef 40       		.byte	64
 10211 06f0 00       		.byte	0
 10212 06f1 00       		.byte	0
 10213 06f2 0000     		.space	2
 10216              	glProbeStilCtrl:
 10217 06f4 01       		.byte	1
 10218 06f5 02       		.byte	2
 10219 06f6 00       		.byte	0
 10220 06f7 00       		.byte	0
 10221 06f8 C6       		.byte	-58
 10222 06f9 99       		.byte	-103
 10223 06fa 00       		.byte	0
 10224 06fb 00       		.byte	0
 10225 06fc 40       		.byte	64
 10226 06fd 00       		.byte	0
 10227 06fe 00       		.byte	0
 10228 06ff 00       		.space	1
 10231              	glProbeStilCtrl20:
 10232 0700 01       		.byte	1
 10233 0701 01       		.byte	1
 10234 0702 00       		.byte	0
 10235 0703 00       		.byte	0
 10236 0704 D2       		.byte	-46
 10237 0705 0F       		.byte	15
 10238 0706 00       		.byte	0
 10239 0707 00       		.byte	0
 10240 0708 40       		.byte	64
 10241 0709 00       		.byte	0
 10242 070a 00       		.byte	0
 10245              	snapButFlag:
 10246 070b 01       		.byte	1
 10249              	CyFxGpifTransition:
 10250 070c 0000     		.short	0
 10251 070e 5555     		.short	21845
 10252 0710 8888     		.short	-30584
 10253 0712 AAAA     		.short	-21846
 10254 0714 3333     		.short	13107
 10255 0716 0000     		.space	2
 10258              	CyFxGpifWavedata:
 10259 0718 0181731E 		.word	510886145
 10260 071c 00000000 		.word	0
 10261 0720 00000080 		.word	-2147483648
 10262 0724 00000000 		.word	0
 10263 0728 00000000 		.word	0
 10264 072c 00000000 		.word	0
 10265 0730 0201702E 		.word	779092226
 10266 0734 00010000 		.word	256
 10267 0738 A0000080 		.word	-2147483488
 10268 073c 00000000 		.word	0
 10269 0740 00000000 		.word	0
 10270 0744 00000000 		.word	0
 10271 0748 0380722E 		.word	779255811
 10272 074c 02010020 		.word	536871170
 10273 0750 60000080 		.word	-2147483552
 10274 0754 00000000 		.word	0
 10275 0758 00000000 		.word	0
 10276 075c 00000000 		.word	0
 10277 0760 0460722E 		.word	779247620
 10278 0764 02010024 		.word	603980034
 10279 0768 90000080 		.word	-2147483504
 10280 076c 0594731E 		.word	510891013
 10281 0770 06000000 		.word	6
 10282 0774 00000080 		.word	-2147483648
 10283 0778 0380722E 		.word	779255811
 10284 077c 02010020 		.word	536871170
 10285 0780 60000080 		.word	-2147483552
 10286 0784 0693731E 		.word	510890758
 10287 0788 06000000 		.word	6
 10288 078c 00000080 		.word	-2147483648
 10289 0790 0720703E 		.word	1047535623
 10290 0794 08010000 		.word	264
 10291 0798 00000080 		.word	-2147483648
 10292 079c 0820703E 		.word	1047535624
 10293 07a0 08010000 		.word	264
 10294 07a4 00000080 		.word	-2147483648
 10295 07a8 0920703E 		.word	1047535625
 10296 07ac 08010000 		.word	264
 10297 07b0 00000080 		.word	-2147483648
 10298 07b4 0A20703E 		.word	1047535626
 10299 07b8 08010000 		.word	264
 10300 07bc 00000080 		.word	-2147483648
 10301 07c0 0380722E 		.word	779255811
 10302 07c4 02010020 		.word	536871170
 10303 07c8 60000080 		.word	-2147483552
 10304 07cc 0B000000 		.word	11
 10305 07d0 00000000 		.word	0
 10306 07d4 00010080 		.word	-2147483392
 10307 07d8 0460722E 		.word	779247620
 10308 07dc 02010024 		.word	603980034
 10309 07e0 90000080 		.word	-2147483504
 10310 07e4 0D000000 		.word	13
 10311 07e8 00000000 		.word	0
 10312 07ec 00010080 		.word	-2147483392
 10313 07f0 0460722E 		.word	779247620
 10314 07f4 02010024 		.word	603980034
 10315 07f8 90000080 		.word	-2147483504
 10316 07fc 0C000000 		.word	12
 10317 0800 00000000 		.word	0
 10318 0804 00010080 		.word	-2147483392
 10319 0808 0380722E 		.word	779255811
 10320 080c 02010020 		.word	536871170
 10321 0810 60000080 		.word	-2147483552
 10322 0814 0E000000 		.word	14
 10323 0818 00000000 		.word	0
 10324 081c 00010080 		.word	-2147483392
 10325 0820 00000000 		.word	0
 10326 0824 00000000 		.word	0
 10327 0828 00000000 		.word	0
 10328 082c 00000000 		.word	0
 10329 0830 00000000 		.word	0
 10330 0834 00000000 		.word	0
 10333              	CyFxGpifWavedataPosition:
 10334 0838 00       		.byte	0
 10335 0839 01       		.byte	1
 10336 083a 02       		.byte	2
 10337 083b 03       		.byte	3
 10338 083c 04       		.byte	4
 10339 083d 05       		.byte	5
 10340 083e 06       		.byte	6
 10341 083f 07       		.byte	7
 10342 0840 08       		.byte	8
 10343 0841 09       		.byte	9
 10344 0842 0A       		.byte	10
 10345 0843 0B       		.byte	11
 10346 0844 0B       		.byte	11
 10347 0845 0B       		.byte	11
 10348 0846 0B       		.byte	11
 10349 0847 00       		.space	1
 10352              	CyFxGpifRegValue:
 10353 0848 08830080 		.word	-2147450104
 10354 084c 67000000 		.word	103
 10355 0850 00000000 		.word	0
 10356 0854 46000000 		.word	70
 10357 0858 00000000 		.word	0
 10358 085c 00000000 		.word	0
 10359 0860 02000000 		.word	2
 10360 0864 82000000 		.word	130
 10361 0868 82070000 		.word	1922
 10362 086c 40040000 		.word	1088
 10363 0870 FCFF0000 		.word	65532
 10364 0874 28000000 		.word	40
 10365 0878 00000000 		.word	0
 10366 087c 00000000 		.word	0
 10367 0880 00000000 		.word	0
 10368 0884 00000000 		.word	0
 10369 0888 01000000 		.word	1
 10370 088c 00000000 		.word	0
 10371 0890 00000000 		.word	0
 10372 0894 00000000 		.word	0
 10373 0898 00000000 		.word	0
 10374 089c 00000000 		.word	0
 10375 08a0 00000000 		.word	0
 10376 08a4 00000000 		.word	0
 10377 08a8 00000000 		.word	0
 10378 08ac 00000000 		.word	0
 10379 08b0 00000000 		.word	0
 10380 08b4 00000000 		.word	0
 10381 08b8 00000000 		.word	0
 10382 08bc 06000000 		.word	6
 10383 08c0 00000000 		.word	0
 10384 08c4 FFFF0000 		.word	65535
 10385 08c8 09010000 		.word	265
 10386 08cc 00000000 		.word	0
 10387 08d0 F71F0000 		.word	8183
 10388 08d4 00000000 		.word	0
 10389 08d8 FFFF0000 		.word	65535
 10390 08dc 09010000 		.word	265
 10391 08e0 00000000 		.word	0
 10392 08e4 F71F0000 		.word	8183
 10393 08e8 00000000 		.word	0
 10394 08ec 00000000 		.word	0
 10395 08f0 00000000 		.word	0
 10396 08f4 00000000 		.word	0
 10397 08f8 00000000 		.word	0
 10398 08fc 00000000 		.word	0
 10399 0900 00000000 		.word	0
 10400 0904 00000000 		.word	0
 10401 0908 00000000 		.word	0
 10402 090c 00000000 		.word	0
 10403 0910 00000000 		.word	0
 10404 0914 00000000 		.word	0
 10405 0918 00000000 		.word	0
 10406 091c 00000000 		.word	0
 10407 0920 00000000 		.word	0
 10408 0924 00000000 		.word	0
 10409 0928 00000000 		.word	0
 10410 092c 00000000 		.word	0
 10411 0930 00000000 		.word	0
 10412 0934 00000000 		.word	0
 10413 0938 00000000 		.word	0
 10414 093c 00000000 		.word	0
 10415 0940 00000000 		.word	0
 10416 0944 00040180 		.word	-2147417088
 10417 0948 01040180 		.word	-2147417087
 10418 094c 02040180 		.word	-2147417086
 10419 0950 03040180 		.word	-2147417085
 10420 0954 00000000 		.word	0
 10421 0958 00000000 		.word	0
 10422 095c 00000000 		.word	0
 10423 0960 00000000 		.word	0
 10424 0964 00000000 		.word	0
 10425 0968 00000000 		.word	0
 10426 096c 00000000 		.word	0
 10427 0970 00000000 		.word	0
 10428 0974 C1FFFFFF 		.word	-63
 10431              	CyFxGpifTransition_usb2:
 10432 0978 0000     		.short	0
 10433 097a 5555     		.short	21845
 10434 097c AAAA     		.short	-21846
 10435 097e 8888     		.short	-30584
 10436 0980 1111     		.short	4369
 10437 0982 4444     		.short	17476
 10438 0984 3333     		.short	13107
 10439 0986 CCCC     		.short	-13108
 10442              	CyFxGpifWavedata_usb2:
 10443 0988 0181731E 		.word	510886145
 10444 098c 00000000 		.word	0
 10445 0990 00000080 		.word	-2147483648
 10446 0994 00000000 		.word	0
 10447 0998 00000000 		.word	0
 10448 099c 00000000 		.word	0
 10449 09a0 0201703E 		.word	1047527682
 10450 09a4 00010000 		.word	256
 10451 09a8 A00000C0 		.word	-1073741664
 10452 09ac 00000000 		.word	0
 10453 09b0 00000000 		.word	0
 10454 09b4 00000000 		.word	0
 10455 09b8 0394731E 		.word	510891011
 10456 09bc 04000020 		.word	536870916
 10457 09c0 60004080 		.word	-2143289248
 10458 09c4 00000000 		.word	0
 10459 09c8 00000000 		.word	0
 10460 09cc 00000000 		.word	0
 10461 09d0 0620702E 		.word	779100166
 10462 09d4 0C000000 		.word	12
 10463 09d8 00000080 		.word	-2147483648
 10464 09dc 0620702E 		.word	779100166
 10465 09e0 0C000000 		.word	12
 10466 09e4 00000080 		.word	-2147483648
 10467 09e8 0394731E 		.word	510891011
 10468 09ec 04000020 		.word	536870916
 10469 09f0 60004080 		.word	-2143289248
 10470 09f4 0620702E 		.word	779100166
 10471 09f8 0C000000 		.word	12
 10472 09fc 00000080 		.word	-2147483648
 10473 0a00 0C93731E 		.word	510890764
 10474 0a04 04000024 		.word	603979780
 10475 0a08 90004080 		.word	-2143289200
 10476 0a0c 0D20702E 		.word	779100173
 10477 0a10 0C000000 		.word	12
 10478 0a14 00000080 		.word	-2147483648
 10479 0a18 0780724E 		.word	1316126727
 10480 0a1c 0A000000 		.word	10
 10481 0a20 00000080 		.word	-2147483648
 10482 0a24 08000000 		.word	8
 10483 0a28 00000000 		.word	0
 10484 0a2c 00010080 		.word	-2147483392
 10485 0a30 0920702E 		.word	779100169
 10486 0a34 0C010000 		.word	268
 10487 0a38 00000080 		.word	-2147483648
 10488 0a3c 0A01701E 		.word	510656778
 10489 0a40 0E000100 		.word	65550
 10490 0a44 00000080 		.word	-2147483648
 10491 0a48 00000000 		.word	0
 10492 0a4c 00000000 		.word	0
 10493 0a50 00000000 		.word	0
 10494 0a54 00000000 		.word	0
 10495 0a58 00000000 		.word	0
 10496 0a5c 00000000 		.word	0
 10497 0a60 0394731E 		.word	510891011
 10498 0a64 04000020 		.word	536870916
 10499 0a68 60004080 		.word	-2143289248
 10500 0a6c 08000000 		.word	8
 10501 0a70 00000000 		.word	0
 10502 0a74 00010080 		.word	-2147483392
 10503 0a78 0B000000 		.word	11
 10504 0a7c 00000000 		.word	0
 10505 0a80 00010080 		.word	-2147483392
 10506 0a84 0C93731E 		.word	510890764
 10507 0a88 04000024 		.word	603979780
 10508 0a8c 90004080 		.word	-2143289200
 10509 0a90 0D20702E 		.word	779100173
 10510 0a94 0C000000 		.word	12
 10511 0a98 00000080 		.word	-2147483648
 10512 0a9c 0D20702E 		.word	779100173
 10513 0aa0 0C000000 		.word	12
 10514 0aa4 00000080 		.word	-2147483648
 10515 0aa8 0E60724E 		.word	1316118542
 10516 0aac 0A000000 		.word	10
 10517 0ab0 00000080 		.word	-2147483648
 10518 0ab4 0F000000 		.word	15
 10519 0ab8 00000000 		.word	0
 10520 0abc 00010080 		.word	-2147483392
 10521 0ac0 1020702E 		.word	779100176
 10522 0ac4 0C010000 		.word	268
 10523 0ac8 00000080 		.word	-2147483648
 10524 0acc 1101701E 		.word	510656785
 10525 0ad0 0E000100 		.word	65550
 10526 0ad4 00000080 		.word	-2147483648
 10527 0ad8 0C93731E 		.word	510890764
 10528 0adc 04000024 		.word	603979780
 10529 0ae0 90004080 		.word	-2143289200
 10530 0ae4 0F000000 		.word	15
 10531 0ae8 00000000 		.word	0
 10532 0aec 00010080 		.word	-2147483392
 10533 0af0 12000000 		.word	18
 10534 0af4 00000000 		.word	0
 10535 0af8 00010080 		.word	-2147483392
 10536 0afc 0394731E 		.word	510891011
 10537 0b00 04000020 		.word	536870916
 10538 0b04 60004080 		.word	-2143289248
 10539 0b08 0480732E 		.word	779321348
 10540 0b0c 02010000 		.word	258
 10541 0b10 0000C0C0 		.word	-1061158912
 10542 0b14 0580732E 		.word	779321349
 10543 0b18 02010000 		.word	258
 10544 0b1c 0000C0C0 		.word	-1061158912
 10545 0b20 0580732E 		.word	779321349
 10546 0b24 02010000 		.word	258
 10547 0b28 0000C0C0 		.word	-1061158912
 10548 0b2c 0480732E 		.word	779321348
 10549 0b30 02010000 		.word	258
 10550 0b34 0000C0C0 		.word	-1061158912
 10553              	CyFxGpifWavedataPosition_usb2:
 10554 0b38 00       		.byte	0
 10555 0b39 01       		.byte	1
 10556 0b3a 02       		.byte	2
 10557 0b3b 03       		.byte	3
 10558 0b3c 04       		.byte	4
 10559 0b3d 05       		.byte	5
 10560 0b3e 06       		.byte	6
 10561 0b3f 07       		.byte	7
 10562 0b40 08       		.byte	8
 10563 0b41 09       		.byte	9
 10564 0b42 0A       		.byte	10
 10565 0b43 08       		.byte	8
 10566 0b44 0B       		.byte	11
 10567 0b45 0C       		.byte	12
 10568 0b46 0D       		.byte	13
 10569 0b47 08       		.byte	8
 10570 0b48 0E       		.byte	14
 10571 0b49 0F       		.byte	15
 10572 0b4a 08       		.byte	8
 10573 0b4b 08       		.byte	8
 10574 0b4c 08       		.byte	8
 10575 0b4d 08       		.byte	8
 10576 0b4e 08       		.byte	8
 10577 0b4f 08       		.byte	8
 10578 0b50 08       		.byte	8
 10579 0b51 08       		.byte	8
 10580 0b52 08       		.byte	8
 10581 0b53 08       		.byte	8
 10582 0b54 08       		.byte	8
 10583 0b55 08       		.byte	8
 10584 0b56 08       		.byte	8
 10585 0b57 08       		.byte	8
 10586 0b58 08       		.byte	8
 10587 0b59 08       		.byte	8
 10588 0b5a 08       		.byte	8
 10589 0b5b 08       		.byte	8
 10590 0b5c 08       		.byte	8
 10591 0b5d 08       		.byte	8
 10592 0b5e 08       		.byte	8
 10593 0b5f 08       		.byte	8
 10594 0b60 08       		.byte	8
 10595 0b61 08       		.byte	8
 10596 0b62 08       		.byte	8
 10597 0b63 08       		.byte	8
 10598 0b64 08       		.byte	8
 10599 0b65 08       		.byte	8
 10600 0b66 08       		.byte	8
 10601 0b67 08       		.byte	8
 10602 0b68 08       		.byte	8
 10603 0b69 08       		.byte	8
 10604 0b6a 08       		.byte	8
 10605 0b6b 08       		.byte	8
 10606 0b6c 08       		.byte	8
 10607 0b6d 08       		.byte	8
 10608 0b6e 08       		.byte	8
 10609 0b6f 08       		.byte	8
 10610 0b70 08       		.byte	8
 10611 0b71 08       		.byte	8
 10612 0b72 08       		.byte	8
 10613 0b73 08       		.byte	8
 10614 0b74 08       		.byte	8
 10615 0b75 08       		.byte	8
 10616 0b76 08       		.byte	8
 10617 0b77 08       		.byte	8
 10618 0b78 08       		.byte	8
 10619 0b79 08       		.byte	8
 10620 0b7a 08       		.byte	8
 10621 0b7b 08       		.byte	8
 10622 0b7c 08       		.byte	8
 10623 0b7d 08       		.byte	8
 10624 0b7e 08       		.byte	8
 10625 0b7f 08       		.byte	8
 10626 0b80 08       		.byte	8
 10627 0b81 08       		.byte	8
 10628 0b82 08       		.byte	8
 10629 0b83 08       		.byte	8
 10630 0b84 08       		.byte	8
 10631 0b85 08       		.byte	8
 10632 0b86 08       		.byte	8
 10633 0b87 08       		.byte	8
 10634 0b88 08       		.byte	8
 10635 0b89 08       		.byte	8
 10636 0b8a 08       		.byte	8
 10637 0b8b 08       		.byte	8
 10638 0b8c 08       		.byte	8
 10639 0b8d 08       		.byte	8
 10640 0b8e 08       		.byte	8
 10641 0b8f 08       		.byte	8
 10642 0b90 08       		.byte	8
 10643 0b91 08       		.byte	8
 10644 0b92 08       		.byte	8
 10645 0b93 08       		.byte	8
 10646 0b94 08       		.byte	8
 10647 0b95 08       		.byte	8
 10648 0b96 08       		.byte	8
 10649 0b97 08       		.byte	8
 10650 0b98 08       		.byte	8
 10651 0b99 08       		.byte	8
 10652 0b9a 08       		.byte	8
 10653 0b9b 08       		.byte	8
 10654 0b9c 08       		.byte	8
 10655 0b9d 08       		.byte	8
 10656 0b9e 08       		.byte	8
 10657 0b9f 08       		.byte	8
 10658 0ba0 08       		.byte	8
 10659 0ba1 08       		.byte	8
 10660 0ba2 08       		.byte	8
 10661 0ba3 08       		.byte	8
 10662 0ba4 08       		.byte	8
 10663 0ba5 08       		.byte	8
 10664 0ba6 08       		.byte	8
 10665 0ba7 08       		.byte	8
 10666 0ba8 08       		.byte	8
 10667 0ba9 08       		.byte	8
 10668 0baa 08       		.byte	8
 10669 0bab 08       		.byte	8
 10670 0bac 08       		.byte	8
 10671 0bad 08       		.byte	8
 10672 0bae 08       		.byte	8
 10673 0baf 08       		.byte	8
 10674 0bb0 08       		.byte	8
 10675 0bb1 08       		.byte	8
 10676 0bb2 08       		.byte	8
 10677 0bb3 08       		.byte	8
 10678 0bb4 08       		.byte	8
 10679 0bb5 08       		.byte	8
 10680 0bb6 08       		.byte	8
 10681 0bb7 08       		.byte	8
 10682 0bb8 00       		.byte	0
 10683 0bb9 01       		.byte	1
 10684 0bba 02       		.byte	2
 10685 0bbb 10       		.byte	16
 10686 0bbc 04       		.byte	4
 10687 0bbd 05       		.byte	5
 10688 0bbe 06       		.byte	6
 10689 0bbf 07       		.byte	7
 10690 0bc0 08       		.byte	8
 10691 0bc1 09       		.byte	9
 10692 0bc2 0A       		.byte	10
 10693 0bc3 08       		.byte	8
 10694 0bc4 11       		.byte	17
 10695 0bc5 0C       		.byte	12
 10696 0bc6 0D       		.byte	13
 10697 0bc7 08       		.byte	8
 10698 0bc8 0E       		.byte	14
 10699 0bc9 0F       		.byte	15
 10700 0bca 08       		.byte	8
 10701 0bcb 00       		.space	1
 10704              	CyFxGpifRegValue_usb2:
 10705 0bcc 08830080 		.word	-2147450104
 10706 0bd0 67000000 		.word	103
 10707 0bd4 01000000 		.word	1
 10708 0bd8 46000000 		.word	70
 10709 0bdc 00000000 		.word	0
 10710 0be0 00000000 		.word	0
 10711 0be4 02000000 		.word	2
 10712 0be8 82000000 		.word	130
 10713 0bec 82070000 		.word	1922
 10714 0bf0 40040000 		.word	1088
 10715 0bf4 FCFF0000 		.word	65532
 10716 0bf8 28000000 		.word	40
 10717 0bfc 00000000 		.word	0
 10718 0c00 00000000 		.word	0
 10719 0c04 00000000 		.word	0
 10720 0c08 00000000 		.word	0
 10721 0c0c 01000000 		.word	1
 10722 0c10 00000000 		.word	0
 10723 0c14 00000000 		.word	0
 10724 0c18 00000000 		.word	0
 10725 0c1c 00000000 		.word	0
 10726 0c20 00000000 		.word	0
 10727 0c24 00000000 		.word	0
 10728 0c28 00000000 		.word	0
 10729 0c2c 00000000 		.word	0
 10730 0c30 00000000 		.word	0
 10731 0c34 00000000 		.word	0
 10732 0c38 00000000 		.word	0
 10733 0c3c 00000000 		.word	0
 10734 0c40 06000000 		.word	6
 10735 0c44 00000000 		.word	0
 10736 0c48 FFFF0000 		.word	65535
 10737 0c4c 09010000 		.word	265
 10738 0c50 00000000 		.word	0
 10739 0c54 F71F0000 		.word	8183
 10740 0c58 00000000 		.word	0
 10741 0c5c FFFF0000 		.word	65535
 10742 0c60 09010000 		.word	265
 10743 0c64 00000000 		.word	0
 10744 0c68 F71F0000 		.word	8183
 10745 0c6c 00000000 		.word	0
 10746 0c70 00000000 		.word	0
 10747 0c74 00000000 		.word	0
 10748 0c78 00000000 		.word	0
 10749 0c7c 00000000 		.word	0
 10750 0c80 00000000 		.word	0
 10751 0c84 00000000 		.word	0
 10752 0c88 00000000 		.word	0
 10753 0c8c 00000000 		.word	0
 10754 0c90 00000000 		.word	0
 10755 0c94 00000000 		.word	0
 10756 0c98 00000000 		.word	0
 10757 0c9c 00000000 		.word	0
 10758 0ca0 00000000 		.word	0
 10759 0ca4 00000000 		.word	0
 10760 0ca8 00000000 		.word	0
 10761 0cac 00000000 		.word	0
 10762 0cb0 00000000 		.word	0
 10763 0cb4 00000000 		.word	0
 10764 0cb8 00000000 		.word	0
 10765 0cbc 00000000 		.word	0
 10766 0cc0 00000000 		.word	0
 10767 0cc4 00000000 		.word	0
 10768 0cc8 00040180 		.word	-2147417088
 10769 0ccc 01040180 		.word	-2147417087
 10770 0cd0 02040180 		.word	-2147417086
 10771 0cd4 03040180 		.word	-2147417085
 10772 0cd8 00000000 		.word	0
 10773 0cdc 00000000 		.word	0
 10774 0ce0 00000000 		.word	0
 10775 0ce4 00000000 		.word	0
 10776 0ce8 00000000 		.word	0
 10777 0cec 00000000 		.word	0
 10778 0cf0 00000000 		.word	0
 10779 0cf4 00000000 		.word	0
 10780 0cf8 C1FFFFFF 		.word	-63
 10781              		.section	.rodata.str1.4,"aMS",%progbits,1
 10782              		.align	2
 10783              	.LC0:
 10784 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 10784      7065722D 
 10784      74696D65 
 10784      72202564 
 10784      0D0A00
 10785 0013 00       		.space	1
 10786              	.LC1:
 10787 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 10787      636F6D6D 
 10787      616E6420 
 10787      71756575 
 10787      65206973 
 10788 0037 00       		.space	1
 10789              	.LC2:
 10790 0038 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 10790      5420656E 
 10790      636F756E 
 10790      74657265 
 10790      642E2E2E 
 10791              	.LC3:
 10792 0058 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 10792      454E4420 
 10792      656E636F 
 10792      756E7465 
 10792      7265642E 
 10793 007a 0000     		.space	2
 10794              	.LC4:
 10795 007c 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 10795      64697363 
 10795      6F6E6E65 
 10795      63746564 
 10795      2E2E2E30 
 10796 009b 00       		.space	1
 10797              	.LC5:
 10798 009c 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 10798      7220696E 
 10798      206D756C 
 10798      74696368 
 10798      616E6E65 
 10799 00cf 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 10799      2025782C 
 10799      20646D61 
 10799      446F6E65 
 10799      20256420 
 10800              	.LC6:
 10801 00e8 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 10801      43595F46 
 10801      585F5556 
 10801      435F5649 
 10801      44454F5F 
 10802 011b 0A00     		.ascii	"\012\000"
 10803 011d 000000   		.space	3
 10804              	.LC7:
 10805 0120 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 10805      43595F46 
 10805      585F5556 
 10805      435F5649 
 10805      44454F5F 
 10806 0153 00       		.ascii	"\000"
 10807              	.LC8:
 10808 0154 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 10808      726E6174 
 10808      65207365 
 10808      7474696E 
 10808      6720302E 
 10809              	.LC9:
 10810 016c 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 10810      72206665 
 10810      61747572 
 10810      65207265 
 10810      71756573 
 10811 018f 00       		.space	1
 10812              	.LC10:
 10813 0190 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 10813      6F6D6D69 
 10813      74656F66 
 10813      20737461 
 10813      7465203D 
 10814              	.LC11:
 10815 01a8 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 10815      6E656C20 
 10815      53657420 
 10815      57726170 
 10815      55702066 
 10816 01d5 000000   		.space	3
 10817              	.LC12:
 10818 01d8 4572726F 		.ascii	"Error handler...\015\012\000"
 10818      72206861 
 10818      6E646C65 
 10818      722E2E2E 
 10818      0D0A00
 10819 01eb 00       		.space	1
 10820              	.LC13:
 10821 01ec 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 10821      69742045 
 10821      4F462066 
 10821      61696C65 
 10821      64210D0A 
 10822 0201 000000   		.space	3
 10823              	.LC14:
 10824 0204 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 10824      49324320 
 10824      636F6D6D 
 10824      616E6420 
 10824      69732030 
 10825 0237 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 10825      78257820 
 10825      30782578 
 10825      20307825 
 10825      78203078 
 10826              	.LC15:
 10827 0250 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 10827      49324320 
 10827      636F6D6D 
 10827      616E6420 
 10827      73657474 
 10828 0276 0000     		.space	2
 10829              	.LC16:
 10830 0278 54686520 		.ascii	"The shutter set value %d 0x%x 0x%x 0x%x\015\012\000"
 10830      73687574 
 10830      74657220 
 10830      73657420 
 10830      76616C75 
 10831 02a2 0000     		.space	2
 10832              	.LC17:
 10833 02a4 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 10833      206C6967 
 10833      68742063 
 10833      6F6D7065 
 10833      6E736174 
 10834 02d7 25640D0A 		.ascii	"%d\015\012\000"
 10834      00
 10835              	.LC18:
 10836 02dc 54686520 		.ascii	"The I2C current data is not available. try again. %"
 10836      49324320 
 10836      63757272 
 10836      656E7420 
 10836      64617461 
 10837 030f 64202564 		.ascii	"d %d\015\012\000"
 10837      0D0A00
 10838 0316 0000     		.space	2
 10839              	.LC19:
 10840 0318 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 10840      26414743 
 10840      2073656E 
 10840      7420746F 
 10840      20686F73 
 10841 033e 0000     		.space	2
 10842              	.LC20:
 10843 0340 54686520 		.ascii	"The shutter&exposure 0x%x 0x%x 0x%x 0x%x\015\012\000"
 10843      73687574 
 10843      74657226 
 10843      6578706F 
 10843      73757265 
 10844 036b 00       		.space	1
 10845              	.LC21:
 10846 036c 4578704D 		.ascii	"ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\015"
 10846      26414743 
 10846      20676F74 
 10846      74656E20 
 10846      66726F6D 
 10847 039d 0A00     		.ascii	"\012\000"
 10848 039f 00       		.space	1
 10849              	.LC22:
 10850 03a0 53687574 		.ascii	"Shutter level gotten from host. 0x%x %d; 0x%x 0x%x "
 10850      74657220 
 10850      6C657665 
 10850      6C20676F 
 10850      7474656E 
 10851 03d3 25640D0A 		.ascii	"%d\015\012\000"
 10851      00
 10852              	.LC23:
 10853 03d8 46536574 		.ascii	"FSet the video mode format %x %d\012\000"
 10853      20746865 
 10853      20766964 
 10853      656F206D 
 10853      6F646520 
 10854 03fa 0000     		.space	2
 10855              	.LC24:
 10856 03fc 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 10856      67657420 
 10856      64617461 
 10856      2066726F 
 10856      6D20686F 
 10857 0429 000000   		.space	3
 10858              	.LC25:
 10859 042c 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 10859      52657175 
 10859      65737420 
 10859      30782578 
 10859      20706172 
 10860 045f 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 10860      6E642074 
 10860      6F20686F 
 10860      73742030 
 10860      78257820 
 10861 047a 0000     		.space	2
 10862              	.LC26:
 10863 047c 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 10863      204F7020 
 10863      72656365 
 10863      69766573 
 10863      20284354 
 10864 04a3 00       		.space	1
 10865              	.LC27:
 10866 04a4 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 10866      756C7420 
 10866      73656C65 
 10866      63746F72 
 10866      20284354 
 10867 04c6 0000     		.space	2
 10868              	.LC28:
 10869 04c8 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 10869      756C7420 
 10869      72657175 
 10869      65737420 
 10869      28435429 
 10870 04e9 000000   		.space	3
 10871              	.LC29:
 10872 04ec 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 10872      52657175 
 10872      65737420 
 10872      30782578 
 10872      20706172 
 10873 051f 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 10873      20307825 
 10873      78202F20 
 10873      73656E64 
 10873      20746F20 
 10874 054c 00       		.ascii	"\000"
 10875 054d 000000   		.space	3
 10876              	.LC30:
 10877 0550 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 10877      73706565 
 10877      64203D20 
 10877      25642065 
 10877      76656E66 
 10878 0580 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 10878      71756573 
 10878      74203D20 
 10878      30782578 
 10878      20775661 
 10879 05b0 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 10879      203D2030 
 10879      78257820 
 10879      6973666C 
 10879      61672030 
 10880 05ca 0000     		.space	2
 10881              	.LC31:
 10882 05cc 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 10882      64656661 
 10882      756C7420 
 10882      73657475 
 10882      70207265 
 10883              	.LC32:
 10884 05f8 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 10884      6F207374 
 10884      7265616D 
 10884      20474554 
 10884      20726571 
 10885 061d 000000   		.space	3
 10886              	.LC33:
 10887 0620 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 10887      74686520 
 10887      76696465 
 10887      6F206D6F 
 10887      64652066 
 10888 0641 000000   		.space	3
 10889              	.LC34:
 10890 0644 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 10890      74686520 
 10890      76696465 
 10890      6F206D6F 
 10890      64652066 
 10891 0669 000000   		.space	3
 10892              	.LC35:
 10893 066c 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 10893      43595F46 
 10893      585F5556 
 10893      435F5354 
 10893      5245414D 
 10894 0692 0000     		.space	2
 10895              	.LC36:
 10896 0694 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 10896      55564320 
 10896      7374696C 
 10896      6C205072 
 10896      6F622873 
 10897 06bf 00       		.space	1
 10898              	.LC37:
 10899 06c0 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 10899      74686520 
 10899      7374696C 
 10899      6C206D6F 
 10899      64652066 
 10900 06e1 000000   		.space	3
 10901              	.LC38:
 10902 06e4 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 10902      7374696C 
 10902      6C20636F 
 10902      6D6D6974 
 10902      20636F6E 
 10903              	.LC39:
 10904 070c 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 10904      43595F46 
 10904      585F5556 
 10904      435F5354 
 10904      494C5F45 
 10905              	.LC40:
 10906 0730 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 10906      55564320 
 10906      7374696C 
 10906      6C207472 
 10906      69676765 
 10907 0759 000000   		.space	3
 10908              	.LC41:
 10909 075c 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 10909      7374696C 
 10909      6C207472 
 10909      69676765 
 10909      7220636F 
 10910 0783 00       		.space	1
 10911              	.LC42:
 10912 0784 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 10912      65642074 
 10912      6F207365 
 10912      6E642069 
 10912      6E746572 
 10913 07b5 0A00     		.ascii	"\012\000"
 10914 07b7 00       		.space	1
 10915              	.LC43:
 10916 07b8 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 10916      73657420 
 10916      64656620 
 10916      64617461 
 10916      20307825 
 10917 07d7 00       		.space	1
 10918              	.LC44:
 10919 07d8 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 10919      73657420 
 10919      64656620 
 10919      64617461 
 10919      20307825 
 10920 080b 2E0D0A00 		.ascii	".\015\012\000"
 10921 080f 00       		.space	1
 10922              	.LC45:
 10923 0810 55415254 		.ascii	"UART initialization failed!\012\000"
 10923      20696E69 
 10923      7469616C 
 10923      697A6174 
 10923      696F6E20 
 10924 082d 000000   		.space	3
 10925              	.LC46:
 10926 0830 49324320 		.ascii	"I2C initialization failed!\012\000"
 10926      696E6974 
 10926      69616C69 
 10926      7A617469 
 10926      6F6E2066 
 10927              	.LC47:
 10928 084c 49324320 		.ascii	"I2C configuration failed!\012\000"
 10928      636F6E66 
 10928      69677572 
 10928      6174696F 
 10928      6E206661 
 10929 0867 00       		.space	1
 10930              	.LC48:
 10931 0868 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 10931      43726561 
 10931      74652045 
 10931      76656E74 
 10931      20666169 
 10932 0892 0000     		.space	2
 10933              	.LC49:
 10934 0894 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 10934      20496E69 
 10934      74206661 
 10934      696C6564 
 10934      2C204572 
 10935 08b7 00       		.space	1
 10936              	.LC50:
 10937 08b8 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 10937      204F7665 
 10937      72726964 
 10937      65206661 
 10937      696C6564 
 10938 08df 00       		.space	1
 10939              	.LC51:
 10940 08e0 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 10940      28323029 
 10940      204F7665 
 10940      72726964 
 10940      65206661 
 10941 090b 00       		.space	1
 10942              	.LC52:
 10943 090c 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 10943      28323429 
 10943      204F7665 
 10943      72726964 
 10943      65206661 
 10944 0937 00       		.space	1
 10945              	.LC53:
 10946 0938 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 10946      20536574 
 10946      20287265 
 10946      73657420 
 10946      32322920 
 10947 096a 00       		.ascii	"\000"
 10948 096b 00       		.space	1
 10949              	.LC54:
 10950 096c 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 10950      20536574 
 10950      2028706F 
 10950      77657220 
 10950      32302920 
 10951 099e 00       		.ascii	"\000"
 10952 099f 00       		.space	1
 10953              	.LC55:
 10954 09a0 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 10954      20536574 
 10954      2028736E 
 10954      61702073 
 10954      686F7420 
 10955 09d3 25640A00 		.ascii	"%d\012\000"
 10956 09d7 00       		.space	1
 10957              	.LC56:
 10958 09d8 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 10958      46756E63 
 10958      74696F6E 
 10958      20466169 
 10958      6C656420 
 10959 0a07 00       		.space	1
 10960              	.LC57:
 10961 0a08 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 10961      46756E63 
 10961      74696F6E 
 10961      20466169 
 10961      6C656420 
 10962 0a37 00       		.space	1
 10963              	.LC58:
 10964 0a38 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 10964      53657420 
 10964      456E6470 
 10964      6F696E74 
 10964      20636F6E 
 10965 0a68 00       		.ascii	"\000"
 10966 0a69 000000   		.space	3
 10967              	.LC59:
 10968 0a6c 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 10968      496E7465 
 10968      72727570 
 10968      74205374 
 10968      61747573 
 10969 0a9f 20436F64 		.ascii	" Code = %d\012\000"
 10969      65203D20 
 10969      25640A00 
 10970 0aab 00       		.space	1
 10971              	.LC60:
 10972 0aac 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 10972      65642074 
 10972      6F20616C 
 10972      6C6F6361 
 10972      7465206D 
 10973 0adf 65720D0A 		.ascii	"er\015\012\000"
 10973      00
 10974              	.LC61:
 10975 0ae4 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 10975      4368616E 
 10975      6E656C20 
 10975      43726561 
 10975      74696F6E 
 10976 0b12 0000     		.space	2
 10977              	.LC62:
 10978 0b14 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 10978      436F6E6E 
 10978      65637420 
 10978      6661696C 
 10978      65642C20 
 10979 0b39 000000   		.space	3
 10980              	.LC63:
 10981 0b3c 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 10981      74686520 
 10981      76696465 
 10981      6F206D6F 
 10981      64652066 
 10982 0b5e 0000     		.space	2
 10983              	.LC64:
 10984 0b60 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 10984      4368616E 
 10984      6E656C20 
 10984      52657365 
 10984      74204661 
 10985 0b8b 00       		.space	1
 10986              	.LC65:
 10987 0b8c 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 10987      4368616E 
 10987      6E656C20 
 10987      53657420 
 10987      5472616E 
 10988 0bbd 00       		.ascii	"\000"
 10989 0bbe 0000     		.space	2
 10990              	.LC66:
 10991 0bc0 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 10991      4368616E 
 10991      6E656C20 
 10991      53657420 
 10991      5472616E 
 10992 0bf1 0A00     		.ascii	"\012\000"
 10993 0bf3 00       		.space	1
 10994              	.LC67:
 10995 0bf4 0D0A2073 		.ascii	"\015\012 super gpif\000"
 10995      75706572 
 10995      20677069 
 10995      6600
 10996 0c02 0000     		.space	2
 10997              	.LC68:
 10998 0c04 0D0A2068 		.ascii	"\015\012 high gpif\000"
 10998      69676820 
 10998      67706966 
 10998      00
 10999 0c11 000000   		.space	3
 11000              	.LC69:
 11001 0c14 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 11001      696E6720 
 11001      47504946 
 11001      20436F6E 
 11001      66696775 
 11002 0c47 0A00     		.ascii	"\012\000"
 11003 0c49 000000   		.space	3
 11004              	.LC70:
 11005 0c4c 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 11005      74696E67 
 11005      20475049 
 11005      46207374 
 11005      61746520 
 11006 0c7f 0D0A00   		.ascii	"\015\012\000"
 11007 0c82 0000     		.space	2
 11008              	.LC71:
 11009 0c84 33303A55 		.ascii	"30:UVC App Thread\000"
 11009      56432041 
 11009      70702054 
 11009      68726561 
 11009      6400
 11010 0c96 0000     		.space	2
 11011              	.LC72:
 11012 0c98 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 11012      56432041 
 11012      70702045 
 11012      50302054 
 11012      68726561 
 11013 0cae 0000     		.space	2
 11014              	.LC73:
 11015 0cb0 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 11015      32432041 
 11015      70702043 
 11015      54524C20 
 11015      54687265 
 11016 0cc7 00       		.bss
 11017              		.align	2
 11018              		.set	.LANCHOR0,. + 0
 11021              	glFxUVCEvent:
 11022 0000 00000000 		.space	40
 11022      00000000 
 11022      00000000 
 11022      00000000 
 11022      00000000 
 11025              	gpif_initialized:
 11026 0028 00000000 		.space	4
 11029              	streamingStarted:
 11030 002c 00000000 		.space	4
 11033              	isUsbConnected:
 11034 0030 00000000 		.space	4
 11037              	fb:
 11038 0034 0000     		.space	2
 11041              	pb:
 11042 0036 0000     		.space	2
 11045              	pbc:
 11046 0038 0000     		.space	2
 11049              	stiflag:
 11050 003a 00       		.space	1
 11051 003b 00       		.space	1
 11054              	hitFV:
 11055 003c 00000000 		.space	4
 11058              	prodCount:
 11059 0040 0000     		.space	2
 11062              	consCount:
 11063 0042 0000     		.space	2
 11066              	clearFeatureRqtReceived:
 11067 0044 00000000 		.space	4
 11070              	usbSpeed:
 11071 0048 00       		.space	1
 11072 0049 000000   		.space	3
 11075              	I2CCMDArry:
 11076 004c 00000000 		.space	12
 11076      00000000 
 11076      00000000 
 11079              	is60Hz:
 11080 0058 00000000 		.space	4
 11083              	glEp0Buffer:
 11084 005c 00000000 		.space	32
 11084      00000000 
 11084      00000000 
 11084      00000000 
 11084      00000000 
 11087              	CamMode:
 11088 007c 00       		.space	1
 11091              	setRes:
 11092 007d 00       		.space	1
 11093 007e 0000     		.space	2
 11096              	glCommitCtrl:
 11097 0080 00000000 		.space	32
 11097      00000000 
 11097      00000000 
 11097      00000000 
 11097      00000000 
 11100              	setstilRes:
 11101 00a0 00       		.space	1
 11104              	IMcount.7853:
 11105 00a1 00       		.space	1
 11106 00a2 0000     		.space	2
 11109              	uvcAppThread:
 11110 00a4 00000000 		.space	168
 11110      00000000 
 11110      00000000 
 11110      00000000 
 11110      00000000 
 11113              	uvcAppEP0Thread:
 11114 014c 00000000 		.space	168
 11114      00000000 
 11114      00000000 
 11114      00000000 
 11114      00000000 
 11117              	i2cAppThread:
 11118 01f4 00000000 		.space	168
 11118      00000000 
 11118      00000000 
 11118      00000000 
 11118      00000000 
 11121              	testSnap:
 11122 029c 00       		.space	1
 11123 029d 00       		.space	1
 11126              	fbbak:
 11127 029e 0000     		.space	2
 11130              	pbbak:
 11131 02a0 0000     		.space	2
 11134              	pbcbak:
 11135 02a2 0000     		.space	2
 11138              	pbcpbak:
 11139 02a4 0000     		.space	2
 11140 02a6 0000     		.text
 11141              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:184    .text:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:190    .text:00000158 $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:291    .text:0000021c $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:305    .text:0000023c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:302    .text:0000023c $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:324    .text:0000024c $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:328    .text:00000250 $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:330    .text:00000250 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:509    .text:000003b0 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:518    .text:000003c0 $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:521    .text:000003c0 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:743    .text:00000560 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:753    .text:0000057c $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:755    .text:0000057c CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:1080   .text:00000844 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:1096   .text:00000870 $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:1099   .text:00000870 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:1136   .text:000008a8 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:1149   .text:000008d4 $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:1196   .text:00000928 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:1203   .text:00000938 $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:1221   .text:00000954 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:1230   .text:0000096c $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:1233   .text:0000096c I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:1461   .text:00000bb8 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:1469   .text:00000bcc $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:1472   .text:00000bcc setIrisauto
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:1535   .text:00000c4c getShutCtrl
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:1558   .text:00000c64 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:1571   .text:00000c8c $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:1677   .text:00000d80 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:1685   .text:00000d94 $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:1688   .text:00000d94 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:1902   .text:00000f3c $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:1944   .text:00000fd8 $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:2008   .text:00001058 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:2049   .text:000010f4 $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:3375   .text:00001ce4 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:3397   .text:00001d30 $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:3604   .text:00001f10 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:3610   .text:00001f20 $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:3816   .text:00002168 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:3984   .text:000022c4 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:3997   .text:000022ec $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:4492   .text:000027fc $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:4503   .text:0000281c $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:4765   .text:00002ad8 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:4778   .text:00002b00 $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:4781   .text:00002b00 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:4843   .text:00002b7c $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:4851   .text:00002b8c $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:5284   .text:00002fc4 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:5291   .text:00002fd4 $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:5767   .text:000033cc $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:5774   .text:000033dc $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:6294   .text:00003870 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:6329   .text:000038e8 $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:6332   .text:000038e8 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:6623   .text:00003ba0 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:6630   .text:00003bb0 $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:6633   .text:00003bb0 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:6674   .text:00003bf4 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:6679   .text:00003bfc $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:6682   .text:00003bfc CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:6707   .text:00003c18 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:6711   .text:00003c1c $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:6714   .text:00003c1c UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:8061   .text:000046bc $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:8067   .text:000046cc $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:8183   .text:00004834 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:8242   .text:00004914 $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:8245   .text:00004914 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:8402   .text:00004a8c $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:8418   .text:00004ac0 $a
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:8421   .text:00004ac0 main
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:10249  .data:0000070c CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:10258  .data:00000718 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:10333  .data:00000838 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:10352  .data:00000848 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:8627   .rodata:000000e0 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:10431  .data:00000978 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:10442  .data:00000988 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:10553  .data:00000b38 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:10704  .data:00000bcc CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:8640   .rodata:000000fc CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:10245  .data:0000070b snapButFlag
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11121  .bss:0000029c testSnap
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11037  .bss:00000034 fb
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11041  .bss:00000036 pb
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11045  .bss:00000038 pbc
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11126  .bss:0000029e fbbak
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11130  .bss:000002a0 pbbak
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11134  .bss:000002a2 pbcbak
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11138  .bss:000002a4 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11033  .bss:00000030 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11070  .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11066  .bss:00000044 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11029  .bss:0000002c streamingStarted
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:10186  .data:000006d8 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:10126  .data:000006a0 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:10216  .data:000006f4 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:10156  .data:000006bc glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:10231  .data:00000700 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:9622   .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:8561   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:8565   .rodata:00000000 ShutSp
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:8580   .rodata:00000020 pEXTSenCtrl
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:9642   .data:00000490 EXTShutter
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:9686   .data:000004b8 EXTAexModGainlev
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:9664   .data:000004a4 EXTShutlev
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:9715   .data:000004d0 EXTBLCWinPos
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:9737   .data:000004e4 EXTBLCWeight
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:8608   .rodata:000000a0 pPUCSenCtrl
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:9759   .data:000004f8 PUCBLC
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:9781   .data:0000050c PUCSharp
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:8652   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:8656   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:8979   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:9637   .data:0000048c ROIMode
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:9708   .data:000004cc WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:9803   .data:00000520 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:10782  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11017  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11021  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11025  .bss:00000028 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11049  .bss:0000003a stiflag
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11054  .bss:0000003c hitFV
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11058  .bss:00000040 prodCount
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11062  .bss:00000042 consCount
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11075  .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11079  .bss:00000058 is60Hz
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11083  .bss:0000005c glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11087  .bss:0000007c CamMode
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11091  .bss:0000007d setRes
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11096  .bss:00000080 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11100  .bss:000000a0 setstilRes
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11104  .bss:000000a1 IMcount.7853
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11109  .bss:000000a4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11113  .bss:0000014c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\cc88plyX.s:11117  .bss:000001f4 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PGpifDisable
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorWrite2B
SensorRead2B
SensorWrite2B2
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifLoad
CyU3PGpifSMStart
CyU3PGpifSMSwitch
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
