   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"uvc.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	I2CCmdCb
  19              	I2CCmdCb:
  20              	.LFB18:
  21              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      ****                                                            received. */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 214:../uvc.c      ****                                                            the current video frame. */
 215:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 216:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 217:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 218:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 219:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 220:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 221:../uvc.c      **** 
 222:../uvc.c      **** /************ control parameters array ***********
 223:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 224:../uvc.c      ****  *    e.g.
 225:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 226:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 227:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 228:../uvc.c      ****  **************************************************/
 229:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 230:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 231:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 232:../uvc.c      **** 		{/*0*/BLCModeRegAct       , BLCModeRegAct        , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,
 233:../uvc.c      **** 		{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 234:../uvc.c      **** 		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1, 
 235:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 236:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 237:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 238:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 239:../uvc.c      **** 		{/*7*/SharpnessEnReg       , SharpnessGaiReg        , 2,    0,    0,  255,    0, 1, 0, 3, 0,  32,
 240:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 241:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 242:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 243:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 244:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 245:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 246:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 247:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 248:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 253:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 254:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 255:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 256:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 257:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 258:../uvc.c      **** 		{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 259:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 260:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 261:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 262:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 263:../uvc.c      **** 		/**********************************
 264:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 265:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 266:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 267:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 268:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 269:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 270:../uvc.c      **** 		 *
 271:../uvc.c      **** 		 *********************************/
 272:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 273:../uvc.c      **** };
 274:../uvc.c      **** #if 1 // the new control structure
 275:../uvc.c      **** /* the processing unit control request */
 276:../uvc.c      **** //		{ 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,   0, I2C_EAGLESDP_ADDR,  CyTrue, CyFalse,
 277:../uvc.c      **** 
 278:../uvc.c      **** volatile static SensorCtrl PUCBLC =
 279:../uvc.c      **** 		{BLCModeRegAct,		//Reg1: the command register address1
 280:../uvc.c      **** 		 BLCModeRegGain,	//Reg2: the command register address2
 281:../uvc.c      **** 		 2,					//UVCLn: the command length
 282:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 283:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 284:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 285:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 286:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 287:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 288:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 289:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 290:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 291:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 292:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 293:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 294:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 295:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 296:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 297:../uvc.c      **** 		}; //
 298:../uvc.c      **** //{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 299:../uvc.c      **** //volatile static SensorCtrl PUCBright;
 300:../uvc.c      **** volatile static SensorCtrl PUCBright =
 301:../uvc.c      **** 		{0x15/*BrightnessReg1*/,		//Reg1: the command register address1
 302:../uvc.c      **** 		 0x15/*BrightnessReg0*/,		//Reg2: the command register address2
 303:../uvc.c      **** 		 2,					//UVCLn: the command length
 304:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 305:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 306:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 307:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 308:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 309:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 310:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 311:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 312:../uvc.c      **** 		 118,				//UVCDefVLo: the command default data value low byte
 313:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 314:../uvc.c      **** 		 118,				//UVCCurVLo: the command current data value low byte
 315:../uvc.c      **** 		 119,				//UVCCurVHi: the command current data value high byte
 316:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 317:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 318:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 319:../uvc.c      **** 		}; //brightness, Reg1: ; Reg2: .
 320:../uvc.c      **** //		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1
 321:../uvc.c      **** //volatile static SensorCtrl PUCContrast;
 322:../uvc.c      **** volatile static SensorCtrl PUCContrast =
 323:../uvc.c      **** 		{ContrastReg,		//Reg1: the command register address1
 324:../uvc.c      **** 		 ContrastReg,		//Reg2: the command register address2
 325:../uvc.c      **** 		 2,					//UVCLn: the command length
 326:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 327:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 328:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 329:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 330:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 331:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 332:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 333:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 334:../uvc.c      **** 		 112,				//UVCDefVLo: the command default data value low byte
 335:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 336:../uvc.c      **** 		 112,				//UVCCurVLo: the command current data value low byte
 337:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 338:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 339:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 340:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 341:../uvc.c      **** 		}; //contrast, Reg1: ; Reg2: .
 342:../uvc.c      **** //volatile static SensorCtrl PUCGain;
 343:../uvc.c      **** //		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 
 344:../uvc.c      **** volatile static SensorCtrl PUCPLFreq =  //in 5MP b/w it is not used.
 345:../uvc.c      **** 		{MainsFreqReg,		//Reg1: the command register address1
 346:../uvc.c      **** 		 MainsFreqReg,		//Reg2: the command register address2
 347:../uvc.c      **** 		 2,					//UVCLn: the command length
 348:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 349:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 350:../uvc.c      **** 		 1,					//UVCMaxLo: the command maximum value low byte
 351:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 352:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 353:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 354:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 355:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 356:../uvc.c      **** 		 1,					//UVCDefVLo: the command default data value low byte
 357:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 358:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 359:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 360:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 361:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 362:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 363:../uvc.c      **** 		}; //main frequency, Reg1: ; Reg2: .
 364:../uvc.c      **** //volatile static SensorCtrl PUCHueC;
 365:../uvc.c      **** //{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 366:../uvc.c      **** volatile static SensorCtrl PUCHueC =
 367:../uvc.c      **** 		{HuectrlRegGr,		//Reg1: the command register address1
 368:../uvc.c      **** 		 HuectrlRegBlu,		//Reg2: the command register address2
 369:../uvc.c      **** 		 2,					//UVCLn: the command length
 370:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 371:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 372:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 373:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 374:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 375:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 376:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 377:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 378:../uvc.c      **** 		 128,				//UVCDefVLo: the command default data value low byte
 379:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 380:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 381:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 382:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 383:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 384:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 385:../uvc.c      **** 		}; //hue control, Reg1: ; Reg2: .
 386:../uvc.c      **** //		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 
 387:../uvc.c      **** //volatile static SensorCtrl PUCSaturation;
 388:../uvc.c      **** volatile static SensorCtrl PUCSaturation =
 389:../uvc.c      **** 		{SaturationRegR,		//Reg1: the command register address1
 390:../uvc.c      **** 		 SaturationRegB,		//Reg2: the command register address2
 391:../uvc.c      **** 		 2,					//UVCLn: the command length
 392:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 393:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 394:../uvc.c      **** 		 100,				//UVCMaxLo: the command maximum value low byte
 395:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 396:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 397:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 398:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 399:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 400:../uvc.c      **** 		 50,				//UVCDefVLo: the command default data value low byte
 401:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 402:../uvc.c      **** 		 50,				//UVCCurVLo: the command current data value low byte
 403:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 404:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 405:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 406:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 407:../uvc.c      **** 		}; //saturation, Reg1: ; Reg2: .
 408:../uvc.c      **** volatile static SensorCtrl PUCSharp =
 409:../uvc.c      **** 		{SharpnessEnReg,		//Reg1: the command register address1
 410:../uvc.c      **** 		 SharpnessGaiReg,		//Reg2: the command register address2
 411:../uvc.c      **** 		 2,					//UVCLn: the command length
 412:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 413:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 414:../uvc.c      **** 		 0xFF,				//UVCMaxLo: the command maximum value low byte
 415:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 416:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 417:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 418:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 419:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 420:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 421:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 422:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 423:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 424:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 425:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 426:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 427:../uvc.c      **** 		}; //sharpness, Reg1: 0-disable & 1-enable; Reg2: 0x00~0xFF.
 428:../uvc.c      **** //		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 
 429:../uvc.c      **** //volatile static SensorCtrl PUCWBMd;
 430:../uvc.c      **** volatile static SensorCtrl PUCWBMd = //not be used in 5MP B/W
 431:../uvc.c      **** 		{WBModeReg,		//Reg1: the command register address1
 432:../uvc.c      **** 		 WBModeReg,		//Reg2: the command register address2
 433:../uvc.c      **** 		 2,					//UVCLn: the command length
 434:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 435:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 436:../uvc.c      **** 		 5,					//UVCMaxLo: the command maximum value low byte
 437:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 438:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 439:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 440:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 441:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 442:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 443:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 444:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 445:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 446:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 447:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 448:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 449:../uvc.c      **** 		}; //write balance mode, Reg1: ; Reg2: .
 450:../uvc.c      **** //		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,5
 451:../uvc.c      **** //volatile static SensorCtrl PUCWBLC; //?
 452:../uvc.c      **** volatile static SensorCtrl PUCWBLC =  //not be used in 5MP B/W
 453:../uvc.c      **** 		{ManuBWBReg,		//Reg1: the command register address1
 454:../uvc.c      **** 		 ManuRWBReg,		//Reg2: the command register address2
 455:../uvc.c      **** 		 4,					//UVCLn: the command length
 456:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 457:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 458:../uvc.c      **** 		 64,				//UVCMaxLo: the command maximum value low byte
 459:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 460:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 461:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 462:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 463:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 464:../uvc.c      **** 		 32,				//UVCDefVLo: the command default data value low byte
 465:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 466:../uvc.c      **** 		 56,				//UVCCurVLo: the command current data value low byte
 467:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 468:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 469:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 470:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 471:../uvc.c      **** 		}; //write balance components, Reg1: ; Reg2: .
 472:../uvc.c      **** //		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 
 473:../uvc.c      **** //volatile static SensorCtrl PUCDZoom;
 474:../uvc.c      **** volatile static SensorCtrl PUCDZoom =
 475:../uvc.c      **** 		{DigZoomReg,		//Reg1: the command register address1
 476:../uvc.c      **** 		 DigZoomReg,		//Reg2: the command register address2
 477:../uvc.c      **** 		 2,					//UVCLn: the command length
 478:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 479:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 480:../uvc.c      **** 		 27,				//UVCMaxLo: the command maximum value low byte
 481:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 482:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 483:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 484:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 485:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 486:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 487:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 488:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 489:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 490:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 491:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 492:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 493:../uvc.c      **** 		}; //digital zoom, Reg1: ; Reg2: .
 494:../uvc.c      **** 
 495:../uvc.c      **** volatile static SensorCtrl *pPUCSenCtrl[0x10] = {
 496:../uvc.c      **** 	&PUCBLC,
 497:../uvc.c      **** 	&PUCBright,
 498:../uvc.c      **** 	&PUCContrast,
 499:../uvc.c      **** 	0, //&PUCGain (AGC?)
 500:../uvc.c      **** 	&PUCPLFreq,
 501:../uvc.c      **** 	&PUCHueC,
 502:../uvc.c      **** 	&PUCSaturation,
 503:../uvc.c      **** 	&PUCSharp,
 504:../uvc.c      **** 	0, //&PUCGamGain,
 505:../uvc.c      **** 	&PUCWBMd,
 506:../uvc.c      **** 	0, //UVCCtlID10,
 507:../uvc.c      **** 	&PUCWBLC,
 508:../uvc.c      **** 	0, //UVCCtlID12,
 509:../uvc.c      **** 	0, //UVCCtlID13,
 510:../uvc.c      **** 	&PUCDZoom,
 511:../uvc.c      **** 	0 //UVCCtlID15
 512:../uvc.c      **** };
 513:../uvc.c      **** 
 514:../uvc.c      **** /* the Camera terminal control request */
 515:../uvc.c      **** //volatile static SensorCtrl CTCAutoExMode;
 516:../uvc.c      **** //volatile static SensorCtrl CTCExposureTAbs;
 517:../uvc.c      **** //volatile static SensorCtrl CTCFocusRel;
 518:../uvc.c      **** //volatile static SensorCtrl CTCIrisAbs;
 519:../uvc.c      **** //volatile static SensorCtrl CTCOPZoomAbs;
 520:../uvc.c      **** 
 521:../uvc.c      **** /* the Extentsion control request */
 522:../uvc.c      **** volatile static SensorCtrl EXTShutter =
 523:../uvc.c      **** 		{ShutterReg,		//Reg1: the command register address1
 524:../uvc.c      **** 		 ExFinShutReg,		//Reg2: the command register address2
 525:../uvc.c      **** 		 2,					//UVCLn: the command length
 526:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 527:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 528:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 529:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 530:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 531:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 532:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 533:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 534:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 535:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 536:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 537:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 538:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 539:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 540:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 541:../uvc.c      **** 		}; //shutter control 0 ~ 0x12
 542:../uvc.c      **** volatile static SensorCtrl EXTSensUp =  //not be used in 5MP B/W
 543:../uvc.c      **** 		{SenseUpReg,		//Reg1: the command register address1
 544:../uvc.c      **** 		 SenseUpReg,		//Reg2: the command register address2
 545:../uvc.c      **** 		 2,					//UVCLn: the command length
 546:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 547:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 548:../uvc.c      **** 		 9,					//UVCMaxLo: the command maximum value low byte
 549:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 550:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 551:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 552:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 553:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 554:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 555:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 556:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 557:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 558:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 559:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 560:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 561:../uvc.c      **** 		};	// sense up control 0 ~ 0x09
 562:../uvc.c      **** 
 563:../uvc.c      **** // 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0
 564:../uvc.c      **** volatile static SensorCtrl EXTMirror =
 565:../uvc.c      **** 		{MirrModeReg,		//Reg1: the command register address1
 566:../uvc.c      **** 		 MirrModeReg,		//Reg2: the command register address2
 567:../uvc.c      **** 		 2,					//UVCLn: the command length
 568:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 569:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 570:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 571:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 572:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 573:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 574:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 575:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 576:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 577:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 578:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 579:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 580:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 581:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 582:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 583:../uvc.c      **** 		};	// mirror mode control 0 ~ 0x03
 584:../uvc.c      **** //		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0,
 585:../uvc.c      **** //volatile static SensorCtrl EXT3DnoiseReduceMode;
 586:../uvc.c      **** volatile static SensorCtrl EXT3DnoiseReduceMode = //2DNR mode
 587:../uvc.c      **** 		{NoiRedu3DModReg,		//Reg1: the command register address1
 588:../uvc.c      **** 		 NoiRedu3DModReg,		//Reg2: the command register address2
 589:../uvc.c      **** 		 2,					//UVCLn: the command length
 590:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 591:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 592:../uvc.c      **** 		 1,					//UVCMaxLo: the command maximum value low byte
 593:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 594:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 595:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 596:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 597:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 598:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 599:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 600:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 601:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 602:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 603:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 604:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 605:../uvc.c      **** 		};	// 3D noise reduce mode control
 606:../uvc.c      **** //		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32,
 607:../uvc.c      **** //volatile static SensorCtrl EXT3DNoiseLev;
 608:../uvc.c      **** volatile static SensorCtrl EXT3DNoiseLev =  //2DNR gain
 609:../uvc.c      **** 		{NoiRedu3DLevReg,		//Reg1: the command register address1
 610:../uvc.c      **** 		 NoiRedu3DLevReg,		//Reg2: the command register address2
 611:../uvc.c      **** 		 2,					//UVCLn: the command length
 612:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 613:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 614:../uvc.c      **** 		 64,				//UVCMaxLo: the command maximum value low byte
 615:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 616:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 617:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 618:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 619:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 620:../uvc.c      **** 		 32,				//UVCDefVLo: the command default data value low byte
 621:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 622:../uvc.c      **** 		 32,				//UVCCurVLo: the command current data value low byte
 623:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 624:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 625:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 626:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 627:../uvc.c      **** 		};	// 3D noise reduce level control
 628:../uvc.c      **** 
 629:../uvc.c      **** //		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0,
 630:../uvc.c      **** //volatile static SensorCtrl EXTDayNightMode;
 631:../uvc.c      **** volatile static SensorCtrl EXTDayNightMode =
 632:../uvc.c      **** 		{DayNightModReg,		//Reg1: the command register address1
 633:../uvc.c      **** 		 DayNightModReg,		//Reg2: the command register address2
 634:../uvc.c      **** 		 2,					//UVCLn: the command length
 635:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 636:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 637:../uvc.c      **** 		 2,					//UVCMaxLo: the command maximum value low byte
 638:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 639:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 640:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 641:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 642:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 643:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 644:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 645:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 646:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 647:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 648:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 649:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 650:../uvc.c      **** 		};	// day night mode control
 651:../uvc.c      **** //{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 652:../uvc.c      **** //volatile static SensorCtrl EXTDayNightdely;
 653:../uvc.c      **** volatile static SensorCtrl EXTDayNightdely =
 654:../uvc.c      **** 		{DayNightDlyReg,		//Reg1: the command register address1
 655:../uvc.c      **** 		 DayNightDlyReg,		//Reg2: the command register address2
 656:../uvc.c      **** 		 2,					//UVCLn: the command length
 657:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 658:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 659:../uvc.c      **** 		 63,				//UVCMaxLo: the command maximum value low byte
 660:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 661:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 662:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 663:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 664:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 665:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 666:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 667:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 668:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 669:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 670:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 671:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 672:../uvc.c      **** 		};	// day night delay control
 673:../uvc.c      **** //{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 674:../uvc.c      **** //volatile static SensorCtrl EXTDayNightlev;
 675:../uvc.c      **** volatile static SensorCtrl EXTDayNightlev =
 676:../uvc.c      **** 		{DayNightLevReg,		//Reg1: the command register address1
 677:../uvc.c      **** 		 DayNightLevReg,		//Reg2: the command register address2
 678:../uvc.c      **** 		 2,					//UVCLn: the command length
 679:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 680:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 681:../uvc.c      **** 		 100,				//UVCMaxLo: the command maximum value low byte
 682:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 683:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 684:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 685:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 686:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 687:../uvc.c      **** 		 16,				//UVCDefVLo: the command default data value low byte
 688:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 689:../uvc.c      **** 		 16,				//UVCCurVLo: the command current data value low byte
 690:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 691:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 692:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 693:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 694:../uvc.c      **** 		};	// day night level control
 695:../uvc.c      **** //{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 696:../uvc.c      **** //volatile static SensorCtrl EXTNightDaylev;
 697:../uvc.c      **** volatile static SensorCtrl EXTNightDaylev =
 698:../uvc.c      **** 		{NightDayLevReg,		//Reg1: the command register address1
 699:../uvc.c      **** 		 NightDayLevReg,		//Reg2: the command register address2
 700:../uvc.c      **** 		 2,					//UVCLn: the command length
 701:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 702:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 703:../uvc.c      **** 		 100,				//UVCMaxLo: the command maximum value low byte
 704:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 705:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 706:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 707:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 708:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 709:../uvc.c      **** 		 16,				//UVCDefVLo: the command default data value low byte
 710:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 711:../uvc.c      **** 		 16,				//UVCCurVLo: the command current data value low byte
 712:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 713:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 714:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 715:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 716:../uvc.c      **** 		};	// night day level control
 717:../uvc.c      **** //{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 718:../uvc.c      **** volatile static SensorCtrl EXTAexModGainlev =
 719:../uvc.c      **** 		{AExModeReg,		//Reg1: the command register address1
 720:../uvc.c      **** 		 AExAGCReg,			//Reg2: the command register address2
 721:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 722:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 723:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 724:../uvc.c      **** 		 127,				//UVCMaxLo: the command maximum value low byte
 725:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 726:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 727:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 728:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 729:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 730:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 731:../uvc.c      **** 		 63, 				//UVCDefVHi: the command default data value high byte
 732:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 733:../uvc.c      **** 		 63,				//UVCCurVHi: the command current data value high byte
 734:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 735:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 736:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 737:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 738:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 739:../uvc.c      **** //{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 740:../uvc.c      **** //volatile static SensorCtrl EXTExpReflev;
 741:../uvc.c      **** volatile static SensorCtrl EXTExpReflev =
 742:../uvc.c      **** 		{AExReferleveReg,		//Reg1: the command register address1
 743:../uvc.c      **** 		 AExReferleveReg,		//Reg2: the command register address2
 744:../uvc.c      **** 		 2,					//UVCLn: the command length
 745:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 746:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 747:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 748:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 749:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 750:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 751:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 752:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 753:../uvc.c      **** 		 60,				//UVCDefVLo: the command default data value low byte
 754:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 755:../uvc.c      **** 		 60,				//UVCCurVLo: the command current data value low byte
 756:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 757:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 758:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 759:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 760:../uvc.c      **** 		};	// AEX reference level control
 761:../uvc.c      **** //{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 762:../uvc.c      **** //volatile static SensorCtrl EXTCamMode;
 763:../uvc.c      **** volatile static SensorCtrl EXTCamMode =  //not be used
 764:../uvc.c      **** 		{SensorModeReg,		//Reg1: the command register address1
 765:../uvc.c      **** 		 SensorModeReg,		//Reg2: the command register address2
 766:../uvc.c      **** 		 2,					//UVCLn: the command length
 767:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 768:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 769:../uvc.c      **** 		 6,					//UVCMaxLo: the command maximum value low byte
 770:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 771:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 772:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 773:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 774:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 775:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 776:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 777:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 778:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 779:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 780:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 781:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 782:../uvc.c      **** 		};	// sensor mode control ???
 783:../uvc.c      **** //volatile static SensorCtrl EXTSnapshot; ???
 784:../uvc.c      **** //{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 785:../uvc.c      **** //volatile static SensorCtrl EXTSensorPare;
 786:../uvc.c      **** volatile static SensorCtrl EXTSensorPare = //not be used
 787:../uvc.c      **** 		{SeveParsReg,		//Reg1: the command register address1
 788:../uvc.c      **** 		 SeveParsReg,		//Reg2: the command register address2
 789:../uvc.c      **** 		 2,					//UVCLn: the command length
 790:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 791:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 792:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 793:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 794:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 795:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 796:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 797:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 798:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 799:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 800:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 801:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 802:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 803:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 804:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 805:../uvc.c      **** 		};	// sensor mode control ???
 806:../uvc.c      **** //{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 807:../uvc.c      **** //volatile static SensorCtrl EXTI2Ccmd;???
 808:../uvc.c      **** volatile static SensorCtrl EXTI2Ccmd = //not be used
 809:../uvc.c      **** 		{0,/*no-fix register*/		//Reg1: the command register address1
 810:../uvc.c      **** 		 0,/*no-fix register*/		//Reg2: the command register address2
 811:../uvc.c      **** 		 11,				//UVCLn: the command length
 812:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 813:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 814:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 815:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 816:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 817:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 818:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 819:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 820:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 821:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 822:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 823:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 824:../uvc.c      **** 		 0,/*no-fix address*/ 		//DeviceAdd: the device address
 825:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 826:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 827:../uvc.c      **** 		};	// sensor mode control ???
 828:../uvc.c      **** volatile static SensorCtrl EXTBLCWinPos =
 829:../uvc.c      **** 		{BLCPosReg,			//Reg1: the command register address1
 830:../uvc.c      **** 		 BLCSizeReg,		//Reg2: the command register address2
 831:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 832:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 833:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 834:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 835:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 836:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 837:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 838:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 839:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 840:../uvc.c      **** 		 0x66,				//UVCDefVLo: the command default data value low byte
 841:../uvc.c      **** 		 0x66, 				//UVCDefVHi: the command default data value high byte
 842:../uvc.c      **** 		 0x66,				//UVCCurVLo: the command current data value low byte
 843:../uvc.c      **** 		 0x66,				//UVCCurVHi: the command current data value high byte
 844:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 845:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 846:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 847:../uvc.c      **** 		}; //BLC position: [7:4]:Top/bottom [3:0]:left/right; BLC size: [7:4]:height [3:0]:width.
 848:../uvc.c      **** //{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 849:../uvc.c      **** volatile static SensorCtrl EXTBLCWeight =
 850:../uvc.c      **** 		{BLCModeRegGain,			//Reg1: the command register address1
 851:../uvc.c      **** 		 BLCModeRegGain,			//Reg2: the command register address2
 852:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 853:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 854:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 855:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 856:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 857:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 858:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 859:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 860:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 861:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 862:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 863:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 864:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 865:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 866:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 867:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 868:../uvc.c      **** 		}; //
 869:../uvc.c      **** //{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 870:../uvc.c      **** //volatile static SensorCtrl EXTBLCGrid;
 871:../uvc.c      **** volatile static SensorCtrl EXTBLCGrid =
 872:../uvc.c      **** 		{BLCModeRegAct,			//Reg1: the command register address1
 873:../uvc.c      **** 		 BLCModeRegAct,			//Reg2: the command register address2
 874:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 875:../uvc.c      **** 		 1,					//UVCMinLo: the command minimum value low byte
 876:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 877:../uvc.c      **** 		 2,		  			//UVCMaxLo: the command maximum value low byte
 878:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 879:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 880:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 881:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 882:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 883:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 884:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 885:../uvc.c      **** 		 0, 				//UVCCurVLo: the command current data value low byte
 886:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 887:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 888:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 889:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 890:../uvc.c      **** 		}; //
 891:../uvc.c      **** 
 892:../uvc.c      **** volatile static SensorCtrl EXTShutlev =
 893:../uvc.c      **** 		{0x12/*ShutterFineReg*/,		//Reg1: the command register address1
 894:../uvc.c      **** 		 0x12/*ShutterFineReg*/,			//Reg2: the command register address2
 895:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 896:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 897:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 898:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 899:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 900:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 901:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 902:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 903:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 904:../uvc.c      **** 		 63,				//UVCDefVLo: the command default data value low byte
 905:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 906:../uvc.c      **** 		 63,					//UVCCurVLo: the command current data value low byte
 907:../uvc.c      **** 		 0,				//UVCCurVHi: the command current data value high byte
 908:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 909:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 910:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 911:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 912:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 913:../uvc.c      **** 
 914:../uvc.c      **** volatile static SensorCtrl EXTExHyster =
 915:../uvc.c      **** 		{ExHysterReg,			//Reg1: the command register address1
 916:../uvc.c      **** 		 ExHysterReg,			//Reg2: the command register address2
 917:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 918:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 919:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 920:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 921:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 922:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 923:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 924:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 925:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 926:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 927:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 928:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 929:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 930:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 931:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 932:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 933:../uvc.c      **** 		}; //
 934:../uvc.c      **** 
 935:../uvc.c      **** volatile static SensorCtrl EXTExCtrlSped =
 936:../uvc.c      **** 		{ExCtrlSpdReg,			//Reg1: the command register address1
 937:../uvc.c      **** 		 ExCtrlSpdReg,			//Reg2: the command register address2
 938:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 939:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 940:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 941:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 942:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 943:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 944:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 945:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 946:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 947:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 948:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 949:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 950:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 951:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 952:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 953:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 954:../uvc.c      **** 		}; //
 955:../uvc.c      **** 
 956:../uvc.c      **** volatile static SensorCtrl EXTEnhanceMode =
 957:../uvc.c      **** 		{ExEnhanceModeReg,			//Reg1: the command register address1
 958:../uvc.c      **** 		 ExEnhanceModeReg,			//Reg2: the command register address2
 959:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 960:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 961:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 962:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 963:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 964:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 965:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 966:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 967:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 968:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 969:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 970:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 971:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 972:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 973:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 974:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 975:../uvc.c      **** 		}; //
 976:../uvc.c      **** 
 977:../uvc.c      **** volatile static SensorCtrl EXTEnhanceGain =
 978:../uvc.c      **** 		{ExEnhanceGainReg,			//Reg1: the command register address1
 979:../uvc.c      **** 		 ExEnhanceGainReg,			//Reg2: the command register address2
 980:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 981:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 982:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 983:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 984:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 985:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 986:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 987:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 988:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 989:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 990:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 991:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 992:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 993:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 994:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 995:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 996:../uvc.c      **** 		}; //
 997:../uvc.c      **** 
 998:../uvc.c      **** volatile static SensorCtrl EXTEnhanceSTED =
 999:../uvc.c      **** 		{ExEnhanceStartReg,			//Reg1: the command register address1
1000:../uvc.c      **** 		 ExEnhanceEndReg,			//Reg2: the command register address2
1001:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1002:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1003:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1004:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
1005:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1006:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1007:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1008:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1009:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1010:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
1011:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1012:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
1013:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1014:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1015:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1016:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1017:../uvc.c      **** 		}; //
1018:../uvc.c      **** 
1019:../uvc.c      **** volatile static SensorCtrl EXT2DNRGain =
1020:../uvc.c      **** 		{Ex2DNREnableReg,		//Reg1: the command register address1
1021:../uvc.c      **** 		 Ex2DNRGainReg,			//Reg2: the command register address2
1022:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1023:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1024:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1025:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
1026:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1027:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1028:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1029:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1030:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1031:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
1032:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1033:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
1034:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1035:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1036:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1037:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1038:../uvc.c      **** 		}; //
1039:../uvc.c      **** 
1040:../uvc.c      **** volatile static SensorCtrl EXT2DNRSTED =
1041:../uvc.c      **** 		{Ex2DNRStartReg,			//Reg1: the command register address1
1042:../uvc.c      **** 		 Ex2DNREndReg,			//Reg2: the command register address2
1043:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1044:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1045:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1046:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
1047:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1048:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1049:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1050:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1051:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1052:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
1053:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1054:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
1055:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1056:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1057:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1058:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1059:../uvc.c      **** 		}; //
1060:../uvc.c      **** 
1061:../uvc.c      **** volatile static SensorCtrl EXTGammaCor =
1062:../uvc.c      **** 		{ExGammaReg,			//Reg1: the command register address1
1063:../uvc.c      **** 		 ExGammaReg,			//Reg2: the command register address2
1064:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1065:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1066:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1067:../uvc.c      **** 		 0x10,				//UVCMaxLo: the command maximum value low byte
1068:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1069:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1070:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1071:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1072:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1073:../uvc.c      **** 		 0x00,				//UVCDefVLo: the command default data value low byte
1074:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1075:../uvc.c      **** 		 0x00,				//UVCCurVLo: the command current data value low byte
1076:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1077:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1078:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1079:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1080:../uvc.c      **** 		}; //
1081:../uvc.c      **** 
1082:../uvc.c      **** volatile static SensorCtrl EXTAGCMaxLimit =
1083:../uvc.c      **** 		{AGCMaxLimtReg,			//Reg1: the command register address1
1084:../uvc.c      **** 		 AGCMaxLimtReg,			//Reg2: the command register address2
1085:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1086:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1087:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1088:../uvc.c      **** 		 0x10,				//UVCMaxLo: the command maximum value low byte
1089:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1090:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1091:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1092:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1093:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1094:../uvc.c      **** 		 0x00,				//UVCDefVLo: the command default data value low byte
1095:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1096:../uvc.c      **** 		 0x00,				//UVCCurVLo: the command current data value low byte
1097:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1098:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1099:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1100:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1101:../uvc.c      **** 		}; //
1102:../uvc.c      **** 
1103:../uvc.c      **** volatile static SensorCtrl *pEXTSenCtrl[0x40] = {//Extension control
1104:../uvc.c      **** 		&EXTShutter,
1105:../uvc.c      **** 		&EXTSensUp,
1106:../uvc.c      **** 		&EXTMirror,
1107:../uvc.c      **** 		&EXT3DnoiseReduceMode,
1108:../uvc.c      **** 		&EXT3DNoiseLev,
1109:../uvc.c      **** 		&EXTDayNightMode,
1110:../uvc.c      **** 		&EXTDayNightdely,
1111:../uvc.c      **** 		&EXTDayNightlev,
1112:../uvc.c      **** 		&EXTNightDaylev,
1113:../uvc.c      **** 		&EXTAexModGainlev,
1114:../uvc.c      **** 		&EXTExpReflev,
1115:../uvc.c      **** 		&EXTShutlev,
1116:../uvc.c      **** 		&EXTCamMode,
1117:../uvc.c      **** 		0, //&EXTSnapshot,
1118:../uvc.c      **** 		&EXTSensorPare,
1119:../uvc.c      **** 		&EXTI2Ccmd,
1120:../uvc.c      **** 		0, //&Ext1CtlID0 = 0x20,
1121:../uvc.c      **** 		0, //&Ext1CtlID1,
1122:../uvc.c      **** 		0, //&Ext1CtlID2,
1123:../uvc.c      **** 		0, //&Ext1CtlID3,
1124:../uvc.c      **** 		&EXTBLCWinPos,   		// back light compensation range
1125:../uvc.c      **** 		&EXTBLCWeight,  	    // back light compensation weight (gain) factor
1126:../uvc.c      **** 		&EXTBLCGrid,    	// back light compensation grid state
1127:../uvc.c      **** 		&EXTExHyster,       // exposure hystereses level
1128:../uvc.c      **** 		&EXTExCtrlSped,     // exposure control speed level
1129:../uvc.c      **** 		&EXTEnhanceMode,    // edge enhancement mode
1130:../uvc.c      **** 		&EXTEnhanceGain,    // edge enhancement gain level
1131:../uvc.c      **** 		&EXTEnhanceSTED,    // edge enhancement start/end level
1132:../uvc.c      **** 		&EXT2DNRGain,       // 2D noise reduction Gain level
1133:../uvc.c      **** 		&EXT2DNRSTED,       // 2D noise reduction start/end level
1134:../uvc.c      **** 		&EXTGammaCor,		// Gamma correction
1135:../uvc.c      **** 		&EXTAGCMaxLimit, 	// AGC Maximum Gain limitation &Ext1AGCMaxLimetCtlID15,
1136:../uvc.c      **** 		0
1137:../uvc.c      **** };
1138:../uvc.c      **** 
1139:../uvc.c      **** #endif //end of the new control structure
1140:../uvc.c      **** 
1141:../uvc.c      **** #ifndef CAM720
1142:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
1143:../uvc.c      **** #else
1144:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
1145:../uvc.c      **** #endif
1146:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
1147:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
1148:../uvc.c      **** 
1149:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
1150:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
1151:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
1152:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
1153:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
1154:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    0,    0,    0xff, 0xff, 1, 0, 3
1155:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   0x80,
1156:../uvc.c      **** 		{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
1157:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
1158:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
1159:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
1160:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
1161:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
1162:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1163:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1164:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1165:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1166:../uvc.c      **** };
1167:../uvc.c      **** 
1168:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
1169:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
1170:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
1171:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
1172:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
1173:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
1174:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
1175:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
1176:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
1177:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
1178:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
1179:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
1180:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
1181:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
1182:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
1183:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1184:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1185:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1186:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1187:../uvc.c      **** };
1188:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
1189:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
1190:../uvc.c      **** static uint16_t ShutSp[16]={33333, 16667, 8333, 4000, 2000, 1000, 500, 200, 100, 10, 0}; // in micr
1191:../uvc.c      **** static uint8_t curFlag[64]={0}; //the curFlag for each controls current records available. 0: unabl
1192:../uvc.c      **** /*
1193:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
1194:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
1195:../uvc.c      ****  */
1196:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
1197:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
1198:../uvc.c      **** };
1199:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
1200:../uvc.c      **** 		0
1201:../uvc.c      **** };
1202:../uvc.c      **** 
1203:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
1204:../uvc.c      **** 
1205:../uvc.c      **** void I2CCmdHandler(){
1206:../uvc.c      **** 	uint8_t buf[2];
1207:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
1208:../uvc.c      **** 	CmdType = I2CCMDArry[0];
1209:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
1210:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
1211:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
1212:../uvc.c      **** 	uint8_t i;
1213:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
1214:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
1215:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
1216:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
1217:../uvc.c      **** 	{
1218:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
1219:../uvc.c      **** 		if(is60Hz==CyFalse)
1220:../uvc.c      **** 			{
1221:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
1222:../uvc.c      **** 			}
1223:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
1224:../uvc.c      **** 
1225:../uvc.c      **** 	}
1226:../uvc.c      **** 	if(CmdType == 0)//I2C read
1227:../uvc.c      **** 	{
1228:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
1229:../uvc.c      **** #if 0 //for debugging
1230:../uvc.c      **** 		/* test still image operation */
1231:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
1232:../uvc.c      **** 			snapButFlag = 0; //press
1233:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
1234:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
1235:../uvc.c      **** 			snapButFlag = 0xf; //release
1236:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
1237:../uvc.c      **** 		}
1238:../uvc.c      **** 
1239:../uvc.c      **** 		/* end of the test */
1240:../uvc.c      **** #endif
1241:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
1242:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
1243:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
1244:../uvc.c      **** 				if(CmdDataLen == 2){
1245:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
1246:../uvc.c      **** 				}
1247:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
1248:../uvc.c      **** 		}else{//not support currently
1249:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
1250:../uvc.c      **** 		}
1251:../uvc.c      **** 	}else if(CmdType == 1){
1252:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
1253:../uvc.c      **** 			if(CmdRegLen == 2){
1254:../uvc.c      **** 				for(i = 0; i<4; i++)
1255:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
1256:../uvc.c      **** 			}
1257:../uvc.c      **** 			else{
1258:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
1259:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
1260:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
1261:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
1262:../uvc.c      **** 				}
1263:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
1264:../uvc.c      **** 			}
1265:../uvc.c      **** 		}else{//not support currently
1266:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
1267:../uvc.c      **** 		}
1268:../uvc.c      **** 
1269:../uvc.c      **** 	}
1270:../uvc.c      **** }
1271:../uvc.c      **** 
1272:../uvc.c      **** /************************************
1273:../uvc.c      ****  * set Iris mode
1274:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
1275:../uvc.c      ****  */
1276:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
1277:../uvc.c      **** 	uint8_t dataIdx = 0;
1278:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
1280:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
1281:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1282:../uvc.c      **** }
1283:../uvc.c      **** 
1284:../uvc.c      **** 
1285:../uvc.c      **** 
1286:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
1287:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
1288:../uvc.c      **** 	uint16_t NumLn;
1289:../uvc.c      **** 	uint16_t fRate, shutTm;
1290:../uvc.c      **** 	uint8_t LnVal;
1291:../uvc.c      **** 	switch (Data){
1292:../uvc.c      **** 	case 1:
1293:../uvc.c      **** 	case 2:
1294:../uvc.c      **** 	case 3:
1295:../uvc.c      **** 	case 4:
1296:../uvc.c      **** 	case 5:
1297:../uvc.c      **** 		shutTm = ShutSp[Data-1];
1298:../uvc.c      **** 		fRate = 30;
1299:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
1300:../uvc.c      **** 		if(NumLn > 1944)
1301:../uvc.c      **** 			NumLn =1944;
1302:../uvc.c      **** 		else if(NumLn < 8)
1303:../uvc.c      **** 			NumLn = 8;
1304:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
1305:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
1306:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
1307:../uvc.c      **** 		break;
1308:../uvc.c      **** 	case 6:
1309:../uvc.c      **** 	case 7:
1310:../uvc.c      **** 	case 8:
1311:../uvc.c      **** 	case 9:
1312:../uvc.c      **** 	case 10:
1313:../uvc.c      **** 		shutTm = ShutSp[Data-1];
1314:../uvc.c      **** 		fRate = 30;
1315:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
1316:../uvc.c      **** 		if(NumLn > 1944)
1317:../uvc.c      **** 			NumLn =1944;
1318:../uvc.c      **** 		else if(NumLn < 8)
1319:../uvc.c      **** 			NumLn = 8;
1320:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
1321:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
1322:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
1323:../uvc.c      **** 		break;
1324:../uvc.c      **** 	case 0: //auto
1325:../uvc.c      **** 	default:
1326:../uvc.c      **** 		*pAxMode = 0x00;	// auto
1327:../uvc.c      **** 		LnVal = 1;
1328:../uvc.c      **** 		break;
1329:../uvc.c      **** 	}
1330:../uvc.c      **** 	return LnVal;
1331:../uvc.c      **** }
1332:../uvc.c      **** 
1333:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
1334:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
1335:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1336:../uvc.c      ****     uint16_t readCount;
1337:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID, AxMode;
1338:../uvc.c      ****     uint8_t devAdd;
1339:../uvc.c      ****     //locCtrlID = CtrlID-EXUAOFFSET+4;
1340:../uvc.c      ****     if(CtrlID >= 0x10){//the extension command over 32.
1341:../uvc.c      ****     	RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1;//ExUCtrlParArry[locCtrlID][0];
1342:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
1343:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
1344:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
1345:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
1346:../uvc.c      ****     	//		CtrlID, RegAdd0, RegAdd1, devAdd, Len);
1347:../uvc.c      ****     }else{
1348:../uvc.c      **** 		RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1;//CtrlParArry[CtrlID][0];
1349:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
1350:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
1351:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
1352:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
1353:../uvc.c      ****     	//		CtrlID, RegAdd0, RegAdd1, devAdd, Len);
1354:../uvc.c      ****     }
1355:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
1356:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1357:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
1358:../uvc.c      **** #endif
1359:../uvc.c      ****     reqData = bRequest;
1360:../uvc.c      ****     /*
1361:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
1362:../uvc.c      ****      */
1363:../uvc.c      ****     //if (0 && (CtrlID == ExtAexModCtlID9)){
1364:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
1365:../uvc.c      ****     	//goto EndofSet;
1366:../uvc.c      ****     //}
1367:../uvc.c      ****     switch (bRequest)
1368:../uvc.c      **** 		 {
1369:../uvc.c      **** 
1370:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
1371:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1372:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1373:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1374:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1375:../uvc.c      **** 			  break;
1376:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1377:../uvc.c      **** 
1378:../uvc.c      **** 		 	 if(CtrlID >= 0x10/*EXUAOFFSET*/){
1379:../uvc.c      **** 				 switch(CtrlID)
1380:../uvc.c      **** 				 {
1381:../uvc.c      **** 					 case Ext1BLCGridCtlID6:
1382:../uvc.c      **** 						 if(curFlag[CtrlID]){
1383:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo; //ExUCtrlParArry[CtrlID-0x20][13];/
1384:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi; //ExUCtrlParArry[CtrlID-0x20][14];
1385:../uvc.c      **** 						 }else{
1386:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1387:../uvc.c      **** 							if(Data0&0x80)
1388:../uvc.c      **** 								glEp0Buffer[0] = 1;
1389:../uvc.c      **** 							else
1390:../uvc.c      **** 								glEp0Buffer[0] = 0;
1391:../uvc.c      **** 							pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1392:../uvc.c      **** 							glEp0Buffer[1] = 0; //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;ExUCtrlParArry[CtrlID-0x20][14];
1393:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
1394:../uvc.c      **** 						 }
1395:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1396:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1397:../uvc.c      **** 						 break;
1398:../uvc.c      **** 			 	 	 case ExtAexModCtlID9:
1399:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1400:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1401:../uvc.c      **** 							 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1402:../uvc.c      **** 			 	 		 }else{
1403:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1404:../uvc.c      **** 			 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // 1:0 for Aex Mode
1405:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1406:../uvc.c      **** 
1407:../uvc.c      **** 			 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
1408:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
1409:../uvc.c      **** 			 	 			//curFlag[CtrlID] = CyTrue;
1410:../uvc.c      **** 			 	 		 }
1411:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1412:../uvc.c      **** 						 glEp0Buffer[3] = 0;
1413:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1414:../uvc.c      **** 						 sendData1 = glEp0Buffer[2];
1415:../uvc.c      **** 						 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1
1416:../uvc.c      **** 						 break;
1417:../uvc.c      **** 				 	 case ExtCamMCtlID12: //EXTCamMode
1418:../uvc.c      **** #if 0 //not be used
1419:../uvc.c      **** 						 sendData = CtrlParArry[CtrlID][13];
1420:../uvc.c      **** 
1421:../uvc.c      **** 						 if(CamMode == 1){//720p
1422:../uvc.c      **** 							if(sendData >= 3){
1423:../uvc.c      **** 								CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, s
1424:../uvc.c      **** 								sendData = 0; //set back to default
1425:../uvc.c      **** 								CtrlParArry[CtrlID][13] = 0;
1426:../uvc.c      **** 							}
1427:../uvc.c      **** 							sendData += 4;
1428:../uvc.c      **** 						 }
1429:../uvc.c      **** 						//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, s
1430:../uvc.c      **** 						 glEp0Buffer[0] = sendData;
1431:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1432:../uvc.c      **** #endif
1433:../uvc.c      **** 						 break;
1434:../uvc.c      **** 				 	 case ExtI2CCtlID15:
1435:../uvc.c      **** 				 		 for(idx=0; idx<Len; idx++){
1436:../uvc.c      **** 				 			glEp0Buffer[idx] = I2CCMDArry[idx];
1437:../uvc.c      **** 				 		 }
1438:../uvc.c      **** 				 		 sendData = glEp0Buffer[9];
1439:../uvc.c      **** 				 		 sendData1 = glEp0Buffer[10];
1440:../uvc.c      **** 	#ifdef USB_DEBUG_PRINT
1441:../uvc.c      **** 				 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x
1442:../uvc.c      **** 				 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
1443:../uvc.c      **** 				 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
1444:../uvc.c      **** 	#endif
1445:../uvc.c      **** 				 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
1446:../uvc.c      **** 				 		 {
1447:../uvc.c      **** 				 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDAr
1448:../uvc.c      **** 				 		 }
1449:../uvc.c      **** 				 		 break;
1450:../uvc.c      **** 			 	 	 case Ext1ExCtrlSpeedCtlID8:
1451:../uvc.c      **** 			 	 		 sendData = SensorGetControl(RegAdd1, devAdd);
1452:../uvc.c      **** 			 	 		// sendData &= 0x70;
1453:../uvc.c      **** 	 	 				 glEp0Buffer[0] = sendData >> 4; // bit6:4 are significant bits. bit7 is fine shutter & shu
1454:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1455:../uvc.c      **** 	 	 				 glEp0Buffer[1] = 0;
1456:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
1457:../uvc.c      **** 	 	 				 sendData = glEp0Buffer[0];
1458:../uvc.c      **** 	 	 				 sendData1 = glEp0Buffer[1];
1459:../uvc.c      **** 	 	 				 break;
1460:../uvc.c      **** 				 	 case Ext1BLCRangeCtlID4:
1461:../uvc.c      **** 	 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1462:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1463:../uvc.c      **** 	 	 				 glEp0Buffer[1] = SensorGetControl(RegAdd1, devAdd);
1464:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
1465:../uvc.c      **** 	 	 				 sendData = glEp0Buffer[0];
1466:../uvc.c      **** 	 	 				 sendData1 = glEp0Buffer[1];
1467:../uvc.c      **** 	 	 				 break;
1468:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
1469:../uvc.c      **** 				 	 case ExtShutCtlID0:
1470:../uvc.c      **** 				 	 case ExtCtlShutlevCtlID11:
1471:../uvc.c      **** 				 		 /* the exposure hysteresis to gamma correction */
1472:../uvc.c      **** 			 	 	 case Ext1ExHysterCtlID7:
1473:../uvc.c      **** 			 	 	 case Ext1EnhanceModeCtlID9:
1474:../uvc.c      **** 			 	 	 case Ext1EnhanceGainCtlID10:
1475:../uvc.c      **** 			 	 	 case Ext1EnhanceStarEndCtlID11:
1476:../uvc.c      **** 			 	 	 case Ext12DNRGainEnblCtlID12:
1477:../uvc.c      **** 			 	 	 case Ext12DNRGainStarEndCtlID13://4bytes
1478:../uvc.c      **** 			 	 	 case Ext1GammaCorCtlID14:
1479:../uvc.c      **** 			 	 	 case Ext1AGCMaxLimetCtlID15:
1480:../uvc.c      **** 					 case ExtExRefCtlID10:
1481:../uvc.c      **** 			 	 	 default:
1482:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1483:../uvc.c      **** 			 	 			 if(Len == 2)
1484:../uvc.c      **** 			 	 			 {
1485:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1486:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1487:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1488:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1489:../uvc.c      **** 			 	 			 }else if(Len == 4){
1490:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1491:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1492:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1493:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1494:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1495:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1496:../uvc.c      **** 			 	 			 }
1497:../uvc.c      **** 			 	 		 }else{
1498:../uvc.c      **** 			 	 			 if(Len == 2)
1499:../uvc.c      **** 			 	 			 {
1500:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1501:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1502:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1503:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
1504:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1505:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1506:../uvc.c      **** 			 	 			 }else if(Len == 4){
1507:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1508:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1509:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
1510:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
1511:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1512:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1513:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1514:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1515:../uvc.c      **** 			 	 			 }
1516:../uvc.c      **** 			 	 			 //curFlag[CtrlID] = CyTrue;
1517:../uvc.c      **** 			 	 		 }
1518:../uvc.c      **** 			 	 		 break;
1519:../uvc.c      **** 			 	 }
1520:../uvc.c      **** 		 	 }
1521:../uvc.c      **** 		 	 else{
1522:../uvc.c      **** 				 switch(CtrlID)
1523:../uvc.c      **** 				 {
1524:../uvc.c      **** 					 case BrgtCtlID1:
1525:../uvc.c      **** 						 /* cancel for 5MP w/b camera
1526:../uvc.c      **** 						 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
1527:../uvc.c      **** 						 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
1528:../uvc.c      **** 						 if (Data1&0x2){ //check the sign bit (bit1)
1529:../uvc.c      **** 							 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
1530:../uvc.c      **** 						 }else{
1531:../uvc.c      **** 							 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
1532:../uvc.c      **** 						 }
1533:../uvc.c      **** 						 glEp0Buffer[0] = Data1;
1534:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1535:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1536:../uvc.c      **** 						 */
1537:../uvc.c      **** 						 if(curFlag[CtrlID]){
1538:../uvc.c      **** 							Data0 = pPUCSenCtrl[CtrlID]->UVCCurVLo; // CtrlParArry[CtrlID][13];
1539:../uvc.c      **** 						 }else{
1540:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1541:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1542:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
1543:../uvc.c      **** 						 }
1544:../uvc.c      **** 						 //Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode(
1545:../uvc.c      **** 						 /*//new implementation 8/23/2016
1546:../uvc.c      **** 						 if(Data0&0x80){
1547:../uvc.c      **** 							  Data0 = ~Data0;
1548:../uvc.c      **** 						  }else{
1549:../uvc.c      **** 							  Data0 = Data0 + 0x80;
1550:../uvc.c      **** 						  }
1551:../uvc.c      **** 						  */
1552:../uvc.c      **** 						 glEp0Buffer[0] = Data0;
1553:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1554:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1555:../uvc.c      **** 						 break;
1556:../uvc.c      **** 					 case HueCtlID5:
1557:../uvc.c      **** 						 if(curFlag[CtrlID]){
1558:../uvc.c      **** 							Data0 = pPUCSenCtrl[CtrlID]->UVCCurVLo; //CtrlParArry[CtrlID][13];
1559:../uvc.c      **** 						 }else{
1560:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1561:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1562:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
1563:../uvc.c      **** 						 }
1564:../uvc.c      **** 
1565:../uvc.c      **** 						 glEp0Buffer[0] = Data0 + GREEN_BASE;
1566:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1567:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1568:../uvc.c      **** 						 break;
1569:../uvc.c      **** 					 case MFreqCtlID4:
1570:../uvc.c      **** 
1571:../uvc.c      **** 						 if(curFlag[CtrlID]){
1572:../uvc.c      **** 
1573:../uvc.c      **** 							 if(is60Hz)
1574:../uvc.c      **** 								 glEp0Buffer[0] = 0;//CtrlParArry[CtrlID][13];//ext_control array;
1575:../uvc.c      **** 							 else
1576:../uvc.c      **** 								 glEp0Buffer[0] = 1;
1577:../uvc.c      **** 
1578:../uvc.c      **** 							 glEp0Buffer[1] = 0; //CtrlParArry[CtrlID][14];
1579:../uvc.c      **** 						 }else{
1580:../uvc.c      **** 							Data0 = SensorGetControl(0x1, devAdd); //get resolution bit7 for main frequency information
1581:../uvc.c      **** 							glEp0Buffer[0] = (Data0&0x80)>>7;
1582:../uvc.c      **** 							//glEp0Buffer[0]++;
1583:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1584:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
1585:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
1586:../uvc.c      **** 						 }
1587:../uvc.c      **** 
1588:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1589:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1590:../uvc.c      **** 						 break;
1591:../uvc.c      **** 					 case WBTLevCtlID11:
1592:../uvc.c      **** 						 if(curFlag[CtrlID]){
1593:../uvc.c      **** 							 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
1594:../uvc.c      **** 							 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
1595:../uvc.c      **** 						 }else{
1596:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1597:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
1598:../uvc.c      **** 							glEp0Buffer[0] = Data0;
1599:../uvc.c      **** 							WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
1600:../uvc.c      **** 							glEp0Buffer[2] = Data1;
1601:../uvc.c      **** 							WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
1602:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
1603:../uvc.c      **** 						 }
1604:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1605:../uvc.c      **** 						 glEp0Buffer[3] = 0;
1606:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1607:../uvc.c      **** 						 sendData1 = glEp0Buffer[2];
1608:../uvc.c      **** 						 break;
1609:../uvc.c      **** 					 case ShapCtlID7:
1610:../uvc.c      **** 						 if(curFlag[CtrlID]){
1611:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1612:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1613:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1614:../uvc.c      **** 			 	 		 }else{
1615:../uvc.c      **** 			 	 			 if(Len == 2)
1616:../uvc.c      **** 			 	 			 {
1617:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1618:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1619:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1620:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
1621:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1622:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1623:../uvc.c      **** 			 	 			 }
1624:../uvc.c      **** 			 	 			 //curFlag[CtrlID] = CyTrue;
1625:../uvc.c      **** 			 	 		 }
1626:../uvc.c      **** 						 break;
1627:../uvc.c      **** 					 case BLCCtlID0:
1628:../uvc.c      **** 					 case ConsCtlID2:
1629:../uvc.c      **** 					 case WBTMdCtlID9:
1630:../uvc.c      **** 					 case SaturCtlID6:
1631:../uvc.c      **** 					 default:
1632:../uvc.c      **** 						 if(curFlag[CtrlID]){
1633:../uvc.c      **** 			 	 			 if(Len == 2)
1634:../uvc.c      **** 			 	 			 {
1635:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1636:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1637:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1638:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1639:../uvc.c      **** 			 	 			 }else if(Len == 4){
1640:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1641:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1642:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1643:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1644:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1645:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1646:../uvc.c      **** 			 	 			 }
1647:../uvc.c      **** 			 	 		 }else{
1648:../uvc.c      **** 			 	 			 if(Len == 2)
1649:../uvc.c      **** 			 	 			 {
1650:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1651:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1652:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1653:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
1654:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1655:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1656:../uvc.c      **** 			 	 			 }else if(Len == 4){
1657:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1658:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1659:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
1660:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
1661:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1662:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1663:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1664:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1665:../uvc.c      **** 			 	 			 }
1666:../uvc.c      **** 			 	 			 //curFlag[CtrlID] = CyTrue;
1667:../uvc.c      **** 			 	 		 }
1668:../uvc.c      **** 						 break;
1669:../uvc.c      **** 				 }
1670:../uvc.c      **** 		 	 }
1671:../uvc.c      **** 
1672:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1673:../uvc.c      **** 
1674:../uvc.c      **** //#ifdef USB_DEBUG_PRINT
1675:../uvc.c      **** 			  CyU3PDebugPrint (4, "The current value 0x%x 0x%x 0x%x, 0x%x, %d\r\n", glEp0Buffer[0], glEp0Buf
1676:../uvc.c      **** //#endif
1677:../uvc.c      **** 			  break;
1678:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
1679:../uvc.c      **** 		 	 if(CtrlID >= 0x10){//the camera terminal/extension uint command over 0x10.
1680:../uvc.c      **** 		 		 if(Len == 2){
1681:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1682:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1683:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1684:../uvc.c      **** 		 		 }else //if(Len == 4)
1685:../uvc.c      **** 		 		 {
1686:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1687:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1688:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1689:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1690:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1691:../uvc.c      **** 				 }
1692:../uvc.c      **** 			 }else{
1693:../uvc.c      **** 			 	 if(Len ==2){
1694:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1695:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1696:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1697:../uvc.c      **** 				 }else{
1698:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1699:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1700:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1701:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1702:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1703:../uvc.c      **** 				 }
1704:../uvc.c      **** 			 }
1705:../uvc.c      **** 		 	 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1706:../uvc.c      **** 		 	 if(Len == 2){
1707:../uvc.c      **** 		 		 sendData = glEp0Buffer[0];
1708:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[1];
1709:../uvc.c      **** 		 	 }else{
1710:../uvc.c      **** 				  sendData = glEp0Buffer[0];
1711:../uvc.c      **** 				  sendData1 = glEp0Buffer[2];
1712:../uvc.c      **** 			  }
1713:../uvc.c      **** 			  break;
1714:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1715:../uvc.c      **** 		 	 if(CtrlID >= 0x10){//the camera terminal/extension uint command over 0x10.
1716:../uvc.c      **** 		 		 if(Len == 2){
1717:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1718:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1719:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1720:../uvc.c      **** 		 		 }else //if(Len == 4)
1721:../uvc.c      **** 		 		 {
1722:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1723:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1724:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1725:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1726:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1727:../uvc.c      **** 				 }
1728:../uvc.c      **** 			 }else{
1729:../uvc.c      **** 			 	 if(Len ==2){
1730:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1731:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1732:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1733:../uvc.c      **** 				 }else{
1734:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1735:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1736:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1737:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1738:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1739:../uvc.c      **** 				 }
1740:../uvc.c      **** 			 }
1741:../uvc.c      **** 				  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1742:../uvc.c      **** 				  if(Len == 2){
1743:../uvc.c      **** 					  sendData = glEp0Buffer[0];
1744:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
1745:../uvc.c      **** 				  }else{
1746:../uvc.c      **** 					  sendData = glEp0Buffer[0];
1747:../uvc.c      **** 					  sendData1 = glEp0Buffer[2];
1748:../uvc.c      **** 				  }
1749:../uvc.c      **** 				  break;
1750:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1751:../uvc.c      **** 		 	 if(CtrlID >= 0x10){
1752:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCResLo;//ExUCtrlParArry[locCtrlID][7];//ext_con
1753:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
1754:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1755:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1756:../uvc.c      **** 		 	 }
1757:../uvc.c      **** 		 	 else{
1758:../uvc.c      **** 		 		 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCResLo;//ExUCtrlParArry[locCtrlID][7];//ext_control a
1759:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
1760:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
1761:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
1762:../uvc.c      **** 		 	 }
1763:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1764:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1765:../uvc.c      **** 			  sendData1 = glEp0Buffer[1];
1766:../uvc.c      **** 			  //CyU3PDebugPrint (4, "The control ResLo: 0x%x, ResHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0], g
1767:../uvc.c      **** 			  break;
1768:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1769:../uvc.c      **** 		 	 if(CtrlID >= 0x10){
1770:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCInfoLo;//ExUCtrlParArry[locCtrlID][9];//ext_co
1771:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
1772:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1773:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1774:../uvc.c      **** 		 	 }
1775:../uvc.c      **** 		 	 else{
1776:../uvc.c      **** 		 		 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCInfoLo;//ExUCtrlParArry[locCtrlID][9];//ext_control 
1777:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
1778:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
1779:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
1780:../uvc.c      **** 		 	 }
1781:../uvc.c      **** 		 	 Len = 1;
1782:../uvc.c      **** 		 	 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1783:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
1784:../uvc.c      **** 		 	 sendData1 = glEp0Buffer[1];
1785:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
1786:../uvc.c      **** 		 	 break;
1787:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1788:../uvc.c      **** 		 	 if(CtrlID >= 0x10){//the camera terminal/extension uint command over 0x10.
1789:../uvc.c      **** 		 		 if(Len == 2){
1790:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1791:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1792:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
1793:../uvc.c      **** 		 		 }else //if(Len == 4)
1794:../uvc.c      **** 		 		 {
1795:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1796:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1797:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1798:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1799:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
1800:../uvc.c      **** 				 }
1801:../uvc.c      **** 			 }else{
1802:../uvc.c      **** 			 	 if(Len ==2){
1803:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1804:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1805:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
1806:../uvc.c      **** 				 }else{
1807:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1808:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1809:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1810:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1811:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
1812:../uvc.c      **** 				 }
1813:../uvc.c      **** 			 }
1814:../uvc.c      **** 		 	 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1815:../uvc.c      **** 		 	 if(Len == 2){
1816:../uvc.c      **** 		 		 sendData = glEp0Buffer[0];
1817:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[1];
1818:../uvc.c      **** 		 	 }else{
1819:../uvc.c      **** 		 		 sendData = glEp0Buffer[0];
1820:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
1821:../uvc.c      **** 		 	 }
1822:../uvc.c      **** 		 	 break;
1823:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1824:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1825:../uvc.c      **** 				  glEp0Buffer, &readCount);
1826:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
1827:../uvc.c      **** 			   {
1828:../uvc.c      **** 				 if(Len == 2){
1829:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
1830:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
1831:../uvc.c      **** 				 }else{
1832:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
1833:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
1834:../uvc.c      **** 				 }
1835:../uvc.c      **** 				 dataIdx = 0;
1836:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x 
1837:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
1838:../uvc.c      **** 			 	 if(CtrlID >= 0x10){
1839:../uvc.c      **** 					 switch(CtrlID)
1840:../uvc.c      **** 					 {
1841:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
1842:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
1843:../uvc.c      **** 							 if(Data0 == 1){
1844:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
1845:../uvc.c      **** 							 }else{
1846:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
1847:../uvc.c      **** 							 }
1848:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1849:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
1850:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1851:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
1852:../uvc.c      **** 							 break;
1853:../uvc.c      **** 					 	 case ExtCamMCtlID12://EXTCamMode
1854:../uvc.c      **** 	#if 0 // not be used
1855:../uvc.c      **** 							 sendData = CtrlParArry[CtrlID][13];
1856:../uvc.c      **** 
1857:../uvc.c      **** 							 if(CamMode == 1){//720p
1858:../uvc.c      **** 								if(sendData >= 3){
1859:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1860:../uvc.c      **** 									sendData = 0; //set back to default
1861:../uvc.c      **** 									CtrlParArry[CtrlID][13] = 0;
1862:../uvc.c      **** 								}
1863:../uvc.c      **** 								sendData += 4;
1864:../uvc.c      **** 							 }
1865:../uvc.c      **** 							//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1866:../uvc.c      **** 							 glEp0Buffer[0] = sendData;
1867:../uvc.c      **** 							 glEp0Buffer[1] = 0;
1868:../uvc.c      **** 	#endif
1869:../uvc.c      **** 							 break;
1870:../uvc.c      **** 					 	 case ExtSensorParCtlID14:
1871:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1872:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
1873:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1874:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
1875:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
1876:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
1877:../uvc.c      **** 							 break;
1878:../uvc.c      **** 					 	 case ExtI2CCtlID15:
1879:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
1880:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
1881:../uvc.c      **** 					 		 }
1882:../uvc.c      **** 					 		 I2CCmdHandler();
1883:../uvc.c      **** 							 break;
1884:../uvc.c      **** 				 	 	 case ExtAexModCtlID9://4byte
1885:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1886:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
1887:../uvc.c      **** 							 {
1888:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//exposure mode (assume b3:2=00, no BLC wind
1889:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1890:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
1891:../uvc.c      **** 								 dataIdx++;
1892:../uvc.c      **** 							 }
1893:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi != Data1){
1894:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
1895:../uvc.c      **** 								 if(Data0 == 2 || Data0 == 3){
1896:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //AGC
1897:../uvc.c      **** 								 }
1898:../uvc.c      **** 							 }
1899:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
1900:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1901:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1902:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi,
1903:../uvc.c      **** 									 EXTShutter.UVCCurVLo, Data0, Data1);
1904:../uvc.c      **** 							 break;
1905:../uvc.c      **** 					 	 case ExtShutCtlID0: //special!!
1906:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0; //CtrlParArry[CtrlID][13] save new setting
1907:../uvc.c      **** 	#if 1	// register setting directly
1908:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)//based on the Aex Mode 2 has been masked in vi
1909:../uvc.c      **** 						     {
1910:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
1911:../uvc.c      **** 						    	 dataIdx = 0;
1912:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1913:../uvc.c      **** 								 //cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
1914:../uvc.c      **** 								 //dataIdx++;
1915:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1916:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1917:../uvc.c      **** 						     }
1918:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
1919:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
1920:../uvc.c      **** 						     break;
1921:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level 2bytes standard operation!!!
1922:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1923:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){
1924:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
1925:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
1926:../uvc.c      **** 									 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
1927:../uvc.c      **** 									 //dataIdx++;
1928:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //shutter level
1929:../uvc.c      **** 								 }
1930:../uvc.c      **** 							 }
1931:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1932:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1933:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1934:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
1935:../uvc.c      **** 							 break;
1936:../uvc.c      **** 
1937:../uvc.c      **** 	#else	// old fashion
1938:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
1939:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
1940:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
1941:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
1942:../uvc.c      **** 									 }else{
1943:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
1944:../uvc.c      **** 									 }
1945:../uvc.c      **** 								 }
1946:../uvc.c      **** 							 }else{
1947:../uvc.c      **** 								 Data1 = Data0 - 1;
1948:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
1949:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
1950:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
1951:../uvc.c      **** 									 }else{
1952:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
1953:../uvc.c      **** 									 }
1954:../uvc.c      **** 								 }
1955:../uvc.c      **** 								 if(Data1 < 8){
1956:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
1957:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
1958:../uvc.c      **** 								 }else{
1959:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
1960:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
1961:../uvc.c      **** 								 }
1962:../uvc.c      **** 							 }
1963:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
1964:../uvc.c      **** 							 dataIdx = 0;
1965:../uvc.c      **** 							 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
1966:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1967:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
1968:../uvc.c      **** 							 if(AxMode){
1969:../uvc.c      **** 								 dataIdx++;
1970:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
1971:../uvc.c      **** 								 dataIdx++;
1972:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustme
1973:../uvc.c      **** 							 }
1974:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1975:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
1976:../uvc.c      **** 							 break;
1977:../uvc.c      **** 	#endif
1978:../uvc.c      **** 						 case Ext1BLCRangeCtlID4:
1979:../uvc.c      **** 	#if 0 //seperate version
1980:../uvc.c      **** 							 //registers value BLD window enable (0x17); position (0x13); size (0x14).getData = Data0&0x
1981:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
1982:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1983:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
1984:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
1985:../uvc.c      **** 							 }else{ //disable BLD window
1986:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
1987:../uvc.c      **** 							 }
1988:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
1989:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
1990:../uvc.c      **** 							 dataIdx++;
1991:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
1992:../uvc.c      **** 							 dataIdx++;
1993:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
1994:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
1995:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
1996:../uvc.c      **** 							 dataIdx++;
1997:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
1998:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1999:../uvc.c      **** 	#else //combination version
2000:../uvc.c      **** 							 //Data0 = Data0&0x7F; //mask window show flag bit.
2001:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2002:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
2003:../uvc.c      **** 							 dataIdx++;
2004:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
2005:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2006:../uvc.c      **** 							 getData1 = Data1;
2007:../uvc.c      **** 	#endif
2008:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
2009:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
2010:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
2011:../uvc.c      **** 							 break;
2012:../uvc.c      **** 				 	 	 case Ext1ExCtrlSpeedCtlID8:
2013:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){  //2Bytes
2014:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
2015:../uvc.c      **** 								 Data1 = SensorGetControl(RegAdd0, devAdd); //get the origin data as the fine shutter enabl
2016:../uvc.c      **** 								 Data1 &= 0x0F; Data0 = (Data0&0x0F) << 4;
2017:../uvc.c      **** 								 Data0 |= Data1;
2018:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2019:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
2020:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2021:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
2022:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2023:../uvc.c      **** 							 }
2024:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
2025:../uvc.c      **** 
2026:../uvc.c      **** 				 	 	 case Ext1BLCWeightCtlID5:
2027:../uvc.c      **** 				 	 	 case Ext1ExHysterCtlID7:
2028:../uvc.c      **** 				 	 	 case Ext1EnhanceModeCtlID9:
2029:../uvc.c      **** 				 	 	 case Ext1EnhanceGainCtlID10:
2030:../uvc.c      **** 				 	 	 case Ext12DNRGainEnblCtlID12:
2031:../uvc.c      **** 				 	 	 case Ext1GammaCorCtlID14:
2032:../uvc.c      **** 				 	 	 case Ext1AGCMaxLimetCtlID15:
2033:../uvc.c      **** 				 	 	 case Ext1EnhanceStarEndCtlID11://4bytes
2034:../uvc.c      **** 				 	 	 case Ext12DNRGainStarEndCtlID13://4bytes
2035:../uvc.c      **** 						 case ExtExRefCtlID10:
2036:../uvc.c      **** 				 	 	 default:
2037:../uvc.c      **** 				 	 			 if(Len == 2)
2038:../uvc.c      **** 				 	 			 {
2039:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){  //2Bytes
2040:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2041:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
2042:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2043:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
2044:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
2045:../uvc.c      **** 									 }
2046:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
2047:../uvc.c      **** 				 	 			 }else if(Len == 4){
2048:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
2049:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
2050:../uvc.c      **** 									 {
2051:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//exposure mode (assume b3:2=00, no BLC wi
2052:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
2053:../uvc.c      **** 										 dataIdx++;
2054:../uvc.c      **** 									 }
2055:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi != Data1){
2056:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
2057:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
2058:../uvc.c      **** 									 }
2059:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
2060:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2061:../uvc.c      **** 
2062:../uvc.c      **** 				 	 			 }
2063:../uvc.c      **** 				 	 			 CyU3PDebugPrint (4, "The data gets from host. [0]: 0x%x [1]: 0x%x curLo: 0x%x curHi: 0x%
2064:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
2065:../uvc.c      **** 				 	 			 break;
2066:../uvc.c      **** 					 }
2067:../uvc.c      **** 			 	 }
2068:../uvc.c      **** 			 	 else{
2069:../uvc.c      **** 					 switch(CtrlID)
2070:../uvc.c      **** 					 {
2071:../uvc.c      **** 						 case BrgtCtlID1:
2072:../uvc.c      **** 	#if 0 //cancel for 5MP w/b camera
2073:../uvc.c      **** 								 dataIdx = 0;
2074:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2075:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
2076:../uvc.c      **** 								  if(Data0&0x80){
2077:../uvc.c      **** 									  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
2078:../uvc.c      **** 								  }else{
2079:../uvc.c      **** 									  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
2080:../uvc.c      **** 								  }
2081:../uvc.c      **** 								 Data1 |= ~0x03;
2082:../uvc.c      **** 								 Data1 &= 0xC7;
2083:../uvc.c      **** 							  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
2084:../uvc.c      **** 							  	 dataIdx++;
2085:../uvc.c      **** 
2086:../uvc.c      **** 								 Data0 = (Data0 << 2);
2087:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
2088:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2089:../uvc.c      **** 
2090:../uvc.c      **** 								 CtrlParArry[CtrlID][13] = Data0;
2091:../uvc.c      **** 								 CtrlParArry[CtrlID][14] = Data1;
2092:../uvc.c      **** 								 CtrlParArry[CtrlID][16] = CyTrue;
2093:../uvc.c      **** 	#endif
2094:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2095:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
2096:../uvc.c      **** 								 /*// new I2C command. direct using Data0 coming from host. 8/23/2016
2097:../uvc.c      **** 								 if(Data0&0x80){
2098:../uvc.c      **** 									  Data0 = Data0 - 0x80;
2099:../uvc.c      **** 								  }else{
2100:../uvc.c      **** 									  Data0 = ~Data0;
2101:../uvc.c      **** 								  }
2102:../uvc.c      **** 								  */
2103:../uvc.c      **** 							  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
2104:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2105:../uvc.c      **** 
2106:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2107:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2108:../uvc.c      **** 							 break;
2109:../uvc.c      **** 						 case HueCtlID5://not being used
2110:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2111:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
2112:../uvc.c      **** 							 dataIdx++;
2113:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
2114:../uvc.c      **** 							 dataIdx++;
2115:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
2116:../uvc.c      **** 							 dataIdx++;
2117:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
2118:../uvc.c      **** 							 dataIdx++;
2119:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
2120:../uvc.c      **** 							 dataIdx++;
2121:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
2122:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2123:../uvc.c      **** 
2124:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0] - GREEN_BASE;
2125:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2126:../uvc.c      **** 							 break;
2127:../uvc.c      **** 						 case MFreqCtlID4:
2128:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2129:../uvc.c      **** 							 //Data0 = Data0 - 1;
2130:../uvc.c      **** 							 is60Hz = Data0;
2131:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
2132:../uvc.c      **** 							 {
2133:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
2134:../uvc.c      **** 								 is60Hz = CyFalse;
2135:../uvc.c      **** 							 }
2136:../uvc.c      **** 							 else if(Data0 >2)
2137:../uvc.c      **** 							 {
2138:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
2139:../uvc.c      **** 								 is60Hz = CyTrue;
2140:../uvc.c      **** 							 }
2141:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
2142:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
2143:../uvc.c      **** 							 {
2144:../uvc.c      **** 			                       switch (setRes)
2145:../uvc.c      **** 			                         {
2146:../uvc.c      **** 			                         	case 1: //1944
2147:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR_
2148:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2149:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
2150:../uvc.c      **** 			                         		break;
2151:../uvc.c      **** 			                         	case 2: //1080
2152:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR_
2153:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2154:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
2155:../uvc.c      **** 			                         		break;
2156:../uvc.c      **** 			                         	case 3: //720
2157:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, I
2158:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2159:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
2160:../uvc.c      **** 			                         		break;
2161:../uvc.c      **** 			                         	case 4: //VGA
2162:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x32:0xB2)&0xFC)|ROIMode, I
2163:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2164:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
2165:../uvc.c      **** 			                         	default:
2166:../uvc.c      **** 			                         		break;
2167:../uvc.c      **** 			                         }
2168:../uvc.c      **** 							 }
2169:../uvc.c      **** 
2170:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2171:../uvc.c      **** 							 break;
2172:../uvc.c      **** 						 case WBTLevCtlID11: //4bytes
2173:../uvc.c      **** 							 //Data0 = glEp0Buffer[0]; //blue
2174:../uvc.c      **** 							 //Data1 = glEp0Buffer[2]; //red
2175:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2176:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2177:../uvc.c      **** 							 dataIdx++;
2178:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
2179:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2180:../uvc.c      **** 
2181:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
2182:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
2183:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2184:../uvc.c      **** 							 break;
2185:../uvc.c      **** 						 case BLCCtlID0:
2186:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2187:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
2188:../uvc.c      **** 							 {
2189:../uvc.c      **** 								 if(Data0 < 3){
2190:../uvc.c      **** 					 				 Data0 += 4;
2191:../uvc.c      **** 					 			 }else{
2192:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
2193:../uvc.c      **** 									Data0 = 4; //set to default.
2194:../uvc.c      **** 					 			 }
2195:../uvc.c      **** 					 		 }else{
2196:../uvc.c      **** 					 			 Data0 |= EXTBLCGrid.UVCCurVLo << 7;
2197:../uvc.c      **** 					 		 }
2198:../uvc.c      **** 
2199:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2200:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2201:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2202:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2203:../uvc.c      **** 					 		 break;
2204:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
2205:../uvc.c      **** 
2206:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2207:../uvc.c      **** 							 if(Data0 != 0){
2208:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2209:../uvc.c      **** 	#ifdef COLOR
2210:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Second: set enhancement valu
2211:../uvc.c      **** 	#else
2212:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
2213:../uvc.c      **** 								 dataIdx++;
2214:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
2215:../uvc.c      **** 	#endif
2216:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2217:../uvc.c      **** 							 }else{
2218:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2219:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
2220:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2221:../uvc.c      **** 							 }
2222:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2223:../uvc.c      **** 							 break;
2224:../uvc.c      **** 						 case ConsCtlID2:
2225:../uvc.c      **** 						 case WBTMdCtlID9:
2226:../uvc.c      **** 						 case SaturCtlID6:
2227:../uvc.c      **** 						 default:
2228:../uvc.c      **** 			 	 			 if(Len == 2)
2229:../uvc.c      **** 			 	 			 {
2230:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0){  //2Bytes
2231:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2232:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
2233:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2234:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
2235:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
2236:../uvc.c      **** 								 }
2237:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2238:../uvc.c      **** 			 	 			 }else if(Len == 4){
2239:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
2240:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
2241:../uvc.c      **** 								 {
2242:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//exposure mode (assume b3:2=00, no BLC window). C
2243:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
2244:../uvc.c      **** 									 dataIdx++;
2245:../uvc.c      **** 								 }
2246:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVHi != Data1){
2247:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
2248:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
2249:../uvc.c      **** 								 }
2250:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2251:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2252:../uvc.c      **** 
2253:../uvc.c      **** 			 	 			 }
2254:../uvc.c      **** 			 	 			 CyU3PDebugPrint (4, "The data gets from host. [0]: 0x%x [1]: 0x%x curLo: 0x%x curHi: 0x%x
2255:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
2256:../uvc.c      **** 			 	 			 break;
2257:../uvc.c      **** 					 }
2258:../uvc.c      **** 			 	 }
2259:../uvc.c      **** 			   }else{
2260:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
2261:../uvc.c      **** 			   }
2262:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2263:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
2264:../uvc.c      **** #endif
2265:../uvc.c      **** 
2266:../uvc.c      **** 			  break;
2267:../uvc.c      **** 		  default:
2268:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
2269:../uvc.c      **** 			  break;
2270:../uvc.c      **** 		 }
2271:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
2272:../uvc.c      **** }
2273:../uvc.c      **** /************** CT control requests handler *************************/
2274:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
2275:../uvc.c      **** 
2276:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
2277:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
2278:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
2279:../uvc.c      ****     uint16_t readCount;
2280:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
2281:../uvc.c      ****     uint16_t diff, value, diffRd;
2282:../uvc.c      ****     uint8_t i, shutter, index;
2283:../uvc.c      ****     diff = 0xffff;
2284:../uvc.c      ****     shutter = 1;
2285:../uvc.c      ****     index = 1;
2286:../uvc.c      **** 
2287:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
2288:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
2289:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
2290:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
2291:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
2292:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2293:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
2294:../uvc.c      **** #endif
2295:../uvc.c      ****     reqData = bRequest;
2296:../uvc.c      **** 
2297:../uvc.c      ****     switch (bRequest)
2298:../uvc.c      **** 		 {
2299:../uvc.c      **** 
2300:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
2301:../uvc.c      **** 			  glEp0Buffer[0] = Len;
2302:../uvc.c      **** 			  glEp0Buffer[1] = 0;
2303:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2304:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2305:../uvc.c      **** 			  break;
2306:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
2307:../uvc.c      **** 
2308:../uvc.c      **** 			 switch(CtrlID)
2309:../uvc.c      **** 			 {
2310:../uvc.c      **** 				 default:
2311:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
2312:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
2313:../uvc.c      **** 					 glEp0Buffer[2] = 0;
2314:../uvc.c      **** 					 glEp0Buffer[3] = 0;
2315:../uvc.c      **** 					 sendData = glEp0Buffer[0];
2316:../uvc.c      **** 					 break;
2317:../uvc.c      **** 			 }
2318:../uvc.c      **** 
2319:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2320:../uvc.c      **** 
2321:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2322:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
2323:../uvc.c      **** #endif
2324:../uvc.c      **** 			  break;
2325:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
2326:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
2327:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
2328:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
2329:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2330:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2331:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2332:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2333:../uvc.c      **** 			  break;
2334:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
2335:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
2336:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
2337:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
2338:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2339:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2340:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2341:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2342:../uvc.c      **** 			  break;
2343:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
2344:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
2345:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
2346:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
2347:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2348:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2349:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2350:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2351:../uvc.c      **** 			  break;
2352:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
2353:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
2354:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2355:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2356:../uvc.c      **** 			  Len = 1;
2357:../uvc.c      **** 			  break;
2358:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
2359:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
2360:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
2361:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
2362:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2363:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2364:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2365:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2366:../uvc.c      **** 			  break;
2367:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
2368:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2369:../uvc.c      **** 			  glEp0Buffer, &readCount);
2370:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
2371:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
2372:../uvc.c      **** 			  value = Data1;
2373:../uvc.c      **** 
2374:../uvc.c      **** 			  switch(CtrlID)
2375:../uvc.c      **** 			  {
2376:../uvc.c      **** 		  	      case AutoExMCtlID1:
2377:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
2378:../uvc.c      **** 
2379:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
2380:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
2381:../uvc.c      **** 				    getData = glEp0Buffer[0];
2382:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
2383:../uvc.c      **** 		  		    switch (getData){
2384:../uvc.c      **** 						case 1:
2385:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
2386:../uvc.c      **** 							break;
2387:../uvc.c      **** 						case 2:
2388:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
2389:../uvc.c      **** 							dataIdx = 0;
2390:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2391:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
2392:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2393:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
2394:../uvc.c      **** 
2395:../uvc.c      **** 							break;
2396:../uvc.c      **** 						case 4:
2397:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
2398:../uvc.c      **** 							break;
2399:../uvc.c      **** 						case 8:
2400:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
2401:../uvc.c      **** 			  		    	dataIdx = 0;
2402:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2403:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
2404:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2405:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
2406:../uvc.c      **** 							break;
2407:../uvc.c      **** 		  		    }
2408:../uvc.c      **** #if 0
2409:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
2410:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
2411:../uvc.c      **** 						  dataIdx = 0;
2412:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2413:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
2414:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2415:../uvc.c      **** 		  		    }
2416:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
2417:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
2418:../uvc.c      **** 		  		    }
2419:../uvc.c      **** #endif
2420:../uvc.c      **** 				    break;
2421:../uvc.c      **** 
2422:../uvc.c      **** 			  	  case ExTmACtlID3:
2423:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
2424:../uvc.c      **** 
2425:../uvc.c      **** 					  value = (value << 8)|Data0;
2426:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
2427:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
2428:../uvc.c      **** 					  {
2429:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
2430:../uvc.c      **** 						  {
2431:../uvc.c      **** 							if(value > ShutValueArry[i]){
2432:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
2433:../uvc.c      **** 							}else{
2434:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
2435:../uvc.c      **** 							}
2436:../uvc.c      **** 							  if(diff > diffRd){
2437:../uvc.c      **** 								  diff = diffRd;
2438:../uvc.c      **** 								  index = i;
2439:../uvc.c      **** 							  }
2440:../uvc.c      **** 						  }
2441:../uvc.c      **** 						  shutter = shutter+index;
2442:../uvc.c      **** 
2443:../uvc.c      **** 						  dataIdx = 0;
2444:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2445:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
2446:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2447:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
2448:../uvc.c      **** 
2449:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
2450:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
2451:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
2452:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
2453:../uvc.c      **** 					  }else{
2454:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
2455:../uvc.c      **** 					  }
2456:../uvc.c      **** 					  getData = glEp0Buffer[0];
2457:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
2458:../uvc.c      **** 					  break;
2459:../uvc.c      **** 			  	  case IriACtlID7:
2460:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
2461:../uvc.c      **** 					  {
2462:../uvc.c      **** 							 dataIdx = 0;
2463:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2464:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
2465:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2466:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
2467:../uvc.c      **** 
2468:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
2469:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
2470:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
2471:../uvc.c      **** 					  }else{
2472:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
2473:../uvc.c      **** 					  }
2474:../uvc.c      **** 					  getData = glEp0Buffer[0];
2475:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
2476:../uvc.c      **** 
2477:../uvc.c      **** 					  break;
2478:../uvc.c      **** 			  	  case ZmOpRCtlID10:
2479:../uvc.c      **** 					  getData = glEp0Buffer[0];
2480:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
2481:../uvc.c      **** #if 1
2482:../uvc.c      **** 					  dataIdx = 0;
2483:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2484:../uvc.c      **** 					  if(getData == 1)
2485:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
2486:../uvc.c      **** 					  else if(getData == 0xff)
2487:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
2488:../uvc.c      **** 					  else
2489:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
2490:../uvc.c      **** 					  //dataIdx++;
2491:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
2492:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2493:../uvc.c      **** #endif
2494:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
2495:../uvc.c      **** 					  break;
2496:../uvc.c      **** 
2497:../uvc.c      **** 			  	  default:
2498:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
2499:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
2500:../uvc.c      **** 			  		 break;
2501:../uvc.c      **** 			  }
2502:../uvc.c      **** 			  break;
2503:../uvc.c      **** 		  default:
2504:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
2505:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
2506:../uvc.c      **** 			  break;
2507:../uvc.c      **** 		 }
2508:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
2509:../uvc.c      **** 
2510:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
2511:../uvc.c      **** }
2512:../uvc.c      **** 
2513:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
2514:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
2515:../uvc.c      **** {
2516:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
2517:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
2518:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
2519:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
2520:../uvc.c      **** 
2521:../uvc.c      ****     CtrlID = BrgtCtlID1;
2522:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
2523:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2524:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
2525:../uvc.c      ****     Data1 = Data0;
2526:../uvc.c      **** 
2527:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2528:../uvc.c      ****     if(Data1&0x80){
2529:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
2530:../uvc.c      ****     }else{
2531:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
2532:../uvc.c      ****     }
2533:../uvc.c      ****     Data0 = (Data0 << 2);
2534:../uvc.c      **** 
2535:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
2536:../uvc.c      **** 
2537:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
2538:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
2539:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2540:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
2541:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
2542:../uvc.c      **** 
2543:../uvc.c      ****     CtrlID = ConsCtlID2;
2544:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2545:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2546:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2547:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
2548:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2549:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
2550:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2551:../uvc.c      **** 
2552:../uvc.c      ****     CtrlID = HueCtlID5;
2553:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2554:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2555:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2556:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
2557:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
2558:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
2559:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
2560:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
2561:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
2562:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
2563:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
2564:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
2565:../uvc.c      **** 
2566:../uvc.c      ****     CtrlID = SaturCtlID6;
2567:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2568:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2569:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
2570:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
2571:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
2572:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2573:../uvc.c      **** 
2574:../uvc.c      ****     CtrlID = ShapCtlID7;
2575:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2576:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2577:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2578:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
2579:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2580:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2581:../uvc.c      **** 
2582:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
2583:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
2584:../uvc.c      **** 	return;
2585:../uvc.c      **** }
2586:../uvc.c      **** 
2587:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
2588:../uvc.c      **** void
2589:../uvc.c      **** CyFxUVCAddHeader (
2590:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
2591:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
2592:../uvc.c      ****         )
2593:../uvc.c      **** {
2594:../uvc.c      ****     /* Copy header to buffer */
2595:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2596:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
2597:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
2598:../uvc.c      **** 
2599:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
2600:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
2601:../uvc.c      ****     {
2602:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
2603:../uvc.c      ****     }
2604:../uvc.c      **** }
2605:../uvc.c      **** 
2606:../uvc.c      **** 
2607:../uvc.c      **** /* Application Error Handler */
2608:../uvc.c      **** void
2609:../uvc.c      **** CyFxAppErrorHandler (
2610:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
2611:../uvc.c      ****         )
2612:../uvc.c      **** {
2613:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
2614:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
2615:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
2616:../uvc.c      **** 
2617:../uvc.c      ****        This function can be modified to take additional error handling actions such
2618:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
2619:../uvc.c      ****      */
2620:../uvc.c      ****     for (;;)
2621:../uvc.c      ****     {
2622:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
2623:../uvc.c      ****         CyU3PThreadSleep (1000);
2624:../uvc.c      ****     }
2625:../uvc.c      **** }
2626:../uvc.c      **** 
2627:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
2628:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
2629:../uvc.c      ****  */
2630:../uvc.c      **** static void
2631:../uvc.c      **** CyFxUVCApplnAbortHandler (
2632:../uvc.c      ****         void)
2633:../uvc.c      **** {
2634:../uvc.c      **** 	uint32_t flag;
2635:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
2636:../uvc.c      **** 	{
2637:../uvc.c      ****         /* Clear the Video Stream Request Event */
2638:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
2639:../uvc.c      **** 
2640:../uvc.c      ****         /* Set Video Stream Abort Event */
2641:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
2642:../uvc.c      **** 	}
2643:../uvc.c      **** }
2644:../uvc.c      **** 
2645:../uvc.c      **** /* This is the Callback function to handle the USB Events */
2646:../uvc.c      **** static void
2647:../uvc.c      **** CyFxUVCApplnUSBEventCB (
2648:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
2649:../uvc.c      ****         uint16_t             evdata  /* Event data */
2650:../uvc.c      ****         )
2651:../uvc.c      **** {
2652:../uvc.c      ****     switch (evtype)
2653:../uvc.c      ****     {
2654:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
2655:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
2656:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2657:../uvc.c      ****             gpif_initialized = 0;
2658:../uvc.c      ****             streamingStarted = CyFalse;
2659:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2660:../uvc.c      ****             break;
2661:../uvc.c      **** 
2662:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
2663:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
2664:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2665:../uvc.c      ****             gpif_initialized = 0;
2666:../uvc.c      ****             streamingStarted = CyFalse;
2667:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2668:../uvc.c      ****             break;
2669:../uvc.c      **** 
2670:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
2671:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
2672:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2673:../uvc.c      ****             gpif_initialized = 0;
2674:../uvc.c      ****             isUsbConnected = CyFalse;
2675:../uvc.c      ****             streamingStarted = CyFalse;
2676:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2677:../uvc.c      ****             break;
2678:../uvc.c      **** 
2679:../uvc.c      **** #ifdef BACKFLOW_DETECT
2680:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
2681:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
2682:../uvc.c      ****             break;
2683:../uvc.c      **** #endif
2684:../uvc.c      **** 
2685:../uvc.c      ****         default:
2686:../uvc.c      ****             break;
2687:../uvc.c      ****     }
2688:../uvc.c      **** }
2689:../uvc.c      **** 
2690:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
2691:../uvc.c      **** static CyBool_t
2692:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
2693:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
2694:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
2695:../uvc.c      ****         )
2696:../uvc.c      **** {
2697:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
2698:../uvc.c      ****     uint32_t status;
2699:../uvc.c      **** 
2700:../uvc.c      ****     /* Obtain Request Type and Request */
2701:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
2702:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
2703:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
2704:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
2705:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
2706:../uvc.c      **** 
2707:../uvc.c      ****     /* Check for UVC Class Requests */
2708:../uvc.c      ****     switch (bmReqType)
2709:../uvc.c      ****     {
2710:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
2711:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
2712:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
2713:../uvc.c      ****             switch (wIndex & 0xFF)
2714:../uvc.c      ****             {
2715:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
2716:../uvc.c      ****                     {
2717:../uvc.c      ****                         uvcHandleReq = CyTrue;
2718:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
2719:../uvc.c      ****                                 CYU3P_EVENT_OR);
2720:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2721:../uvc.c      ****                         {
2722:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
2723:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2724:../uvc.c      ****                         }
2725:../uvc.c      ****                     }
2726:../uvc.c      ****                     break;
2727:../uvc.c      **** 
2728:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
2729:../uvc.c      ****                     {
2730:../uvc.c      ****                         uvcHandleReq = CyTrue;
2731:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
2732:../uvc.c      ****                                 CYU3P_EVENT_OR);
2733:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2734:../uvc.c      ****                         {
2735:../uvc.c      ****                             /* Error handling */
2736:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
2737:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2738:../uvc.c      ****                         }
2739:../uvc.c      ****                     }
2740:../uvc.c      ****                     break;
2741:../uvc.c      **** 
2742:../uvc.c      ****                 default:
2743:../uvc.c      ****                     break;
2744:../uvc.c      ****             }
2745:../uvc.c      ****             break;
2746:../uvc.c      **** 
2747:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
2748:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
2749:../uvc.c      ****             {
2750:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
2751:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
2752:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
2753:../uvc.c      ****                 {
2754:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
2755:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
2756:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
2757:../uvc.c      ****                     gpif_initialized = 0;
2758:../uvc.c      ****                     streamingStarted = CyFalse;
2759:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
2760:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2761:../uvc.c      ****                     CyU3PBusyWait (100);
2762:../uvc.c      **** 
2763:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
2764:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2765:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2766:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2767:../uvc.c      ****                     CyU3PBusyWait (100);
2768:../uvc.c      **** 
2769:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
2770:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2771:../uvc.c      ****                     uvcHandleReq = CyTrue;
2772:../uvc.c      ****                     /* Complete Control request handshake */
2773:../uvc.c      ****                     CyU3PUsbAckSetup ();
2774:../uvc.c      ****                     /* Indicate stop streaming to main thread */
2775:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
2776:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
2777:../uvc.c      **** 
2778:../uvc.c      ****                 }
2779:../uvc.c      ****             }
2780:../uvc.c      ****             break;
2781:../uvc.c      **** 
2782:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
2783:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
2784:../uvc.c      ****             {
2785:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
2786:../uvc.c      ****                 {
2787:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
2788:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
2789:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
2790:../uvc.c      ****                 	 * has started. */
2791:../uvc.c      ****                     if (streamingStarted == CyTrue)
2792:../uvc.c      ****                     {
2793:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
2794:../uvc.c      **** 
2795:../uvc.c      ****                         /* Disable the GPIF state machine. */
2796:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
2797:../uvc.c      ****                         gpif_initialized = 0;
2798:../uvc.c      ****                         streamingStarted = CyFalse;
2799:../uvc.c      **** 
2800:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
2801:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2802:../uvc.c      ****                         CyU3PBusyWait (100);
2803:../uvc.c      **** 
2804:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
2805:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2806:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2807:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2808:../uvc.c      ****                         CyU3PBusyWait (100);
2809:../uvc.c      **** 
2810:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
2811:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2812:../uvc.c      **** 
2813:../uvc.c      ****                         uvcHandleReq = CyTrue;
2814:../uvc.c      ****                         /* Complete Control request handshake */
2815:../uvc.c      ****                         CyU3PUsbAckSetup ();
2816:../uvc.c      ****                         /* Indicate stop streaming to main thread */
2817:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
2818:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
2819:../uvc.c      ****                     }
2820:../uvc.c      ****                     else
2821:../uvc.c      ****                     {
2822:../uvc.c      ****                         uvcHandleReq = CyTrue;
2823:../uvc.c      ****                         CyU3PUsbAckSetup ();
2824:../uvc.c      ****                     }
2825:../uvc.c      ****                 }
2826:../uvc.c      ****             }
2827:../uvc.c      ****             break;
2828:../uvc.c      **** 
2829:../uvc.c      ****         default:
2830:../uvc.c      ****             break;
2831:../uvc.c      ****     }
2832:../uvc.c      **** 
2833:../uvc.c      ****     /* Return status of request handling to the USB driver */
2834:../uvc.c      ****     return uvcHandleReq;
2835:../uvc.c      **** }
2836:../uvc.c      **** 
2837:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
2838:../uvc.c      **** 
2839:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
2840:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
2841:../uvc.c      ****  */
2842:../uvc.c      **** void
2843:../uvc.c      **** CyFxUvcApplnDmaCallback (
2844:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
2845:../uvc.c      ****         CyU3PDmaCbType_t      type,
2846:../uvc.c      ****         CyU3PDmaCBInput_t    *input
2847:../uvc.c      ****         )
2848:../uvc.c      **** {
2849:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
2850:../uvc.c      **** #if 1
2851:../uvc.c      ****     CyU3PReturnStatus_t status;
2852:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
2853:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
2854:../uvc.c      **** 
2855:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2856:../uvc.c      ****     {
2857:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
2858:../uvc.c      ****             {
2859:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
2860:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
2861:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2862:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
2863:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2864:../uvc.c      ****                 	stiflag = 0x03;
2865:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
2866:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2867:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2868:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2869:../uvc.c      ****                 }
2870:../uvc.c      **** #endif
2871:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
2872:../uvc.c      ****                 fb++;
2873:../uvc.c      ****             }
2874:../uvc.c      ****             else
2875:../uvc.c      ****             {
2876:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
2877:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
2878:../uvc.c      ****                 pb++;
2879:../uvc.c      ****                 pbc = input->buffer_p.count;
2880:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
2881:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
2882:../uvc.c      ****                 //lineCount = 0; //res test
2883:../uvc.c      **** #if 1   //remove the still flag clearing here
2884:../uvc.c      ****                 if(stiflag == 0x0F){
2885:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2886:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2887:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2888:../uvc.c      ****                 	stiflag = 0xAA;
2889:../uvc.c      ****                 }
2890:../uvc.c      **** #endif
2891:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
2892:../uvc.c      ****             }
2893:../uvc.c      **** 
2894:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
2895:../uvc.c      ****             prodCount++;
2896:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2897:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
2898:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
2899:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
2900:../uvc.c      ****             {
2901:../uvc.c      ****                 prodCount--;
2902:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
2903:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
2904:../uvc.c      ****             }
2905:../uvc.c      ****     }
2906:../uvc.c      **** #endif
2907:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
2908:../uvc.c      ****     {
2909:../uvc.c      ****         consCount++;
2910:../uvc.c      ****         streamingStarted = CyTrue;
2911:../uvc.c      ****     }
2912:../uvc.c      **** }
2913:../uvc.c      **** 
2914:../uvc.c      **** /*
2915:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
2916:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
2917:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
2918:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
2919:../uvc.c      ****  * to commit the buffer.
2920:../uvc.c      ****  */
2921:../uvc.c      **** static uint8_t
2922:../uvc.c      **** CyFxUvcAppCommitEOF (
2923:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
2924:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
2925:../uvc.c      ****         )
2926:../uvc.c      **** {
2927:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2928:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
2929:../uvc.c      **** 
2930:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
2931:../uvc.c      **** 
2932:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2933:../uvc.c      ****     {
2934:../uvc.c      ****         switch (stateId)
2935:../uvc.c      ****         {
2936:../uvc.c      **** 
2937:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
2938:../uvc.c      ****             case FULL_BUF_IN_SCK1:
2939:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2940:../uvc.c      ****                 break;
2941:../uvc.c      **** 
2942:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
2943:../uvc.c      ****                 socket = 0;
2944:../uvc.c      ****                 break;
2945:../uvc.c      **** 
2946:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
2947:../uvc.c      ****                 socket = 1;
2948:../uvc.c      ****                 break;
2949:../uvc.c      **** 
2950:../uvc.c      ****             default:
2951:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2952:../uvc.c      ****                 /* Unexpected current state. Return error. */
2953:../uvc.c      ****             	//lineCount++;
2954:../uvc.c      ****             	return 1;
2955:../uvc.c      ****         }
2956:../uvc.c      ****     }
2957:../uvc.c      **** 
2958:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2959:../uvc.c      ****     {
2960:../uvc.c      ****         switch (stateId)
2961:../uvc.c      ****         {
2962:../uvc.c      **** #ifndef CAM720
2963:../uvc.c      **** #ifdef GPIFIIM
2964:../uvc.c      ****             case 13:
2965:../uvc.c      ****             case 24:
2966:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2967:../uvc.c      ****                 break;
2968:../uvc.c      **** 
2969:../uvc.c      ****             case 8:
2970:../uvc.c      ****                 socket = 0;
2971:../uvc.c      ****                 break;
2972:../uvc.c      **** 
2973:../uvc.c      ****             case 20:
2974:../uvc.c      ****                 socket = 1;
2975:../uvc.c      ****                 break;
2976:../uvc.c      **** #else
2977:../uvc.c      ****             case 11:
2978:../uvc.c      ****             case 18:
2979:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2980:../uvc.c      ****                 break;
2981:../uvc.c      **** 
2982:../uvc.c      ****             case 8:
2983:../uvc.c      ****                 socket = 0;
2984:../uvc.c      ****                 break;
2985:../uvc.c      **** 
2986:../uvc.c      ****             case 15:
2987:../uvc.c      ****                 socket = 1;
2988:../uvc.c      ****                 break;
2989:../uvc.c      **** #endif
2990:../uvc.c      **** #else
2991:../uvc.c      ****             case 11:
2992:../uvc.c      ****             case 18:
2993:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2994:../uvc.c      ****                 break;
2995:../uvc.c      **** 
2996:../uvc.c      ****             case 8:
2997:../uvc.c      ****                 socket = 0;
2998:../uvc.c      ****                 break;
2999:../uvc.c      **** 
3000:../uvc.c      ****             case 15:
3001:../uvc.c      ****                 socket = 1;
3002:../uvc.c      ****                 break;
3003:../uvc.c      **** 
3004:../uvc.c      **** #endif
3005:../uvc.c      ****              default:
3006:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
3007:../uvc.c      ****                 /* Unexpected current state. Return error. */
3008:../uvc.c      ****                return 1;
3009:../uvc.c      ****         }
3010:../uvc.c      ****     }
3011:../uvc.c      **** 
3012:../uvc.c      ****     if (socket != 0xFF)
3013:../uvc.c      ****     {
3014:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
3015:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
3016:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
3017:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
3018:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
3019:../uvc.c      ****         {
3020:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
3021:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
3022:../uvc.c      ****         }
3023:../uvc.c      ****     }
3024:../uvc.c      **** 
3025:../uvc.c      ****     return 0;
3026:../uvc.c      **** }
3027:../uvc.c      **** 
3028:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
3029:../uvc.c      **** void
3030:../uvc.c      **** CyFxGpifCB (
3031:../uvc.c      ****         CyU3PGpifEventType event,
3032:../uvc.c      ****         uint8_t currentState
3033:../uvc.c      ****         )
3034:../uvc.c      **** {
3035:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
3036:../uvc.c      ****     {
3037:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
3038:../uvc.c      ****     	           in the UVC implementation. */
3039:../uvc.c      ****     	//hitFV = CyTrue;
3040:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
3041:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
3042:../uvc.c      ****     }
3043:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
3044:../uvc.c      **** }
3045:../uvc.c      **** 
3046:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
3047:../uvc.c      **** static void
3048:../uvc.c      **** CyFxUVCApplnDebugInit (
3049:../uvc.c      ****         void)
3050:../uvc.c      **** {
3051:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
3052:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3053:../uvc.c      **** 
3054:../uvc.c      ****     /* Initialize the UART for printing debug messages */
3055:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
3056:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3057:../uvc.c      ****     {
3058:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
3059:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3060:../uvc.c      ****     }
3061:../uvc.c      **** 
3062:../uvc.c      ****     /* Set UART Configuration */
3063:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
3064:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
3065:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
3066:../uvc.c      ****     uartConfig.txEnable = CyTrue;
3067:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
3068:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
3069:../uvc.c      ****     uartConfig.isDma    = CyTrue;
3070:../uvc.c      **** 
3071:../uvc.c      ****     /* Set the UART configuration */
3072:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
3073:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3074:../uvc.c      ****     {
3075:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3076:../uvc.c      ****     }
3077:../uvc.c      **** 
3078:../uvc.c      ****     /* Set the UART transfer */
3079:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
3080:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3081:../uvc.c      ****     {
3082:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3083:../uvc.c      ****     }
3084:../uvc.c      **** 
3085:../uvc.c      ****     /* Initialize the Debug logger module. */
3086:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
3087:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3088:../uvc.c      ****     {
3089:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3090:../uvc.c      ****     }
3091:../uvc.c      **** 
3092:../uvc.c      ****     /* Disable log message headers. */
3093:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
3094:../uvc.c      **** }
3095:../uvc.c      **** 
3096:../uvc.c      **** /* I2C initialization. */
3097:../uvc.c      **** static void
3098:../uvc.c      **** CyFxUVCApplnI2CInit (void)
3099:../uvc.c      **** {
3100:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
3101:../uvc.c      ****     CyU3PReturnStatus_t status;
3102:../uvc.c      **** 
3103:../uvc.c      ****     status = CyU3PI2cInit ();
3104:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
3105:../uvc.c      ****     {
3106:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
3107:../uvc.c      ****         CyFxAppErrorHandler (status);
3108:../uvc.c      ****     }
3109:../uvc.c      **** 
3110:../uvc.c      ****     /*  Set I2C Configuration */
3111:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
3112:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
3113:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
3114:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
3115:../uvc.c      **** 
3116:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
3117:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
3118:../uvc.c      ****     {
3119:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
3120:../uvc.c      ****         CyFxAppErrorHandler (status);
3121:../uvc.c      ****     }
3122:../uvc.c      **** }
3123:../uvc.c      **** 
3124:../uvc.c      **** #ifdef BACKFLOW_DETECT
3125:../uvc.c      **** static void CyFxUvcAppPibCallback (
3126:../uvc.c      ****         CyU3PPibIntrType cbType,
3127:../uvc.c      ****         uint16_t cbArg)
3128:../uvc.c      **** {
3129:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
3130:../uvc.c      ****     {
3131:../uvc.c      ****         if (!back_flow_detected)
3132:../uvc.c      ****         {
3133:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
3134:../uvc.c      ****             back_flow_detected = 1;
3135:../uvc.c      ****         }
3136:../uvc.c      ****     }
3137:../uvc.c      **** }
3138:../uvc.c      **** #endif
3139:../uvc.c      **** 
3140:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3141:../uvc.c      **** static void
3142:../uvc.c      **** CyFxUvcAppDebugCallback (
3143:../uvc.c      ****         CyU3PDmaChannel   *handle,
3144:../uvc.c      ****         CyU3PDmaCbType_t   type,
3145:../uvc.c      ****         CyU3PDmaCBInput_t *input)
3146:../uvc.c      **** {
3147:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
3148:../uvc.c      ****     {
3149:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
3150:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
3151:../uvc.c      ****     }
3152:../uvc.c      **** }
3153:../uvc.c      **** #endif
3154:../uvc.c      **** 
3155:../uvc.c      **** #if 0
3156:../uvc.c      **** static void CyFxAppIntEpCb(
3157:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
3158:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
3159:../uvc.c      **** 		uint8_t  ebNum)
3160:../uvc.c      **** 		{
3161:../uvc.c      **** 			//CyBool_t value;
3162:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
3163:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
3164:../uvc.c      **** 
3165:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
3166:../uvc.c      **** 		}
3167:../uvc.c      **** #endif
3168:../uvc.c      **** 
3169:../uvc.c      **** /* This function initializes the USB Module, creates event group,
3170:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
3171:../uvc.c      ****    configures the DMA module for the UVC Application */
3172:../uvc.c      **** static void
3173:../uvc.c      **** CyFxUVCApplnInit (void)
3174:../uvc.c      **** {
3175:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
3176:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
3177:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
3178:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
3179:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
3180:../uvc.c      ****     CyU3PPibClock_t              pibclock;
3181:../uvc.c      **** 
3182:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
3183:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
3184:../uvc.c      **** 
3185:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3186:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
3187:../uvc.c      **** #endif
3188:../uvc.c      **** 
3189:../uvc.c      ****     /* Create UVC event group */
3190:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
3191:../uvc.c      ****     if (apiRetStatus != 0)
3192:../uvc.c      ****     {
3193:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
3194:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3195:../uvc.c      ****     }
3196:../uvc.c      **** 
3197:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3198:../uvc.c      ****     CyFxUvcAppPTZInit ();
3199:../uvc.c      **** #endif
3200:../uvc.c      **** 
3201:../uvc.c      ****     isUsbConnected = CyFalse;
3202:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
3203:../uvc.c      **** 
3204:../uvc.c      ****     /* Init the GPIO module */
3205:../uvc.c      ****     gpioClock.fastClkDiv = 2;
3206:../uvc.c      ****     gpioClock.slowClkDiv = 2;
3207:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
3208:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
3209:../uvc.c      ****     gpioClock.halfDiv    = 0;
3210:../uvc.c      **** 
3211:../uvc.c      ****     /* Initialize Gpio interface */
3212:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
3213:../uvc.c      ****     if (apiRetStatus != 0)
3214:../uvc.c      ****     {
3215:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
3216:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3217:../uvc.c      ****     }
3218:../uvc.c      **** 
3219:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
3220:../uvc.c      ****      * must use GpioOverride to configure it */
3221:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
3222:../uvc.c      ****     if (apiRetStatus != 0)
3223:../uvc.c      ****     {
3224:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
3225:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3226:../uvc.c      ****     }
3227:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
3228:../uvc.c      ****     if (apiRetStatus != 0)
3229:../uvc.c      ****     {
3230:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
3231:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3232:../uvc.c      ****     }
3233:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
3234:../uvc.c      ****     if (apiRetStatus != 0)
3235:../uvc.c      ****     {
3236:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
3237:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3238:../uvc.c      ****     }
3239:../uvc.c      **** 
3240:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
3241:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
3242:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
3243:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
3244:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
3245:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3246:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
3247:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3248:../uvc.c      ****     {
3249:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
3250:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3251:../uvc.c      ****     }
3252:../uvc.c      **** 
3253:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
3254:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
3255:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
3256:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
3257:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
3258:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
3259:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3260:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
3261:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3262:../uvc.c      ****     {
3263:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
3264:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3265:../uvc.c      ****     }
3266:../uvc.c      **** 
3267:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
3268:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
3269:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
3270:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
3271:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
3272:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
3273:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3274:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
3275:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3276:../uvc.c      ****     {
3277:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
3278:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3279:../uvc.c      ****     }
3280:../uvc.c      **** 
3281:../uvc.c      ****     /* Initialize the P-port. */
3282:../uvc.c      ****     pibclock.clkDiv      = 2;
3283:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
3284:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
3285:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
3286:../uvc.c      **** 
3287:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
3288:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3289:../uvc.c      ****     {
3290:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
3291:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3292:../uvc.c      ****     }
3293:../uvc.c      **** 
3294:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
3295:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
3296:../uvc.c      **** 
3297:../uvc.c      **** #ifdef BACKFLOW_DETECT
3298:../uvc.c      ****     back_flow_detected = 0;
3299:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
3300:../uvc.c      **** #endif
3301:../uvc.c      **** 
3302:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
3303:../uvc.c      ****     SensorReset ();
3304:../uvc.c      ****     CyU3PThreadSleep(5000);
3305:../uvc.c      ****     //SensorInit ();
3306:../uvc.c      **** 
3307:../uvc.c      ****     /* USB initialization. */
3308:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
3309:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3310:../uvc.c      ****     {
3311:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
3312:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3313:../uvc.c      ****     }
3314:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
3315:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
3316:../uvc.c      **** 
3317:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
3318:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
3319:../uvc.c      **** 
3320:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
3321:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
3322:../uvc.c      **** 
3323:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
3324:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
3325:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
3326:../uvc.c      **** 
3327:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
3328:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
3329:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
3330:../uvc.c      **** 
3331:../uvc.c      ****     /* Configuration descriptors. */
3332:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
3333:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
3334:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
3335:../uvc.c      **** 
3336:../uvc.c      ****     /* String Descriptors */
3337:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
3338:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
3339:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
3340:../uvc.c      **** 
3341:../uvc.c      ****     /* Configure the status interrupt endpoint.
3342:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
3343:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
3344:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
3345:../uvc.c      ****      */
3346:../uvc.c      ****     endPointConfig.enable   = 1;
3347:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
3348:../uvc.c      ****     endPointConfig.pcktSize = 64;
3349:../uvc.c      ****     endPointConfig.isoPkts  = 0;
3350:../uvc.c      ****     endPointConfig.streams  = 0;
3351:../uvc.c      ****     endPointConfig.burstLen = 1;
3352:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
3353:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3354:../uvc.c      ****     {
3355:../uvc.c      ****         /* Error Handling */
3356:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
3357:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3358:../uvc.c      ****     }
3359:../uvc.c      **** 
3360:../uvc.c      ****     /* create a DMA for interrupt endpoint */
3361:../uvc.c      ****     dmaInterConfig.size           = 1024;
3362:../uvc.c      ****     dmaInterConfig.count          = 1;
3363:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
3364:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
3365:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
3366:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
3367:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
3368:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
3369:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3370:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
3371:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
3372:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
3373:../uvc.c      ****             &dmaInterConfig);
3374:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3375:../uvc.c      ****     {
3376:../uvc.c      ****         /* Error handling */
3377:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
3378:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3379:../uvc.c      ****     }
3380:../uvc.c      **** 
3381:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
3382:../uvc.c      ****     if (glInterStaBuffer == 0)
3383:../uvc.c      ****     {
3384:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
3385:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
3386:../uvc.c      ****     }
3387:../uvc.c      **** 
3388:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
3389:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
3390:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
3391:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
3392:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
3393:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
3394:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
3395:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
3396:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
3397:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
3398:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
3399:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
3400:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3401:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
3402:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
3403:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
3404:../uvc.c      ****             &dmaMultiConfig);
3405:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3406:../uvc.c      ****     {
3407:../uvc.c      ****         /* Error handling */
3408:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
3409:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3410:../uvc.c      ****     }
3411:../uvc.c      **** 
3412:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3413:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
3414:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
3415:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
3416:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
3417:../uvc.c      ****      */
3418:../uvc.c      **** 
3419:../uvc.c      ****     endPointConfig.enable   = 1;
3420:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
3421:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
3422:../uvc.c      ****     endPointConfig.isoPkts  = 0;
3423:../uvc.c      ****     endPointConfig.streams  = 0;
3424:../uvc.c      ****     endPointConfig.burstLen = 1;
3425:../uvc.c      **** 
3426:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
3427:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3428:../uvc.c      ****     {
3429:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
3430:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3431:../uvc.c      ****     }
3432:../uvc.c      **** 
3433:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
3434:../uvc.c      **** 
3435:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
3436:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3437:../uvc.c      ****     {
3438:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
3439:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3440:../uvc.c      ****     }
3441:../uvc.c      **** 
3442:../uvc.c      ****     channelConfig.size           = 1024;
3443:../uvc.c      ****     channelConfig.count          = 1;
3444:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
3445:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
3446:../uvc.c      ****     channelConfig.prodAvailCount = 0;
3447:../uvc.c      ****     channelConfig.prodHeader     = 0;
3448:../uvc.c      ****     channelConfig.prodFooter     = 0;
3449:../uvc.c      ****     channelConfig.consHeader     = 0;
3450:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3451:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
3452:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
3453:../uvc.c      **** 
3454:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
3455:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3456:../uvc.c      ****     {
3457:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
3458:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3459:../uvc.c      ****     }
3460:../uvc.c      **** 
3461:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
3462:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3463:../uvc.c      ****     {
3464:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
3465:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3466:../uvc.c      ****     }
3467:../uvc.c      **** 
3468:../uvc.c      ****     channelConfig.size           = 1024;
3469:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
3470:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
3471:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
3472:../uvc.c      ****     channelConfig.prodAvailCount = 0;
3473:../uvc.c      ****     channelConfig.prodHeader     = 0;
3474:../uvc.c      ****     channelConfig.prodFooter     = 0;
3475:../uvc.c      ****     channelConfig.consHeader     = 0;
3476:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3477:../uvc.c      ****     channelConfig.notification   = 0;
3478:../uvc.c      ****     channelConfig.cb             = 0;
3479:../uvc.c      **** 
3480:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
3481:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3482:../uvc.c      ****     {
3483:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
3484:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3485:../uvc.c      ****     }
3486:../uvc.c      **** 
3487:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
3488:../uvc.c      ****     if (glDebugRspBuffer == 0)
3489:../uvc.c      ****     {
3490:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
3491:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
3492:../uvc.c      ****     }
3493:../uvc.c      **** #endif
3494:../uvc.c      **** 
3495:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
3496:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
3497:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3498:../uvc.c      ****     {
3499:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
3500:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3501:../uvc.c      ****     }
3502:../uvc.c      **** 
3503:../uvc.c      ****     CyU3PBusyWait(100);
3504:../uvc.c      **** 
3505:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
3506:../uvc.c      **** 
3507:../uvc.c      ****     endPointConfig.enable   = 1;
3508:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
3509:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
3510:../uvc.c      ****     {
3511:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
3512:../uvc.c      ****     	endPointConfig.burstLen = 16;
3513:../uvc.c      ****     }
3514:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
3515:../uvc.c      ****     {
3516:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
3517:../uvc.c      ****     	endPointConfig.burstLen = 1;
3518:../uvc.c      ****     }
3519:../uvc.c      ****     endPointConfig.streams  = 0;
3520:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
3521:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3522:../uvc.c      ****     {
3523:../uvc.c      ****         /* Error Handling */
3524:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
3525:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3526:../uvc.c      ****     }
3527:../uvc.c      **** #if 0    //for still image method 3 using
3528:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
3529:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3530:../uvc.c      ****     {
3531:../uvc.c      ****         /* Error Handling */
3532:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
3533:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3534:../uvc.c      ****     }
3535:../uvc.c      **** #endif
3536:../uvc.c      **** 
3537:../uvc.c      **** }
3538:../uvc.c      **** 
3539:../uvc.c      **** /*
3540:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
3541:../uvc.c      ****  * streaming session is started.
3542:../uvc.c      ****  */
3543:../uvc.c      **** static void
3544:../uvc.c      **** CyFxUvcAppGpifInit (
3545:../uvc.c      ****         void)
3546:../uvc.c      **** {
3547:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
3548:../uvc.c      **** 
3549:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3550:../uvc.c      ****     {
3551:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
3552:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
3553:../uvc.c      ****     }
3554:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
3555:../uvc.c      ****     {
3556:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
3557:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
3558:../uvc.c      ****     }
3559:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3560:../uvc.c      ****     {
3561:../uvc.c      ****         /* Error Handling */
3562:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
3563:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3564:../uvc.c      ****     }
3565:../uvc.c      **** 
3566:../uvc.c      ****     /* Start the state machine from the designated start state. */
3567:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3568:../uvc.c      ****     {
3569:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
3570:../uvc.c      ****     }
3571:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
3572:../uvc.c      ****     {
3573:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
3574:../uvc.c      ****     }
3575:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3576:../uvc.c      ****     {
3577:../uvc.c      ****         /* Error Handling */
3578:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
3579:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3580:../uvc.c      ****     }
3581:../uvc.c      **** }
3582:../uvc.c      **** 
3583:../uvc.c      **** /*
3584:../uvc.c      ****  * Entry function for the UVC Application Thread
3585:../uvc.c      ****  */
3586:../uvc.c      **** 
3587:../uvc.c      **** uint32_t posTick;
3588:../uvc.c      **** CyU3PTimer I2CCmdTimer;
3589:../uvc.c      **** 
3590:../uvc.c      **** void  I2CCmdCb(uint32_t input){
  22              		.loc 1 3590 0
  23              		.cfi_startproc
  24              		@ args = 0, pretend = 0, frame = 0
  25              		@ frame_needed = 0, uses_anonymous_args = 0
  26              	.LVL0:
3591:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  27              		.loc 1 3591 0
  28 0000 28209FE5 		ldr	r2, .L2
3590:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  29              		.loc 1 3590 0
  30 0004 08402DE9 		stmfd	sp!, {r3, lr}
  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 3, -8
  34              		.cfi_offset 14, -4
  35              		.loc 1 3591 0
  36 0008 002092E5 		ldr	r2, [r2]
3590:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  37              		.loc 1 3590 0
  38 000c 0030A0E1 		mov	r3, r0
  39              		.loc 1 3591 0
  40 0010 1C109FE5 		ldr	r1, .L2+4
  41 0014 0400A0E3 		mov	r0, #4
  42              	.LVL1:
  43 0018 FEFFFFEB 		bl	CyU3PDebugPrint
  44              	.LVL2:
3592:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  45              		.loc 1 3592 0
  46 001c 14009FE5 		ldr	r0, .L2+8
  47 0020 2010A0E3 		mov	r1, #32
  48 0024 0020A0E3 		mov	r2, #0
3593:../uvc.c      **** }
  49              		.loc 1 3593 0
  50 0028 0840BDE8 		ldmfd	sp!, {r3, lr}
3592:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  51              		.loc 1 3592 0
  52 002c FEFFFFEA 		b	_txe_event_flags_set
  53              	.LVL3:
  54              	.L3:
  55              		.align	2
  56              	.L2:
  57 0030 00000000 		.word	posTick
  58 0034 00000000 		.word	.LC0
  59 0038 00000000 		.word	.LANCHOR0
  60              		.cfi_endproc
  61              	.LFE18:
  63              		.align	2
  65              	UVCHandleVideoStreamingRqts:
  66              	.LFB24:
3594:../uvc.c      **** 
3595:../uvc.c      **** 
3596:../uvc.c      **** void
3597:../uvc.c      **** UVCAppThread_Entry (
3598:../uvc.c      ****         uint32_t input)
3599:../uvc.c      **** {
3600:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
3601:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
3602:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
3603:../uvc.c      ****     uint8_t i = 0;
3604:../uvc.c      ****     uint32_t flag;
3605:../uvc.c      ****     uint32_t prinflag = 0;
3606:../uvc.c      **** static uint8_t IMcount = 0;
3607:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
3608:../uvc.c      ****     uint32_t frameCnt = 0;
3609:../uvc.c      **** #endif
3610:../uvc.c      ****     /* Initialize the Uart Debug Module */
3611:../uvc.c      ****     CyFxUVCApplnDebugInit ();
3612:../uvc.c      **** 
3613:../uvc.c      ****     /* Initialize the I2C interface */
3614:../uvc.c      **** 	while (i++ < 6){
3615:../uvc.c      **** 		CyU3PThreadSleep(500);
3616:../uvc.c      **** 	}
3617:../uvc.c      **** 
3618:../uvc.c      ****     CyFxUVCApplnI2CInit ();
3619:../uvc.c      **** 
3620:../uvc.c      ****     /* Initialize the UVC Application */
3621:../uvc.c      ****     CyFxUVCApplnInit ();
3622:../uvc.c      ****     /*
3623:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
3624:../uvc.c      **** 
3625:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
3626:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
3627:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
3628:../uvc.c      **** 
3629:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
3630:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
3631:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
3632:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
3633:../uvc.c      **** 
3634:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
3635:../uvc.c      ****        of handling the abort request.
3636:../uvc.c      ****      */
3637:../uvc.c      **** 
3638:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
3639:../uvc.c      ****     //CyU3PThreadSleep(1000);
3640:../uvc.c      **** 
3641:../uvc.c      ****     for (;;)
3642:../uvc.c      ****     {
3643:../uvc.c      ****         /* Waiting for the Video Stream Event */
3644:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
3645:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3646:../uvc.c      ****         {
3647:../uvc.c      **** #if 0 //test for new firmware no video bring up
3648:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
3649:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
3650:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
3651:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
3652:../uvc.c      ****             {
3653:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
3654:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
3655:../uvc.c      ****                 {
3656:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3657:../uvc.c      **** #ifdef  USB_LOWRES_IMG
3658:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
3659:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
3660:../uvc.c      **** #endif
3661:../uvc.c      **** #endif
3662:../uvc.c      ****                     }
3663:../uvc.c      ****                 else
3664:../uvc.c      ****                 {
3665:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
3666:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3667:../uvc.c      **** #ifdef USB_LOWRES_IMG
3668:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
3669:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3670:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
3671:../uvc.c      **** #endif
3672:../uvc.c      **** #endif
3673:../uvc.c      ****                 }
3674:../uvc.c      **** 
3675:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
3676:../uvc.c      ****                 prodCount++;
3677:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
3678:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
3679:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
3680:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3681:../uvc.c      ****                 {
3682:../uvc.c      ****                     prodCount--;
3683:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
3684:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
3685:../uvc.c      ****                 }
3686:../uvc.c      ****             }
3687:../uvc.c      **** #endif
3688:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
3689:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
3690:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
3691:../uvc.c      ****             {
3692:../uvc.c      ****             	if(0&&(prinflag == 0)){
3693:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
3694:../uvc.c      ****             		prinflag = 1;
3695:../uvc.c      ****             	}
3696:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
3697:../uvc.c      ****             	fb=0;
3698:../uvc.c      ****             	pb=0;
3699:../uvc.c      ****             	pbc=0;
3700:../uvc.c      ****                 prodCount = 0;
3701:../uvc.c      ****                 consCount = 0;
3702:../uvc.c      ****                 hitFV     = CyFalse;
3703:../uvc.c      **** 
3704:../uvc.c      **** #ifdef BACKFLOW_DETECT
3705:../uvc.c      ****                 back_flow_detected = 0;
3706:../uvc.c      **** #endif
3707:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
3708:../uvc.c      ****                 frameCnt++;
3709:../uvc.c      **** #endif
3710:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
3711:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
3712:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
3713:../uvc.c      ****                 //}
3714:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
3715:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3716:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
3717:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
3718:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3719:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
3720:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
3721:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
3722:../uvc.c      ****                      	//CyU3PThreadSleep(100);
3723:../uvc.c      ****                 		stiflag = 0xFF;
3724:../uvc.c      ****                 		IMcount = 0;
3725:../uvc.c      ****                 	}
3726:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
3727:../uvc.c      **** 
3728:../uvc.c      ****                  		if(IMcount++ >= 0x3){
3729:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
3730:../uvc.c      ****                 		stiflag = 0x0F;
3731:../uvc.c      ****                 		IMcount = 0;
3732:../uvc.c      ****                 		}
3733:../uvc.c      ****                  		/*if(IMcount > 0x4){
3734:../uvc.c      ****                 			stiflag = 0x0F;
3735:../uvc.c      ****                 			IMcount = 0;
3736:../uvc.c      ****                 		}*/
3737:../uvc.c      **** 
3738:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
3739:../uvc.c      ****                     //CyU3PThreadSleep(400);
3740:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3741:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3742:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
3743:../uvc.c      **** 
3744:../uvc.c      ****                 	if(IMcount++ >= 0x3)
3745:../uvc.c      ****                 	{
3746:../uvc.c      ****                     switch (setRes)
3747:../uvc.c      ****                      {
3748:../uvc.c      ****                  	case 1: //1944
3749:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR_WR/*boardID
3750:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3751:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x22:0xA2
3752:../uvc.c      ****                  		break;
3753:../uvc.c      ****                  	case 2: //1080
3754:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR_WR/*boardID
3755:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3756:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x12:0x92
3757:../uvc.c      ****                  		break;
3758:../uvc.c      ****                  	case 3: //720
3759:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, I2C_DSPBOARD
3760:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3761:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x02:0x
3762:../uvc.c      ****                  		break;
3763:../uvc.c      ****                  	case 4: //VGA
3764:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x32:0xB2)&0xFC)|ROIMode, I2C_DSPBOARD
3765:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3766:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x32:0x
3767:../uvc.c      ****                  		break;
3768:../uvc.c      ****                  	default:
3769:../uvc.c      ****                  		break;
3770:../uvc.c      ****                      }
3771:../uvc.c      ****                     IMcount = 0;
3772:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3773:../uvc.c      ****                 	stiflag = 0x0;
3774:../uvc.c      ****                 	}
3775:../uvc.c      ****                 }
3776:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
3777:../uvc.c      ****                 /* Reset the DMA channel. */
3778:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3779:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3780:../uvc.c      ****                 {
3781:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
3782:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3783:../uvc.c      ****                 }
3784:../uvc.c      **** 
3785:../uvc.c      ****                 /* Start Channel Immediately */
3786:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3787:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3788:../uvc.c      ****                 {
3789:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
3790:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3791:../uvc.c      ****                 }
3792:../uvc.c      **** 
3793:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
3794:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
3795:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3796:../uvc.c      ****                 }
3797:../uvc.c      ****         }
3798:../uvc.c      ****         else
3799:../uvc.c      ****         {
3800:../uvc.c      ****             /* If we have a stream abort request pending. */
3801:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
3802:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3803:../uvc.c      ****             {
3804:../uvc.c      ****                 hitFV     = CyFalse;
3805:../uvc.c      ****                 prodCount = 0;
3806:../uvc.c      ****                 consCount = 0;
3807:../uvc.c      ****                 if(0&&(prinflag == 0)){
3808:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
3809:../uvc.c      ****                 	prinflag = 1;
3810:../uvc.c      ****                 }
3811:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
3812:../uvc.c      ****                 fb=0;
3813:../uvc.c      ****                 pb=0;
3814:../uvc.c      ****                 pbc=0;
3815:../uvc.c      **** 
3816:../uvc.c      ****                 if (!clearFeatureRqtReceived)
3817:../uvc.c      ****                 {
3818:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3819:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
3820:../uvc.c      ****                     {
3821:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
3822:../uvc.c      ****                     }
3823:../uvc.c      **** 
3824:../uvc.c      ****                     /* Flush the Endpoint memory */
3825:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
3826:../uvc.c      ****                 }
3827:../uvc.c      **** 
3828:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
3829:../uvc.c      ****             }
3830:../uvc.c      ****             else
3831:../uvc.c      ****             {
3832:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
3833:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
3834:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
3835:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
3836:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
3837:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3838:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3839:../uvc.c      ****                 {
3840:../uvc.c      ****                     /* Error handling */
3841:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
3842:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3843:../uvc.c      ****                 }
3844:../uvc.c      **** 
3845:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
3846:../uvc.c      ****                 if (gpif_initialized == CyFalse)
3847:../uvc.c      ****                 {
3848:../uvc.c      **** #if 0
3849:../uvc.c      ****                 	//for start up of the AF Lens
3850:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3851:../uvc.c      ****                     CyU3PThreadSleep(500);
3852:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3853:../uvc.c      ****                     CyU3PThreadSleep(500);
3854:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
3855:../uvc.c      ****                    	CyU3PThreadSleep(300);
3856:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3857:../uvc.c      ****                     CyU3PThreadSleep(500);
3858:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3859:../uvc.c      ****                     CyU3PThreadSleep(500);
3860:../uvc.c      **** #endif
3861:../uvc.c      **** #if 0
3862:../uvc.c      ****                     switch (setRes)
3863:../uvc.c      ****                     {
3864:../uvc.c      ****                     	case 1: //1944
3865:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x64, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3866:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3867:../uvc.c      ****                     		break;
3868:../uvc.c      ****                     	case 2: //1080
3869:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x54, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3870:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3871:../uvc.c      ****                     		break;
3872:../uvc.c      ****                     	case 3: //720
3873:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x45, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3874:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3875:../uvc.c      ****                     		break;
3876:../uvc.c      ****                     	default:
3877:../uvc.c      ****                     		break;
3878:../uvc.c      ****                     }
3879:../uvc.c      **** #endif
3880:../uvc.c      ****                     CyFxUvcAppGpifInit ();
3881:../uvc.c      **** 
3882:../uvc.c      ****                     gpif_initialized = CyTrue;
3883:../uvc.c      ****                     CyU3PThreadSleep(200);
3884:../uvc.c      ****                     
3885:../uvc.c      ****                 }
3886:../uvc.c      ****                 else
3887:../uvc.c      ****                 {
3888:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
3889:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
3890:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3891:../uvc.c      ****                 }
3892:../uvc.c      ****             }
3893:../uvc.c      ****         }
3894:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
3895:../uvc.c      **** 
3896:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
3897:../uvc.c      ****         CyU3PThreadRelinquish ();
3898:../uvc.c      ****     }
3899:../uvc.c      **** }
3900:../uvc.c      **** 
3901:../uvc.c      **** /*
3902:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
3903:../uvc.c      ****  */
3904:../uvc.c      **** 
3905:../uvc.c      **** static void
3906:../uvc.c      **** UVCHandleProcessingUnitRqts (
3907:../uvc.c      ****         void)
3908:../uvc.c      **** {
3909:../uvc.c      ****     uint8_t CtrlAdd;
3910:../uvc.c      **** #ifdef DbgInfo
3911:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3912:../uvc.c      **** #endif
3913:../uvc.c      ****     switch (wValue)
3914:../uvc.c      ****     {
3915:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
3916:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
3917:../uvc.c      ****     		ControlHandle(BLCCtlID0);
3918:../uvc.c      ****     		break;
3919:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
3920:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
3921:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
3922:../uvc.c      ****     		break;
3923:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
3924:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
3925:../uvc.c      **** 			ControlHandle(ConsCtlID2);
3926:../uvc.c      **** 			break;
3927:../uvc.c      **** 
3928:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
3929:../uvc.c      **** 
3930:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
3931:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
3932:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
3933:../uvc.c      ****       		break;
3934:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
3935:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
3936:../uvc.c      ****      		ControlHandle(HueCtlID5);
3937:../uvc.c      ****      		break;
3938:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
3939:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
3940:../uvc.c      ****           		ControlHandle(SaturCtlID6);
3941:../uvc.c      ****           		break;
3942:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
3943:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
3944:../uvc.c      ****           		ControlHandle(ShapCtlID7);
3945:../uvc.c      ****           		break;
3946:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
3947:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
3948:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
3949:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
3950:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
3951:../uvc.c      ****     		break;
3952:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
3953:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
3954:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
3955:../uvc.c      ****     		break;
3956:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
3957:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
3958:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
3959:../uvc.c      ****     		break;
3960:../uvc.c      **** 
3961:../uvc.c      ****         default:
3962:../uvc.c      ****             /*
3963:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3964:../uvc.c      ****              * other controls.
3965:../uvc.c      ****              */
3966:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3967:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3968:../uvc.c      ****             break;
3969:../uvc.c      ****     }
3970:../uvc.c      **** }
3971:../uvc.c      **** 
3972:../uvc.c      **** /*
3973:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
3974:../uvc.c      ****  */
3975:../uvc.c      **** static void
3976:../uvc.c      **** UVCHandleCameraTerminalRqts (
3977:../uvc.c      ****         void)
3978:../uvc.c      **** {
3979:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3980:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3981:../uvc.c      ****     uint16_t readCount;
3982:../uvc.c      ****     uint16_t zoomVal;
3983:../uvc.c      ****     int32_t  panVal, tiltVal;
3984:../uvc.c      ****     CyBool_t sendData = CyFalse;
3985:../uvc.c      **** #endif
3986:../uvc.c      ****     uint8_t CtrlAdd;
3987:../uvc.c      **** 
3988:../uvc.c      ****     switch (wValue)
3989:../uvc.c      ****     {
3990:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
3991:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
3992:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
3993:../uvc.c      ****     		break;
3994:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
3995:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
3996:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
3997:../uvc.c      ****     		break;
3998:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
3999:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
4000:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
4001:../uvc.c      **** 			break;
4002:../uvc.c      **** 
4003:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
4004:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
4005:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
4006:../uvc.c      **** 			break;
4007:../uvc.c      **** 
4008:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
4009:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
4010:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
4011:../uvc.c      ****       		break;
4012:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
4013:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
4014:../uvc.c      ****      		CTControlHandle(FocACtlID5);
4015:../uvc.c      ****      		break;
4016:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
4017:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
4018:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
4019:../uvc.c      ****           		break;
4020:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
4021:../uvc.c      ****           		break;
4022:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
4023:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
4024:../uvc.c      ****      		CTControlHandle(IriACtlID7);
4025:../uvc.c      ****      		break;
4026:../uvc.c      **** 
4027:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
4028:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
4029:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
4030:../uvc.c      ****     		break;
4031:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
4032:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
4033:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
4034:../uvc.c      ****     		break;
4035:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
4036:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
4037:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
4038:../uvc.c      ****     		break;
4039:../uvc.c      **** 
4040:../uvc.c      ****         default:
4041:../uvc.c      ****             /*
4042:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
4043:../uvc.c      ****              * other controls.
4044:../uvc.c      ****              */
4045:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
4046:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4047:../uvc.c      ****             break;
4048:../uvc.c      ****     }
4049:../uvc.c      **** 
4050:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
4051:../uvc.c      ****     switch (wValue)
4052:../uvc.c      ****     {
4053:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
4054:../uvc.c      ****             switch (bRequest)
4055:../uvc.c      ****             {
4056:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4057:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
4058:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4059:../uvc.c      ****                     break;
4060:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
4061:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
4062:../uvc.c      ****                     sendData = CyTrue;
4063:../uvc.c      ****                     break;
4064:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
4065:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
4066:../uvc.c      ****                     sendData = CyTrue;
4067:../uvc.c      ****                     break;
4068:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
4069:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
4070:../uvc.c      ****                     sendData = CyTrue;
4071:../uvc.c      ****                     break;
4072:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
4073:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
4074:../uvc.c      ****                     sendData = CyTrue;
4075:../uvc.c      ****                     break;
4076:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
4077:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
4078:../uvc.c      ****                     sendData = CyTrue;
4079:../uvc.c      ****                     break;
4080:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4081:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4082:../uvc.c      ****                             glEp0Buffer, &readCount);
4083:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4084:../uvc.c      ****                     {
4085:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
4086:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
4087:../uvc.c      ****                     }
4088:../uvc.c      ****                     break;
4089:../uvc.c      ****                 default:
4090:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4091:../uvc.c      ****                     break;
4092:../uvc.c      ****             }
4093:../uvc.c      **** 
4094:../uvc.c      ****             if (sendData)
4095:../uvc.c      ****             {
4096:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
4097:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
4098:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
4099:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
4100:../uvc.c      ****             }
4101:../uvc.c      ****             break;
4102:../uvc.c      **** 
4103:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
4104:../uvc.c      ****             switch (bRequest)
4105:../uvc.c      ****             {
4106:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4107:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
4108:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4109:../uvc.c      ****                     break;
4110:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
4111:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
4112:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
4113:../uvc.c      ****                     sendData = CyTrue;
4114:../uvc.c      ****                     break;
4115:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
4116:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
4117:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
4118:../uvc.c      ****                     sendData = CyTrue;
4119:../uvc.c      ****                     break;
4120:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
4121:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
4122:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
4123:../uvc.c      ****                     sendData = CyTrue;
4124:../uvc.c      ****                     break;
4125:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
4126:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
4127:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
4128:../uvc.c      ****                     sendData = CyTrue;
4129:../uvc.c      ****                     break;
4130:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
4131:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
4132:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
4133:../uvc.c      ****                     sendData = CyTrue;
4134:../uvc.c      ****                     break;
4135:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4136:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4137:../uvc.c      ****                             glEp0Buffer, &readCount);
4138:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4139:../uvc.c      ****                     {
4140:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
4141:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
4142:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
4143:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
4144:../uvc.c      **** 
4145:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
4146:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
4147:../uvc.c      ****                     }
4148:../uvc.c      ****                     break;
4149:../uvc.c      ****                 default:
4150:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4151:../uvc.c      ****                     break;
4152:../uvc.c      ****             }
4153:../uvc.c      **** 
4154:../uvc.c      ****             if (sendData)
4155:../uvc.c      ****             {
4156:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
4157:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
4158:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
4159:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
4160:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
4161:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
4162:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
4163:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
4164:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
4165:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
4166:../uvc.c      ****             }
4167:../uvc.c      ****             break;
4168:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
4169:../uvc.c      ****         default:
4170:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
4171:../uvc.c      ****             break;
4172:../uvc.c      ****     }
4173:../uvc.c      **** #endif
4174:../uvc.c      **** }
4175:../uvc.c      **** 
4176:../uvc.c      **** /*
4177:../uvc.c      ****  * Handler for UVC Interface control requests.
4178:../uvc.c      ****  */
4179:../uvc.c      **** static void
4180:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
4181:../uvc.c      ****         void)
4182:../uvc.c      **** {
4183:../uvc.c      **** 
4184:../uvc.c      ****     switch (wValue)
4185:../uvc.c      ****     {
4186:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
4187:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
4188:../uvc.c      ****     		break;
4189:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
4190:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
4191:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
4192:../uvc.c      ****     		break;
4193:../uvc.c      ****     	default:
4194:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
4195:../uvc.c      ****      		break;
4196:../uvc.c      ****     }
4197:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
4198:../uvc.c      **** 
4199:../uvc.c      **** }
4200:../uvc.c      **** 
4201:../uvc.c      **** /*
4202:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
4203:../uvc.c      ****  */
4204:../uvc.c      **** static void
4205:../uvc.c      **** UVCHandleExtensionUnitRqts (
4206:../uvc.c      ****         void)
4207:../uvc.c      **** {
4208:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
4209:../uvc.c      **** 
4210:../uvc.c      **** #ifdef DbgInfo
4211:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
4212:../uvc.c      **** #endif
4213:../uvc.c      ****     switch (wValue)
4214:../uvc.c      ****     {
4215:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
4216:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
4217:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
4218:../uvc.c      ****     		break;
4219:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
4220:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
4221:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
4222:../uvc.c      ****     		break;
4223:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
4224:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
4225:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
4226:../uvc.c      ****      		break;
4227:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
4228:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
4229:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
4230:../uvc.c      ****     		break;
4231:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
4232:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
4233:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
4234:../uvc.c      ****     		break;
4235:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
4236:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
4237:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
4238:../uvc.c      ****      		break;
4239:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
4240:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
4241:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
4242:../uvc.c      ****     		break;
4243:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
4244:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
4245:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
4246:../uvc.c      ****     		break;
4247:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
4248:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
4249:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
4250:../uvc.c      ****      		break;
4251:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
4252:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
4253:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
4254:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
4255:../uvc.c      ****     		}else/* no support for 1080p camera */
4256:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
4257:../uvc.c      ****     		break;
4258:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
4259:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
4260:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
4261:../uvc.c      ****     		break;
4262:../uvc.c      **** 		case CY_FX_EXT_CONTROL_12: //AEx shutter level CONTROL12
4263:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCtlShutlevCtlID11][0];
4264:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
4265:../uvc.c      ****     		break;
4266:../uvc.c      **** 
4267:../uvc.c      ****     		//ExtCtlShutlevCtlID11
4268:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
4269:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
4270:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
4271:../uvc.c      ****     		break;
4272:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
4273:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
4274:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
4275:../uvc.c      ****     		//break;
4276:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
4277:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
4278:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
4279:../uvc.c      ****     		break;
4280:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
4281:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
4282:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
4283:../uvc.c      ****     		break;
4284:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
4285:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET][0];
4286:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
4287:../uvc.c      ****     		break;
4288:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
4289:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET][0];
4290:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
4291:../uvc.c      ****     		break;
4292:../uvc.c      **** 		case CY_FX_EXT_CONTROL_19BLC_GRID:   //BLD gain CONTROL19
4293:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET][0];
4294:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
4295:../uvc.c      ****     		break;
4296:../uvc.c      **** 		case CY_FX_EXT_CONTROL_20EXP_HYSTER: //exposure hysteresis CONTROL20
4297:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1ExHysterCtlID7-EXUAOFFSET][0];
4298:../uvc.c      ****       		ControlHandle(Ext1ExHysterCtlID7);
4299:../uvc.c      **** 			CyU3PDebugPrint (4, "The hyster command 0x%x 0x%x\r\n", wValue, bRequest);
4300:../uvc.c      ****     		break;
4301:../uvc.c      **** 		case CY_FX_EXT_CONTROL_21EXP_CTRLSPD: //exposure control speed CONTROL21
4302:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1ExCtrlSpeedCtlID8-EXUAOFFSET][0];
4303:../uvc.c      ****       		ControlHandle(Ext1ExCtrlSpeedCtlID8);
4304:../uvc.c      **** 			CyU3PDebugPrint (4, "The ctrlspd command 0x%x 0x%x\r\n", wValue, bRequest);
4305:../uvc.c      ****     		break;
4306:../uvc.c      **** 		case CY_FX_EXT_CONTROL_22ENHANCE_MODE: //edge enhancement mode CONTROL22
4307:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceModeCtlID9-EXUAOFFSET][0];
4308:../uvc.c      ****       		ControlHandle(Ext1EnhanceModeCtlID9);
4309:../uvc.c      **** 			CyU3PDebugPrint (4, "The edgeMode command 0x%x 0x%x\r\n", wValue, bRequest);
4310:../uvc.c      ****     		break;
4311:../uvc.c      **** 		case CY_FX_EXT_CONTROL_23ENHANCE_GAIN: //edge enhancement gain CONTROL23
4312:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceGainCtlID10-EXUAOFFSET][0];
4313:../uvc.c      ****       		ControlHandle(Ext1EnhanceGainCtlID10);
4314:../uvc.c      **** 			CyU3PDebugPrint (4, "The edgegain command 0x%x 0x%x\r\n", wValue, bRequest);
4315:../uvc.c      ****    		break;
4316:../uvc.c      **** 		case CY_FX_EXT_CONTROL_24ENHANCE_STED: //edge enhancement start/end CONTROL24
4317:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceStarEndCtlID11-EXUAOFFSET][0];
4318:../uvc.c      ****       		ControlHandle(Ext1EnhanceStarEndCtlID11);
4319:../uvc.c      **** 			CyU3PDebugPrint (4, "The edge start/end command 0x%x 0x%x\r\n", wValue, bRequest);
4320:../uvc.c      ****     		break;
4321:../uvc.c      **** 		case CY_FX_EXT_CONTROL_262DNR_STED: //2D noise reduction start/end CONTROL26
4322:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext12DNRGainStarEndCtlID13-EXUAOFFSET][0];
4323:../uvc.c      ****       		ControlHandle(Ext12DNRGainStarEndCtlID13);
4324:../uvc.c      **** 			CyU3PDebugPrint (4, "The 2DNR start/end command 0x%x 0x%x\r\n", wValue, bRequest);
4325:../uvc.c      ****     		break;
4326:../uvc.c      **** 		case CY_FX_EXT_CONTROL_27GAMMA_MODE: //gamma correction CONTROL27
4327:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1GammaCorCtlID14-EXUAOFFSET][0];
4328:../uvc.c      ****       		ControlHandle(Ext1GammaCorCtlID14);
4329:../uvc.c      **** 			CyU3PDebugPrint (4, "The gamma command 0x%x 0x%x\r\n", wValue, bRequest);
4330:../uvc.c      ****     		break;
4331:../uvc.c      **** 		case CY_FX_EXT_CONTROL_28AGC_MAX: //AGC Maximum limitation CONTROL28
4332:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1GammaCorCtlID14-EXUAOFFSET][0];
4333:../uvc.c      ****       		ControlHandle(Ext1AGCMaxLimetCtlID15);
4334:../uvc.c      **** 			CyU3PDebugPrint (4, "The AGC Max command 0x%x 0x%x\r\n", wValue, bRequest);
4335:../uvc.c      ****     		break;
4336:../uvc.c      **** 
4337:../uvc.c      ****    	default:
4338:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
4339:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
4340:../uvc.c      ****     		break;
4341:../uvc.c      ****     }
4342:../uvc.c      **** 
4343:../uvc.c      **** }
4344:../uvc.c      **** 
4345:../uvc.c      **** /*
4346:../uvc.c      ****  * Handler for the video streaming control requests.
4347:../uvc.c      ****  */
4348:../uvc.c      **** static void
4349:../uvc.c      **** UVCHandleVideoStreamingRqts (
4350:../uvc.c      ****         void)
4351:../uvc.c      **** {
  67              		.loc 1 4351 0
  68              		.cfi_startproc
  69              		@ args = 0, pretend = 0, frame = 8
  70              		@ frame_needed = 0, uses_anonymous_args = 0
  71              	.LVL4:
4352:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
4353:../uvc.c      ****     uint16_t readCount;
4354:../uvc.c      **** 
4355:../uvc.c      ****     switch (wValue)
  72              		.loc 1 4355 0
  73 003c A8369FE5 		ldr	r3, .L133
4351:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
  74              		.loc 1 4351 0
  75 0040 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
  76              	.LCFI1:
  77              		.cfi_def_cfa_offset 16
  78              		.cfi_offset 4, -16
  79              		.cfi_offset 5, -12
  80              		.cfi_offset 6, -8
  81              		.cfi_offset 14, -4
  82              		.loc 1 4355 0
  83 0044 B030D3E1 		ldrh	r3, [r3]
4351:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
  84              		.loc 1 4351 0
  85 0048 10D04DE2 		sub	sp, sp, #16
  86              	.LCFI2:
  87              		.cfi_def_cfa_offset 32
  88              		.loc 1 4355 0
  89 004c 030C53E3 		cmp	r3, #768
  90 0050 5200000A 		beq	.L6
  91 0054 1300008A 		bhi	.L7
  92 0058 010C53E3 		cmp	r3, #256
  93 005c 2400000A 		beq	.L8
  94 0060 020C53E3 		cmp	r3, #512
  95 0064 1C00001A 		bne	.L5
4356:../uvc.c      ****     {
4357:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
4358:../uvc.c      ****             switch (bRequest)
4359:../uvc.c      ****             {
4360:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4361:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
4362:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4363:../uvc.c      ****                     break;
4364:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
4365:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4366:../uvc.c      ****                     glEp0Buffer[1] = 0;
4367:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4368:../uvc.c      ****                     break;
4369:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
4370:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
4371:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
4372:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
4373:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
4374:../uvc.c      ****                     {
4375:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
4376:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
4377:../uvc.c      **** 
4378:../uvc.c      ****                     }
4379:../uvc.c      ****                     else
4380:../uvc.c      ****                     {
4381:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
4382:../uvc.c      ****                     }
4383:../uvc.c      ****                     break;
4384:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4385:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4386:../uvc.c      ****                             glCommitCtrl, &readCount);
4387:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4388:../uvc.c      ****                     {
4389:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4390:../uvc.c      ****                         {
4391:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
4392:../uvc.c      ****                                active data structure. */
4393:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
4394:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
4395:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
4396:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
4397:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
4398:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
4399:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
4400:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
4401:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
4402:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
4403:../uvc.c      **** #if 0
4404:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
4405:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
4406:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
4407:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
4408:../uvc.c      **** #endif
4409:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
4410:../uvc.c      ****                        }
4411:../uvc.c      ****                     }
4412:../uvc.c      ****                     break;
4413:../uvc.c      ****                 default:
4414:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4415:../uvc.c      ****                     break;
4416:../uvc.c      ****             }
4417:../uvc.c      ****             break;
4418:../uvc.c      **** 
4419:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
4420:../uvc.c      ****             switch (bRequest)
  96              		.loc 1 4420 0
  97 0068 80369FE5 		ldr	r3, .L133+4
  98 006c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
  99 0070 810053E3 		cmp	r3, #129
 100 0074 9000000A 		beq	.L23
 101 0078 AF00009A 		bls	.L127
 102              	.L53:
4421:../uvc.c      ****             {
4422:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4423:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
4424:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4425:../uvc.c      ****                     break;
4426:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
4427:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4428:../uvc.c      ****                     glEp0Buffer[1] = 0;
4429:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4430:../uvc.c      ****                     break;
4431:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
4432:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
4433:../uvc.c      ****                     {
4434:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
4435:../uvc.c      ****                     }
4436:../uvc.c      ****                     else
4437:../uvc.c      ****                     {
4438:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
4439:../uvc.c      ****                     }
4440:../uvc.c      ****                     break;
4441:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4442:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
4443:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
4444:../uvc.c      ****                        */
4445:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4446:../uvc.c      ****                             glCommitCtrl, &readCount);
4447:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4448:../uvc.c      ****                     {
4449:../uvc.c      ****                         switch (glCommitCtrl[3])
4450:../uvc.c      ****                          {
4451:../uvc.c      ****                          	case 1: //1944
4452:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR_WR/
4453:../uvc.c      ****                          		CyU3PThreadSleep(500);
4454:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
4455:../uvc.c      ****                          		break;
4456:../uvc.c      ****                          	case 2: //1080
4457:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR_WR/
4458:../uvc.c      ****                          		CyU3PThreadSleep(500);
4459:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
4460:../uvc.c      ****                          		break;
4461:../uvc.c      ****                          	case 3: //720
4462:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, I2C_
4463:../uvc.c      ****                          		CyU3PThreadSleep(500);
4464:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
4465:../uvc.c      ****                          		break;
4466:../uvc.c      ****                          	case 4: //VGA
4467:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x32:0xB2)&0xFC)|ROIMode, I2C_
4468:../uvc.c      ****                          		CyU3PThreadSleep(500);
4469:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
4470:../uvc.c      ****                          		break;
4471:../uvc.c      ****                          	default:
4472:../uvc.c      ****                          		break;
4473:../uvc.c      ****                          }
4474:../uvc.c      ****                         setRes = glCommitCtrl[3];
4475:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
4476:../uvc.c      **** 
4477:../uvc.c      **** #if 0
4478:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
4479:../uvc.c      ****                         {
4480:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
4481:../uvc.c      ****                         }
4482:../uvc.c      ****                         else
4483:../uvc.c      ****                         {
4484:../uvc.c      ****                             SensorScaling_VGA ();
4485:../uvc.c      ****                         }
4486:../uvc.c      **** #endif
4487:../uvc.c      ****                         /* We can start streaming video now. */
4488:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
4489:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
4490:../uvc.c      ****                         {
4491:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
4492:../uvc.c      ****                         }
4493:../uvc.c      ****                     }
4494:../uvc.c      ****                     break;
4495:../uvc.c      **** 
4496:../uvc.c      ****                 default:
4497:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4498:../uvc.c      ****                     break;
4499:../uvc.c      ****             }
4500:../uvc.c      ****             break;
4501:../uvc.c      **** 
4502:../uvc.c      **** /* still image streaming handler */
4503:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
4504:../uvc.c      ****                 switch (bRequest)
4505:../uvc.c      ****                 {
4506:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4507:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
4508:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4509:../uvc.c      ****                         break;
4510:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4511:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4512:../uvc.c      ****                         glEp0Buffer[1] = 0;
4513:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4514:../uvc.c      ****                         break;
4515:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
4516:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
4517:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
4518:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
4519:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4520:../uvc.c      ****                         {
4521:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4522:../uvc.c      ****                         }
4523:../uvc.c      ****                         else
4524:../uvc.c      ****                         {
4525:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4526:../uvc.c      ****                         }
4527:../uvc.c      ****                         break;
4528:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4529:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4530:../uvc.c      ****                                 glCommitCtrl, &readCount);
4531:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4532:../uvc.c      ****                         {
4533:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
4534:../uvc.c      ****                             {
4535:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
4536:../uvc.c      ****                                    active data structure. */
4537:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
4538:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
4539:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
4540:../uvc.c      ****                             	//glProbeStilCtrl[4] = glCommitCtrl[4];
4541:../uvc.c      ****                             	//glProbeStilCtrl[5] = glCommitCtrl[5];
4542:../uvc.c      ****                             	//glProbeStilCtrl[6] = glCommitCtrl[6];
4543:../uvc.c      ****                             }
4544:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
4545:../uvc.c      ****                         }
4546:../uvc.c      ****                         break;
4547:../uvc.c      ****                     default:
4548:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4549:../uvc.c      ****                         break;
4550:../uvc.c      ****                 }
4551:../uvc.c      ****                 break;
4552:../uvc.c      **** 
4553:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
4554:../uvc.c      ****                 switch (bRequest)
 103              		.loc 1 4554 0
 104 007c 850053E3 		cmp	r3, #133
 105 0080 2500000A 		beq	.L55
 106 0084 860053E3 		cmp	r3, #134
 107 0088 1300001A 		bne	.L5
 108              	.L120:
4555:../uvc.c      ****                 {
4556:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4557:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
4558:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4559:../uvc.c      ****                         break;
4560:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4561:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4562:../uvc.c      ****                         glEp0Buffer[1] = 0;
4563:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4564:../uvc.c      ****                         break;
4565:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
4566:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4567:../uvc.c      ****                         {
4568:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4569:../uvc.c      ****                         }
4570:../uvc.c      ****                         else
4571:../uvc.c      ****                         {
4572:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4573:../uvc.c      ****                         }
4574:../uvc.c      ****                         break;
4575:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4576:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4577:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4578:../uvc.c      ****                            */
4579:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4580:../uvc.c      ****                                 glCommitCtrl, &readCount);
4581:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4582:../uvc.c      ****                         {
4583:../uvc.c      ****     #if 0
4584:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
4585:../uvc.c      ****                             {
4586:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
4587:../uvc.c      ****                             }
4588:../uvc.c      ****                             else
4589:../uvc.c      ****                             {
4590:../uvc.c      ****                                 SensorScaling_VGA ();
4591:../uvc.c      ****                             }
4592:../uvc.c      ****                             /* We can start streaming video now. */
4593:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
4594:../uvc.c      **** 
4595:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4596:../uvc.c      ****                             {
4597:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
4598:../uvc.c      ****                             }
4599:../uvc.c      **** 	#endif
4600:../uvc.c      ****                            switch (glCommitCtrl[1])
4601:../uvc.c      ****                              {
4602:../uvc.c      ****                              	case 4: //1944
4603:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR
4604:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4605:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4606:../uvc.c      ****                              		break;
4607:../uvc.c      ****                              	case 3: //1080
4608:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR
4609:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4610:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4611:../uvc.c      ****                              		break;
4612:../uvc.c      ****                              	case 2: //720
4613:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, 
4614:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4615:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4616:../uvc.c      ****                              		break;
4617:../uvc.c      ****                             	case 1: //VGA
4618:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
4619:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4620:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4621:../uvc.c      ****                              		break;
4622:../uvc.c      ****                               	default:
4623:../uvc.c      ****                              		break;
4624:../uvc.c      ****                              }
4625:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
4626:../uvc.c      **** 
4627:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
4628:../uvc.c      **** 
4629:../uvc.c      ****                         }
4630:../uvc.c      ****                         break;
4631:../uvc.c      **** 
4632:../uvc.c      ****                     default:
4633:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4634:../uvc.c      ****                         break;
4635:../uvc.c      ****                 }
4636:../uvc.c      ****                 break;
4637:../uvc.c      **** 
4638:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
4639:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
4640:../uvc.c      ****             	switch (bRequest)
4641:../uvc.c      ****                 {
4642:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4643:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
 109              		.loc 1 4643 0
 110 008c 60169FE5 		ldr	r1, .L133+8
 111 0090 0330A0E3 		mov	r3, #3
 112 0094 2830E1E5 		strb	r3, [r1, #40]!
4644:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 113              		.loc 1 4644 0
 114 0098 0100A0E3 		mov	r0, #1
 115 009c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 116              	.LVL5:
4645:../uvc.c      ****                         break;
4646:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4647:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
4648:../uvc.c      ****                         glEp0Buffer[1] = 0;
4649:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4650:../uvc.c      ****                         break;
4651:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
4652:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4653:../uvc.c      ****                         {
4654:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4655:../uvc.c      ****                         }
4656:../uvc.c      ****                         else
4657:../uvc.c      ****                         {
4658:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4659:../uvc.c      ****                         }
4660:../uvc.c      ****                         break;
4661:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4662:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4663:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4664:../uvc.c      ****                            */
4665:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4666:../uvc.c      ****                                 glCommitCtrl, &readCount);
4667:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4668:../uvc.c      ****                         {
4669:../uvc.c      ****     #if 1
4670:../uvc.c      ****                             /* We can start still streaming video now. */
4671:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
4672:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4673:../uvc.c      ****                             {
4674:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
4675:../uvc.c      ****                             }
4676:../uvc.c      ****     #endif
4677:../uvc.c      ****                             else{
4678:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
4679:../uvc.c      ****                             //stillcont = 0;
4680:../uvc.c      ****                             }
4681:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
4682:../uvc.c      ****                         }else{
4683:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
4684:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
4685:../uvc.c      ****                         }
4686:../uvc.c      ****                         break;
4687:../uvc.c      **** 
4688:../uvc.c      ****                     default:
4689:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4690:../uvc.c      ****                         break;
4691:../uvc.c      ****                 }
4692:../uvc.c      ****                 break;
4693:../uvc.c      **** 
4694:../uvc.c      ****         default:
4695:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4696:../uvc.c      ****             break;
4697:../uvc.c      ****     }
4698:../uvc.c      **** }
 117              		.loc 1 4698 0
 118 00a0 10D08DE2 		add	sp, sp, #16
 119              		@ sp needed
 120 00a4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 121              	.L7:
4355:../uvc.c      ****     {
 122              		.loc 1 4355 0
 123 00a8 010B53E3 		cmp	r3, #1024
 124 00ac 2400000A 		beq	.L10
 125 00b0 050C53E3 		cmp	r3, #1280
 126 00b4 0800001A 		bne	.L5
4640:../uvc.c      ****                 {
 127              		.loc 1 4640 0
 128 00b8 30369FE5 		ldr	r3, .L133+4
 129 00bc 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
 130 00c0 810055E3 		cmp	r5, #129
 131 00c4 7C00000A 		beq	.L23
 132 00c8 8300009A 		bls	.L128
 133 00cc 850055E3 		cmp	r5, #133
 134 00d0 6601000A 		beq	.L76
 135 00d4 860055E3 		cmp	r5, #134
 136 00d8 EBFFFF0A 		beq	.L120
 137              	.L5:
4695:../uvc.c      ****             break;
 138              		.loc 1 4695 0
 139 00dc 0000A0E3 		mov	r0, #0
 140 00e0 0020A0E1 		mov	r2, r0
 141 00e4 0110A0E3 		mov	r1, #1
 142 00e8 FEFFFFEB 		bl	CyU3PUsbStall
 143              	.LVL6:
 144              	.L4:
 145              		.loc 1 4698 0
 146 00ec 10D08DE2 		add	sp, sp, #16
 147              		@ sp needed
 148 00f0 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 149              	.LVL7:
 150              	.L8:
4358:../uvc.c      ****             {
 151              		.loc 1 4358 0
 152 00f4 F4459FE5 		ldr	r4, .L133+4
 153 00f8 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 154 00fc 830053E3 		cmp	r3, #131
 155 0100 5100009A 		bls	.L129
 156 0104 860053E3 		cmp	r3, #134
 157 0108 DFFFFF0A 		beq	.L120
 158 010c 870053E3 		cmp	r3, #135
 159 0110 5901000A 		beq	.L14
 160              	.L125:
4504:../uvc.c      ****                 {
 161              		.loc 1 4504 0
 162 0114 850053E3 		cmp	r3, #133
 163 0118 EFFFFF1A 		bne	.L5
 164              	.L55:
4561:../uvc.c      ****                         glEp0Buffer[1] = 0;
 165              		.loc 1 4561 0
 166 011c D0359FE5 		ldr	r3, .L133+8
 167 0120 1AC0A0E3 		mov	ip, #26
 168              	.L121:
4648:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 169              		.loc 1 4648 0
 170 0124 0020A0E3 		mov	r2, #0
4649:../uvc.c      ****                         break;
 171              		.loc 1 4649 0
 172 0128 281083E2 		add	r1, r3, #40
 173 012c 0200A0E3 		mov	r0, #2
4647:../uvc.c      ****                         glEp0Buffer[1] = 0;
 174              		.loc 1 4647 0
 175 0130 28C0C3E5 		strb	ip, [r3, #40]
4648:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 176              		.loc 1 4648 0
 177 0134 2920C3E5 		strb	r2, [r3, #41]
4649:../uvc.c      ****                         break;
 178              		.loc 1 4649 0
 179 0138 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 180              	.LVL8:
 181              		.loc 1 4698 0
 182 013c 10D08DE2 		add	sp, sp, #16
 183              		@ sp needed
 184 0140 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 185              	.L10:
4554:../uvc.c      ****                 {
 186              		.loc 1 4554 0
 187 0144 A4359FE5 		ldr	r3, .L133+4
 188 0148 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 189 014c 810053E3 		cmp	r3, #129
 190 0150 1A00000A 		beq	.L44
 191 0154 C8FFFF8A 		bhi	.L53
 192 0158 010053E3 		cmp	r3, #1
 193 015c DEFFFF1A 		bne	.L5
4579:../uvc.c      ****                                 glCommitCtrl, &readCount);
 194              		.loc 1 4579 0
 195 0160 8C459FE5 		ldr	r4, .L133+8
 196 0164 2000A0E3 		mov	r0, #32
 197 0168 4C1084E2 		add	r1, r4, #76
 198 016c 08208DE2 		add	r2, sp, #8
 199 0170 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 200              	.LVL9:
4581:../uvc.c      ****                         {
 201              		.loc 1 4581 0
 202 0174 000050E3 		cmp	r0, #0
 203 0178 DBFFFF1A 		bne	.L4
4600:../uvc.c      ****                              {
 204              		.loc 1 4600 0
 205 017c 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
 206 0180 01304CE2 		sub	r3, ip, #1
 207 0184 030053E3 		cmp	r3, #3
 208 0188 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 209 018c B80000EA 		b	.L58
 210              	.L60:
 211 0190 F0040000 		.word	.L59
 212 0194 94040000 		.word	.L61
 213 0198 30040000 		.word	.L62
 214 019c 28060000 		.word	.L63
 215              	.LVL10:
 216              	.L6:
4504:../uvc.c      ****                 {
 217              		.loc 1 4504 0
 218 01a0 48359FE5 		ldr	r3, .L133+4
 219 01a4 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 220 01a8 830053E3 		cmp	r3, #131
 221 01ac 0B00009A 		bls	.L130
 222 01b0 860053E3 		cmp	r3, #134
 223 01b4 B4FFFF0A 		beq	.L120
 224 01b8 870053E3 		cmp	r3, #135
 225 01bc D4FFFF1A 		bne	.L125
 226              	.L44:
4519:../uvc.c      ****                         {
 227              		.loc 1 4519 0
 228 01c0 2C359FE5 		ldr	r3, .L133+8
4521:../uvc.c      ****                         }
 229              		.loc 1 4521 0
 230 01c4 0B00A0E3 		mov	r0, #11
4519:../uvc.c      ****                         {
 231              		.loc 1 4519 0
 232 01c8 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 233 01cc 030053E3 		cmp	r3, #3
4521:../uvc.c      ****                         }
 234              		.loc 1 4521 0
 235 01d0 20159F05 		ldreq	r1, .L133+12
4525:../uvc.c      ****                         }
 236              		.loc 1 4525 0
 237 01d4 20159F15 		ldrne	r1, .L133+16
 238 01d8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 239              	.LVL11:
 240 01dc C2FFFFEA 		b	.L4
 241              	.L130:
4504:../uvc.c      ****                 {
 242              		.loc 1 4504 0
 243 01e0 810053E3 		cmp	r3, #129
 244 01e4 F5FFFF2A 		bcs	.L44
 245 01e8 010053E3 		cmp	r3, #1
 246 01ec BAFFFF1A 		bne	.L5
4529:../uvc.c      ****                                 glCommitCtrl, &readCount);
 247              		.loc 1 4529 0
 248 01f0 FC449FE5 		ldr	r4, .L133+8
 249 01f4 2000A0E3 		mov	r0, #32
 250 01f8 4C1084E2 		add	r1, r4, #76
 251 01fc 08208DE2 		add	r2, sp, #8
 252 0200 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 253              	.LVL12:
4531:../uvc.c      ****                         {
 254              		.loc 1 4531 0
 255 0204 000050E3 		cmp	r0, #0
 256 0208 B7FFFF1A 		bne	.L4
4533:../uvc.c      ****                             {
 257              		.loc 1 4533 0
 258 020c 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 259 0210 030053E3 		cmp	r3, #3
4537:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 260              		.loc 1 4537 0
 261 0214 4D20D405 		ldreqb	r2, [r4, #77]	@ zero_extendqisi2
 262 0218 E0349F05 		ldreq	r3, .L133+20
4538:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
 263              		.loc 1 4538 0
 264 021c 4E00D405 		ldreqb	r0, [r4, #78]	@ zero_extendqisi2
 265              	.LVL13:
 266 0220 4D10D415 		ldrneb	r1, [r4, #77]	@ zero_extendqisi2
 267 0224 0210A001 		moveq	r1, r2
4537:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 268              		.loc 1 4537 0
 269 0228 5520C305 		streqb	r2, [r3, #85]
4538:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
 270              		.loc 1 4538 0
 271 022c 5600C305 		streqb	r0, [r3, #86]
4544:../uvc.c      ****                         }
 272              		.loc 1 4544 0
 273 0230 B820DDE1 		ldrh	r2, [sp, #8]
 274 0234 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 275 0238 0400A0E3 		mov	r0, #4
 276 023c 00108DE5 		str	r1, [sp]
 277 0240 BC149FE5 		ldr	r1, .L133+24
 278 0244 FEFFFFEB 		bl	CyU3PDebugPrint
 279              	.LVL14:
 280 0248 A7FFFFEA 		b	.L4
 281              	.LVL15:
 282              	.L129:
4358:../uvc.c      ****             {
 283              		.loc 1 4358 0
 284 024c 810053E3 		cmp	r3, #129
 285 0250 0901002A 		bcs	.L14
 286 0254 010053E3 		cmp	r3, #1
 287 0258 9FFFFF1A 		bne	.L5
4385:../uvc.c      ****                             glCommitCtrl, &readCount);
 288              		.loc 1 4385 0
 289 025c 90449FE5 		ldr	r4, .L133+8
 290 0260 2000A0E3 		mov	r0, #32
 291 0264 4C1084E2 		add	r1, r4, #76
 292 0268 08208DE2 		add	r2, sp, #8
 293 026c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 294              	.LVL16:
4387:../uvc.c      ****                     {
 295              		.loc 1 4387 0
 296 0270 000050E3 		cmp	r0, #0
 297 0274 9CFFFF1A 		bne	.L4
4389:../uvc.c      ****                         {
 298              		.loc 1 4389 0
 299 0278 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 300 027c 030053E3 		cmp	r3, #3
 301 0280 99FFFF1A 		bne	.L4
4393:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 302              		.loc 1 4393 0
 303 0284 74349FE5 		ldr	r3, .L133+20
 304 0288 4E60D4E5 		ldrb	r6, [r4, #78]	@ zero_extendqisi2
4394:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 305              		.loc 1 4394 0
 306 028c 4F50D4E5 		ldrb	r5, [r4, #79]	@ zero_extendqisi2
4395:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 307              		.loc 1 4395 0
 308 0290 50C0D4E5 		ldrb	ip, [r4, #80]	@ zero_extendqisi2
4396:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 309              		.loc 1 4396 0
 310 0294 5100D4E5 		ldrb	r0, [r4, #81]	@ zero_extendqisi2
 311              	.LVL17:
4397:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 312              		.loc 1 4397 0
 313 0298 5210D4E5 		ldrb	r1, [r4, #82]	@ zero_extendqisi2
4398:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
 314              		.loc 1 4398 0
 315 029c 5320D4E5 		ldrb	r2, [r4, #83]	@ zero_extendqisi2
4393:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 316              		.loc 1 4393 0
 317 02a0 0260C3E5 		strb	r6, [r3, #2]
4394:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 318              		.loc 1 4394 0
 319 02a4 0350C3E5 		strb	r5, [r3, #3]
4395:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 320              		.loc 1 4395 0
 321 02a8 04C0C3E5 		strb	ip, [r3, #4]
4396:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 322              		.loc 1 4396 0
 323 02ac 0500C3E5 		strb	r0, [r3, #5]
4397:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 324              		.loc 1 4397 0
 325 02b0 0610C3E5 		strb	r1, [r3, #6]
4398:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
 326              		.loc 1 4398 0
 327 02b4 0720C3E5 		strb	r2, [r3, #7]
 328 02b8 8BFFFFEA 		b	.L4
 329              	.LVL18:
 330              	.L23:
4432:../uvc.c      ****                     {
 331              		.loc 1 4432 0
 332 02bc 30349FE5 		ldr	r3, .L133+8
 333 02c0 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 334 02c4 030053E3 		cmp	r3, #3
 335 02c8 2D00000A 		beq	.L131
 336              	.L19:
4381:../uvc.c      ****                     }
 337              		.loc 1 4381 0
 338 02cc 34149FE5 		ldr	r1, .L133+28
 339 02d0 1A00A0E3 		mov	r0, #26
 340 02d4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 341              	.LVL19:
 342 02d8 83FFFFEA 		b	.L4
 343              	.L128:
4640:../uvc.c      ****                 {
 344              		.loc 1 4640 0
 345 02dc 010055E3 		cmp	r5, #1
 346 02e0 7DFFFF1A 		bne	.L5
4665:../uvc.c      ****                                 glCommitCtrl, &readCount);
 347              		.loc 1 4665 0
 348 02e4 08449FE5 		ldr	r4, .L133+8
 349 02e8 08208DE2 		add	r2, sp, #8
 350 02ec 2000A0E3 		mov	r0, #32
 351 02f0 4C1084E2 		add	r1, r4, #76
 352 02f4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 353              	.LVL20:
4667:../uvc.c      ****                         {
 354              		.loc 1 4667 0
 355 02f8 002050E2 		subs	r2, r0, #0
 356 02fc EA00001A 		bne	.L79
4671:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 357              		.loc 1 4671 0
 358 0300 0400A0E1 		mov	r0, r4
 359              	.LVL21:
 360 0304 8010A0E3 		mov	r1, #128
 361 0308 FEFFFFEB 		bl	_txe_event_flags_set
 362              	.LVL22:
4672:../uvc.c      ****                             {
 363              		.loc 1 4672 0
 364 030c 002050E2 		subs	r2, r0, #0
4678:../uvc.c      ****                             //stillcont = 0;
 365              		.loc 1 4678 0
 366 0310 0F30E003 		mvneq	r3, #15
 367 0314 7230C405 		streqb	r3, [r4, #114]
4672:../uvc.c      ****                             {
 368              		.loc 1 4672 0
 369 0318 ED00001A 		bne	.L132
 370              	.LVL23:
 371              	.L81:
4681:../uvc.c      ****                         }else{
 372              		.loc 1 4681 0 discriminator 1
 373 031c 4D10D4E5 		ldrb	r1, [r4, #77]	@ zero_extendqisi2
 374 0320 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 375 0324 B820DDE1 		ldrh	r2, [sp, #8]
 376 0328 00108DE5 		str	r1, [sp]
 377 032c 0400A0E3 		mov	r0, #4
 378 0330 D4139FE5 		ldr	r1, .L133+32
 379 0334 FEFFFFEB 		bl	CyU3PDebugPrint
 380              	.LVL24:
 381 0338 6BFFFFEA 		b	.L4
 382              	.LVL25:
 383              	.L127:
4420:../uvc.c      ****             {
 384              		.loc 1 4420 0
 385 033c 010053E3 		cmp	r3, #1
 386 0340 65FFFF1A 		bne	.L5
4445:../uvc.c      ****                             glCommitCtrl, &readCount);
 387              		.loc 1 4445 0
 388 0344 A8439FE5 		ldr	r4, .L133+8
 389 0348 2000A0E3 		mov	r0, #32
 390 034c 4C1084E2 		add	r1, r4, #76
 391 0350 08208DE2 		add	r2, sp, #8
 392 0354 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 393              	.LVL26:
4447:../uvc.c      ****                     {
 394              		.loc 1 4447 0
 395 0358 000050E3 		cmp	r0, #0
 396 035c 62FFFF1A 		bne	.L4
4449:../uvc.c      ****                          {
 397              		.loc 1 4449 0
 398 0360 4F20D4E5 		ldrb	r2, [r4, #79]	@ zero_extendqisi2
 399 0364 013042E2 		sub	r3, r2, #1
 400 0368 030053E3 		cmp	r3, #3
 401 036c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 402 0370 DB0000EA 		b	.L82
 403              	.L30:
 404 0374 D8050000 		.word	.L29
 405 0378 88050000 		.word	.L31
 406 037c 38050000 		.word	.L32
 407 0380 94030000 		.word	.L33
 408              	.LVL27:
 409              	.L131:
4434:../uvc.c      ****                     }
 410              		.loc 1 4434 0
 411 0384 84139FE5 		ldr	r1, .L133+36
 412 0388 1A00A0E3 		mov	r0, #26
 413 038c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 414              	.LVL28:
 415 0390 55FFFFEA 		b	.L4
 416              	.LVL29:
 417              	.L33:
4467:../uvc.c      ****                          		CyU3PThreadSleep(500);
 418              		.loc 1 4467 0
 419 0394 64539FE5 		ldr	r5, .L133+20
 420 0398 6C2094E5 		ldr	r2, [r4, #108]
 421 039c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 422 03a0 000052E3 		cmp	r2, #0
 423 03a4 B020A003 		moveq	r2, #176
 424 03a8 3020A013 		movne	r2, #48
 425 03ac 032082E1 		orr	r2, r2, r3
 426 03b0 3010A0E3 		mov	r1, #48
 427 03b4 5230A0E3 		mov	r3, #82
 428 03b8 0100A0E3 		mov	r0, #1
 429              	.LVL30:
 430 03bc FEFFFFEB 		bl	SensorSetIrisControl
 431              	.LVL31:
4468:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 432              		.loc 1 4468 0
 433 03c0 7D0FA0E3 		mov	r0, #500
 434 03c4 FEFFFFEB 		bl	_tx_thread_sleep
 435              	.LVL32:
4469:../uvc.c      ****                          		break;
 436              		.loc 1 4469 0
 437 03c8 6C1094E5 		ldr	r1, [r4, #108]
 438 03cc 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 439 03d0 6C3094E5 		ldr	r3, [r4, #108]
 440 03d4 000051E3 		cmp	r1, #0
 441 03d8 B010A003 		moveq	r1, #176
 442 03dc 3010A013 		movne	r1, #48
 443              	.L116:
 444 03e0 022081E1 		orr	r2, r1, r2
 445 03e4 0400A0E3 		mov	r0, #4
 446 03e8 24139FE5 		ldr	r1, .L133+40
 447 03ec FEFFFFEB 		bl	CyU3PDebugPrint
 448              	.LVL33:
 449 03f0 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 450              	.L28:
4475:../uvc.c      **** 
 451              		.loc 1 4475 0
 452 03f4 0320A0E1 		mov	r2, r3
 453 03f8 18139FE5 		ldr	r1, .L133+44
 454 03fc 0400A0E3 		mov	r0, #4
4474:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 455              		.loc 1 4474 0
 456 0400 7030C4E5 		strb	r3, [r4, #112]
4475:../uvc.c      **** 
 457              		.loc 1 4475 0
 458 0404 FEFFFFEB 		bl	CyU3PDebugPrint
 459              	.LVL34:
4488:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 460              		.loc 1 4488 0
 461 0408 0020A0E3 		mov	r2, #0
 462 040c E0029FE5 		ldr	r0, .L133+8
 463 0410 0110A0E3 		mov	r1, #1
 464 0414 FEFFFFEB 		bl	_txe_event_flags_set
 465              	.LVL35:
4489:../uvc.c      ****                         {
 466              		.loc 1 4489 0
 467 0418 002050E2 		subs	r2, r0, #0
 468 041c 32FFFF0A 		beq	.L4
4491:../uvc.c      ****                         }
 469              		.loc 1 4491 0
 470 0420 F4129FE5 		ldr	r1, .L133+48
 471 0424 0400A0E3 		mov	r0, #4
 472              	.LVL36:
 473 0428 FEFFFFEB 		bl	CyU3PDebugPrint
 474              	.LVL37:
 475 042c 2EFFFFEA 		b	.L4
 476              	.LVL38:
 477              	.L62:
4608:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 478              		.loc 1 4608 0
 479 0430 6C2094E5 		ldr	r2, [r4, #108]
 480 0434 3010A0E3 		mov	r1, #48
 481 0438 000052E3 		cmp	r2, #0
 482 043c 9220A003 		moveq	r2, #146
 483 0440 1220A013 		movne	r2, #18
 484 0444 5230A0E3 		mov	r3, #82
 485 0448 0100A0E3 		mov	r0, #1
 486              	.LVL39:
 487 044c FEFFFFEB 		bl	SensorSetIrisControl
 488              	.LVL40:
4610:../uvc.c      ****                              		break;
 489              		.loc 1 4610 0
 490 0450 6C2094E5 		ldr	r2, [r4, #108]
 491 0454 0400A0E3 		mov	r0, #4
 492 0458 000052E3 		cmp	r2, #0
 493 045c 6C3094E5 		ldr	r3, [r4, #108]
 494 0460 9220A003 		moveq	r2, #146
 495 0464 1220A013 		movne	r2, #18
 496 0468 B0129FE5 		ldr	r1, .L133+52
 497 046c FEFFFFEB 		bl	CyU3PDebugPrint
 498              	.LVL41:
 499 0470 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
 500              	.L58:
4627:../uvc.c      **** 
 501              		.loc 1 4627 0
 502 0474 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 503 0478 B820DDE1 		ldrh	r2, [sp, #8]
 504 047c 00C08DE5 		str	ip, [sp]
 505 0480 9C129FE5 		ldr	r1, .L133+56
4625:../uvc.c      **** 
 506              		.loc 1 4625 0
 507 0484 71C0C4E5 		strb	ip, [r4, #113]
4627:../uvc.c      **** 
 508              		.loc 1 4627 0
 509 0488 0400A0E3 		mov	r0, #4
 510 048c FEFFFFEB 		bl	CyU3PDebugPrint
 511              	.LVL42:
 512 0490 15FFFFEA 		b	.L4
 513              	.LVL43:
 514              	.L61:
4613:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 515              		.loc 1 4613 0
 516 0494 64529FE5 		ldr	r5, .L133+20
 517 0498 6C2094E5 		ldr	r2, [r4, #108]
 518 049c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 519 04a0 000052E3 		cmp	r2, #0
 520 04a4 8020A003 		moveq	r2, #128
 521 04a8 0020A013 		movne	r2, #0
 522 04ac 032082E1 		orr	r2, r2, r3
 523 04b0 3010A0E3 		mov	r1, #48
 524 04b4 5230A0E3 		mov	r3, #82
 525 04b8 0100A0E3 		mov	r0, #1
 526              	.LVL44:
 527 04bc FEFFFFEB 		bl	SensorSetIrisControl
 528              	.LVL45:
4615:../uvc.c      ****                              		break;
 529              		.loc 1 4615 0
 530 04c0 6C1094E5 		ldr	r1, [r4, #108]
 531 04c4 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 532 04c8 6C3094E5 		ldr	r3, [r4, #108]
 533 04cc 000051E3 		cmp	r1, #0
 534 04d0 8010A003 		moveq	r1, #128
 535 04d4 0010A013 		movne	r1, #0
 536              	.L118:
4620:../uvc.c      ****                              		break;
 537              		.loc 1 4620 0
 538 04d8 022081E1 		orr	r2, r1, r2
 539 04dc 0400A0E3 		mov	r0, #4
 540 04e0 38129FE5 		ldr	r1, .L133+52
 541 04e4 FEFFFFEB 		bl	CyU3PDebugPrint
 542              	.LVL46:
 543 04e8 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
4621:../uvc.c      ****                               	default:
 544              		.loc 1 4621 0
 545 04ec E0FFFFEA 		b	.L58
 546              	.LVL47:
 547              	.L59:
4618:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 548              		.loc 1 4618 0
 549 04f0 08529FE5 		ldr	r5, .L133+20
 550 04f4 6C2094E5 		ldr	r2, [r4, #108]
 551 04f8 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 552 04fc 000052E3 		cmp	r2, #0
 553 0500 F420A003 		moveq	r2, #244
 554 0504 7420A013 		movne	r2, #116
 555 0508 032082E1 		orr	r2, r2, r3
 556 050c 3010A0E3 		mov	r1, #48
 557 0510 5230A0E3 		mov	r3, #82
 558 0514 0100A0E3 		mov	r0, #1
 559              	.LVL48:
 560 0518 FEFFFFEB 		bl	SensorSetIrisControl
 561              	.LVL49:
4620:../uvc.c      ****                              		break;
 562              		.loc 1 4620 0
 563 051c 6C1094E5 		ldr	r1, [r4, #108]
 564 0520 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 565 0524 000051E3 		cmp	r1, #0
 566 0528 6C3094E5 		ldr	r3, [r4, #108]
 567 052c F410A003 		moveq	r1, #244
 568 0530 7410A013 		movne	r1, #116
 569 0534 E7FFFFEA 		b	.L118
 570              	.LVL50:
 571              	.L32:
4462:../uvc.c      ****                          		CyU3PThreadSleep(500);
 572              		.loc 1 4462 0
 573 0538 C0519FE5 		ldr	r5, .L133+20
 574 053c 6C2094E5 		ldr	r2, [r4, #108]
 575 0540 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 576 0544 000052E3 		cmp	r2, #0
 577 0548 8020A003 		moveq	r2, #128
 578 054c 0020A013 		movne	r2, #0
 579 0550 032082E1 		orr	r2, r2, r3
 580 0554 3010A0E3 		mov	r1, #48
 581 0558 5230A0E3 		mov	r3, #82
 582 055c 0100A0E3 		mov	r0, #1
 583              	.LVL51:
 584 0560 FEFFFFEB 		bl	SensorSetIrisControl
 585              	.LVL52:
4463:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 586              		.loc 1 4463 0
 587 0564 7D0FA0E3 		mov	r0, #500
 588 0568 FEFFFFEB 		bl	_tx_thread_sleep
 589              	.LVL53:
4464:../uvc.c      ****                          		break;
 590              		.loc 1 4464 0
 591 056c 6C1094E5 		ldr	r1, [r4, #108]
 592 0570 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 593 0574 000051E3 		cmp	r1, #0
 594 0578 6C3094E5 		ldr	r3, [r4, #108]
 595 057c 8010A003 		moveq	r1, #128
 596 0580 0010A013 		movne	r1, #0
 597 0584 95FFFFEA 		b	.L116
 598              	.LVL54:
 599              	.L31:
4457:../uvc.c      ****                          		CyU3PThreadSleep(500);
 600              		.loc 1 4457 0
 601 0588 6C2094E5 		ldr	r2, [r4, #108]
 602 058c 3010A0E3 		mov	r1, #48
 603 0590 000052E3 		cmp	r2, #0
 604 0594 9220A003 		moveq	r2, #146
 605 0598 1220A013 		movne	r2, #18
 606 059c 5230A0E3 		mov	r3, #82
 607 05a0 0100A0E3 		mov	r0, #1
 608              	.LVL55:
 609 05a4 FEFFFFEB 		bl	SensorSetIrisControl
 610              	.LVL56:
4458:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 611              		.loc 1 4458 0
 612 05a8 7D0FA0E3 		mov	r0, #500
 613 05ac FEFFFFEB 		bl	_tx_thread_sleep
 614              	.LVL57:
4459:../uvc.c      ****                          		break;
 615              		.loc 1 4459 0
 616 05b0 6C2094E5 		ldr	r2, [r4, #108]
 617 05b4 0400A0E3 		mov	r0, #4
 618 05b8 000052E3 		cmp	r2, #0
 619 05bc 6C3094E5 		ldr	r3, [r4, #108]
 620 05c0 9220A003 		moveq	r2, #146
 621 05c4 1220A013 		movne	r2, #18
 622 05c8 44119FE5 		ldr	r1, .L133+40
 623 05cc FEFFFFEB 		bl	CyU3PDebugPrint
 624              	.LVL58:
 625 05d0 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
4460:../uvc.c      ****                          	case 3: //720
 626              		.loc 1 4460 0
 627 05d4 86FFFFEA 		b	.L28
 628              	.LVL59:
 629              	.L29:
4452:../uvc.c      ****                          		CyU3PThreadSleep(500);
 630              		.loc 1 4452 0
 631 05d8 6C2094E5 		ldr	r2, [r4, #108]
 632 05dc 3010A0E3 		mov	r1, #48
 633 05e0 000052E3 		cmp	r2, #0
 634 05e4 A220A003 		moveq	r2, #162
 635 05e8 2220A013 		movne	r2, #34
 636 05ec 5230A0E3 		mov	r3, #82
 637 05f0 0100A0E3 		mov	r0, #1
 638              	.LVL60:
 639 05f4 FEFFFFEB 		bl	SensorSetIrisControl
 640              	.LVL61:
4453:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 641              		.loc 1 4453 0
 642 05f8 7D0FA0E3 		mov	r0, #500
 643 05fc FEFFFFEB 		bl	_tx_thread_sleep
 644              	.LVL62:
4454:../uvc.c      ****                          		break;
 645              		.loc 1 4454 0
 646 0600 6C2094E5 		ldr	r2, [r4, #108]
 647 0604 0400A0E3 		mov	r0, #4
 648 0608 000052E3 		cmp	r2, #0
 649 060c 6C3094E5 		ldr	r3, [r4, #108]
 650 0610 A220A003 		moveq	r2, #162
 651 0614 2220A013 		movne	r2, #34
 652 0618 F4109FE5 		ldr	r1, .L133+40
 653 061c FEFFFFEB 		bl	CyU3PDebugPrint
 654              	.LVL63:
 655 0620 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
4455:../uvc.c      ****                          	case 2: //1080
 656              		.loc 1 4455 0
 657 0624 72FFFFEA 		b	.L28
 658              	.LVL64:
 659              	.L63:
4603:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 660              		.loc 1 4603 0
 661 0628 6C2094E5 		ldr	r2, [r4, #108]
 662 062c 3010A0E3 		mov	r1, #48
 663 0630 000052E3 		cmp	r2, #0
 664 0634 A220A003 		moveq	r2, #162
 665 0638 2220A013 		movne	r2, #34
 666 063c 5230A0E3 		mov	r3, #82
 667 0640 0100A0E3 		mov	r0, #1
 668              	.LVL65:
 669 0644 FEFFFFEB 		bl	SensorSetIrisControl
 670              	.LVL66:
4605:../uvc.c      ****                              		break;
 671              		.loc 1 4605 0
 672 0648 6C2094E5 		ldr	r2, [r4, #108]
 673 064c 0400A0E3 		mov	r0, #4
 674 0650 000052E3 		cmp	r2, #0
 675 0654 6C3094E5 		ldr	r3, [r4, #108]
 676 0658 A220A003 		moveq	r2, #162
 677 065c 2220A013 		movne	r2, #34
 678 0660 B8109FE5 		ldr	r1, .L133+52
 679 0664 FEFFFFEB 		bl	CyU3PDebugPrint
 680              	.LVL67:
 681 0668 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
4606:../uvc.c      ****                              	case 3: //1080
 682              		.loc 1 4606 0
 683 066c 80FFFFEA 		b	.L58
 684              	.LVL68:
 685              	.L76:
4647:../uvc.c      ****                         glEp0Buffer[1] = 0;
 686              		.loc 1 4647 0
 687 0670 7C309FE5 		ldr	r3, .L133+8
 688 0674 01C0A0E3 		mov	ip, #1
 689 0678 A9FEFFEA 		b	.L121
 690              	.L14:
4373:../uvc.c      ****                     {
 691              		.loc 1 4373 0
 692 067c 70309FE5 		ldr	r3, .L133+8
 693 0680 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 694 0684 030053E3 		cmp	r3, #3
 695 0688 0FFFFF1A 		bne	.L19
4375:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 696              		.loc 1 4375 0
 697 068c 6C109FE5 		ldr	r1, .L133+20
 698 0690 1A00A0E3 		mov	r0, #26
 699 0694 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 700              	.LVL69:
4376:../uvc.c      **** 
 701              		.loc 1 4376 0
 702 0698 0020D4E5 		ldrb	r2, [r4]	@ zero_extendqisi2
 703 069c 84109FE5 		ldr	r1, .L133+60
 704 06a0 0400A0E3 		mov	r0, #4
 705 06a4 FEFFFFEB 		bl	CyU3PDebugPrint
 706              	.LVL70:
 707 06a8 8FFEFFEA 		b	.L4
 708              	.LVL71:
 709              	.L79:
4683:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
 710              		.loc 1 4683 0
 711 06ac B820DDE1 		ldrh	r2, [sp, #8]
 712 06b0 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 713 06b4 70109FE5 		ldr	r1, .L133+64
 714 06b8 0400A0E3 		mov	r0, #4
 715              	.LVL72:
 716 06bc FEFFFFEB 		bl	CyU3PDebugPrint
 717              	.LVL73:
4684:../uvc.c      ****                         }
 718              		.loc 1 4684 0
 719 06c0 0000A0E3 		mov	r0, #0
 720 06c4 0510A0E1 		mov	r1, r5
 721 06c8 0020A0E1 		mov	r2, r0
 722 06cc FEFFFFEB 		bl	CyU3PUsbStall
 723              	.LVL74:
 724 06d0 85FEFFEA 		b	.L4
 725              	.LVL75:
 726              	.L132:
4674:../uvc.c      ****                             }
 727              		.loc 1 4674 0
 728 06d4 54109FE5 		ldr	r1, .L133+68
 729 06d8 0400A0E3 		mov	r0, #4
 730              	.LVL76:
 731 06dc FEFFFFEB 		bl	CyU3PDebugPrint
 732              	.LVL77:
 733 06e0 0DFFFFEA 		b	.L81
 734              	.LVL78:
 735              	.L82:
4449:../uvc.c      ****                          {
 736              		.loc 1 4449 0
 737 06e4 0230A0E1 		mov	r3, r2
 738 06e8 41FFFFEA 		b	.L28
 739              	.L134:
 740              		.align	2
 741              	.L133:
 742 06ec 00000000 		.word	wValue
 743 06f0 00000000 		.word	bRequest
 744 06f4 00000000 		.word	.LANCHOR0
 745 06f8 54000000 		.word	.LANCHOR1+84
 746 06fc 60000000 		.word	.LANCHOR1+96
 747 0700 00000000 		.word	.LANCHOR1
 748 0704 B4000000 		.word	.LC5
 749 0708 1C000000 		.word	.LANCHOR1+28
 750 070c 50010000 		.word	.LC9
 751 0710 38000000 		.word	.LANCHOR1+56
 752 0714 40000000 		.word	.LC2
 753 0718 64000000 		.word	.LC3
 754 071c 8C000000 		.word	.LC4
 755 0720 E0000000 		.word	.LC6
 756 0724 04010000 		.word	.LC7
 757 0728 18000000 		.word	.LC1
 758 072c 7C010000 		.word	.LC10
 759 0730 2C010000 		.word	.LC8
 760              		.cfi_endproc
 761              	.LFE24:
 763              		.align	2
 764              		.global	I2cAppThread_Entry
 766              	I2cAppThread_Entry:
 767              	.LFB26:
4699:../uvc.c      **** 
4700:../uvc.c      **** /*
4701:../uvc.c      ****  * Entry function for the UVC control request processing thread.
4702:../uvc.c      ****  */
4703:../uvc.c      **** void
4704:../uvc.c      **** UVCAppEP0Thread_Entry (
4705:../uvc.c      ****         uint32_t input)
4706:../uvc.c      **** {
4707:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
4708:../uvc.c      ****     uint32_t eventFlag;
4709:../uvc.c      **** 	CyBool_t value;
4710:../uvc.c      **** 	CyBool_t *valueptr = &value;
4711:../uvc.c      **** 
4712:../uvc.c      **** 
4713:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4714:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4715:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
4716:../uvc.c      **** 
4717:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
4718:../uvc.c      **** #endif
4719:../uvc.c      **** 
4720:../uvc.c      ****     /* for interrupt status test */
4721:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4722:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
4723:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
4724:../uvc.c      **** 
4725:../uvc.c      ****     for (;;)
4726:../uvc.c      ****     {
4727:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
4728:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
4729:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
4730:../uvc.c      ****         {
4731:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
4732:../uvc.c      ****             if (!isUsbConnected)
4733:../uvc.c      ****             {
4734:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
4735:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
4736:../uvc.c      ****                 {
4737:../uvc.c      ****                     isUsbConnected = CyTrue;
4738:../uvc.c      ****                 }
4739:../uvc.c      ****             }
4740:../uvc.c      **** //#ifdef DbgInfo
4741:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
4742:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
4743:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
4744:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
4745:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
4746:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
4747:../uvc.c      **** //#endif
4748:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
4749:../uvc.c      ****             {
4750:../uvc.c      ****             	switch ((wIndex >> 8))
4751:../uvc.c      ****                 {
4752:../uvc.c      **** 
4753:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
4754:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
4755:../uvc.c      ****                         break;
4756:../uvc.c      **** 
4757:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
4758:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
4759:../uvc.c      ****                         break;
4760:../uvc.c      **** 
4761:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
4762:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
4763:../uvc.c      ****                         break;
4764:../uvc.c      **** 
4765:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
4766:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
4767:../uvc.c      ****                         break;
4768:../uvc.c      **** 
4769:../uvc.c      ****                     default:
4770:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
4771:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4772:../uvc.c      ****                         break;
4773:../uvc.c      ****                 }
4774:../uvc.c      ****             }
4775:../uvc.c      **** 
4776:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
4777:../uvc.c      ****             {
4778:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
4779:../uvc.c      **** 
4780:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
4781:../uvc.c      ****                 {
4782:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4783:../uvc.c      ****                 }
4784:../uvc.c      ****                 else
4785:../uvc.c      ****                 {
4786:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
4787:../uvc.c      ****                 }
4788:../uvc.c      ****             }
4789:../uvc.c      **** 
4790:../uvc.c      ****             /* handle interrupt status event */
4791:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
4792:../uvc.c      ****             {
4793:../uvc.c      **** 
4794:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
4795:../uvc.c      ****             	/** preparing interrupt status data **/
4796:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
4797:../uvc.c      **** 
4798:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4799:../uvc.c      **** 
4800:../uvc.c      **** #if 0 //for real button
4801:../uvc.c      **** 				if(value&&(!snapButFlag)){
4802:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4803:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4804:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4805:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4806:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4807:../uvc.c      **** 
4808:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4809:../uvc.c      **** 					interStabuf.size   = 1024;
4810:../uvc.c      **** 					interStabuf.status = 0;
4811:../uvc.c      **** 
4812:../uvc.c      **** 					interStabuf.count = 4;
4813:../uvc.c      **** 
4814:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4815:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4816:../uvc.c      **** 
4817:../uvc.c      **** 					/** send a interrupt status data **/
4818:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4819:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4820:../uvc.c      **** 					{
4821:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4822:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4823:../uvc.c      **** 					}
4824:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
4825:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
4826:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4827:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4828:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4829:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4830:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4831:../uvc.c      **** 
4832:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4833:../uvc.c      **** 					interStabuf.size   = 1024;
4834:../uvc.c      **** 					interStabuf.status = 0;
4835:../uvc.c      **** 
4836:../uvc.c      **** 					interStabuf.count = 4;
4837:../uvc.c      **** 
4838:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4839:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4840:../uvc.c      **** 
4841:../uvc.c      **** 					/** send a interrupt status data **/
4842:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4843:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4844:../uvc.c      **** 					{
4845:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4846:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4847:../uvc.c      **** 					}
4848:../uvc.c      **** 
4849:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
4850:../uvc.c      **** 					stiflag = 0xFF;
4851:../uvc.c      **** 				}
4852:../uvc.c      **** #else			//for botton simulation
4853:../uvc.c      **** 				if(snapButFlag == 0x0f){
4854:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4855:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4856:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4857:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4858:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4859:../uvc.c      **** 
4860:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4861:../uvc.c      **** 					interStabuf.size   = 1024;
4862:../uvc.c      **** 					interStabuf.status = 0;
4863:../uvc.c      **** 
4864:../uvc.c      **** 					interStabuf.count = 4;
4865:../uvc.c      **** 
4866:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4867:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4868:../uvc.c      **** 
4869:../uvc.c      **** 					/** send a interrupt status data **/
4870:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4871:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4872:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4873:../uvc.c      **** 					{
4874:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4875:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4876:../uvc.c      **** 					}
4877:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
4878:../uvc.c      **** 
4879:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
4880:../uvc.c      **** 				}else if(!snapButFlag){
4881:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4882:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4883:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4884:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4885:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4886:../uvc.c      **** 
4887:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4888:../uvc.c      **** 					interStabuf.size   = 1024;
4889:../uvc.c      **** 					interStabuf.status = 0;
4890:../uvc.c      **** 
4891:../uvc.c      **** 					interStabuf.count = 4;
4892:../uvc.c      **** 
4893:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4894:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4895:../uvc.c      **** 
4896:../uvc.c      **** 					/** send a interrupt status data **/
4897:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4898:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4899:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4900:../uvc.c      **** 					{
4901:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4902:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4903:../uvc.c      **** 					}
4904:../uvc.c      **** 
4905:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
4906:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
4907:../uvc.c      **** 				}
4908:../uvc.c      **** #endif
4909:../uvc.c      **** 
4910:../uvc.c      ****             }
4911:../uvc.c      **** 
4912:../uvc.c      **** 
4913:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4914:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
4915:../uvc.c      ****             {
4916:../uvc.c      ****                 /* Get the command buffer */
4917:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
4918:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4919:../uvc.c      ****                 {
4920:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
4921:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4922:../uvc.c      ****                 }
4923:../uvc.c      **** 
4924:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
4925:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
4926:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
4927:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
4928:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
4929:../uvc.c      ****                  * register value high byte and register value low byte.
4930:../uvc.c      ****                  */
4931:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
4932:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
4933:../uvc.c      ****                 {
4934:../uvc.c      ****                     if (dmaInfo.count == 3)
4935:../uvc.c      ****                     {
4936:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
4937:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
4938:../uvc.c      ****                         dmaInfo.count = 3;
4939:../uvc.c      ****                     }
4940:../uvc.c      ****                     else if (dmaInfo.count == 4)
4941:../uvc.c      ****                     {
4942:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
4943:../uvc.c      ****                         {
4944:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
4945:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
4946:../uvc.c      ****                         }
4947:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
4948:../uvc.c      ****                     }
4949:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
4950:../uvc.c      ****                 }
4951:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
4952:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
4953:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
4954:../uvc.c      ****                  */
4955:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
4956:../uvc.c      ****                 {
4957:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4958:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
4959:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4960:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
4961:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
4962:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4963:../uvc.c      ****                         	break;
4964:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
4965:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
4966:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4967:../uvc.c      ****                         	break;*/
4968:../uvc.c      ****                     dmaInfo.count -= 2;
4969:../uvc.c      ****                 }
4970:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
4971:../uvc.c      ****                 else
4972:../uvc.c      ****                 {
4973:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
4974:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
4975:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
4976:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
4977:../uvc.c      ****                 }
4978:../uvc.c      **** 
4979:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
4980:../uvc.c      ****                 dmaInfo.size   = 1024;
4981:../uvc.c      ****                 dmaInfo.status = 0;
4982:../uvc.c      **** 
4983:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
4984:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
4985:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4986:../uvc.c      ****                 {
4987:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
4988:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4989:../uvc.c      ****                 }
4990:../uvc.c      **** 
4991:../uvc.c      ****                 /* Wait until the response has gone out. */
4992:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
4993:../uvc.c      **** 
4994:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
4995:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4996:../uvc.c      ****                 {
4997:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
4998:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4999:../uvc.c      ****                 }
5000:../uvc.c      ****             }
5001:../uvc.c      **** #endif
5002:../uvc.c      ****         }
5003:../uvc.c      ****         /* Allow other ready threads to run. */
5004:../uvc.c      ****         CyU3PThreadRelinquish ();
5005:../uvc.c      ****     }
5006:../uvc.c      **** }
5007:../uvc.c      **** 
5008:../uvc.c      **** /*
5009:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
5010:../uvc.c      ****  * added 10/2013
5011:../uvc.c      ****  */
5012:../uvc.c      **** /*
5013:../uvc.c      **** static uint8_t timeDelay[64] = {
5014:../uvc.c      **** 
5015:../uvc.c      **** };
5016:../uvc.c      **** */
5017:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
 768              		.loc 1 5017 0
 769              		.cfi_startproc
 770              		@ args = 0, pretend = 0, frame = 8
 771              		@ frame_needed = 0, uses_anonymous_args = 0
 772              	.LVL79:
 773 0734 F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
 774              	.LCFI3:
 775              		.cfi_def_cfa_offset 28
 776              		.cfi_offset 4, -28
 777              		.cfi_offset 5, -24
 778              		.cfi_offset 6, -20
 779              		.cfi_offset 7, -16
 780              		.cfi_offset 8, -12
 781              		.cfi_offset 9, -8
 782              		.cfi_offset 14, -4
5018:../uvc.c      **** 
5019:../uvc.c      **** 	uint16_t count = 0, cmdCopyIdx = 0, count1 = 0, cmdQuIdx = 0; //
5020:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
5021:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
5022:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
5023:../uvc.c      **** 	VdcmdDes  *lcStaDes;
5024:../uvc.c      **** 	uint32_t flag = 0;
5025:../uvc.c      **** 	uint8_t  cmdFlag = 0;
5026:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
5027:../uvc.c      **** 	uint8_t i;
5028:../uvc.c      **** 	uint16_t delaytime;
5029:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
5030:../uvc.c      **** 
5031:../uvc.c      **** #if 0 //for test the command queue
5032:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
5033:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
5034:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
5035:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
5036:../uvc.c      **** 		lcCmdDes += 1;
5037:../uvc.c      **** 	}
5038:../uvc.c      **** 	lcCmdDes = statQuptr->startAdd;
5039:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
5040:../uvc.c      **** 		CyU3PDebugPrint (4, "State Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n",
5041:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
5042:../uvc.c      **** 		lcCmdDes += 1;
5043:../uvc.c      **** 	}
5044:../uvc.c      **** 
5045:../uvc.c      **** #endif
5046:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
5047:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
 783              		.loc 1 5047 0
 784 0738 34029FE5 		ldr	r0, .L161
 785              	.LVL80:
5017:../uvc.c      **** 
 786              		.loc 1 5017 0
 787 073c 1CD04DE2 		sub	sp, sp, #28
 788              	.LCFI4:
 789              		.cfi_def_cfa_offset 56
5024:../uvc.c      **** 	uint8_t  cmdFlag = 0;
 790              		.loc 1 5024 0
 791 0740 00C0A0E3 		mov	ip, #0
 792              		.loc 1 5047 0
 793 0744 FA2FA0E3 		mov	r2, #1000
 794 0748 2C30A0E3 		mov	r3, #44
 795 074c 0C10A0E1 		mov	r1, ip
 796 0750 04C08DE5 		str	ip, [sp, #4]
 797 0754 08C08DE5 		str	ip, [sp, #8]
 798 0758 00208DE5 		str	r2, [sp]
 799 075c 0C308DE5 		str	r3, [sp, #12]
 800 0760 10229FE5 		ldr	r2, .L161+4
 801 0764 0B30A0E3 		mov	r3, #11
5024:../uvc.c      **** 	uint8_t  cmdFlag = 0;
 802              		.loc 1 5024 0
 803 0768 14C08DE5 		str	ip, [sp, #20]
 804              	.LVL81:
 805              		.loc 1 5047 0
 806 076c FEFFFFEB 		bl	_txe_timer_create
 807              	.LVL82:
5048:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
 808              		.loc 1 5048 0
 809 0770 FEFFFFEB 		bl	_tx_time_get
 810              	.LVL83:
5049:../uvc.c      **** 	CyU3PThreadSleep(50);
5050:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
5051:../uvc.c      **** 
5052:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
 811              		.loc 1 5052 0
 812 0774 00529FE5 		ldr	r5, .L161+8
5048:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
 813              		.loc 1 5048 0
 814 0778 00129FE5 		ldr	r1, .L161+12
 815 077c 0020A0E1 		mov	r2, r0
 816 0780 0400A0E3 		mov	r0, #4
 817 0784 FEFFFFEB 		bl	CyU3PDebugPrint
 818              	.LVL84:
5049:../uvc.c      **** 	CyU3PThreadSleep(50);
 819              		.loc 1 5049 0
 820 0788 3200A0E3 		mov	r0, #50
 821 078c FEFFFFEB 		bl	_tx_thread_sleep
 822              	.LVL85:
5050:../uvc.c      **** 
 823              		.loc 1 5050 0
 824 0790 DC019FE5 		ldr	r0, .L161
 825 0794 FEFFFFEB 		bl	_txe_timer_activate
 826              	.LVL86:
 827              		.loc 1 5052 0
 828 0798 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 829 079c 000052E3 		cmp	r2, #0
 830 07a0 0300001A 		bne	.L136
 831              	.L137:
5053:../uvc.c      ****         /* Allow other ready threads to run. */
5054:../uvc.c      **** 
5055:../uvc.c      ****         CyU3PThreadRelinquish ();
 832              		.loc 1 5055 0
 833 07a4 FEFFFFEB 		bl	_txe_thread_relinquish
 834              	.LVL87:
5052:../uvc.c      ****         /* Allow other ready threads to run. */
 835              		.loc 1 5052 0
 836 07a8 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 837 07ac 000052E3 		cmp	r2, #0
 838 07b0 FBFFFF0A 		beq	.L137
 839              	.L136:
5056:../uvc.c      **** 	}
5057:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
 840              		.loc 1 5057 0
 841 07b4 103095E5 		ldr	r3, [r5, #16]
 842 07b8 0400A0E3 		mov	r0, #4
 843 07bc 3C3093E5 		ldr	r3, [r3, #60]
 844 07c0 BC119FE5 		ldr	r1, .L161+16
 845 07c4 FEFFFFEB 		bl	CyU3PDebugPrint
 846              	.LVL88:
 847 07c8 B8619FE5 		ldr	r6, .L161+20
 848 07cc B8819FE5 		ldr	r8, .L161+24
5058:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
5059:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
5060:../uvc.c      **** 	//CyU3PThreadSleep(100);
5061:../uvc.c      **** 	//SetCurCmd();
5062:../uvc.c      **** 	/*********** the loop of the thread ***********/
5063:../uvc.c      **** 	for(;;){
5064:../uvc.c      **** 
5065:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 849              		.loc 1 5065 0
 850 07d0 0070E0E3 		mvn	r7, #0
 851              	.L154:
 852 07d4 14308DE2 		add	r3, sp, #20
 853 07d8 2010A0E3 		mov	r1, #32
 854 07dc 0320A0E3 		mov	r2, #3
 855 07e0 00708DE5 		str	r7, [sp]
 856 07e4 A4019FE5 		ldr	r0, .L161+28
 857 07e8 FEFFFFEB 		bl	_txe_event_flags_get
 858              	.LVL89:
5066:../uvc.c      **** /*  // for test GPIO output
5067:../uvc.c      **** 		if(trigger)
5068:../uvc.c      **** 		{
5069:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
5070:../uvc.c      **** 			{
5071:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
5072:../uvc.c      **** 			}
5073:../uvc.c      **** 
5074:../uvc.c      **** 		}else{
5075:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
5076:../uvc.c      **** 			{
5077:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
5078:../uvc.c      **** 			}
5079:../uvc.c      **** 
5080:../uvc.c      **** 		}
5081:../uvc.c      **** */
5082:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 859              		.loc 1 5082 0
 860 07ec 1C0096E5 		ldr	r0, [r6, #28]
 861 07f0 0010E0E3 		mvn	r1, #0
 862 07f4 FEFFFFEB 		bl	_txe_mutex_get
 863              	.LVL90:
5083:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
5084:../uvc.c      **** 			/* find an available reading I2C command in the state queue */
5085:../uvc.c      **** 			lcStaDes = (VdcmdDes*)statQuptr->readPtr;
5086:../uvc.c      **** 			//if(0 && (lcStaDes->cmdFlag == CyTrue)){ /* for state queue it's not used right now. */
5087:../uvc.c      **** 				i = 0;
5088:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 864              		.loc 1 5088 0
 865 07f8 103096E5 		ldr	r3, [r6, #16]
 866 07fc 3C3093E5 		ldr	r3, [r3, #60]
 867 0800 000053E3 		cmp	r3, #0
 868 0804 0300001A 		bne	.L138
 869 0808 4030A0E3 		mov	r3, #64
 870              	.LVL91:
 871              	.L139:
 872 080c 013043E2 		sub	r3, r3, #1
 873 0810 FF3013E2 		ands	r3, r3, #255
 874 0814 FCFFFF1A 		bne	.L139
 875              	.LVL92:
 876              	.L138:
5089:../uvc.c      **** 					i++;
5090:../uvc.c      **** 					lcCmdDes = lcStaDes->cmdDesNext;
5091:../uvc.c      **** 					statQuptr->readPtr = lcStaDes;
5092:../uvc.c      **** 				}
5093:../uvc.c      **** #if 0
5094:../uvc.c      **** 				if(lcStaDes->cmdFlag != deswait){
5095:../uvc.c      **** 				i = lcStaDes->curNum;
5096:../uvc.c      **** 				regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
5097:../uvc.c      **** 				devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
5098:../uvc.c      **** 				data = ((lcStaDes->CmdPar)+i)->Data;
5099:../uvc.c      **** 				//delaytime = ((lcStaDes->CmdPar)+i)->DelayT;
5100:../uvc.c      **** 
5101:../uvc.c      **** 				//for(i = 0; i < lcStaDes->NumPara; i++){
5102:../uvc.c      **** 					//regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
5103:../uvc.c      **** 					//devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
5104:../uvc.c      **** 					((lcStaDes->CmdPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
5105:../uvc.c      **** #ifdef USB_DEBUG_PRINT
5106:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
5107:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
5108:../uvc.c      **** #endif
5109:../uvc.c      **** 				//}
5110:../uvc.c      **** 				lcStaDes->cmdFlag = CyFalse;
5111:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->cmdDesNext; //update command queue read pointer
5112:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
5113:../uvc.c      **** 				/* setting delay */
5114:../uvc.c      **** 				delaytime = 300;
5115:../uvc.c      **** 				CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
5116:../uvc.c      **** 				CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
5117:../uvc.c      **** 			} //end of the if condition statment
5118:../uvc.c      **** #endif
5119:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 877              		.loc 1 5119 0
 878 0818 1C0096E5 		ldr	r0, [r6, #28]
 879 081c FEFFFFEB 		bl	_txe_mutex_put
 880              	.LVL93:
5120:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
5121:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 881              		.loc 1 5121 0
 882 0820 1C0095E5 		ldr	r0, [r5, #28]
 883 0824 0010E0E3 		mvn	r1, #0
 884 0828 FEFFFFEB 		bl	_txe_mutex_get
 885              	.LVL94:
5122:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 886              		.loc 1 5122 0
 887 082c 104095E5 		ldr	r4, [r5, #16]
 888              	.LVL95:
5123:../uvc.c      **** 
5124:../uvc.c      **** 				/*
5125:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
5126:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
5127:../uvc.c      **** 				*/
5128:../uvc.c      **** 
5129:../uvc.c      **** 				/* find a available command */
5130:../uvc.c      **** 				i = 0;
5131:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 889              		.loc 1 5131 0
 890 0830 3C3094E5 		ldr	r3, [r4, #60]
 891 0834 000053E3 		cmp	r3, #0
 892 0838 0900001A 		bne	.L140
 893 083c 4020A0E3 		mov	r2, #64
 894 0840 010000EA 		b	.L143
 895              	.LVL96:
 896              	.L141:
 897              		.loc 1 5131 0 is_stmt 0 discriminator 2
 898 0844 FF2012E2 		ands	r2, r2, #255
 899 0848 3100000A 		beq	.L159
 900              	.L143:
5132:../uvc.c      **** 					i++;
5133:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 901              		.loc 1 5133 0 is_stmt 1
 902 084c 344094E5 		ldr	r4, [r4, #52]
 903              	.LVL97:
 904 0850 012042E2 		sub	r2, r2, #1
5131:../uvc.c      **** 					i++;
 905              		.loc 1 5131 0
 906 0854 3C3094E5 		ldr	r3, [r4, #60]
 907 0858 000053E3 		cmp	r3, #0
 908 085c F8FFFF0A 		beq	.L141
 909 0860 104085E5 		str	r4, [r5, #16]
 910              	.L140:
 911              	.LVL98:
 912 0864 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
5134:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
5135:../uvc.c      **** 				}
5136:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
5137:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
5138:../uvc.c      **** 					i = lcCmdDes->curNum;
5139:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
5140:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
5141:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
5142:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
5143:../uvc.c      **** #if 1
5144:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 913              		.loc 1 5144 0
 914 0868 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
 915 086c 833083E0 		add	r3, r3, r3, asl #1
 916 0870 833084E0 		add	r3, r4, r3, asl #1
 917 0874 20C04CE2 		sub	ip, ip, #32
5139:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 918              		.loc 1 5139 0
 919 0878 0400D3E5 		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 920              	.LVL99:
5140:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 921              		.loc 1 5140 0
 922 087c 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 923              	.LVL100:
5141:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 924              		.loc 1 5141 0
 925 0880 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 926              	.LVL101:
5142:../uvc.c      **** #if 1
 927              		.loc 1 5142 0
 928 0884 B890D3E1 		ldrh	r9, [r3, #8]
 929              	.LVL102:
 930              		.loc 1 5144 0
 931 0888 03005CE3 		cmp	ip, #3
 932 088c 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 933 0890 340000EA 		b	.L149
 934              	.L155:
 935 0894 04090000 		.word	.L144
 936 0898 F4080000 		.word	.L146
 937 089c A4080000 		.word	.L148
 938 08a0 A4080000 		.word	.L148
 939              	.L148:
5145:../uvc.c      **** 						case 0x20:
5146:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
5147:../uvc.c      **** 							delaytime = 500;
5148:../uvc.c      **** 							break;
5149:../uvc.c      **** 						case 0x21:
5150:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
5151:../uvc.c      **** 							delaytime = 500;
5152:../uvc.c      **** 							break;
5153:../uvc.c      **** 						case 0x22:
5154:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
5155:../uvc.c      **** 							delaytime = 300;
5156:../uvc.c      **** 							break;
5157:../uvc.c      **** 						case 0x23:
5158:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 940              		.loc 1 5158 0
 941 08a4 8230A0E3 		mov	r3, #130
 942              	.LVL103:
 943 08a8 FEFFFFEB 		bl	SensorSetIrisControl
 944              	.LVL104:
5159:../uvc.c      **** 							delaytime = 300;
5160:../uvc.c      **** 							break;
 945              		.loc 1 5160 0
 946 08ac 4B1FA0E3 		mov	r1, #300
 947              	.LVL105:
 948              	.L145:
5161:../uvc.c      **** 						default:
5162:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
5163:../uvc.c      **** 							break;
5164:../uvc.c      **** 					}
5165:../uvc.c      **** #endif
5166:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
5167:../uvc.c      **** 					/** timer's ticket modify **/
5168:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
5169:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 949              		.loc 1 5169 0
 950 08b0 0020A0E3 		mov	r2, #0
 951 08b4 B8009FE5 		ldr	r0, .L161
 952 08b8 FEFFFFEB 		bl	_txe_timer_change
 953              	.LVL106:
5170:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 954              		.loc 1 5170 0
 955 08bc B0009FE5 		ldr	r0, .L161
 956 08c0 FEFFFFEB 		bl	_txe_timer_activate
 957              	.LVL107:
5171:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
5172:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
5173:../uvc.c      **** #ifdef USB_DEBUG_PRINT
5174:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
5175:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
5176:../uvc.c      **** #endif
5177:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 958              		.loc 1 5177 0
 959 08c4 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 960 08c8 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 961 08cc 030052E1 		cmp	r2, r3
 962 08d0 1600000A 		beq	.L160
5178:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
5179:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
5180:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
5181:../uvc.c      **** 						}else{
5182:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
5183:../uvc.c      **** 						}
5184:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
5185:../uvc.c      **** 					}else{
5186:../uvc.c      **** 						lcCmdDes->curNum ++;
 963              		.loc 1 5186 0
 964 08d4 013083E2 		add	r3, r3, #1
5187:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 965              		.loc 1 5187 0
 966 08d8 0F20A0E3 		mov	r2, #15
5186:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 967              		.loc 1 5186 0
 968 08dc 0130C4E5 		strb	r3, [r4, #1]
 969              		.loc 1 5187 0
 970 08e0 3C2084E5 		str	r2, [r4, #60]
 971              	.LVL108:
 972              	.L153:
5188:../uvc.c      **** 					}
5189:../uvc.c      **** 				}else{
5190:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
5191:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
5192:../uvc.c      **** 				}
5193:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 973              		.loc 1 5193 0
 974 08e4 1C0095E5 		ldr	r0, [r5, #28]
 975 08e8 FEFFFFEB 		bl	_txe_mutex_put
 976              	.LVL109:
5194:../uvc.c      **** 			}
5195:../uvc.c      **** /*
5196:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
5197:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
5198:../uvc.c      **** */
5199:../uvc.c      **** #ifdef USB_DEBUG_PRINT
5200:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
5201:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
5202:../uvc.c      **** #endif
5203:../uvc.c      **** 
5204:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
5205:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
5206:../uvc.c      **** #if 0
5207:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
5208:../uvc.c      **** 
5209:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
5210:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
5211:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
5212:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
5213:../uvc.c      **** 			    i = 0;
5214:../uvc.c      **** 				 switch(cmdCopyIdx)
5215:../uvc.c      **** 				 {
5216:../uvc.c      **** 					 case BrgtCtlID1:
5217:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
5218:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5219:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
5220:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5221:../uvc.c      **** 							 i++;
5222:../uvc.c      **** 						 }
5223:../uvc.c      **** 						 else{
5224:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5225:../uvc.c      **** 						 }
5226:../uvc.c      **** 
5227:../uvc.c      **** 						 CyU3PBusyWait(500);
5228:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
5229:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
5230:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5231:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
5232:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5233:../uvc.c      **** 						 }
5234:../uvc.c      **** 						 else{
5235:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5236:../uvc.c      **** 						 }
5237:../uvc.c      **** 						 break;
5238:../uvc.c      **** 					 case HueCtlID5:
5239:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
5240:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5241:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
5242:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5243:../uvc.c      **** 						 }
5244:../uvc.c      **** 						 else{
5245:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5246:../uvc.c      **** 						 }
5247:../uvc.c      **** 						 break;
5248:../uvc.c      **** 					 case SaturCtlID6:
5249:../uvc.c      **** 					 case WBTLevCtlID10:
5250:../uvc.c      **** 					 default:
5251:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
5252:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5253:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
5254:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5255:../uvc.c      **** 						 }
5256:../uvc.c      **** 						 else{
5257:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5258:../uvc.c      **** 						 }
5259:../uvc.c      **** 						 break;
5260:../uvc.c      **** 				 }
5261:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
5262:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
5263:../uvc.c      **** 			}
5264:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
5265:../uvc.c      **** #endif
5266:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
5267:../uvc.c      **** 		/* Allow other ready threads to run. */
5268:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
5269:../uvc.c      **** 			CyU3PThreadRelinquish ();
 977              		.loc 1 5269 0
 978 08ec FEFFFFEB 		bl	_txe_thread_relinquish
 979              	.LVL110:
5270:../uvc.c      **** 		}
 980              		.loc 1 5270 0
 981 08f0 B7FFFFEA 		b	.L154
 982              	.LVL111:
 983              	.L146:
5150:../uvc.c      **** 							delaytime = 500;
 984              		.loc 1 5150 0
 985 08f4 5230A0E3 		mov	r3, #82
 986              	.LVL112:
 987 08f8 FEFFFFEB 		bl	SensorSetIrisControl
 988              	.LVL113:
5152:../uvc.c      **** 						case 0x22:
 989              		.loc 1 5152 0
 990 08fc 7D1FA0E3 		mov	r1, #500
 991 0900 EAFFFFEA 		b	.L145
 992              	.LVL114:
 993              	.L144:
5146:../uvc.c      **** 							delaytime = 500;
 994              		.loc 1 5146 0
 995 0904 8230A0E3 		mov	r3, #130
 996              	.LVL115:
 997 0908 FEFFFFEB 		bl	SensorSetIrisControl
 998              	.LVL116:
5148:../uvc.c      **** 						case 0x21:
 999              		.loc 1 5148 0
 1000 090c 7D1FA0E3 		mov	r1, #500
 1001 0910 E6FFFFEA 		b	.L145
 1002              	.LVL117:
 1003              	.L159:
5190:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 1004              		.loc 1 5190 0
 1005 0914 FA1FA0E3 		mov	r1, #1000
 1006 0918 54009FE5 		ldr	r0, .L161
 1007 091c 104085E5 		str	r4, [r5, #16]
 1008 0920 FEFFFFEB 		bl	_txe_timer_change
 1009              	.LVL118:
5191:../uvc.c      **** 				}
 1010              		.loc 1 5191 0
 1011 0924 48009FE5 		ldr	r0, .L161
 1012 0928 FEFFFFEB 		bl	_txe_timer_activate
 1013              	.LVL119:
 1014 092c ECFFFFEA 		b	.L153
 1015              	.LVL120:
 1016              	.L160:
5179:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 1017              		.loc 1 5179 0
 1018 0930 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
5178:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 1019              		.loc 1 5178 0
 1020 0934 0020A0E3 		mov	r2, #0
5179:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 1021              		.loc 1 5179 0
 1022 0938 230053E3 		cmp	r3, #35
5180:../uvc.c      **** 						}else{
 1023              		.loc 1 5180 0
 1024 093c 24304382 		subhi	r3, r3, #36
 1025 0940 83308380 		addhi	r3, r3, r3, asl #1
5182:../uvc.c      **** 						}
 1026              		.loc 1 5182 0
 1027 0944 83308390 		addls	r3, r3, r3, asl #1
5180:../uvc.c      **** 						}else{
 1028              		.loc 1 5180 0
 1029 0948 83318880 		addhi	r3, r8, r3, asl #3
5182:../uvc.c      **** 						}
 1030              		.loc 1 5182 0
 1031 094c 83318890 		addls	r3, r8, r3, asl #3
5180:../uvc.c      **** 						}else{
 1032              		.loc 1 5180 0
 1033 0950 7C20C385 		strhib	r2, [r3, #124]
5182:../uvc.c      **** 						}
 1034              		.loc 1 5182 0
 1035 0954 FC21C395 		strlsb	r2, [r3, #508]
5184:../uvc.c      **** 					}else{
 1036              		.loc 1 5184 0
 1037 0958 343094E5 		ldr	r3, [r4, #52]
5178:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 1038              		.loc 1 5178 0
 1039 095c 3C2084E5 		str	r2, [r4, #60]
5184:../uvc.c      **** 					}else{
 1040              		.loc 1 5184 0
 1041 0960 103085E5 		str	r3, [r5, #16]
 1042 0964 DEFFFFEA 		b	.L153
 1043              	.LVL121:
 1044              	.L149:
5162:../uvc.c      **** 							break;
 1045              		.loc 1 5162 0
 1046 0968 FEFFFFEB 		bl	SensorSetControl
 1047              	.LVL122:
 1048 096c 0910A0E1 		mov	r1, r9
5163:../uvc.c      **** 					}
 1049              		.loc 1 5163 0
 1050 0970 CEFFFFEA 		b	.L145
 1051              	.L162:
 1052              		.align	2
 1053              	.L161:
 1054 0974 00000000 		.word	I2CCmdTimer
 1055 0978 00000000 		.word	I2CCmdCb
 1056 097c 00000000 		.word	cmdQu
 1057 0980 A4010000 		.word	.LC11
 1058 0984 B8010000 		.word	.LC12
 1059 0988 00000000 		.word	statQu
 1060 098c 00000000 		.word	.LANCHOR1
 1061 0990 00000000 		.word	.LANCHOR0
 1062              		.cfi_endproc
 1063              	.LFE26:
 1065              		.align	2
 1066              		.global	CyFxUvcApplnDmaCallback
 1068              	CyFxUvcApplnDmaCallback:
 1069              	.LFB11:
2848:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 1070              		.loc 1 2848 0
 1071              		.cfi_startproc
 1072              		@ args = 0, pretend = 0, frame = 0
 1073              		@ frame_needed = 0, uses_anonymous_args = 0
 1074              	.LVL123:
2855:../uvc.c      ****     {
 1075              		.loc 1 2855 0
 1076 0994 080051E3 		cmp	r1, #8
2848:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 1077              		.loc 1 2848 0
 1078 0998 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1079              	.LCFI5:
 1080              		.cfi_def_cfa_offset 16
 1081              		.cfi_offset 4, -16
 1082              		.cfi_offset 5, -12
 1083              		.cfi_offset 6, -8
 1084              		.cfi_offset 14, -4
 1085 099c 0250A0E1 		mov	r5, r2
 1086 09a0 08D04DE2 		sub	sp, sp, #8
 1087              	.LCFI6:
 1088              		.cfi_def_cfa_offset 24
2855:../uvc.c      ****     {
 1089              		.loc 1 2855 0
 1090 09a4 0B00000A 		beq	.L174
2907:../uvc.c      ****     {
 1091              		.loc 1 2907 0
 1092 09a8 100051E3 		cmp	r1, #16
 1093 09ac 0700001A 		bne	.L163
2909:../uvc.c      ****         streamingStarted = CyTrue;
 1094              		.loc 1 2909 0
 1095 09b0 6C319FE5 		ldr	r3, .L177
2910:../uvc.c      ****     }
 1096              		.loc 1 2910 0
 1097 09b4 0110A0E3 		mov	r1, #1
 1098              	.LVL124:
2909:../uvc.c      ****         streamingStarted = CyTrue;
 1099              		.loc 1 2909 0
 1100 09b8 B228D3E1 		ldrh	r2, [r3, #130]
 1101              	.LVL125:
2910:../uvc.c      ****     }
 1102              		.loc 1 2910 0
 1103 09bc 841083E5 		str	r1, [r3, #132]
2909:../uvc.c      ****         streamingStarted = CyTrue;
 1104              		.loc 1 2909 0
 1105 09c0 012082E0 		add	r2, r2, r1
 1106 09c4 0228A0E1 		mov	r2, r2, asl #16
 1107 09c8 2228A0E1 		mov	r2, r2, lsr #16
 1108 09cc B228C3E1 		strh	r2, [r3, #130]	@ movhi
 1109              	.LVL126:
 1110              	.L163:
2912:../uvc.c      **** 
 1111              		.loc 1 2912 0
 1112 09d0 08D08DE2 		add	sp, sp, #8
 1113              		@ sp needed
 1114 09d4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1115              	.LVL127:
 1116              	.L174:
2857:../uvc.c      ****             {
 1117              		.loc 1 2857 0
 1118 09d8 48319FE5 		ldr	r3, .L177+4
 1119 09dc B420D2E1 		ldrh	r2, [r2, #4]
 1120              	.LVL128:
2871:../uvc.c      ****                 fb++;
 1121              		.loc 1 2871 0
 1122 09e0 006095E5 		ldr	r6, [r5]
2857:../uvc.c      ****             {
 1123              		.loc 1 2857 0
 1124 09e4 030052E1 		cmp	r2, r3
 1125              	.LBB6:
 1126              	.LBB7:
2595:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1127              		.loc 1 2595 0
 1128 09e8 3C019FE5 		ldr	r0, .L177+8
 1129              	.LVL129:
 1130              	.LBE7:
 1131              	.LBE6:
2857:../uvc.c      ****             {
 1132              		.loc 1 2857 0
 1133 09ec 3100000A 		beq	.L175
 1134              	.LBB11:
 1135              	.LBB12:
2595:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1136              		.loc 1 2595 0
 1137 09f0 0010E0E3 		mvn	r1, #0
 1138              	.LVL130:
 1139 09f4 FEFFFFEB 		bl	_txe_mutex_get
 1140              	.LVL131:
2596:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1141              		.loc 1 2596 0
 1142 09f8 0C0046E2 		sub	r0, r6, #12
 1143 09fc 2C119FE5 		ldr	r1, .L177+12
 1144 0a00 0C20A0E3 		mov	r2, #12
 1145 0a04 FEFFFFEB 		bl	CyU3PMemCopy
 1146              	.LVL132:
2597:../uvc.c      **** 
 1147              		.loc 1 2597 0
 1148 0a08 1C019FE5 		ldr	r0, .L177+8
 1149 0a0c FEFFFFEB 		bl	_txe_mutex_put
 1150              	.LVL133:
2602:../uvc.c      ****     }
 1151              		.loc 1 2602 0
 1152 0a10 0B3056E5 		ldrb	r3, [r6, #-11]	@ zero_extendqisi2
 1153              	.LBE12:
 1154              	.LBE11:
2878:../uvc.c      ****                 pbc = input->buffer_p.count;
 1155              		.loc 1 2878 0
 1156 0a14 08419FE5 		ldr	r4, .L177
 1157              	.LBB15:
 1158              	.LBB13:
2602:../uvc.c      ****     }
 1159              		.loc 1 2602 0
 1160 0a18 023083E3 		orr	r3, r3, #2
 1161 0a1c 0B3046E5 		strb	r3, [r6, #-11]
 1162              	.LBE13:
 1163              	.LBE15:
2884:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1164              		.loc 1 2884 0
 1165 0a20 7210D4E5 		ldrb	r1, [r4, #114]	@ zero_extendqisi2
2878:../uvc.c      ****                 pbc = input->buffer_p.count;
 1166              		.loc 1 2878 0
 1167 0a24 B627D4E1 		ldrh	r2, [r4, #118]
2879:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
 1168              		.loc 1 2879 0
 1169 0a28 B430D5E1 		ldrh	r3, [r5, #4]
2878:../uvc.c      ****                 pbc = input->buffer_p.count;
 1170              		.loc 1 2878 0
 1171 0a2c 012082E2 		add	r2, r2, #1
2884:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1172              		.loc 1 2884 0
 1173 0a30 0F0051E3 		cmp	r1, #15
2878:../uvc.c      ****                 pbc = input->buffer_p.count;
 1174              		.loc 1 2878 0
 1175 0a34 B627C4E1 		strh	r2, [r4, #118]	@ movhi
2879:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
 1176              		.loc 1 2879 0
 1177 0a38 B837C4E1 		strh	r3, [r4, #120]	@ movhi
 1178              	.LBB16:
 1179              	.LBB14:
2596:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1180              		.loc 1 2596 0
 1181 0a3c F0609FE5 		ldr	r6, .L177+16
 1182              	.LBE14:
 1183              	.LBE16:
2884:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1184              		.loc 1 2884 0
 1185 0a40 2B00000A 		beq	.L176
 1186              	.L167:
2891:../uvc.c      ****             }
 1187              		.loc 1 2891 0
 1188 0a44 0120A0E3 		mov	r2, #1
 1189 0a48 7C2084E5 		str	r2, [r4, #124]
 1190              	.L166:
2895:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1191              		.loc 1 2895 0
 1192 0a4c B028D4E1 		ldrh	r2, [r4, #128]
2896:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1193              		.loc 1 2896 0
 1194 0a50 0C1083E2 		add	r1, r3, #12
2895:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1195              		.loc 1 2895 0
 1196 0a54 013082E2 		add	r3, r2, #1
2896:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1197              		.loc 1 2896 0
 1198 0a58 0118A0E1 		mov	r1, r1, asl #16
2895:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1199              		.loc 1 2895 0
 1200 0a5c 0338A0E1 		mov	r3, r3, asl #16
2896:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1201              		.loc 1 2896 0
 1202 0a60 2118A0E1 		mov	r1, r1, lsr #16
2895:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1203              		.loc 1 2895 0
 1204 0a64 2338A0E1 		mov	r3, r3, lsr #16
2896:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1205              		.loc 1 2896 0
 1206 0a68 0020A0E3 		mov	r2, #0
 1207 0a6c C4009FE5 		ldr	r0, .L177+20
2895:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1208              		.loc 1 2895 0
 1209 0a70 B038C4E1 		strh	r3, [r4, #128]	@ movhi
2896:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1210              		.loc 1 2896 0
 1211 0a74 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 1212              	.LVL134:
2895:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1213              		.loc 1 2895 0
 1214 0a78 A4109FE5 		ldr	r1, .L177
2899:../uvc.c      ****             {
 1215              		.loc 1 2899 0
 1216 0a7c 002050E2 		subs	r2, r0, #0
 1217 0a80 D2FFFF0A 		beq	.L163
2901:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 1218              		.loc 1 2901 0
 1219 0a84 B008D1E1 		ldrh	r0, [r1, #128]
 1220              	.LVL135:
2902:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
 1221              		.loc 1 2902 0
 1222 0a88 B430D5E1 		ldrh	r3, [r5, #4]
2901:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 1223              		.loc 1 2901 0
 1224 0a8c 010040E2 		sub	r0, r0, #1
 1225 0a90 0008A0E1 		mov	r0, r0, asl #16
 1226 0a94 2008A0E1 		mov	r0, r0, lsr #16
 1227 0a98 B008C1E1 		strh	r0, [r1, #128]	@ movhi
2902:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
 1228              		.loc 1 2902 0
 1229 0a9c B008D1E1 		ldrh	r0, [r1, #128]
 1230 0aa0 B218D1E1 		ldrh	r1, [r1, #130]
 1231 0aa4 03008DE8 		stmia	sp, {r0, r1}
 1232 0aa8 8C109FE5 		ldr	r1, .L177+24
 1233 0aac 0400A0E3 		mov	r0, #4
 1234 0ab0 FEFFFFEB 		bl	CyU3PDebugPrint
 1235              	.LVL136:
 1236 0ab4 C5FFFFEA 		b	.L163
 1237              	.LVL137:
 1238              	.L175:
 1239              	.LBB17:
 1240              	.LBB8:
2595:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1241              		.loc 1 2595 0
 1242 0ab8 0010E0E3 		mvn	r1, #0
 1243              	.LVL138:
 1244              	.LBE8:
 1245              	.LBE17:
2872:../uvc.c      ****             }
 1246              		.loc 1 2872 0
 1247 0abc 60409FE5 		ldr	r4, .L177
 1248              	.LBB18:
 1249              	.LBB9:
2595:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1250              		.loc 1 2595 0
 1251 0ac0 FEFFFFEB 		bl	_txe_mutex_get
 1252              	.LVL139:
 1253              	.LBE9:
 1254              	.LBE18:
2871:../uvc.c      ****                 fb++;
 1255              		.loc 1 2871 0
 1256 0ac4 0C6046E2 		sub	r6, r6, #12
 1257              	.LVL140:
 1258              	.LBB19:
 1259              	.LBB10:
2596:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1260              		.loc 1 2596 0
 1261 0ac8 0C20A0E3 		mov	r2, #12
 1262 0acc 0600A0E1 		mov	r0, r6
 1263 0ad0 58109FE5 		ldr	r1, .L177+12
 1264 0ad4 FEFFFFEB 		bl	CyU3PMemCopy
 1265              	.LVL141:
2597:../uvc.c      **** 
 1266              		.loc 1 2597 0
 1267 0ad8 4C009FE5 		ldr	r0, .L177+8
 1268 0adc FEFFFFEB 		bl	_txe_mutex_put
 1269              	.LVL142:
 1270              	.LBE10:
 1271              	.LBE19:
2872:../uvc.c      ****             }
 1272              		.loc 1 2872 0
 1273 0ae0 B427D4E1 		ldrh	r2, [r4, #116]
 1274 0ae4 B430D5E1 		ldrh	r3, [r5, #4]
 1275 0ae8 012082E2 		add	r2, r2, #1
 1276 0aec B427C4E1 		strh	r2, [r4, #116]	@ movhi
 1277 0af0 D5FFFFEA 		b	.L166
 1278              	.LVL143:
 1279              	.L176:
2885:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 1280              		.loc 1 2885 0
 1281 0af4 0010E0E3 		mvn	r1, #0
 1282 0af8 2C009FE5 		ldr	r0, .L177+8
 1283 0afc FEFFFFEB 		bl	_txe_mutex_get
 1284              	.LVL144:
2886:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 1285              		.loc 1 2886 0
 1286 0b00 ED34D6E5 		ldrb	r3, [r6, #1261]	@ zero_extendqisi2
2887:../uvc.c      ****                 	stiflag = 0xAA;
 1287              		.loc 1 2887 0
 1288 0b04 20009FE5 		ldr	r0, .L177+8
2886:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 1289              		.loc 1 2886 0
 1290 0b08 DF3003E2 		and	r3, r3, #223
 1291 0b0c ED34C6E5 		strb	r3, [r6, #1261]
2887:../uvc.c      ****                 	stiflag = 0xAA;
 1292              		.loc 1 2887 0
 1293 0b10 FEFFFFEB 		bl	_txe_mutex_put
 1294              	.LVL145:
2888:../uvc.c      ****                 }
 1295              		.loc 1 2888 0
 1296 0b14 5530E0E3 		mvn	r3, #85
 1297 0b18 7230C4E5 		strb	r3, [r4, #114]
 1298 0b1c B430D5E1 		ldrh	r3, [r5, #4]
 1299 0b20 C7FFFFEA 		b	.L167
 1300              	.L178:
 1301              		.align	2
 1302              	.L177:
 1303 0b24 00000000 		.word	.LANCHOR0
 1304 0b28 F03F0000 		.word	16368
 1305 0b2c 00000000 		.word	imgHdMux
 1306 0b30 EC040000 		.word	.LANCHOR1+1260
 1307 0b34 00000000 		.word	.LANCHOR1
 1308 0b38 00000000 		.word	glChHandleUVCStream
 1309 0b3c DC010000 		.word	.LC13
 1310              		.cfi_endproc
 1311              	.LFE11:
 1313              		.align	2
 1315              	CyFxUVCApplnUSBEventCB:
 1316              	.LFB9:
2651:../uvc.c      ****     switch (evtype)
 1317              		.loc 1 2651 0
 1318              		.cfi_startproc
 1319              		@ args = 0, pretend = 0, frame = 8
 1320              		@ frame_needed = 0, uses_anonymous_args = 0
 1321              	.LVL146:
2652:../uvc.c      ****     {
 1322              		.loc 1 2652 0
 1323 0b40 020050E3 		cmp	r0, #2
2651:../uvc.c      ****     switch (evtype)
 1324              		.loc 1 2651 0
 1325 0b44 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1326              	.LCFI7:
 1327              		.cfi_def_cfa_offset 16
 1328              		.cfi_offset 4, -16
 1329              		.cfi_offset 5, -12
 1330              		.cfi_offset 6, -8
 1331              		.cfi_offset 14, -4
 1332 0b48 0040A0E1 		mov	r4, r0
 1333 0b4c 10D04DE2 		sub	sp, sp, #16
 1334              	.LCFI8:
 1335              		.cfi_def_cfa_offset 32
2652:../uvc.c      ****     {
 1336              		.loc 1 2652 0
 1337 0b50 3D00000A 		beq	.L181
 1338 0b54 040050E3 		cmp	r0, #4
 1339 0b58 2000000A 		beq	.L182
 1340 0b5c 010050E3 		cmp	r0, #1
 1341 0b60 0100000A 		beq	.L187
 1342              	.LVL147:
 1343              	.L179:
2688:../uvc.c      **** 
 1344              		.loc 1 2688 0
 1345 0b64 10D08DE2 		add	sp, sp, #16
 1346              		@ sp needed
 1347 0b68 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1348              	.LVL148:
 1349              	.L187:
 1350              	.LBB34:
 1351              	.LBB35:
2671:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1352              		.loc 1 2671 0
 1353 0b6c 0130A0E1 		mov	r3, r1
 1354 0b70 0420A0E1 		mov	r2, r4
2673:../uvc.c      ****             isUsbConnected = CyFalse;
 1355              		.loc 1 2673 0
 1356 0b74 40519FE5 		ldr	r5, .L188
2671:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1357              		.loc 1 2671 0
 1358 0b78 40119FE5 		ldr	r1, .L188+4
 1359              	.LVL149:
 1360 0b7c 0400A0E3 		mov	r0, #4
 1361              	.LVL150:
 1362 0b80 FEFFFFEB 		bl	CyU3PDebugPrint
 1363              	.LVL151:
2672:../uvc.c      ****             gpif_initialized = 0;
 1364              		.loc 1 2672 0
 1365 0b84 0400A0E1 		mov	r0, r4
 1366 0b88 FEFFFFEB 		bl	CyU3PGpifDisable
 1367              	.LVL152:
2673:../uvc.c      ****             isUsbConnected = CyFalse;
 1368              		.loc 1 2673 0
 1369 0b8c 00C0A0E3 		mov	ip, #0
 1370              	.LBB36:
 1371              	.LBB37:
2635:../uvc.c      **** 	{
 1372              		.loc 1 2635 0
 1373 0b90 00C08DE5 		str	ip, [sp]
 1374 0b94 0410A0E1 		mov	r1, r4
 1375 0b98 0500A0E1 		mov	r0, r5
 1376 0b9c 0220A0E3 		mov	r2, #2
 1377 0ba0 0C308DE2 		add	r3, sp, #12
 1378              	.LBE37:
 1379              	.LBE36:
2673:../uvc.c      ****             isUsbConnected = CyFalse;
 1380              		.loc 1 2673 0
 1381 0ba4 88C085E5 		str	ip, [r5, #136]
2674:../uvc.c      ****             streamingStarted = CyFalse;
 1382              		.loc 1 2674 0
 1383 0ba8 8CC085E5 		str	ip, [r5, #140]
2675:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1384              		.loc 1 2675 0
 1385 0bac 84C085E5 		str	ip, [r5, #132]
 1386              	.LBB41:
 1387              	.LBB40:
2635:../uvc.c      **** 	{
 1388              		.loc 1 2635 0
 1389 0bb0 FEFFFFEB 		bl	_txe_event_flags_get
 1390              	.LVL153:
 1391 0bb4 004050E2 		subs	r4, r0, #0
 1392 0bb8 E9FFFF1A 		bne	.L179
 1393              	.LBB38:
 1394              	.LBB39:
2638:../uvc.c      **** 
 1395              		.loc 1 2638 0
 1396 0bbc 0500A0E1 		mov	r0, r5
 1397 0bc0 0110E0E3 		mvn	r1, #1
 1398 0bc4 0220A0E3 		mov	r2, #2
 1399 0bc8 FEFFFFEB 		bl	_txe_event_flags_set
 1400              	.LVL154:
2641:../uvc.c      **** 	}
 1401              		.loc 1 2641 0
 1402 0bcc 0500A0E1 		mov	r0, r5
 1403 0bd0 0420A0E1 		mov	r2, r4
 1404 0bd4 0210A0E3 		mov	r1, #2
 1405 0bd8 FEFFFFEB 		bl	_txe_event_flags_set
 1406              	.LVL155:
 1407 0bdc E0FFFFEA 		b	.L179
 1408              	.LVL156:
 1409              	.L182:
 1410              	.LBE39:
 1411              	.LBE38:
 1412              	.LBE40:
 1413              	.LBE41:
 1414              	.LBE35:
 1415              	.LBE34:
2655:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1416              		.loc 1 2655 0
 1417 0be0 0130A0E1 		mov	r3, r1
 1418 0be4 0020A0E1 		mov	r2, r0
 1419 0be8 D4109FE5 		ldr	r1, .L188+8
 1420              	.LVL157:
 1421 0bec FEFFFFEB 		bl	CyU3PDebugPrint
 1422              	.LVL158:
2657:../uvc.c      ****             streamingStarted = CyFalse;
 1423              		.loc 1 2657 0
 1424 0bf0 C4409FE5 		ldr	r4, .L188
2656:../uvc.c      ****             gpif_initialized = 0;
 1425              		.loc 1 2656 0
 1426 0bf4 0100A0E3 		mov	r0, #1
 1427 0bf8 FEFFFFEB 		bl	CyU3PGpifDisable
 1428              	.LVL159:
2657:../uvc.c      ****             streamingStarted = CyFalse;
 1429              		.loc 1 2657 0
 1430 0bfc 00C0A0E3 		mov	ip, #0
 1431              	.LBB42:
 1432              	.LBB43:
2635:../uvc.c      **** 	{
 1433              		.loc 1 2635 0
 1434 0c00 00C08DE5 		str	ip, [sp]
 1435 0c04 0400A0E1 		mov	r0, r4
 1436 0c08 0110A0E3 		mov	r1, #1
 1437 0c0c 0220A0E3 		mov	r2, #2
 1438 0c10 0C308DE2 		add	r3, sp, #12
 1439              	.LBE43:
 1440              	.LBE42:
2657:../uvc.c      ****             streamingStarted = CyFalse;
 1441              		.loc 1 2657 0
 1442 0c14 88C084E5 		str	ip, [r4, #136]
2658:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1443              		.loc 1 2658 0
 1444 0c18 84C084E5 		str	ip, [r4, #132]
 1445              	.LBB47:
 1446              	.LBB46:
2635:../uvc.c      **** 	{
 1447              		.loc 1 2635 0
 1448 0c1c FEFFFFEB 		bl	_txe_event_flags_get
 1449              	.LVL160:
 1450 0c20 005050E2 		subs	r5, r0, #0
 1451 0c24 CEFFFF1A 		bne	.L179
 1452              	.LBB44:
 1453              	.LBB45:
2638:../uvc.c      **** 
 1454              		.loc 1 2638 0
 1455 0c28 0400A0E1 		mov	r0, r4
 1456 0c2c 0110E0E3 		mvn	r1, #1
 1457 0c30 0220A0E3 		mov	r2, #2
 1458 0c34 FEFFFFEB 		bl	_txe_event_flags_set
 1459              	.LVL161:
2641:../uvc.c      **** 	}
 1460              		.loc 1 2641 0
 1461 0c38 0400A0E1 		mov	r0, r4
 1462 0c3c 0520A0E1 		mov	r2, r5
 1463 0c40 0210A0E3 		mov	r1, #2
 1464 0c44 FEFFFFEB 		bl	_txe_event_flags_set
 1465              	.LVL162:
 1466 0c48 C5FFFFEA 		b	.L179
 1467              	.LVL163:
 1468              	.L181:
 1469              	.LBE45:
 1470              	.LBE44:
 1471              	.LBE46:
 1472              	.LBE47:
2663:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1473              		.loc 1 2663 0
 1474 0c4c 0130A0E1 		mov	r3, r1
 1475 0c50 0420A0E1 		mov	r2, r4
 1476 0c54 6C109FE5 		ldr	r1, .L188+12
 1477              	.LVL164:
2665:../uvc.c      ****             streamingStarted = CyFalse;
 1478              		.loc 1 2665 0
 1479 0c58 5C509FE5 		ldr	r5, .L188
2663:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1480              		.loc 1 2663 0
 1481 0c5c 0400A0E3 		mov	r0, #4
 1482              	.LVL165:
 1483 0c60 FEFFFFEB 		bl	CyU3PDebugPrint
 1484              	.LVL166:
2664:../uvc.c      ****             gpif_initialized = 0;
 1485              		.loc 1 2664 0
 1486 0c64 0100A0E3 		mov	r0, #1
 1487 0c68 FEFFFFEB 		bl	CyU3PGpifDisable
 1488              	.LVL167:
2665:../uvc.c      ****             streamingStarted = CyFalse;
 1489              		.loc 1 2665 0
 1490 0c6c 00C0A0E3 		mov	ip, #0
 1491              	.LBB48:
 1492              	.LBB49:
2635:../uvc.c      **** 	{
 1493              		.loc 1 2635 0
 1494 0c70 00C08DE5 		str	ip, [sp]
 1495 0c74 0500A0E1 		mov	r0, r5
 1496 0c78 0110A0E3 		mov	r1, #1
 1497 0c7c 0420A0E1 		mov	r2, r4
 1498 0c80 0C308DE2 		add	r3, sp, #12
 1499              	.LBE49:
 1500              	.LBE48:
2665:../uvc.c      ****             streamingStarted = CyFalse;
 1501              		.loc 1 2665 0
 1502 0c84 88C085E5 		str	ip, [r5, #136]
2666:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1503              		.loc 1 2666 0
 1504 0c88 84C085E5 		str	ip, [r5, #132]
 1505              	.LBB53:
 1506              	.LBB52:
2635:../uvc.c      **** 	{
 1507              		.loc 1 2635 0
 1508 0c8c FEFFFFEB 		bl	_txe_event_flags_get
 1509              	.LVL168:
 1510 0c90 006050E2 		subs	r6, r0, #0
 1511 0c94 B2FFFF1A 		bne	.L179
 1512              	.LBB50:
 1513              	.LBB51:
2638:../uvc.c      **** 
 1514              		.loc 1 2638 0
 1515 0c98 0420A0E1 		mov	r2, r4
 1516 0c9c 0500A0E1 		mov	r0, r5
 1517 0ca0 0110E0E3 		mvn	r1, #1
 1518 0ca4 FEFFFFEB 		bl	_txe_event_flags_set
 1519              	.LVL169:
2641:../uvc.c      **** 	}
 1520              		.loc 1 2641 0
 1521 0ca8 0500A0E1 		mov	r0, r5
 1522 0cac 0410A0E1 		mov	r1, r4
 1523 0cb0 0620A0E1 		mov	r2, r6
 1524 0cb4 FEFFFFEB 		bl	_txe_event_flags_set
 1525              	.LVL170:
 1526 0cb8 A9FFFFEA 		b	.L179
 1527              	.L189:
 1528              		.align	2
 1529              	.L188:
 1530 0cbc 00000000 		.word	.LANCHOR0
 1531 0cc0 6C020000 		.word	.LC16
 1532 0cc4 28020000 		.word	.LC14
 1533 0cc8 48020000 		.word	.LC15
 1534              	.LBE51:
 1535              	.LBE50:
 1536              	.LBE52:
 1537              	.LBE53:
 1538              		.cfi_endproc
 1539              	.LFE9:
 1541              		.align	2
 1543              	CyFxUVCApplnUSBSetupCB:
 1544              	.LFB10:
2696:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1545              		.loc 1 2696 0
 1546              		.cfi_startproc
 1547              		@ args = 0, pretend = 0, frame = 8
 1548              		@ frame_needed = 0, uses_anonymous_args = 0
 1549              	.LVL171:
 1550 0ccc F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
 1551              	.LCFI9:
 1552              		.cfi_def_cfa_offset 28
 1553              		.cfi_offset 4, -28
 1554              		.cfi_offset 5, -24
 1555              		.cfi_offset 6, -20
 1556              		.cfi_offset 7, -16
 1557              		.cfi_offset 8, -12
 1558              		.cfi_offset 9, -8
 1559              		.cfi_offset 14, -4
2705:../uvc.c      **** 
 1560              		.loc 1 2705 0
 1561 0cd0 B0C29FE5 		ldr	ip, .L224
2702:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1562              		.loc 1 2702 0
 1563 0cd4 B0929FE5 		ldr	r9, .L224+4
2704:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1564              		.loc 1 2704 0
 1565 0cd8 B0829FE5 		ldr	r8, .L224+8
2701:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1566              		.loc 1 2701 0
 1567 0cdc B0229FE5 		ldr	r2, .L224+12
2703:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1568              		.loc 1 2703 0
 1569 0ce0 B0329FE5 		ldr	r3, .L224+16
2704:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1570              		.loc 1 2704 0
 1571 0ce4 0168A0E1 		mov	r6, r1, asl #16
2701:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1572              		.loc 1 2701 0
 1573 0ce8 FF4000E2 		and	r4, r0, #255
2702:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1574              		.loc 1 2702 0
 1575 0cec FF5C00E2 		and	r5, r0, #65280
 1576 0cf0 2554A0E1 		mov	r5, r5, lsr #8
2704:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1577              		.loc 1 2704 0
 1578 0cf4 2668A0E1 		mov	r6, r6, lsr #16
2705:../uvc.c      **** 
 1579              		.loc 1 2705 0
 1580 0cf8 2118A0E1 		mov	r1, r1, lsr #16
 1581              	.LVL172:
2703:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1582              		.loc 1 2703 0
 1583 0cfc 2078A0E1 		mov	r7, r0, lsr #16
2708:../uvc.c      ****     {
 1584              		.loc 1 2708 0
 1585 0d00 020054E3 		cmp	r4, #2
2696:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1586              		.loc 1 2696 0
 1587 0d04 14D04DE2 		sub	sp, sp, #20
 1588              	.LCFI10:
 1589              		.cfi_def_cfa_offset 48
2702:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1590              		.loc 1 2702 0
 1591 0d08 0050C9E5 		strb	r5, [r9]
2704:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1592              		.loc 1 2704 0
 1593 0d0c B060C8E1 		strh	r6, [r8]	@ movhi
2705:../uvc.c      **** 
 1594              		.loc 1 2705 0
 1595 0d10 B010CCE1 		strh	r1, [ip]	@ movhi
2701:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1596              		.loc 1 2701 0
 1597 0d14 0040C2E5 		strb	r4, [r2]
2703:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1598              		.loc 1 2703 0
 1599 0d18 B070C3E1 		strh	r7, [r3]	@ movhi
2708:../uvc.c      ****     {
 1600              		.loc 1 2708 0
 1601 0d1c 4A00000A 		beq	.L192
 1602 0d20 0600009A 		bls	.L221
 1603 0d24 210054E3 		cmp	r4, #33
 1604 0d28 3900000A 		beq	.L195
 1605 0d2c A10054E3 		cmp	r4, #161
 1606 0d30 3700000A 		beq	.L195
 1607              	.L209:
2697:../uvc.c      ****     uint32_t status;
 1608              		.loc 1 2697 0
 1609 0d34 0000A0E3 		mov	r0, #0
 1610              	.LVL173:
 1611              	.L191:
2835:../uvc.c      **** 
 1612              		.loc 1 2835 0
 1613 0d38 14D08DE2 		add	sp, sp, #20
 1614              		@ sp needed
 1615 0d3c F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1616              	.LVL174:
 1617              	.L221:
2708:../uvc.c      ****     {
 1618              		.loc 1 2708 0
 1619 0d40 010054E3 		cmp	r4, #1
 1620 0d44 FAFFFF1A 		bne	.L209
2748:../uvc.c      ****             {
 1621              		.loc 1 2748 0
 1622 0d48 0B0055E3 		cmp	r5, #11
 1623 0d4c F8FFFF1A 		bne	.L209
2752:../uvc.c      ****                 {
 1624              		.loc 1 2752 0
 1625 0d50 010056E3 		cmp	r6, #1
 1626 0d54 F6FFFF1A 		bne	.L209
2752:../uvc.c      ****                 {
 1627              		.loc 1 2752 0 is_stmt 0 discriminator 1
 1628 0d58 000057E3 		cmp	r7, #0
 1629 0d5c F4FFFF1A 		bne	.L209
2757:../uvc.c      ****                     streamingStarted = CyFalse;
 1630              		.loc 1 2757 0 is_stmt 1
 1631 0d60 34429FE5 		ldr	r4, .L224+20
2755:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 1632              		.loc 1 2755 0
 1633 0d64 34129FE5 		ldr	r1, .L224+24
 1634 0d68 0400A0E3 		mov	r0, #4
 1635              	.LVL175:
 1636 0d6c FEFFFFEB 		bl	CyU3PDebugPrint
 1637              	.LVL176:
2756:../uvc.c      ****                     gpif_initialized = 0;
 1638              		.loc 1 2756 0
 1639 0d70 0600A0E1 		mov	r0, r6
 1640 0d74 FEFFFFEB 		bl	CyU3PGpifDisable
 1641              	.LVL177:
2760:../uvc.c      ****                     CyU3PBusyWait (100);
 1642              		.loc 1 2760 0
 1643 0d78 0610A0E1 		mov	r1, r6
 1644 0d7c 8300A0E3 		mov	r0, #131
2757:../uvc.c      ****                     streamingStarted = CyFalse;
 1645              		.loc 1 2757 0
 1646 0d80 887084E5 		str	r7, [r4, #136]
2758:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
 1647              		.loc 1 2758 0
 1648 0d84 847084E5 		str	r7, [r4, #132]
2760:../uvc.c      ****                     CyU3PBusyWait (100);
 1649              		.loc 1 2760 0
 1650 0d88 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1651              	.LVL178:
2761:../uvc.c      **** 
 1652              		.loc 1 2761 0
 1653 0d8c 6400A0E3 		mov	r0, #100
 1654 0d90 FEFFFFEB 		bl	CyFx3BusyWait
 1655              	.LVL179:
2764:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1656              		.loc 1 2764 0
 1657 0d94 08029FE5 		ldr	r0, .L224+28
 1658 0d98 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1659              	.LVL180:
2765:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1660              		.loc 1 2765 0
 1661 0d9c 8300A0E3 		mov	r0, #131
 1662 0da0 FEFFFFEB 		bl	CyU3PUsbFlushEp
 1663              	.LVL181:
2766:../uvc.c      ****                     CyU3PBusyWait (100);
 1664              		.loc 1 2766 0
 1665 0da4 0710A0E1 		mov	r1, r7
 1666 0da8 8300A0E3 		mov	r0, #131
 1667 0dac FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1668              	.LVL182:
2767:../uvc.c      **** 
 1669              		.loc 1 2767 0
 1670 0db0 6400A0E3 		mov	r0, #100
 1671 0db4 FEFFFFEB 		bl	CyFx3BusyWait
 1672              	.LVL183:
2770:../uvc.c      ****                     uvcHandleReq = CyTrue;
 1673              		.loc 1 2770 0
 1674 0db8 0710A0E1 		mov	r1, r7
 1675 0dbc 0620A0E1 		mov	r2, r6
 1676 0dc0 8300A0E3 		mov	r0, #131
 1677 0dc4 FEFFFFEB 		bl	CyU3PUsbStall
 1678              	.LVL184:
2773:../uvc.c      ****                     /* Indicate stop streaming to main thread */
 1679              		.loc 1 2773 0
 1680 0dc8 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1681              	.LVL185:
 1682              	.LBB62:
 1683              	.LBB63:
2635:../uvc.c      **** 	{
 1684              		.loc 1 2635 0
 1685 0dcc 00708DE5 		str	r7, [sp]
 1686 0dd0 0610A0E1 		mov	r1, r6
 1687 0dd4 0400A0E1 		mov	r0, r4
 1688 0dd8 0220A0E3 		mov	r2, #2
 1689 0ddc 0C308DE2 		add	r3, sp, #12
 1690              	.LBE63:
 1691              	.LBE62:
2775:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
 1692              		.loc 1 2775 0
 1693 0de0 906084E5 		str	r6, [r4, #144]
 1694              	.LBB67:
 1695              	.LBB66:
2635:../uvc.c      **** 	{
 1696              		.loc 1 2635 0
 1697 0de4 FEFFFFEB 		bl	_txe_event_flags_get
 1698              	.LVL186:
 1699 0de8 005050E2 		subs	r5, r0, #0
 1700 0dec 1300001A 		bne	.L220
 1701              	.LBB64:
 1702              	.LBB65:
2638:../uvc.c      **** 
 1703              		.loc 1 2638 0
 1704 0df0 0400A0E1 		mov	r0, r4
 1705 0df4 0110E0E3 		mvn	r1, #1
 1706 0df8 0220A0E3 		mov	r2, #2
 1707 0dfc FEFFFFEB 		bl	_txe_event_flags_set
 1708              	.LVL187:
2641:../uvc.c      **** 	}
 1709              		.loc 1 2641 0
 1710 0e00 0400A0E1 		mov	r0, r4
 1711 0e04 0520A0E1 		mov	r2, r5
 1712 0e08 0210A0E3 		mov	r1, #2
 1713 0e0c FEFFFFEB 		bl	_txe_event_flags_set
 1714              	.LVL188:
 1715 0e10 0A0000EA 		b	.L220
 1716              	.LVL189:
 1717              	.L195:
 1718              	.LBE65:
 1719              	.LBE64:
 1720              	.LBE66:
 1721              	.LBE67:
2713:../uvc.c      ****             {
 1722              		.loc 1 2713 0
 1723 0e14 FF6006E2 		and	r6, r6, #255
 1724 0e18 000056E3 		cmp	r6, #0
 1725 0e1c 1500000A 		beq	.L196
 1726 0e20 010056E3 		cmp	r6, #1
 1727 0e24 C2FFFF1A 		bne	.L209
 1728              	.LVL190:
2731:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1729              		.loc 1 2731 0
 1730 0e28 0020A0E3 		mov	r2, #0
 1731 0e2c 68019FE5 		ldr	r0, .L224+20
 1732              	.LVL191:
 1733 0e30 0810A0E3 		mov	r1, #8
 1734 0e34 FEFFFFEB 		bl	_txe_event_flags_set
 1735              	.LVL192:
2733:../uvc.c      ****                         {
 1736              		.loc 1 2733 0
 1737 0e38 002050E2 		subs	r2, r0, #0
 1738 0e3c 1B00001A 		bne	.L222
 1739              	.LVL193:
 1740              	.L220:
2717:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 1741              		.loc 1 2717 0
 1742 0e40 0100A0E3 		mov	r0, #1
 1743              	.LVL194:
2835:../uvc.c      **** 
 1744              		.loc 1 2835 0
 1745 0e44 14D08DE2 		add	sp, sp, #20
 1746              		@ sp needed
 1747 0e48 F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1748              	.LVL195:
 1749              	.L192:
2783:../uvc.c      ****             {
 1750              		.loc 1 2783 0
 1751 0e4c 010055E3 		cmp	r5, #1
 1752 0e50 B7FFFF1A 		bne	.L209
2785:../uvc.c      ****                 {
 1753              		.loc 1 2785 0
 1754 0e54 830056E3 		cmp	r6, #131
 1755 0e58 B5FFFF1A 		bne	.L209
2791:../uvc.c      ****                     {
 1756              		.loc 1 2791 0
 1757 0e5c 38819FE5 		ldr	r8, .L224+20
 1758 0e60 847098E5 		ldr	r7, [r8, #132]
 1759 0e64 010057E3 		cmp	r7, #1
 1760 0e68 1900000A 		beq	.L223
 1761              	.LVL196:
2823:../uvc.c      ****                     }
 1762              		.loc 1 2823 0
 1763 0e6c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1764              	.LVL197:
2822:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1765              		.loc 1 2822 0
 1766 0e70 0500A0E1 		mov	r0, r5
 1767 0e74 AFFFFFEA 		b	.L191
 1768              	.LVL198:
 1769              	.L196:
2718:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1770              		.loc 1 2718 0
 1771 0e78 0620A0E1 		mov	r2, r6
 1772 0e7c 18019FE5 		ldr	r0, .L224+20
 1773              	.LVL199:
 1774 0e80 0410A0E3 		mov	r1, #4
 1775 0e84 FEFFFFEB 		bl	_txe_event_flags_set
 1776              	.LVL200:
2720:../uvc.c      ****                         {
 1777              		.loc 1 2720 0
 1778 0e88 002050E2 		subs	r2, r0, #0
 1779 0e8c EBFFFF0A 		beq	.L220
2722:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1780              		.loc 1 2722 0
 1781 0e90 10119FE5 		ldr	r1, .L224+32
 1782 0e94 0400A0E3 		mov	r0, #4
 1783              	.LVL201:
 1784 0e98 FEFFFFEB 		bl	CyU3PDebugPrint
 1785              	.LVL202:
2723:../uvc.c      ****                         }
 1786              		.loc 1 2723 0
 1787 0e9c 0600A0E1 		mov	r0, r6
 1788 0ea0 0620A0E1 		mov	r2, r6
 1789 0ea4 0110A0E3 		mov	r1, #1
 1790 0ea8 FEFFFFEB 		bl	CyU3PUsbStall
 1791              	.LVL203:
 1792 0eac E3FFFFEA 		b	.L220
 1793              	.LVL204:
 1794              	.L222:
2736:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1795              		.loc 1 2736 0
 1796 0eb0 F4109FE5 		ldr	r1, .L224+36
 1797 0eb4 0400A0E3 		mov	r0, #4
 1798              	.LVL205:
 1799 0eb8 FEFFFFEB 		bl	CyU3PDebugPrint
 1800              	.LVL206:
2737:../uvc.c      ****                         }
 1801              		.loc 1 2737 0
 1802 0ebc 0000A0E3 		mov	r0, #0
 1803 0ec0 0020A0E1 		mov	r2, r0
 1804 0ec4 0610A0E1 		mov	r1, r6
 1805 0ec8 FEFFFFEB 		bl	CyU3PUsbStall
 1806              	.LVL207:
2730:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 1807              		.loc 1 2730 0
 1808 0ecc 0600A0E1 		mov	r0, r6
 1809 0ed0 98FFFFEA 		b	.L191
 1810              	.LVL208:
 1811              	.L223:
2793:../uvc.c      **** 
 1812              		.loc 1 2793 0
 1813 0ed4 D4109FE5 		ldr	r1, .L224+40
 1814 0ed8 0400A0E3 		mov	r0, #4
 1815              	.LVL209:
 1816 0edc FEFFFFEB 		bl	CyU3PDebugPrint
 1817              	.LVL210:
2796:../uvc.c      ****                         gpif_initialized = 0;
 1818              		.loc 1 2796 0
 1819 0ee0 0700A0E1 		mov	r0, r7
 1820 0ee4 FEFFFFEB 		bl	CyU3PGpifDisable
 1821              	.LVL211:
2797:../uvc.c      ****                         streamingStarted = CyFalse;
 1822              		.loc 1 2797 0
 1823 0ee8 0050A0E3 		mov	r5, #0
2801:../uvc.c      ****                         CyU3PBusyWait (100);
 1824              		.loc 1 2801 0
 1825 0eec 0710A0E1 		mov	r1, r7
 1826 0ef0 0600A0E1 		mov	r0, r6
2797:../uvc.c      ****                         streamingStarted = CyFalse;
 1827              		.loc 1 2797 0
 1828 0ef4 885088E5 		str	r5, [r8, #136]
2798:../uvc.c      **** 
 1829              		.loc 1 2798 0
 1830 0ef8 845088E5 		str	r5, [r8, #132]
2801:../uvc.c      ****                         CyU3PBusyWait (100);
 1831              		.loc 1 2801 0
 1832 0efc FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1833              	.LVL212:
2802:../uvc.c      **** 
 1834              		.loc 1 2802 0
 1835 0f00 6400A0E3 		mov	r0, #100
 1836 0f04 FEFFFFEB 		bl	CyFx3BusyWait
 1837              	.LVL213:
2805:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1838              		.loc 1 2805 0
 1839 0f08 94009FE5 		ldr	r0, .L224+28
 1840 0f0c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1841              	.LVL214:
2806:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1842              		.loc 1 2806 0
 1843 0f10 0600A0E1 		mov	r0, r6
 1844 0f14 FEFFFFEB 		bl	CyU3PUsbFlushEp
 1845              	.LVL215:
2807:../uvc.c      ****                         CyU3PBusyWait (100);
 1846              		.loc 1 2807 0
 1847 0f18 0510A0E1 		mov	r1, r5
 1848 0f1c 0600A0E1 		mov	r0, r6
 1849 0f20 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1850              	.LVL216:
2808:../uvc.c      **** 
 1851              		.loc 1 2808 0
 1852 0f24 6400A0E3 		mov	r0, #100
 1853 0f28 FEFFFFEB 		bl	CyFx3BusyWait
 1854              	.LVL217:
2811:../uvc.c      **** 
 1855              		.loc 1 2811 0
 1856 0f2c 0510A0E1 		mov	r1, r5
 1857 0f30 0720A0E1 		mov	r2, r7
 1858 0f34 0600A0E1 		mov	r0, r6
 1859 0f38 FEFFFFEB 		bl	CyU3PUsbStall
 1860              	.LVL218:
2815:../uvc.c      ****                         /* Indicate stop streaming to main thread */
 1861              		.loc 1 2815 0
 1862 0f3c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1863              	.LVL219:
 1864              	.LBB68:
 1865              	.LBB69:
2635:../uvc.c      **** 	{
 1866              		.loc 1 2635 0
 1867 0f40 00508DE5 		str	r5, [sp]
 1868 0f44 0710A0E1 		mov	r1, r7
 1869 0f48 0800A0E1 		mov	r0, r8
 1870 0f4c 0420A0E1 		mov	r2, r4
 1871 0f50 0C308DE2 		add	r3, sp, #12
 1872              	.LBE69:
 1873              	.LBE68:
2817:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
 1874              		.loc 1 2817 0
 1875 0f54 907088E5 		str	r7, [r8, #144]
 1876              	.LBB73:
 1877              	.LBB72:
2635:../uvc.c      **** 	{
 1878              		.loc 1 2635 0
 1879 0f58 FEFFFFEB 		bl	_txe_event_flags_get
 1880              	.LVL220:
 1881 0f5c 005050E2 		subs	r5, r0, #0
 1882 0f60 B6FFFF1A 		bne	.L220
 1883              	.LBB70:
 1884              	.LBB71:
2638:../uvc.c      **** 
 1885              		.loc 1 2638 0
 1886 0f64 0420A0E1 		mov	r2, r4
 1887 0f68 0800A0E1 		mov	r0, r8
 1888 0f6c 0110E0E3 		mvn	r1, #1
 1889 0f70 FEFFFFEB 		bl	_txe_event_flags_set
 1890              	.LVL221:
2641:../uvc.c      **** 	}
 1891              		.loc 1 2641 0
 1892 0f74 0800A0E1 		mov	r0, r8
 1893 0f78 0410A0E1 		mov	r1, r4
 1894 0f7c 0520A0E1 		mov	r2, r5
 1895 0f80 FEFFFFEB 		bl	_txe_event_flags_set
 1896              	.LVL222:
 1897 0f84 ADFFFFEA 		b	.L220
 1898              	.L225:
 1899              		.align	2
 1900              	.L224:
 1901 0f88 00000000 		.word	wLength
 1902 0f8c 00000000 		.word	bRequest
 1903 0f90 00000000 		.word	wIndex
 1904 0f94 00000000 		.word	bmReqType
 1905 0f98 00000000 		.word	wValue
 1906 0f9c 00000000 		.word	.LANCHOR0
 1907 0fa0 F8020000 		.word	.LC19
 1908 0fa4 00000000 		.word	glChHandleUVCStream
 1909 0fa8 8C020000 		.word	.LC17
 1910 0fac C4020000 		.word	.LC18
 1911 0fb0 10030000 		.word	.LC20
 1912              	.LBE71:
 1913              	.LBE70:
 1914              	.LBE72:
 1915              	.LBE73:
 1916              		.cfi_endproc
 1917              	.LFE10:
 1919              		.align	2
 1920              		.global	I2CCmdHandler
 1922              	I2CCmdHandler:
 1923              	.LFB0:
1205:../uvc.c      **** 	uint8_t buf[2];
 1924              		.loc 1 1205 0
 1925              		.cfi_startproc
 1926              		@ args = 0, pretend = 0, frame = 8
 1927              		@ frame_needed = 0, uses_anonymous_args = 0
 1928 0fb4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1929              	.LCFI11:
 1930              		.cfi_def_cfa_offset 36
 1931              		.cfi_offset 4, -36
 1932              		.cfi_offset 5, -32
 1933              		.cfi_offset 6, -28
 1934              		.cfi_offset 7, -24
 1935              		.cfi_offset 8, -20
 1936              		.cfi_offset 9, -16
 1937              		.cfi_offset 10, -12
 1938              		.cfi_offset 11, -8
 1939              		.cfi_offset 14, -4
1208:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1940              		.loc 1 1208 0
 1941 0fb8 F8419FE5 		ldr	r4, .L248
1205:../uvc.c      **** 	uint8_t buf[2];
 1942              		.loc 1 1205 0
 1943 0fbc 34D04DE2 		sub	sp, sp, #52
 1944              	.LCFI12:
 1945              		.cfi_def_cfa_offset 88
1213:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1946              		.loc 1 1213 0
 1947 0fc0 9A30D4E5 		ldrb	r3, [r4, #154]	@ zero_extendqisi2
1208:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1948              		.loc 1 1208 0
 1949 0fc4 9450D4E5 		ldrb	r5, [r4, #148]	@ zero_extendqisi2
 1950              	.LVL223:
1209:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1951              		.loc 1 1209 0
 1952 0fc8 9570D4E5 		ldrb	r7, [r4, #149]	@ zero_extendqisi2
 1953              	.LVL224:
1210:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 1954              		.loc 1 1210 0
 1955 0fcc 9C60D4E5 		ldrb	r6, [r4, #156]	@ zero_extendqisi2
 1956              	.LVL225:
1213:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1957              		.loc 1 1213 0
 1958 0fd0 96B0D4E5 		ldrb	fp, [r4, #150]	@ zero_extendqisi2
 1959 0fd4 97A0D4E5 		ldrb	r10, [r4, #151]	@ zero_extendqisi2
 1960 0fd8 9890D4E5 		ldrb	r9, [r4, #152]	@ zero_extendqisi2
 1961 0fdc 9980D4E5 		ldrb	r8, [r4, #153]	@ zero_extendqisi2
 1962 0fe0 10308DE5 		str	r3, [sp, #16]
 1963 0fe4 9E10D4E5 		ldrb	r1, [r4, #158]	@ zero_extendqisi2
 1964 0fe8 9BE0D4E5 		ldrb	lr, [r4, #155]	@ zero_extendqisi2
 1965 0fec 9DC0D4E5 		ldrb	ip, [r4, #157]	@ zero_extendqisi2
 1966 0ff0 0730A0E1 		mov	r3, r7
 1967 0ff4 20108DE5 		str	r1, [sp, #32]
 1968 0ff8 0400A0E3 		mov	r0, #4
 1969 0ffc 0520A0E1 		mov	r2, r5
 1970 1000 18608DE5 		str	r6, [sp, #24]
 1971 1004 00B08DE5 		str	fp, [sp]
 1972 1008 04A08DE5 		str	r10, [sp, #4]
 1973 100c 08908DE5 		str	r9, [sp, #8]
 1974 1010 0C808DE5 		str	r8, [sp, #12]
 1975 1014 14E08DE5 		str	lr, [sp, #20]
 1976 1018 1CC08DE5 		str	ip, [sp, #28]
 1977 101c 98119FE5 		ldr	r1, .L248+4
 1978 1020 FEFFFFEB 		bl	CyU3PDebugPrint
 1979              	.LVL226:
1216:../uvc.c      **** 	{
 1980              		.loc 1 1216 0
 1981 1024 9730D4E5 		ldrb	r3, [r4, #151]	@ zero_extendqisi2
 1982 1028 520053E3 		cmp	r3, #82
 1983 102c 2D00000A 		beq	.L243
 1984              	.L227:
1226:../uvc.c      **** 	{
 1985              		.loc 1 1226 0
 1986 1030 000055E3 		cmp	r5, #0
 1987 1034 1600000A 		beq	.L244
1251:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 1988              		.loc 1 1251 0
 1989 1038 010055E3 		cmp	r5, #1
 1990 103c 0100000A 		beq	.L245
 1991              	.LVL227:
 1992              	.L226:
1270:../uvc.c      **** 
 1993              		.loc 1 1270 0
 1994 1040 34D08DE2 		add	sp, sp, #52
 1995              		@ sp needed
 1996 1044 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1997              	.LVL228:
 1998              	.L245:
1253:../uvc.c      **** 				for(i = 0; i<4; i++)
 1999              		.loc 1 1253 0
 2000 1048 020057E3 		cmp	r7, #2
 2001 104c 3800000A 		beq	.L246
1258:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2002              		.loc 1 1258 0
 2003 1050 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2004 1054 5C019FE5 		ldr	r0, .L248
 2005 1058 FE1001E2 		and	r1, r1, #254
 2006 105c 820051E3 		cmp	r1, #130
 2007 1060 0200001A 		bne	.L236
1258:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2008              		.loc 1 1258 0 is_stmt 0 discriminator 1
 2009 1064 9850D0E5 		ldrb	r5, [r0, #152]	@ zero_extendqisi2
 2010              	.LVL229:
 2011 1068 300055E3 		cmp	r5, #48
 2012 106c 3D00000A 		beq	.L247
 2013              	.L236:
 2014 1070 9820D4E5 		ldrb	r2, [r4, #152]	@ zero_extendqisi2
 2015 1074 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2016              	.LVL230:
 2017              	.L237:
1263:../uvc.c      **** 			}
 2018              		.loc 1 1263 0 is_stmt 1
 2019 1078 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2020 107c 9DC0D4E5 		ldrb	ip, [r4, #157]	@ zero_extendqisi2
 2021 1080 FE0000E2 		and	r0, r0, #254
 2022 1084 00C08DE5 		str	ip, [sp]
 2023 1088 FEFFFFEB 		bl	SensorWrite2B
 2024              	.LVL231:
1270:../uvc.c      **** 
 2025              		.loc 1 1270 0
 2026 108c 34D08DE2 		add	sp, sp, #52
 2027              		@ sp needed
 2028 1090 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2029              	.LVL232:
 2030              	.L244:
1242:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2031              		.loc 1 1242 0
 2032 1094 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2033 1098 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2034 109c 28C08DE2 		add	ip, sp, #40
 2035 10a0 9820D4E5 		ldrb	r2, [r4, #152]	@ zero_extendqisi2
 2036 10a4 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2037 10a8 00C08DE5 		str	ip, [sp]
1228:../uvc.c      **** #if 0 //for debugging
 2038              		.loc 1 1228 0
 2039 10ac 0FC0A0E3 		mov	ip, #15
1242:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2040              		.loc 1 1242 0
 2041 10b0 011081E3 		orr	r1, r1, #1
1228:../uvc.c      **** #if 0 //for debugging
 2042              		.loc 1 1228 0
 2043 10b4 9FC0C4E5 		strb	ip, [r4, #159]
1242:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2044              		.loc 1 1242 0
 2045 10b8 010080E3 		orr	r0, r0, #1
 2046 10bc FEFFFFEB 		bl	SensorRead2B
 2047              	.LVL233:
1243:../uvc.c      **** 				if(CmdDataLen == 2){
 2048              		.loc 1 1243 0
 2049 10c0 2830DDE5 		ldrb	r3, [sp, #40]	@ zero_extendqisi2
1244:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 2050              		.loc 1 1244 0
 2051 10c4 020056E3 		cmp	r6, #2
1243:../uvc.c      **** 				if(CmdDataLen == 2){
 2052              		.loc 1 1243 0
 2053 10c8 9D30C4E5 		strb	r3, [r4, #157]
1245:../uvc.c      **** 				}
 2054              		.loc 1 1245 0
 2055 10cc 2920DD05 		ldreqb	r2, [sp, #41]	@ zero_extendqisi2
1228:../uvc.c      **** #if 0 //for debugging
 2056              		.loc 1 1228 0
 2057 10d0 E0309FE5 		ldr	r3, .L248
1245:../uvc.c      **** 				}
 2058              		.loc 1 1245 0
 2059 10d4 9E20C305 		streqb	r2, [r3, #158]
1247:../uvc.c      **** 		}else{//not support currently
 2060              		.loc 1 1247 0
 2061 10d8 0030E0E3 		mvn	r3, #0
 2062 10dc 9F30C4E5 		strb	r3, [r4, #159]
1270:../uvc.c      **** 
 2063              		.loc 1 1270 0
 2064 10e0 34D08DE2 		add	sp, sp, #52
 2065              		@ sp needed
 2066 10e4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2067              	.LVL234:
 2068              	.L243:
1216:../uvc.c      **** 	{
 2069              		.loc 1 1216 0 discriminator 1
 2070 10e8 9830D4E5 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 2071 10ec 300053E3 		cmp	r3, #48
 2072 10f0 CEFFFF1A 		bne	.L227
 2073 10f4 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2074 10f8 010053E3 		cmp	r3, #1
 2075 10fc CBFFFF1A 		bne	.L227
1218:../uvc.c      **** 		if(is60Hz==CyFalse)
 2076              		.loc 1 1218 0
 2077 1100 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 2078 1104 B4309FE5 		ldr	r3, .L248+8
 2079 1108 031002E2 		and	r1, r2, #3
 2080 110c 5210C3E5 		strb	r1, [r3, #82]
1219:../uvc.c      **** 			{
 2081              		.loc 1 1219 0
 2082 1110 6C1094E5 		ldr	r1, [r4, #108]
1223:../uvc.c      **** 
 2083              		.loc 1 1223 0
 2084 1114 0400A0E3 		mov	r0, #4
1219:../uvc.c      **** 			{
 2085              		.loc 1 1219 0
 2086 1118 000051E3 		cmp	r1, #0
1221:../uvc.c      **** 			}
 2087              		.loc 1 1221 0
 2088 111c 80208203 		orreq	r2, r2, #128
1223:../uvc.c      **** 
 2089              		.loc 1 1223 0
 2090 1120 5230D3E5 		ldrb	r3, [r3, #82]	@ zero_extendqisi2
 2091 1124 98109FE5 		ldr	r1, .L248+12
1221:../uvc.c      **** 			}
 2092              		.loc 1 1221 0
 2093 1128 9D20C405 		streqb	r2, [r4, #157]
1223:../uvc.c      **** 
 2094              		.loc 1 1223 0
 2095 112c FEFFFFEB 		bl	CyU3PDebugPrint
 2096              	.LVL235:
 2097 1130 BEFFFFEA 		b	.L227
 2098              	.L246:
1253:../uvc.c      **** 				for(i = 0; i<4; i++)
 2099              		.loc 1 1253 0
 2100 1134 0450A0E3 		mov	r5, #4
 2101              	.LVL236:
 2102              	.L235:
1255:../uvc.c      **** 			}
 2103              		.loc 1 1255 0 discriminator 2
 2104 1138 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2105 113c 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 2106 1140 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2107 1144 9830D4E5 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 2108 1148 FE0000E2 		and	r0, r0, #254
 2109 114c 00208DE5 		str	r2, [sp]
 2110 1150 015045E2 		sub	r5, r5, #1
 2111 1154 0020A0E3 		mov	r2, #0
 2112 1158 FEFFFFEB 		bl	SensorWrite2B2
 2113              	.LVL237:
1254:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 2114              		.loc 1 1254 0 discriminator 2
 2115 115c FF5015E2 		ands	r5, r5, #255
 2116 1160 F4FFFF1A 		bne	.L235
 2117 1164 B5FFFFEA 		b	.L226
 2118              	.L247:
1258:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2119              		.loc 1 1258 0 discriminator 1
 2120 1168 9960D0E5 		ldrb	r6, [r0, #153]	@ zero_extendqisi2
 2121              	.LVL238:
 2122 116c 100056E3 		cmp	r6, #16
 2123 1170 0630A011 		movne	r3, r6
 2124 1174 0520A011 		movne	r2, r5
 2125 1178 BEFFFF1A 		bne	.L237
1259:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 2126              		.loc 1 1259 0
 2127 117c 44409FE5 		ldr	r4, .L248+16
 2128 1180 0010E0E3 		mvn	r1, #0
 2129 1184 1C0094E5 		ldr	r0, [r4, #28]
 2130 1188 FEFFFFEB 		bl	_txe_mutex_get
 2131              	.LVL239:
1260:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 2132              		.loc 1 1260 0
 2133 118c 0010A0E3 		mov	r1, #0
 2134 1190 00108DE5 		str	r1, [sp]
 2135 1194 04108DE5 		str	r1, [sp, #4]
 2136 1198 0620A0E1 		mov	r2, r6
 2137 119c 0530A0E1 		mov	r3, r5
 2138 11a0 0400A0E1 		mov	r0, r4
 2139 11a4 1710A0E3 		mov	r1, #23
 2140 11a8 FEFFFFEB 		bl	cmdSet
 2141              	.LVL240:
1261:../uvc.c      **** 				}
 2142              		.loc 1 1261 0
 2143 11ac 1C0094E5 		ldr	r0, [r4, #28]
 2144 11b0 FEFFFFEB 		bl	_txe_mutex_put
 2145              	.LVL241:
 2146 11b4 A1FFFFEA 		b	.L226
 2147              	.L249:
 2148              		.align	2
 2149              	.L248:
 2150 11b8 00000000 		.word	.LANCHOR0
 2151 11bc 34030000 		.word	.LC21
 2152 11c0 00000000 		.word	.LANCHOR1
 2153 11c4 80030000 		.word	.LC22
 2154 11c8 00000000 		.word	cmdQu
 2155              		.cfi_endproc
 2156              	.LFE0:
 2158              		.align	2
 2159              		.global	setIrisauto
 2161              	setIrisauto:
 2162              	.LFB1:
1276:../uvc.c      **** 	uint8_t dataIdx = 0;
 2163              		.loc 1 1276 0
 2164              		.cfi_startproc
 2165              		@ args = 0, pretend = 0, frame = 0
 2166              		@ frame_needed = 0, uses_anonymous_args = 0
 2167              	.LVL242:
 2168 11cc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 2169              	.LCFI13:
 2170              		.cfi_def_cfa_offset 16
 2171              		.cfi_offset 4, -16
 2172              		.cfi_offset 5, -12
 2173              		.cfi_offset 6, -8
 2174              		.cfi_offset 14, -4
 2175 11d0 0150A0E1 		mov	r5, r1
 2176 11d4 08D04DE2 		sub	sp, sp, #8
 2177              	.LCFI14:
 2178              		.cfi_def_cfa_offset 24
1276:../uvc.c      **** 	uint8_t dataIdx = 0;
 2179              		.loc 1 1276 0
 2180 11d8 0040A0E1 		mov	r4, r0
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 2181              		.loc 1 1279 0
 2182 11dc 0060A0E3 		mov	r6, #0
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 2183              		.loc 1 1278 0
 2184 11e0 0010E0E3 		mvn	r1, #0
 2185              	.LVL243:
 2186 11e4 1C0090E5 		ldr	r0, [r0, #28]
 2187              	.LVL244:
 2188 11e8 FEFFFFEB 		bl	_txe_mutex_get
 2189              	.LVL245:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 2190              		.loc 1 1279 0
 2191 11ec 062055E0 		subs	r2, r5, r6
 2192 11f0 003072E2 		rsbs	r3, r2, #0
 2193 11f4 0230B3E0 		adcs	r3, r3, r2
 2194 11f8 00308DE5 		str	r3, [sp]
 2195 11fc 0400A0E1 		mov	r0, r4
 2196 1200 04608DE5 		str	r6, [sp, #4]
 2197 1204 2010A0E3 		mov	r1, #32
 2198 1208 2720A0E3 		mov	r2, #39
 2199 120c 3030A0E3 		mov	r3, #48
 2200 1210 FEFFFFEB 		bl	cmdSet
 2201              	.LVL246:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2202              		.loc 1 1280 0
 2203 1214 060055E1 		cmp	r5, r6
 2204 1218 0250A003 		moveq	r5, #2
 2205 121c 0150A013 		movne	r5, #1
 2206 1220 60008DE8 		stmia	sp, {r5, r6}
 2207 1224 0400A0E1 		mov	r0, r4
 2208 1228 2110A0E3 		mov	r1, #33
 2209 122c 2520A0E3 		mov	r2, #37
 2210 1230 3030A0E3 		mov	r3, #48
 2211 1234 FEFFFFEB 		bl	cmdSet
 2212              	.LVL247:
1281:../uvc.c      **** }
 2213              		.loc 1 1281 0
 2214 1238 1C0094E5 		ldr	r0, [r4, #28]
1282:../uvc.c      **** 
 2215              		.loc 1 1282 0
 2216 123c 08D08DE2 		add	sp, sp, #8
 2217              		@ sp needed
 2218 1240 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 2219              	.LVL248:
1281:../uvc.c      **** }
 2220              		.loc 1 1281 0
 2221 1244 FEFFFFEA 		b	_txe_mutex_put
 2222              	.LVL249:
 2223              		.cfi_endproc
 2224              	.LFE1:
 2226              		.align	2
 2227              		.global	getShutCtrl
 2229              	getShutCtrl:
 2230              	.LFB2:
1286:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 2231              		.loc 1 1286 0
 2232              		.cfi_startproc
 2233              		@ args = 0, pretend = 0, frame = 0
 2234              		@ frame_needed = 0, uses_anonymous_args = 0
 2235              	.LVL250:
1291:../uvc.c      **** 	case 1:
 2236              		.loc 1 1291 0
 2237 1248 013040E2 		sub	r3, r0, #1
1286:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 2238              		.loc 1 1286 0
 2239 124c 30402DE9 		stmfd	sp!, {r4, r5, lr}
 2240              	.LCFI15:
 2241              		.cfi_def_cfa_offset 12
 2242              		.cfi_offset 4, -12
 2243              		.cfi_offset 5, -8
 2244              		.cfi_offset 14, -4
 2245 1250 0020A0E1 		mov	r2, r0
 2246 1254 0CD04DE2 		sub	sp, sp, #12
 2247              	.LCFI16:
 2248              		.cfi_def_cfa_offset 24
1291:../uvc.c      **** 	case 1:
 2249              		.loc 1 1291 0
 2250 1258 090053E3 		cmp	r3, #9
 2251 125c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2252 1260 350000EA 		b	.L254
 2253              	.L256:
 2254 1264 00130000 		.word	.L255
 2255 1268 00130000 		.word	.L255
 2256 126c 00130000 		.word	.L255
 2257 1270 00130000 		.word	.L255
 2258 1274 00130000 		.word	.L255
 2259 1278 8C120000 		.word	.L257
 2260 127c 8C120000 		.word	.L257
 2261 1280 8C120000 		.word	.L257
 2262 1284 8C120000 		.word	.L257
 2263 1288 8C120000 		.word	.L257
 2264              	.L257:
 2265              	.LVL251:
1313:../uvc.c      **** 		fRate = 30;
 2266              		.loc 1 1313 0
 2267 128c D0009FE5 		ldr	r0, .L269
 2268              	.LVL252:
 2269 1290 8330A0E1 		mov	r3, r3, asl #1
1315:../uvc.c      **** 		if(NumLn > 1944)
 2270              		.loc 1 1315 0
 2271 1294 B33090E1 		ldrh	r3, [r0, r3]
 2272 1298 C8C09FE5 		ldr	ip, .L269+4
 2273 129c 030263E0 		rsb	r0, r3, r3, asl #4
 2274 12a0 8000A0E1 		mov	r0, r0, asl #1
 2275 12a4 90ECCCE0 		smull	lr, ip, r0, ip
 2276 12a8 C00FA0E1 		mov	r0, r0, asr #31
 2277 12ac 4C0460E0 		rsb	r0, r0, ip, asr #8
1316:../uvc.c      **** 			NumLn =1944;
 2278              		.loc 1 1316 0
 2279 12b0 B4E09FE5 		ldr	lr, .L269+8
1315:../uvc.c      **** 		if(NumLn > 1944)
 2280              		.loc 1 1315 0
 2281 12b4 0008A0E1 		mov	r0, r0, asl #16
 2282 12b8 20C8A0E1 		mov	ip, r0, lsr #16
 2283              	.LVL253:
1316:../uvc.c      **** 			NumLn =1944;
 2284              		.loc 1 1316 0
 2285 12bc 0E005CE1 		cmp	ip, lr
 2286 12c0 1A00008A 		bhi	.L263
 2287              	.LVL254:
 2288              	.L267:
1318:../uvc.c      **** 			NumLn = 8;
 2289              		.loc 1 1318 0
 2290 12c4 07005CE3 		cmp	ip, #7
 2291 12c8 2100008A 		bhi	.L268
 2292 12cc 0100A0E3 		mov	r0, #1
 2293 12d0 0040A0E1 		mov	r4, r0
 2294 12d4 08E0A0E3 		mov	lr, #8
 2295              	.L260:
 2296              	.LVL255:
1321:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 2297              		.loc 1 1321 0
 2298 12d8 0150A0E3 		mov	r5, #1
1322:../uvc.c      **** 		break;
 2299              		.loc 1 1322 0
 2300 12dc 04008DE5 		str	r0, [sp, #4]
 2301 12e0 00E08DE5 		str	lr, [sp]
 2302 12e4 0400A0E3 		mov	r0, #4
1321:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 2303              		.loc 1 1321 0
 2304 12e8 0050C1E5 		strb	r5, [r1]
1322:../uvc.c      **** 		break;
 2305              		.loc 1 1322 0
 2306 12ec 7C109FE5 		ldr	r1, .L269+12
 2307              	.LVL256:
 2308 12f0 FEFFFFEB 		bl	CyU3PDebugPrint
 2309              	.LVL257:
1331:../uvc.c      **** 
 2310              		.loc 1 1331 0
 2311 12f4 0400A0E1 		mov	r0, r4
 2312 12f8 0CD08DE2 		add	sp, sp, #12
 2313              		@ sp needed
 2314 12fc 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 2315              	.LVL258:
 2316              	.L255:
1297:../uvc.c      **** 		fRate = 30;
 2317              		.loc 1 1297 0
 2318 1300 5C009FE5 		ldr	r0, .L269
 2319              	.LVL259:
 2320 1304 8330A0E1 		mov	r3, r3, asl #1
 2321 1308 B33090E1 		ldrh	r3, [r0, r3]
 2322              	.LVL260:
1299:../uvc.c      **** 		if(NumLn > 1944)
 2323              		.loc 1 1299 0
 2324 130c 60009FE5 		ldr	r0, .L269+16
 2325              	.LVL261:
1300:../uvc.c      **** 			NumLn =1944;
 2326              		.loc 1 1300 0
 2327 1310 54E09FE5 		ldr	lr, .L269+8
1299:../uvc.c      **** 		if(NumLn > 1944)
 2328              		.loc 1 1299 0
 2329 1314 93C080E0 		umull	ip, r0, r3, r0
 2330 1318 A004A0E1 		mov	r0, r0, lsr #9
 2331 131c 000260E0 		rsb	r0, r0, r0, asl #4
 2332 1320 8008A0E1 		mov	r0, r0, asl #17
 2333 1324 20C8A0E1 		mov	ip, r0, lsr #16
 2334              	.LVL262:
1300:../uvc.c      **** 			NumLn =1944;
 2335              		.loc 1 1300 0
 2336 1328 0E005CE1 		cmp	ip, lr
 2337 132c E4FFFF9A 		bls	.L267
 2338              	.LVL263:
 2339              	.L263:
 2340 1330 F300A0E3 		mov	r0, #243
 2341 1334 0040A0E1 		mov	r4, r0
 2342 1338 E6FFFFEA 		b	.L260
 2343              	.LVL264:
 2344              	.L254:
1327:../uvc.c      **** 		break;
 2345              		.loc 1 1327 0
 2346 133c 0140A0E3 		mov	r4, #1
1326:../uvc.c      **** 		LnVal = 1;
 2347              		.loc 1 1326 0
 2348 1340 0030A0E3 		mov	r3, #0
1331:../uvc.c      **** 
 2349              		.loc 1 1331 0
 2350 1344 0400A0E1 		mov	r0, r4
 2351              	.LVL265:
1326:../uvc.c      **** 		LnVal = 1;
 2352              		.loc 1 1326 0
 2353 1348 0030C1E5 		strb	r3, [r1]
 2354              	.LVL266:
1331:../uvc.c      **** 
 2355              		.loc 1 1331 0
 2356 134c 0CD08DE2 		add	sp, sp, #12
 2357              		@ sp needed
 2358 1350 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 2359              	.LVL267:
 2360              	.L268:
 2361 1354 A009A0E1 		mov	r0, r0, lsr #19
 2362 1358 FF4000E2 		and	r4, r0, #255
 2363 135c 0CE0A0E1 		mov	lr, ip
 2364 1360 DCFFFFEA 		b	.L260
 2365              	.L270:
 2366              		.align	2
 2367              	.L269:
 2368 1364 00000000 		.word	.LANCHOR2
 2369 1368 817F807F 		.word	2139127681
 2370 136c 98070000 		.word	1944
 2371 1370 A8030000 		.word	.LC23
 2372 1374 01FF00FF 		.word	-16711935
 2373              		.cfi_endproc
 2374              	.LFE2:
 2376              		.align	2
 2377              		.global	ControlHandle
 2379              	ControlHandle:
 2380              	.LFB3:
1333:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2381              		.loc 1 1333 0
 2382              		.cfi_startproc
 2383              		@ args = 0, pretend = 0, frame = 32
 2384              		@ frame_needed = 0, uses_anonymous_args = 0
 2385              	.LVL268:
 2386 1378 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2387              	.LCFI17:
 2388              		.cfi_def_cfa_offset 36
 2389              		.cfi_offset 4, -36
 2390              		.cfi_offset 5, -32
 2391              		.cfi_offset 6, -28
 2392              		.cfi_offset 7, -24
 2393              		.cfi_offset 8, -20
 2394              		.cfi_offset 9, -16
 2395              		.cfi_offset 10, -12
 2396              		.cfi_offset 11, -8
 2397              		.cfi_offset 14, -4
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 2398              		.loc 1 1341 0
 2399 137c C47F9FE5 		ldr	r7, .L451+52
1340:../uvc.c      ****     	RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1;//ExUCtrlParArry[locCtrlID][0];
 2400              		.loc 1 1340 0
 2401 1380 0F0050E3 		cmp	r0, #15
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 2402              		.loc 1 1341 0
 2403 1384 003187E0 		add	r3, r7, r0, asl #2
 2404 1388 20301385 		ldrhi	r3, [r3, #-32]
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 2405              		.loc 1 1348 0
 2406 138c 20319395 		ldrls	r3, [r3, #288]
1333:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2407              		.loc 1 1333 0
 2408 1390 3CD04DE2 		sub	sp, sp, #60
 2409              	.LCFI18:
 2410              		.cfi_def_cfa_offset 96
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 2411              		.loc 1 1348 0
 2412 1394 00C0D3E5 		ldrb	ip, [r3]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 2413              		.loc 1 1349 0
 2414 1398 0120D3E5 		ldrb	r2, [r3, #1]	@ zero_extendqisi2
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 2415              		.loc 1 1350 0
 2416 139c 0FB0D3E5 		ldrb	fp, [r3, #15]	@ zero_extendqisi2
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 2417              		.loc 1 1351 0
 2418 13a0 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 2419              		.loc 1 1359 0
 2420 13a4 683F9FE5 		ldr	r3, .L451
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 2421              		.loc 1 1349 0
 2422 13a8 FF2002E2 		and	r2, r2, #255
1359:../uvc.c      ****     /*
 2423              		.loc 1 1359 0
 2424 13ac 0060D3E5 		ldrb	r6, [r3]	@ zero_extendqisi2
1333:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2425              		.loc 1 1333 0
 2426 13b0 0050A0E1 		mov	r5, r0
1367:../uvc.c      **** 		 {
 2427              		.loc 1 1367 0
 2428 13b4 830056E3 		cmp	r6, #131
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 2429              		.loc 1 1348 0
 2430 13b8 FFC00CE2 		and	ip, ip, #255
 2431              	.LVL269:
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 2432              		.loc 1 1349 0
 2433 13bc 20208DE5 		str	r2, [sp, #32]
 2434              	.LVL270:
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 2435              		.loc 1 1350 0
 2436 13c0 FFB00BE2 		and	fp, fp, #255
 2437              	.LVL271:
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 2438              		.loc 1 1351 0
 2439 13c4 FF8008E2 		and	r8, r8, #255
 2440              	.LVL272:
1367:../uvc.c      **** 		 {
 2441              		.loc 1 1367 0
 2442 13c8 B100000A 		beq	.L275
 2443 13cc 1500009A 		bls	.L434
 2444 13d0 850056E3 		cmp	r6, #133
 2445 13d4 A200000A 		beq	.L280
 2446 13d8 BC00003A 		bcc	.L281
 2447 13dc 860056E3 		cmp	r6, #134
 2448 13e0 6500000A 		beq	.L282
 2449 13e4 870056E3 		cmp	r6, #135
 2450 13e8 9400001A 		bne	.L274
1788:../uvc.c      **** 		 		 if(Len == 2){
 2451              		.loc 1 1788 0
 2452 13ec 0F0050E3 		cmp	r0, #15
1790:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2453              		.loc 1 1790 0
 2454 13f0 005187E0 		add	r5, r7, r0, asl #2
1788:../uvc.c      **** 		 		 if(Len == 2){
 2455              		.loc 1 1788 0
 2456 13f4 C300009A 		bls	.L328
1789:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 2457              		.loc 1 1789 0
 2458 13f8 020058E3 		cmp	r8, #2
 2459 13fc 0701000A 		beq	.L435
1795:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2460              		.loc 1 1795 0
 2461 1400 202015E5 		ldr	r2, [r5, #-32]
 2462 1404 504F9FE5 		ldr	r4, .L451+72
 2463 1408 0B10D2E5 		ldrb	r1, [r2, #11]	@ zero_extendqisi2
1796:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2464              		.loc 1 1796 0
 2465 140c 0030A0E3 		mov	r3, #0
1795:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2466              		.loc 1 1795 0
 2467 1410 2810C4E5 		strb	r1, [r4, #40]
1796:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2468              		.loc 1 1796 0
 2469 1414 2930C4E5 		strb	r3, [r4, #41]
1797:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2470              		.loc 1 1797 0
 2471 1418 0C20D2E5 		ldrb	r2, [r2, #12]	@ zero_extendqisi2
1798:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 2472              		.loc 1 1798 0
 2473 141c 2B30C4E5 		strb	r3, [r4, #43]
1797:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2474              		.loc 1 1797 0
 2475 1420 2A20C4E5 		strb	r2, [r4, #42]
 2476 1424 E60000EA 		b	.L331
 2477              	.L434:
1367:../uvc.c      **** 		 {
 2478              		.loc 1 1367 0
 2479 1428 810056E3 		cmp	r6, #129
 2480 142c 6D00000A 		beq	.L277
 2481 1430 4200008A 		bhi	.L278
 2482 1434 010056E3 		cmp	r6, #1
 2483 1438 8000001A 		bne	.L274
1824:../uvc.c      **** 				  glEp0Buffer, &readCount);
 2484              		.loc 1 1824 0
 2485 143c 184F9FE5 		ldr	r4, .L451+72
 2486 1440 36208DE2 		add	r2, sp, #54
 2487 1444 2000A0E3 		mov	r0, #32
 2488              	.LVL273:
 2489 1448 281084E2 		add	r1, r4, #40
 2490 144c 18C08DE5 		str	ip, [sp, #24]
 2491 1450 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2492              	.LVL274:
1826:../uvc.c      **** 			   {
 2493              		.loc 1 1826 0
 2494 1454 18C09DE5 		ldr	ip, [sp, #24]
 2495 1458 002050E2 		subs	r2, r0, #0
 2496 145c 1304001A 		bne	.L333
1828:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 2497              		.loc 1 1828 0
 2498 1460 020058E3 		cmp	r8, #2
1829:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 2499              		.loc 1 1829 0
 2500 1464 2810D405 		ldreqb	r1, [r4, #40]	@ zero_extendqisi2
1830:../uvc.c      **** 				 }else{
 2501              		.loc 1 1830 0
 2502 1468 2920D405 		ldreqb	r2, [r4, #41]	@ zero_extendqisi2
1832:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 2503              		.loc 1 1832 0
 2504 146c 2830D415 		ldrneb	r3, [r4, #40]	@ zero_extendqisi2
1833:../uvc.c      **** 				 }
 2505              		.loc 1 1833 0
 2506 1470 2A10D415 		ldrneb	r1, [r4, #42]	@ zero_extendqisi2
 2507 1474 0130A001 		moveq	r3, r1
1829:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 2508              		.loc 1 1829 0
 2509 1478 24108D05 		streq	r1, [sp, #36]
 2510              	.LVL275:
1830:../uvc.c      **** 				 }else{
 2511              		.loc 1 1830 0
 2512 147c 28208D05 		streq	r2, [sp, #40]
 2513              	.LVL276:
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 2514              		.loc 1 1836 0
 2515 1480 20209DE5 		ldr	r2, [sp, #32]
 2516 1484 28109D05 		ldreq	r1, [sp, #40]
1832:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 2517              		.loc 1 1832 0
 2518 1488 24308D15 		strne	r3, [sp, #36]
 2519              	.LVL277:
1833:../uvc.c      **** 				 }
 2520              		.loc 1 1833 0
 2521 148c 28108D15 		strne	r1, [sp, #40]
 2522              	.LVL278:
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 2523              		.loc 1 1836 0
 2524 1490 04088DE8 		stmia	sp, {r2, fp}
 2525 1494 0C308DE5 		str	r3, [sp, #12]
 2526 1498 10108DE5 		str	r1, [sp, #16]
 2527 149c 0C30A0E1 		mov	r3, ip
 2528 14a0 08808DE5 		str	r8, [sp, #8]
 2529 14a4 0400A0E3 		mov	r0, #4
 2530              	.LVL279:
 2531 14a8 681E9FE5 		ldr	r1, .L451+4
 2532 14ac 0520A0E1 		mov	r2, r5
 2533 14b0 18C08DE5 		str	ip, [sp, #24]
 2534 14b4 FEFFFFEB 		bl	CyU3PDebugPrint
 2535              	.LVL280:
1838:../uvc.c      **** 					 switch(CtrlID)
 2536              		.loc 1 1838 0
 2537 14b8 0F0055E3 		cmp	r5, #15
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 2538              		.loc 1 1836 0
 2539 14bc 24909DE5 		ldr	r9, [sp, #36]
 2540 14c0 28A09DE5 		ldr	r10, [sp, #40]
1838:../uvc.c      **** 					 switch(CtrlID)
 2541              		.loc 1 1838 0
 2542 14c4 18C09DE5 		ldr	ip, [sp, #24]
 2543 14c8 C500009A 		bls	.L336
1839:../uvc.c      **** 					 {
 2544              		.loc 1 1839 0
 2545 14cc 104045E2 		sub	r4, r5, #16
 2546 14d0 180054E3 		cmp	r4, #24
 2547 14d4 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2548 14d8 F10300EA 		b	.L337
 2549              	.L339:
 2550 14dc 7C220000 		.word	.L338
 2551 14e0 A4240000 		.word	.L337
 2552 14e4 A4240000 		.word	.L337
 2553 14e8 A4240000 		.word	.L337
 2554 14ec A4240000 		.word	.L337
 2555 14f0 A4240000 		.word	.L337
 2556 14f4 A4240000 		.word	.L337
 2557 14f8 A4240000 		.word	.L337
 2558 14fc A4240000 		.word	.L337
 2559 1500 60230000 		.word	.L340
 2560 1504 A4240000 		.word	.L337
 2561 1508 44210000 		.word	.L341
 2562 150c 8C1F0000 		.word	.L398
 2563 1510 A4240000 		.word	.L337
 2564 1514 981F0000 		.word	.L342
 2565 1518 54220000 		.word	.L343
 2566 151c A4240000 		.word	.L337
 2567 1520 A4240000 		.word	.L337
 2568 1524 A4240000 		.word	.L337
 2569 1528 A4240000 		.word	.L337
 2570 152c C8210000 		.word	.L344
 2571 1530 A4240000 		.word	.L337
 2572 1534 E8200000 		.word	.L345
 2573 1538 A4240000 		.word	.L337
 2574 153c 04200000 		.word	.L346
 2575              	.LVL281:
 2576              	.L278:
1679:../uvc.c      **** 		 		 if(Len == 2){
 2577              		.loc 1 1679 0
 2578 1540 0F0050E3 		cmp	r0, #15
1681:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2579              		.loc 1 1681 0
 2580 1544 005187E0 		add	r5, r7, r0, asl #2
1679:../uvc.c      **** 		 		 if(Len == 2){
 2581              		.loc 1 1679 0
 2582 1548 8800009A 		bls	.L314
1680:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 2583              		.loc 1 1680 0
 2584 154c 020058E3 		cmp	r8, #2
 2585 1550 CB00000A 		beq	.L436
1686:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2586              		.loc 1 1686 0
 2587 1554 202015E5 		ldr	r2, [r5, #-32]
 2588 1558 FC4D9FE5 		ldr	r4, .L451+72
 2589 155c 0310D2E5 		ldrb	r1, [r2, #3]	@ zero_extendqisi2
1687:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2590              		.loc 1 1687 0
 2591 1560 0030A0E3 		mov	r3, #0
1686:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2592              		.loc 1 1686 0
 2593 1564 2810C4E5 		strb	r1, [r4, #40]
1687:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2594              		.loc 1 1687 0
 2595 1568 2930C4E5 		strb	r3, [r4, #41]
1688:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2596              		.loc 1 1688 0
 2597 156c 0420D2E5 		ldrb	r2, [r2, #4]	@ zero_extendqisi2
1689:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2598              		.loc 1 1689 0
 2599 1570 2B30C4E5 		strb	r3, [r4, #43]
1688:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2600              		.loc 1 1688 0
 2601 1574 2A20C4E5 		strb	r2, [r4, #42]
 2602 1578 910000EA 		b	.L331
 2603              	.L282:
 2604              	.LVL282:
1769:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCInfoLo;//ExUCtrlParArry[locCtrlID][9];//ext_co
 2605              		.loc 1 1769 0
 2606 157c 0F0050E3 		cmp	r0, #15
1770:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 2607              		.loc 1 1770 0
 2608 1580 005187E0 		add	r5, r7, r0, asl #2
 2609 1584 20301585 		ldrhi	r3, [r5, #-32]
1776:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 2610              		.loc 1 1776 0
 2611 1588 20319595 		ldrls	r3, [r5, #288]
 2612 158c C84D9FE5 		ldr	r4, .L451+72
 2613 1590 0920D3E5 		ldrb	r2, [r3, #9]	@ zero_extendqisi2
1782:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 2614              		.loc 1 1782 0
 2615 1594 0100A0E3 		mov	r0, #1
 2616              	.LVL283:
1777:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2617              		.loc 1 1777 0
 2618 1598 0030A0E3 		mov	r3, #0
1776:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 2619              		.loc 1 1776 0
 2620 159c 2820C4E5 		strb	r2, [r4, #40]
1777:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2621              		.loc 1 1777 0
 2622 15a0 2930C4E5 		strb	r3, [r4, #41]
1778:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 2623              		.loc 1 1778 0
 2624 15a4 2A30C4E5 		strb	r3, [r4, #42]
1779:../uvc.c      **** 		 	 }
 2625              		.loc 1 1779 0
 2626 15a8 2B30C4E5 		strb	r3, [r4, #43]
 2627              	.LVL284:
 2628              	.L427:
1814:../uvc.c      **** 		 	 if(Len == 2){
 2629              		.loc 1 1814 0
 2630 15ac 681D9FE5 		ldr	r1, .L451+8
 2631 15b0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2632              	.LVL285:
 2633 15b4 28B0D4E5 		ldrb	fp, [r4, #40]	@ zero_extendqisi2
 2634              	.LVL286:
 2635 15b8 2970D4E5 		ldrb	r7, [r4, #41]	@ zero_extendqisi2
 2636 15bc 0090A0E3 		mov	r9, #0
 2637 15c0 09A0A0E1 		mov	r10, r9
 2638              	.LVL287:
 2639              	.L284:
2271:../uvc.c      **** }
 2640              		.loc 1 2271 0
 2641 15c4 000C8DE8 		stmia	sp, {r10, fp}
 2642 15c8 501D9FE5 		ldr	r1, .L451+12
 2643 15cc 08708DE5 		str	r7, [sp, #8]
 2644 15d0 0620A0E1 		mov	r2, r6
 2645 15d4 0930A0E1 		mov	r3, r9
 2646 15d8 0400A0E3 		mov	r0, #4
 2647 15dc FEFFFFEB 		bl	CyU3PDebugPrint
 2648              	.LVL288:
2272:../uvc.c      **** /************** CT control requests handler *************************/
 2649              		.loc 1 2272 0
 2650 15e0 3CD08DE2 		add	sp, sp, #60
 2651              		@ sp needed
 2652 15e4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2653              	.LVL289:
 2654              	.L277:
1378:../uvc.c      **** 				 switch(CtrlID)
 2655              		.loc 1 1378 0
 2656 15e8 0F0050E3 		cmp	r0, #15
 2657 15ec 5000009A 		bls	.L285
1379:../uvc.c      **** 				 {
 2658              		.loc 1 1379 0
 2659 15f0 193040E2 		sub	r3, r0, #25
 2660 15f4 0F0053E3 		cmp	r3, #15
 2661 15f8 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2662 15fc 950300EA 		b	.L286
 2663              	.L288:
 2664 1600 C41A0000 		.word	.L287
 2665 1604 58240000 		.word	.L286
 2666 1608 58240000 		.word	.L286
 2667 160c 3C190000 		.word	.L303
 2668 1610 58240000 		.word	.L286
 2669 1614 58240000 		.word	.L286
 2670 1618 341B0000 		.word	.L290
 2671 161c 58240000 		.word	.L286
 2672 1620 58240000 		.word	.L286
 2673 1624 58240000 		.word	.L286
 2674 1628 58240000 		.word	.L286
 2675 162c 3C1A0000 		.word	.L291
 2676 1630 58240000 		.word	.L286
 2677 1634 041A0000 		.word	.L292
 2678 1638 58240000 		.word	.L286
 2679 163c 841A0000 		.word	.L293
 2680              	.L274:
2268:../uvc.c      **** 			  break;
 2681              		.loc 1 2268 0
 2682 1640 0000A0E3 		mov	r0, #0
 2683              	.LVL290:
 2684 1644 0020A0E1 		mov	r2, r0
 2685 1648 0110A0E3 		mov	r1, #1
2269:../uvc.c      **** 		 }
 2686              		.loc 1 2269 0
 2687 164c FF70A0E3 		mov	r7, #255
 2688 1650 0090A0E3 		mov	r9, #0
2268:../uvc.c      **** 			  break;
 2689              		.loc 1 2268 0
 2690 1654 FEFFFFEB 		bl	CyU3PUsbStall
 2691              	.LVL291:
2269:../uvc.c      **** 		 }
 2692              		.loc 1 2269 0
 2693 1658 07B0A0E1 		mov	fp, r7
 2694              	.LVL292:
 2695 165c 09A0A0E1 		mov	r10, r9
 2696 1660 D7FFFFEA 		b	.L284
 2697              	.LVL293:
 2698              	.L280:
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2699              		.loc 1 1371 0
 2700 1664 F04C9FE5 		ldr	r4, .L451+72
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2701              		.loc 1 1372 0
 2702 1668 0030A0E3 		mov	r3, #0
 2703 166c 0390A0E1 		mov	r9, r3
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2704              		.loc 1 1373 0
 2705 1670 281084E2 		add	r1, r4, #40
 2706 1674 0200A0E3 		mov	r0, #2
 2707              	.LVL294:
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2708              		.loc 1 1371 0
 2709 1678 2880C4E5 		strb	r8, [r4, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2710              		.loc 1 1372 0
 2711 167c 2930C4E5 		strb	r3, [r4, #41]
 2712 1680 09A0A0E1 		mov	r10, r9
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2713              		.loc 1 1373 0
 2714 1684 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2715              	.LVL295:
1375:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 2716              		.loc 1 1375 0
 2717 1688 FF70A0E3 		mov	r7, #255
 2718 168c 28B0D4E5 		ldrb	fp, [r4, #40]	@ zero_extendqisi2
 2719              	.LVL296:
 2720 1690 CBFFFFEA 		b	.L284
 2721              	.LVL297:
 2722              	.L275:
1715:../uvc.c      **** 		 		 if(Len == 2){
 2723              		.loc 1 1715 0
 2724 1694 0F0050E3 		cmp	r0, #15
1717:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2725              		.loc 1 1717 0
 2726 1698 005187E0 		add	r5, r7, r0, asl #2
1715:../uvc.c      **** 		 		 if(Len == 2){
 2727              		.loc 1 1715 0
 2728 169c 3E00009A 		bls	.L319
1716:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 2729              		.loc 1 1716 0
 2730 16a0 020058E3 		cmp	r8, #2
 2731 16a4 6500000A 		beq	.L437
1722:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2732              		.loc 1 1722 0
 2733 16a8 202015E5 		ldr	r2, [r5, #-32]
 2734 16ac A84C9FE5 		ldr	r4, .L451+72
 2735 16b0 0510D2E5 		ldrb	r1, [r2, #5]	@ zero_extendqisi2
1723:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2736              		.loc 1 1723 0
 2737 16b4 0030A0E3 		mov	r3, #0
1722:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2738              		.loc 1 1722 0
 2739 16b8 2810C4E5 		strb	r1, [r4, #40]
1723:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2740              		.loc 1 1723 0
 2741 16bc 2930C4E5 		strb	r3, [r4, #41]
1724:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2742              		.loc 1 1724 0
 2743 16c0 0620D2E5 		ldrb	r2, [r2, #6]	@ zero_extendqisi2
1725:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2744              		.loc 1 1725 0
 2745 16c4 2B30C4E5 		strb	r3, [r4, #43]
1724:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2746              		.loc 1 1724 0
 2747 16c8 2A20C4E5 		strb	r2, [r4, #42]
 2748 16cc 3C0000EA 		b	.L331
 2749              	.L281:
1751:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCResLo;//ExUCtrlParArry[locCtrlID][7];//ext_con
 2750              		.loc 1 1751 0
 2751 16d0 0F0050E3 		cmp	r0, #15
1752:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 2752              		.loc 1 1752 0
 2753 16d4 005187E0 		add	r5, r7, r0, asl #2
 2754 16d8 20201585 		ldrhi	r2, [r5, #-32]
1758:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 2755              		.loc 1 1758 0
 2756 16dc 20219595 		ldrls	r2, [r5, #288]
 2757 16e0 744C9FE5 		ldr	r4, .L451+72
 2758 16e4 0710D2E5 		ldrb	r1, [r2, #7]	@ zero_extendqisi2
1760:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 2759              		.loc 1 1760 0
 2760 16e8 0030A0E3 		mov	r3, #0
1758:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 2761              		.loc 1 1758 0
 2762 16ec 2810C4E5 		strb	r1, [r4, #40]
1759:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2763              		.loc 1 1759 0
 2764 16f0 0820D2E5 		ldrb	r2, [r2, #8]	@ zero_extendqisi2
1763:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2765              		.loc 1 1763 0
 2766 16f4 0800A0E1 		mov	r0, r8
 2767              	.LVL298:
1760:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 2768              		.loc 1 1760 0
 2769 16f8 2A30C4E5 		strb	r3, [r4, #42]
1759:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2770              		.loc 1 1759 0
 2771 16fc 2920C4E5 		strb	r2, [r4, #41]
1761:../uvc.c      **** 		 	 }
 2772              		.loc 1 1761 0
 2773 1700 2B30C4E5 		strb	r3, [r4, #43]
 2774 1704 A8FFFFEA 		b	.L427
 2775              	.LVL299:
 2776              	.L328:
1802:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 2777              		.loc 1 1802 0
 2778 1708 020058E3 		cmp	r8, #2
1803:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2779              		.loc 1 1803 0
 2780 170c 203195E5 		ldr	r3, [r5, #288]
 2781 1710 444C9FE5 		ldr	r4, .L451+72
1802:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 2782              		.loc 1 1802 0
 2783 1714 5500000A 		beq	.L438
1807:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2784              		.loc 1 1807 0
 2785 1718 0B10D3E5 		ldrb	r1, [r3, #11]	@ zero_extendqisi2
1810:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 2786              		.loc 1 1810 0
 2787 171c 0020A0E3 		mov	r2, #0
1807:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2788              		.loc 1 1807 0
 2789 1720 2810C4E5 		strb	r1, [r4, #40]
1809:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2790              		.loc 1 1809 0
 2791 1724 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
1810:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 2792              		.loc 1 1810 0
 2793 1728 2B20C4E5 		strb	r2, [r4, #43]
1809:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2794              		.loc 1 1809 0
 2795 172c 2930C4E5 		strb	r3, [r4, #41]
 2796 1730 230000EA 		b	.L331
 2797              	.L285:
1522:../uvc.c      **** 				 {
 2798              		.loc 1 1522 0
 2799 1734 013040E2 		sub	r3, r0, #1
 2800 1738 0A0053E3 		cmp	r3, #10
 2801 173c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2802 1740 F90100EA 		b	.L304
 2803              	.L306:
 2804 1744 CC190000 		.word	.L305
 2805 1748 2C1F0000 		.word	.L304
 2806 174c 2C1F0000 		.word	.L304
 2807 1750 90190000 		.word	.L307
 2808 1754 54190000 		.word	.L308
 2809 1758 2C1F0000 		.word	.L304
 2810 175c 34190000 		.word	.L309
 2811 1760 2C1F0000 		.word	.L304
 2812 1764 2C1F0000 		.word	.L304
 2813 1768 2C1F0000 		.word	.L304
 2814 176c B4180000 		.word	.L310
 2815              	.L314:
1693:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 2816              		.loc 1 1693 0
 2817 1770 020058E3 		cmp	r8, #2
1694:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2818              		.loc 1 1694 0
 2819 1774 203195E5 		ldr	r3, [r5, #288]
 2820 1778 DC4B9FE5 		ldr	r4, .L451+72
1693:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 2821              		.loc 1 1693 0
 2822 177c 4700000A 		beq	.L439
1698:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2823              		.loc 1 1698 0
 2824 1780 0310D3E5 		ldrb	r1, [r3, #3]	@ zero_extendqisi2
1701:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2825              		.loc 1 1701 0
 2826 1784 0020A0E3 		mov	r2, #0
1698:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2827              		.loc 1 1698 0
 2828 1788 2810C4E5 		strb	r1, [r4, #40]
1700:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2829              		.loc 1 1700 0
 2830 178c 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
1701:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2831              		.loc 1 1701 0
 2832 1790 2B20C4E5 		strb	r2, [r4, #43]
1700:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2833              		.loc 1 1700 0
 2834 1794 2930C4E5 		strb	r3, [r4, #41]
 2835 1798 090000EA 		b	.L331
 2836              	.L319:
1729:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 2837              		.loc 1 1729 0
 2838 179c 020058E3 		cmp	r8, #2
1730:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2839              		.loc 1 1730 0
 2840 17a0 203195E5 		ldr	r3, [r5, #288]
 2841 17a4 B04B9FE5 		ldr	r4, .L451+72
1729:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 2842              		.loc 1 1729 0
 2843 17a8 2B00000A 		beq	.L440
1734:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2844              		.loc 1 1734 0
 2845 17ac 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
1737:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2846              		.loc 1 1737 0
 2847 17b0 0020A0E3 		mov	r2, #0
1734:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2848              		.loc 1 1734 0
 2849 17b4 2810C4E5 		strb	r1, [r4, #40]
1736:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2850              		.loc 1 1736 0
 2851 17b8 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
1737:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2852              		.loc 1 1737 0
 2853 17bc 2B20C4E5 		strb	r2, [r4, #43]
1736:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2854              		.loc 1 1736 0
 2855 17c0 2930C4E5 		strb	r3, [r4, #41]
 2856              	.L331:
1814:../uvc.c      **** 		 	 if(Len == 2){
 2857              		.loc 1 1814 0
 2858 17c4 0800A0E1 		mov	r0, r8
 2859              	.LVL300:
 2860 17c8 4C1B9FE5 		ldr	r1, .L451+8
 2861 17cc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2862              	.LVL301:
 2863 17d0 0090A0E3 		mov	r9, #0
 2864 17d4 09A0A0E1 		mov	r10, r9
 2865 17d8 28B0D4E5 		ldrb	fp, [r4, #40]	@ zero_extendqisi2
 2866              	.LVL302:
 2867 17dc 2A70D4E5 		ldrb	r7, [r4, #42]	@ zero_extendqisi2
 2868 17e0 77FFFFEA 		b	.L284
 2869              	.LVL303:
 2870              	.L336:
2069:../uvc.c      **** 					 {
 2871              		.loc 1 2069 0
 2872 17e4 0B0055E3 		cmp	r5, #11
 2873 17e8 05F19F97 		ldrls	pc, [pc, r5, asl #2]
 2874 17ec 250300EA 		b	.L367
 2875              	.L369:
 2876 17f0 BC1E0000 		.word	.L368
 2877 17f4 5C1E0000 		.word	.L370
 2878 17f8 88240000 		.word	.L367
 2879 17fc 88240000 		.word	.L367
 2880 1800 FC1D0000 		.word	.L371
 2881 1804 A81C0000 		.word	.L372
 2882 1808 88240000 		.word	.L367
 2883 180c 181C0000 		.word	.L373
 2884 1810 88240000 		.word	.L367
 2885 1814 88240000 		.word	.L367
 2886 1818 88240000 		.word	.L367
 2887 181c 841B0000 		.word	.L374
 2888              	.LVL304:
 2889              	.L435:
1790:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2890              		.loc 1 1790 0
 2891 1820 203015E5 		ldr	r3, [r5, #-32]
 2892 1824 304B9FE5 		ldr	r4, .L451+72
 2893 1828 0B20D3E5 		ldrb	r2, [r3, #11]	@ zero_extendqisi2
 2894 182c 2820C4E5 		strb	r2, [r4, #40]
1791:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 2895              		.loc 1 1791 0
 2896 1830 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 2897 1834 2930C4E5 		strb	r3, [r4, #41]
 2898              	.L330:
1814:../uvc.c      **** 		 	 if(Len == 2){
 2899              		.loc 1 1814 0
 2900 1838 0200A0E3 		mov	r0, #2
 2901              	.LVL305:
 2902 183c 5AFFFFEA 		b	.L427
 2903              	.LVL306:
 2904              	.L437:
1717:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2905              		.loc 1 1717 0
 2906 1840 203015E5 		ldr	r3, [r5, #-32]
 2907 1844 104B9FE5 		ldr	r4, .L451+72
 2908 1848 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 2909 184c 2820C4E5 		strb	r2, [r4, #40]
1718:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2910              		.loc 1 1718 0
 2911 1850 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 2912 1854 2930C4E5 		strb	r3, [r4, #41]
 2913 1858 F6FFFFEA 		b	.L330
 2914              	.L440:
1730:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2915              		.loc 1 1730 0
 2916 185c 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 2917 1860 2820C4E5 		strb	r2, [r4, #40]
1731:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2918              		.loc 1 1731 0
 2919 1864 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 2920 1868 2930C4E5 		strb	r3, [r4, #41]
 2921 186c F1FFFFEA 		b	.L330
 2922              	.L438:
1803:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2923              		.loc 1 1803 0
 2924 1870 0B20D3E5 		ldrb	r2, [r3, #11]	@ zero_extendqisi2
 2925 1874 2820C4E5 		strb	r2, [r4, #40]
1804:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 2926              		.loc 1 1804 0
 2927 1878 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 2928 187c 2930C4E5 		strb	r3, [r4, #41]
 2929 1880 ECFFFFEA 		b	.L330
 2930              	.L436:
1681:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2931              		.loc 1 1681 0
 2932 1884 203015E5 		ldr	r3, [r5, #-32]
 2933 1888 CC4A9FE5 		ldr	r4, .L451+72
 2934 188c 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 2935 1890 2820C4E5 		strb	r2, [r4, #40]
1682:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2936              		.loc 1 1682 0
 2937 1894 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2938 1898 2930C4E5 		strb	r3, [r4, #41]
 2939 189c E5FFFFEA 		b	.L330
 2940              	.L439:
1694:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2941              		.loc 1 1694 0
 2942 18a0 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 2943 18a4 2820C4E5 		strb	r2, [r4, #40]
1695:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2944              		.loc 1 1695 0
 2945 18a8 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2946 18ac 2930C4E5 		strb	r3, [r4, #41]
 2947 18b0 E0FFFFEA 		b	.L330
 2948              	.L310:
1596:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
 2949              		.loc 1 1596 0
 2950 18b4 0B10A0E1 		mov	r1, fp
 2951 18b8 0C00A0E1 		mov	r0, ip
 2952              	.LVL307:
 2953 18bc FEFFFFEB 		bl	SensorGetControl
 2954              	.LVL308:
1597:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 2955              		.loc 1 1597 0
 2956 18c0 0B10A0E1 		mov	r1, fp
1598:../uvc.c      **** 							WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 2957              		.loc 1 1598 0
 2958 18c4 904A9FE5 		ldr	r4, .L451+72
1596:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
 2959              		.loc 1 1596 0
 2960 18c8 0050A0E1 		mov	r5, r0
 2961              	.LVL309:
1597:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 2962              		.loc 1 1597 0
 2963 18cc 20009DE5 		ldr	r0, [sp, #32]
 2964              	.LVL310:
 2965 18d0 FEFFFFEB 		bl	SensorGetControl
 2966              	.LVL311:
1599:../uvc.c      **** 							glEp0Buffer[2] = Data1;
 2967              		.loc 1 1599 0
 2968 18d4 782A9FE5 		ldr	r2, .L451+64
1604:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 2969              		.loc 1 1604 0
 2970 18d8 0030A0E3 		mov	r3, #0
 2971 18dc 0590A0E1 		mov	r9, r5
1608:../uvc.c      **** 					 case ShapCtlID7:
 2972              		.loc 1 1608 0
 2973 18e0 05B0A0E1 		mov	fp, r5
 2974              	.LVL312:
1598:../uvc.c      **** 							WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 2975              		.loc 1 1598 0
 2976 18e4 2850C4E5 		strb	r5, [r4, #40]
1599:../uvc.c      **** 							glEp0Buffer[2] = Data1;
 2977              		.loc 1 1599 0
 2978 18e8 8455C2E5 		strb	r5, [r2, #1412]
1604:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 2979              		.loc 1 1604 0
 2980 18ec 2930C4E5 		strb	r3, [r4, #41]
1605:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 2981              		.loc 1 1605 0
 2982 18f0 2B30C4E5 		strb	r3, [r4, #43]
 2983 18f4 0070A0E1 		mov	r7, r0
1608:../uvc.c      **** 					 case ShapCtlID7:
 2984              		.loc 1 1608 0
 2985 18f8 00A0A0E1 		mov	r10, r0
1600:../uvc.c      **** 							WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 2986              		.loc 1 1600 0
 2987 18fc 2A00C4E5 		strb	r0, [r4, #42]
1601:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 2988              		.loc 1 1601 0
 2989 1900 8605C2E5 		strb	r0, [r2, #1414]
 2990              	.LVL313:
 2991              	.L294:
1672:../uvc.c      **** 
 2992              		.loc 1 1672 0
 2993 1904 0800A0E1 		mov	r0, r8
 2994 1908 0C1A9FE5 		ldr	r1, .L451+8
 2995 190c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2996              	.LVL314:
1675:../uvc.c      **** //#endif
 2997              		.loc 1 1675 0
 2998 1910 2B00D4E5 		ldrb	r0, [r4, #43]	@ zero_extendqisi2
 2999 1914 2C10D4E5 		ldrb	r1, [r4, #44]	@ zero_extendqisi2
 3000 1918 2820D4E5 		ldrb	r2, [r4, #40]	@ zero_extendqisi2
 3001 191c 2930D4E5 		ldrb	r3, [r4, #41]	@ zero_extendqisi2
 3002 1920 03018DE8 		stmia	sp, {r0, r1, r8}
 3003 1924 F8199FE5 		ldr	r1, .L451+16
 3004 1928 0400A0E3 		mov	r0, #4
 3005 192c FEFFFFEB 		bl	CyU3PDebugPrint
 3006              	.LVL315:
1677:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 3007              		.loc 1 1677 0
 3008 1930 23FFFFEA 		b	.L284
 3009              	.LVL316:
 3010              	.L309:
1615:../uvc.c      **** 			 	 			 {
 3011              		.loc 1 1615 0
 3012 1934 020058E3 		cmp	r8, #2
 3013 1938 ED03000A 		beq	.L441
 3014              	.L303:
1397:../uvc.c      **** 			 	 	 case ExtAexModCtlID9:
 3015              		.loc 1 1397 0
 3016 193c FF70A0E3 		mov	r7, #255
 3017 1940 0090A0E3 		mov	r9, #0
 3018 1944 07B0A0E1 		mov	fp, r7
 3019              	.LVL317:
 3020 1948 09A0A0E1 		mov	r10, r9
 3021 194c 084A9FE5 		ldr	r4, .L451+72
 3022 1950 EBFFFFEA 		b	.L294
 3023              	.LVL318:
 3024              	.L308:
1560:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3025              		.loc 1 1560 0
 3026 1954 0B10A0E1 		mov	r1, fp
 3027 1958 0C00A0E1 		mov	r0, ip
 3028              	.LVL319:
 3029 195c FEFFFFEB 		bl	SensorGetControl
 3030              	.LVL320:
1565:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3031              		.loc 1 1565 0
 3032 1960 F4499FE5 		ldr	r4, .L451+72
1561:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3033              		.loc 1 1561 0
 3034 1964 E8299FE5 		ldr	r2, .L451+64
1566:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3035              		.loc 1 1566 0
 3036 1968 0030A0E3 		mov	r3, #0
 3037 196c 2930C4E5 		strb	r3, [r4, #41]
 3038 1970 03A0A0E1 		mov	r10, r3
1568:../uvc.c      **** 					 case MFreqCtlID4:
 3039              		.loc 1 1568 0
 3040 1974 FF70A0E3 		mov	r7, #255
1565:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3041              		.loc 1 1565 0
 3042 1978 80B040E2 		sub	fp, r0, #128
 3043              	.LVL321:
 3044 197c FFB00BE2 		and	fp, fp, #255
1561:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3045              		.loc 1 1561 0
 3046 1980 6905C2E5 		strb	r0, [r2, #1385]
 3047 1984 0090A0E1 		mov	r9, r0
1565:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3048              		.loc 1 1565 0
 3049 1988 28B0C4E5 		strb	fp, [r4, #40]
 3050              	.LVL322:
1568:../uvc.c      **** 					 case MFreqCtlID4:
 3051              		.loc 1 1568 0
 3052 198c DCFFFFEA 		b	.L294
 3053              	.LVL323:
 3054              	.L307:
1580:../uvc.c      **** 							glEp0Buffer[0] = (Data0&0x80)>>7;
 3055              		.loc 1 1580 0
 3056 1990 0B10A0E1 		mov	r1, fp
 3057 1994 0100A0E3 		mov	r0, #1
 3058              	.LVL324:
 3059 1998 FEFFFFEB 		bl	SensorGetControl
 3060              	.LVL325:
1583:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
 3061              		.loc 1 1583 0
 3062 199c B0399FE5 		ldr	r3, .L451+64
1581:../uvc.c      **** 							//glEp0Buffer[0]++;
 3063              		.loc 1 1581 0
 3064 19a0 B4499FE5 		ldr	r4, .L451+72
 3065 19a4 00A0A0E3 		mov	r10, #0
 3066 19a8 A0B3A0E1 		mov	fp, r0, lsr #7
 3067              	.LVL326:
 3068 19ac FFB00BE2 		and	fp, fp, #255
1583:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
 3069              		.loc 1 1583 0
 3070 19b0 7DB5C3E5 		strb	fp, [r3, #1405]
1584:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3071              		.loc 1 1584 0
 3072 19b4 7E75D3E5 		ldrb	r7, [r3, #1406]	@ zero_extendqisi2
 3073 19b8 0090A0E1 		mov	r9, r0
 3074 19bc FF7007E2 		and	r7, r7, #255
 3075 19c0 2970C4E5 		strb	r7, [r4, #41]
 3076              	.LVL327:
1581:../uvc.c      **** 							//glEp0Buffer[0]++;
 3077              		.loc 1 1581 0
 3078 19c4 28B0C4E5 		strb	fp, [r4, #40]
1590:../uvc.c      **** 					 case WBTLevCtlID11:
 3079              		.loc 1 1590 0
 3080 19c8 CDFFFFEA 		b	.L294
 3081              	.LVL328:
 3082              	.L305:
1540:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3083              		.loc 1 1540 0
 3084 19cc 0B10A0E1 		mov	r1, fp
 3085 19d0 0C00A0E1 		mov	r0, ip
 3086              	.LVL329:
 3087 19d4 FEFFFFEB 		bl	SensorGetControl
 3088              	.LVL330:
1552:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3089              		.loc 1 1552 0
 3090 19d8 7C499FE5 		ldr	r4, .L451+72
1541:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3091              		.loc 1 1541 0
 3092 19dc 70299FE5 		ldr	r2, .L451+64
1553:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3093              		.loc 1 1553 0
 3094 19e0 0030A0E3 		mov	r3, #0
 3095 19e4 2930C4E5 		strb	r3, [r4, #41]
 3096 19e8 03A0A0E1 		mov	r10, r3
1555:../uvc.c      **** 					 case HueCtlID5:
 3097              		.loc 1 1555 0
 3098 19ec FF70A0E3 		mov	r7, #255
 3099 19f0 0090A0E1 		mov	r9, r0
1541:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3100              		.loc 1 1541 0
 3101 19f4 5505C2E5 		strb	r0, [r2, #1365]
 3102              	.LVL331:
1552:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3103              		.loc 1 1552 0
 3104 19f8 2800C4E5 		strb	r0, [r4, #40]
1555:../uvc.c      **** 					 case HueCtlID5:
 3105              		.loc 1 1555 0
 3106 19fc 00B0A0E1 		mov	fp, r0
 3107              	.LVL332:
 3108 1a00 BFFFFFEA 		b	.L294
 3109              	.LVL333:
 3110              	.L292:
1386:../uvc.c      **** 							if(Data0&0x80)
 3111              		.loc 1 1386 0
 3112 1a04 0B10A0E1 		mov	r1, fp
 3113 1a08 0C00A0E1 		mov	r0, ip
 3114              	.LVL334:
 3115 1a0c FEFFFFEB 		bl	SensorGetControl
 3116              	.LVL335:
 3117 1a10 44499FE5 		ldr	r4, .L451+72
1391:../uvc.c      **** 							glEp0Buffer[1] = 0; //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;ExUCtrlParArry[CtrlID-0x20][14];
 3118              		.loc 1 1391 0
 3119 1a14 38399FE5 		ldr	r3, .L451+64
1392:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3120              		.loc 1 1392 0
 3121 1a18 0070A0E3 		mov	r7, #0
 3122 1a1c 2970C4E5 		strb	r7, [r4, #41]
 3123 1a20 07A0A0E1 		mov	r10, r7
1387:../uvc.c      **** 								glEp0Buffer[0] = 1;
 3124              		.loc 1 1387 0
 3125 1a24 FFB000E2 		and	fp, r0, #255
 3126              	.LVL336:
 3127 1a28 ABB3A0E1 		mov	fp, fp, lsr #7
 3128              	.LVL337:
 3129 1a2c 0090A0E1 		mov	r9, r0
1391:../uvc.c      **** 							glEp0Buffer[1] = 0; //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;ExUCtrlParArry[CtrlID-0x20][14];
 3130              		.loc 1 1391 0
 3131 1a30 05B5C3E5 		strb	fp, [r3, #1285]
 3132 1a34 28B0C4E5 		strb	fp, [r4, #40]
1397:../uvc.c      **** 			 	 	 case ExtAexModCtlID9:
 3133              		.loc 1 1397 0
 3134 1a38 B1FFFFEA 		b	.L294
 3135              	.LVL338:
 3136              	.L291:
1461:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3137              		.loc 1 1461 0
 3138 1a3c 0B10A0E1 		mov	r1, fp
 3139 1a40 0C00A0E1 		mov	r0, ip
 3140              	.LVL339:
 3141 1a44 FEFFFFEB 		bl	SensorGetControl
 3142              	.LVL340:
 3143 1a48 0C499FE5 		ldr	r4, .L451+72
1462:../uvc.c      **** 	 	 				 glEp0Buffer[1] = SensorGetControl(RegAdd1, devAdd);
 3144              		.loc 1 1462 0
 3145 1a4c 00599FE5 		ldr	r5, .L451+64
1463:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 3146              		.loc 1 1463 0
 3147 1a50 0B10A0E1 		mov	r1, fp
1461:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3148              		.loc 1 1461 0
 3149 1a54 0030A0E1 		mov	r3, r0
1463:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 3150              		.loc 1 1463 0
 3151 1a58 20009DE5 		ldr	r0, [sp, #32]
1461:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3152              		.loc 1 1461 0
 3153 1a5c 2830C4E5 		strb	r3, [r4, #40]
1462:../uvc.c      **** 	 	 				 glEp0Buffer[1] = SensorGetControl(RegAdd1, devAdd);
 3154              		.loc 1 1462 0
 3155 1a60 4135C5E5 		strb	r3, [r5, #1345]
1463:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 3156              		.loc 1 1463 0
 3157 1a64 FEFFFFEB 		bl	SensorGetControl
 3158              	.LVL341:
 3159 1a68 28B0D4E5 		ldrb	fp, [r4, #40]	@ zero_extendqisi2
 3160              	.LVL342:
 3161 1a6c 0070A0E1 		mov	r7, r0
 3162 1a70 2900C4E5 		strb	r0, [r4, #41]
1464:../uvc.c      **** 	 	 				 sendData = glEp0Buffer[0];
 3163              		.loc 1 1464 0
 3164 1a74 4205C5E5 		strb	r0, [r5, #1346]
 3165              	.LVL343:
 3166              	.L422:
 3167 1a78 0090A0E3 		mov	r9, #0
 3168 1a7c 09A0A0E1 		mov	r10, r9
1467:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 3169              		.loc 1 1467 0
 3170 1a80 9FFFFFEA 		b	.L294
 3171              	.LVL344:
 3172              	.L293:
1451:../uvc.c      **** 			 	 		// sendData &= 0x70;
 3173              		.loc 1 1451 0
 3174 1a84 0B10A0E1 		mov	r1, fp
 3175 1a88 20009DE5 		ldr	r0, [sp, #32]
 3176              	.LVL345:
 3177 1a8c FEFFFFEB 		bl	SensorGetControl
 3178              	.LVL346:
1453:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3179              		.loc 1 1453 0
 3180 1a90 C4489FE5 		ldr	r4, .L451+72
1454:../uvc.c      **** 	 	 				 glEp0Buffer[1] = 0;
 3181              		.loc 1 1454 0
 3182 1a94 B8289FE5 		ldr	r2, .L451+64
1455:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 3183              		.loc 1 1455 0
 3184 1a98 0030A0E3 		mov	r3, #0
 3185 1a9c 2930C4E5 		strb	r3, [r4, #41]
1459:../uvc.c      **** 				 	 case Ext1BLCRangeCtlID4:
 3186              		.loc 1 1459 0
 3187 1aa0 0370A0E1 		mov	r7, r3
 3188 1aa4 0390A0E1 		mov	r9, r3
 3189 1aa8 03A0A0E1 		mov	r10, r3
1453:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3190              		.loc 1 1453 0
 3191 1aac 2002A0E1 		mov	r0, r0, lsr #4
 3192              	.LVL347:
 3193 1ab0 FFB000E2 		and	fp, r0, #255
 3194              	.LVL348:
1454:../uvc.c      **** 	 	 				 glEp0Buffer[1] = 0;
 3195              		.loc 1 1454 0
 3196 1ab4 2DB5C2E5 		strb	fp, [r2, #1325]
1453:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3197              		.loc 1 1453 0
 3198 1ab8 28B0C4E5 		strb	fp, [r4, #40]
1456:../uvc.c      **** 	 	 				 sendData = glEp0Buffer[0];
 3199              		.loc 1 1456 0
 3200 1abc 2E35C2E5 		strb	r3, [r2, #1326]
 3201              	.LVL349:
1459:../uvc.c      **** 				 	 case Ext1BLCRangeCtlID4:
 3202              		.loc 1 1459 0
 3203 1ac0 8FFFFFEA 		b	.L294
 3204              	.LVL350:
 3205              	.L287:
1403:../uvc.c      **** 			 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // 1:0 for Aex Mode
 3206              		.loc 1 1403 0
 3207 1ac4 0C00A0E1 		mov	r0, ip
 3208              	.LVL351:
 3209 1ac8 0B10A0E1 		mov	r1, fp
 3210 1acc FEFFFFEB 		bl	SensorGetControl
 3211              	.LVL352:
1404:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3212              		.loc 1 1404 0
 3213 1ad0 84489FE5 		ldr	r4, .L451+72
1405:../uvc.c      **** 
 3214              		.loc 1 1405 0
 3215 1ad4 78589FE5 		ldr	r5, .L451+64
1407:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 3216              		.loc 1 1407 0
 3217 1ad8 0B10A0E1 		mov	r1, fp
 3218 1adc 0090A0E3 		mov	r9, #0
 3219 1ae0 09A0A0E1 		mov	r10, r9
1404:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3220              		.loc 1 1404 0
 3221 1ae4 033000E2 		and	r3, r0, #3
1407:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 3222              		.loc 1 1407 0
 3223 1ae8 20009DE5 		ldr	r0, [sp, #32]
1404:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3224              		.loc 1 1404 0
 3225 1aec 2830C4E5 		strb	r3, [r4, #40]
1405:../uvc.c      **** 
 3226              		.loc 1 1405 0
 3227 1af0 1935C5E5 		strb	r3, [r5, #1305]
1407:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 3228              		.loc 1 1407 0
 3229 1af4 FEFFFFEB 		bl	SensorGetControl
 3230              	.LVL353:
1415:../uvc.c      **** 						 break;
 3231              		.loc 1 1415 0
 3232 1af8 28B0D4E5 		ldrb	fp, [r4, #40]	@ zero_extendqisi2
 3233              	.LVL354:
 3234 1afc 0930A0E1 		mov	r3, r9
 3235 1b00 04908DE5 		str	r9, [sp, #4]
 3236 1b04 0B20A0E1 		mov	r2, fp
 3237 1b08 18189FE5 		ldr	r1, .L451+20
1407:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 3238              		.loc 1 1407 0
 3239 1b0c 00E0A0E1 		mov	lr, r0
1415:../uvc.c      **** 						 break;
 3240              		.loc 1 1415 0
 3241 1b10 00008DE5 		str	r0, [sp]
 3242 1b14 0070A0E1 		mov	r7, r0
1407:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 3243              		.loc 1 1407 0
 3244 1b18 2AE0C4E5 		strb	lr, [r4, #42]
1408:../uvc.c      **** 			 	 			//curFlag[CtrlID] = CyTrue;
 3245              		.loc 1 1408 0
 3246 1b1c 1AE5C5E5 		strb	lr, [r5, #1306]
1411:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 3247              		.loc 1 1411 0
 3248 1b20 2990C4E5 		strb	r9, [r4, #41]
1412:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3249              		.loc 1 1412 0
 3250 1b24 2B90C4E5 		strb	r9, [r4, #43]
 3251              	.LVL355:
1415:../uvc.c      **** 						 break;
 3252              		.loc 1 1415 0
 3253 1b28 0400A0E3 		mov	r0, #4
 3254              	.LVL356:
 3255 1b2c FEFFFFEB 		bl	CyU3PDebugPrint
 3256              	.LVL357:
1416:../uvc.c      **** 				 	 case ExtCamMCtlID12: //EXTCamMode
 3257              		.loc 1 1416 0
 3258 1b30 73FFFFEA 		b	.L294
 3259              	.LVL358:
 3260              	.L290:
1435:../uvc.c      **** 				 			glEp0Buffer[idx] = I2CCMDArry[idx];
 3261              		.loc 1 1435 0 discriminator 1
 3262 1b34 000058E3 		cmp	r8, #0
 3263 1b38 0300000A 		beq	.L298
 3264 1b3c D8079FE5 		ldr	r0, .L451+8
 3265              	.LVL359:
 3266 1b40 0820A0E1 		mov	r2, r8
 3267 1b44 6C1080E2 		add	r1, r0, #108
 3268 1b48 FEFFFFEB 		bl	memcpy
 3269              	.LVL360:
 3270              	.L298:
1438:../uvc.c      **** 				 		 sendData1 = glEp0Buffer[10];
 3271              		.loc 1 1438 0
 3272 1b4c 08489FE5 		ldr	r4, .L451+72
1445:../uvc.c      **** 				 		 {
 3273              		.loc 1 1445 0
 3274 1b50 9F30D4E5 		ldrb	r3, [r4, #159]	@ zero_extendqisi2
1438:../uvc.c      **** 				 		 sendData1 = glEp0Buffer[10];
 3275              		.loc 1 1438 0
 3276 1b54 31B0D4E5 		ldrb	fp, [r4, #49]	@ zero_extendqisi2
 3277              	.LVL361:
1445:../uvc.c      **** 				 		 {
 3278              		.loc 1 1445 0
 3279 1b58 FF0053E3 		cmp	r3, #255
1439:../uvc.c      **** 	#ifdef USB_DEBUG_PRINT
 3280              		.loc 1 1439 0
 3281 1b5c 3270D4E5 		ldrb	r7, [r4, #50]	@ zero_extendqisi2
 3282              	.LVL362:
1445:../uvc.c      **** 				 		 {
 3283              		.loc 1 1445 0
 3284 1b60 C4FFFF0A 		beq	.L422
1447:../uvc.c      **** 				 		 }
 3285              		.loc 1 1447 0
 3286 1b64 0400A0E3 		mov	r0, #4
 3287 1b68 BC179FE5 		ldr	r1, .L451+24
 3288 1b6c 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 3289 1b70 9E30D4E5 		ldrb	r3, [r4, #158]	@ zero_extendqisi2
 3290 1b74 FEFFFFEB 		bl	CyU3PDebugPrint
 3291              	.LVL363:
 3292 1b78 0090A0E3 		mov	r9, #0
 3293 1b7c 09A0A0E1 		mov	r10, r9
 3294 1b80 5FFFFFEA 		b	.L294
 3295              	.LVL364:
 3296              	.L374:
2175:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3297              		.loc 1 2175 0
 3298 1b84 CC479FE5 		ldr	r4, .L451+68
 3299 1b88 0010E0E3 		mvn	r1, #0
 3300 1b8c 1C0094E5 		ldr	r0, [r4, #28]
 3301 1b90 18C08DE5 		str	ip, [sp, #24]
 3302 1b94 FEFFFFEB 		bl	_txe_mutex_get
 3303              	.LVL365:
2176:../uvc.c      **** 							 dataIdx++;
 3304              		.loc 1 2176 0
 3305 1b98 24109DE5 		ldr	r1, [sp, #36]
 3306 1b9c 18C09DE5 		ldr	ip, [sp, #24]
 3307 1ba0 0030A0E3 		mov	r3, #0
 3308 1ba4 0C20A0E1 		mov	r2, ip
 3309 1ba8 00108DE5 		str	r1, [sp]
 3310 1bac 04308DE5 		str	r3, [sp, #4]
 3311 1bb0 0B10A0E3 		mov	r1, #11
 3312 1bb4 0B30A0E1 		mov	r3, fp
 3313 1bb8 0400A0E1 		mov	r0, r4
 3314 1bbc FEFFFFEB 		bl	cmdSet
 3315              	.LVL366:
2178:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3316              		.loc 1 2178 0
 3317 1bc0 28C09DE5 		ldr	ip, [sp, #40]
 3318 1bc4 0180A0E3 		mov	r8, #1
 3319              	.LVL367:
 3320 1bc8 0B30A0E1 		mov	r3, fp
 3321 1bcc 00C08DE5 		str	ip, [sp]
 3322 1bd0 20209DE5 		ldr	r2, [sp, #32]
 3323 1bd4 0B10A0E3 		mov	r1, #11
 3324 1bd8 0400A0E1 		mov	r0, r4
 3325 1bdc 04808DE5 		str	r8, [sp, #4]
 3326 1be0 FEFFFFEB 		bl	cmdSet
 3327              	.LVL368:
2179:../uvc.c      **** 
 3328              		.loc 1 2179 0
 3329 1be4 1C0094E5 		ldr	r0, [r4, #28]
 3330 1be8 FEFFFFEB 		bl	_txe_mutex_put
 3331              	.LVL369:
2181:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3332              		.loc 1 2181 0
 3333 1bec 60379FE5 		ldr	r3, .L451+64
 3334 1bf0 24C09DE5 		ldr	ip, [sp, #36]
2183:../uvc.c      **** 							 break;
 3335              		.loc 1 2183 0
 3336 1bf4 055187E0 		add	r5, r7, r5, asl #2
 3337 1bf8 202195E5 		ldr	r2, [r5, #288]
2181:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3338              		.loc 1 2181 0
 3339 1bfc 84C5C3E5 		strb	ip, [r3, #1412]
2182:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3340              		.loc 1 2182 0
 3341 1c00 28C09DE5 		ldr	ip, [sp, #40]
2184:../uvc.c      **** 						 case BLCCtlID0:
 3342              		.loc 1 2184 0
 3343 1c04 FF70A0E3 		mov	r7, #255
2183:../uvc.c      **** 							 break;
 3344              		.loc 1 2183 0
 3345 1c08 1180C2E5 		strb	r8, [r2, #17]
2182:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3346              		.loc 1 2182 0
 3347 1c0c 86C5C3E5 		strb	ip, [r3, #1414]
2184:../uvc.c      **** 						 case BLCCtlID0:
 3348              		.loc 1 2184 0
 3349 1c10 07B0A0E1 		mov	fp, r7
 3350              	.LVL370:
 3351 1c14 6AFEFFEA 		b	.L284
 3352              	.LVL371:
 3353              	.L373:
2207:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3354              		.loc 1 2207 0
 3355 1c18 24209DE5 		ldr	r2, [sp, #36]
2206:../uvc.c      **** 							 if(Data0 != 0){
 3356              		.loc 1 2206 0
 3357 1c1c 055187E0 		add	r5, r7, r5, asl #2
 3358 1c20 205195E5 		ldr	r5, [r5, #288]
2208:../uvc.c      **** 	#ifdef COLOR
 3359              		.loc 1 2208 0
 3360 1c24 2C479FE5 		ldr	r4, .L451+68
2207:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3361              		.loc 1 2207 0
 3362 1c28 000052E3 		cmp	r2, #0
2206:../uvc.c      **** 							 if(Data0 != 0){
 3363              		.loc 1 2206 0
 3364 1c2c 0D20C5E5 		strb	r2, [r5, #13]
2208:../uvc.c      **** 	#ifdef COLOR
 3365              		.loc 1 2208 0
 3366 1c30 0010E0E3 		mvn	r1, #0
 3367 1c34 1C0094E5 		ldr	r0, [r4, #28]
 3368 1c38 18C08DE5 		str	ip, [sp, #24]
2207:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3369              		.loc 1 2207 0
 3370 1c3c 5D02000A 		beq	.L390
2208:../uvc.c      **** 	#ifdef COLOR
 3371              		.loc 1 2208 0
 3372 1c40 FEFFFFEB 		bl	_txe_mutex_get
 3373              	.LVL372:
2212:../uvc.c      **** 								 dataIdx++;
 3374              		.loc 1 2212 0
 3375 1c44 18C09DE5 		ldr	ip, [sp, #24]
 3376 1c48 0170A0E3 		mov	r7, #1
 3377 1c4c 0030A0E3 		mov	r3, #0
 3378 1c50 0C20A0E1 		mov	r2, ip
 3379 1c54 04308DE5 		str	r3, [sp, #4]
 3380 1c58 0400A0E1 		mov	r0, r4
 3381 1c5c 00708DE5 		str	r7, [sp]
 3382 1c60 0710A0E3 		mov	r1, #7
 3383 1c64 0B30A0E1 		mov	r3, fp
 3384 1c68 FEFFFFEB 		bl	cmdSet
 3385              	.LVL373:
2214:../uvc.c      **** 	#endif
 3386              		.loc 1 2214 0
 3387 1c6c 24C09DE5 		ldr	ip, [sp, #36]
 3388 1c70 20209DE5 		ldr	r2, [sp, #32]
 3389 1c74 04708DE5 		str	r7, [sp, #4]
 3390 1c78 00C08DE5 		str	ip, [sp]
 3391              	.LVL374:
 3392              	.L425:
2219:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3393              		.loc 1 2219 0
 3394 1c7c 0B30A0E1 		mov	r3, fp
 3395 1c80 0710A0E3 		mov	r1, #7
 3396 1c84 0400A0E1 		mov	r0, r4
 3397 1c88 FEFFFFEB 		bl	cmdSet
 3398              	.LVL375:
2220:../uvc.c      **** 							 }
 3399              		.loc 1 2220 0
 3400 1c8c 1C0094E5 		ldr	r0, [r4, #28]
 3401 1c90 FEFFFFEB 		bl	_txe_mutex_put
 3402              	.LVL376:
2223:../uvc.c      **** 						 case ConsCtlID2:
 3403              		.loc 1 2223 0
 3404 1c94 FF70A0E3 		mov	r7, #255
2222:../uvc.c      **** 							 break;
 3405              		.loc 1 2222 0
 3406 1c98 0130A0E3 		mov	r3, #1
 3407 1c9c 1130C5E5 		strb	r3, [r5, #17]
 3408              	.LVL377:
2223:../uvc.c      **** 						 case ConsCtlID2:
 3409              		.loc 1 2223 0
 3410 1ca0 07B0A0E1 		mov	fp, r7
 3411              	.LVL378:
 3412 1ca4 46FEFFEA 		b	.L284
 3413              	.LVL379:
 3414              	.L372:
2110:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 3415              		.loc 1 2110 0
 3416 1ca8 A8869FE5 		ldr	r8, .L451+68
 3417              	.LVL380:
 3418 1cac 0010E0E3 		mvn	r1, #0
 3419 1cb0 1C0098E5 		ldr	r0, [r8, #28]
 3420 1cb4 18C08DE5 		str	ip, [sp, #24]
 3421 1cb8 FEFFFFEB 		bl	_txe_mutex_get
 3422              	.LVL381:
2111:../uvc.c      **** 							 dataIdx++;
 3423              		.loc 1 2111 0
 3424 1cbc 24209DE5 		ldr	r2, [sp, #36]
 3425 1cc0 18C09DE5 		ldr	ip, [sp, #24]
 3426 1cc4 801042E2 		sub	r1, r2, #128
 3427 1cc8 FF1001E2 		and	r1, r1, #255
 3428 1ccc 0030A0E3 		mov	r3, #0
 3429 1cd0 0C20A0E1 		mov	r2, ip
 3430 1cd4 00108DE5 		str	r1, [sp]
 3431 1cd8 04308DE5 		str	r3, [sp, #4]
 3432 1cdc 0510A0E3 		mov	r1, #5
 3433 1ce0 0B30A0E1 		mov	r3, fp
 3434 1ce4 0800A0E1 		mov	r0, r8
 3435 1ce8 FEFFFFEB 		bl	cmdSet
 3436              	.LVL382:
2113:../uvc.c      **** 							 dataIdx++;
 3437              		.loc 1 2113 0
 3438 1cec 24C09DE5 		ldr	ip, [sp, #36]
 3439 1cf0 0510A0E3 		mov	r1, #5
 3440 1cf4 76304CE2 		sub	r3, ip, #118
 3441 1cf8 FF3003E2 		and	r3, r3, #255
 3442 1cfc 01C0A0E3 		mov	ip, #1
 3443 1d00 04C08DE5 		str	ip, [sp, #4]
 3444 1d04 00308DE5 		str	r3, [sp]
 3445 1d08 DC20A0E3 		mov	r2, #220
 3446 1d0c 0B30A0E1 		mov	r3, fp
 3447 1d10 0800A0E1 		mov	r0, r8
 3448 1d14 18C08DE5 		str	ip, [sp, #24]
 3449 1d18 FEFFFFEB 		bl	cmdSet
 3450              	.LVL383:
2115:../uvc.c      **** 							 dataIdx++;
 3451              		.loc 1 2115 0
 3452 1d1c 24109DE5 		ldr	r1, [sp, #36]
 3453 1d20 0230A0E3 		mov	r3, #2
 3454 1d24 7E2081E2 		add	r2, r1, #126
 3455 1d28 FF2002E2 		and	r2, r2, #255
 3456 1d2c 00208DE5 		str	r2, [sp]
 3457 1d30 04308DE5 		str	r3, [sp, #4]
 3458 1d34 0510A0E3 		mov	r1, #5
 3459 1d38 0B30A0E1 		mov	r3, fp
 3460 1d3c DE20A0E3 		mov	r2, #222
 3461 1d40 0800A0E1 		mov	r0, r8
 3462 1d44 FEFFFFEB 		bl	cmdSet
 3463              	.LVL384:
2117:../uvc.c      **** 							 dataIdx++;
 3464              		.loc 1 2117 0
 3465 1d48 24309DE5 		ldr	r3, [sp, #36]
 3466 1d4c 0510A0E3 		mov	r1, #5
 3467 1d50 722083E2 		add	r2, r3, #114
 3468 1d54 FF2002E2 		and	r2, r2, #255
 3469 1d58 0330A0E3 		mov	r3, #3
 3470 1d5c 00208DE5 		str	r2, [sp]
 3471 1d60 04308DE5 		str	r3, [sp, #4]
 3472 1d64 E020A0E3 		mov	r2, #224
 3473 1d68 0B30A0E1 		mov	r3, fp
 3474 1d6c 0800A0E1 		mov	r0, r8
 3475 1d70 FEFFFFEB 		bl	cmdSet
 3476              	.LVL385:
2119:../uvc.c      **** 							 dataIdx++;
 3477              		.loc 1 2119 0
 3478 1d74 24109DE5 		ldr	r1, [sp, #36]
 3479 1d78 0430A0E3 		mov	r3, #4
 3480 1d7c 6F2041E2 		sub	r2, r1, #111
 3481 1d80 FF2002E2 		and	r2, r2, #255
 3482 1d84 00208DE5 		str	r2, [sp]
 3483 1d88 04308DE5 		str	r3, [sp, #4]
 3484 1d8c 0510A0E3 		mov	r1, #5
 3485 1d90 0B30A0E1 		mov	r3, fp
 3486 1d94 DD20A0E3 		mov	r2, #221
 3487 1d98 0800A0E1 		mov	r0, r8
 3488 1d9c FEFFFFEB 		bl	cmdSet
 3489              	.LVL386:
2121:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3490              		.loc 1 2121 0
 3491 1da0 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
 3492 1da4 0510A0E3 		mov	r1, #5
 3493 1da8 7F0080E2 		add	r0, r0, #127
 3494 1dac FF0000E2 		and	r0, r0, #255
 3495 1db0 0B30A0E1 		mov	r3, fp
 3496 1db4 20209DE5 		ldr	r2, [sp, #32]
 3497 1db8 00008DE5 		str	r0, [sp]
 3498 1dbc 04108DE5 		str	r1, [sp, #4]
 3499 1dc0 0800A0E1 		mov	r0, r8
 3500 1dc4 FEFFFFEB 		bl	cmdSet
 3501              	.LVL387:
2122:../uvc.c      **** 
 3502              		.loc 1 2122 0
 3503 1dc8 1C0098E5 		ldr	r0, [r8, #28]
 3504 1dcc FEFFFFEB 		bl	_txe_mutex_put
 3505              	.LVL388:
2124:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3506              		.loc 1 2124 0
 3507 1dd0 2820D4E5 		ldrb	r2, [r4, #40]	@ zero_extendqisi2
 3508 1dd4 055187E0 		add	r5, r7, r5, asl #2
 3509 1dd8 203195E5 		ldr	r3, [r5, #288]
 3510 1ddc 802042E2 		sub	r2, r2, #128
 3511 1de0 FF2002E2 		and	r2, r2, #255
 3512 1de4 0D20C3E5 		strb	r2, [r3, #13]
2125:../uvc.c      **** 							 break;
 3513              		.loc 1 2125 0
 3514 1de8 18C09DE5 		ldr	ip, [sp, #24]
2126:../uvc.c      **** 						 case MFreqCtlID4:
 3515              		.loc 1 2126 0
 3516 1dec FF70A0E3 		mov	r7, #255
 3517 1df0 07B0A0E1 		mov	fp, r7
 3518              	.LVL389:
2125:../uvc.c      **** 							 break;
 3519              		.loc 1 2125 0
 3520 1df4 11C0C3E5 		strb	ip, [r3, #17]
2126:../uvc.c      **** 						 case MFreqCtlID4:
 3521              		.loc 1 2126 0
 3522 1df8 F1FDFFEA 		b	.L284
 3523              	.LVL390:
 3524              	.L371:
2136:../uvc.c      **** 							 {
 3525              		.loc 1 2136 0
 3526 1dfc 24C09DE5 		ldr	ip, [sp, #36]
2128:../uvc.c      **** 							 //Data0 = Data0 - 1;
 3527              		.loc 1 2128 0
 3528 1e00 055187E0 		add	r5, r7, r5, asl #2
2136:../uvc.c      **** 							 {
 3529              		.loc 1 2136 0
 3530 1e04 02005CE3 		cmp	ip, #2
2128:../uvc.c      **** 							 //Data0 = Data0 - 1;
 3531              		.loc 1 2128 0
 3532 1e08 208195E5 		ldr	r8, [r5, #288]
 3533              	.LVL391:
2130:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 3534              		.loc 1 2130 0
 3535 1e0c 48359FE5 		ldr	r3, .L451+72
2139:../uvc.c      **** 							 }
 3536              		.loc 1 2139 0
 3537 1e10 0120A083 		movhi	r2, #1
 3538 1e14 0290A081 		movhi	r9, r2
2128:../uvc.c      **** 							 //Data0 = Data0 - 1;
 3539              		.loc 1 2128 0
 3540 1e18 0DC0C8E5 		strb	ip, [r8, #13]
2141:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3541              		.loc 1 2141 0
 3542 1e1c 0400A0E3 		mov	r0, #4
2130:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 3543              		.loc 1 2130 0
 3544 1e20 6CC084E5 		str	ip, [r4, #108]
 3545              	.LVL392:
2141:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3546              		.loc 1 2141 0
 3547 1e24 04159FE5 		ldr	r1, .L451+28
2139:../uvc.c      **** 							 }
 3548              		.loc 1 2139 0
 3549 1e28 6C208385 		strhi	r2, [r3, #108]
 3550              	.LVL393:
2141:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3551              		.loc 1 2141 0
 3552 1e2c 0920A0E1 		mov	r2, r9
 3553 1e30 6C3094E5 		ldr	r3, [r4, #108]
 3554 1e34 FEFFFFEB 		bl	CyU3PDebugPrint
 3555              	.LVL394:
2142:../uvc.c      **** 							 {
 3556              		.loc 1 2142 0
 3557 1e38 883094E5 		ldr	r3, [r4, #136]
2141:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3558              		.loc 1 2141 0
 3559 1e3c 18259FE5 		ldr	r2, .L451+72
2142:../uvc.c      **** 							 {
 3560              		.loc 1 2142 0
 3561 1e40 010053E3 		cmp	r3, #1
 3562 1e44 FE01000A 		beq	.L442
 3563              	.L376:
2170:../uvc.c      **** 							 break;
 3564              		.loc 1 2170 0
 3565 1e48 0130A0E3 		mov	r3, #1
2171:../uvc.c      **** 						 case WBTLevCtlID11: //4bytes
 3566              		.loc 1 2171 0
 3567 1e4c FF70A0E3 		mov	r7, #255
2170:../uvc.c      **** 							 break;
 3568              		.loc 1 2170 0
 3569 1e50 1130C8E5 		strb	r3, [r8, #17]
2171:../uvc.c      **** 						 case WBTLevCtlID11: //4bytes
 3570              		.loc 1 2171 0
 3571 1e54 07B0A0E1 		mov	fp, r7
 3572              	.LVL395:
 3573 1e58 D9FDFFEA 		b	.L284
 3574              	.LVL396:
 3575              	.L370:
2094:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
 3576              		.loc 1 2094 0
 3577 1e5c F4449FE5 		ldr	r4, .L451+68
 3578 1e60 0010E0E3 		mvn	r1, #0
 3579 1e64 1C0094E5 		ldr	r0, [r4, #28]
 3580 1e68 FEFFFFEB 		bl	_txe_mutex_get
 3581              	.LVL397:
2103:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3582              		.loc 1 2103 0
 3583 1e6c 24C09DE5 		ldr	ip, [sp, #36]
 3584 1e70 0010A0E3 		mov	r1, #0
 3585 1e74 0B30A0E1 		mov	r3, fp
 3586 1e78 00C08DE5 		str	ip, [sp]
 3587 1e7c 20209DE5 		ldr	r2, [sp, #32]
 3588 1e80 04108DE5 		str	r1, [sp, #4]
 3589 1e84 0400A0E1 		mov	r0, r4
 3590 1e88 0110A0E3 		mov	r1, #1
 3591 1e8c FEFFFFEB 		bl	cmdSet
 3592              	.LVL398:
2106:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3593              		.loc 1 2106 0
 3594 1e90 055187E0 		add	r5, r7, r5, asl #2
2104:../uvc.c      **** 
 3595              		.loc 1 2104 0
 3596 1e94 1C0094E5 		ldr	r0, [r4, #28]
 3597 1e98 FEFFFFEB 		bl	_txe_mutex_put
 3598              	.LVL399:
2106:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3599              		.loc 1 2106 0
 3600 1e9c 203195E5 		ldr	r3, [r5, #288]
 3601 1ea0 24C09DE5 		ldr	ip, [sp, #36]
2107:../uvc.c      **** 							 break;
 3602              		.loc 1 2107 0
 3603 1ea4 0120A0E3 		mov	r2, #1
2108:../uvc.c      **** 						 case HueCtlID5://not being used
 3604              		.loc 1 2108 0
 3605 1ea8 FF70A0E3 		mov	r7, #255
2106:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3606              		.loc 1 2106 0
 3607 1eac 0DC0C3E5 		strb	ip, [r3, #13]
2108:../uvc.c      **** 						 case HueCtlID5://not being used
 3608              		.loc 1 2108 0
 3609 1eb0 07B0A0E1 		mov	fp, r7
 3610              	.LVL400:
2107:../uvc.c      **** 							 break;
 3611              		.loc 1 2107 0
 3612 1eb4 1120C3E5 		strb	r2, [r3, #17]
 3613              	.LVL401:
2108:../uvc.c      **** 						 case HueCtlID5://not being used
 3614              		.loc 1 2108 0
 3615 1eb8 C1FDFFEA 		b	.L284
 3616              	.LVL402:
 3617              	.L368:
2186:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3618              		.loc 1 2186 0
 3619 1ebc 055187E0 		add	r5, r7, r5, asl #2
 3620 1ec0 24109DE5 		ldr	r1, [sp, #36]
2196:../uvc.c      **** 					 		 }
 3621              		.loc 1 2196 0
 3622 1ec4 88349FE5 		ldr	r3, .L451+64
2186:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3623              		.loc 1 2186 0
 3624 1ec8 205195E5 		ldr	r5, [r5, #288]
2199:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3625              		.loc 1 2199 0
 3626 1ecc 84449FE5 		ldr	r4, .L451+68
2186:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3627              		.loc 1 2186 0
 3628 1ed0 0D10C5E5 		strb	r1, [r5, #13]
2196:../uvc.c      **** 					 		 }
 3629              		.loc 1 2196 0
 3630 1ed4 0595D3E5 		ldrb	r9, [r3, #1285]	@ zero_extendqisi2
2199:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3631              		.loc 1 2199 0
 3632 1ed8 1C0094E5 		ldr	r0, [r4, #28]
2196:../uvc.c      **** 					 		 }
 3633              		.loc 1 2196 0
 3634 1edc 899381E1 		orr	r9, r1, r9, asl #7
2199:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3635              		.loc 1 2199 0
 3636 1ee0 0010E0E3 		mvn	r1, #0
 3637 1ee4 18C08DE5 		str	ip, [sp, #24]
 3638 1ee8 FEFFFFEB 		bl	_txe_mutex_get
 3639              	.LVL403:
2200:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3640              		.loc 1 2200 0
 3641 1eec 18C09DE5 		ldr	ip, [sp, #24]
2196:../uvc.c      **** 					 		 }
 3642              		.loc 1 2196 0
 3643 1ef0 FF9009E2 		and	r9, r9, #255
 3644              	.LVL404:
2200:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3645              		.loc 1 2200 0
 3646 1ef4 0010A0E3 		mov	r1, #0
 3647 1ef8 0C20A0E1 		mov	r2, ip
 3648 1efc 0B30A0E1 		mov	r3, fp
 3649 1f00 0400A0E1 		mov	r0, r4
 3650 1f04 00908DE5 		str	r9, [sp]
 3651 1f08 04108DE5 		str	r1, [sp, #4]
 3652              	.LVL405:
 3653              	.L426:
 3654 1f0c FEFFFFEB 		bl	cmdSet
 3655              	.LVL406:
2201:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3656              		.loc 1 2201 0
 3657 1f10 1C0094E5 		ldr	r0, [r4, #28]
 3658 1f14 FEFFFFEB 		bl	_txe_mutex_put
 3659              	.LVL407:
2203:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
 3660              		.loc 1 2203 0
 3661 1f18 FF70A0E3 		mov	r7, #255
2202:../uvc.c      **** 					 		 break;
 3662              		.loc 1 2202 0
 3663 1f1c 0130A0E3 		mov	r3, #1
 3664 1f20 1130C5E5 		strb	r3, [r5, #17]
 3665              	.LVL408:
2203:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
 3666              		.loc 1 2203 0
 3667 1f24 07B0A0E1 		mov	fp, r7
 3668              	.LVL409:
 3669 1f28 A5FDFFEA 		b	.L284
 3670              	.LVL410:
 3671              	.L304:
1632:../uvc.c      **** 			 	 			 if(Len == 2)
 3672              		.loc 1 1632 0
 3673 1f2c 007087E0 		add	r7, r7, r0
 3674 1f30 6031D7E5 		ldrb	r3, [r7, #352]	@ zero_extendqisi2
 3675 1f34 0C449FE5 		ldr	r4, .L451+52
 3676 1f38 000053E3 		cmp	r3, #0
 3677 1f3c 6301000A 		beq	.L311
1633:../uvc.c      **** 			 	 			 {
 3678              		.loc 1 1633 0
 3679 1f40 020058E3 		cmp	r8, #2
 3680 1f44 5B02000A 		beq	.L443
1639:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 3681              		.loc 1 1639 0
 3682 1f48 040058E3 		cmp	r8, #4
 3683 1f4c 7AFEFF1A 		bne	.L303
1640:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 3684              		.loc 1 1640 0
 3685 1f50 004184E0 		add	r4, r4, r0, asl #2
 3686 1f54 202194E5 		ldr	r2, [r4, #288]
 3687              	.L421:
 3688 1f58 0DB0D2E5 		ldrb	fp, [r2, #13]	@ zero_extendqisi2
 3689              	.LVL411:
 3690 1f5c F8439FE5 		ldr	r4, .L451+72
1641:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3691              		.loc 1 1641 0
 3692 1f60 0030A0E3 		mov	r3, #0
1640:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 3693              		.loc 1 1640 0
 3694 1f64 FFB00BE2 		and	fp, fp, #255
 3695 1f68 28B0C4E5 		strb	fp, [r4, #40]
1641:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3696              		.loc 1 1641 0
 3697 1f6c 2930C4E5 		strb	r3, [r4, #41]
1642:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 3698              		.loc 1 1642 0
 3699 1f70 0E70D2E5 		ldrb	r7, [r2, #14]	@ zero_extendqisi2
 3700 1f74 0390A0E1 		mov	r9, r3
 3701 1f78 FF7007E2 		and	r7, r7, #255
 3702 1f7c 2A70C4E5 		strb	r7, [r4, #42]
1643:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 3703              		.loc 1 1643 0
 3704 1f80 2B30C4E5 		strb	r3, [r4, #43]
 3705              	.LVL412:
 3706 1f84 03A0A0E1 		mov	r10, r3
 3707 1f88 5DFEFFEA 		b	.L294
 3708              	.LVL413:
 3709              	.L398:
1839:../uvc.c      **** 					 {
 3710              		.loc 1 1839 0
 3711 1f8c FF70A0E3 		mov	r7, #255
 3712 1f90 07B0A0E1 		mov	fp, r7
 3713              	.LVL414:
 3714 1f94 8AFDFFEA 		b	.L284
 3715              	.LVL415:
 3716              	.L342:
1871:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 3717              		.loc 1 1871 0
 3718 1f98 B8539FE5 		ldr	r5, .L451+68
 3719 1f9c 0010E0E3 		mvn	r1, #0
 3720 1fa0 1C0095E5 		ldr	r0, [r5, #28]
 3721 1fa4 18C08DE5 		str	ip, [sp, #24]
 3722 1fa8 FEFFFFEB 		bl	_txe_mutex_get
 3723              	.LVL416:
1872:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3724              		.loc 1 1872 0
 3725 1fac 18C09DE5 		ldr	ip, [sp, #24]
 3726 1fb0 24309DE5 		ldr	r3, [sp, #36]
 3727 1fb4 0080A0E3 		mov	r8, #0
 3728              	.LVL417:
 3729 1fb8 0C20A0E1 		mov	r2, ip
 3730 1fbc 00308DE5 		str	r3, [sp]
 3731 1fc0 1E10A0E3 		mov	r1, #30
 3732 1fc4 0B30A0E1 		mov	r3, fp
 3733 1fc8 0500A0E1 		mov	r0, r5
 3734 1fcc 04808DE5 		str	r8, [sp, #4]
 3735 1fd0 FEFFFFEB 		bl	cmdSet
 3736              	.LVL418:
1874:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 3737              		.loc 1 1874 0
 3738 1fd4 044187E0 		add	r4, r7, r4, asl #2
1873:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 3739              		.loc 1 1873 0
 3740 1fd8 1C0095E5 		ldr	r0, [r5, #28]
 3741 1fdc FEFFFFEB 		bl	_txe_mutex_put
 3742              	.LVL419:
1874:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 3743              		.loc 1 1874 0
 3744 1fe0 203094E5 		ldr	r3, [r4, #32]
 3745 1fe4 24C09DE5 		ldr	ip, [sp, #36]
1876:../uvc.c      **** 							 break;
 3746              		.loc 1 1876 0
 3747 1fe8 0120A0E3 		mov	r2, #1
1877:../uvc.c      **** 					 	 case ExtI2CCtlID15:
 3748              		.loc 1 1877 0
 3749 1fec FF70A0E3 		mov	r7, #255
1874:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 3750              		.loc 1 1874 0
 3751 1ff0 0DC0C3E5 		strb	ip, [r3, #13]
1877:../uvc.c      **** 					 	 case ExtI2CCtlID15:
 3752              		.loc 1 1877 0
 3753 1ff4 07B0A0E1 		mov	fp, r7
 3754              	.LVL420:
1875:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
 3755              		.loc 1 1875 0
 3756 1ff8 0E80C3E5 		strb	r8, [r3, #14]
1876:../uvc.c      **** 							 break;
 3757              		.loc 1 1876 0
 3758 1ffc 1120C3E5 		strb	r2, [r3, #17]
 3759              	.LVL421:
1877:../uvc.c      **** 					 	 case ExtI2CCtlID15:
 3760              		.loc 1 1877 0
 3761 2000 6FFDFFEA 		b	.L284
 3762              	.LVL422:
 3763              	.L346:
2013:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 3764              		.loc 1 2013 0
 3765 2004 044187E0 		add	r4, r7, r4, asl #2
 3766 2008 207094E5 		ldr	r7, [r4, #32]
 3767 200c 24109DE5 		ldr	r1, [sp, #36]
 3768 2010 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 3769 2014 010053E1 		cmp	r3, r1
 3770 2018 2100000A 		beq	.L361
2014:../uvc.c      **** 								 Data1 = SensorGetControl(RegAdd0, devAdd); //get the origin data as the fine shutter enabl
 3771              		.loc 1 2014 0
 3772 201c 0D10C7E5 		strb	r1, [r7, #13]
2015:../uvc.c      **** 								 Data1 &= 0x0F; Data0 = (Data0&0x0F) << 4;
 3773              		.loc 1 2015 0
 3774 2020 0C00A0E1 		mov	r0, ip
 3775 2024 0B10A0E1 		mov	r1, fp
 3776 2028 18C08DE5 		str	ip, [sp, #24]
 3777 202c FEFFFFEB 		bl	SensorGetControl
 3778              	.LVL423:
2016:../uvc.c      **** 								 Data0 |= Data1;
 3779              		.loc 1 2016 0
 3780 2030 24209DE5 		ldr	r2, [sp, #36]
2018:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 3781              		.loc 1 2018 0
 3782 2034 1C439FE5 		ldr	r4, .L451+68
2016:../uvc.c      **** 								 Data0 |= Data1;
 3783              		.loc 1 2016 0
 3784 2038 0232A0E1 		mov	r3, r2, asl #4
 3785 203c FF3003E2 		and	r3, r3, #255
2018:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 3786              		.loc 1 2018 0
 3787 2040 0010E0E3 		mvn	r1, #0
2019:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3788              		.loc 1 2019 0
 3789 2044 0090A0E3 		mov	r9, #0
2016:../uvc.c      **** 								 Data0 |= Data1;
 3790              		.loc 1 2016 0
 3791 2048 0F0000E2 		and	r0, r0, #15
 3792              	.LVL424:
2017:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3793              		.loc 1 2017 0
 3794 204c 033080E1 		orr	r3, r0, r3
2016:../uvc.c      **** 								 Data0 |= Data1;
 3795              		.loc 1 2016 0
 3796 2050 28008DE5 		str	r0, [sp, #40]
 3797              	.LVL425:
2018:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 3798              		.loc 1 2018 0
 3799 2054 1C0094E5 		ldr	r0, [r4, #28]
2017:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3800              		.loc 1 2017 0
 3801 2058 24308DE5 		str	r3, [sp, #36]
 3802              	.LVL426:
2018:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 3803              		.loc 1 2018 0
 3804 205c FEFFFFEB 		bl	_txe_mutex_get
 3805              	.LVL427:
2019:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3806              		.loc 1 2019 0
 3807 2060 18C09DE5 		ldr	ip, [sp, #24]
 3808 2064 24309DE5 		ldr	r3, [sp, #36]
 3809 2068 0C20A0E1 		mov	r2, ip
 3810 206c 2810A0E3 		mov	r1, #40
 3811 2070 00308DE5 		str	r3, [sp]
 3812 2074 04908DE5 		str	r9, [sp, #4]
 3813 2078 0B30A0E1 		mov	r3, fp
 3814 207c 0400A0E1 		mov	r0, r4
 3815 2080 FEFFFFEB 		bl	cmdSet
 3816              	.LVL428:
2020:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 3817              		.loc 1 2020 0
 3818 2084 1C0094E5 		ldr	r0, [r4, #28]
 3819 2088 FEFFFFEB 		bl	_txe_mutex_put
 3820              	.LVL429:
2021:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3821              		.loc 1 2021 0
 3822 208c 0E90C7E5 		strb	r9, [r7, #14]
2022:../uvc.c      **** 							 }
 3823              		.loc 1 2022 0
 3824 2090 1C0094E5 		ldr	r0, [r4, #28]
 3825 2094 FEFFFFEB 		bl	_txe_mutex_put
 3826              	.LVL430:
 3827 2098 24909DE5 		ldr	r9, [sp, #36]
 3828 209c 28A09DE5 		ldr	r10, [sp, #40]
 3829 20a0 18C09DE5 		ldr	ip, [sp, #24]
 3830              	.L361:
2024:../uvc.c      **** 
 3831              		.loc 1 2024 0
 3832 20a4 0130A0E3 		mov	r3, #1
 3833 20a8 1130C7E5 		strb	r3, [r7, #17]
 3834              	.L347:
2037:../uvc.c      **** 				 	 			 {
 3835              		.loc 1 2037 0
 3836 20ac 020058E3 		cmp	r8, #2
 3837 20b0 4701000A 		beq	.L444
2047:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 3838              		.loc 1 2047 0
 3839 20b4 040058E3 		cmp	r8, #4
 3840 20b8 D801000A 		beq	.L445
 3841              	.LVL431:
 3842              	.L394:
2255:../uvc.c      **** 			 	 			 break;
 3843              		.loc 1 2255 0
 3844 20bc 0E00D7E5 		ldrb	r0, [r7, #14]	@ zero_extendqisi2
 3845 20c0 0D10D7E5 		ldrb	r1, [r7, #13]	@ zero_extendqisi2
2254:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
 3846              		.loc 1 2254 0
 3847 20c4 24209DE5 		ldr	r2, [sp, #36]
 3848 20c8 03018DE8 		stmia	sp, {r0, r1, r8}
 3849 20cc 28309DE5 		ldr	r3, [sp, #40]
 3850 20d0 0400A0E3 		mov	r0, #4
 3851 20d4 58129FE5 		ldr	r1, .L451+32
 3852 20d8 FEFFFFEB 		bl	CyU3PDebugPrint
 3853              	.LVL432:
2256:../uvc.c      **** 					 }
 3854              		.loc 1 2256 0
 3855 20dc FF70A0E3 		mov	r7, #255
 3856 20e0 07B0A0E1 		mov	fp, r7
 3857              	.LVL433:
 3858 20e4 36FDFFEA 		b	.L284
 3859              	.LVL434:
 3860              	.L345:
1842:../uvc.c      **** 							 if(Data0 == 1){
 3861              		.loc 1 1842 0
 3862 20e8 044187E0 		add	r4, r7, r4, asl #2
1843:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3863              		.loc 1 1843 0
 3864 20ec 24209DE5 		ldr	r2, [sp, #36]
1842:../uvc.c      **** 							 if(Data0 == 1){
 3865              		.loc 1 1842 0
 3866 20f0 205094E5 		ldr	r5, [r4, #32]
1844:../uvc.c      **** 							 }else{
 3867              		.loc 1 1844 0
 3868 20f4 58329FE5 		ldr	r3, .L451+64
1848:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3869              		.loc 1 1848 0
 3870 20f8 58429FE5 		ldr	r4, .L451+68
1842:../uvc.c      **** 							 if(Data0 == 1){
 3871              		.loc 1 1842 0
 3872 20fc 0D20C5E5 		strb	r2, [r5, #13]
1844:../uvc.c      **** 							 }else{
 3873              		.loc 1 1844 0
 3874 2100 A995D3E5 		ldrb	r9, [r3, #1449]	@ zero_extendqisi2
1843:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3875              		.loc 1 1843 0
 3876 2104 010052E3 		cmp	r2, #1
1848:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3877              		.loc 1 1848 0
 3878 2108 0010E0E3 		mvn	r1, #0
 3879 210c 1C0094E5 		ldr	r0, [r4, #28]
1844:../uvc.c      **** 							 }else{
 3880              		.loc 1 1844 0
 3881 2110 80908903 		orreq	r9, r9, #128
 3882              	.LVL435:
1846:../uvc.c      **** 							 }
 3883              		.loc 1 1846 0
 3884 2114 7F900912 		andne	r9, r9, #127
 3885              	.LVL436:
1848:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3886              		.loc 1 1848 0
 3887 2118 18C08DE5 		str	ip, [sp, #24]
 3888 211c FEFFFFEB 		bl	_txe_mutex_get
 3889              	.LVL437:
1849:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3890              		.loc 1 1849 0
 3891 2120 18C09DE5 		ldr	ip, [sp, #24]
 3892 2124 0010A0E3 		mov	r1, #0
 3893 2128 04108DE5 		str	r1, [sp, #4]
 3894 212c 00908DE5 		str	r9, [sp]
 3895 2130 0C20A0E1 		mov	r2, ip
 3896 2134 0B30A0E1 		mov	r3, fp
 3897 2138 0400A0E1 		mov	r0, r4
 3898 213c 2610A0E3 		mov	r1, #38
 3899 2140 71FFFFEA 		b	.L426
 3900              	.LVL438:
 3901              	.L341:
1922:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){
 3902              		.loc 1 1922 0
 3903 2144 0CC29FE5 		ldr	ip, .L451+68
 3904 2148 0010E0E3 		mvn	r1, #0
 3905 214c 1C009CE5 		ldr	r0, [ip, #28]
1923:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 3906              		.loc 1 1923 0
 3907 2150 044187E0 		add	r4, r7, r4, asl #2
1922:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){
 3908              		.loc 1 1922 0
 3909 2154 2CC08DE5 		str	ip, [sp, #44]
 3910 2158 FEFFFFEB 		bl	_txe_mutex_get
 3911              	.LVL439:
1923:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 3912              		.loc 1 1923 0
 3913 215c 203094E5 		ldr	r3, [r4, #32]
 3914 2160 24C09DE5 		ldr	ip, [sp, #36]
 3915 2164 0D20D3E5 		ldrb	r2, [r3, #13]	@ zero_extendqisi2
1925:../uvc.c      **** 									 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 3916              		.loc 1 1925 0
 3917 2168 E4519FE5 		ldr	r5, .L451+64
1923:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 3918              		.loc 1 1923 0
 3919 216c 0C0052E1 		cmp	r2, ip
 3920 2170 0600000A 		beq	.L358
1924:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 3921              		.loc 1 1924 0
 3922 2174 0DC0C3E5 		strb	ip, [r3, #13]
1925:../uvc.c      **** 									 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 3923              		.loc 1 1925 0
 3924 2178 1935D5E5 		ldrb	r3, [r5, #1305]	@ zero_extendqisi2
 3925 217c 010053E3 		cmp	r3, #1
 3926 2180 9C01000A 		beq	.L359
1925:../uvc.c      **** 									 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 3927              		.loc 1 1925 0 is_stmt 0 discriminator 1
 3928 2184 1935D5E5 		ldrb	r3, [r5, #1305]	@ zero_extendqisi2
 3929 2188 030053E3 		cmp	r3, #3
 3930 218c 9901000A 		beq	.L359
 3931              	.L358:
1932:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3932              		.loc 1 1932 0 is_stmt 1
 3933 2190 2CC09DE5 		ldr	ip, [sp, #44]
1933:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3934              		.loc 1 1933 0
 3935 2194 FF70A0E3 		mov	r7, #255
1932:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3936              		.loc 1 1932 0
 3937 2198 1C009CE5 		ldr	r0, [ip, #28]
 3938 219c FEFFFFEB 		bl	_txe_mutex_put
 3939              	.LVL440:
1934:../uvc.c      **** 							 break;
 3940              		.loc 1 1934 0
 3941 21a0 1925D5E5 		ldrb	r2, [r5, #1305]	@ zero_extendqisi2
 3942 21a4 1A35D5E5 		ldrb	r3, [r5, #1306]	@ zero_extendqisi2
 3943 21a8 D115D5E5 		ldrb	r1, [r5, #1489]	@ zero_extendqisi2
1933:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3944              		.loc 1 1933 0
 3945 21ac 0400A0E3 		mov	r0, #4
 3946 21b0 82008DE8 		stmia	sp, {r1, r7}
 3947 21b4 7C119FE5 		ldr	r1, .L451+36
 3948 21b8 08708DE5 		str	r7, [sp, #8]
 3949 21bc FEFFFFEB 		bl	CyU3PDebugPrint
 3950              	.LVL441:
1935:../uvc.c      **** 
 3951              		.loc 1 1935 0
 3952 21c0 07B0A0E1 		mov	fp, r7
 3953              	.LVL442:
 3954 21c4 FEFCFFEA 		b	.L284
 3955              	.LVL443:
 3956              	.L344:
2001:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 3957              		.loc 1 2001 0
 3958 21c8 88419FE5 		ldr	r4, .L451+68
 3959 21cc 0010E0E3 		mvn	r1, #0
 3960 21d0 1C0094E5 		ldr	r0, [r4, #28]
 3961 21d4 18C08DE5 		str	ip, [sp, #24]
 3962 21d8 FEFFFFEB 		bl	_txe_mutex_get
 3963              	.LVL444:
2002:../uvc.c      **** 							 dataIdx++;
 3964              		.loc 1 2002 0
 3965 21dc 24109DE5 		ldr	r1, [sp, #36]
 3966 21e0 18C09DE5 		ldr	ip, [sp, #24]
 3967 21e4 0030A0E3 		mov	r3, #0
 3968 21e8 0C20A0E1 		mov	r2, ip
 3969 21ec 00108DE5 		str	r1, [sp]
 3970 21f0 04308DE5 		str	r3, [sp, #4]
 3971 21f4 2410A0E3 		mov	r1, #36
 3972 21f8 0B30A0E1 		mov	r3, fp
 3973 21fc 0400A0E1 		mov	r0, r4
 3974 2200 FEFFFFEB 		bl	cmdSet
 3975              	.LVL445:
2004:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3976              		.loc 1 2004 0
 3977 2204 28C09DE5 		ldr	ip, [sp, #40]
 3978 2208 0150A0E3 		mov	r5, #1
 3979 220c 0B30A0E1 		mov	r3, fp
 3980 2210 00C08DE5 		str	ip, [sp]
 3981 2214 20209DE5 		ldr	r2, [sp, #32]
 3982 2218 2410A0E3 		mov	r1, #36
 3983 221c 0400A0E1 		mov	r0, r4
 3984 2220 04508DE5 		str	r5, [sp, #4]
 3985 2224 FEFFFFEB 		bl	cmdSet
 3986              	.LVL446:
2005:../uvc.c      **** 							 getData1 = Data1;
 3987              		.loc 1 2005 0
 3988 2228 1C0094E5 		ldr	r0, [r4, #28]
 3989 222c FEFFFFEB 		bl	_txe_mutex_put
 3990              	.LVL447:
2008:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3991              		.loc 1 2008 0
 3992 2230 1C319FE5 		ldr	r3, .L451+64
 3993 2234 24C09DE5 		ldr	ip, [sp, #36]
2011:../uvc.c      **** 				 	 	 case Ext1ExCtrlSpeedCtlID8:
 3994              		.loc 1 2011 0
 3995 2238 FF70A0E3 		mov	r7, #255
2008:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3996              		.loc 1 2008 0
 3997 223c 41C5C3E5 		strb	ip, [r3, #1345]
2009:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3998              		.loc 1 2009 0
 3999 2240 28C09DE5 		ldr	ip, [sp, #40]
2011:../uvc.c      **** 				 	 	 case Ext1ExCtrlSpeedCtlID8:
 4000              		.loc 1 2011 0
 4001 2244 07B0A0E1 		mov	fp, r7
 4002              	.LVL448:
2009:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 4003              		.loc 1 2009 0
 4004 2248 42C5C3E5 		strb	ip, [r3, #1346]
2010:../uvc.c      **** 							 break;
 4005              		.loc 1 2010 0
 4006 224c 4555C3E5 		strb	r5, [r3, #1349]
2011:../uvc.c      **** 				 	 	 case Ext1ExCtrlSpeedCtlID8:
 4007              		.loc 1 2011 0
 4008 2250 DBFCFFEA 		b	.L284
 4009              	.LVL449:
 4010              	.L343:
1879:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 4011              		.loc 1 1879 0 discriminator 1
 4012 2254 000058E3 		cmp	r8, #0
 4013 2258 0300000A 		beq	.L351
 4014 225c D8009FE5 		ldr	r0, .L451+40
 4015 2260 0820A0E1 		mov	r2, r8
 4016 2264 6C1040E2 		sub	r1, r0, #108
 4017 2268 FEFFFFEB 		bl	memcpy
 4018              	.LVL450:
 4019              	.L351:
1883:../uvc.c      **** 				 	 	 case ExtAexModCtlID9://4byte
 4020              		.loc 1 1883 0
 4021 226c FF70A0E3 		mov	r7, #255
1882:../uvc.c      **** 							 break;
 4022              		.loc 1 1882 0
 4023 2270 FEFFFFEB 		bl	I2CCmdHandler
 4024              	.LVL451:
1883:../uvc.c      **** 				 	 	 case ExtAexModCtlID9://4byte
 4025              		.loc 1 1883 0
 4026 2274 07B0A0E1 		mov	fp, r7
 4027              	.LVL452:
 4028 2278 D1FCFFEA 		b	.L284
 4029              	.LVL453:
 4030              	.L338:
1906:../uvc.c      **** 	#if 1	// register setting directly
 4031              		.loc 1 1906 0
 4032 227c 044187E0 		add	r4, r7, r4, asl #2
 4033 2280 203094E5 		ldr	r3, [r4, #32]
1908:../uvc.c      **** 						     {
 4034              		.loc 1 1908 0
 4035 2284 C8509FE5 		ldr	r5, .L451+64
1906:../uvc.c      **** 	#if 1	// register setting directly
 4036              		.loc 1 1906 0
 4037 2288 24109DE5 		ldr	r1, [sp, #36]
 4038 228c 0D10C3E5 		strb	r1, [r3, #13]
1908:../uvc.c      **** 						     {
 4039              		.loc 1 1908 0
 4040 2290 1935D5E5 		ldrb	r3, [r5, #1305]	@ zero_extendqisi2
 4041 2294 030013E3 		tst	r3, #3
 4042 2298 1200000A 		beq	.L356
1910:../uvc.c      **** 						    	 dataIdx = 0;
 4043              		.loc 1 1910 0
 4044 229c 1995D5E5 		ldrb	r9, [r5, #1305]	@ zero_extendqisi2
1912:../uvc.c      **** 								 //cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 4045              		.loc 1 1912 0
 4046 22a0 B0409FE5 		ldr	r4, .L451+68
1910:../uvc.c      **** 						    	 dataIdx = 0;
 4047              		.loc 1 1910 0
 4048 22a4 019289E1 		orr	r9, r9, r1, asl #4
1912:../uvc.c      **** 								 //cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 4049              		.loc 1 1912 0
 4050 22a8 1C0094E5 		ldr	r0, [r4, #28]
 4051 22ac 0010E0E3 		mvn	r1, #0
 4052 22b0 18C08DE5 		str	ip, [sp, #24]
 4053 22b4 FEFFFFEB 		bl	_txe_mutex_get
 4054              	.LVL454:
1915:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4055              		.loc 1 1915 0
 4056 22b8 18C09DE5 		ldr	ip, [sp, #24]
 4057 22bc 0010A0E3 		mov	r1, #0
1910:../uvc.c      **** 						    	 dataIdx = 0;
 4058              		.loc 1 1910 0
 4059 22c0 FF9009E2 		and	r9, r9, #255
 4060              	.LVL455:
1915:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4061              		.loc 1 1915 0
 4062 22c4 04108DE5 		str	r1, [sp, #4]
 4063 22c8 00908DE5 		str	r9, [sp]
 4064 22cc 0C20A0E1 		mov	r2, ip
 4065 22d0 0B30A0E1 		mov	r3, fp
 4066 22d4 0400A0E1 		mov	r0, r4
 4067 22d8 1010A0E3 		mov	r1, #16
 4068 22dc FEFFFFEB 		bl	cmdSet
 4069              	.LVL456:
1916:../uvc.c      **** 						     }
 4070              		.loc 1 1916 0
 4071 22e0 1C0094E5 		ldr	r0, [r4, #28]
 4072 22e4 FEFFFFEB 		bl	_txe_mutex_put
 4073              	.LVL457:
 4074              	.L356:
1919:../uvc.c      **** 						     break;
 4075              		.loc 1 1919 0
 4076 22e8 1915D5E5 		ldrb	r1, [r5, #1305]	@ zero_extendqisi2
 4077 22ec BD35D5E5 		ldrb	r3, [r5, #1469]	@ zero_extendqisi2
1918:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 4078              		.loc 1 1918 0
 4079 22f0 28209DE5 		ldr	r2, [sp, #40]
 4080 22f4 0A008DE8 		stmia	sp, {r1, r3}
 4081 22f8 40109FE5 		ldr	r1, .L451+44
 4082 22fc 0400A0E3 		mov	r0, #4
 4083 2300 0930A0E1 		mov	r3, r9
1920:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level 2bytes standard operation!!!
 4084              		.loc 1 1920 0
 4085 2304 FF70A0E3 		mov	r7, #255
1918:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 4086              		.loc 1 1918 0
 4087 2308 FEFFFFEB 		bl	CyU3PDebugPrint
 4088              	.LVL458:
1920:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level 2bytes standard operation!!!
 4089              		.loc 1 1920 0
 4090 230c 07B0A0E1 		mov	fp, r7
 4091              	.LVL459:
 4092 2310 ABFCFFEA 		b	.L284
 4093              	.L452:
 4094              		.align	2
 4095              	.L451:
 4096 2314 00000000 		.word	bRequest
 4097 2318 68040000 		.word	.LC27
 4098 231c 28000000 		.word	.LANCHOR0+40
 4099 2320 2C060000 		.word	.LC35
 4100 2324 38040000 		.word	.LC26
 4101 2328 D4030000 		.word	.LC24
 4102 232c FC030000 		.word	.LC25
 4103 2330 B8050000 		.word	.LC32
 4104 2334 64050000 		.word	.LC31
 4105 2338 2C050000 		.word	.LC30
 4106 233c 94000000 		.word	.LANCHOR0+148
 4107 2340 00050000 		.word	.LC29
 4108 2344 CC040000 		.word	.LC28
 4109 2348 00000000 		.word	.LANCHOR2
 4110 234c FC050000 		.word	.LC34
 4111 2350 D8050000 		.word	.LC33
 4112 2354 00000000 		.word	.LANCHOR1
 4113 2358 00000000 		.word	cmdQu
 4114 235c 00000000 		.word	.LANCHOR0
 4115              	.LVL460:
 4116              	.L340:
1885:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 4117              		.loc 1 1885 0
 4118 2360 10101FE5 		ldr	r1, .L451+68
1886:../uvc.c      **** 							 {
 4119              		.loc 1 1886 0
 4120 2364 044187E0 		add	r4, r7, r4, asl #2
1885:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 4121              		.loc 1 1885 0
 4122 2368 2C108DE5 		str	r1, [sp, #44]
 4123 236c 2C209DE5 		ldr	r2, [sp, #44]
 4124 2370 0010E0E3 		mvn	r1, #0
 4125 2374 1C0092E5 		ldr	r0, [r2, #28]
 4126 2378 18C08DE5 		str	ip, [sp, #24]
 4127 237c FEFFFFEB 		bl	_txe_mutex_get
 4128              	.LVL461:
1886:../uvc.c      **** 							 {
 4129              		.loc 1 1886 0
 4130 2380 204094E5 		ldr	r4, [r4, #32]
 4131 2384 24109DE5 		ldr	r1, [sp, #36]
 4132 2388 0D30D4E5 		ldrb	r3, [r4, #13]	@ zero_extendqisi2
1889:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4133              		.loc 1 1889 0
 4134 238c 40501FE5 		ldr	r5, .L451+64
1886:../uvc.c      **** 							 {
 4135              		.loc 1 1886 0
 4136 2390 010053E1 		cmp	r3, r1
 4137 2394 18C09DE5 		ldr	ip, [sp, #24]
1835:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x 
 4138              		.loc 1 1835 0
 4139 2398 0020A003 		moveq	r2, #0
1886:../uvc.c      **** 							 {
 4140              		.loc 1 1886 0
 4141 239c 0F00000A 		beq	.L352
1888:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 4142              		.loc 1 1888 0
 4143 23a0 0D10C4E5 		strb	r1, [r4, #13]
1889:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4144              		.loc 1 1889 0
 4145 23a4 BD25D5E5 		ldrb	r2, [r5, #1469]	@ zero_extendqisi2
1890:../uvc.c      **** 								 dataIdx++;
 4146              		.loc 1 1890 0
 4147 23a8 0030A0E3 		mov	r3, #0
1889:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4148              		.loc 1 1889 0
 4149 23ac 022281E1 		orr	r2, r1, r2, asl #4
 4150 23b0 FF2002E2 		and	r2, r2, #255
 4151 23b4 24208DE5 		str	r2, [sp, #36]
 4152              	.LVL462:
1890:../uvc.c      **** 								 dataIdx++;
 4153              		.loc 1 1890 0
 4154 23b8 0C20A0E1 		mov	r2, ip
 4155 23bc 24C09DE5 		ldr	ip, [sp, #36]
 4156 23c0 04308DE5 		str	r3, [sp, #4]
 4157 23c4 00C08DE5 		str	ip, [sp]
 4158 23c8 2C009DE5 		ldr	r0, [sp, #44]
 4159 23cc 1910A0E3 		mov	r1, #25
 4160 23d0 0B30A0E1 		mov	r3, fp
 4161 23d4 FEFFFFEB 		bl	cmdSet
 4162              	.LVL463:
 4163 23d8 24909DE5 		ldr	r9, [sp, #36]
1891:../uvc.c      **** 							 }
 4164              		.loc 1 1891 0
 4165 23dc 0120A0E3 		mov	r2, #1
 4166              	.LVL464:
 4167              	.L352:
1893:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 4168              		.loc 1 1893 0
 4169 23e0 0E30D4E5 		ldrb	r3, [r4, #14]	@ zero_extendqisi2
 4170 23e4 28C09DE5 		ldr	ip, [sp, #40]
 4171 23e8 0C0053E1 		cmp	r3, ip
 4172 23ec 0600000A 		beq	.L354
1895:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //AGC
 4173              		.loc 1 1895 0
 4174 23f0 24C09DE5 		ldr	ip, [sp, #36]
 4175 23f4 02304CE2 		sub	r3, ip, #2
1894:../uvc.c      **** 								 if(Data0 == 2 || Data0 == 3){
 4176              		.loc 1 1894 0
 4177 23f8 28C09DE5 		ldr	ip, [sp, #40]
1895:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //AGC
 4178              		.loc 1 1895 0
 4179 23fc FF3003E2 		and	r3, r3, #255
 4180 2400 010053E3 		cmp	r3, #1
1894:../uvc.c      **** 								 if(Data0 == 2 || Data0 == 3){
 4181              		.loc 1 1894 0
 4182 2404 0EC0C4E5 		strb	ip, [r4, #14]
1895:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //AGC
 4183              		.loc 1 1895 0
 4184 2408 5001009A 		bls	.L446
 4185              	.LVL465:
 4186              	.L354:
1900:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 4187              		.loc 1 1900 0
 4188 240c 2CC09DE5 		ldr	ip, [sp, #44]
1899:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4189              		.loc 1 1899 0
 4190 2410 0130A0E3 		mov	r3, #1
 4191 2414 1130C4E5 		strb	r3, [r4, #17]
1900:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 4192              		.loc 1 1900 0
 4193 2418 1C009CE5 		ldr	r0, [ip, #28]
 4194 241c FEFFFFEB 		bl	_txe_mutex_put
 4195              	.LVL466:
1901:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi,
 4196              		.loc 1 1901 0
 4197 2420 24C09DE5 		ldr	ip, [sp, #36]
1902:../uvc.c      **** 									 EXTShutter.UVCCurVLo, Data0, Data1);
 4198              		.loc 1 1902 0
 4199 2424 0D20D4E5 		ldrb	r2, [r4, #13]	@ zero_extendqisi2
 4200 2428 0E30D4E5 		ldrb	r3, [r4, #14]	@ zero_extendqisi2
1903:../uvc.c      **** 							 break;
 4201              		.loc 1 1903 0
 4202 242c BD15D5E5 		ldrb	r1, [r5, #1469]	@ zero_extendqisi2
1901:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi,
 4203              		.loc 1 1901 0
 4204 2430 04C08DE5 		str	ip, [sp, #4]
 4205 2434 28C09DE5 		ldr	ip, [sp, #40]
 4206 2438 00108DE5 		str	r1, [sp]
 4207 243c 08C08DE5 		str	ip, [sp, #8]
 4208 2440 0400A0E3 		mov	r0, #4
 4209 2444 08111FE5 		ldr	r1, .L451+48
 4210 2448 FEFFFFEB 		bl	CyU3PDebugPrint
 4211              	.LVL467:
1904:../uvc.c      **** 					 	 case ExtShutCtlID0: //special!!
 4212              		.loc 1 1904 0
 4213 244c FF70A0E3 		mov	r7, #255
 4214 2450 07B0A0E1 		mov	fp, r7
 4215              	.LVL468:
 4216 2454 5AFCFFEA 		b	.L284
 4217              	.LVL469:
 4218              	.L286:
1482:../uvc.c      **** 			 	 			 if(Len == 2)
 4219              		.loc 1 1482 0
 4220 2458 007087E0 		add	r7, r7, r0
 4221 245c 6031D7E5 		ldrb	r3, [r7, #352]	@ zero_extendqisi2
 4222 2460 20411FE5 		ldr	r4, .L451+52
 4223 2464 000053E3 		cmp	r3, #0
 4224 2468 3500000A 		beq	.L299
1483:../uvc.c      **** 			 	 			 {
 4225              		.loc 1 1483 0
 4226 246c 020058E3 		cmp	r8, #2
 4227 2470 1C01000A 		beq	.L447
1489:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 4228              		.loc 1 1489 0
 4229 2474 040058E3 		cmp	r8, #4
 4230 2478 2FFDFF1A 		bne	.L303
1490:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4231              		.loc 1 1490 0
 4232 247c 004184E0 		add	r4, r4, r0, asl #2
 4233 2480 202014E5 		ldr	r2, [r4, #-32]
 4234 2484 B3FEFFEA 		b	.L421
 4235              	.LVL470:
 4236              	.L367:
2228:../uvc.c      **** 			 	 			 {
 4237              		.loc 1 2228 0
 4238 2488 020058E3 		cmp	r8, #2
 4239 248c CB00000A 		beq	.L448
2238:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 4240              		.loc 1 2238 0
 4241 2490 040058E3 		cmp	r8, #4
 4242 2494 2401000A 		beq	.L395
 4243 2498 055187E0 		add	r5, r7, r5, asl #2
 4244 249c 207195E5 		ldr	r7, [r5, #288]
 4245 24a0 05FFFFEA 		b	.L394
 4246              	.L337:
 4247 24a4 044187E0 		add	r4, r7, r4, asl #2
 4248 24a8 207094E5 		ldr	r7, [r4, #32]
 4249 24ac FEFEFFEA 		b	.L347
 4250              	.LVL471:
 4251              	.L333:
2260:../uvc.c      **** 			   }
 4252              		.loc 1 2260 0
 4253 24b0 0400A0E3 		mov	r0, #4
 4254              	.LVL472:
 4255 24b4 70111FE5 		ldr	r1, .L451+56
 4256 24b8 FEFFFFEB 		bl	CyU3PDebugPrint
 4257              	.LVL473:
 4258 24bc FF70A0E3 		mov	r7, #255
 4259 24c0 0090A0E3 		mov	r9, #0
 4260 24c4 07B0A0E1 		mov	fp, r7
 4261              	.LVL474:
 4262 24c8 09A0A0E1 		mov	r10, r9
 4263 24cc 3CFCFFEA 		b	.L284
 4264              	.LVL475:
 4265              	.L311:
1648:../uvc.c      **** 			 	 			 {
 4266              		.loc 1 1648 0
 4267 24d0 020058E3 		cmp	r8, #2
 4268 24d4 2501000A 		beq	.L449
1656:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4269              		.loc 1 1656 0
 4270 24d8 040058E3 		cmp	r8, #4
 4271 24dc 16FDFF1A 		bne	.L303
1657:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4272              		.loc 1 1657 0
 4273 24e0 0B10A0E1 		mov	r1, fp
 4274 24e4 20009DE5 		ldr	r0, [sp, #32]
 4275              	.LVL476:
 4276 24e8 1C308DE5 		str	r3, [sp, #28]
 4277 24ec 18C08DE5 		str	ip, [sp, #24]
 4278 24f0 FEFFFFEB 		bl	SensorGetControl
 4279              	.LVL477:
1658:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4280              		.loc 1 1658 0
 4281 24f4 054184E0 		add	r4, r4, r5, asl #2
 4282 24f8 205194E5 		ldr	r5, [r4, #288]
1659:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4283              		.loc 1 1659 0
 4284 24fc 18C09DE5 		ldr	ip, [sp, #24]
1657:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4285              		.loc 1 1657 0
 4286 2500 AC411FE5 		ldr	r4, .L451+72
1659:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4287              		.loc 1 1659 0
 4288 2504 0B10A0E1 		mov	r1, fp
 4289 2508 0090A0E3 		mov	r9, #0
 4290 250c 09A0A0E1 		mov	r10, r9
1657:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4291              		.loc 1 1657 0
 4292 2510 0020A0E1 		mov	r2, r0
 4293 2514 2820C4E5 		strb	r2, [r4, #40]
1659:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4294              		.loc 1 1659 0
 4295 2518 0C00A0E1 		mov	r0, ip
1658:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4296              		.loc 1 1658 0
 4297 251c 0D20C5E5 		strb	r2, [r5, #13]
1659:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4298              		.loc 1 1659 0
 4299 2520 FEFFFFEB 		bl	SensorGetControl
 4300              	.LVL478:
 4301 2524 2A00C4E5 		strb	r0, [r4, #42]
1660:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4302              		.loc 1 1660 0
 4303 2528 0E00C5E5 		strb	r0, [r5, #14]
1661:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 4304              		.loc 1 1661 0
 4305 252c 1C309DE5 		ldr	r3, [sp, #28]
 4306 2530 28B0D4E5 		ldrb	fp, [r4, #40]	@ zero_extendqisi2
 4307              	.LVL479:
 4308 2534 0070A0E1 		mov	r7, r0
 4309 2538 2930C4E5 		strb	r3, [r4, #41]
1662:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4310              		.loc 1 1662 0
 4311 253c 2B30C4E5 		strb	r3, [r4, #43]
 4312              	.LVL480:
 4313 2540 EFFCFFEA 		b	.L294
 4314              	.LVL481:
 4315              	.L299:
1498:../uvc.c      **** 			 	 			 {
 4316              		.loc 1 1498 0
 4317 2544 020058E3 		cmp	r8, #2
 4318 2548 1901000A 		beq	.L450
1506:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4319              		.loc 1 1506 0
 4320 254c 040058E3 		cmp	r8, #4
 4321 2550 F9FCFF1A 		bne	.L303
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4322              		.loc 1 1507 0
 4323 2554 0B10A0E1 		mov	r1, fp
 4324 2558 20009DE5 		ldr	r0, [sp, #32]
 4325              	.LVL482:
 4326 255c 1C308DE5 		str	r3, [sp, #28]
 4327 2560 18C08DE5 		str	ip, [sp, #24]
 4328 2564 FEFFFFEB 		bl	SensorGetControl
 4329              	.LVL483:
1508:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4330              		.loc 1 1508 0
 4331 2568 054184E0 		add	r4, r4, r5, asl #2
 4332 256c 205014E5 		ldr	r5, [r4, #-32]
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4333              		.loc 1 1509 0
 4334 2570 18C09DE5 		ldr	ip, [sp, #24]
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4335              		.loc 1 1507 0
 4336 2574 20421FE5 		ldr	r4, .L451+72
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4337              		.loc 1 1509 0
 4338 2578 0B10A0E1 		mov	r1, fp
 4339 257c 0090A0E3 		mov	r9, #0
 4340 2580 09A0A0E1 		mov	r10, r9
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4341              		.loc 1 1507 0
 4342 2584 0020A0E1 		mov	r2, r0
 4343 2588 2820C4E5 		strb	r2, [r4, #40]
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4344              		.loc 1 1509 0
 4345 258c 0C00A0E1 		mov	r0, ip
1508:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4346              		.loc 1 1508 0
 4347 2590 0D20C5E5 		strb	r2, [r5, #13]
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4348              		.loc 1 1509 0
 4349 2594 FEFFFFEB 		bl	SensorGetControl
 4350              	.LVL484:
 4351 2598 2A00C4E5 		strb	r0, [r4, #42]
1510:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4352              		.loc 1 1510 0
 4353 259c 0E00C5E5 		strb	r0, [r5, #14]
1511:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 4354              		.loc 1 1511 0
 4355 25a0 1C309DE5 		ldr	r3, [sp, #28]
 4356 25a4 0070A0E1 		mov	r7, r0
 4357 25a8 2930C4E5 		strb	r3, [r4, #41]
1512:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4358              		.loc 1 1512 0
 4359 25ac 2B30C4E5 		strb	r3, [r4, #43]
 4360              	.LVL485:
 4361 25b0 28B0D4E5 		ldrb	fp, [r4, #40]	@ zero_extendqisi2
 4362              	.LVL486:
 4363 25b4 D2FCFFEA 		b	.L294
 4364              	.LVL487:
 4365              	.L390:
2218:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 4366              		.loc 1 2218 0
 4367 25b8 FEFFFFEB 		bl	_txe_mutex_get
 4368              	.LVL488:
2219:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4369              		.loc 1 2219 0
 4370 25bc 24109DE5 		ldr	r1, [sp, #36]
 4371 25c0 18C09DE5 		ldr	ip, [sp, #24]
 4372 25c4 00108DE5 		str	r1, [sp]
 4373 25c8 04108DE5 		str	r1, [sp, #4]
 4374 25cc 0C20A0E1 		mov	r2, ip
 4375 25d0 A9FDFFEA 		b	.L425
 4376              	.L444:
2039:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4377              		.loc 1 2039 0
 4378 25d4 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4379 25d8 24109DE5 		ldr	r1, [sp, #36]
 4380 25dc 010053E1 		cmp	r3, r1
 4381 25e0 1400000A 		beq	.L393
2040:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 4382              		.loc 1 2040 0
 4383 25e4 94421FE5 		ldr	r4, .L451+68
 4384 25e8 0010E0E3 		mvn	r1, #0
 4385 25ec 1C0094E5 		ldr	r0, [r4, #28]
 4386 25f0 18C08DE5 		str	ip, [sp, #24]
 4387 25f4 FEFFFFEB 		bl	_txe_mutex_get
 4388              	.LVL489:
2041:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4389              		.loc 1 2041 0
 4390 25f8 24209DE5 		ldr	r2, [sp, #36]
 4391 25fc 00208DE5 		str	r2, [sp]
 4392              	.L428:
2232:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4393              		.loc 1 2232 0
 4394 2600 18C09DE5 		ldr	ip, [sp, #24]
 4395 2604 0510A0E1 		mov	r1, r5
 4396 2608 0C20A0E1 		mov	r2, ip
 4397 260c 00C0A0E3 		mov	ip, #0
 4398 2610 04C08DE5 		str	ip, [sp, #4]
 4399 2614 0B30A0E1 		mov	r3, fp
 4400 2618 0400A0E1 		mov	r0, r4
 4401 261c FEFFFFEB 		bl	cmdSet
 4402              	.LVL490:
2233:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 4403              		.loc 1 2233 0
 4404 2620 1C0094E5 		ldr	r0, [r4, #28]
 4405 2624 FEFFFFEB 		bl	_txe_mutex_put
 4406              	.LVL491:
2234:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
 4407              		.loc 1 2234 0
 4408 2628 24C09DE5 		ldr	ip, [sp, #36]
2235:../uvc.c      **** 								 }
 4409              		.loc 1 2235 0
 4410 262c 0010A0E3 		mov	r1, #0
2234:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
 4411              		.loc 1 2234 0
 4412 2630 0DC0C7E5 		strb	ip, [r7, #13]
 4413              	.LVL492:
2235:../uvc.c      **** 								 }
 4414              		.loc 1 2235 0
 4415 2634 0E10C7E5 		strb	r1, [r7, #14]
 4416              	.L393:
2237:../uvc.c      **** 			 	 			 }else if(Len == 4){
 4417              		.loc 1 2237 0
 4418 2638 0130A0E3 		mov	r3, #1
 4419 263c 1130C7E5 		strb	r3, [r7, #17]
 4420 2640 9DFEFFEA 		b	.L394
 4421              	.LVL493:
 4422              	.L442:
2144:../uvc.c      **** 			                         {
 4423              		.loc 1 2144 0
 4424 2644 7030D2E5 		ldrb	r3, [r2, #112]	@ zero_extendqisi2
 4425 2648 013043E2 		sub	r3, r3, #1
 4426 264c 030053E3 		cmp	r3, #3
 4427 2650 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 4428 2654 FBFDFFEA 		b	.L376
 4429              	.L378:
 4430 2658 74270000 		.word	.L377
 4431 265c 28270000 		.word	.L379
 4432 2660 C8260000 		.word	.L380
 4433 2664 68260000 		.word	.L381
 4434              	.L381:
2162:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4435              		.loc 1 2162 0
 4436 2668 1C531FE5 		ldr	r5, .L451+64
 4437 266c 6C2094E5 		ldr	r2, [r4, #108]
 4438 2670 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 4439 2674 000052E3 		cmp	r2, #0
 4440 2678 B020A003 		moveq	r2, #176
 4441 267c 3020A013 		movne	r2, #48
 4442 2680 032082E1 		orr	r2, r2, r3
 4443 2684 3010A0E3 		mov	r1, #48
 4444 2688 5230A0E3 		mov	r3, #82
 4445 268c 0100A0E3 		mov	r0, #1
 4446 2690 FEFFFFEB 		bl	SensorSetIrisControl
 4447              	.LVL494:
2163:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4448              		.loc 1 2163 0
 4449 2694 7D0FA0E3 		mov	r0, #500
 4450 2698 FEFFFFEB 		bl	_tx_thread_sleep
 4451              	.LVL495:
2164:../uvc.c      **** 			                         	default:
 4452              		.loc 1 2164 0
 4453 269c 6C1094E5 		ldr	r1, [r4, #108]
 4454 26a0 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 4455 26a4 000051E3 		cmp	r1, #0
 4456 26a8 B010A003 		moveq	r1, #176
 4457 26ac 3010A013 		movne	r1, #48
 4458 26b0 022081E1 		orr	r2, r1, r2
 4459 26b4 6C3094E5 		ldr	r3, [r4, #108]
 4460 26b8 70131FE5 		ldr	r1, .L451+60
 4461 26bc 0400A0E3 		mov	r0, #4
 4462 26c0 FEFFFFEB 		bl	CyU3PDebugPrint
 4463              	.LVL496:
 4464 26c4 DFFDFFEA 		b	.L376
 4465              	.L380:
2157:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4466              		.loc 1 2157 0
 4467 26c8 7C531FE5 		ldr	r5, .L451+64
 4468 26cc 6C2094E5 		ldr	r2, [r4, #108]
 4469 26d0 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 4470 26d4 000052E3 		cmp	r2, #0
 4471 26d8 8020A003 		moveq	r2, #128
 4472 26dc 0020A013 		movne	r2, #0
 4473 26e0 032082E1 		orr	r2, r2, r3
 4474 26e4 3010A0E3 		mov	r1, #48
 4475 26e8 5230A0E3 		mov	r3, #82
 4476 26ec 0100A0E3 		mov	r0, #1
 4477 26f0 FEFFFFEB 		bl	SensorSetIrisControl
 4478              	.LVL497:
2158:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4479              		.loc 1 2158 0
 4480 26f4 7D0FA0E3 		mov	r0, #500
 4481 26f8 FEFFFFEB 		bl	_tx_thread_sleep
 4482              	.LVL498:
2159:../uvc.c      **** 			                         		break;
 4483              		.loc 1 2159 0
 4484 26fc 6C1094E5 		ldr	r1, [r4, #108]
 4485 2700 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 4486 2704 000051E3 		cmp	r1, #0
 4487 2708 8010A003 		moveq	r1, #128
 4488 270c 0010A013 		movne	r1, #0
 4489 2710 022081E1 		orr	r2, r1, r2
 4490 2714 6C3094E5 		ldr	r3, [r4, #108]
 4491 2718 D0131FE5 		ldr	r1, .L451+60
 4492 271c 0400A0E3 		mov	r0, #4
 4493 2720 FEFFFFEB 		bl	CyU3PDebugPrint
 4494              	.LVL499:
2160:../uvc.c      **** 			                         	case 4: //VGA
 4495              		.loc 1 2160 0
 4496 2724 C7FDFFEA 		b	.L376
 4497              	.L379:
2152:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4498              		.loc 1 2152 0
 4499 2728 6C2094E5 		ldr	r2, [r4, #108]
 4500 272c 3010A0E3 		mov	r1, #48
 4501 2730 000052E3 		cmp	r2, #0
 4502 2734 9220A003 		moveq	r2, #146
 4503 2738 1220A013 		movne	r2, #18
 4504 273c 5230A0E3 		mov	r3, #82
 4505 2740 0100A0E3 		mov	r0, #1
 4506 2744 FEFFFFEB 		bl	SensorSetIrisControl
 4507              	.LVL500:
2153:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4508              		.loc 1 2153 0
 4509 2748 7D0FA0E3 		mov	r0, #500
 4510 274c FEFFFFEB 		bl	_tx_thread_sleep
 4511              	.LVL501:
2154:../uvc.c      **** 			                         		break;
 4512              		.loc 1 2154 0
 4513 2750 6C2094E5 		ldr	r2, [r4, #108]
 4514 2754 0C141FE5 		ldr	r1, .L451+60
 4515 2758 000052E3 		cmp	r2, #0
 4516 275c 6C3094E5 		ldr	r3, [r4, #108]
 4517 2760 9220A003 		moveq	r2, #146
 4518 2764 1220A013 		movne	r2, #18
 4519 2768 0400A0E3 		mov	r0, #4
 4520 276c FEFFFFEB 		bl	CyU3PDebugPrint
 4521              	.LVL502:
2155:../uvc.c      **** 			                         	case 3: //720
 4522              		.loc 1 2155 0
 4523 2770 B4FDFFEA 		b	.L376
 4524              	.L377:
2147:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4525              		.loc 1 2147 0
 4526 2774 6C2094E5 		ldr	r2, [r4, #108]
 4527 2778 3010A0E3 		mov	r1, #48
 4528 277c 000052E3 		cmp	r2, #0
 4529 2780 A220A003 		moveq	r2, #162
 4530 2784 2220A013 		movne	r2, #34
 4531 2788 5230A0E3 		mov	r3, #82
 4532 278c 0100A0E3 		mov	r0, #1
 4533 2790 FEFFFFEB 		bl	SensorSetIrisControl
 4534              	.LVL503:
2148:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4535              		.loc 1 2148 0
 4536 2794 7D0FA0E3 		mov	r0, #500
 4537 2798 FEFFFFEB 		bl	_tx_thread_sleep
 4538              	.LVL504:
2149:../uvc.c      **** 			                         		break;
 4539              		.loc 1 2149 0
 4540 279c 6C2094E5 		ldr	r2, [r4, #108]
 4541 27a0 58141FE5 		ldr	r1, .L451+60
 4542 27a4 000052E3 		cmp	r2, #0
 4543 27a8 6C3094E5 		ldr	r3, [r4, #108]
 4544 27ac A220A003 		moveq	r2, #162
 4545 27b0 2220A013 		movne	r2, #34
 4546 27b4 0400A0E3 		mov	r0, #4
 4547 27b8 FEFFFFEB 		bl	CyU3PDebugPrint
 4548              	.LVL505:
2150:../uvc.c      **** 			                         	case 2: //1080
 4549              		.loc 1 2150 0
 4550 27bc A1FDFFEA 		b	.L376
 4551              	.LVL506:
 4552              	.L448:
2230:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4553              		.loc 1 2230 0
 4554 27c0 057187E0 		add	r7, r7, r5, asl #2
 4555 27c4 207197E5 		ldr	r7, [r7, #288]
 4556 27c8 24209DE5 		ldr	r2, [sp, #36]
 4557 27cc 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4558 27d0 020053E1 		cmp	r3, r2
 4559 27d4 97FFFF0A 		beq	.L393
2231:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 4560              		.loc 1 2231 0
 4561 27d8 88441FE5 		ldr	r4, .L451+68
 4562 27dc 0010E0E3 		mvn	r1, #0
 4563 27e0 1C0094E5 		ldr	r0, [r4, #28]
 4564 27e4 18C08DE5 		str	ip, [sp, #24]
 4565 27e8 FEFFFFEB 		bl	_txe_mutex_get
 4566              	.LVL507:
2232:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4567              		.loc 1 2232 0
 4568 27ec 24309DE5 		ldr	r3, [sp, #36]
 4569 27f0 00308DE5 		str	r3, [sp]
 4570 27f4 81FFFFEA 		b	.L428
 4571              	.L359:
1928:../uvc.c      **** 								 }
 4572              		.loc 1 1928 0
 4573 27f8 24C09DE5 		ldr	ip, [sp, #36]
 4574 27fc 0010A0E3 		mov	r1, #0
 4575 2800 04108DE5 		str	r1, [sp, #4]
 4576 2804 00C08DE5 		str	ip, [sp]
 4577 2808 20209DE5 		ldr	r2, [sp, #32]
 4578 280c 0B30A0E1 		mov	r3, fp
 4579 2810 1B10A0E3 		mov	r1, #27
 4580 2814 C4041FE5 		ldr	r0, .L451+68
 4581 2818 FEFFFFEB 		bl	cmdSet
 4582              	.LVL508:
 4583 281c 5BFEFFEA 		b	.L358
 4584              	.L445:
2048:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 4585              		.loc 1 2048 0
 4586 2820 D0241FE5 		ldr	r2, .L451+68
 4587 2824 0010E0E3 		mvn	r1, #0
 4588 2828 1C0092E5 		ldr	r0, [r2, #28]
 4589 282c 2C208DE5 		str	r2, [sp, #44]
 4590 2830 18C08DE5 		str	ip, [sp, #24]
 4591 2834 FEFFFFEB 		bl	_txe_mutex_get
 4592              	.LVL509:
 4593              	.L433:
2240:../uvc.c      **** 								 {
 4594              		.loc 1 2240 0
 4595 2838 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4596 283c 24109DE5 		ldr	r1, [sp, #36]
 4597 2840 18C09DE5 		ldr	ip, [sp, #24]
 4598 2844 010053E1 		cmp	r3, r1
2243:../uvc.c      **** 									 dataIdx++;
 4599              		.loc 1 2243 0
 4600 2848 0030A0E3 		mov	r3, #0
2240:../uvc.c      **** 								 {
 4601              		.loc 1 2240 0
 4602 284c 0700000A 		beq	.L396
2242:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4603              		.loc 1 2242 0
 4604 2850 0D10C7E5 		strb	r1, [r7, #13]
 4605              	.LVL510:
2243:../uvc.c      **** 									 dataIdx++;
 4606              		.loc 1 2243 0
 4607 2854 0C20A0E1 		mov	r2, ip
 4608 2858 0A008DE8 		stmia	sp, {r1, r3}
 4609 285c 2C009DE5 		ldr	r0, [sp, #44]
 4610 2860 0B30A0E1 		mov	r3, fp
 4611 2864 0510A0E1 		mov	r1, r5
 4612 2868 FEFFFFEB 		bl	cmdSet
 4613              	.LVL511:
2244:../uvc.c      **** 								 }
 4614              		.loc 1 2244 0
 4615 286c 0130A0E3 		mov	r3, #1
 4616              	.LVL512:
 4617              	.L396:
2246:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 4618              		.loc 1 2246 0
 4619 2870 0E20D7E5 		ldrb	r2, [r7, #14]	@ zero_extendqisi2
 4620 2874 28C09DE5 		ldr	ip, [sp, #40]
 4621 2878 0C0052E1 		cmp	r2, ip
 4622 287c 0700000A 		beq	.L397
2247:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 4623              		.loc 1 2247 0
 4624 2880 0EC0C7E5 		strb	ip, [r7, #14]
2248:../uvc.c      **** 								 }
 4625              		.loc 1 2248 0
 4626 2884 0510A0E1 		mov	r1, r5
 4627 2888 04308DE5 		str	r3, [sp, #4]
 4628 288c 00C08DE5 		str	ip, [sp]
 4629 2890 20209DE5 		ldr	r2, [sp, #32]
 4630 2894 0B30A0E1 		mov	r3, fp
 4631              	.LVL513:
 4632 2898 48051FE5 		ldr	r0, .L451+68
 4633 289c FEFFFFEB 		bl	cmdSet
 4634              	.LVL514:
 4635              	.L397:
2250:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4636              		.loc 1 2250 0
 4637 28a0 0130A0E3 		mov	r3, #1
 4638 28a4 1130C7E5 		strb	r3, [r7, #17]
2251:../uvc.c      **** 
 4639              		.loc 1 2251 0
 4640 28a8 2CC09DE5 		ldr	ip, [sp, #44]
 4641 28ac 1C009CE5 		ldr	r0, [ip, #28]
 4642 28b0 FEFFFFEB 		bl	_txe_mutex_put
 4643              	.LVL515:
 4644 28b4 00FEFFEA 		b	.L394
 4645              	.LVL516:
 4646              	.L443:
1635:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4647              		.loc 1 1635 0
 4648 28b8 004184E0 		add	r4, r4, r0, asl #2
 4649 28bc 203194E5 		ldr	r3, [r4, #288]
 4650              	.L420:
 4651 28c0 0DB0D3E5 		ldrb	fp, [r3, #13]	@ zero_extendqisi2
 4652              	.LVL517:
 4653 28c4 70451FE5 		ldr	r4, .L451+72
 4654 28c8 FFB00BE2 		and	fp, fp, #255
 4655 28cc 28B0C4E5 		strb	fp, [r4, #40]
1636:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4656              		.loc 1 1636 0
 4657 28d0 0E70D3E5 		ldrb	r7, [r3, #14]	@ zero_extendqisi2
 4658 28d4 0090A0E3 		mov	r9, #0
 4659 28d8 FF7007E2 		and	r7, r7, #255
 4660 28dc 2970C4E5 		strb	r7, [r4, #41]
 4661              	.LVL518:
 4662 28e0 09A0A0E1 		mov	r10, r9
 4663 28e4 06FCFFEA 		b	.L294
 4664              	.LVL519:
 4665              	.L447:
1485:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4666              		.loc 1 1485 0
 4667 28e8 004184E0 		add	r4, r4, r0, asl #2
 4668 28ec 203014E5 		ldr	r3, [r4, #-32]
 4669 28f0 F2FFFFEA 		b	.L420
 4670              	.L441:
1617:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4671              		.loc 1 1617 0
 4672 28f4 0B10A0E1 		mov	r1, fp
 4673 28f8 20009DE5 		ldr	r0, [sp, #32]
 4674              	.LVL520:
 4675 28fc FEFFFFEB 		bl	SensorGetControl
 4676              	.LVL521:
 4677 2900 AC451FE5 		ldr	r4, .L451+72
1618:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4678              		.loc 1 1618 0
 4679 2904 B8351FE5 		ldr	r3, .L451+64
1619:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
 4680              		.loc 1 1619 0
 4681 2908 0070A0E3 		mov	r7, #0
 4682 290c 2970C4E5 		strb	r7, [r4, #41]
 4683 2910 0790A0E1 		mov	r9, r7
 4684 2914 07A0A0E1 		mov	r10, r7
1618:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4685              		.loc 1 1618 0
 4686 2918 9505C3E5 		strb	r0, [r3, #1429]
1617:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4687              		.loc 1 1617 0
 4688 291c 2800C4E5 		strb	r0, [r4, #40]
1620:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4689              		.loc 1 1620 0
 4690 2920 9675C3E5 		strb	r7, [r3, #1430]
 4691              	.LVL522:
 4692 2924 00B0A0E1 		mov	fp, r0
 4693              	.LVL523:
 4694 2928 F5FBFFEA 		b	.L294
 4695              	.LVL524:
 4696              	.L395:
2239:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
 4697              		.loc 1 2239 0
 4698 292c DC251FE5 		ldr	r2, .L451+68
 4699 2930 0010E0E3 		mvn	r1, #0
 4700 2934 1C0092E5 		ldr	r0, [r2, #28]
2240:../uvc.c      **** 								 {
 4701              		.loc 1 2240 0
 4702 2938 057187E0 		add	r7, r7, r5, asl #2
2239:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
 4703              		.loc 1 2239 0
 4704 293c 2C208DE5 		str	r2, [sp, #44]
 4705 2940 18C08DE5 		str	ip, [sp, #24]
 4706 2944 FEFFFFEB 		bl	_txe_mutex_get
 4707              	.LVL525:
2240:../uvc.c      **** 								 {
 4708              		.loc 1 2240 0
 4709 2948 207197E5 		ldr	r7, [r7, #288]
 4710 294c B9FFFFEA 		b	.L433
 4711              	.LVL526:
 4712              	.L446:
1896:../uvc.c      **** 								 }
 4713              		.loc 1 1896 0
 4714 2950 04208DE5 		str	r2, [sp, #4]
 4715 2954 00C08DE5 		str	ip, [sp]
 4716 2958 20209DE5 		ldr	r2, [sp, #32]
 4717              	.LVL527:
 4718 295c 0B30A0E1 		mov	r3, fp
 4719 2960 1910A0E3 		mov	r1, #25
 4720 2964 14061FE5 		ldr	r0, .L451+68
 4721 2968 FEFFFFEB 		bl	cmdSet
 4722              	.LVL528:
 4723 296c A6FEFFEA 		b	.L354
 4724              	.LVL529:
 4725              	.L449:
1650:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4726              		.loc 1 1650 0
 4727 2970 0C00A0E1 		mov	r0, ip
 4728              	.LVL530:
 4729 2974 0B10A0E1 		mov	r1, fp
1651:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4730              		.loc 1 1651 0
 4731 2978 054184E0 		add	r4, r4, r5, asl #2
1650:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4732              		.loc 1 1650 0
 4733 297c 1C308DE5 		str	r3, [sp, #28]
 4734 2980 FEFFFFEB 		bl	SensorGetControl
 4735              	.LVL531:
1651:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4736              		.loc 1 1651 0
 4737 2984 202194E5 		ldr	r2, [r4, #288]
 4738              	.L419:
1650:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4739              		.loc 1 1650 0
 4740 2988 34461FE5 		ldr	r4, .L451+72
 4741 298c 0090A0E3 		mov	r9, #0
 4742 2990 2800C4E5 		strb	r0, [r4, #40]
 4743 2994 1C309DE5 		ldr	r3, [sp, #28]
 4744 2998 00B0A0E1 		mov	fp, r0
 4745              	.LVL532:
1651:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4746              		.loc 1 1651 0
 4747 299c 0D00C2E5 		strb	r0, [r2, #13]
 4748              	.LVL533:
 4749 29a0 0370A0E1 		mov	r7, r3
1652:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
 4750              		.loc 1 1652 0
 4751 29a4 2930C4E5 		strb	r3, [r4, #41]
 4752 29a8 09A0A0E1 		mov	r10, r9
1653:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4753              		.loc 1 1653 0
 4754 29ac 0E30C2E5 		strb	r3, [r2, #14]
 4755              	.LVL534:
 4756 29b0 D3FBFFEA 		b	.L294
 4757              	.LVL535:
 4758              	.L450:
1500:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4759              		.loc 1 1500 0
 4760 29b4 0C00A0E1 		mov	r0, ip
 4761              	.LVL536:
 4762 29b8 0B10A0E1 		mov	r1, fp
1501:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4763              		.loc 1 1501 0
 4764 29bc 054184E0 		add	r4, r4, r5, asl #2
1500:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4765              		.loc 1 1500 0
 4766 29c0 1C308DE5 		str	r3, [sp, #28]
 4767 29c4 FEFFFFEB 		bl	SensorGetControl
 4768              	.LVL537:
1501:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4769              		.loc 1 1501 0
 4770 29c8 202014E5 		ldr	r2, [r4, #-32]
 4771 29cc EDFFFFEA 		b	.L419
 4772              		.cfi_endproc
 4773              	.LFE3:
 4775              		.align	2
 4776              		.global	CTControlHandle
 4778              	CTControlHandle:
 4779              	.LFB4:
2276:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 4780              		.loc 1 2276 0
 4781              		.cfi_startproc
 4782              		@ args = 0, pretend = 0, frame = 24
 4783              		@ frame_needed = 0, uses_anonymous_args = 0
 4784              	.LVL538:
 4785 29d0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 4786              	.LCFI19:
 4787              		.cfi_def_cfa_offset 36
 4788              		.cfi_offset 4, -36
 4789              		.cfi_offset 5, -32
 4790              		.cfi_offset 6, -28
 4791              		.cfi_offset 7, -24
 4792              		.cfi_offset 8, -20
 4793              		.cfi_offset 9, -16
 4794              		.cfi_offset 10, -12
 4795              		.cfi_offset 11, -8
 4796              		.cfi_offset 14, -4
2295:../uvc.c      **** 
 4797              		.loc 1 2295 0
 4798 29d4 28B89FE5 		ldr	fp, .L491
2287:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4799              		.loc 1 2287 0
 4800 29d8 28389FE5 		ldr	r3, .L491+4
2295:../uvc.c      **** 
 4801              		.loc 1 2295 0
 4802 29dc 0050DBE5 		ldrb	r5, [fp]	@ zero_extendqisi2
2287:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4803              		.loc 1 2287 0
 4804 29e0 8080A0E1 		mov	r8, r0, asl #1
 4805 29e4 002088E0 		add	r2, r8, r0
 4806 29e8 822183E0 		add	r2, r3, r2, asl #3
2297:../uvc.c      **** 		 {
 4807              		.loc 1 2297 0
 4808 29ec 830055E3 		cmp	r5, #131
2276:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 4809              		.loc 1 2276 0
 4810 29f0 34D04DE2 		sub	sp, sp, #52
 4811              	.LCFI20:
 4812              		.cfi_def_cfa_offset 88
2276:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 4813              		.loc 1 2276 0
 4814 29f4 0060A0E1 		mov	r6, r0
2287:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4815              		.loc 1 2287 0
 4816 29f8 E795D2E5 		ldrb	r9, [r2, #1511]	@ zero_extendqisi2
 4817              	.LVL539:
2288:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 4818              		.loc 1 2288 0
 4819 29fc D8A5D2E5 		ldrb	r10, [r2, #1496]	@ zero_extendqisi2
 4820              	.LVL540:
2290:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 4821              		.loc 1 2290 0
 4822 2a00 DA75D2E5 		ldrb	r7, [r2, #1498]	@ zero_extendqisi2
 4823              	.LVL541:
2297:../uvc.c      **** 		 {
 4824              		.loc 1 2297 0
 4825 2a04 8000000A 		beq	.L455
 4826 2a08 2600009A 		bls	.L489
 4827 2a0c 850055E3 		cmp	r5, #133
 4828 2a10 7200000A 		beq	.L460
 4829 2a14 5000003A 		bcc	.L461
 4830 2a18 860055E3 		cmp	r5, #134
 4831 2a1c 4300000A 		beq	.L462
 4832 2a20 870055E3 		cmp	r5, #135
 4833 2a24 5F00001A 		bne	.L454
2359:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4834              		.loc 1 2359 0
 4835 2a28 E3C5D2E5 		ldrb	ip, [r2, #1507]	@ zero_extendqisi2
 4836 2a2c D8479FE5 		ldr	r4, .L491+8
2360:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4837              		.loc 1 2360 0
 4838 2a30 E425D2E5 		ldrb	r2, [r2, #1508]	@ zero_extendqisi2
 4839              	.LVL542:
 4840              	.L488:
2337:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 4841              		.loc 1 2337 0
 4842 2a34 0A1056E2 		subs	r1, r6, #10
 4843 2a38 006071E2 		rsbs	r6, r1, #0
 4844 2a3c 0160B6E0 		adcs	r6, r6, r1
2339:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4845              		.loc 1 2339 0
 4846 2a40 0030A0E3 		mov	r3, #0
 4847              	.LVL543:
2340:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4848              		.loc 1 2340 0
 4849 2a44 281084E2 		add	r1, r4, #40
 4850 2a48 0700A0E1 		mov	r0, r7
 4851              	.LVL544:
2337:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 4852              		.loc 1 2337 0
 4853 2a4c 2A60C4E5 		strb	r6, [r4, #42]
2335:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4854              		.loc 1 2335 0
 4855 2a50 28C0C4E5 		strb	ip, [r4, #40]
2336:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4856              		.loc 1 2336 0
 4857 2a54 2920C4E5 		strb	r2, [r4, #41]
2339:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4858              		.loc 1 2339 0
 4859 2a58 2B30C4E5 		strb	r3, [r4, #43]
2340:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4860              		.loc 1 2340 0
 4861 2a5c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4862              	.LVL545:
 4863 2a60 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
2342:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 4864              		.loc 1 2342 0
 4865 2a64 FF80A0E3 		mov	r8, #255
 4866 2a68 0860A0E1 		mov	r6, r8
 4867              	.LVL546:
 4868              	.L464:
2510:../uvc.c      **** }
 4869              		.loc 1 2510 0
 4870 2a6c 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 4871 2a70 FFC0A0E3 		mov	ip, #255
 4872 2a74 04108DE5 		str	r1, [sp, #4]
 4873 2a78 10108DE5 		str	r1, [sp, #16]
 4874 2a7c 08008DE5 		str	r0, [sp, #8]
 4875 2a80 00808DE5 		str	r8, [sp]
 4876 2a84 14708DE5 		str	r7, [sp, #20]
 4877 2a88 0520A0E1 		mov	r2, r5
 4878 2a8c 0630A0E1 		mov	r3, r6
 4879 2a90 0CC08DE5 		str	ip, [sp, #12]
 4880 2a94 74179FE5 		ldr	r1, .L491+12
 4881 2a98 0400A0E3 		mov	r0, #4
 4882 2a9c FEFFFFEB 		bl	CyU3PDebugPrint
 4883              	.LVL547:
2511:../uvc.c      **** 
 4884              		.loc 1 2511 0
 4885 2aa0 34D08DE2 		add	sp, sp, #52
 4886              		@ sp needed
 4887 2aa4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 4888              	.LVL548:
 4889              	.L489:
2297:../uvc.c      **** 		 {
 4890              		.loc 1 2297 0
 4891 2aa8 810055E3 		cmp	r5, #129
 4892 2aac 2E00000A 		beq	.L457
 4893 2ab0 1A00008A 		bhi	.L458
 4894 2ab4 010055E3 		cmp	r5, #1
 4895 2ab8 3A00001A 		bne	.L454
2368:../uvc.c      **** 			  glEp0Buffer, &readCount);
 4896              		.loc 1 2368 0
 4897 2abc 48479FE5 		ldr	r4, .L491+8
 4898 2ac0 2E208DE2 		add	r2, sp, #46
 4899              	.LVL549:
 4900 2ac4 2000A0E3 		mov	r0, #32
 4901              	.LVL550:
 4902 2ac8 281084E2 		add	r1, r4, #40
 4903 2acc 18308DE5 		str	r3, [sp, #24]
 4904 2ad0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4905              	.LVL551:
2370:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4906              		.loc 1 2370 0
 4907 2ad4 28C0D4E5 		ldrb	ip, [r4, #40]	@ zero_extendqisi2
2374:../uvc.c      **** 			  {
 4908              		.loc 1 2374 0
 4909 2ad8 012046E2 		sub	r2, r6, #1
2370:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4910              		.loc 1 2370 0
 4911 2adc 1CC08DE5 		str	ip, [sp, #28]
 4912              	.LVL552:
2371:../uvc.c      **** 			  value = Data1;
 4913              		.loc 1 2371 0
 4914 2ae0 29C0D4E5 		ldrb	ip, [r4, #41]	@ zero_extendqisi2
2374:../uvc.c      **** 			  {
 4915              		.loc 1 2374 0
 4916 2ae4 18309DE5 		ldr	r3, [sp, #24]
2371:../uvc.c      **** 			  value = Data1;
 4917              		.loc 1 2371 0
 4918 2ae8 20C08DE5 		str	ip, [sp, #32]
 4919              	.LVL553:
2374:../uvc.c      **** 			  {
 4920              		.loc 1 2374 0
 4921 2aec 090052E3 		cmp	r2, #9
 4922 2af0 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4923 2af4 1D0100EA 		b	.L465
 4924              	.L467:
 4925 2af8 282F0000 		.word	.L466
 4926 2afc 702F0000 		.word	.L465
 4927 2b00 282D0000 		.word	.L468
 4928 2b04 702F0000 		.word	.L465
 4929 2b08 702F0000 		.word	.L465
 4930 2b0c 702F0000 		.word	.L465
 4931 2b10 982C0000 		.word	.L469
 4932 2b14 702F0000 		.word	.L465
 4933 2b18 702F0000 		.word	.L465
 4934 2b1c 1C2C0000 		.word	.L470
 4935              	.LVL554:
 4936              	.L458:
2326:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 4937              		.loc 1 2326 0
 4938 2b20 DBC5D2E5 		ldrb	ip, [r2, #1499]	@ zero_extendqisi2
 4939 2b24 E0469FE5 		ldr	r4, .L491+8
2327:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 4940              		.loc 1 2327 0
 4941 2b28 DC25D2E5 		ldrb	r2, [r2, #1500]	@ zero_extendqisi2
 4942              	.LVL555:
 4943 2b2c C0FFFFEA 		b	.L488
 4944              	.LVL556:
 4945              	.L462:
2353:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4946              		.loc 1 2353 0
 4947 2b30 D4469FE5 		ldr	r4, .L491+8
 4948 2b34 E135D2E5 		ldrb	r3, [r2, #1505]	@ zero_extendqisi2
 4949 2b38 0410A0E1 		mov	r1, r4
 4950 2b3c 2830E1E5 		strb	r3, [r1, #40]!
2354:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4951              		.loc 1 2354 0
 4952 2b40 0100A0E3 		mov	r0, #1
 4953              	.LVL557:
2357:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 4954              		.loc 1 2357 0
 4955 2b44 FF80A0E3 		mov	r8, #255
2354:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4956              		.loc 1 2354 0
 4957 2b48 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4958              	.LVL558:
2357:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 4959              		.loc 1 2357 0
 4960 2b4c 0860A0E1 		mov	r6, r8
 4961 2b50 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
 4962 2b54 0170A0E3 		mov	r7, #1
 4963 2b58 C3FFFFEA 		b	.L464
 4964              	.LVL559:
 4965              	.L461:
2344:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4966              		.loc 1 2344 0
 4967 2b5c DFC5D2E5 		ldrb	ip, [r2, #1503]	@ zero_extendqisi2
 4968 2b60 A4469FE5 		ldr	r4, .L491+8
2345:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4969              		.loc 1 2345 0
 4970 2b64 E025D2E5 		ldrb	r2, [r2, #1504]	@ zero_extendqisi2
 4971              	.LVL560:
 4972 2b68 B1FFFFEA 		b	.L488
 4973              	.LVL561:
 4974              	.L457:
2311:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4975              		.loc 1 2311 0
 4976 2b6c 98469FE5 		ldr	r4, .L491+8
 4977 2b70 E595D2E5 		ldrb	r9, [r2, #1509]	@ zero_extendqisi2
2312:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4978              		.loc 1 2312 0
 4979 2b74 E6C5D2E5 		ldrb	ip, [r2, #1510]	@ zero_extendqisi2
2313:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4980              		.loc 1 2313 0
 4981 2b78 0030A0E3 		mov	r3, #0
2319:../uvc.c      **** 
 4982              		.loc 1 2319 0
 4983 2b7c 281084E2 		add	r1, r4, #40
 4984 2b80 0700A0E1 		mov	r0, r7
 4985              	.LVL562:
2324:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 4986              		.loc 1 2324 0
 4987 2b84 FF80A0E3 		mov	r8, #255
2312:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4988              		.loc 1 2312 0
 4989 2b88 29C0C4E5 		strb	ip, [r4, #41]
2311:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4990              		.loc 1 2311 0
 4991 2b8c 2890C4E5 		strb	r9, [r4, #40]
2313:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4992              		.loc 1 2313 0
 4993 2b90 2A30C4E5 		strb	r3, [r4, #42]
2314:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 4994              		.loc 1 2314 0
 4995 2b94 2B30C4E5 		strb	r3, [r4, #43]
 4996              	.LVL563:
2324:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 4997              		.loc 1 2324 0
 4998 2b98 0860A0E1 		mov	r6, r8
 4999              	.LVL564:
2319:../uvc.c      **** 
 5000              		.loc 1 2319 0
 5001 2b9c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5002              	.LVL565:
 5003 2ba0 0900A0E1 		mov	r0, r9
2324:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 5004              		.loc 1 2324 0
 5005 2ba4 B0FFFFEA 		b	.L464
 5006              	.LVL566:
 5007              	.L454:
2504:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 5008              		.loc 1 2504 0
 5009 2ba8 0000A0E3 		mov	r0, #0
 5010              	.LVL567:
 5011 2bac 0020A0E1 		mov	r2, r0
 5012              	.LVL568:
 5013 2bb0 0110A0E3 		mov	r1, #1
 5014 2bb4 FEFFFFEB 		bl	CyU3PUsbStall
 5015              	.LVL569:
2505:../uvc.c      **** 			  break;
 5016              		.loc 1 2505 0
 5017 2bb8 0620A0E1 		mov	r2, r6
 5018 2bbc 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 5019 2bc0 0400A0E3 		mov	r0, #4
 5020 2bc4 48169FE5 		ldr	r1, .L491+16
 5021 2bc8 FEFFFFEB 		bl	CyU3PDebugPrint
 5022              	.LVL570:
2506:../uvc.c      **** 		 }
 5023              		.loc 1 2506 0
 5024 2bcc FF00A0E3 		mov	r0, #255
 5025 2bd0 34469FE5 		ldr	r4, .L491+8
 5026 2bd4 0080A0E1 		mov	r8, r0
 5027 2bd8 0060A0E1 		mov	r6, r0
 5028 2bdc A2FFFFEA 		b	.L464
 5029              	.LVL571:
 5030              	.L460:
2301:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 5031              		.loc 1 2301 0
 5032 2be0 24469FE5 		ldr	r4, .L491+8
2302:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5033              		.loc 1 2302 0
 5034 2be4 0030A0E3 		mov	r3, #0
2303:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5035              		.loc 1 2303 0
 5036 2be8 281084E2 		add	r1, r4, #40
 5037 2bec 0200A0E3 		mov	r0, #2
 5038              	.LVL572:
2305:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5039              		.loc 1 2305 0
 5040 2bf0 FF80A0E3 		mov	r8, #255
2301:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 5041              		.loc 1 2301 0
 5042 2bf4 2870C4E5 		strb	r7, [r4, #40]
2302:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5043              		.loc 1 2302 0
 5044 2bf8 2930C4E5 		strb	r3, [r4, #41]
2305:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5045              		.loc 1 2305 0
 5046 2bfc 0860A0E1 		mov	r6, r8
 5047              	.LVL573:
2303:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5048              		.loc 1 2303 0
 5049 2c00 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5050              	.LVL574:
 5051 2c04 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
2305:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5052              		.loc 1 2305 0
 5053 2c08 97FFFFEA 		b	.L464
 5054              	.LVL575:
 5055              	.L455:
2335:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5056              		.loc 1 2335 0
 5057 2c0c DDC5D2E5 		ldrb	ip, [r2, #1501]	@ zero_extendqisi2
 5058 2c10 F4459FE5 		ldr	r4, .L491+8
2336:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5059              		.loc 1 2336 0
 5060 2c14 DE25D2E5 		ldrb	r2, [r2, #1502]	@ zero_extendqisi2
 5061              	.LVL576:
 5062 2c18 85FFFFEA 		b	.L488
 5063              	.LVL577:
 5064              	.L470:
2483:../uvc.c      **** 					  if(getData == 1)
 5065              		.loc 1 2483 0
 5066 2c1c F4659FE5 		ldr	r6, .L491+20
 5067 2c20 0010E0E3 		mvn	r1, #0
 5068 2c24 1C0096E5 		ldr	r0, [r6, #28]
 5069 2c28 FEFFFFEB 		bl	_txe_mutex_get
 5070              	.LVL578:
2484:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5071              		.loc 1 2484 0
 5072 2c2c 1CC09DE5 		ldr	ip, [sp, #28]
 5073 2c30 01005CE3 		cmp	ip, #1
2485:../uvc.c      **** 					  else if(getData == 0xff)
 5074              		.loc 1 2485 0
 5075 2c34 0400A003 		moveq	r0, #4
2484:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5076              		.loc 1 2484 0
 5077 2c38 6901000A 		beq	.L487
2486:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 5078              		.loc 1 2486 0
 5079 2c3c FF005CE3 		cmp	ip, #255
 5080 2c40 6601000A 		beq	.L490
2489:../uvc.c      **** 					  //dataIdx++;
 5081              		.loc 1 2489 0
 5082 2c44 0010A0E3 		mov	r1, #0
 5083 2c48 00108DE5 		str	r1, [sp]
 5084 2c4c 04108DE5 		str	r1, [sp, #4]
 5085 2c50 0A20A0E1 		mov	r2, r10
 5086 2c54 0930A0E1 		mov	r3, r9
 5087 2c58 0600A0E1 		mov	r0, r6
 5088 2c5c 2310A0E3 		mov	r1, #35
 5089 2c60 FEFFFFEB 		bl	cmdSet
 5090              	.LVL579:
 5091              	.L482:
2492:../uvc.c      **** #endif
 5092              		.loc 1 2492 0
 5093 2c64 1C0096E5 		ldr	r0, [r6, #28]
 5094 2c68 FEFFFFEB 		bl	_txe_mutex_put
 5095              	.LVL580:
2494:../uvc.c      **** 					  break;
 5096              		.loc 1 2494 0
 5097 2c6c 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 5098 2c70 1C609DE5 		ldr	r6, [sp, #28]
 5099 2c74 20809DE5 		ldr	r8, [sp, #32]
 5100 2c78 00108DE5 		str	r1, [sp]
 5101 2c7c 0620A0E1 		mov	r2, r6
 5102 2c80 0830A0E1 		mov	r3, r8
 5103 2c84 0400A0E3 		mov	r0, #4
 5104 2c88 8C159FE5 		ldr	r1, .L491+24
 5105 2c8c FEFFFFEB 		bl	CyU3PDebugPrint
 5106              	.LVL581:
2495:../uvc.c      **** 
 5107              		.loc 1 2495 0
 5108 2c90 FF00A0E3 		mov	r0, #255
 5109 2c94 74FFFFEA 		b	.L464
 5110              	.LVL582:
 5111              	.L469:
2460:../uvc.c      **** 					  {
 5112              		.loc 1 2460 0
 5113 2c98 FD05D3E5 		ldrb	r0, [r3, #1533]	@ zero_extendqisi2
 5114 2c9c 64C59FE5 		ldr	ip, .L491+4
 5115 2ca0 010050E3 		cmp	r0, #1
 5116 2ca4 08005013 		cmpne	r0, #8
 5117 2ca8 0000A013 		movne	r0, #0
 5118 2cac 0100A003 		moveq	r0, #1
 5119 2cb0 4601001A 		bne	.L479
 5120              	.LVL583:
2463:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 5121              		.loc 1 2463 0
 5122 2cb4 5CB59FE5 		ldr	fp, .L491+20
 5123 2cb8 0010E0E3 		mvn	r1, #0
 5124 2cbc 1C009BE5 		ldr	r0, [fp, #28]
 5125 2cc0 18C08DE5 		str	ip, [sp, #24]
 5126 2cc4 FEFFFFEB 		bl	_txe_mutex_get
 5127              	.LVL584:
2464:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5128              		.loc 1 2464 0
 5129 2cc8 1C009DE5 		ldr	r0, [sp, #28]
 5130 2ccc 0010A0E3 		mov	r1, #0
 5131 2cd0 0A20A0E1 		mov	r2, r10
 5132 2cd4 0930A0E1 		mov	r3, r9
 5133 2cd8 00008DE5 		str	r0, [sp]
 5134 2cdc 04108DE5 		str	r1, [sp, #4]
 5135 2ce0 0B00A0E1 		mov	r0, fp
 5136 2ce4 2210A0E3 		mov	r1, #34
 5137 2ce8 FEFFFFEB 		bl	cmdSet
 5138              	.LVL585:
2465:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 5139              		.loc 1 2465 0
 5140 2cec 1C009BE5 		ldr	r0, [fp, #28]
 5141 2cf0 FEFFFFEB 		bl	_txe_mutex_put
 5142              	.LVL586:
2468:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5143              		.loc 1 2468 0
 5144 2cf4 18C09DE5 		ldr	ip, [sp, #24]
 5145 2cf8 1C109DE5 		ldr	r1, [sp, #28]
2469:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5146              		.loc 1 2469 0
 5147 2cfc 20209DE5 		ldr	r2, [sp, #32]
2468:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5148              		.loc 1 2468 0
 5149 2d00 066088E0 		add	r6, r8, r6
 5150 2d04 86C18CE0 		add	ip, ip, r6, asl #3
2470:../uvc.c      **** 					  }else{
 5151              		.loc 1 2470 0
 5152 2d08 0130A0E3 		mov	r3, #1
2468:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5153              		.loc 1 2468 0
 5154 2d0c E515CCE5 		strb	r1, [ip, #1509]
2469:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5155              		.loc 1 2469 0
 5156 2d10 E625CCE5 		strb	r2, [ip, #1510]
2470:../uvc.c      **** 					  }else{
 5157              		.loc 1 2470 0
 5158 2d14 E835CCE5 		strb	r3, [ip, #1512]
 5159              	.LVL587:
 5160              	.L480:
 5161 2d18 2860D4E5 		ldrb	r6, [r4, #40]	@ zero_extendqisi2
 5162 2d1c 2980D4E5 		ldrb	r8, [r4, #41]	@ zero_extendqisi2
2477:../uvc.c      **** 			  	  case ZmOpRCtlID10:
 5163              		.loc 1 2477 0
 5164 2d20 FF00A0E3 		mov	r0, #255
 5165 2d24 50FFFFEA 		b	.L464
 5166              	.LVL588:
 5167              	.L468:
2426:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 5168              		.loc 1 2426 0
 5169 2d28 FD35D3E5 		ldrb	r3, [r3, #1533]	@ zero_extendqisi2
 5170 2d2c 010053E3 		cmp	r3, #1
 5171 2d30 04005313 		cmpne	r3, #4
 5172 2d34 2001001A 		bne	.L477
2425:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 5173              		.loc 1 2425 0
 5174 2d38 1CC09DE5 		ldr	ip, [sp, #28]
 5175 2d3c 20009DE5 		ldr	r0, [sp, #32]
 5176 2d40 00348CE1 		orr	r3, ip, r0, asl #8
2427:../uvc.c      **** 					  {
 5177              		.loc 1 2427 0
 5178 2d44 F90053E3 		cmp	r3, #249
 5179 2d48 1B01008A 		bhi	.L477
 5180              	.LVL589:
2432:../uvc.c      **** 							}else{
 5181              		.loc 1 2432 0
 5182 2d4c C80043E2 		sub	r0, r3, #200
 5183 2d50 C80053E3 		cmp	r3, #200
2434:../uvc.c      **** 							}
 5184              		.loc 1 2434 0
 5185 2d54 C82063E2 		rsb	r2, r3, #200
 5186 2d58 C0149FE5 		ldr	r1, .L491+28
 5187 2d5c 0208A091 		movls	r0, r2, asl #16
 5188 2d60 0008A081 		movhi	r0, r0, asl #16
 5189 2d64 642063E2 		rsb	r2, r3, #100
 5190 2d68 640053E3 		cmp	r3, #100
2432:../uvc.c      **** 							}else{
 5191              		.loc 1 2432 0
 5192 2d6c 64C043E2 		sub	ip, r3, #100
 5193 2d70 2008A0E1 		mov	r0, r0, lsr #16
 5194 2d74 0C28A081 		movhi	r2, ip, asl #16
 5195 2d78 0228A091 		movls	r2, r2, asl #16
 5196 2d7c 010050E1 		cmp	r0, r1
 5197 2d80 00E0A031 		movcc	lr, r0
 5198 2d84 01E0A021 		movcs	lr, r1
 5199 2d88 010050E1 		cmp	r0, r1
 5200 2d8c 27C043E2 		sub	ip, r3, #39
2434:../uvc.c      **** 							}
 5201              		.loc 1 2434 0
 5202 2d90 271063E2 		rsb	r1, r3, #39
 5203 2d94 00B0A033 		movcc	fp, #0
 5204 2d98 01B0A023 		movcs	fp, #1
 5205 2d9c 270053E3 		cmp	r3, #39
2432:../uvc.c      **** 							}else{
 5206              		.loc 1 2432 0
 5207 2da0 140043E2 		sub	r0, r3, #20
 5208 2da4 01C8A091 		movls	ip, r1, asl #16
 5209 2da8 2228A0E1 		mov	r2, r2, lsr #16
2434:../uvc.c      **** 							}
 5210              		.loc 1 2434 0
 5211 2dac 141063E2 		rsb	r1, r3, #20
 5212 2db0 0CC8A081 		movhi	ip, ip, asl #16
 5213 2db4 140053E3 		cmp	r3, #20
 5214 2db8 0018A081 		movhi	r1, r0, asl #16
 5215 2dbc 0118A091 		movls	r1, r1, asl #16
 5216 2dc0 0E0052E1 		cmp	r2, lr
2432:../uvc.c      **** 							}else{
 5217              		.loc 1 2432 0
 5218 2dc4 0A0043E2 		sub	r0, r3, #10
 5219 2dc8 01B0A033 		movcc	fp, #1
 5220 2dcc 2CC8A0E1 		mov	ip, ip, lsr #16
 5221 2dd0 02005EE1 		cmp	lr, r2
 5222 2dd4 0E20A031 		movcc	r2, lr
 5223 2dd8 0A0053E3 		cmp	r3, #10
 5224 2ddc 21E8A0E1 		mov	lr, r1, lsr #16
2434:../uvc.c      **** 							}
 5225              		.loc 1 2434 0
 5226 2de0 0A1063E2 		rsb	r1, r3, #10
 5227 2de4 0118A091 		movls	r1, r1, asl #16
 5228 2de8 0018A081 		movhi	r1, r0, asl #16
 5229 2dec 0C0052E1 		cmp	r2, ip
 5230 2df0 02B0A083 		movhi	fp, #2
 5231 2df4 24B08DE5 		str	fp, [sp, #36]
2432:../uvc.c      **** 							}else{
 5232              		.loc 1 2432 0
 5233 2df8 050043E2 		sub	r0, r3, #5
 5234 2dfc 02005CE1 		cmp	ip, r2
 5235 2e00 0C20A031 		movcc	r2, ip
 5236 2e04 21B8A0E1 		mov	fp, r1, lsr #16
2434:../uvc.c      **** 							}
 5237              		.loc 1 2434 0
 5238 2e08 05C063E2 		rsb	ip, r3, #5
 5239 2e0c 050053E3 		cmp	r3, #5
 5240 2e10 24109DE5 		ldr	r1, [sp, #36]
 5241 2e14 00C8A081 		movhi	ip, r0, asl #16
 5242 2e18 0CC8A091 		movls	ip, ip, asl #16
 5243 2e1c 0E0052E1 		cmp	r2, lr
 5244 2e20 0310A083 		movhi	r1, #3
 5245 2e24 24108DE5 		str	r1, [sp, #36]
 5246 2e28 02005EE1 		cmp	lr, r2
 5247 2e2c 0E00A031 		movcc	r0, lr
 5248 2e30 0200A021 		movcs	r0, r2
 5249 2e34 021063E2 		rsb	r1, r3, #2
2432:../uvc.c      **** 							}else{
 5250              		.loc 1 2432 0
 5251 2e38 022043E2 		sub	r2, r3, #2
 5252 2e3c 020053E3 		cmp	r3, #2
 5253 2e40 0128A091 		movls	r2, r1, asl #16
 5254 2e44 0228A081 		movhi	r2, r2, asl #16
 5255 2e48 0B0050E1 		cmp	r0, fp
 5256 2e4c 24E09DE5 		ldr	lr, [sp, #36]
 5257 2e50 2CC8A0E1 		mov	ip, ip, lsr #16
 5258 2e54 04E0A083 		movhi	lr, #4
 5259 2e58 00005BE1 		cmp	fp, r0
 5260 2e5c 0B00A031 		movcc	r0, fp
 5261 2e60 00005CE1 		cmp	ip, r0
 5262 2e64 0C10A031 		movcc	r1, ip
 5263 2e68 0010A021 		movcs	r1, r0
 5264 2e6c 0C0050E1 		cmp	r0, ip
 5265 2e70 05E0A083 		movhi	lr, #5
 5266 2e74 01C043E2 		sub	ip, r3, #1
 5267 2e78 010053E3 		cmp	r3, #1
2434:../uvc.c      **** 							}
 5268              		.loc 1 2434 0
 5269 2e7c 010063E2 		rsb	r0, r3, #1
 5270 2e80 0C38A081 		movhi	r3, ip, asl #16
2444:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 5271              		.loc 1 2444 0
 5272 2e84 8CC39FE5 		ldr	ip, .L491+20
 5273 2e88 2228A0E1 		mov	r2, r2, lsr #16
 5274 2e8c 0038A091 		movls	r3, r0, asl #16
 5275 2e90 010052E1 		cmp	r2, r1
 5276 2e94 0200A031 		movcc	r0, r2
 5277 2e98 0100A021 		movcs	r0, r1
 5278 2e9c 020051E1 		cmp	r1, r2
 5279 2ea0 0E20A091 		movls	r2, lr
 5280 2ea4 0620A083 		movhi	r2, #6
 5281              	.LVL590:
 5282 2ea8 0010E0E3 		mvn	r1, #0
 5283              	.LVL591:
 5284 2eac 230850E1 		cmp	r0, r3, lsr #16
 5285 2eb0 1C009CE5 		ldr	r0, [ip, #28]
 5286 2eb4 02B0A091 		movls	fp, r2
 5287 2eb8 07B0A083 		movhi	fp, #7
 5288              	.LVL592:
 5289 2ebc 18C08DE5 		str	ip, [sp, #24]
 5290 2ec0 FEFFFFEB 		bl	_txe_mutex_get
 5291              	.LVL593:
2445:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5292              		.loc 1 2445 0
 5293 2ec4 18C09DE5 		ldr	ip, [sp, #24]
2441:../uvc.c      **** 
 5294              		.loc 1 2441 0
 5295 2ec8 01B08BE2 		add	fp, fp, #1
 5296              	.LVL594:
2445:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5297              		.loc 1 2445 0
 5298 2ecc 0010A0E3 		mov	r1, #0
 5299 2ed0 0A20A0E1 		mov	r2, r10
 5300 2ed4 0930A0E1 		mov	r3, r9
 5301 2ed8 0C00A0E1 		mov	r0, ip
 5302 2edc 04108DE5 		str	r1, [sp, #4]
 5303 2ee0 00B08DE5 		str	fp, [sp]
 5304 2ee4 0310A0E3 		mov	r1, #3
 5305 2ee8 FEFFFFEB 		bl	cmdSet
 5306              	.LVL595:
2446:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 5307              		.loc 1 2446 0
 5308 2eec 18C09DE5 		ldr	ip, [sp, #24]
 5309 2ef0 1C009CE5 		ldr	r0, [ip, #28]
 5310 2ef4 FEFFFFEB 		bl	_txe_mutex_put
 5311              	.LVL596:
2452:../uvc.c      **** 					  }else{
 5312              		.loc 1 2452 0
 5313 2ef8 08C39FE5 		ldr	ip, .L491+4
2449:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5314              		.loc 1 2449 0
 5315 2efc 04239FE5 		ldr	r2, .L491+4
2452:../uvc.c      **** 					  }else{
 5316              		.loc 1 2452 0
 5317 2f00 79B3CCE5 		strb	fp, [ip, #889]
2449:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5318              		.loc 1 2449 0
 5319 2f04 1CC09DE5 		ldr	ip, [sp, #28]
 5320 2f08 063088E0 		add	r3, r8, r6
 5321 2f0c 833182E0 		add	r3, r2, r3, asl #3
 5322 2f10 E5C5C3E5 		strb	ip, [r3, #1509]
2450:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5323              		.loc 1 2450 0
 5324 2f14 20C09DE5 		ldr	ip, [sp, #32]
2451:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5325              		.loc 1 2451 0
 5326 2f18 0120A0E3 		mov	r2, #1
2450:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5327              		.loc 1 2450 0
 5328 2f1c E6C5C3E5 		strb	ip, [r3, #1510]
2451:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5329              		.loc 1 2451 0
 5330 2f20 E825C3E5 		strb	r2, [r3, #1512]
2452:../uvc.c      **** 					  }else{
 5331              		.loc 1 2452 0
 5332 2f24 7BFFFFEA 		b	.L480
 5333              	.LVL597:
 5334              	.L466:
2383:../uvc.c      **** 						case 1:
 5335              		.loc 1 2383 0
 5336 2f28 1CC09DE5 		ldr	ip, [sp, #28]
2379:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5337              		.loc 1 2379 0
 5338 2f2c 066088E0 		add	r6, r8, r6
 5339 2f30 866183E0 		add	r6, r3, r6, asl #3
2380:../uvc.c      **** 				    getData = glEp0Buffer[0];
 5340              		.loc 1 2380 0
 5341 2f34 0110A0E3 		mov	r1, #1
2383:../uvc.c      **** 						case 1:
 5342              		.loc 1 2383 0
 5343 2f38 01204CE2 		sub	r2, ip, #1
2379:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5344              		.loc 1 2379 0
 5345 2f3c E5C5C6E5 		strb	ip, [r6, #1509]
2380:../uvc.c      **** 				    getData = glEp0Buffer[0];
 5346              		.loc 1 2380 0
 5347 2f40 E815C6E5 		strb	r1, [r6, #1512]
 5348              	.LVL598:
2383:../uvc.c      **** 						case 1:
 5349              		.loc 1 2383 0
 5350 2f44 070052E3 		cmp	r2, #7
 5351 2f48 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 5352 2f4c 960000EA 		b	.L471
 5353              	.L473:
 5354 2f50 48310000 		.word	.L472
 5355 2f54 AC300000 		.word	.L474
 5356 2f58 AC310000 		.word	.L471
 5357 2f5c 44300000 		.word	.L475
 5358 2f60 AC310000 		.word	.L471
 5359 2f64 AC310000 		.word	.L471
 5360 2f68 AC310000 		.word	.L471
 5361 2f6c A42F0000 		.word	.L476
 5362              	.LVL599:
 5363              	.L465:
2498:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5364              		.loc 1 2498 0
 5365 2f70 1CC09DE5 		ldr	ip, [sp, #28]
 5366 2f74 068088E0 		add	r8, r8, r6
 5367 2f78 888183E0 		add	r8, r3, r8, asl #3
2499:../uvc.c      **** 			  		 break;
 5368              		.loc 1 2499 0
 5369 2f7c 0620A0E1 		mov	r2, r6
 5370 2f80 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 5371 2f84 0400A0E3 		mov	r0, #4
 5372 2f88 94129FE5 		ldr	r1, .L491+32
2498:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5373              		.loc 1 2498 0
 5374 2f8c E5C5C8E5 		strb	ip, [r8, #1509]
2499:../uvc.c      **** 			  		 break;
 5375              		.loc 1 2499 0
 5376 2f90 FEFFFFEB 		bl	CyU3PDebugPrint
 5377              	.LVL600:
2500:../uvc.c      **** 			  }
 5378              		.loc 1 2500 0
 5379 2f94 FF00A0E3 		mov	r0, #255
 5380 2f98 0080A0E1 		mov	r8, r0
 5381 2f9c 0060A0E1 		mov	r6, r0
 5382 2fa0 B1FEFFEA 		b	.L464
 5383              	.LVL601:
 5384              	.L476:
2402:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5385              		.loc 1 2402 0
 5386 2fa4 6C629FE5 		ldr	r6, .L491+20
2400:../uvc.c      **** 			  		    	dataIdx = 0;
 5387              		.loc 1 2400 0
 5388 2fa8 0080A0E3 		mov	r8, #0
2402:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5389              		.loc 1 2402 0
 5390 2fac 1C0096E5 		ldr	r0, [r6, #28]
 5391 2fb0 0010E0E3 		mvn	r1, #0
2400:../uvc.c      **** 			  		    	dataIdx = 0;
 5392              		.loc 1 2400 0
 5393 2fb4 7983C3E5 		strb	r8, [r3, #889]
 5394              	.LVL602:
2402:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5395              		.loc 1 2402 0
 5396 2fb8 FEFFFFEB 		bl	_txe_mutex_get
 5397              	.LVL603:
2403:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5398              		.loc 1 2403 0
 5399 2fbc 0A20A0E1 		mov	r2, r10
 5400 2fc0 0930A0E1 		mov	r3, r9
 5401 2fc4 1010A0E3 		mov	r1, #16
 5402 2fc8 00808DE5 		str	r8, [sp]
 5403 2fcc 04808DE5 		str	r8, [sp, #4]
 5404 2fd0 0600A0E1 		mov	r0, r6
 5405 2fd4 FEFFFFEB 		bl	cmdSet
 5406              	.LVL604:
2404:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
 5407              		.loc 1 2404 0
 5408 2fd8 1C0096E5 		ldr	r0, [r6, #28]
 5409 2fdc FEFFFFEB 		bl	_txe_mutex_put
 5410              	.LVL605:
 5411              	.LBB82:
 5412              	.LBB83:
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5413              		.loc 1 1278 0
 5414 2fe0 1C0096E5 		ldr	r0, [r6, #28]
 5415 2fe4 0010E0E3 		mvn	r1, #0
 5416 2fe8 FEFFFFEB 		bl	_txe_mutex_get
 5417              	.LVL606:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5418              		.loc 1 1279 0
 5419 2fec 0130A0E3 		mov	r3, #1
 5420 2ff0 04808DE5 		str	r8, [sp, #4]
 5421 2ff4 0600A0E1 		mov	r0, r6
 5422 2ff8 00308DE5 		str	r3, [sp]
 5423 2ffc 2010A0E3 		mov	r1, #32
 5424 3000 2720A0E3 		mov	r2, #39
 5425 3004 3030A0E3 		mov	r3, #48
 5426 3008 FEFFFFEB 		bl	cmdSet
 5427              	.LVL607:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5428              		.loc 1 1280 0
 5429 300c 0230A0E3 		mov	r3, #2
 5430 3010 04808DE5 		str	r8, [sp, #4]
 5431 3014 0600A0E1 		mov	r0, r6
 5432 3018 00308DE5 		str	r3, [sp]
 5433 301c 2110A0E3 		mov	r1, #33
 5434 3020 2520A0E3 		mov	r2, #37
 5435 3024 3030A0E3 		mov	r3, #48
 5436 3028 FEFFFFEB 		bl	cmdSet
 5437              	.LVL608:
1281:../uvc.c      **** }
 5438              		.loc 1 1281 0
 5439 302c 1C0096E5 		ldr	r0, [r6, #28]
 5440 3030 FEFFFFEB 		bl	_txe_mutex_put
 5441              	.LVL609:
 5442 3034 FF00A0E3 		mov	r0, #255
 5443 3038 0080A0E1 		mov	r8, r0
 5444 303c 0860A0E3 		mov	r6, #8
 5445 3040 89FEFFEA 		b	.L464
 5446              	.LVL610:
 5447              	.L475:
 5448              	.LBE83:
 5449              	.LBE82:
 5450              	.LBB84:
 5451              	.LBB85:
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5452              		.loc 1 1278 0
 5453 3044 CC619FE5 		ldr	r6, .L491+20
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5454              		.loc 1 1279 0
 5455 3048 0080A0E3 		mov	r8, #0
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5456              		.loc 1 1278 0
 5457 304c 0010E0E3 		mvn	r1, #0
 5458 3050 1C0096E5 		ldr	r0, [r6, #28]
 5459 3054 FEFFFFEB 		bl	_txe_mutex_get
 5460              	.LVL611:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5461              		.loc 1 1279 0
 5462 3058 0600A0E1 		mov	r0, r6
 5463 305c 00808DE5 		str	r8, [sp]
 5464 3060 04808DE5 		str	r8, [sp, #4]
 5465 3064 2010A0E3 		mov	r1, #32
 5466 3068 2720A0E3 		mov	r2, #39
 5467 306c 3030A0E3 		mov	r3, #48
 5468 3070 FEFFFFEB 		bl	cmdSet
 5469              	.LVL612:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5470              		.loc 1 1280 0
 5471 3074 0130A0E3 		mov	r3, #1
 5472 3078 04808DE5 		str	r8, [sp, #4]
 5473 307c 0600A0E1 		mov	r0, r6
 5474 3080 00308DE5 		str	r3, [sp]
 5475 3084 2110A0E3 		mov	r1, #33
 5476 3088 2520A0E3 		mov	r2, #37
 5477 308c 3030A0E3 		mov	r3, #48
 5478 3090 FEFFFFEB 		bl	cmdSet
 5479              	.LVL613:
1281:../uvc.c      **** }
 5480              		.loc 1 1281 0
 5481 3094 1C0096E5 		ldr	r0, [r6, #28]
 5482 3098 FEFFFFEB 		bl	_txe_mutex_put
 5483              	.LVL614:
 5484 309c FF00A0E3 		mov	r0, #255
 5485 30a0 0080A0E1 		mov	r8, r0
 5486 30a4 0460A0E3 		mov	r6, #4
 5487 30a8 6FFEFFEA 		b	.L464
 5488              	.LVL615:
 5489              	.L474:
 5490              	.LBE85:
 5491              	.LBE84:
2390:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5492              		.loc 1 2390 0
 5493 30ac 64619FE5 		ldr	r6, .L491+20
2388:../uvc.c      **** 							dataIdx = 0;
 5494              		.loc 1 2388 0
 5495 30b0 0080A0E3 		mov	r8, #0
2390:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5496              		.loc 1 2390 0
 5497 30b4 1C0096E5 		ldr	r0, [r6, #28]
 5498 30b8 0010E0E3 		mvn	r1, #0
2388:../uvc.c      **** 							dataIdx = 0;
 5499              		.loc 1 2388 0
 5500 30bc 7983C3E5 		strb	r8, [r3, #889]
 5501              	.LVL616:
2390:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5502              		.loc 1 2390 0
 5503 30c0 FEFFFFEB 		bl	_txe_mutex_get
 5504              	.LVL617:
2391:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5505              		.loc 1 2391 0
 5506 30c4 0A20A0E1 		mov	r2, r10
 5507 30c8 0930A0E1 		mov	r3, r9
 5508 30cc 1010A0E3 		mov	r1, #16
 5509 30d0 00808DE5 		str	r8, [sp]
 5510 30d4 04808DE5 		str	r8, [sp, #4]
 5511 30d8 0600A0E1 		mov	r0, r6
 5512 30dc FEFFFFEB 		bl	cmdSet
 5513              	.LVL618:
2392:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
 5514              		.loc 1 2392 0
 5515 30e0 1C0096E5 		ldr	r0, [r6, #28]
 5516 30e4 FEFFFFEB 		bl	_txe_mutex_put
 5517              	.LVL619:
 5518              	.LBB86:
 5519              	.LBB87:
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5520              		.loc 1 1278 0
 5521 30e8 1C0096E5 		ldr	r0, [r6, #28]
 5522 30ec 0010E0E3 		mvn	r1, #0
 5523 30f0 FEFFFFEB 		bl	_txe_mutex_get
 5524              	.LVL620:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5525              		.loc 1 1279 0
 5526 30f4 00808DE5 		str	r8, [sp]
 5527 30f8 04808DE5 		str	r8, [sp, #4]
 5528 30fc 0600A0E1 		mov	r0, r6
 5529 3100 2010A0E3 		mov	r1, #32
 5530 3104 2720A0E3 		mov	r2, #39
 5531 3108 3030A0E3 		mov	r3, #48
 5532 310c FEFFFFEB 		bl	cmdSet
 5533              	.LVL621:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5534              		.loc 1 1280 0
 5535 3110 0130A0E3 		mov	r3, #1
 5536 3114 04808DE5 		str	r8, [sp, #4]
 5537 3118 0600A0E1 		mov	r0, r6
 5538 311c 00308DE5 		str	r3, [sp]
 5539 3120 2110A0E3 		mov	r1, #33
 5540 3124 2520A0E3 		mov	r2, #37
 5541 3128 3030A0E3 		mov	r3, #48
 5542 312c FEFFFFEB 		bl	cmdSet
 5543              	.LVL622:
1281:../uvc.c      **** }
 5544              		.loc 1 1281 0
 5545 3130 1C0096E5 		ldr	r0, [r6, #28]
 5546 3134 FEFFFFEB 		bl	_txe_mutex_put
 5547              	.LVL623:
 5548 3138 FF00A0E3 		mov	r0, #255
 5549 313c 0080A0E1 		mov	r8, r0
 5550 3140 0260A0E3 		mov	r6, #2
 5551 3144 48FEFFEA 		b	.L464
 5552              	.LVL624:
 5553              	.L472:
 5554              	.LBE87:
 5555              	.LBE86:
 5556              	.LBB88:
 5557              	.LBB89:
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5558              		.loc 1 1278 0
 5559 3148 C8809FE5 		ldr	r8, .L491+20
 5560 314c 0010E0E3 		mvn	r1, #0
 5561 3150 1C0098E5 		ldr	r0, [r8, #28]
 5562 3154 FEFFFFEB 		bl	_txe_mutex_get
 5563              	.LVL625:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5564              		.loc 1 1279 0
 5565 3158 0090A0E3 		mov	r9, #0
 5566              	.LVL626:
 5567 315c 0160A0E3 		mov	r6, #1
 5568 3160 0800A0E1 		mov	r0, r8
 5569 3164 2010A0E3 		mov	r1, #32
 5570 3168 2720A0E3 		mov	r2, #39
 5571 316c 3030A0E3 		mov	r3, #48
 5572 3170 40028DE8 		stmia	sp, {r6, r9}
 5573 3174 FEFFFFEB 		bl	cmdSet
 5574              	.LVL627:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5575              		.loc 1 1280 0
 5576 3178 0230A0E3 		mov	r3, #2
 5577 317c 0800A0E1 		mov	r0, r8
 5578 3180 00308DE5 		str	r3, [sp]
 5579 3184 2110A0E3 		mov	r1, #33
 5580 3188 2520A0E3 		mov	r2, #37
 5581 318c 3030A0E3 		mov	r3, #48
 5582 3190 04908DE5 		str	r9, [sp, #4]
 5583 3194 FEFFFFEB 		bl	cmdSet
 5584              	.LVL628:
1281:../uvc.c      **** }
 5585              		.loc 1 1281 0
 5586 3198 1C0098E5 		ldr	r0, [r8, #28]
 5587 319c FEFFFFEB 		bl	_txe_mutex_put
 5588              	.LVL629:
 5589 31a0 FF00A0E3 		mov	r0, #255
 5590 31a4 0080A0E1 		mov	r8, r0
 5591 31a8 2FFEFFEA 		b	.L464
 5592              	.LVL630:
 5593              	.L471:
 5594              	.LBE89:
 5595              	.LBE88:
2383:../uvc.c      **** 						case 1:
 5596              		.loc 1 2383 0
 5597 31ac FF00A0E3 		mov	r0, #255
 5598 31b0 0C60A0E1 		mov	r6, ip
 5599 31b4 0080A0E1 		mov	r8, r0
 5600 31b8 2BFEFFEA 		b	.L464
 5601              	.LVL631:
 5602              	.L477:
2454:../uvc.c      **** 					  }
 5603              		.loc 1 2454 0
 5604 31bc 0000A0E3 		mov	r0, #0
 5605 31c0 0020A0E1 		mov	r2, r0
 5606 31c4 0110A0E3 		mov	r1, #1
 5607 31c8 FEFFFFEB 		bl	CyU3PUsbStall
 5608              	.LVL632:
 5609 31cc D1FEFFEA 		b	.L480
 5610              	.LVL633:
 5611              	.L479:
2472:../uvc.c      **** 					  }
 5612              		.loc 1 2472 0
 5613 31d0 0020A0E1 		mov	r2, r0
 5614 31d4 0110A0E3 		mov	r1, #1
 5615 31d8 FEFFFFEB 		bl	CyU3PUsbStall
 5616              	.LVL634:
 5617 31dc CDFEFFEA 		b	.L480
 5618              	.LVL635:
 5619              	.L490:
2487:../uvc.c      **** 					  else
 5620              		.loc 1 2487 0
 5621 31e0 0800A0E3 		mov	r0, #8
 5622              	.L487:
 5623 31e4 0010A0E3 		mov	r1, #0
 5624 31e8 03008DE8 		stmia	sp, {r0, r1}
 5625 31ec 0A20A0E1 		mov	r2, r10
 5626 31f0 0930A0E1 		mov	r3, r9
 5627 31f4 0600A0E1 		mov	r0, r6
 5628 31f8 2310A0E3 		mov	r1, #35
 5629 31fc FEFFFFEB 		bl	cmdSet
 5630              	.LVL636:
 5631 3200 97FEFFEA 		b	.L482
 5632              	.L492:
 5633              		.align	2
 5634              	.L491:
 5635 3204 00000000 		.word	bRequest
 5636 3208 00000000 		.word	.LANCHOR1
 5637 320c 00000000 		.word	.LANCHOR0
 5638 3210 EC060000 		.word	.LC39
 5639 3214 C8060000 		.word	.LC38
 5640 3218 00000000 		.word	cmdQu
 5641 321c 7C060000 		.word	.LC36
 5642 3220 FFFF0000 		.word	65535
 5643 3224 A4060000 		.word	.LC37
 5644              		.cfi_endproc
 5645              	.LFE4:
 5647              		.align	2
 5648              		.global	CamDefSet
 5650              	CamDefSet:
 5651              	.LFB5:
2515:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
 5652              		.loc 1 2515 0
 5653              		.cfi_startproc
 5654              		@ args = 0, pretend = 0, frame = 24
 5655              		@ frame_needed = 0, uses_anonymous_args = 0
 5656              	.LVL637:
 5657 3228 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5658              	.LCFI21:
 5659              		.cfi_def_cfa_offset 36
 5660              		.cfi_offset 4, -36
 5661              		.cfi_offset 5, -32
 5662              		.cfi_offset 6, -28
 5663              		.cfi_offset 7, -24
 5664              		.cfi_offset 8, -20
 5665              		.cfi_offset 9, -16
 5666              		.cfi_offset 10, -12
 5667              		.cfi_offset 11, -8
 5668              		.cfi_offset 14, -4
2522:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5669              		.loc 1 2522 0
 5670 322c B0429FE5 		ldr	r4, .L496
2527:../uvc.c      ****     if(Data1&0x80){
 5671              		.loc 1 2527 0
 5672 3230 B0229FE5 		ldr	r2, .L496+4
2524:../uvc.c      ****     Data1 = Data0;
 5673              		.loc 1 2524 0
 5674 3234 0F52D4E5 		ldrb	r5, [r4, #527]	@ zero_extendqisi2
2515:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
 5675              		.loc 1 2515 0
 5676 3238 2CD04DE2 		sub	sp, sp, #44
 5677              	.LCFI22:
 5678              		.cfi_def_cfa_offset 80
2527:../uvc.c      ****     if(Data1&0x80){
 5679              		.loc 1 2527 0
 5680 323c 1C0092E5 		ldr	r0, [r2, #28]
 5681 3240 0010E0E3 		mvn	r1, #0
2529:../uvc.c      ****     }else{
 5682              		.loc 1 2529 0
 5683 3244 2563A0E1 		mov	r6, r5, lsr #6
2523:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5684              		.loc 1 2523 0
 5685 3248 1372D4E5 		ldrb	r7, [r4, #531]	@ zero_extendqisi2
2522:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5686              		.loc 1 2522 0
 5687 324c 0592D4E5 		ldrb	r9, [r4, #517]	@ zero_extendqisi2
 5688              	.LVL638:
2527:../uvc.c      ****     if(Data1&0x80){
 5689              		.loc 1 2527 0
 5690 3250 FEFFFFEB 		bl	_txe_mutex_get
 5691              	.LVL639:
2528:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5692              		.loc 1 2528 0
 5693 3254 800015E3 		tst	r5, #128
2529:../uvc.c      ****     }else{
 5694              		.loc 1 2529 0
 5695 3258 01600612 		andne	r6, r6, #1
 5696 325c 0660E011 		mvnne	r6, r6
 5697 3260 3B600612 		andne	r6, r6, #59
 5698 3264 0660E011 		mvnne	r6, r6
 5699 3268 FF600612 		andne	r6, r6, #255
 5700              	.LVL640:
2531:../uvc.c      ****     }
 5701              		.loc 1 2531 0
 5702 326c C6608603 		orreq	r6, r6, #198
 5703              	.LVL641:
2535:../uvc.c      **** 
 5704              		.loc 1 2535 0
 5705 3270 0080A0E3 		mov	r8, #0
2533:../uvc.c      **** 
 5706              		.loc 1 2533 0
 5707 3274 0551A0E1 		mov	r5, r5, asl #2
 5708              	.LVL642:
 5709 3278 FF5005E2 		and	r5, r5, #255
 5710              	.LVL643:
2538:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5711              		.loc 1 2538 0
 5712 327c 01A0A0E3 		mov	r10, #1
2535:../uvc.c      **** 
 5713              		.loc 1 2535 0
 5714 3280 00608DE5 		str	r6, [sp]
 5715 3284 0920A0E1 		mov	r2, r9
 5716 3288 0730A0E1 		mov	r3, r7
 5717 328c 04808DE5 		str	r8, [sp, #4]
 5718 3290 0110A0E3 		mov	r1, #1
 5719 3294 4C029FE5 		ldr	r0, .L496+4
 5720 3298 FEFFFFEB 		bl	cmdSet
 5721              	.LVL644:
2538:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5722              		.loc 1 2538 0
 5723 329c 0422D4E5 		ldrb	r2, [r4, #516]	@ zero_extendqisi2
 5724 32a0 0730A0E1 		mov	r3, r7
 5725 32a4 0A10A0E1 		mov	r1, r10
 5726 32a8 00508DE5 		str	r5, [sp]
 5727 32ac 04A08DE5 		str	r10, [sp, #4]
 5728 32b0 30029FE5 		ldr	r0, .L496+4
 5729 32b4 FEFFFFEB 		bl	cmdSet
 5730              	.LVL645:
2541:../uvc.c      **** 
 5731              		.loc 1 2541 0
 5732 32b8 0620A0E1 		mov	r2, r6
 5733 32bc 0530A0E1 		mov	r3, r5
 5734 32c0 24129FE5 		ldr	r1, .L496+8
 5735 32c4 0400A0E3 		mov	r0, #4
2540:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5736              		.loc 1 2540 0
 5737 32c8 1262C4E5 		strb	r6, [r4, #530]
2539:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5738              		.loc 1 2539 0
 5739 32cc 1152C4E5 		strb	r5, [r4, #529]
2541:../uvc.c      **** 
 5740              		.loc 1 2541 0
 5741 32d0 FEFFFFEB 		bl	CyU3PDebugPrint
 5742              	.LVL646:
2546:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5743              		.loc 1 2546 0
 5744 32d4 2762D4E5 		ldrb	r6, [r4, #551]	@ zero_extendqisi2
 5745              	.LVL647:
2547:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5746              		.loc 1 2547 0
 5747 32d8 1C22D4E5 		ldrb	r2, [r4, #540]	@ zero_extendqisi2
 5748 32dc 2B32D4E5 		ldrb	r3, [r4, #555]	@ zero_extendqisi2
 5749 32e0 40018DE8 		stmia	sp, {r6, r8}
 5750 32e4 FC019FE5 		ldr	r0, .L496+4
 5751 32e8 0210A0E3 		mov	r1, #2
 5752 32ec FEFFFFEB 		bl	cmdSet
 5753              	.LVL648:
2550:../uvc.c      **** 
 5754              		.loc 1 2550 0
 5755 32f0 0620A0E1 		mov	r2, r6
 5756 32f4 0530A0E1 		mov	r3, r5
 5757 32f8 EC119FE5 		ldr	r1, .L496+8
 5758 32fc 0400A0E3 		mov	r0, #4
2548:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
 5759              		.loc 1 2548 0
 5760 3300 2952C4E5 		strb	r5, [r4, #553]
2549:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5761              		.loc 1 2549 0
 5762 3304 6954C4E5 		strb	r5, [r4, #1129]
2550:../uvc.c      **** 
 5763              		.loc 1 2550 0
 5764 3308 FEFFFFEB 		bl	CyU3PDebugPrint
 5765              	.LVL649:
2555:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5766              		.loc 1 2555 0
 5767 330c 6F72D4E5 		ldrb	r7, [r4, #623]	@ zero_extendqisi2
2554:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5768              		.loc 1 2554 0
 5769 3310 7362D4E5 		ldrb	r6, [r4, #627]	@ zero_extendqisi2
 5770              	.LVL650:
2556:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5771              		.loc 1 2556 0
 5772 3314 80C047E2 		sub	ip, r7, #128
 5773 3318 FF300CE2 		and	r3, ip, #255
2557:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5774              		.loc 1 2557 0
 5775 331c 76E047E2 		sub	lr, r7, #118
2556:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5776              		.loc 1 2556 0
 5777 3320 18308DE5 		str	r3, [sp, #24]
 5778 3324 08018DE8 		stmia	sp, {r3, r8}
 5779 3328 B8019FE5 		ldr	r0, .L496+4
 5780 332c 0630A0E1 		mov	r3, r6
 5781 3330 0510A0E3 		mov	r1, #5
 5782 3334 DF20A0E3 		mov	r2, #223
 5783 3338 14C08DE5 		str	ip, [sp, #20]
2557:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5784              		.loc 1 2557 0
 5785 333c 1CE08DE5 		str	lr, [sp, #28]
2556:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5786              		.loc 1 2556 0
 5787 3340 FEFFFFEB 		bl	cmdSet
 5788              	.LVL651:
2557:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5789              		.loc 1 2557 0
 5790 3344 1C209DE5 		ldr	r2, [sp, #28]
2558:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5791              		.loc 1 2558 0
 5792 3348 7EE087E2 		add	lr, r7, #126
2557:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5793              		.loc 1 2557 0
 5794 334c FF3002E2 		and	r3, r2, #255
 5795 3350 08048DE8 		stmia	sp, {r3, r10}
 5796 3354 8C019FE5 		ldr	r0, .L496+4
 5797 3358 0630A0E1 		mov	r3, r6
 5798 335c 0510A0E3 		mov	r1, #5
 5799 3360 DC20A0E3 		mov	r2, #220
2558:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5800              		.loc 1 2558 0
 5801 3364 20E08DE5 		str	lr, [sp, #32]
2557:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5802              		.loc 1 2557 0
 5803 3368 FEFFFFEB 		bl	cmdSet
 5804              	.LVL652:
2558:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5805              		.loc 1 2558 0
 5806 336c 20209DE5 		ldr	r2, [sp, #32]
2559:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5807              		.loc 1 2559 0
 5808 3370 72E087E2 		add	lr, r7, #114
2558:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5809              		.loc 1 2558 0
 5810 3374 FF3002E2 		and	r3, r2, #255
 5811 3378 0220A0E3 		mov	r2, #2
 5812 337c 00308DE5 		str	r3, [sp]
 5813 3380 04208DE5 		str	r2, [sp, #4]
 5814 3384 0630A0E1 		mov	r3, r6
 5815 3388 0510A0E3 		mov	r1, #5
 5816 338c DE20A0E3 		mov	r2, #222
 5817 3390 50019FE5 		ldr	r0, .L496+4
2559:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5818              		.loc 1 2559 0
 5819 3394 24E08DE5 		str	lr, [sp, #36]
2558:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5820              		.loc 1 2558 0
 5821 3398 FEFFFFEB 		bl	cmdSet
 5822              	.LVL653:
2559:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5823              		.loc 1 2559 0
 5824 339c 24209DE5 		ldr	r2, [sp, #36]
2560:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5825              		.loc 1 2560 0
 5826 33a0 6FB047E2 		sub	fp, r7, #111
2559:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5827              		.loc 1 2559 0
 5828 33a4 FF3002E2 		and	r3, r2, #255
 5829 33a8 0320A0E3 		mov	r2, #3
 5830 33ac 00308DE5 		str	r3, [sp]
 5831 33b0 04208DE5 		str	r2, [sp, #4]
 5832 33b4 0630A0E1 		mov	r3, r6
 5833 33b8 0510A0E3 		mov	r1, #5
 5834 33bc E020A0E3 		mov	r2, #224
 5835 33c0 20019FE5 		ldr	r0, .L496+4
 5836 33c4 FEFFFFEB 		bl	cmdSet
 5837              	.LVL654:
2560:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5838              		.loc 1 2560 0
 5839 33c8 0490A0E3 		mov	r9, #4
 5840 33cc FF300BE2 		and	r3, fp, #255
2561:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5841              		.loc 1 2561 0
 5842 33d0 7F7087E2 		add	r7, r7, #127
 5843              	.LVL655:
2560:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5844              		.loc 1 2560 0
 5845 33d4 00308DE5 		str	r3, [sp]
 5846 33d8 04908DE5 		str	r9, [sp, #4]
 5847 33dc 0630A0E1 		mov	r3, r6
 5848 33e0 0510A0E3 		mov	r1, #5
 5849 33e4 DD20A0E3 		mov	r2, #221
 5850 33e8 F8009FE5 		ldr	r0, .L496+4
 5851 33ec FEFFFFEB 		bl	cmdSet
 5852              	.LVL656:
2561:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5853              		.loc 1 2561 0
 5854 33f0 FF2007E2 		and	r2, r7, #255
 5855 33f4 0510A0E3 		mov	r1, #5
 5856 33f8 0630A0E1 		mov	r3, r6
 5857 33fc 00208DE5 		str	r2, [sp]
 5858 3400 04108DE5 		str	r1, [sp, #4]
 5859 3404 E120A0E3 		mov	r2, #225
 5860 3408 D8009FE5 		ldr	r0, .L496+4
 5861 340c FEFFFFEB 		bl	cmdSet
 5862              	.LVL657:
2563:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 5863              		.loc 1 2563 0
 5864 3410 14C09DE5 		ldr	ip, [sp, #20]
 5865 3414 24E09DE5 		ldr	lr, [sp, #36]
 5866 3418 20309DE5 		ldr	r3, [sp, #32]
 5867 341c 0C20A0E1 		mov	r2, ip
2562:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5868              		.loc 1 2562 0
 5869 3420 18C09DE5 		ldr	ip, [sp, #24]
2563:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 5870              		.loc 1 2563 0
 5871 3424 04E08DE5 		str	lr, [sp, #4]
 5872 3428 00308DE5 		str	r3, [sp]
 5873 342c 0C708DE5 		str	r7, [sp, #12]
 5874 3430 1C309DE5 		ldr	r3, [sp, #28]
 5875 3434 08B08DE5 		str	fp, [sp, #8]
 5876 3438 0900A0E1 		mov	r0, r9
 5877 343c AC109FE5 		ldr	r1, .L496+12
2562:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5878              		.loc 1 2562 0
 5879 3440 71C2C4E5 		strb	ip, [r4, #625]
2563:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 5880              		.loc 1 2563 0
 5881 3444 FEFFFFEB 		bl	CyU3PDebugPrint
 5882              	.LVL658:
2568:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5883              		.loc 1 2568 0
 5884 3448 8762D4E5 		ldrb	r6, [r4, #647]	@ zero_extendqisi2
 5885              	.LVL659:
2567:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5886              		.loc 1 2567 0
 5887 344c 8B72D4E5 		ldrb	r7, [r4, #651]	@ zero_extendqisi2
 5888              	.LVL660:
2569:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5889              		.loc 1 2569 0
 5890 3450 00608DE5 		str	r6, [sp]
 5891 3454 0730A0E1 		mov	r3, r7
 5892 3458 04808DE5 		str	r8, [sp, #4]
 5893 345c 0610A0E3 		mov	r1, #6
 5894 3460 8520A0E3 		mov	r2, #133
 5895 3464 7C009FE5 		ldr	r0, .L496+4
 5896 3468 FEFFFFEB 		bl	cmdSet
 5897              	.LVL661:
2570:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5898              		.loc 1 2570 0
 5899 346c 40048DE8 		stmia	sp, {r6, r10}
 5900 3470 70009FE5 		ldr	r0, .L496+4
 5901 3474 0730A0E1 		mov	r3, r7
 5902 3478 0610A0E3 		mov	r1, #6
 5903 347c 8620A0E3 		mov	r2, #134
 5904 3480 FEFFFFEB 		bl	cmdSet
 5905              	.LVL662:
2572:../uvc.c      **** 
 5906              		.loc 1 2572 0
 5907 3484 0620A0E1 		mov	r2, r6
 5908 3488 0530A0E1 		mov	r3, r5
 5909 348c 0900A0E1 		mov	r0, r9
 5910 3490 54109FE5 		ldr	r1, .L496+8
2571:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5911              		.loc 1 2571 0
 5912 3494 8962C4E5 		strb	r6, [r4, #649]
2572:../uvc.c      **** 
 5913              		.loc 1 2572 0
 5914 3498 FEFFFFEB 		bl	CyU3PDebugPrint
 5915              	.LVL663:
2577:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5916              		.loc 1 2577 0
 5917 349c 9F62D4E5 		ldrb	r6, [r4, #671]	@ zero_extendqisi2
 5918              	.LVL664:
2578:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5919              		.loc 1 2578 0
 5920 34a0 9422D4E5 		ldrb	r2, [r4, #660]	@ zero_extendqisi2
 5921 34a4 A332D4E5 		ldrb	r3, [r4, #675]	@ zero_extendqisi2
 5922 34a8 40018DE8 		stmia	sp, {r6, r8}
 5923 34ac 34009FE5 		ldr	r0, .L496+4
 5924 34b0 0710A0E3 		mov	r1, #7
 5925 34b4 FEFFFFEB 		bl	cmdSet
 5926              	.LVL665:
2580:../uvc.c      **** 
 5927              		.loc 1 2580 0
 5928 34b8 0620A0E1 		mov	r2, r6
 5929 34bc 0530A0E1 		mov	r3, r5
 5930 34c0 0900A0E1 		mov	r0, r9
 5931 34c4 20109FE5 		ldr	r1, .L496+8
2579:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5932              		.loc 1 2579 0
 5933 34c8 A152C4E5 		strb	r5, [r4, #673]
2580:../uvc.c      **** 
 5934              		.loc 1 2580 0
 5935 34cc FEFFFFEB 		bl	CyU3PDebugPrint
 5936              	.LVL666:
2582:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 5937              		.loc 1 2582 0
 5938 34d0 10209FE5 		ldr	r2, .L496+4
 5939 34d4 1C0092E5 		ldr	r0, [r2, #28]
2585:../uvc.c      **** 
 5940              		.loc 1 2585 0
 5941 34d8 2CD08DE2 		add	sp, sp, #44
 5942              		@ sp needed
 5943 34dc F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5944              	.LVL667:
2582:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 5945              		.loc 1 2582 0
 5946 34e0 FEFFFFEA 		b	_txe_mutex_put
 5947              	.LVL668:
 5948              	.L497:
 5949              		.align	2
 5950              	.L496:
 5951 34e4 00000000 		.word	.LANCHOR1
 5952 34e8 00000000 		.word	statQu
 5953 34ec 50070000 		.word	.LC40
 5954 34f0 70070000 		.word	.LC41
 5955              		.cfi_endproc
 5956              	.LFE5:
 5958              		.align	2
 5959              		.global	CyFxUVCAddHeader
 5961              	CyFxUVCAddHeader:
 5962              	.LFB6:
2593:../uvc.c      ****     /* Copy header to buffer */
 5963              		.loc 1 2593 0
 5964              		.cfi_startproc
 5965              		@ args = 0, pretend = 0, frame = 0
 5966              		@ frame_needed = 0, uses_anonymous_args = 0
 5967              	.LVL669:
 5968 34f4 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5969              	.LCFI23:
 5970              		.cfi_def_cfa_offset 16
 5971              		.cfi_offset 3, -16
 5972              		.cfi_offset 4, -12
 5973              		.cfi_offset 5, -8
 5974              		.cfi_offset 14, -4
2593:../uvc.c      ****     /* Copy header to buffer */
 5975              		.loc 1 2593 0
 5976 34f8 0040A0E1 		mov	r4, r0
 5977 34fc 0150A0E1 		mov	r5, r1
2595:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5978              		.loc 1 2595 0
 5979 3500 30009FE5 		ldr	r0, .L503
 5980              	.LVL670:
 5981 3504 0010E0E3 		mvn	r1, #0
 5982              	.LVL671:
 5983 3508 FEFFFFEB 		bl	_txe_mutex_get
 5984              	.LVL672:
2596:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 5985              		.loc 1 2596 0
 5986 350c 0400A0E1 		mov	r0, r4
 5987 3510 24109FE5 		ldr	r1, .L503+4
 5988 3514 0C20A0E3 		mov	r2, #12
 5989 3518 FEFFFFEB 		bl	CyU3PMemCopy
 5990              	.LVL673:
2597:../uvc.c      **** 
 5991              		.loc 1 2597 0
 5992 351c 14009FE5 		ldr	r0, .L503
 5993 3520 FEFFFFEB 		bl	_txe_mutex_put
 5994              	.LVL674:
2600:../uvc.c      ****     {
 5995              		.loc 1 2600 0
 5996 3524 020015E3 		tst	r5, #2
2602:../uvc.c      ****     }
 5997              		.loc 1 2602 0
 5998 3528 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5999 352c 02308313 		orrne	r3, r3, #2
 6000 3530 0130C415 		strneb	r3, [r4, #1]
 6001 3534 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 6002              	.L504:
 6003              		.align	2
 6004              	.L503:
 6005 3538 00000000 		.word	imgHdMux
 6006 353c EC040000 		.word	.LANCHOR1+1260
 6007              		.cfi_endproc
 6008              	.LFE6:
 6010              		.align	2
 6011              		.global	CyFxAppErrorHandler
 6013              	CyFxAppErrorHandler:
 6014              	.LFB7:
2612:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
 6015              		.loc 1 2612 0
 6016              		.cfi_startproc
 6017              		@ Volatile: function does not return.
 6018              		@ args = 0, pretend = 0, frame = 0
 6019              		@ frame_needed = 0, uses_anonymous_args = 0
 6020              	.LVL675:
 6021 3540 08402DE9 		stmfd	sp!, {r3, lr}
 6022              	.LCFI24:
 6023              		.cfi_def_cfa_offset 8
 6024              		.cfi_offset 3, -8
 6025              		.cfi_offset 14, -4
 6026              	.LVL676:
 6027              	.L506:
2622:../uvc.c      ****         CyU3PThreadSleep (1000);
 6028              		.loc 1 2622 0 discriminator 1
 6029 3544 10109FE5 		ldr	r1, .L507
 6030 3548 0400A0E3 		mov	r0, #4
 6031 354c FEFFFFEB 		bl	CyU3PDebugPrint
 6032              	.LVL677:
2623:../uvc.c      ****     }
 6033              		.loc 1 2623 0 discriminator 1
 6034 3550 FA0FA0E3 		mov	r0, #1000
 6035 3554 FEFFFFEB 		bl	_tx_thread_sleep
 6036              	.LVL678:
 6037 3558 F9FFFFEA 		b	.L506
 6038              	.L508:
 6039              		.align	2
 6040              	.L507:
 6041 355c A8070000 		.word	.LC42
 6042              		.cfi_endproc
 6043              	.LFE7:
 6045              		.align	2
 6046              		.global	UVCAppThread_Entry
 6048              	UVCAppThread_Entry:
 6049              	.LFB19:
3599:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
 6050              		.loc 1 3599 0
 6051              		.cfi_startproc
 6052              		@ args = 0, pretend = 0, frame = 128
 6053              		@ frame_needed = 0, uses_anonymous_args = 0
 6054              	.LVL679:
 6055 3560 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 6056              	.LCFI25:
 6057              		.cfi_def_cfa_offset 32
 6058              		.cfi_offset 4, -32
 6059              		.cfi_offset 5, -28
 6060              		.cfi_offset 6, -24
 6061              		.cfi_offset 7, -20
 6062              		.cfi_offset 8, -16
 6063              		.cfi_offset 9, -12
 6064              		.cfi_offset 10, -8
 6065              		.cfi_offset 14, -4
 6066 3564 88D04DE2 		sub	sp, sp, #136
 6067              	.LCFI26:
 6068              		.cfi_def_cfa_offset 168
 6069              	.LBB98:
 6070              	.LBB99:
3055:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6071              		.loc 1 3055 0
 6072 3568 FEFFFFEB 		bl	CyU3PUartInit
 6073              	.LVL680:
3056:../uvc.c      ****     {
 6074              		.loc 1 3056 0
 6075 356c 004050E2 		subs	r4, r0, #0
 6076 3570 2902001A 		bne	.L590
3063:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6077              		.loc 1 3063 0
 6078 3574 582A9FE5 		ldr	r2, .L621
3064:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6079              		.loc 1 3064 0
 6080 3578 0130A0E3 		mov	r3, #1
3072:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6081              		.loc 1 3072 0
 6082 357c 0410A0E1 		mov	r1, r4
 6083 3580 60008DE2 		add	r0, sp, #96
 6084              	.LVL681:
3065:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 6085              		.loc 1 3065 0
 6086 3584 7540CDE5 		strb	r4, [sp, #117]
3067:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 6087              		.loc 1 3067 0
 6088 3588 64408DE5 		str	r4, [sp, #100]
3068:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 6089              		.loc 1 3068 0
 6090 358c 68408DE5 		str	r4, [sp, #104]
3063:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6091              		.loc 1 3063 0
 6092 3590 70208DE5 		str	r2, [sp, #112]
3064:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6093              		.loc 1 3064 0
 6094 3594 7430CDE5 		strb	r3, [sp, #116]
3066:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 6095              		.loc 1 3066 0
 6096 3598 60308DE5 		str	r3, [sp, #96]
3069:../uvc.c      **** 
 6097              		.loc 1 3069 0
 6098 359c 6C308DE5 		str	r3, [sp, #108]
3072:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6099              		.loc 1 3072 0
 6100 35a0 FEFFFFEB 		bl	CyU3PUartSetConfig
 6101              	.LVL682:
3073:../uvc.c      ****     {
 6102              		.loc 1 3073 0
 6103 35a4 000050E3 		cmp	r0, #0
 6104 35a8 B201001A 		bne	.L589
3079:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6105              		.loc 1 3079 0
 6106 35ac 0000E0E3 		mvn	r0, #0
 6107              	.LVL683:
 6108 35b0 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 6109              	.LVL684:
3080:../uvc.c      ****     {
 6110              		.loc 1 3080 0
 6111 35b4 000050E3 		cmp	r0, #0
 6112 35b8 AE01001A 		bne	.L589
3086:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6113              		.loc 1 3086 0
 6114 35bc 0300A0E3 		mov	r0, #3
 6115              	.LVL685:
 6116 35c0 0410A0E3 		mov	r1, #4
 6117 35c4 FEFFFFEB 		bl	CyU3PDebugInit
 6118              	.LVL686:
3087:../uvc.c      ****     {
 6119              		.loc 1 3087 0
 6120 35c8 000050E3 		cmp	r0, #0
 6121 35cc A901001A 		bne	.L589
3093:../uvc.c      **** }
 6122              		.loc 1 3093 0
 6123 35d0 FEFFFFEB 		bl	CyU3PDebugPreamble
 6124              	.LVL687:
 6125 35d4 0640A0E3 		mov	r4, #6
 6126              	.LVL688:
 6127              	.L515:
 6128              	.LBE99:
 6129              	.LBE98:
3615:../uvc.c      **** 	}
 6130              		.loc 1 3615 0
 6131 35d8 7D0FA0E3 		mov	r0, #500
 6132 35dc 014044E2 		sub	r4, r4, #1
 6133 35e0 FEFFFFEB 		bl	_tx_thread_sleep
 6134              	.LVL689:
3614:../uvc.c      **** 		CyU3PThreadSleep(500);
 6135              		.loc 1 3614 0
 6136 35e4 FF4014E2 		ands	r4, r4, #255
 6137 35e8 FAFFFF1A 		bne	.L515
 6138              	.LBB101:
 6139              	.LBB102:
3103:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 6140              		.loc 1 3103 0
 6141 35ec FEFFFFEB 		bl	CyU3PI2cInit
 6142              	.LVL690:
3104:../uvc.c      ****     {
 6143              		.loc 1 3104 0
 6144 35f0 005050E2 		subs	r5, r0, #0
 6145 35f4 3002001A 		bne	.L591
3111:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6146              		.loc 1 3111 0
 6147 35f8 D8299FE5 		ldr	r2, .L621+4
3113:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6148              		.loc 1 3113 0
 6149 35fc 0030E0E3 		mvn	r3, #0
3116:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6150              		.loc 1 3116 0
 6151 3600 60008DE2 		add	r0, sp, #96
 6152              	.LVL691:
 6153 3604 0410A0E1 		mov	r1, r4
3112:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6154              		.loc 1 3112 0
 6155 3608 64408DE5 		str	r4, [sp, #100]
3111:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6156              		.loc 1 3111 0
 6157 360c 60208DE5 		str	r2, [sp, #96]
3113:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6158              		.loc 1 3113 0
 6159 3610 68308DE5 		str	r3, [sp, #104]
3114:../uvc.c      **** 
 6160              		.loc 1 3114 0
 6161 3614 BC36CDE1 		strh	r3, [sp, #108]	@ movhi
3116:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6162              		.loc 1 3116 0
 6163 3618 FEFFFFEB 		bl	CyU3PI2cSetConfig
 6164              	.LVL692:
3117:../uvc.c      ****     {
 6165              		.loc 1 3117 0
 6166 361c 005050E2 		subs	r5, r0, #0
 6167 3620 2002001A 		bne	.L592
 6168              	.LBE102:
 6169              	.LBE101:
 6170              	.LBB104:
 6171              	.LBB105:
3190:../uvc.c      ****     if (apiRetStatus != 0)
 6172              		.loc 1 3190 0
 6173 3624 B0799FE5 		ldr	r7, .L621+8
 6174 3628 0410A0E1 		mov	r1, r4
 6175 362c 0700A0E1 		mov	r0, r7
 6176              	.LVL693:
 6177 3630 2820A0E3 		mov	r2, #40
 6178 3634 FEFFFFEB 		bl	_txe_event_flags_create
 6179              	.LVL694:
3191:../uvc.c      ****     {
 6180              		.loc 1 3191 0
 6181 3638 005050E2 		subs	r5, r0, #0
 6182              	.LVL695:
 6183 363c 1302001A 		bne	.L593
3205:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6184              		.loc 1 3205 0
 6185 3640 0230A0E3 		mov	r3, #2
3208:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6186              		.loc 1 3208 0
 6187 3644 0320A0E3 		mov	r2, #3
3212:../uvc.c      ****     if (apiRetStatus != 0)
 6188              		.loc 1 3212 0
 6189 3648 14008DE2 		add	r0, sp, #20
 6190              	.LVL696:
 6191 364c 0410A0E1 		mov	r1, r4
3201:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 6192              		.loc 1 3201 0
 6193 3650 8C4087E5 		str	r4, [r7, #140]
3202:../uvc.c      **** 
 6194              		.loc 1 3202 0
 6195 3654 904087E5 		str	r4, [r7, #144]
3207:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6196              		.loc 1 3207 0
 6197 3658 1C40CDE5 		strb	r4, [sp, #28]
3209:../uvc.c      **** 
 6198              		.loc 1 3209 0
 6199 365c 18408DE5 		str	r4, [sp, #24]
3205:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6200              		.loc 1 3205 0
 6201 3660 1430CDE5 		strb	r3, [sp, #20]
3206:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 6202              		.loc 1 3206 0
 6203 3664 1530CDE5 		strb	r3, [sp, #21]
3208:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6204              		.loc 1 3208 0
 6205 3668 1D20CDE5 		strb	r2, [sp, #29]
3212:../uvc.c      ****     if (apiRetStatus != 0)
 6206              		.loc 1 3212 0
 6207 366c FEFFFFEB 		bl	CyU3PGpioInit
 6208              	.LVL697:
3213:../uvc.c      ****     {
 6209              		.loc 1 3213 0
 6210 3670 005050E2 		subs	r5, r0, #0
 6211 3674 FF01001A 		bne	.L594
3221:../uvc.c      ****     if (apiRetStatus != 0)
 6212              		.loc 1 3221 0
 6213 3678 1600A0E3 		mov	r0, #22
 6214              	.LVL698:
 6215 367c 0110A0E3 		mov	r1, #1
 6216 3680 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6217              	.LVL699:
3222:../uvc.c      ****     {
 6218              		.loc 1 3222 0
 6219 3684 005050E2 		subs	r5, r0, #0
 6220 3688 3A02001A 		bne	.L595
3227:../uvc.c      ****     if (apiRetStatus != 0)
 6221              		.loc 1 3227 0
 6222 368c 1400A0E3 		mov	r0, #20
 6223              	.LVL700:
 6224 3690 0110A0E3 		mov	r1, #1
 6225 3694 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6226              	.LVL701:
3228:../uvc.c      ****     {
 6227              		.loc 1 3228 0
 6228 3698 005050E2 		subs	r5, r0, #0
 6229 369c 2F02001A 		bne	.L596
3233:../uvc.c      ****     if (apiRetStatus != 0)
 6230              		.loc 1 3233 0
 6231 36a0 1800A0E3 		mov	r0, #24
 6232              	.LVL702:
 6233 36a4 0110A0E3 		mov	r1, #1
 6234 36a8 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6235              	.LVL703:
3234:../uvc.c      ****     {
 6236              		.loc 1 3234 0
 6237 36ac 005050E2 		subs	r5, r0, #0
 6238 36b0 2402001A 		bne	.L597
3241:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6239              		.loc 1 3241 0
 6240 36b4 0150A0E3 		mov	r5, #1
3246:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6241              		.loc 1 3246 0
 6242 36b8 30108DE2 		add	r1, sp, #48
 6243 36bc 1600A0E3 		mov	r0, #22
 6244              	.LVL704:
3244:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6245              		.loc 1 3244 0
 6246 36c0 3C408DE5 		str	r4, [sp, #60]
3245:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6247              		.loc 1 3245 0
 6248 36c4 4040CDE5 		strb	r4, [sp, #64]
3241:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6249              		.loc 1 3241 0
 6250 36c8 30508DE5 		str	r5, [sp, #48]
3242:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6251              		.loc 1 3242 0
 6252 36cc 34508DE5 		str	r5, [sp, #52]
3243:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6253              		.loc 1 3243 0
 6254 36d0 38508DE5 		str	r5, [sp, #56]
3246:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6255              		.loc 1 3246 0
 6256 36d4 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6257              	.LVL705:
3247:../uvc.c      ****     {
 6258              		.loc 1 3247 0
 6259 36d8 006050E2 		subs	r6, r0, #0
 6260 36dc 1302001A 		bne	.L598
3260:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6261              		.loc 1 3260 0
 6262 36e0 1400A0E3 		mov	r0, #20
 6263              	.LVL706:
 6264 36e4 30108DE2 		add	r1, sp, #48
3258:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6265              		.loc 1 3258 0
 6266 36e8 3C408DE5 		str	r4, [sp, #60]
3259:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6267              		.loc 1 3259 0
 6268 36ec 4040CDE5 		strb	r4, [sp, #64]
3255:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6269              		.loc 1 3255 0
 6270 36f0 30508DE5 		str	r5, [sp, #48]
3256:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6271              		.loc 1 3256 0
 6272 36f4 34508DE5 		str	r5, [sp, #52]
3257:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6273              		.loc 1 3257 0
 6274 36f8 38508DE5 		str	r5, [sp, #56]
3260:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6275              		.loc 1 3260 0
 6276 36fc FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6277              	.LVL707:
3261:../uvc.c      ****     {
 6278              		.loc 1 3261 0
 6279 3700 004050E2 		subs	r4, r0, #0
 6280 3704 0302001A 		bne	.L599
3269:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6281              		.loc 1 3269 0
 6282 3708 0030A0E3 		mov	r3, #0
3274:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6283              		.loc 1 3274 0
 6284 370c 30108DE2 		add	r1, sp, #48
3272:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6285              		.loc 1 3272 0
 6286 3710 0150A0E3 		mov	r5, #1
3274:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6287              		.loc 1 3274 0
 6288 3714 1800A0E3 		mov	r0, #24
 6289              	.LVL708:
3269:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6290              		.loc 1 3269 0
 6291 3718 30308DE5 		str	r3, [sp, #48]
3270:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 6292              		.loc 1 3270 0
 6293 371c 34308DE5 		str	r3, [sp, #52]
3271:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 6294              		.loc 1 3271 0
 6295 3720 38308DE5 		str	r3, [sp, #56]
3273:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6296              		.loc 1 3273 0
 6297 3724 4030CDE5 		strb	r3, [sp, #64]
3272:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6298              		.loc 1 3272 0
 6299 3728 3C508DE5 		str	r5, [sp, #60]
3274:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6300              		.loc 1 3274 0
 6301 372c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6302              	.LVL709:
3275:../uvc.c      ****     {
 6303              		.loc 1 3275 0
 6304 3730 004050E2 		subs	r4, r0, #0
 6305 3734 F101001A 		bne	.L600
3282:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6306              		.loc 1 3282 0
 6307 3738 0260A0E3 		mov	r6, #2
3283:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6308              		.loc 1 3283 0
 6309 373c 0380A0E3 		mov	r8, #3
3287:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6310              		.loc 1 3287 0
 6311 3740 0500A0E1 		mov	r0, r5
 6312              	.LVL710:
 6313 3744 20108DE2 		add	r1, sp, #32
3284:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 6314              		.loc 1 3284 0
 6315 3748 28408DE5 		str	r4, [sp, #40]
3285:../uvc.c      **** 
 6316              		.loc 1 3285 0
 6317 374c 24408DE5 		str	r4, [sp, #36]
3282:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6318              		.loc 1 3282 0
 6319 3750 B062CDE1 		strh	r6, [sp, #32]	@ movhi
3283:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6320              		.loc 1 3283 0
 6321 3754 2C80CDE5 		strb	r8, [sp, #44]
3287:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6322              		.loc 1 3287 0
 6323 3758 FEFFFFEB 		bl	CyU3PPibInit
 6324              	.LVL711:
3288:../uvc.c      ****     {
 6325              		.loc 1 3288 0
 6326 375c 004050E2 		subs	r4, r0, #0
 6327 3760 E001001A 		bne	.L601
3295:../uvc.c      **** 
 6328              		.loc 1 3295 0
 6329 3764 74089FE5 		ldr	r0, .L621+12
 6330              	.LVL712:
 6331 3768 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 6332              	.LVL713:
3303:../uvc.c      ****     CyU3PThreadSleep(5000);
 6333              		.loc 1 3303 0
 6334 376c FEFFFFEB 		bl	SensorReset
 6335              	.LVL714:
3304:../uvc.c      ****     //SensorInit ();
 6336              		.loc 1 3304 0
 6337 3770 6C089FE5 		ldr	r0, .L621+16
 6338 3774 FEFFFFEB 		bl	_tx_thread_sleep
 6339              	.LVL715:
3308:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6340              		.loc 1 3308 0
 6341 3778 FEFFFFEB 		bl	CyU3PUsbStart
 6342              	.LVL716:
3309:../uvc.c      ****     {
 6343              		.loc 1 3309 0
 6344 377c 004050E2 		subs	r4, r0, #0
 6345 3780 D201001A 		bne	.L602
3315:../uvc.c      **** 
 6346              		.loc 1 3315 0
 6347 3784 0410A0E1 		mov	r1, r4
 6348 3788 58089FE5 		ldr	r0, .L621+20
 6349              	.LVL717:
 6350 378c FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 6351              	.LVL718:
3318:../uvc.c      **** 
 6352              		.loc 1 3318 0
 6353 3790 54089FE5 		ldr	r0, .L621+24
 6354 3794 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
 6355              	.LVL719:
3324:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 6356              		.loc 1 3324 0
 6357 3798 0410A0E1 		mov	r1, r4
 6358 379c 4C289FE5 		ldr	r2, .L621+28
 6359 37a0 0500A0E1 		mov	r0, r5
 6360 37a4 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6361              	.LVL720:
3325:../uvc.c      **** 
 6362              		.loc 1 3325 0
 6363 37a8 0410A0E1 		mov	r1, r4
 6364 37ac 0400A0E1 		mov	r0, r4
 6365 37b0 3C289FE5 		ldr	r2, .L621+32
 6366 37b4 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6367              	.LVL721:
3328:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 6368              		.loc 1 3328 0
 6369 37b8 0410A0E1 		mov	r1, r4
 6370 37bc 34289FE5 		ldr	r2, .L621+36
 6371 37c0 0600A0E1 		mov	r0, r6
 6372 37c4 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6373              	.LVL722:
3329:../uvc.c      **** 
 6374              		.loc 1 3329 0
 6375 37c8 0410A0E1 		mov	r1, r4
 6376 37cc 28289FE5 		ldr	r2, .L621+40
 6377 37d0 0700A0E3 		mov	r0, #7
 6378 37d4 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6379              	.LVL723:
3332:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 6380              		.loc 1 3332 0
 6381 37d8 0410A0E1 		mov	r1, r4
 6382 37dc 1C289FE5 		ldr	r2, .L621+44
 6383 37e0 0400A0E3 		mov	r0, #4
 6384 37e4 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6385              	.LVL724:
3333:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 6386              		.loc 1 3333 0
 6387 37e8 0410A0E1 		mov	r1, r4
 6388 37ec 10289FE5 		ldr	r2, .L621+48
 6389 37f0 0800A0E1 		mov	r0, r8
 6390 37f4 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6391              	.LVL725:
3334:../uvc.c      **** 
 6392              		.loc 1 3334 0
 6393 37f8 0410A0E1 		mov	r1, r4
 6394 37fc 04289FE5 		ldr	r2, .L621+52
 6395 3800 0600A0E3 		mov	r0, #6
 6396 3804 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6397              	.LVL726:
3337:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 6398              		.loc 1 3337 0
 6399 3808 0410A0E1 		mov	r1, r4
 6400 380c F8279FE5 		ldr	r2, .L621+56
 6401 3810 0500A0E3 		mov	r0, #5
 6402 3814 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6403              	.LVL727:
3338:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 6404              		.loc 1 3338 0
 6405 3818 0510A0E1 		mov	r1, r5
 6406 381c EC279FE5 		ldr	r2, .L621+60
 6407 3820 0500A0E3 		mov	r0, #5
 6408 3824 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6409              	.LVL728:
3339:../uvc.c      **** 
 6410              		.loc 1 3339 0
 6411 3828 0610A0E1 		mov	r1, r6
 6412 382c E0279FE5 		ldr	r2, .L621+64
 6413 3830 0500A0E3 		mov	r0, #5
 6414 3834 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6415              	.LVL729:
3348:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6416              		.loc 1 3348 0
 6417 3838 4030A0E3 		mov	r3, #64
3352:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6418              		.loc 1 3352 0
 6419 383c 08108DE2 		add	r1, sp, #8
 6420 3840 8200A0E3 		mov	r0, #130
3349:../uvc.c      ****     endPointConfig.streams  = 0;
 6421              		.loc 1 3349 0
 6422 3844 1340CDE5 		strb	r4, [sp, #19]
3350:../uvc.c      ****     endPointConfig.burstLen = 1;
 6423              		.loc 1 3350 0
 6424 3848 BE40CDE1 		strh	r4, [sp, #14]	@ movhi
3346:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6425              		.loc 1 3346 0
 6426 384c 08508DE5 		str	r5, [sp, #8]
3347:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6427              		.loc 1 3347 0
 6428 3850 0C80CDE5 		strb	r8, [sp, #12]
3351:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6429              		.loc 1 3351 0
 6430 3854 1250CDE5 		strb	r5, [sp, #18]
3348:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6431              		.loc 1 3348 0
 6432 3858 B031CDE1 		strh	r3, [sp, #16]	@ movhi
3352:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6433              		.loc 1 3352 0
 6434 385c FEFFFFEB 		bl	CyU3PSetEpConfig
 6435              	.LVL730:
3353:../uvc.c      ****     {
 6436              		.loc 1 3353 0
 6437 3860 004050E2 		subs	r4, r0, #0
3356:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6438              		.loc 1 3356 0
 6439 3864 0400A013 		movne	r0, #4
 6440              	.LVL731:
3353:../uvc.c      ****     {
 6441              		.loc 1 3353 0
 6442 3868 7101001A 		bne	.L587
3361:../uvc.c      ****     dmaInterConfig.count          = 1;
 6443              		.loc 1 3361 0
 6444 386c A4C79FE5 		ldr	ip, .L621+68
 6445 3870 413BA0E3 		mov	r3, #66560
3370:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6446              		.loc 1 3370 0
 6447 3874 1080A0E3 		mov	r8, #16
3372:../uvc.c      ****             &dmaInterConfig);
 6448              		.loc 1 3372 0
 6449 3878 9C079FE5 		ldr	r0, .L621+72
 6450 387c 0410A0E3 		mov	r1, #4
 6451 3880 44208DE2 		add	r2, sp, #68
3361:../uvc.c      ****     dmaInterConfig.count          = 1;
 6452              		.loc 1 3361 0
 6453 3884 4C408DE5 		str	r4, [sp, #76]
 6454 3888 50408DE5 		str	r4, [sp, #80]
3369:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6455              		.loc 1 3369 0
 6456 388c 5440CDE5 		strb	r4, [sp, #84]
3371:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6457              		.loc 1 3371 0
 6458 3890 5C408DE5 		str	r4, [sp, #92]
3361:../uvc.c      ****     dmaInterConfig.count          = 1;
 6459              		.loc 1 3361 0
 6460 3894 48C08DE5 		str	ip, [sp, #72]
 6461 3898 44308DE5 		str	r3, [sp, #68]
3370:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6462              		.loc 1 3370 0
 6463 389c 58808DE5 		str	r8, [sp, #88]
3372:../uvc.c      ****             &dmaInterConfig);
 6464              		.loc 1 3372 0
 6465 38a0 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6466              	.LVL732:
3374:../uvc.c      ****     {
 6467              		.loc 1 3374 0
 6468 38a4 004050E2 		subs	r4, r0, #0
 6469 38a8 BE01001A 		bne	.L603
3381:../uvc.c      ****     if (glInterStaBuffer == 0)
 6470              		.loc 1 3381 0
 6471 38ac 010BA0E3 		mov	r0, #1024
 6472              	.LVL733:
 6473 38b0 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6474              	.LVL734:
 6475 38b4 64379FE5 		ldr	r3, .L621+76
3382:../uvc.c      ****     {
 6476              		.loc 1 3382 0
 6477 38b8 000050E3 		cmp	r0, #0
3381:../uvc.c      ****     if (glInterStaBuffer == 0)
 6478              		.loc 1 3381 0
 6479 38bc 000083E5 		str	r0, [r3]
3382:../uvc.c      ****     {
 6480              		.loc 1 3382 0
 6481 38c0 BE01000A 		beq	.L604
3389:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6482              		.loc 1 3389 0
 6483 38c4 0410A0E1 		mov	r1, r4
 6484 38c8 0420A0E1 		mov	r2, r4
 6485 38cc 3830A0E3 		mov	r3, #56
 6486 38d0 4C079FE5 		ldr	r0, .L621+80
 6487 38d4 FEFFFFEB 		bl	_txe_mutex_create
 6488              	.LVL735:
3394:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6489              		.loc 1 3394 0
 6490 38d8 48179FE5 		ldr	r1, .L621+84
3395:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6491              		.loc 1 3395 0
 6492 38dc 48279FE5 		ldr	r2, .L621+88
3402:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6493              		.loc 1 3402 0
 6494 38e0 48A79FE5 		ldr	r10, .L621+92
3391:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6495              		.loc 1 3391 0
 6496 38e4 0480A0E3 		mov	r8, #4
3393:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6497              		.loc 1 3393 0
 6498 38e8 01ECA0E3 		mov	lr, #256
3397:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6499              		.loc 1 3397 0
 6500 38ec 0CC0A0E3 		mov	ip, #12
3401:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6501              		.loc 1 3401 0
 6502 38f0 1830A0E3 		mov	r3, #24
3394:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6503              		.loc 1 3394 0
 6504 38f4 B816CDE1 		strh	r1, [sp, #104]	@ movhi
3395:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6505              		.loc 1 3395 0
 6506 38f8 BE26CDE1 		strh	r2, [sp, #110]	@ movhi
3390:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6507              		.loc 1 3390 0
 6508 38fc 0199A0E3 		mov	r9, #16384
3403:../uvc.c      ****             &dmaMultiConfig);
 6509              		.loc 1 3403 0
 6510 3900 2C079FE5 		ldr	r0, .L621+96
 6511 3904 0710A0E3 		mov	r1, #7
 6512 3908 60208DE2 		add	r2, sp, #96
3396:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6513              		.loc 1 3396 0
 6514 390c B647CDE1 		strh	r4, [sp, #118]	@ movhi
3399:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6515              		.loc 1 3399 0
 6516 3910 BC47CDE1 		strh	r4, [sp, #124]	@ movhi
3400:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6517              		.loc 1 3400 0
 6518 3914 7E40CDE5 		strb	r4, [sp, #126]
3392:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6519              		.loc 1 3392 0
 6520 3918 B466CDE1 		strh	r6, [sp, #100]	@ movhi
3402:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6521              		.loc 1 3402 0
 6522 391c 84A08DE5 		str	r10, [sp, #132]
3390:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6523              		.loc 1 3390 0
 6524 3920 B096CDE1 		strh	r9, [sp, #96]	@ movhi
3391:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6525              		.loc 1 3391 0
 6526 3924 B286CDE1 		strh	r8, [sp, #98]	@ movhi
3398:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6527              		.loc 1 3398 0
 6528 3928 BA87CDE1 		strh	r8, [sp, #122]	@ movhi
3393:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6529              		.loc 1 3393 0
 6530 392c B6E6CDE1 		strh	lr, [sp, #102]	@ movhi
3397:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6531              		.loc 1 3397 0
 6532 3930 B8C7CDE1 		strh	ip, [sp, #120]	@ movhi
3401:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6533              		.loc 1 3401 0
 6534 3934 80308DE5 		str	r3, [sp, #128]
3403:../uvc.c      ****             &dmaMultiConfig);
 6535              		.loc 1 3403 0
 6536 3938 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6537              	.LVL736:
3405:../uvc.c      ****     {
 6538              		.loc 1 3405 0
 6539 393c 004050E2 		subs	r4, r0, #0
 6540 3940 9201001A 		bne	.L605
3496:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6541              		.loc 1 3496 0
 6542 3944 0500A0E1 		mov	r0, r5
 6543              	.LVL737:
 6544 3948 0510A0E1 		mov	r1, r5
 6545 394c FEFFFFEB 		bl	CyU3PConnectState
 6546              	.LVL738:
3497:../uvc.c      ****     {
 6547              		.loc 1 3497 0
 6548 3950 004050E2 		subs	r4, r0, #0
 6549 3954 3B01001A 		bne	.L606
3503:../uvc.c      **** 
 6550              		.loc 1 3503 0
 6551 3958 6400A0E3 		mov	r0, #100
 6552              	.LVL739:
 6553 395c FEFFFFEB 		bl	CyFx3BusyWait
 6554              	.LVL740:
3505:../uvc.c      **** 
 6555              		.loc 1 3505 0
 6556 3960 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 6557              	.LVL741:
3520:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6558              		.loc 1 3520 0
 6559 3964 08108DE2 		add	r1, sp, #8
3519:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6560              		.loc 1 3519 0
 6561 3968 BE40CDE1 		strh	r4, [sp, #14]	@ movhi
3507:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6562              		.loc 1 3507 0
 6563 396c 08508DE5 		str	r5, [sp, #8]
3508:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6564              		.loc 1 3508 0
 6565 3970 0C60CDE5 		strb	r6, [sp, #12]
3512:../uvc.c      ****     }
 6566              		.loc 1 3512 0
 6567 3974 030050E3 		cmp	r0, #3
3505:../uvc.c      **** 
 6568              		.loc 1 3505 0
 6569 3978 0030A0E1 		mov	r3, r0
3512:../uvc.c      ****     }
 6570              		.loc 1 3512 0
 6571 397c 01C0A013 		movne	ip, #1
 6572 3980 10C0A003 		moveq	ip, #16
 6573 3984 022CA013 		movne	r2, #512
 6574 3988 012BA003 		moveq	r2, #1024
3520:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6575              		.loc 1 3520 0
 6576 398c 8300A0E3 		mov	r0, #131
3505:../uvc.c      **** 
 6577              		.loc 1 3505 0
 6578 3990 4830C7E5 		strb	r3, [r7, #72]
 6579 3994 12C0CDE5 		strb	ip, [sp, #18]
 6580 3998 B021CDE1 		strh	r2, [sp, #16]	@ movhi
3520:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6581              		.loc 1 3520 0
 6582 399c FEFFFFEB 		bl	CyU3PSetEpConfig
 6583              	.LVL742:
3521:../uvc.c      ****     {
 6584              		.loc 1 3521 0
 6585 39a0 004050E2 		subs	r4, r0, #0
 6586              	.LBE105:
 6587              	.LBE104:
3644:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6588              		.loc 1 3644 0
 6589 39a4 30469F05 		ldreq	r4, .L621+8
 6590              	.LBB110:
 6591              	.LBB106:
3521:../uvc.c      ****     {
 6592              		.loc 1 3521 0
 6593 39a8 0C00000A 		beq	.L566
 6594 39ac 1F0100EA 		b	.L620
 6595              	.LVL743:
 6596              	.L609:
 6597              	.LBE106:
 6598              	.LBE110:
3690:../uvc.c      ****             {
 6599              		.loc 1 3690 0
 6600 39b0 7C3094E5 		ldr	r3, [r4, #124]
 6601 39b4 050053E1 		cmp	r3, r5
 6602 39b8 0300000A 		beq	.L536
3690:../uvc.c      ****             {
 6603              		.loc 1 3690 0 is_stmt 0 discriminator 1
 6604 39bc B028D4E1 		ldrh	r2, [r4, #128]
 6605 39c0 B238D4E1 		ldrh	r3, [r4, #130]
 6606 39c4 030052E1 		cmp	r2, r3
 6607 39c8 3B00000A 		beq	.L608
 6608              	.L536:
3894:../uvc.c      **** 
 6609              		.loc 1 3894 0 is_stmt 1
 6610 39cc 4010A0E3 		mov	r1, #64
 6611 39d0 0020A0E3 		mov	r2, #0
 6612 39d4 00069FE5 		ldr	r0, .L621+8
 6613 39d8 FEFFFFEB 		bl	_txe_event_flags_set
 6614              	.LVL744:
3897:../uvc.c      ****     }
 6615              		.loc 1 3897 0
 6616 39dc FEFFFFEB 		bl	_txe_thread_relinquish
 6617              	.LVL745:
 6618              	.L566:
3644:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6619              		.loc 1 3644 0
 6620 39e0 0050A0E3 		mov	r5, #0
 6621 39e4 00508DE5 		str	r5, [sp]
 6622 39e8 EC059FE5 		ldr	r0, .L621+8
 6623 39ec 0110A0E3 		mov	r1, #1
 6624 39f0 0220A0E3 		mov	r2, #2
 6625 39f4 60308DE2 		add	r3, sp, #96
 6626 39f8 FEFFFFEB 		bl	_txe_event_flags_get
 6627              	.LVL746:
 6628 39fc 006050E2 		subs	r6, r0, #0
 6629 3a00 EAFFFF0A 		beq	.L609
3801:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6630              		.loc 1 3801 0
 6631 3a04 00508DE5 		str	r5, [sp]
 6632 3a08 CC059FE5 		ldr	r0, .L621+8
 6633 3a0c 0210A0E3 		mov	r1, #2
 6634 3a10 0320A0E3 		mov	r2, #3
 6635 3a14 60308DE2 		add	r3, sp, #96
 6636 3a18 FEFFFFEB 		bl	_txe_event_flags_get
 6637              	.LVL747:
 6638 3a1c 000050E3 		cmp	r0, #0
 6639 3a20 0B00001A 		bne	.L558
3816:../uvc.c      ****                 {
 6640              		.loc 1 3816 0
 6641 3a24 903094E5 		ldr	r3, [r4, #144]
3804:../uvc.c      ****                 prodCount = 0;
 6642              		.loc 1 3804 0
 6643 3a28 7C0084E5 		str	r0, [r4, #124]
3816:../uvc.c      ****                 {
 6644              		.loc 1 3816 0
 6645 3a2c 000053E3 		cmp	r3, #0
3805:../uvc.c      ****                 consCount = 0;
 6646              		.loc 1 3805 0
 6647 3a30 B008C4E1 		strh	r0, [r4, #128]	@ movhi
3812:../uvc.c      ****                 pb=0;
 6648              		.loc 1 3812 0
 6649 3a34 B407C4E1 		strh	r0, [r4, #116]	@ movhi
3806:../uvc.c      ****                 if(0&&(prinflag == 0)){
 6650              		.loc 1 3806 0
 6651 3a38 B208C4E1 		strh	r0, [r4, #130]	@ movhi
3813:../uvc.c      ****                 pbc=0;
 6652              		.loc 1 3813 0
 6653 3a3c B607C4E1 		strh	r0, [r4, #118]	@ movhi
3814:../uvc.c      **** 
 6654              		.loc 1 3814 0
 6655 3a40 B807C4E1 		strh	r0, [r4, #120]	@ movhi
3816:../uvc.c      ****                 {
 6656              		.loc 1 3816 0
 6657 3a44 4600000A 		beq	.L610
 6658              	.L559:
3828:../uvc.c      ****             }
 6659              		.loc 1 3828 0
 6660 3a48 0030A0E3 		mov	r3, #0
 6661 3a4c 903087E5 		str	r3, [r7, #144]
 6662 3a50 DDFFFFEA 		b	.L536
 6663              	.L558:
3833:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
 6664              		.loc 1 3833 0
 6665 3a54 0030E0E3 		mvn	r3, #0
 6666 3a58 00308DE5 		str	r3, [sp]
 6667 3a5c 0110A0E3 		mov	r1, #1
 6668 3a60 0220A0E3 		mov	r2, #2
 6669 3a64 60308DE2 		add	r3, sp, #96
 6670 3a68 6C059FE5 		ldr	r0, .L621+8
 6671 3a6c FEFFFFEB 		bl	_txe_event_flags_get
 6672              	.LVL748:
3837:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6673              		.loc 1 3837 0
 6674 3a70 0510A0E1 		mov	r1, r5
 6675 3a74 0520A0E1 		mov	r2, r5
 6676 3a78 B4059FE5 		ldr	r0, .L621+96
 6677 3a7c FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6678              	.LVL749:
3838:../uvc.c      ****                 {
 6679              		.loc 1 3838 0
 6680 3a80 005050E2 		subs	r5, r0, #0
 6681 3a84 9D00001A 		bne	.L611
3846:../uvc.c      ****                 {
 6682              		.loc 1 3846 0
 6683 3a88 883094E5 		ldr	r3, [r4, #136]
 6684 3a8c 000053E3 		cmp	r3, #0
 6685 3a90 2B00001A 		bne	.L557
 6686              	.LVL750:
 6687              	.LBB111:
 6688              	.LBB112:
3549:../uvc.c      ****     {
 6689              		.loc 1 3549 0
 6690 3a94 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 6691 3a98 030053E3 		cmp	r3, #3
 6692 3a9c 5E00000A 		beq	.L612
3554:../uvc.c      ****     {
 6693              		.loc 1 3554 0
 6694 3aa0 020053E3 		cmp	r3, #2
 6695 3aa4 7400000A 		beq	.L613
 6696              	.LVL751:
 6697              	.L564:
 6698              	.LBE112:
 6699              	.LBE111:
3882:../uvc.c      ****                     CyU3PThreadSleep(200);
 6700              		.loc 1 3882 0
 6701 3aa8 0130A0E3 		mov	r3, #1
3883:../uvc.c      ****                     
 6702              		.loc 1 3883 0
 6703 3aac C800A0E3 		mov	r0, #200
3882:../uvc.c      ****                     CyU3PThreadSleep(200);
 6704              		.loc 1 3882 0
 6705 3ab0 883087E5 		str	r3, [r7, #136]
3883:../uvc.c      ****                     
 6706              		.loc 1 3883 0
 6707 3ab4 FEFFFFEB 		bl	_tx_thread_sleep
 6708              	.LVL752:
 6709 3ab8 C3FFFFEA 		b	.L536
 6710              	.L608:
3716:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 6711              		.loc 1 3716 0
 6712 3abc 74559FE5 		ldr	r5, .L621+100
3715:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6713              		.loc 1 3715 0
 6714 3ac0 5C059FE5 		ldr	r0, .L621+80
 6715 3ac4 0010E0E3 		mvn	r1, #0
3700:../uvc.c      ****                 consCount = 0;
 6716              		.loc 1 3700 0
 6717 3ac8 B068C4E1 		strh	r6, [r4, #128]	@ movhi
3697:../uvc.c      ****             	pb=0;
 6718              		.loc 1 3697 0
 6719 3acc B467C4E1 		strh	r6, [r4, #116]	@ movhi
3701:../uvc.c      ****                 hitFV     = CyFalse;
 6720              		.loc 1 3701 0
 6721 3ad0 B268C4E1 		strh	r6, [r4, #130]	@ movhi
3698:../uvc.c      ****             	pbc=0;
 6722              		.loc 1 3698 0
 6723 3ad4 B667C4E1 		strh	r6, [r4, #118]	@ movhi
3699:../uvc.c      ****                 prodCount = 0;
 6724              		.loc 1 3699 0
 6725 3ad8 B867C4E1 		strh	r6, [r4, #120]	@ movhi
3702:../uvc.c      **** 
 6726              		.loc 1 3702 0
 6727 3adc 7C6084E5 		str	r6, [r4, #124]
3715:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6728              		.loc 1 3715 0
 6729 3ae0 FEFFFFEB 		bl	_txe_mutex_get
 6730              	.LVL753:
3716:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 6731              		.loc 1 3716 0
 6732 3ae4 ED34D5E5 		ldrb	r3, [r5, #1261]	@ zero_extendqisi2
 6733 3ae8 013023E2 		eor	r3, r3, #1
 6734 3aec ED34C5E5 		strb	r3, [r5, #1261]
3718:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 6735              		.loc 1 3718 0
 6736 3af0 7230D4E5 		ldrb	r3, [r4, #114]	@ zero_extendqisi2
 6737 3af4 F00053E3 		cmp	r3, #240
 6738 3af8 3B00000A 		beq	.L614
 6739              	.L537:
3726:../uvc.c      **** 
 6740              		.loc 1 3726 0
 6741 3afc 7230D7E5 		ldrb	r3, [r7, #114]	@ zero_extendqisi2
 6742 3b00 FF0053E3 		cmp	r3, #255
 6743 3b04 1D00000A 		beq	.L615
3738:../uvc.c      ****                     //CyU3PThreadSleep(400);
 6744              		.loc 1 3738 0
 6745 3b08 7230D4E5 		ldrb	r3, [r4, #114]	@ zero_extendqisi2
 6746 3b0c AA0053E3 		cmp	r3, #170
 6747 3b10 2700000A 		beq	.L616
 6748              	.L538:
3776:../uvc.c      ****                 /* Reset the DMA channel. */
 6749              		.loc 1 3776 0
 6750 3b14 08059FE5 		ldr	r0, .L621+80
 6751 3b18 FEFFFFEB 		bl	_txe_mutex_put
 6752              	.LVL754:
3778:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6753              		.loc 1 3778 0
 6754 3b1c 10059FE5 		ldr	r0, .L621+96
 6755 3b20 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6756              	.LVL755:
3779:../uvc.c      ****                 {
 6757              		.loc 1 3779 0
 6758 3b24 005050E2 		subs	r5, r0, #0
 6759 3b28 7A00001A 		bne	.L617
3786:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6760              		.loc 1 3786 0
 6761 3b2c 0510A0E1 		mov	r1, r5
 6762 3b30 0520A0E1 		mov	r2, r5
 6763 3b34 F8049FE5 		ldr	r0, .L621+96
 6764              	.LVL756:
 6765 3b38 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6766              	.LVL757:
3787:../uvc.c      ****                 {
 6767              		.loc 1 3787 0
 6768 3b3c 005050E2 		subs	r5, r0, #0
 6769 3b40 6800001A 		bne	.L618
 6770              	.L557:
3795:../uvc.c      ****                 }
 6771              		.loc 1 3795 0
 6772 3b44 DC049FE5 		ldr	r0, .L621+84
 6773              	.LVL758:
 6774 3b48 0230A0E3 		mov	r3, #2
 6775 3b4c 0010A0E3 		mov	r1, #0
 6776 3b50 00308DE5 		str	r3, [sp]
 6777 3b54 0020A0E1 		mov	r2, r0
 6778 3b58 0130A0E1 		mov	r3, r1
 6779 3b5c FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6780              	.LVL759:
 6781 3b60 99FFFFEA 		b	.L536
 6782              	.LVL760:
 6783              	.L610:
3818:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6784              		.loc 1 3818 0
 6785 3b64 C8049FE5 		ldr	r0, .L621+96
 6786 3b68 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6787              	.LVL761:
3819:../uvc.c      ****                     {
 6788              		.loc 1 3819 0
 6789 3b6c 000050E3 		cmp	r0, #0
 6790 3b70 4000001A 		bne	.L589
3825:../uvc.c      ****                 }
 6791              		.loc 1 3825 0
 6792 3b74 8300A0E3 		mov	r0, #131
 6793              	.LVL762:
 6794 3b78 FEFFFFEB 		bl	CyU3PUsbFlushEp
 6795              	.LVL763:
 6796 3b7c B1FFFFEA 		b	.L559
 6797              	.L615:
3728:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 6798              		.loc 1 3728 0
 6799 3b80 A030D4E5 		ldrb	r3, [r4, #160]	@ zero_extendqisi2
 6800 3b84 020053E3 		cmp	r3, #2
 6801 3b88 013083E2 		add	r3, r3, #1
 6802 3b8c A030C4E5 		strb	r3, [r4, #160]
 6803 3b90 DFFFFF9A 		bls	.L538
3729:../uvc.c      ****                 		stiflag = 0x0F;
 6804              		.loc 1 3729 0
 6805 3b94 ED14D5E5 		ldrb	r1, [r5, #1261]	@ zero_extendqisi2
3730:../uvc.c      ****                 		IMcount = 0;
 6806              		.loc 1 3730 0
 6807 3b98 0F30A0E3 		mov	r3, #15
3729:../uvc.c      ****                 		stiflag = 0x0F;
 6808              		.loc 1 3729 0
 6809 3b9c 201081E3 		orr	r1, r1, #32
3731:../uvc.c      ****                 		}
 6810              		.loc 1 3731 0
 6811 3ba0 0020A0E3 		mov	r2, #0
3729:../uvc.c      ****                 		stiflag = 0x0F;
 6812              		.loc 1 3729 0
 6813 3ba4 ED14C5E5 		strb	r1, [r5, #1261]
3731:../uvc.c      ****                 		}
 6814              		.loc 1 3731 0
 6815 3ba8 A020C4E5 		strb	r2, [r4, #160]
3730:../uvc.c      ****                 		IMcount = 0;
 6816              		.loc 1 3730 0
 6817 3bac 7230C4E5 		strb	r3, [r4, #114]
 6818 3bb0 D7FFFFEA 		b	.L538
 6819              	.L616:
3744:../uvc.c      ****                 	{
 6820              		.loc 1 3744 0
 6821 3bb4 A030D4E5 		ldrb	r3, [r4, #160]	@ zero_extendqisi2
 6822 3bb8 020053E3 		cmp	r3, #2
 6823 3bbc 013083E2 		add	r3, r3, #1
 6824 3bc0 A030C4E5 		strb	r3, [r4, #160]
 6825 3bc4 D2FFFF9A 		bls	.L538
3746:../uvc.c      ****                      {
 6826              		.loc 1 3746 0
 6827 3bc8 7030D4E5 		ldrb	r3, [r4, #112]	@ zero_extendqisi2
 6828 3bcc 013043E2 		sub	r3, r3, #1
 6829 3bd0 030053E3 		cmp	r3, #3
 6830 3bd4 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 6831 3bd8 3E0000EA 		b	.L542
 6832              	.L544:
 6833 3bdc 983C0000 		.word	.L543
 6834 3be0 843D0000 		.word	.L545
 6835 3be4 C83D0000 		.word	.L546
 6836 3be8 303D0000 		.word	.L547
 6837              	.L614:
3718:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 6838              		.loc 1 3718 0 discriminator 1
 6839 3bec 00608DE5 		str	r6, [sp]
 6840 3bf0 E4039FE5 		ldr	r0, .L621+8
 6841 3bf4 8010A0E3 		mov	r1, #128
 6842 3bf8 0320A0E3 		mov	r2, #3
 6843 3bfc 60308DE2 		add	r3, sp, #96
 6844 3c00 FEFFFFEB 		bl	_txe_event_flags_get
 6845              	.LVL764:
 6846 3c04 000050E3 		cmp	r0, #0
 6847 3c08 BBFFFF1A 		bne	.L537
3723:../uvc.c      ****                 		IMcount = 0;
 6848              		.loc 1 3723 0
 6849 3c0c 0030E0E3 		mvn	r3, #0
3724:../uvc.c      ****                 	}
 6850              		.loc 1 3724 0
 6851 3c10 A000C4E5 		strb	r0, [r4, #160]
3723:../uvc.c      ****                 		IMcount = 0;
 6852              		.loc 1 3723 0
 6853 3c14 7230C4E5 		strb	r3, [r4, #114]
3724:../uvc.c      ****                 	}
 6854              		.loc 1 3724 0
 6855 3c18 BDFFFFEA 		b	.L538
 6856              	.LVL765:
 6857              	.L612:
 6858              	.LBB115:
 6859              	.LBB113:
3551:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 6860              		.loc 1 3551 0
 6861 3c1c 18149FE5 		ldr	r1, .L621+104
 6862 3c20 0100A0E3 		mov	r0, #1
 6863              	.LVL766:
 6864 3c24 FEFFFFEB 		bl	CyU3PDebugPrint
 6865              	.LVL767:
3552:../uvc.c      ****     }
 6866              		.loc 1 3552 0
 6867 3c28 10049FE5 		ldr	r0, .L621+108
 6868 3c2c FEFFFFEB 		bl	CyU3PGpifLoad
 6869              	.LVL768:
 6870 3c30 0050A0E1 		mov	r5, r0
 6871              	.LVL769:
 6872              	.L563:
3559:../uvc.c      ****     {
 6873              		.loc 1 3559 0
 6874 3c34 000055E3 		cmp	r5, #0
 6875 3c38 8800001A 		bne	.L619
 6876              	.LVL770:
3571:../uvc.c      ****     {
 6877              		.loc 1 3571 0
 6878 3c3c 4830D7E5 		ldrb	r3, [r7, #72]	@ zero_extendqisi2
 6879 3c40 023043E2 		sub	r3, r3, #2
 6880 3c44 FF3003E2 		and	r3, r3, #255
 6881 3c48 010053E3 		cmp	r3, #1
 6882 3c4c 95FFFF8A 		bhi	.L564
3569:../uvc.c      ****     }
 6883              		.loc 1 3569 0
 6884 3c50 0500A0E1 		mov	r0, r5
 6885 3c54 0510A0E1 		mov	r1, r5
 6886 3c58 FEFFFFEB 		bl	CyU3PGpifSMStart
 6887              	.LVL771:
3575:../uvc.c      ****     {
 6888              		.loc 1 3575 0
 6889 3c5c 005050E2 		subs	r5, r0, #0
 6890 3c60 90FFFF0A 		beq	.L564
3578:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6891              		.loc 1 3578 0
 6892 3c64 0400A0E3 		mov	r0, #4
 6893              	.LVL772:
 6894 3c68 D4139FE5 		ldr	r1, .L621+112
 6895 3c6c 0520A0E1 		mov	r2, r5
 6896 3c70 FEFFFFEB 		bl	CyU3PDebugPrint
 6897              	.LVL773:
3579:../uvc.c      ****     }
 6898              		.loc 1 3579 0
 6899 3c74 0500A0E1 		mov	r0, r5
 6900              	.LVL774:
 6901              	.L589:
3563:../uvc.c      ****     }
 6902              		.loc 1 3563 0
 6903 3c78 FEFFFFEB 		bl	CyFxAppErrorHandler
 6904              	.LVL775:
 6905              	.L613:
3556:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 6906              		.loc 1 3556 0
 6907 3c7c C4139FE5 		ldr	r1, .L621+116
 6908 3c80 0100A0E3 		mov	r0, #1
 6909              	.LVL776:
 6910 3c84 FEFFFFEB 		bl	CyU3PDebugPrint
 6911              	.LVL777:
3557:../uvc.c      ****     }
 6912              		.loc 1 3557 0
 6913 3c88 BC039FE5 		ldr	r0, .L621+120
 6914 3c8c FEFFFFEB 		bl	CyU3PGpifLoad
 6915              	.LVL778:
 6916 3c90 0050A0E1 		mov	r5, r0
 6917              	.LVL779:
 6918 3c94 E6FFFFEA 		b	.L563
 6919              	.LVL780:
 6920              	.L543:
 6921              	.LBE113:
 6922              	.LBE115:
3749:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 6923              		.loc 1 3749 0
 6924 3c98 6C2097E5 		ldr	r2, [r7, #108]
 6925 3c9c 3010A0E3 		mov	r1, #48
 6926 3ca0 000052E3 		cmp	r2, #0
 6927 3ca4 A220A003 		moveq	r2, #162
 6928 3ca8 2220A013 		movne	r2, #34
 6929 3cac 5230A0E3 		mov	r3, #82
 6930 3cb0 0100A0E3 		mov	r0, #1
 6931 3cb4 FEFFFFEB 		bl	SensorSetIrisControl
 6932              	.LVL781:
3751:../uvc.c      ****                  		break;
 6933              		.loc 1 3751 0
 6934 3cb8 6C2097E5 		ldr	r2, [r7, #108]
 6935 3cbc 0400A0E3 		mov	r0, #4
 6936 3cc0 000052E3 		cmp	r2, #0
 6937 3cc4 6C3097E5 		ldr	r3, [r7, #108]
 6938 3cc8 A220A003 		moveq	r2, #162
 6939 3ccc 2220A013 		movne	r2, #34
 6940 3cd0 78139FE5 		ldr	r1, .L621+124
 6941 3cd4 FEFFFFEB 		bl	CyU3PDebugPrint
 6942              	.LVL782:
 6943              	.L542:
3771:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6944              		.loc 1 3771 0
 6945 3cd8 0030A0E3 		mov	r3, #0
 6946 3cdc A030C7E5 		strb	r3, [r7, #160]
3773:../uvc.c      ****                 	}
 6947              		.loc 1 3773 0
 6948 3ce0 7230C7E5 		strb	r3, [r7, #114]
 6949 3ce4 8AFFFFEA 		b	.L538
 6950              	.LVL783:
 6951              	.L618:
3789:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 6952              		.loc 1 3789 0
 6953 3ce8 0400A0E3 		mov	r0, #4
 6954              	.LVL784:
 6955 3cec 60139FE5 		ldr	r1, .L621+128
 6956 3cf0 0520A0E1 		mov	r2, r5
 6957 3cf4 FEFFFFEB 		bl	CyU3PDebugPrint
 6958              	.LVL785:
3790:../uvc.c      ****                 }
 6959              		.loc 1 3790 0
 6960 3cf8 0500A0E1 		mov	r0, r5
 6961 3cfc FEFFFFEB 		bl	CyFxAppErrorHandler
 6962              	.LVL786:
 6963              	.L611:
3841:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 6964              		.loc 1 3841 0
 6965 3d00 0400A0E3 		mov	r0, #4
 6966              	.LVL787:
 6967 3d04 4C139FE5 		ldr	r1, .L621+132
 6968 3d08 0520A0E1 		mov	r2, r5
 6969 3d0c FEFFFFEB 		bl	CyU3PDebugPrint
 6970              	.LVL788:
3842:../uvc.c      ****                 }
 6971              		.loc 1 3842 0
 6972 3d10 0500A0E1 		mov	r0, r5
 6973 3d14 FEFFFFEB 		bl	CyFxAppErrorHandler
 6974              	.LVL789:
 6975              	.L617:
3781:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 6976              		.loc 1 3781 0
 6977 3d18 0400A0E3 		mov	r0, #4
 6978              	.LVL790:
 6979 3d1c 38139FE5 		ldr	r1, .L621+136
 6980 3d20 0520A0E1 		mov	r2, r5
 6981 3d24 FEFFFFEB 		bl	CyU3PDebugPrint
 6982              	.LVL791:
3782:../uvc.c      ****                 }
 6983              		.loc 1 3782 0
 6984 3d28 0500A0E1 		mov	r0, r5
 6985 3d2c FEFFFFEB 		bl	CyFxAppErrorHandler
 6986              	.LVL792:
 6987              	.L547:
3764:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 6988              		.loc 1 3764 0
 6989 3d30 6C2097E5 		ldr	r2, [r7, #108]
 6990 3d34 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 6991 3d38 000052E3 		cmp	r2, #0
 6992 3d3c B020A003 		moveq	r2, #176
 6993 3d40 3020A013 		movne	r2, #48
 6994 3d44 032082E1 		orr	r2, r2, r3
 6995 3d48 3010A0E3 		mov	r1, #48
 6996 3d4c 5230A0E3 		mov	r3, #82
 6997 3d50 0100A0E3 		mov	r0, #1
 6998 3d54 FEFFFFEB 		bl	SensorSetIrisControl
 6999              	.LVL793:
3766:../uvc.c      ****                  		break;
 7000              		.loc 1 3766 0
 7001 3d58 6C1097E5 		ldr	r1, [r7, #108]
 7002 3d5c 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 7003 3d60 000051E3 		cmp	r1, #0
 7004 3d64 B010A003 		moveq	r1, #176
 7005 3d68 3010A013 		movne	r1, #48
 7006 3d6c 022081E1 		orr	r2, r1, r2
 7007 3d70 6C3097E5 		ldr	r3, [r7, #108]
 7008 3d74 D4129FE5 		ldr	r1, .L621+124
 7009 3d78 0400A0E3 		mov	r0, #4
 7010 3d7c FEFFFFEB 		bl	CyU3PDebugPrint
 7011              	.LVL794:
3767:../uvc.c      ****                  	default:
 7012              		.loc 1 3767 0
 7013 3d80 D4FFFFEA 		b	.L542
 7014              	.L545:
3754:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 7015              		.loc 1 3754 0
 7016 3d84 6C2097E5 		ldr	r2, [r7, #108]
 7017 3d88 3010A0E3 		mov	r1, #48
 7018 3d8c 000052E3 		cmp	r2, #0
 7019 3d90 9220A003 		moveq	r2, #146
 7020 3d94 1220A013 		movne	r2, #18
 7021 3d98 5230A0E3 		mov	r3, #82
 7022 3d9c 0100A0E3 		mov	r0, #1
 7023 3da0 FEFFFFEB 		bl	SensorSetIrisControl
 7024              	.LVL795:
3756:../uvc.c      ****                  		break;
 7025              		.loc 1 3756 0
 7026 3da4 6C2097E5 		ldr	r2, [r7, #108]
 7027 3da8 A0129FE5 		ldr	r1, .L621+124
 7028 3dac 000052E3 		cmp	r2, #0
 7029 3db0 6C3097E5 		ldr	r3, [r7, #108]
 7030 3db4 9220A003 		moveq	r2, #146
 7031 3db8 1220A013 		movne	r2, #18
 7032 3dbc 0400A0E3 		mov	r0, #4
 7033 3dc0 FEFFFFEB 		bl	CyU3PDebugPrint
 7034              	.LVL796:
3757:../uvc.c      ****                  	case 3: //720
 7035              		.loc 1 3757 0
 7036 3dc4 C3FFFFEA 		b	.L542
 7037              	.L546:
3759:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 7038              		.loc 1 3759 0
 7039 3dc8 6C2097E5 		ldr	r2, [r7, #108]
 7040 3dcc 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 7041 3dd0 000052E3 		cmp	r2, #0
 7042 3dd4 8020A003 		moveq	r2, #128
 7043 3dd8 0020A013 		movne	r2, #0
 7044 3ddc 032082E1 		orr	r2, r2, r3
 7045 3de0 3010A0E3 		mov	r1, #48
 7046 3de4 5230A0E3 		mov	r3, #82
 7047 3de8 0100A0E3 		mov	r0, #1
 7048 3dec FEFFFFEB 		bl	SensorSetIrisControl
 7049              	.LVL797:
3761:../uvc.c      ****                  		break;
 7050              		.loc 1 3761 0
 7051 3df0 6C1097E5 		ldr	r1, [r7, #108]
 7052 3df4 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 7053 3df8 000051E3 		cmp	r1, #0
 7054 3dfc 8010A003 		moveq	r1, #128
 7055 3e00 0010A013 		movne	r1, #0
 7056 3e04 022081E1 		orr	r2, r1, r2
 7057 3e08 6C3097E5 		ldr	r3, [r7, #108]
 7058 3e0c 3C129FE5 		ldr	r1, .L621+124
 7059 3e10 0400A0E3 		mov	r0, #4
 7060 3e14 FEFFFFEB 		bl	CyU3PDebugPrint
 7061              	.LVL798:
3762:../uvc.c      ****                  	case 4: //VGA
 7062              		.loc 1 3762 0
 7063 3e18 AEFFFFEA 		b	.L542
 7064              	.LVL799:
 7065              	.L590:
 7066              	.LBB116:
 7067              	.LBB100:
3058:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7068              		.loc 1 3058 0
 7069 3e1c 0400A0E3 		mov	r0, #4
 7070              	.LVL800:
 7071 3e20 38129FE5 		ldr	r1, .L621+140
 7072 3e24 FEFFFFEB 		bl	CyU3PDebugPrint
 7073              	.LVL801:
3059:../uvc.c      ****     }
 7074              		.loc 1 3059 0
 7075 3e28 0400A0E1 		mov	r0, r4
 7076 3e2c FEFFFFEB 		bl	CyFxAppErrorHandler
 7077              	.LVL802:
 7078              	.L620:
 7079              	.LBE100:
 7080              	.LBE116:
 7081              	.LBB117:
 7082              	.LBB107:
3524:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7083              		.loc 1 3524 0
 7084 3e30 0800A0E1 		mov	r0, r8
 7085              	.LVL803:
 7086              	.L587:
 7087 3e34 28129FE5 		ldr	r1, .L621+144
 7088 3e38 0420A0E1 		mov	r2, r4
 7089 3e3c FEFFFFEB 		bl	CyU3PDebugPrint
 7090              	.LVL804:
3525:../uvc.c      ****     }
 7091              		.loc 1 3525 0
 7092 3e40 0400A0E1 		mov	r0, r4
 7093 3e44 8BFFFFEA 		b	.L589
 7094              	.LVL805:
 7095              	.L606:
3499:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7096              		.loc 1 3499 0
 7097 3e48 0800A0E1 		mov	r0, r8
 7098              	.LVL806:
 7099 3e4c 14129FE5 		ldr	r1, .L621+148
 7100 3e50 0420A0E1 		mov	r2, r4
 7101 3e54 FEFFFFEB 		bl	CyU3PDebugPrint
 7102              	.LVL807:
3500:../uvc.c      ****     }
 7103              		.loc 1 3500 0
 7104 3e58 0400A0E1 		mov	r0, r4
 7105 3e5c FEFFFFEB 		bl	CyFxAppErrorHandler
 7106              	.LVL808:
 7107              	.L619:
 7108              	.LBE107:
 7109              	.LBE117:
 7110              	.LBB118:
 7111              	.LBB114:
3562:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7112              		.loc 1 3562 0
 7113 3e60 0400A0E3 		mov	r0, #4
 7114              	.LVL809:
 7115 3e64 00129FE5 		ldr	r1, .L621+152
 7116 3e68 0520A0E1 		mov	r2, r5
 7117 3e6c FEFFFFEB 		bl	CyU3PDebugPrint
 7118              	.LVL810:
3563:../uvc.c      ****     }
 7119              		.loc 1 3563 0
 7120 3e70 0500A0E1 		mov	r0, r5
 7121 3e74 7FFFFFEA 		b	.L589
 7122              	.LVL811:
 7123              	.L594:
 7124              	.LBE114:
 7125              	.LBE118:
 7126              	.LBB119:
 7127              	.LBB108:
3215:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7128              		.loc 1 3215 0
 7129 3e78 0400A0E3 		mov	r0, #4
 7130              	.LVL812:
 7131 3e7c EC119FE5 		ldr	r1, .L621+156
 7132 3e80 0520A0E1 		mov	r2, r5
 7133 3e84 FEFFFFEB 		bl	CyU3PDebugPrint
 7134              	.LVL813:
3216:../uvc.c      ****     }
 7135              		.loc 1 3216 0
 7136 3e88 0500A0E1 		mov	r0, r5
 7137 3e8c FEFFFFEB 		bl	CyFxAppErrorHandler
 7138              	.LVL814:
 7139              	.L593:
3193:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7140              		.loc 1 3193 0
 7141 3e90 0400A0E3 		mov	r0, #4
 7142              	.LVL815:
 7143 3e94 D8119FE5 		ldr	r1, .L621+160
 7144 3e98 0520A0E1 		mov	r2, r5
 7145 3e9c FEFFFFEB 		bl	CyU3PDebugPrint
 7146              	.LVL816:
3194:../uvc.c      ****     }
 7147              		.loc 1 3194 0
 7148 3ea0 0500A0E1 		mov	r0, r5
 7149 3ea4 FEFFFFEB 		bl	CyFxAppErrorHandler
 7150              	.LVL817:
 7151              	.L592:
 7152              	.LBE108:
 7153              	.LBE119:
 7154              	.LBB120:
 7155              	.LBB103:
3119:../uvc.c      ****         CyFxAppErrorHandler (status);
 7156              		.loc 1 3119 0
 7157 3ea8 0400A0E3 		mov	r0, #4
 7158              	.LVL818:
 7159 3eac C4119FE5 		ldr	r1, .L621+164
 7160 3eb0 FEFFFFEB 		bl	CyU3PDebugPrint
 7161              	.LVL819:
3120:../uvc.c      ****     }
 7162              		.loc 1 3120 0
 7163 3eb4 0500A0E1 		mov	r0, r5
 7164 3eb8 FEFFFFEB 		bl	CyFxAppErrorHandler
 7165              	.LVL820:
 7166              	.L591:
3106:../uvc.c      ****         CyFxAppErrorHandler (status);
 7167              		.loc 1 3106 0
 7168 3ebc 0400A0E3 		mov	r0, #4
 7169              	.LVL821:
 7170 3ec0 B4119FE5 		ldr	r1, .L621+168
 7171 3ec4 FEFFFFEB 		bl	CyU3PDebugPrint
 7172              	.LVL822:
3107:../uvc.c      ****     }
 7173              		.loc 1 3107 0
 7174 3ec8 0500A0E1 		mov	r0, r5
 7175 3ecc FEFFFFEB 		bl	CyFxAppErrorHandler
 7176              	.LVL823:
 7177              	.L602:
 7178              	.LBE103:
 7179              	.LBE120:
 7180              	.LBB121:
 7181              	.LBB109:
3311:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7182              		.loc 1 3311 0
 7183 3ed0 0400A0E3 		mov	r0, #4
 7184              	.LVL824:
 7185 3ed4 A4119FE5 		ldr	r1, .L621+172
 7186 3ed8 0420A0E1 		mov	r2, r4
 7187 3edc FEFFFFEB 		bl	CyU3PDebugPrint
 7188              	.LVL825:
3312:../uvc.c      ****     }
 7189              		.loc 1 3312 0
 7190 3ee0 0400A0E1 		mov	r0, r4
 7191 3ee4 FEFFFFEB 		bl	CyFxAppErrorHandler
 7192              	.LVL826:
 7193              	.L601:
3290:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7194              		.loc 1 3290 0
 7195 3ee8 0400A0E3 		mov	r0, #4
 7196              	.LVL827:
 7197 3eec 90119FE5 		ldr	r1, .L621+176
 7198 3ef0 0420A0E1 		mov	r2, r4
 7199 3ef4 FEFFFFEB 		bl	CyU3PDebugPrint
 7200              	.LVL828:
3291:../uvc.c      ****     }
 7201              		.loc 1 3291 0
 7202 3ef8 0400A0E1 		mov	r0, r4
 7203 3efc FEFFFFEB 		bl	CyFxAppErrorHandler
 7204              	.LVL829:
 7205              	.L600:
3277:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7206              		.loc 1 3277 0
 7207 3f00 0400A0E3 		mov	r0, #4
 7208              	.LVL830:
 7209 3f04 7C119FE5 		ldr	r1, .L621+180
 7210 3f08 0420A0E1 		mov	r2, r4
 7211 3f0c FEFFFFEB 		bl	CyU3PDebugPrint
 7212              	.LVL831:
3278:../uvc.c      ****     }
 7213              		.loc 1 3278 0
 7214 3f10 0400A0E1 		mov	r0, r4
 7215 3f14 FEFFFFEB 		bl	CyFxAppErrorHandler
 7216              	.LVL832:
 7217              	.L599:
3263:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7218              		.loc 1 3263 0
 7219 3f18 0400A0E3 		mov	r0, #4
 7220              	.LVL833:
 7221 3f1c 68119FE5 		ldr	r1, .L621+184
 7222 3f20 0420A0E1 		mov	r2, r4
 7223 3f24 FEFFFFEB 		bl	CyU3PDebugPrint
 7224              	.LVL834:
3264:../uvc.c      ****     }
 7225              		.loc 1 3264 0
 7226 3f28 0400A0E1 		mov	r0, r4
 7227 3f2c FEFFFFEB 		bl	CyFxAppErrorHandler
 7228              	.LVL835:
 7229              	.L598:
3249:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7230              		.loc 1 3249 0
 7231 3f30 0400A0E3 		mov	r0, #4
 7232              	.LVL836:
 7233 3f34 54119FE5 		ldr	r1, .L621+188
 7234 3f38 0620A0E1 		mov	r2, r6
 7235 3f3c FEFFFFEB 		bl	CyU3PDebugPrint
 7236              	.LVL837:
3250:../uvc.c      ****     }
 7237              		.loc 1 3250 0
 7238 3f40 0600A0E1 		mov	r0, r6
 7239 3f44 FEFFFFEB 		bl	CyFxAppErrorHandler
 7240              	.LVL838:
 7241              	.L597:
3236:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7242              		.loc 1 3236 0
 7243 3f48 0400A0E3 		mov	r0, #4
 7244              	.LVL839:
 7245 3f4c 40119FE5 		ldr	r1, .L621+192
 7246 3f50 0520A0E1 		mov	r2, r5
 7247 3f54 FEFFFFEB 		bl	CyU3PDebugPrint
 7248              	.LVL840:
3237:../uvc.c      ****     }
 7249              		.loc 1 3237 0
 7250 3f58 0500A0E1 		mov	r0, r5
 7251 3f5c FEFFFFEB 		bl	CyFxAppErrorHandler
 7252              	.LVL841:
 7253              	.L596:
3230:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7254              		.loc 1 3230 0
 7255 3f60 0400A0E3 		mov	r0, #4
 7256              	.LVL842:
 7257 3f64 2C119FE5 		ldr	r1, .L621+196
 7258 3f68 0520A0E1 		mov	r2, r5
 7259 3f6c FEFFFFEB 		bl	CyU3PDebugPrint
 7260              	.LVL843:
3231:../uvc.c      ****     }
 7261              		.loc 1 3231 0
 7262 3f70 0500A0E1 		mov	r0, r5
 7263 3f74 FEFFFFEB 		bl	CyFxAppErrorHandler
 7264              	.LVL844:
 7265              	.L595:
3224:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7266              		.loc 1 3224 0
 7267 3f78 0400A0E3 		mov	r0, #4
 7268              	.LVL845:
 7269 3f7c 18119FE5 		ldr	r1, .L621+200
 7270 3f80 0520A0E1 		mov	r2, r5
 7271 3f84 FEFFFFEB 		bl	CyU3PDebugPrint
 7272              	.LVL846:
3225:../uvc.c      ****     }
 7273              		.loc 1 3225 0
 7274 3f88 0500A0E1 		mov	r0, r5
 7275 3f8c FEFFFFEB 		bl	CyFxAppErrorHandler
 7276              	.LVL847:
 7277              	.L605:
3408:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7278              		.loc 1 3408 0
 7279 3f90 0800A0E1 		mov	r0, r8
 7280              	.LVL848:
 7281 3f94 04119FE5 		ldr	r1, .L621+204
 7282 3f98 0420A0E1 		mov	r2, r4
 7283 3f9c FEFFFFEB 		bl	CyU3PDebugPrint
 7284              	.LVL849:
3409:../uvc.c      ****     }
 7285              		.loc 1 3409 0
 7286 3fa0 0400A0E1 		mov	r0, r4
 7287 3fa4 FEFFFFEB 		bl	CyFxAppErrorHandler
 7288              	.LVL850:
 7289              	.L603:
3377:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7290              		.loc 1 3377 0
 7291 3fa8 0400A0E3 		mov	r0, #4
 7292              	.LVL851:
 7293 3fac F0109FE5 		ldr	r1, .L621+208
 7294 3fb0 0420A0E1 		mov	r2, r4
 7295 3fb4 FEFFFFEB 		bl	CyU3PDebugPrint
 7296              	.LVL852:
3378:../uvc.c      ****     }
 7297              		.loc 1 3378 0
 7298 3fb8 0400A0E1 		mov	r0, r4
 7299 3fbc FEFFFFEB 		bl	CyFxAppErrorHandler
 7300              	.LVL853:
 7301              	.L604:
3384:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
 7302              		.loc 1 3384 0
 7303 3fc0 0400A0E3 		mov	r0, #4
 7304 3fc4 DC109FE5 		ldr	r1, .L621+212
 7305 3fc8 FEFFFFEB 		bl	CyU3PDebugPrint
 7306              	.LVL854:
3385:../uvc.c      ****     }
 7307              		.loc 1 3385 0
 7308 3fcc 0800A0E1 		mov	r0, r8
 7309 3fd0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7310              	.LVL855:
 7311              	.L622:
 7312              		.align	2
 7313              	.L621:
 7314 3fd4 00C20100 		.word	115200
 7315 3fd8 A0860100 		.word	100000
 7316 3fdc 00000000 		.word	.LANCHOR0
 7317 3fe0 00000000 		.word	CyFxGpifCB
 7318 3fe4 88130000 		.word	5000
 7319 3fe8 00000000 		.word	CyFxUVCApplnUSBSetupCB
 7320 3fec 00000000 		.word	CyFxUVCApplnUSBEventCB
 7321 3ff0 00000000 		.word	CyFxUSBDeviceDscr
 7322 3ff4 00000000 		.word	CyFxUSBDeviceDscrSS
 7323 3ff8 00000000 		.word	CyFxUSBDeviceQualDscr
 7324 3ffc 00000000 		.word	CyFxUSBBOSDscr
 7325 4000 00000000 		.word	CyFxUSBHSConfigDscr
 7326 4004 00000000 		.word	CyFxUSBFSConfigDscr
 7327 4008 00000000 		.word	CyFxUSBSSConfigDscr
 7328 400c 00000000 		.word	CyFxUSBStringLangIDDscr
 7329 4010 00000000 		.word	CyFxUSBManufactureDscr
 7330 4014 00000000 		.word	CyFxUSBProductDscr
 7331 4018 013F0203 		.word	50478849
 7332 401c 00000000 		.word	glChHandleInterStat
 7333 4020 00000000 		.word	glInterStaBuffer
 7334 4024 00000000 		.word	imgHdMux
 7335 4028 01010000 		.word	257
 7336 402c 03030000 		.word	771
 7337 4030 00000000 		.word	CyFxUvcApplnDmaCallback
 7338 4034 00000000 		.word	glChHandleUVCStream
 7339 4038 00000000 		.word	.LANCHOR1
 7340 403c A00B0000 		.word	.LC65
 7341 4040 A0010000 		.word	.LANCHOR2+416
 7342 4044 F80B0000 		.word	.LC68
 7343 4048 B00B0000 		.word	.LC66
 7344 404c BC010000 		.word	.LANCHOR2+444
 7345 4050 E80A0000 		.word	.LC61
 7346 4054 380B0000 		.word	.LC63
 7347 4058 6C0B0000 		.word	.LC64
 7348 405c 0C0B0000 		.word	.LC62
 7349 4060 BC070000 		.word	.LC43
 7350 4064 E4090000 		.word	.LC56
 7351 4068 C00A0000 		.word	.LC60
 7352 406c C00B0000 		.word	.LC67
 7353 4070 40080000 		.word	.LC47
 7354 4074 14080000 		.word	.LC46
 7355 4078 F8070000 		.word	.LC45
 7356 407c DC070000 		.word	.LC44
 7357 4080 B4090000 		.word	.LC55
 7358 4084 84090000 		.word	.LC54
 7359 4088 4C090000 		.word	.LC53
 7360 408c 18090000 		.word	.LC52
 7361 4090 E4080000 		.word	.LC51
 7362 4094 B8080000 		.word	.LC50
 7363 4098 8C080000 		.word	.LC49
 7364 409c 64080000 		.word	.LC48
 7365 40a0 900A0000 		.word	.LC59
 7366 40a4 180A0000 		.word	.LC57
 7367 40a8 580A0000 		.word	.LC58
 7368              	.LBE109:
 7369              	.LBE121:
 7370              		.cfi_endproc
 7371              	.LFE19:
 7373              		.align	2
 7374              		.global	UVCAppEP0Thread_Entry
 7376              	UVCAppEP0Thread_Entry:
 7377              	.LFB25:
4706:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 7378              		.loc 1 4706 0
 7379              		.cfi_startproc
 7380              		@ args = 0, pretend = 0, frame = 64
 7381              		@ frame_needed = 0, uses_anonymous_args = 0
 7382              	.LVL856:
 7383 40ac F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 7384              	.LCFI27:
 7385              		.cfi_def_cfa_offset 36
 7386              		.cfi_offset 4, -36
 7387              		.cfi_offset 5, -32
 7388              		.cfi_offset 6, -28
 7389              		.cfi_offset 7, -24
 7390              		.cfi_offset 8, -20
 7391              		.cfi_offset 9, -16
 7392              		.cfi_offset 10, -12
 7393              		.cfi_offset 11, -8
 7394              		.cfi_offset 14, -4
 7395 40b0 D87F9FE5 		ldr	r7, .L981
 7396 40b4 D8AF9FE5 		ldr	r10, .L981+4
 7397 40b8 D86F9FE5 		ldr	r6, .L981+8
4780:../uvc.c      ****                 {
 7398              		.loc 1 4780 0
 7399 40bc D89F9FE5 		ldr	r9, .L981+12
 7400              	.LBB154:
 7401              	.LBB155:
4213:../uvc.c      ****     {
 7402              		.loc 1 4213 0
 7403 40c0 D88F9FE5 		ldr	r8, .L981+16
 7404              	.LBE155:
 7405              	.LBE154:
4706:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 7406              		.loc 1 4706 0
 7407 40c4 5CD04DE2 		sub	sp, sp, #92
 7408              	.LCFI28:
 7409              		.cfi_def_cfa_offset 128
 7410              	.LVL857:
4728:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
 7411              		.loc 1 4728 0
 7412 40c8 07B0A0E1 		mov	fp, r7
 7413              	.LVL858:
 7414              	.L888:
 7415 40cc 0030E0E3 		mvn	r3, #0
 7416 40d0 00308DE5 		str	r3, [sp]
 7417 40d4 B40F9FE5 		ldr	r0, .L981
 7418 40d8 4C10A0E3 		mov	r1, #76
 7419 40dc 0120A0E3 		mov	r2, #1
 7420 40e0 44308DE2 		add	r3, sp, #68
 7421 40e4 FEFFFFEB 		bl	_txe_event_flags_get
 7422              	.LVL859:
 7423 40e8 000050E3 		cmp	r0, #0
 7424 40ec 3B00001A 		bne	.L625
4732:../uvc.c      ****             {
 7425              		.loc 1 4732 0
 7426 40f0 8C309BE5 		ldr	r3, [fp, #140]
 7427 40f4 000053E3 		cmp	r3, #0
 7428 40f8 9600000A 		beq	.L942
 7429              	.L627:
4741:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 7430              		.loc 1 4741 0
 7431 40fc 44309DE5 		ldr	r3, [sp, #68]
 7432 4100 0C0013E3 		tst	r3, #12
 7433 4104 7E00001A 		bne	.L943
 7434              	.L629:
4748:../uvc.c      ****             {
 7435              		.loc 1 4748 0
 7436 4108 040013E3 		tst	r3, #4
 7437 410c 1F00000A 		beq	.L630
4750:../uvc.c      ****                 {
 7438              		.loc 1 4750 0
 7439 4110 B020D9E1 		ldrh	r2, [r9]
 7440 4114 2224A0E1 		mov	r2, r2, lsr #8
 7441 4118 030052E3 		cmp	r2, #3
 7442 411c 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 7443 4120 150000EA 		b	.L631
 7444              	.L633:
 7445 4124 7C410000 		.word	.L631
 7446 4128 34410000 		.word	.L634
 7447 412c E8410000 		.word	.L635
 7448 4130 B0420000 		.word	.L636
 7449              	.L634:
 7450              	.LBB229:
 7451              	.LBB230:
3988:../uvc.c      ****     {
 7452              		.loc 1 3988 0
 7453 4134 B020D8E1 		ldrh	r2, [r8]
 7454 4138 060C52E3 		cmp	r2, #1536
 7455 413c A901000A 		beq	.L669
 7456 4140 EC00009A 		bls	.L944
 7457 4144 090C52E3 		cmp	r2, #2304
 7458 4148 4B02000A 		beq	.L677
 7459 414c 2201009A 		bls	.L945
 7460 4150 0B0C52E3 		cmp	r2, #2816
 7461 4154 B501000A 		beq	.L680
 7462 4158 030B52E3 		cmp	r2, #3072
 7463 415c 3E02000A 		beq	.L681
 7464 4160 0A0C52E3 		cmp	r2, #2560
 7465 4164 2002000A 		beq	.L946
 7466              	.L668:
4045:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 7467              		.loc 1 4045 0
 7468 4168 683F9FE5 		ldr	r3, .L981+72
 7469 416c 0400A0E3 		mov	r0, #4
 7470 4170 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 7471 4174 281F9FE5 		ldr	r1, .L981+20
 7472 4178 FEFFFFEB 		bl	CyU3PDebugPrint
 7473              	.LVL860:
 7474              	.L631:
 7475              	.LBE230:
 7476              	.LBE229:
4771:../uvc.c      ****                         break;
 7477              		.loc 1 4771 0
 7478 417c 0000A0E3 		mov	r0, #0
 7479 4180 0020A0E1 		mov	r2, r0
 7480 4184 0110A0E3 		mov	r1, #1
 7481 4188 FEFFFFEB 		bl	CyU3PUsbStall
 7482              	.LVL861:
 7483 418c 44309DE5 		ldr	r3, [sp, #68]
 7484              	.L630:
4776:../uvc.c      ****             {
 7485              		.loc 1 4776 0
 7486 4190 080013E3 		tst	r3, #8
 7487 4194 0700000A 		beq	.L882
4780:../uvc.c      ****                 {
 7488              		.loc 1 4780 0
 7489 4198 B030D9E1 		ldrh	r3, [r9]
 7490 419c 010053E3 		cmp	r3, #1
 7491 41a0 7200000A 		beq	.L883
4782:../uvc.c      ****                 }
 7492              		.loc 1 4782 0
 7493 41a4 0000A0E3 		mov	r0, #0
 7494 41a8 0020A0E1 		mov	r2, r0
 7495 41ac 0110A0E3 		mov	r1, #1
 7496 41b0 FEFFFFEB 		bl	CyU3PUsbStall
 7497              	.LVL862:
 7498 41b4 44309DE5 		ldr	r3, [sp, #68]
 7499              	.L882:
4791:../uvc.c      ****             {
 7500              		.loc 1 4791 0
 7501 41b8 400013E3 		tst	r3, #64
 7502 41bc 0700000A 		beq	.L625
4796:../uvc.c      **** 
 7503              		.loc 1 4796 0
 7504 41c0 1800A0E3 		mov	r0, #24
 7505 41c4 48108DE2 		add	r1, sp, #72
 7506              	.LVL863:
 7507 41c8 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
 7508              	.LVL864:
4853:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 7509              		.loc 1 4853 0
 7510 41cc 9237DAE5 		ldrb	r3, [r10, #1938]	@ zero_extendqisi2
 7511 41d0 0F0053E3 		cmp	r3, #15
 7512 41d4 8800000A 		beq	.L947
4880:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 7513              		.loc 1 4880 0
 7514 41d8 000053E3 		cmp	r3, #0
 7515 41dc 6600000A 		beq	.L948
 7516              	.L625:
5004:../uvc.c      ****     }
 7517              		.loc 1 5004 0
 7518 41e0 FEFFFFEB 		bl	_txe_thread_relinquish
 7519              	.LVL865:
5005:../uvc.c      **** }
 7520              		.loc 1 5005 0
 7521 41e4 B8FFFFEA 		b	.L888
 7522              	.L635:
 7523              	.LBB366:
 7524              	.LBB367:
3913:../uvc.c      ****     {
 7525              		.loc 1 3913 0
 7526 41e8 B020D8E1 		ldrh	r2, [r8]
 7527 41ec 060C52E3 		cmp	r2, #1536
 7528 41f0 3201000A 		beq	.L638
 7529 41f4 B200008A 		bhi	.L639
 7530 41f8 030C52E3 		cmp	r2, #768
 7531 41fc 2701000A 		beq	.L640
 7532 4200 E500008A 		bhi	.L641
 7533 4204 010C52E3 		cmp	r2, #256
 7534 4208 2001000A 		beq	.L642
 7535 420c 020C52E3 		cmp	r2, #512
 7536 4210 D4FFFF1A 		bne	.L668
 7537              	.LVL866:
 7538              	.LBB368:
 7539              	.LBB369:
1359:../uvc.c      ****     /*
 7540              		.loc 1 1359 0
 7541 4214 BC3E9FE5 		ldr	r3, .L981+72
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7542              		.loc 1 1348 0
 7543 4218 4805DAE5 		ldrb	r0, [r10, #1352]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 7544              		.loc 1 1359 0
 7545 421c 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7546              		.loc 1 1349 0
 7547 4220 4915DAE5 		ldrb	r1, [r10, #1353]	@ zero_extendqisi2
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7548              		.loc 1 1350 0
 7549 4224 5725DAE5 		ldrb	r2, [r10, #1367]	@ zero_extendqisi2
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 7550              		.loc 1 1351 0
 7551 4228 4A35DAE5 		ldrb	r3, [r10, #1354]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7552              		.loc 1 1349 0
 7553 422c FF1001E2 		and	r1, r1, #255
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7554              		.loc 1 1350 0
 7555 4230 FF2002E2 		and	r2, r2, #255
1367:../uvc.c      **** 		 {
 7556              		.loc 1 1367 0
 7557 4234 830055E3 		cmp	r5, #131
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7558              		.loc 1 1348 0
 7559 4238 FFC000E2 		and	ip, r0, #255
 7560              	.LVL867:
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7561              		.loc 1 1349 0
 7562 423c 2C108DE5 		str	r1, [sp, #44]
 7563              	.LVL868:
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7564              		.loc 1 1350 0
 7565 4240 28208DE5 		str	r2, [sp, #40]
 7566              	.LVL869:
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 7567              		.loc 1 1351 0
 7568 4244 FF3003E2 		and	r3, r3, #255
 7569              	.LVL870:
1367:../uvc.c      **** 		 {
 7570              		.loc 1 1367 0
 7571 4248 A405000A 		beq	.L652
 7572 424c 9802009A 		bls	.L949
 7573 4250 850055E3 		cmp	r5, #133
 7574 4254 8B05000A 		beq	.L657
 7575 4258 7905003A 		bcc	.L658
 7576 425c 860055E3 		cmp	r5, #134
 7577 4260 1F04000A 		beq	.L659
 7578 4264 870055E3 		cmp	r5, #135
 7579 4268 9205001A 		bne	.L651
1802:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 7580              		.loc 1 1802 0
 7581 426c 020053E3 		cmp	r3, #2
1803:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 7582              		.loc 1 1803 0
 7583 4270 53C5DAE5 		ldrb	ip, [r10, #1363]	@ zero_extendqisi2
 7584              	.LVL871:
1814:../uvc.c      **** 		 	 if(Len == 2){
 7585              		.loc 1 1814 0
 7586 4274 0300A0E1 		mov	r0, r3
 7587              	.LVL872:
1804:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 7588              		.loc 1 1804 0
 7589 4278 5425DAE5 		ldrb	r2, [r10, #1364]	@ zero_extendqisi2
1802:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 7590              		.loc 1 1802 0
 7591 427c 7007000A 		beq	.L950
 7592              	.L664:
1810:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 7593              		.loc 1 1810 0
 7594 4280 0030A0E3 		mov	r3, #0
 7595              	.LVL873:
1814:../uvc.c      **** 		 	 if(Len == 2){
 7596              		.loc 1 1814 0
 7597 4284 701E9FE5 		ldr	r1, .L981+108
1807:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 7598              		.loc 1 1807 0
 7599 4288 28C0C7E5 		strb	ip, [r7, #40]
1809:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7600              		.loc 1 1809 0
 7601 428c 2920C7E5 		strb	r2, [r7, #41]
1810:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 7602              		.loc 1 1810 0
 7603 4290 2B30C7E5 		strb	r3, [r7, #43]
1820:../uvc.c      **** 		 	 }
 7604              		.loc 1 1820 0
 7605 4294 0340A0E1 		mov	r4, r3
 7606 4298 24308DE5 		str	r3, [sp, #36]
1814:../uvc.c      **** 		 	 if(Len == 2){
 7607              		.loc 1 1814 0
 7608 429c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7609              	.LVL874:
1819:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 7610              		.loc 1 1819 0
 7611 42a0 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 7612              	.LVL875:
1820:../uvc.c      **** 		 	 }
 7613              		.loc 1 1820 0
 7614 42a4 2A30D7E5 		ldrb	r3, [r7, #42]	@ zero_extendqisi2
 7615              	.LVL876:
 7616 42a8 24C09DE5 		ldr	ip, [sp, #36]
 7617 42ac B50200EA 		b	.L661
 7618              	.LVL877:
 7619              	.L636:
 7620              	.LBE369:
 7621              	.LBE368:
 7622              	.LBE367:
 7623              	.LBE366:
 7624              	.LBB385:
 7625              	.LBB218:
4213:../uvc.c      ****     {
 7626              		.loc 1 4213 0
 7627 42b0 B030D8E1 		ldrh	r3, [r8]
 7628 42b4 E44D9FE5 		ldr	r4, .L981+16
 7629 42b8 0D0C53E3 		cmp	r3, #3328
 7630 42bc B303000A 		beq	.L777
 7631 42c0 6F00008A 		bhi	.L778
 7632 42c4 060C53E3 		cmp	r3, #1536
 7633 42c8 AC03000A 		beq	.L779
 7634 42cc A700009A 		bls	.L951
 7635 42d0 090C53E3 		cmp	r3, #2304
 7636 42d4 A503000A 		beq	.L787
 7637 42d8 3201009A 		bls	.L952
 7638 42dc 0B0C53E3 		cmp	r3, #2816
 7639 42e0 9E03000A 		beq	.L791
 7640 42e4 030B53E3 		cmp	r3, #3072
 7641 42e8 2202000A 		beq	.L792
 7642 42ec 0A0C53E3 		cmp	r3, #2560
 7643 42f0 A1FFFF1A 		bne	.L631
 7644              	.LVL878:
4254:../uvc.c      ****     		}else/* no support for 1080p camera */
 7645              		.loc 1 4254 0
 7646 42f4 1900A0E3 		mov	r0, #25
 7647 42f8 FEFFFFEB 		bl	ControlHandle
 7648              	.LVL879:
 7649 42fc 44309DE5 		ldr	r3, [sp, #68]
 7650 4300 A2FFFFEA 		b	.L630
 7651              	.L943:
 7652              	.LBE218:
 7653              	.LBE385:
4742:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
 7654              		.loc 1 4742 0
 7655 4304 9C0D9FE5 		ldr	r0, .L981+24
 7656 4308 C81D9FE5 		ldr	r1, .L981+72
 7657 430c 982D9FE5 		ldr	r2, .L981+28
 7658 4310 0000D0E5 		ldrb	r0, [r0]	@ zero_extendqisi2
 7659 4314 00E0D1E5 		ldrb	lr, [r1]	@ zero_extendqisi2
 7660 4318 B010D2E1 		ldrh	r1, [r2]
 7661 431c B0C0D8E1 		ldrh	ip, [r8]
 7662 4320 00008DE5 		str	r0, [sp]
 7663 4324 B000D9E1 		ldrh	r0, [r9]
 7664 4328 10108DE5 		str	r1, [sp, #16]
 7665 432c 0010A0E3 		mov	r1, #0
 7666 4330 0C008DE5 		str	r0, [sp, #12]
 7667 4334 14108DE5 		str	r1, [sp, #20]
 7668 4338 4820D7E5 		ldrb	r2, [r7, #72]	@ zero_extendqisi2
 7669 433c 04E08DE5 		str	lr, [sp, #4]
 7670 4340 08C08DE5 		str	ip, [sp, #8]
 7671 4344 0400A0E3 		mov	r0, #4
 7672 4348 601D9FE5 		ldr	r1, .L981+32
 7673 434c FEFFFFEB 		bl	CyU3PDebugPrint
 7674              	.LVL880:
 7675 4350 44309DE5 		ldr	r3, [sp, #68]
 7676 4354 6BFFFFEA 		b	.L629
 7677              	.L942:
4734:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 7678              		.loc 1 4734 0
 7679 4358 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 7680              	.LVL881:
4735:../uvc.c      ****                 {
 7681              		.loc 1 4735 0
 7682 435c 000050E3 		cmp	r0, #0
4737:../uvc.c      ****                 }
 7683              		.loc 1 4737 0
 7684 4360 0130A013 		movne	r3, #1
4734:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 7685              		.loc 1 4734 0
 7686 4364 4800CBE5 		strb	r0, [fp, #72]
4737:../uvc.c      ****                 }
 7687              		.loc 1 4737 0
 7688 4368 8C308B15 		strne	r3, [fp, #140]
 7689 436c 62FFFFEA 		b	.L627
 7690              	.L883:
4786:../uvc.c      ****                 }
 7691              		.loc 1 4786 0
 7692 4370 31EFFFEB 		bl	UVCHandleVideoStreamingRqts
 7693              	.LVL882:
 7694 4374 44309DE5 		ldr	r3, [sp, #68]
 7695 4378 8EFFFFEA 		b	.L882
 7696              	.L948:
4882:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 7697              		.loc 1 4882 0
 7698 437c 002096E5 		ldr	r2, [r6]
 7699 4380 0210A0E3 		mov	r1, #2
 7700 4384 0010C2E5 		strb	r1, [r2]
4883:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 7701              		.loc 1 4883 0
 7702 4388 002096E5 		ldr	r2, [r6]
 7703 438c 0140A0E3 		mov	r4, #1
 7704 4390 0140C2E5 		strb	r4, [r2, #1]
4884:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 7705              		.loc 1 4884 0
 7706 4394 001096E5 		ldr	r1, [r6]
4888:../uvc.c      **** 					interStabuf.status = 0;
 7707              		.loc 1 4888 0
 7708 4398 012BA0E3 		mov	r2, #1024
4884:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 7709              		.loc 1 4884 0
 7710 439c 0230C1E5 		strb	r3, [r1, #2]
4885:../uvc.c      **** 
 7711              		.loc 1 4885 0
 7712 43a0 001096E5 		ldr	r1, [r6]
4891:../uvc.c      **** 
 7713              		.loc 1 4891 0
 7714 43a4 0450A0E3 		mov	r5, #4
4885:../uvc.c      **** 
 7715              		.loc 1 4885 0
 7716 43a8 0340C1E5 		strb	r4, [r1, #3]
4887:../uvc.c      **** 					interStabuf.size   = 1024;
 7717              		.loc 1 4887 0
 7718 43ac 001096E5 		ldr	r1, [r6]
4894:../uvc.c      **** 
 7719              		.loc 1 4894 0
 7720 43b0 FC0C9FE5 		ldr	r0, .L981+36
4887:../uvc.c      **** 					interStabuf.size   = 1024;
 7721              		.loc 1 4887 0
 7722 43b4 4C108DE5 		str	r1, [sp, #76]
4894:../uvc.c      **** 
 7723              		.loc 1 4894 0
 7724 43b8 0010E0E3 		mvn	r1, #0
4889:../uvc.c      **** 
 7725              		.loc 1 4889 0
 7726 43bc B435CDE1 		strh	r3, [sp, #84]	@ movhi
4888:../uvc.c      **** 					interStabuf.status = 0;
 7727              		.loc 1 4888 0
 7728 43c0 B225CDE1 		strh	r2, [sp, #82]	@ movhi
4891:../uvc.c      **** 
 7729              		.loc 1 4891 0
 7730 43c4 B055CDE1 		strh	r5, [sp, #80]	@ movhi
4894:../uvc.c      **** 
 7731              		.loc 1 4894 0
 7732 43c8 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 7733              	.LVL883:
4897:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
 7734              		.loc 1 4897 0
 7735 43cc E00C9FE5 		ldr	r0, .L981+36
 7736 43d0 4C108DE2 		add	r1, sp, #76
 7737 43d4 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 7738              	.LVL884:
4899:../uvc.c      **** 					{
 7739              		.loc 1 4899 0
 7740 43d8 000050E3 		cmp	r0, #0
 7741 43dc D201001A 		bne	.L953
4905:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 7742              		.loc 1 4905 0
 7743 43e0 0500A0E3 		mov	r0, #5
 7744              	.LVL885:
 7745 43e4 3010A0E3 		mov	r1, #48
 7746 43e8 0420A0E1 		mov	r2, r4
 7747 43ec FEFFFFEB 		bl	SensorSetControl
 7748              	.LVL886:
4906:../uvc.c      **** 				}
 7749              		.loc 1 4906 0
 7750 43f0 9CEC9FE5 		ldr	lr, .L981+4
 7751 43f4 9247CEE5 		strb	r4, [lr, #1938]
 7752 43f8 78FFFFEA 		b	.L625
 7753              	.L947:
4855:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 7754              		.loc 1 4855 0
 7755 43fc 003096E5 		ldr	r3, [r6]
 7756 4400 0220A0E3 		mov	r2, #2
 7757 4404 0020C3E5 		strb	r2, [r3]
4856:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 7758              		.loc 1 4856 0
 7759 4408 003096E5 		ldr	r3, [r6]
 7760 440c 0140A0E3 		mov	r4, #1
 7761 4410 0140C3E5 		strb	r4, [r3, #1]
4857:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 7762              		.loc 1 4857 0
 7763 4414 002096E5 		ldr	r2, [r6]
 7764 4418 0030A0E3 		mov	r3, #0
 7765 441c 0230C2E5 		strb	r3, [r2, #2]
4858:../uvc.c      **** 
 7766              		.loc 1 4858 0
 7767 4420 001096E5 		ldr	r1, [r6]
4864:../uvc.c      **** 
 7768              		.loc 1 4864 0
 7769 4424 04C0A0E3 		mov	ip, #4
4858:../uvc.c      **** 
 7770              		.loc 1 4858 0
 7771 4428 0330C1E5 		strb	r3, [r1, #3]
4860:../uvc.c      **** 					interStabuf.size   = 1024;
 7772              		.loc 1 4860 0
 7773 442c 001096E5 		ldr	r1, [r6]
4861:../uvc.c      **** 					interStabuf.status = 0;
 7774              		.loc 1 4861 0
 7775 4430 012BA0E3 		mov	r2, #1024
4860:../uvc.c      **** 					interStabuf.size   = 1024;
 7776              		.loc 1 4860 0
 7777 4434 4C108DE5 		str	r1, [sp, #76]
4867:../uvc.c      **** 
 7778              		.loc 1 4867 0
 7779 4438 740C9FE5 		ldr	r0, .L981+36
 7780 443c 0010E0E3 		mvn	r1, #0
4861:../uvc.c      **** 					interStabuf.status = 0;
 7781              		.loc 1 4861 0
 7782 4440 B225CDE1 		strh	r2, [sp, #82]	@ movhi
4864:../uvc.c      **** 
 7783              		.loc 1 4864 0
 7784 4444 B0C5CDE1 		strh	ip, [sp, #80]	@ movhi
4867:../uvc.c      **** 
 7785              		.loc 1 4867 0
 7786 4448 1CC08DE5 		str	ip, [sp, #28]
4862:../uvc.c      **** 
 7787              		.loc 1 4862 0
 7788 444c B435CDE1 		strh	r3, [sp, #84]	@ movhi
4867:../uvc.c      **** 
 7789              		.loc 1 4867 0
 7790 4450 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 7791              	.LVL887:
4870:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
 7792              		.loc 1 4870 0
 7793 4454 580C9FE5 		ldr	r0, .L981+36
 7794 4458 4C108DE2 		add	r1, sp, #76
 7795 445c FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 7796              	.LVL888:
4872:../uvc.c      **** 					{
 7797              		.loc 1 4872 0
 7798 4460 1CC09DE5 		ldr	ip, [sp, #28]
 7799 4464 002050E2 		subs	r2, r0, #0
 7800 4468 9703001A 		bne	.L954
4877:../uvc.c      **** 
 7801              		.loc 1 4877 0
 7802 446c 0500A0E3 		mov	r0, #5
 7803              	.LVL889:
 7804 4470 3010A0E3 		mov	r1, #48
 7805 4474 FEFFFFEB 		bl	SensorSetControl
 7806              	.LVL890:
4879:../uvc.c      **** 				}else if(!snapButFlag){
 7807              		.loc 1 4879 0
 7808 4478 14CC9FE5 		ldr	ip, .L981+4
 7809 447c 9247CCE5 		strb	r4, [ip, #1938]
 7810 4480 56FFFFEA 		b	.L625
 7811              	.L778:
 7812              	.LBB386:
 7813              	.LBB219:
4213:../uvc.c      ****     {
 7814              		.loc 1 4213 0
 7815 4484 150C53E3 		cmp	r3, #5376
 7816 4488 4403000A 		beq	.L794
 7817 448c 2400008A 		bhi	.L795
 7818 4490 110C53E3 		cmp	r3, #4352
 7819 4494 4F03000A 		beq	.L796
 7820 4498 CA00009A 		bls	.L955
 7821 449c 130C53E3 		cmp	r3, #4864
 7822 44a0 4803000A 		beq	.L800
 7823 44a4 050B53E3 		cmp	r3, #5120
 7824 44a8 A801000A 		beq	.L801
 7825 44ac 120C53E3 		cmp	r3, #4608
 7826 44b0 31FFFF1A 		bne	.L631
 7827              	.LVL891:
4290:../uvc.c      ****     		break;
 7828              		.loc 1 4290 0
 7829 44b4 2500A0E3 		mov	r0, #37
 7830 44b8 FEFFFFEB 		bl	ControlHandle
 7831              	.LVL892:
 7832 44bc 44309DE5 		ldr	r3, [sp, #68]
 7833 44c0 32FFFFEA 		b	.L630
 7834              	.L639:
 7835              	.LBE219:
 7836              	.LBE386:
 7837              	.LBB387:
 7838              	.LBB378:
3913:../uvc.c      ****     {
 7839              		.loc 1 3913 0
 7840 44c4 0A0C52E3 		cmp	r2, #2560
 7841 44c8 6800000A 		beq	.L645
 7842 44cc 3A00009A 		bls	.L956
 7843 44d0 0D0C52E3 		cmp	r2, #3328
 7844 44d4 6500000A 		beq	.L645
 7845 44d8 0E0C52E3 		cmp	r2, #3584
 7846 44dc 6700000A 		beq	.L649
 7847 44e0 030B52E3 		cmp	r2, #3072
 7848 44e4 1FFFFF1A 		bne	.L668
 7849              	.LVL893:
3954:../uvc.c      ****     		break;
 7850              		.loc 1 3954 0
 7851 44e8 0B00A0E3 		mov	r0, #11
 7852 44ec FEFFFFEB 		bl	ControlHandle
 7853              	.LVL894:
 7854 44f0 44309DE5 		ldr	r3, [sp, #68]
 7855 44f4 25FFFFEA 		b	.L630
 7856              	.L944:
 7857              	.LBE378:
 7858              	.LBE387:
 7859              	.LBB388:
 7860              	.LBB359:
3988:../uvc.c      ****     {
 7861              		.loc 1 3988 0
 7862 44f8 030C52E3 		cmp	r2, #768
 7863 44fc 0301000A 		beq	.L671
 7864 4500 3A00008A 		bhi	.L672
 7865 4504 010C52E3 		cmp	r2, #256
 7866 4508 E400000A 		beq	.L673
 7867 450c 020C52E3 		cmp	r2, #512
 7868 4510 14FFFF1A 		bne	.L668
 7869              	.LVL895:
3996:../uvc.c      ****     		break;
 7870              		.loc 1 3996 0
 7871 4514 0100A0E3 		mov	r0, #1
 7872 4518 FEFFFFEB 		bl	CTControlHandle
 7873              	.LVL896:
 7874 451c 44309DE5 		ldr	r3, [sp, #68]
 7875 4520 1AFFFFEA 		b	.L630
 7876              	.L795:
 7877              	.LBE359:
 7878              	.LBE388:
 7879              	.LBB389:
 7880              	.LBB220:
4213:../uvc.c      ****     {
 7881              		.loc 1 4213 0
 7882 4524 060B53E3 		cmp	r3, #6144
 7883 4528 3C03000A 		beq	.L803
 7884 452c 6F00009A 		bls	.L957
 7885 4530 1B0C53E3 		cmp	r3, #6912
 7886 4534 2F03000A 		beq	.L807
 7887 4538 070B53E3 		cmp	r3, #7168
 7888 453c D201000A 		beq	.L808
 7889 4540 1A0C53E3 		cmp	r3, #6656
 7890 4544 0CFFFF1A 		bne	.L631
4323:../uvc.c      **** 			CyU3PDebugPrint (4, "The 2DNR start/end command 0x%x 0x%x\r\n", wValue, bRequest);
 7891              		.loc 1 4323 0
 7892 4548 2D00A0E3 		mov	r0, #45
 7893 454c FEFFFFEB 		bl	ControlHandle
 7894              	.LVL897:
4324:../uvc.c      ****     		break;
 7895              		.loc 1 4324 0
 7896 4550 803B9FE5 		ldr	r3, .L981+72
 7897 4554 B020D4E1 		ldrh	r2, [r4]
 7898 4558 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 7899 455c 0400A0E3 		mov	r0, #4
 7900 4560 501B9FE5 		ldr	r1, .L981+40
 7901 4564 FEFFFFEB 		bl	CyU3PDebugPrint
 7902              	.LVL898:
 7903 4568 44309DE5 		ldr	r3, [sp, #68]
 7904 456c 07FFFFEA 		b	.L630
 7905              	.L951:
4213:../uvc.c      ****     {
 7906              		.loc 1 4213 0
 7907 4570 030C53E3 		cmp	r3, #768
 7908 4574 1B03000A 		beq	.L781
 7909 4578 5400008A 		bhi	.L782
 7910 457c 010C53E3 		cmp	r3, #256
 7911 4580 BD01000A 		beq	.L783
 7912 4584 020C53E3 		cmp	r3, #512
 7913 4588 FBFEFF1A 		bne	.L631
 7914              	.LVL899:
4221:../uvc.c      ****     		break;
 7915              		.loc 1 4221 0
 7916 458c 1100A0E3 		mov	r0, #17
 7917 4590 FEFFFFEB 		bl	ControlHandle
 7918              	.LVL900:
 7919 4594 44309DE5 		ldr	r3, [sp, #68]
 7920 4598 FCFEFFEA 		b	.L630
 7921              	.L641:
 7922              	.LBE220:
 7923              	.LBE389:
 7924              	.LBB390:
 7925              	.LBB379:
3913:../uvc.c      ****     {
 7926              		.loc 1 3913 0
 7927 459c 010B52E3 		cmp	r2, #1024
 7928 45a0 FAFEFF0A 		beq	.L630
 7929 45a4 050C52E3 		cmp	r2, #1280
 7930 45a8 EEFEFF1A 		bne	.L668
 7931              	.LVL901:
3932:../uvc.c      ****       		break;
 7932              		.loc 1 3932 0
 7933 45ac 0400A0E3 		mov	r0, #4
 7934 45b0 FEFFFFEB 		bl	ControlHandle
 7935              	.LVL902:
 7936 45b4 44309DE5 		ldr	r3, [sp, #68]
 7937 45b8 F4FEFFEA 		b	.L630
 7938              	.L956:
3913:../uvc.c      ****     {
 7939              		.loc 1 3913 0
 7940 45bc 070C52E3 		cmp	r2, #1792
 7941 45c0 3A00000A 		beq	.L647
 7942 45c4 020B52E3 		cmp	r2, #2048
 7943 45c8 E6FEFF1A 		bne	.L668
 7944              	.LVL903:
3944:../uvc.c      ****           		break;
 7945              		.loc 1 3944 0
 7946 45cc 0700A0E3 		mov	r0, #7
 7947 45d0 FEFFFFEB 		bl	ControlHandle
 7948              	.LVL904:
 7949 45d4 44309DE5 		ldr	r3, [sp, #68]
 7950 45d8 ECFEFFEA 		b	.L630
 7951              	.L945:
 7952              	.LBE379:
 7953              	.LBE390:
 7954              	.LBB391:
 7955              	.LBB360:
3988:../uvc.c      ****     {
 7956              		.loc 1 3988 0
 7957 45dc 070C52E3 		cmp	r2, #1792
 7958 45e0 E500000A 		beq	.L679
 7959 45e4 020B52E3 		cmp	r2, #2048
 7960 45e8 E8FEFF0A 		beq	.L630
 7961 45ec DDFEFFEA 		b	.L668
 7962              	.L672:
 7963 45f0 010B52E3 		cmp	r2, #1024
 7964 45f4 1C01000A 		beq	.L675
 7965 45f8 050C52E3 		cmp	r2, #1280
 7966 45fc D9FEFF1A 		bne	.L668
 7967              	.LVL905:
 7968              	.LBB231:
 7969              	.LBB232:
2295:../uvc.c      **** 
 7970              		.loc 1 2295 0
 7971 4600 D04A9FE5 		ldr	r4, .L981+72
2290:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 7972              		.loc 1 2290 0
 7973 4604 3A56DAE5 		ldrb	r5, [r10, #1594]	@ zero_extendqisi2
 7974              	.LVL906:
2295:../uvc.c      **** 
 7975              		.loc 1 2295 0
 7976 4608 24408DE5 		str	r4, [sp, #36]
 7977 460c 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 7978              	.LVL907:
2297:../uvc.c      **** 		 {
 7979              		.loc 1 2297 0
 7980 4610 830054E3 		cmp	r4, #131
 7981 4614 0105000A 		beq	.L706
 7982 4618 E301009A 		bls	.L958
 7983 461c 850054E3 		cmp	r4, #133
 7984 4620 B902000A 		beq	.L768
 7985 4624 1D05003A 		bcc	.L712
 7986 4628 860054E3 		cmp	r4, #134
 7987 462c 5A03000A 		beq	.L713
 7988 4630 870054E3 		cmp	r4, #135
2359:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 7989              		.loc 1 2359 0
 7990 4634 4316DA05 		ldreqb	r1, [r10, #1603]	@ zero_extendqisi2
2360:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7991              		.loc 1 2360 0
 7992 4638 4426DA05 		ldreqb	r2, [r10, #1604]	@ zero_extendqisi2
2297:../uvc.c      **** 		 {
 7993              		.loc 1 2297 0
 7994 463c C400000A 		beq	.L931
 7995              	.L705:
2504:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7996              		.loc 1 2504 0
 7997 4640 0000A0E3 		mov	r0, #0
 7998 4644 0020A0E1 		mov	r2, r0
 7999 4648 0110A0E3 		mov	r1, #1
 8000 464c FEFFFFEB 		bl	CyU3PUsbStall
 8001              	.LVL908:
2505:../uvc.c      **** 			  break;
 8002              		.loc 1 2505 0
 8003 4650 24C09DE5 		ldr	ip, [sp, #36]
 8004 4654 0400A0E3 		mov	r0, #4
 8005 4658 0020A0E1 		mov	r2, r0
 8006 465c 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 8007 4660 881A9FE5 		ldr	r1, .L981+96
 8008 4664 FEFFFFEB 		bl	CyU3PDebugPrint
 8009              	.LVL909:
2291:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8010              		.loc 1 2291 0
 8011 4668 FF20A0E3 		mov	r2, #255
 8012              	.LVL910:
 8013 466c AD0200EA 		b	.L772
 8014              	.LVL911:
 8015              	.L645:
 8016              	.LBE232:
 8017              	.LBE231:
 8018              	.LBE360:
 8019              	.LBE391:
 8020              	.LBB392:
 8021              	.LBB380:
3950:../uvc.c      ****     		break;
 8022              		.loc 1 3950 0
 8023 4670 0900A0E3 		mov	r0, #9
 8024 4674 FEFFFFEB 		bl	ControlHandle
 8025              	.LVL912:
 8026 4678 44309DE5 		ldr	r3, [sp, #68]
 8027 467c C3FEFFEA 		b	.L630
 8028              	.L649:
 8029              	.LVL913:
3958:../uvc.c      ****     		break;
 8030              		.loc 1 3958 0
 8031 4680 0E00A0E3 		mov	r0, #14
 8032 4684 FEFFFFEB 		bl	ControlHandle
 8033              	.LVL914:
 8034 4688 44309DE5 		ldr	r3, [sp, #68]
 8035 468c BFFEFFEA 		b	.L630
 8036              	.L642:
 8037              	.LVL915:
3917:../uvc.c      ****     		break;
 8038              		.loc 1 3917 0
 8039 4690 0000A0E3 		mov	r0, #0
 8040 4694 FEFFFFEB 		bl	ControlHandle
 8041              	.LVL916:
 8042 4698 44309DE5 		ldr	r3, [sp, #68]
 8043 469c BBFEFFEA 		b	.L630
 8044              	.L640:
 8045              	.LVL917:
3925:../uvc.c      **** 			break;
 8046              		.loc 1 3925 0
 8047 46a0 0200A0E3 		mov	r0, #2
 8048 46a4 FEFFFFEB 		bl	ControlHandle
 8049              	.LVL918:
 8050 46a8 44309DE5 		ldr	r3, [sp, #68]
 8051 46ac B7FEFFEA 		b	.L630
 8052              	.L647:
 8053              	.LVL919:
3940:../uvc.c      ****           		break;
 8054              		.loc 1 3940 0
 8055 46b0 0600A0E3 		mov	r0, #6
 8056 46b4 FEFFFFEB 		bl	ControlHandle
 8057              	.LVL920:
 8058 46b8 44309DE5 		ldr	r3, [sp, #68]
 8059 46bc B3FEFFEA 		b	.L630
 8060              	.L638:
 8061              	.LVL921:
3936:../uvc.c      ****      		break;
 8062              		.loc 1 3936 0
 8063 46c0 0500A0E3 		mov	r0, #5
 8064 46c4 FEFFFFEB 		bl	ControlHandle
 8065              	.LVL922:
 8066 46c8 44309DE5 		ldr	r3, [sp, #68]
 8067 46cc AFFEFFEA 		b	.L630
 8068              	.L782:
 8069              	.LBE380:
 8070              	.LBE392:
 8071              	.LBB393:
 8072              	.LBB221:
4213:../uvc.c      ****     {
 8073              		.loc 1 4213 0
 8074 46d0 010B53E3 		cmp	r3, #1024
 8075 46d4 3501000A 		beq	.L785
 8076 46d8 050C53E3 		cmp	r3, #1280
 8077 46dc A6FEFF1A 		bne	.L631
 8078              	.LVL923:
4233:../uvc.c      ****     		break;
 8079              		.loc 1 4233 0
 8080 46e0 1400A0E3 		mov	r0, #20
 8081 46e4 FEFFFFEB 		bl	ControlHandle
 8082              	.LVL924:
 8083 46e8 44309DE5 		ldr	r3, [sp, #68]
 8084 46ec A7FEFFEA 		b	.L630
 8085              	.L957:
4213:../uvc.c      ****     {
 8086              		.loc 1 4213 0
 8087 46f0 160C53E3 		cmp	r3, #5632
 8088 46f4 2301000A 		beq	.L805
 8089 46f8 170C53E3 		cmp	r3, #5888
 8090 46fc 9EFEFF1A 		bne	.L631
 8091              	.LVL925:
 8092              	.LBB156:
 8093              	.LBB157:
1359:../uvc.c      ****     /*
 8094              		.loc 1 1359 0
 8095 4700 D0499FE5 		ldr	r4, .L981+72
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8096              		.loc 1 1341 0
 8097 4704 6C17DAE5 		ldrb	r1, [r10, #1900]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 8098              		.loc 1 1359 0
 8099 4708 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
 8100 470c 24408DE5 		str	r4, [sp, #36]
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8101              		.loc 1 1342 0
 8102 4710 6D47DAE5 		ldrb	r4, [r10, #1901]	@ zero_extendqisi2
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8103              		.loc 1 1343 0
 8104 4714 7B27DAE5 		ldrb	r2, [r10, #1915]	@ zero_extendqisi2
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 8105              		.loc 1 1344 0
 8106 4718 6E37DAE5 		ldrb	r3, [r10, #1902]	@ zero_extendqisi2
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8107              		.loc 1 1341 0
 8108 471c FF1001E2 		and	r1, r1, #255
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8109              		.loc 1 1343 0
 8110 4720 FF2002E2 		and	r2, r2, #255
1367:../uvc.c      **** 		 {
 8111              		.loc 1 1367 0
 8112 4724 83005CE3 		cmp	ip, #131
1359:../uvc.c      ****     /*
 8113              		.loc 1 1359 0
 8114 4728 2CC08DE5 		str	ip, [sp, #44]
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8115              		.loc 1 1341 0
 8116 472c 34108DE5 		str	r1, [sp, #52]
 8117              	.LVL926:
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8118              		.loc 1 1342 0
 8119 4730 FF4004E2 		and	r4, r4, #255
 8120              	.LVL927:
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8121              		.loc 1 1343 0
 8122 4734 30208DE5 		str	r2, [sp, #48]
 8123              	.LVL928:
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 8124              		.loc 1 1344 0
 8125 4738 FF3003E2 		and	r3, r3, #255
 8126              	.LVL929:
1367:../uvc.c      **** 		 {
 8127              		.loc 1 1367 0
 8128 473c 2D05000A 		beq	.L835
 8129 4740 EE03009A 		bls	.L959
 8130 4744 2C409DE5 		ldr	r4, [sp, #44]
 8131              	.LVL930:
 8132 4748 850054E3 		cmp	r4, #133
 8133 474c 6E03000A 		beq	.L840
 8134 4750 4205003A 		bcc	.L841
 8135 4754 860054E3 		cmp	r4, #134
 8136 4758 3205000A 		beq	.L842
 8137 475c 870054E3 		cmp	r4, #135
 8138 4760 AC05001A 		bne	.L834
1789:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8139              		.loc 1 1789 0
 8140 4764 020053E3 		cmp	r3, #2
1790:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8141              		.loc 1 1790 0
 8142 4768 77C7DAE5 		ldrb	ip, [r10, #1911]	@ zero_extendqisi2
1814:../uvc.c      **** 		 	 if(Len == 2){
 8143              		.loc 1 1814 0
 8144 476c 0300A0E1 		mov	r0, r3
1791:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 8145              		.loc 1 1791 0
 8146 4770 7827DAE5 		ldrb	r2, [r10, #1912]	@ zero_extendqisi2
1789:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8147              		.loc 1 1789 0
 8148 4774 F705000A 		beq	.L941
 8149              	.L849:
1796:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8150              		.loc 1 1796 0
 8151 4778 0030A0E3 		mov	r3, #0
 8152              	.LVL931:
1814:../uvc.c      **** 		 	 if(Len == 2){
 8153              		.loc 1 1814 0
 8154 477c 78199FE5 		ldr	r1, .L981+108
1795:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8155              		.loc 1 1795 0
 8156 4780 28C0C7E5 		strb	ip, [r7, #40]
1797:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8157              		.loc 1 1797 0
 8158 4784 2A20C7E5 		strb	r2, [r7, #42]
1796:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8159              		.loc 1 1796 0
 8160 4788 2930C7E5 		strb	r3, [r7, #41]
1798:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 8161              		.loc 1 1798 0
 8162 478c 2B30C7E5 		strb	r3, [r7, #43]
1820:../uvc.c      **** 		 	 }
 8163              		.loc 1 1820 0
 8164 4790 28308DE5 		str	r3, [sp, #40]
1814:../uvc.c      **** 		 	 if(Len == 2){
 8165              		.loc 1 1814 0
 8166 4794 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8167              	.LVL932:
1820:../uvc.c      **** 		 	 }
 8168              		.loc 1 1820 0
 8169 4798 00C0A0E3 		mov	ip, #0
1819:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 8170              		.loc 1 1819 0
 8171 479c 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 8172              	.LVL933:
1820:../uvc.c      **** 		 	 }
 8173              		.loc 1 1820 0
 8174 47a0 2A40D7E5 		ldrb	r4, [r7, #42]	@ zero_extendqisi2
 8175              	.LVL934:
 8176 47a4 620300EA 		b	.L844
 8177              	.LVL935:
 8178              	.L952:
 8179              	.LBE157:
 8180              	.LBE156:
4213:../uvc.c      ****     {
 8181              		.loc 1 4213 0
 8182 47a8 070C53E3 		cmp	r3, #1792
 8183 47ac 0701000A 		beq	.L789
 8184 47b0 020B53E3 		cmp	r3, #2048
 8185 47b4 70FEFF1A 		bne	.L631
 8186              	.LVL936:
4245:../uvc.c      ****     		break;
 8187              		.loc 1 4245 0
 8188 47b8 1700A0E3 		mov	r0, #23
 8189 47bc FEFFFFEB 		bl	ControlHandle
 8190              	.LVL937:
 8191 47c0 44309DE5 		ldr	r3, [sp, #68]
 8192 47c4 71FEFFEA 		b	.L630
 8193              	.L955:
4213:../uvc.c      ****     {
 8194              		.loc 1 4213 0
 8195 47c8 0F0C53E3 		cmp	r3, #3840
 8196 47cc FB00000A 		beq	.L798
 8197 47d0 010A53E3 		cmp	r3, #4096
 8198 47d4 68FEFF1A 		bne	.L631
 8199              	.LVL938:
4282:../uvc.c      ****     		break;
 8200              		.loc 1 4282 0
 8201 47d8 1F00A0E3 		mov	r0, #31
 8202 47dc FEFFFFEB 		bl	ControlHandle
 8203              	.LVL939:
 8204 47e0 44309DE5 		ldr	r3, [sp, #68]
 8205 47e4 69FEFFEA 		b	.L630
 8206              	.L669:
 8207              	.LVL940:
 8208              	.LBE221:
 8209              	.LBE393:
 8210              	.LBB394:
 8211              	.LBB361:
 8212              	.LBB239:
 8213              	.LBB240:
2295:../uvc.c      **** 
 8214              		.loc 1 2295 0
 8215 47e8 E8489FE5 		ldr	r4, .L981+72
2290:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8216              		.loc 1 2290 0
 8217 47ec 5256DAE5 		ldrb	r5, [r10, #1618]	@ zero_extendqisi2
 8218              	.LVL941:
2295:../uvc.c      **** 
 8219              		.loc 1 2295 0
 8220 47f0 24408DE5 		str	r4, [sp, #36]
 8221 47f4 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 8222              	.LVL942:
2297:../uvc.c      **** 		 {
 8223              		.loc 1 2297 0
 8224 47f8 830054E3 		cmp	r4, #131
 8225 47fc 9F04000A 		beq	.L717
 8226 4800 C901009A 		bls	.L960
 8227 4804 850054E3 		cmp	r4, #133
 8228 4808 3F02000A 		beq	.L768
 8229 480c D704003A 		bcc	.L723
 8230 4810 860054E3 		cmp	r4, #134
 8231 4814 FC02000A 		beq	.L724
 8232 4818 870054E3 		cmp	r4, #135
 8233 481c BC04001A 		bne	.L716
2359:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8234              		.loc 1 2359 0
 8235 4820 6CE89FE5 		ldr	lr, .L981+4
 8236 4824 5B16DEE5 		ldrb	r1, [lr, #1627]	@ zero_extendqisi2
2360:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8237              		.loc 1 2360 0
 8238 4828 5C26DEE5 		ldrb	r2, [lr, #1628]	@ zero_extendqisi2
 8239 482c 480000EA 		b	.L931
 8240              	.LVL943:
 8241              	.L680:
 8242              	.LBE240:
 8243              	.LBE239:
 8244              	.LBB248:
 8245              	.LBB249:
2295:../uvc.c      **** 
 8246              		.loc 1 2295 0
 8247 4830 A0489FE5 		ldr	r4, .L981+72
2290:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8248              		.loc 1 2290 0
 8249 4834 B256DAE5 		ldrb	r5, [r10, #1714]	@ zero_extendqisi2
 8250              	.LVL944:
2295:../uvc.c      **** 
 8251              		.loc 1 2295 0
 8252 4838 24408DE5 		str	r4, [sp, #36]
 8253 483c 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 8254              	.LVL945:
2297:../uvc.c      **** 		 {
 8255              		.loc 1 2297 0
 8256 4840 830054E3 		cmp	r4, #131
 8257 4844 7904000A 		beq	.L763
 8258 4848 6A01009A 		bls	.L961
 8259 484c 850054E3 		cmp	r4, #133
 8260 4850 2D02000A 		beq	.L768
 8261 4854 8D04003A 		bcc	.L769
 8262 4858 860054E3 		cmp	r4, #134
 8263 485c CC02000A 		beq	.L770
 8264 4860 870054E3 		cmp	r4, #135
2359:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8265              		.loc 1 2359 0
 8266 4864 BB16DA05 		ldreqb	r1, [r10, #1723]	@ zero_extendqisi2
2360:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8267              		.loc 1 2360 0
 8268 4868 BC26DA05 		ldreqb	r2, [r10, #1724]	@ zero_extendqisi2
2297:../uvc.c      **** 		 {
 8269              		.loc 1 2297 0
 8270 486c 3800000A 		beq	.L931
 8271              	.L762:
2504:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8272              		.loc 1 2504 0
 8273 4870 0000A0E3 		mov	r0, #0
 8274 4874 0020A0E1 		mov	r2, r0
 8275 4878 0110A0E3 		mov	r1, #1
 8276 487c FEFFFFEB 		bl	CyU3PUsbStall
 8277              	.LVL946:
2505:../uvc.c      **** 			  break;
 8278              		.loc 1 2505 0
 8279 4880 24C09DE5 		ldr	ip, [sp, #36]
 8280 4884 0920A0E3 		mov	r2, #9
 8281 4888 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 8282 488c 0400A0E3 		mov	r0, #4
 8283 4890 58189FE5 		ldr	r1, .L981+96
 8284 4894 FEFFFFEB 		bl	CyU3PDebugPrint
 8285              	.LVL947:
2291:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8286              		.loc 1 2291 0
 8287 4898 FF20A0E3 		mov	r2, #255
 8288 489c 210200EA 		b	.L772
 8289              	.LVL948:
 8290              	.L673:
 8291              	.LBE249:
 8292              	.LBE248:
 8293              	.LBB260:
 8294              	.LBB261:
2295:../uvc.c      **** 
 8295              		.loc 1 2295 0
 8296 48a0 30489FE5 		ldr	r4, .L981+72
2290:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8297              		.loc 1 2290 0
 8298 48a4 DA55DAE5 		ldrb	r5, [r10, #1498]	@ zero_extendqisi2
 8299              	.LVL949:
2295:../uvc.c      **** 
 8300              		.loc 1 2295 0
 8301 48a8 24408DE5 		str	r4, [sp, #36]
 8302 48ac 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 8303              	.LVL950:
2297:../uvc.c      **** 		 {
 8304              		.loc 1 2297 0
 8305 48b0 830054E3 		cmp	r4, #131
 8306 48b4 6504000A 		beq	.L684
 8307 48b8 8801009A 		bls	.L962
 8308 48bc 850054E3 		cmp	r4, #133
 8309 48c0 1102000A 		beq	.L768
 8310 48c4 5104003A 		bcc	.L690
 8311 48c8 860054E3 		cmp	r4, #134
 8312 48cc DE02000A 		beq	.L691
 8313 48d0 870054E3 		cmp	r4, #135
2359:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8314              		.loc 1 2359 0
 8315 48d4 E315DA05 		ldreqb	r1, [r10, #1507]	@ zero_extendqisi2
2360:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8316              		.loc 1 2360 0
 8317 48d8 E425DA05 		ldreqb	r2, [r10, #1508]	@ zero_extendqisi2
2297:../uvc.c      **** 		 {
 8318              		.loc 1 2297 0
 8319 48dc 1C00000A 		beq	.L931
 8320              	.L683:
2504:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8321              		.loc 1 2504 0
 8322 48e0 0000A0E3 		mov	r0, #0
 8323 48e4 0020A0E1 		mov	r2, r0
 8324 48e8 0110A0E3 		mov	r1, #1
 8325 48ec FEFFFFEB 		bl	CyU3PUsbStall
 8326              	.LVL951:
2505:../uvc.c      **** 			  break;
 8327              		.loc 1 2505 0
 8328 48f0 24C09DE5 		ldr	ip, [sp, #36]
 8329 48f4 0020A0E3 		mov	r2, #0
 8330 48f8 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 8331 48fc 0400A0E3 		mov	r0, #4
 8332 4900 E8179FE5 		ldr	r1, .L981+96
 8333 4904 FEFFFFEB 		bl	CyU3PDebugPrint
 8334              	.LVL952:
2291:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8335              		.loc 1 2291 0
 8336 4908 FF20A0E3 		mov	r2, #255
 8337              	.LVL953:
 8338 490c 050200EA 		b	.L772
 8339              	.LVL954:
 8340              	.L671:
 8341              	.LBE261:
 8342              	.LBE260:
 8343              	.LBB268:
 8344              	.LBB269:
2295:../uvc.c      **** 
 8345              		.loc 1 2295 0
 8346 4910 C0479FE5 		ldr	r4, .L981+72
2290:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8347              		.loc 1 2290 0
 8348 4914 0A56DAE5 		ldrb	r5, [r10, #1546]	@ zero_extendqisi2
 8349              	.LVL955:
2295:../uvc.c      **** 
 8350              		.loc 1 2295 0
 8351 4918 24408DE5 		str	r4, [sp, #36]
 8352 491c 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 8353              	.LVL956:
2297:../uvc.c      **** 		 {
 8354              		.loc 1 2297 0
 8355 4920 830054E3 		cmp	r4, #131
 8356 4924 4D04000A 		beq	.L695
 8357 4928 5801009A 		bls	.L963
 8358 492c 850054E3 		cmp	r4, #133
 8359 4930 F501000A 		beq	.L768
 8360 4934 8904003A 		bcc	.L701
 8361 4938 860054E3 		cmp	r4, #134
 8362 493c C402000A 		beq	.L702
 8363 4940 870054E3 		cmp	r4, #135
 8364 4944 EF03001A 		bne	.L694
2359:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8365              		.loc 1 2359 0
 8366 4948 44E79FE5 		ldr	lr, .L981+4
 8367 494c 1316DEE5 		ldrb	r1, [lr, #1555]	@ zero_extendqisi2
2360:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8368              		.loc 1 2360 0
 8369 4950 1426DEE5 		ldrb	r2, [lr, #1556]	@ zero_extendqisi2
 8370              	.LVL957:
 8371              	.L931:
 8372              	.LBE269:
 8373              	.LBE268:
 8374              	.LBB277:
 8375              	.LBB250:
2338:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8376              		.loc 1 2338 0
 8377 4954 0030A0E3 		mov	r3, #0
2335:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8378              		.loc 1 2335 0
 8379 4958 2810C7E5 		strb	r1, [r7, #40]
2340:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8380              		.loc 1 2340 0
 8381 495c 0500A0E1 		mov	r0, r5
 8382 4960 94179FE5 		ldr	r1, .L981+108
2336:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8383              		.loc 1 2336 0
 8384 4964 2920C7E5 		strb	r2, [r7, #41]
2338:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8385              		.loc 1 2338 0
 8386 4968 2A30C7E5 		strb	r3, [r7, #42]
2339:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 8387              		.loc 1 2339 0
 8388 496c 2B30C7E5 		strb	r3, [r7, #43]
2340:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8389              		.loc 1 2340 0
 8390 4970 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8391              	.LVL958:
2341:../uvc.c      **** 			  break;
 8392              		.loc 1 2341 0
 8393 4974 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 8394              	.LVL959:
 8395 4978 EA0100EA 		b	.L772
 8396              	.LVL960:
 8397              	.L679:
 8398              	.LBE250:
 8399              	.LBE277:
 8400              	.LBB278:
 8401              	.LBB279:
2295:../uvc.c      **** 
 8402              		.loc 1 2295 0
 8403 497c 54479FE5 		ldr	r4, .L981+72
2290:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8404              		.loc 1 2290 0
 8405 4980 6A56DAE5 		ldrb	r5, [r10, #1642]	@ zero_extendqisi2
 8406              	.LVL961:
2295:../uvc.c      **** 
 8407              		.loc 1 2295 0
 8408 4984 24408DE5 		str	r4, [sp, #36]
 8409 4988 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 8410              	.LVL962:
2297:../uvc.c      **** 		 {
 8411              		.loc 1 2297 0
 8412 498c 830054E3 		cmp	r4, #131
 8413 4990 3604000A 		beq	.L728
 8414 4994 2A01009A 		bls	.L964
 8415 4998 850054E3 		cmp	r4, #133
 8416 499c DA01000A 		beq	.L768
 8417 49a0 6704003A 		bcc	.L734
 8418 49a4 860054E3 		cmp	r4, #134
 8419 49a8 A502000A 		beq	.L735
 8420 49ac 870054E3 		cmp	r4, #135
2359:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8421              		.loc 1 2359 0
 8422 49b0 7316DA05 		ldreqb	r1, [r10, #1651]	@ zero_extendqisi2
2360:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8423              		.loc 1 2360 0
 8424 49b4 7426DA05 		ldreqb	r2, [r10, #1652]	@ zero_extendqisi2
2297:../uvc.c      **** 		 {
 8425              		.loc 1 2297 0
 8426 49b8 E5FFFF0A 		beq	.L931
 8427              	.L727:
2504:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8428              		.loc 1 2504 0
 8429 49bc 0000A0E3 		mov	r0, #0
 8430 49c0 0020A0E1 		mov	r2, r0
 8431 49c4 0110A0E3 		mov	r1, #1
 8432 49c8 FEFFFFEB 		bl	CyU3PUsbStall
 8433              	.LVL963:
2505:../uvc.c      **** 			  break;
 8434              		.loc 1 2505 0
 8435 49cc 24C09DE5 		ldr	ip, [sp, #36]
 8436 49d0 0620A0E3 		mov	r2, #6
 8437 49d4 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 8438 49d8 0400A0E3 		mov	r0, #4
 8439 49dc 0C179FE5 		ldr	r1, .L981+96
 8440 49e0 FEFFFFEB 		bl	CyU3PDebugPrint
 8441              	.LVL964:
2291:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8442              		.loc 1 2291 0
 8443 49e4 FF20A0E3 		mov	r2, #255
 8444              	.LVL965:
 8445 49e8 CE0100EA 		b	.L772
 8446              	.LVL966:
 8447              	.L946:
 8448              	.LBE279:
 8449              	.LBE278:
 8450              	.LBB286:
 8451              	.LBB287:
2295:../uvc.c      **** 
 8452              		.loc 1 2295 0
 8453 49ec E4469FE5 		ldr	r4, .L981+72
2290:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8454              		.loc 1 2290 0
 8455 49f0 9A56DAE5 		ldrb	r5, [r10, #1690]	@ zero_extendqisi2
 8456              	.LVL967:
2295:../uvc.c      **** 
 8457              		.loc 1 2295 0
 8458 49f4 24408DE5 		str	r4, [sp, #36]
 8459 49f8 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 8460              	.LVL968:
2297:../uvc.c      **** 		 {
 8461              		.loc 1 2297 0
 8462 49fc 830054E3 		cmp	r4, #131
 8463 4a00 2904000A 		beq	.L752
 8464 4a04 5C01009A 		bls	.L965
 8465 4a08 850054E3 		cmp	r4, #133
 8466 4a0c BE01000A 		beq	.L768
 8467 4a10 4F04003A 		bcc	.L758
 8468 4a14 860054E3 		cmp	r4, #134
 8469 4a18 5102000A 		beq	.L759
 8470 4a1c 870054E3 		cmp	r4, #135
2359:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8471              		.loc 1 2359 0
 8472 4a20 A316DA05 		ldreqb	r1, [r10, #1699]	@ zero_extendqisi2
2360:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8473              		.loc 1 2360 0
 8474 4a24 A426DA05 		ldreqb	r2, [r10, #1700]	@ zero_extendqisi2
2297:../uvc.c      **** 		 {
 8475              		.loc 1 2297 0
 8476 4a28 C9FFFF0A 		beq	.L931
 8477              	.L751:
2504:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8478              		.loc 1 2504 0
 8479 4a2c 0000A0E3 		mov	r0, #0
 8480 4a30 0020A0E1 		mov	r2, r0
 8481 4a34 0110A0E3 		mov	r1, #1
 8482 4a38 FEFFFFEB 		bl	CyU3PUsbStall
 8483              	.LVL969:
2505:../uvc.c      **** 			  break;
 8484              		.loc 1 2505 0
 8485 4a3c 24C09DE5 		ldr	ip, [sp, #36]
 8486 4a40 0820A0E3 		mov	r2, #8
 8487 4a44 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 8488 4a48 0400A0E3 		mov	r0, #4
 8489 4a4c 9C169FE5 		ldr	r1, .L981+96
 8490 4a50 FEFFFFEB 		bl	CyU3PDebugPrint
 8491              	.LVL970:
2291:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8492              		.loc 1 2291 0
 8493 4a54 FF20A0E3 		mov	r2, #255
 8494              	.LVL971:
 8495 4a58 B20100EA 		b	.L772
 8496              	.LVL972:
 8497              	.L681:
 8498              	.LBE287:
 8499              	.LBE286:
4037:../uvc.c      ****     		break;
 8500              		.loc 1 4037 0
 8501 4a5c 0A00A0E3 		mov	r0, #10
 8502 4a60 FEFFFFEB 		bl	CTControlHandle
 8503              	.LVL973:
 8504 4a64 44309DE5 		ldr	r3, [sp, #68]
 8505 4a68 C8FDFFEA 		b	.L630
 8506              	.L675:
 8507              	.LVL974:
4005:../uvc.c      **** 			break;
 8508              		.loc 1 4005 0
 8509 4a6c 0300A0E3 		mov	r0, #3
 8510 4a70 FEFFFFEB 		bl	CTControlHandle
 8511              	.LVL975:
 8512 4a74 44309DE5 		ldr	r3, [sp, #68]
 8513 4a78 C4FDFFEA 		b	.L630
 8514              	.L677:
 8515              	.LVL976:
 8516              	.LBB294:
 8517              	.LBB295:
2295:../uvc.c      **** 
 8518              		.loc 1 2295 0
 8519 4a7c 54469FE5 		ldr	r4, .L981+72
2287:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 8520              		.loc 1 2287 0
 8521 4a80 8FC6DAE5 		ldrb	ip, [r10, #1679]	@ zero_extendqisi2
 8522              	.LVL977:
2295:../uvc.c      **** 
 8523              		.loc 1 2295 0
 8524 4a84 24408DE5 		str	r4, [sp, #36]
 8525 4a88 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
2288:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 8526              		.loc 1 2288 0
 8527 4a8c 8036DAE5 		ldrb	r3, [r10, #1664]	@ zero_extendqisi2
 8528              	.LVL978:
2297:../uvc.c      **** 		 {
 8529              		.loc 1 2297 0
 8530 4a90 830054E3 		cmp	r4, #131
2290:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8531              		.loc 1 2290 0
 8532 4a94 8256DAE5 		ldrb	r5, [r10, #1666]	@ zero_extendqisi2
 8533              	.LVL979:
2297:../uvc.c      **** 		 {
 8534              		.loc 1 2297 0
 8535 4a98 E803000A 		beq	.L739
 8536 4a9c 4901009A 		bls	.L966
 8537 4aa0 850054E3 		cmp	r4, #133
 8538 4aa4 1004000A 		beq	.L744
 8539 4aa8 0B04003A 		bcc	.L745
 8540 4aac 860054E3 		cmp	r4, #134
 8541 4ab0 5802000A 		beq	.L746
 8542 4ab4 870054E3 		cmp	r4, #135
 8543 4ab8 C003001A 		bne	.L738
2359:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8544              		.loc 1 2359 0
 8545 4abc D0E59FE5 		ldr	lr, .L981+4
 8546 4ac0 8B16DEE5 		ldrb	r1, [lr, #1675]	@ zero_extendqisi2
2360:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8547              		.loc 1 2360 0
 8548 4ac4 8C26DEE5 		ldrb	r2, [lr, #1676]	@ zero_extendqisi2
 8549              	.L929:
2338:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8550              		.loc 1 2338 0
 8551 4ac8 0030A0E3 		mov	r3, #0
2335:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8552              		.loc 1 2335 0
 8553 4acc 2810C7E5 		strb	r1, [r7, #40]
2340:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8554              		.loc 1 2340 0
 8555 4ad0 0500A0E1 		mov	r0, r5
 8556 4ad4 20169FE5 		ldr	r1, .L981+108
2336:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8557              		.loc 1 2336 0
 8558 4ad8 2920C7E5 		strb	r2, [r7, #41]
2338:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8559              		.loc 1 2338 0
 8560 4adc 2A30C7E5 		strb	r3, [r7, #42]
2339:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 8561              		.loc 1 2339 0
 8562 4ae0 2B30C7E5 		strb	r3, [r7, #43]
2340:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8563              		.loc 1 2340 0
 8564 4ae4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8565              	.LVL980:
2341:../uvc.c      **** 			  break;
 8566              		.loc 1 2341 0
 8567 4ae8 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 8568              	.LVL981:
2291:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8569              		.loc 1 2291 0
 8570 4aec FF20A0E3 		mov	r2, #255
 8571 4af0 0230A0E1 		mov	r3, r2
 8572              	.LVL982:
 8573              	.L748:
2510:../uvc.c      **** }
 8574              		.loc 1 2510 0
 8575 4af4 2A10D7E5 		ldrb	r1, [r7, #42]	@ zero_extendqisi2
 8576 4af8 FF00A0E3 		mov	r0, #255
 8577 4afc 00208DE5 		str	r2, [sp]
 8578 4b00 04108DE5 		str	r1, [sp, #4]
 8579 4b04 10108DE5 		str	r1, [sp, #16]
 8580 4b08 0C008DE5 		str	r0, [sp, #12]
 8581 4b0c 08C08DE5 		str	ip, [sp, #8]
 8582 4b10 14508DE5 		str	r5, [sp, #20]
 8583 4b14 0420A0E1 		mov	r2, r4
 8584              	.LVL983:
 8585 4b18 0400A0E3 		mov	r0, #4
 8586 4b1c A8159FE5 		ldr	r1, .L981+60
 8587 4b20 FEFFFFEB 		bl	CyU3PDebugPrint
 8588              	.LVL984:
 8589 4b24 44309DE5 		ldr	r3, [sp, #68]
 8590 4b28 98FDFFEA 		b	.L630
 8591              	.LVL985:
 8592              	.L953:
 8593 4b2c 0030A0E1 		mov	r3, r0
 8594              	.LBE295:
 8595              	.LBE294:
 8596              	.LBE361:
 8597              	.LBE394:
4901:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 8598              		.loc 1 4901 0
 8599 4b30 0320A0E1 		mov	r2, r3
 8600 4b34 0500A0E1 		mov	r0, r5
 8601              	.LVL986:
 8602 4b38 9C159FE5 		ldr	r1, .L981+76
 8603 4b3c 20308DE5 		str	r3, [sp, #32]
 8604 4b40 FEFFFFEB 		bl	CyU3PDebugPrint
 8605              	.LVL987:
4902:../uvc.c      **** 					}
 8606              		.loc 1 4902 0
 8607 4b44 20309DE5 		ldr	r3, [sp, #32]
 8608 4b48 0300A0E1 		mov	r0, r3
 8609 4b4c FEFFFFEB 		bl	CyFxAppErrorHandler
 8610              	.LVL988:
 8611              	.L801:
 8612              	.LBB395:
 8613              	.LBB222:
4298:../uvc.c      **** 			CyU3PDebugPrint (4, "The hyster command 0x%x 0x%x\r\n", wValue, bRequest);
 8614              		.loc 1 4298 0
 8615 4b50 2700A0E3 		mov	r0, #39
 8616 4b54 FEFFFFEB 		bl	ControlHandle
 8617              	.LVL989:
4299:../uvc.c      ****     		break;
 8618              		.loc 1 4299 0
 8619 4b58 78359FE5 		ldr	r3, .L981+72
 8620 4b5c B020D4E1 		ldrh	r2, [r4]
 8621 4b60 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 8622 4b64 0400A0E3 		mov	r0, #4
 8623 4b68 4C159FE5 		ldr	r1, .L981+44
 8624 4b6c FEFFFFEB 		bl	CyU3PDebugPrint
 8625              	.LVL990:
 8626 4b70 44309DE5 		ldr	r3, [sp, #68]
 8627 4b74 85FDFFEA 		b	.L630
 8628              	.L792:
 8629              	.LVL991:
4264:../uvc.c      ****     		break;
 8630              		.loc 1 4264 0
 8631 4b78 1B00A0E3 		mov	r0, #27
 8632 4b7c FEFFFFEB 		bl	ControlHandle
 8633              	.LVL992:
 8634 4b80 44309DE5 		ldr	r3, [sp, #68]
 8635 4b84 81FDFFEA 		b	.L630
 8636              	.L805:
4308:../uvc.c      **** 			CyU3PDebugPrint (4, "The edgeMode command 0x%x 0x%x\r\n", wValue, bRequest);
 8637              		.loc 1 4308 0
 8638 4b88 2900A0E3 		mov	r0, #41
 8639 4b8c FEFFFFEB 		bl	ControlHandle
 8640              	.LVL993:
4309:../uvc.c      ****     		break;
 8641              		.loc 1 4309 0
 8642 4b90 40359FE5 		ldr	r3, .L981+72
 8643 4b94 B020D4E1 		ldrh	r2, [r4]
 8644 4b98 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 8645 4b9c 0400A0E3 		mov	r0, #4
 8646 4ba0 18159FE5 		ldr	r1, .L981+48
 8647 4ba4 FEFFFFEB 		bl	CyU3PDebugPrint
 8648              	.LVL994:
 8649 4ba8 44309DE5 		ldr	r3, [sp, #68]
 8650 4bac 77FDFFEA 		b	.L630
 8651              	.L785:
 8652              	.LVL995:
4229:../uvc.c      ****     		break;
 8653              		.loc 1 4229 0
 8654 4bb0 1300A0E3 		mov	r0, #19
 8655 4bb4 FEFFFFEB 		bl	ControlHandle
 8656              	.LVL996:
 8657 4bb8 44309DE5 		ldr	r3, [sp, #68]
 8658 4bbc 73FDFFEA 		b	.L630
 8659              	.L798:
 8660              	.LVL997:
4278:../uvc.c      ****     		break;
 8661              		.loc 1 4278 0
 8662 4bc0 1E00A0E3 		mov	r0, #30
 8663 4bc4 FEFFFFEB 		bl	ControlHandle
 8664              	.LVL998:
 8665 4bc8 44309DE5 		ldr	r3, [sp, #68]
 8666 4bcc 6FFDFFEA 		b	.L630
 8667              	.L789:
 8668              	.LVL999:
 8669              	.LBB167:
 8670              	.LBB168:
1359:../uvc.c      ****     /*
 8671              		.loc 1 1359 0
 8672 4bd0 00359FE5 		ldr	r3, .L981+72
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8673              		.loc 1 1341 0
 8674 4bd4 5807DAE5 		ldrb	r0, [r10, #1880]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 8675              		.loc 1 1359 0
 8676 4bd8 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8677              		.loc 1 1342 0
 8678 4bdc 5917DAE5 		ldrb	r1, [r10, #1881]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 8679              		.loc 1 1359 0
 8680 4be0 28308DE5 		str	r3, [sp, #40]
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8681              		.loc 1 1343 0
 8682 4be4 6727DAE5 		ldrb	r2, [r10, #1895]	@ zero_extendqisi2
1367:../uvc.c      **** 		 {
 8683              		.loc 1 1367 0
 8684 4be8 28409DE5 		ldr	r4, [sp, #40]
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 8685              		.loc 1 1344 0
 8686 4bec 5A37DAE5 		ldrb	r3, [r10, #1882]	@ zero_extendqisi2
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8687              		.loc 1 1341 0
 8688 4bf0 FF0000E2 		and	r0, r0, #255
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8689              		.loc 1 1342 0
 8690 4bf4 FF1001E2 		and	r1, r1, #255
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8691              		.loc 1 1343 0
 8692 4bf8 FF2002E2 		and	r2, r2, #255
1367:../uvc.c      **** 		 {
 8693              		.loc 1 1367 0
 8694 4bfc 830054E3 		cmp	r4, #131
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8695              		.loc 1 1341 0
 8696 4c00 30008DE5 		str	r0, [sp, #48]
 8697              	.LVL1000:
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8698              		.loc 1 1342 0
 8699 4c04 34108DE5 		str	r1, [sp, #52]
 8700              	.LVL1001:
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8701              		.loc 1 1343 0
 8702 4c08 2C208DE5 		str	r2, [sp, #44]
 8703              	.LVL1002:
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 8704              		.loc 1 1344 0
 8705 4c0c FF3003E2 		and	r3, r3, #255
 8706              	.LVL1003:
1367:../uvc.c      **** 		 {
 8707              		.loc 1 1367 0
 8708 4c10 7604000A 		beq	.L811
 8709 4c14 8902009A 		bls	.L967
 8710 4c18 28C09DE5 		ldr	ip, [sp, #40]
 8711 4c1c 85005CE3 		cmp	ip, #133
 8712 4c20 0E02000A 		beq	.L816
 8713 4c24 B604003A 		bcc	.L817
 8714 4c28 86005CE3 		cmp	ip, #134
 8715 4c2c A604000A 		beq	.L818
 8716 4c30 87005CE3 		cmp	ip, #135
 8717 4c34 3C04001A 		bne	.L810
1789:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8718              		.loc 1 1789 0
 8719 4c38 020053E3 		cmp	r3, #2
1790:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8720              		.loc 1 1790 0
 8721 4c3c 63C7DAE5 		ldrb	ip, [r10, #1891]	@ zero_extendqisi2
1814:../uvc.c      **** 		 	 if(Len == 2){
 8722              		.loc 1 1814 0
 8723 4c40 0300A0E1 		mov	r0, r3
1791:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 8724              		.loc 1 1791 0
 8725 4c44 6427DAE5 		ldrb	r2, [r10, #1892]	@ zero_extendqisi2
1789:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8726              		.loc 1 1789 0
 8727 4c48 1904000A 		beq	.L934
 8728              	.L825:
1796:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8729              		.loc 1 1796 0
 8730 4c4c 0030A0E3 		mov	r3, #0
 8731              	.LVL1004:
1814:../uvc.c      **** 		 	 if(Len == 2){
 8732              		.loc 1 1814 0
 8733 4c50 A4149FE5 		ldr	r1, .L981+108
1795:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8734              		.loc 1 1795 0
 8735 4c54 28C0C7E5 		strb	ip, [r7, #40]
1797:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8736              		.loc 1 1797 0
 8737 4c58 2A20C7E5 		strb	r2, [r7, #42]
1796:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8738              		.loc 1 1796 0
 8739 4c5c 2930C7E5 		strb	r3, [r7, #41]
1798:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 8740              		.loc 1 1798 0
 8741 4c60 2B30C7E5 		strb	r3, [r7, #43]
1820:../uvc.c      **** 		 	 }
 8742              		.loc 1 1820 0
 8743 4c64 0340A0E1 		mov	r4, r3
 8744 4c68 24308DE5 		str	r3, [sp, #36]
1814:../uvc.c      **** 		 	 if(Len == 2){
 8745              		.loc 1 1814 0
 8746 4c6c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8747              	.LVL1005:
1819:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 8748              		.loc 1 1819 0
 8749 4c70 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 8750              	.LVL1006:
1820:../uvc.c      **** 		 	 }
 8751              		.loc 1 1820 0
 8752 4c74 2A50D7E5 		ldrb	r5, [r7, #42]	@ zero_extendqisi2
 8753              	.LVL1007:
 8754 4c78 020200EA 		b	.L820
 8755              	.LVL1008:
 8756              	.L783:
 8757              	.LBE168:
 8758              	.LBE167:
4217:../uvc.c      ****     		break;
 8759              		.loc 1 4217 0
 8760 4c7c 1000A0E3 		mov	r0, #16
 8761 4c80 FEFFFFEB 		bl	ControlHandle
 8762              	.LVL1009:
 8763 4c84 44309DE5 		ldr	r3, [sp, #68]
 8764 4c88 40FDFFEA 		b	.L630
 8765              	.L808:
4333:../uvc.c      **** 			CyU3PDebugPrint (4, "The AGC Max command 0x%x 0x%x\r\n", wValue, bRequest);
 8766              		.loc 1 4333 0
 8767 4c8c 2F00A0E3 		mov	r0, #47
 8768 4c90 FEFFFFEB 		bl	ControlHandle
 8769              	.LVL1010:
4334:../uvc.c      ****     		break;
 8770              		.loc 1 4334 0
 8771 4c94 3C349FE5 		ldr	r3, .L981+72
 8772 4c98 B020D4E1 		ldrh	r2, [r4]
 8773 4c9c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 8774 4ca0 0400A0E3 		mov	r0, #4
 8775 4ca4 18149FE5 		ldr	r1, .L981+52
 8776 4ca8 FEFFFFEB 		bl	CyU3PDebugPrint
 8777              	.LVL1011:
 8778 4cac 44309DE5 		ldr	r3, [sp, #68]
 8779 4cb0 36FDFFEA 		b	.L630
 8780              	.LVL1012:
 8781              	.L949:
 8782              	.LBE222:
 8783              	.LBE395:
 8784              	.LBB396:
 8785              	.LBB381:
 8786              	.LBB374:
 8787              	.LBB370:
1367:../uvc.c      **** 		 {
 8788              		.loc 1 1367 0
 8789 4cb4 810055E3 		cmp	r5, #129
 8790 4cb8 C202000A 		beq	.L654
 8791 4cbc 9701008A 		bhi	.L655
 8792 4cc0 010055E3 		cmp	r5, #1
 8793 4cc4 FB02001A 		bne	.L651
1824:../uvc.c      **** 				  glEp0Buffer, &readCount);
 8794              		.loc 1 1824 0
 8795 4cc8 42208DE2 		add	r2, sp, #66
 8796 4ccc 2000A0E3 		mov	r0, #32
 8797 4cd0 24149FE5 		ldr	r1, .L981+108
 8798 4cd4 20308DE5 		str	r3, [sp, #32]
 8799 4cd8 1CC08DE5 		str	ip, [sp, #28]
 8800 4cdc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8801              	.LVL1013:
1826:../uvc.c      **** 			   {
 8802              		.loc 1 1826 0
 8803 4ce0 20309DE5 		ldr	r3, [sp, #32]
 8804 4ce4 1CC09DE5 		ldr	ip, [sp, #28]
 8805 4ce8 002050E2 		subs	r2, r0, #0
 8806 4cec D804001A 		bne	.L665
1828:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 8807              		.loc 1 1828 0
 8808 4cf0 020053E3 		cmp	r3, #2
1830:../uvc.c      **** 				 }else{
 8809              		.loc 1 1830 0
 8810 4cf4 29E0DB05 		ldreqb	lr, [fp, #41]	@ zero_extendqisi2
1833:../uvc.c      **** 				 }
 8811              		.loc 1 1833 0
 8812 4cf8 2A00DB15 		ldrneb	r0, [fp, #42]	@ zero_extendqisi2
 8813              	.LVL1014:
1829:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 8814              		.loc 1 1829 0
 8815 4cfc 2840DBE5 		ldrb	r4, [fp, #40]	@ zero_extendqisi2
 8816              	.LVL1015:
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8817              		.loc 1 1836 0
 8818 4d00 28209DE5 		ldr	r2, [sp, #40]
 8819              	.LVL1016:
1830:../uvc.c      **** 				 }else{
 8820              		.loc 1 1830 0
 8821 4d04 24E08D05 		streq	lr, [sp, #36]
 8822              	.LVL1017:
1833:../uvc.c      **** 				 }
 8823              		.loc 1 1833 0
 8824 4d08 24008D15 		strne	r0, [sp, #36]
 8825              	.LVL1018:
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8826              		.loc 1 1836 0
 8827 4d0c 2C109DE5 		ldr	r1, [sp, #44]
 8828 4d10 1C008DE9 		stmib	sp, {r2, r3, r4}
 8829 4d14 24309DE5 		ldr	r3, [sp, #36]
 8830 4d18 0120A0E3 		mov	r2, #1
 8831 4d1c 00108DE5 		str	r1, [sp]
 8832 4d20 10308DE5 		str	r3, [sp, #16]
 8833 4d24 D8139FE5 		ldr	r1, .L981+116
 8834 4d28 0C30A0E1 		mov	r3, ip
 8835 4d2c 0400A0E3 		mov	r0, #4
 8836 4d30 FEFFFFEB 		bl	CyU3PDebugPrint
 8837              	.LVL1019:
2094:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
 8838              		.loc 1 2094 0
 8839 4d34 CCC39FE5 		ldr	ip, .L981+120
 8840 4d38 0010E0E3 		mvn	r1, #0
 8841 4d3c 1C009CE5 		ldr	r0, [ip, #28]
 8842 4d40 FEFFFFEB 		bl	_txe_mutex_get
 8843              	.LVL1020:
2103:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 8844              		.loc 1 2103 0
 8845 4d44 0010A0E3 		mov	r1, #0
 8846 4d48 2C209DE5 		ldr	r2, [sp, #44]
 8847 4d4c 28309DE5 		ldr	r3, [sp, #40]
 8848 4d50 04108DE5 		str	r1, [sp, #4]
 8849 4d54 00408DE5 		str	r4, [sp]
 8850 4d58 0110A0E3 		mov	r1, #1
 8851 4d5c A4039FE5 		ldr	r0, .L981+120
 8852 4d60 FEFFFFEB 		bl	cmdSet
 8853              	.LVL1021:
2104:../uvc.c      **** 
 8854              		.loc 1 2104 0
 8855 4d64 9CE39FE5 		ldr	lr, .L981+120
 8856 4d68 1C009EE5 		ldr	r0, [lr, #28]
 8857 4d6c FEFFFFEB 		bl	_txe_mutex_put
 8858              	.LVL1022:
 8859 4d70 24C09DE5 		ldr	ip, [sp, #36]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8860              		.loc 1 1355 0
 8861 4d74 FF30A0E3 		mov	r3, #255
2107:../uvc.c      **** 							 break;
 8862              		.loc 1 2107 0
 8863 4d78 0110A0E3 		mov	r1, #1
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8864              		.loc 1 1355 0
 8865 4d7c 0320A0E1 		mov	r2, r3
2106:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 8866              		.loc 1 2106 0
 8867 4d80 5545CAE5 		strb	r4, [r10, #1365]
2107:../uvc.c      **** 							 break;
 8868              		.loc 1 2107 0
 8869 4d84 5915CAE5 		strb	r1, [r10, #1369]
 8870              	.LVL1023:
 8871              	.L661:
2271:../uvc.c      **** }
 8872              		.loc 1 2271 0
 8873 4d88 0C008DE9 		stmib	sp, {r2, r3}
 8874 4d8c 0520A0E1 		mov	r2, r5
 8875              	.LVL1024:
 8876 4d90 00C08DE5 		str	ip, [sp]
 8877              	.LVL1025:
 8878              	.L938:
 8879              	.LBE370:
 8880              	.LBE374:
 8881              	.LBE381:
 8882              	.LBE396:
 8883              	.LBB397:
 8884              	.LBB223:
 8885              	.LBB177:
 8886              	.LBB169:
 8887 4d94 0430A0E1 		mov	r3, r4
 8888 4d98 0400A0E3 		mov	r0, #4
 8889 4d9c 40139FE5 		ldr	r1, .L981+84
 8890 4da0 FEFFFFEB 		bl	CyU3PDebugPrint
 8891              	.LVL1026:
 8892 4da4 44309DE5 		ldr	r3, [sp, #68]
 8893 4da8 F8FCFFEA 		b	.L630
 8894              	.LVL1027:
 8895              	.L958:
 8896              	.LBE169:
 8897              	.LBE177:
 8898              	.LBE223:
 8899              	.LBE397:
 8900              	.LBB398:
 8901              	.LBB362:
 8902              	.LBB304:
 8903              	.LBB233:
2297:../uvc.c      **** 		 {
 8904              		.loc 1 2297 0
 8905 4dac 810054E3 		cmp	r4, #129
 8906 4db0 4503000A 		beq	.L708
 8907 4db4 9101008A 		bhi	.L709
 8908 4db8 010054E3 		cmp	r4, #1
 8909 4dbc 1FFEFF1A 		bne	.L705
2368:../uvc.c      **** 			  glEp0Buffer, &readCount);
 8910              		.loc 1 2368 0
 8911 4dc0 34139FE5 		ldr	r1, .L981+108
 8912 4dc4 42208DE2 		add	r2, sp, #66
 8913 4dc8 2000A0E3 		mov	r0, #32
 8914 4dcc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8915              	.LVL1028:
2499:../uvc.c      **** 			  		 break;
 8916              		.loc 1 2499 0
 8917 4dd0 24109DE5 		ldr	r1, [sp, #36]
2498:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8918              		.loc 1 2498 0
 8919 4dd4 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
2499:../uvc.c      **** 			  		 break;
 8920              		.loc 1 2499 0
 8921 4dd8 0400A0E3 		mov	r0, #4
 8922 4ddc 0030D1E5 		ldrb	r3, [r1]	@ zero_extendqisi2
 8923 4de0 0020A0E1 		mov	r2, r0
 8924 4de4 DC129FE5 		ldr	r1, .L981+56
2498:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8925              		.loc 1 2498 0
 8926 4de8 45C6CAE5 		strb	ip, [r10, #1605]
2499:../uvc.c      **** 			  		 break;
 8927              		.loc 1 2499 0
 8928 4dec FEFFFFEB 		bl	CyU3PDebugPrint
 8929              	.LVL1029:
2291:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8930              		.loc 1 2291 0
 8931 4df0 FF20A0E3 		mov	r2, #255
 8932 4df4 CB0000EA 		b	.L772
 8933              	.LVL1030:
 8934              	.L961:
 8935              	.LBE233:
 8936              	.LBE304:
 8937              	.LBB305:
 8938              	.LBB251:
2297:../uvc.c      **** 		 {
 8939              		.loc 1 2297 0
 8940 4df8 810054E3 		cmp	r4, #129
 8941 4dfc FF02000A 		beq	.L765
 8942 4e00 6701008A 		bhi	.L766
 8943 4e04 010054E3 		cmp	r4, #1
 8944 4e08 98FEFF1A 		bne	.L762
2368:../uvc.c      **** 			  glEp0Buffer, &readCount);
 8945              		.loc 1 2368 0
 8946 4e0c E8129FE5 		ldr	r1, .L981+108
 8947 4e10 42208DE2 		add	r2, sp, #66
 8948 4e14 2000A0E3 		mov	r0, #32
 8949 4e18 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8950              	.LVL1031:
2499:../uvc.c      **** 			  		 break;
 8951              		.loc 1 2499 0
 8952 4e1c 24E09DE5 		ldr	lr, [sp, #36]
2498:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8953              		.loc 1 2498 0
 8954 4e20 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
2499:../uvc.c      **** 			  		 break;
 8955              		.loc 1 2499 0
 8956 4e24 0920A0E3 		mov	r2, #9
 8957 4e28 0030DEE5 		ldrb	r3, [lr]	@ zero_extendqisi2
 8958 4e2c 0400A0E3 		mov	r0, #4
 8959 4e30 90129FE5 		ldr	r1, .L981+56
2498:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8960              		.loc 1 2498 0
 8961 4e34 BDC6CAE5 		strb	ip, [r10, #1725]
2499:../uvc.c      **** 			  		 break;
 8962              		.loc 1 2499 0
 8963 4e38 FEFFFFEB 		bl	CyU3PDebugPrint
 8964              	.LVL1032:
2291:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8965              		.loc 1 2291 0
 8966 4e3c FF20A0E3 		mov	r2, #255
 8967 4e40 B80000EA 		b	.L772
 8968              	.LVL1033:
 8969              	.L964:
 8970              	.LBE251:
 8971              	.LBE305:
 8972              	.LBB306:
 8973              	.LBB280:
2297:../uvc.c      **** 		 {
 8974              		.loc 1 2297 0
 8975 4e44 810054E3 		cmp	r4, #129
 8976 4e48 CA02000A 		beq	.L730
 8977 4e4c 5C01008A 		bhi	.L731
 8978 4e50 010054E3 		cmp	r4, #1
 8979 4e54 D8FEFF1A 		bne	.L727
2368:../uvc.c      **** 			  glEp0Buffer, &readCount);
 8980              		.loc 1 2368 0
 8981 4e58 9C129FE5 		ldr	r1, .L981+108
 8982 4e5c 42208DE2 		add	r2, sp, #66
 8983 4e60 2000A0E3 		mov	r0, #32
 8984 4e64 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8985              	.LVL1034:
2499:../uvc.c      **** 			  		 break;
 8986              		.loc 1 2499 0
 8987 4e68 24E09DE5 		ldr	lr, [sp, #36]
2498:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8988              		.loc 1 2498 0
 8989 4e6c 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
2499:../uvc.c      **** 			  		 break;
 8990              		.loc 1 2499 0
 8991 4e70 0620A0E3 		mov	r2, #6
 8992 4e74 0030DEE5 		ldrb	r3, [lr]	@ zero_extendqisi2
 8993 4e78 0400A0E3 		mov	r0, #4
 8994 4e7c 44129FE5 		ldr	r1, .L981+56
2498:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8995              		.loc 1 2498 0
 8996 4e80 75C6CAE5 		strb	ip, [r10, #1653]
2499:../uvc.c      **** 			  		 break;
 8997              		.loc 1 2499 0
 8998 4e84 FEFFFFEB 		bl	CyU3PDebugPrint
 8999              	.LVL1035:
2291:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9000              		.loc 1 2291 0
 9001 4e88 FF20A0E3 		mov	r2, #255
 9002 4e8c A50000EA 		b	.L772
 9003              	.LVL1036:
 9004              	.L963:
 9005              	.LBE280:
 9006              	.LBE306:
 9007              	.LBB307:
 9008              	.LBB270:
2297:../uvc.c      **** 		 {
 9009              		.loc 1 2297 0
 9010 4e90 810054E3 		cmp	r4, #129
 9011 4e94 C502000A 		beq	.L697
 9012 4e98 4D01008A 		bhi	.L698
 9013 4e9c 010054E3 		cmp	r4, #1
 9014 4ea0 9802001A 		bne	.L694
2368:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9015              		.loc 1 2368 0
 9016 4ea4 50129FE5 		ldr	r1, .L981+108
 9017 4ea8 42208DE2 		add	r2, sp, #66
 9018 4eac 2000A0E3 		mov	r0, #32
 9019 4eb0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9020              	.LVL1037:
2499:../uvc.c      **** 			  		 break;
 9021              		.loc 1 2499 0
 9022 4eb4 24009DE5 		ldr	r0, [sp, #36]
2498:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9023              		.loc 1 2498 0
 9024 4eb8 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 9025 4ebc D0E19FE5 		ldr	lr, .L981+4
2499:../uvc.c      **** 			  		 break;
 9026              		.loc 1 2499 0
 9027 4ec0 0030D0E5 		ldrb	r3, [r0]	@ zero_extendqisi2
 9028 4ec4 0220A0E3 		mov	r2, #2
 9029 4ec8 0400A0E3 		mov	r0, #4
 9030 4ecc F4119FE5 		ldr	r1, .L981+56
2498:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9031              		.loc 1 2498 0
 9032 4ed0 15C6CEE5 		strb	ip, [lr, #1557]
2499:../uvc.c      **** 			  		 break;
 9033              		.loc 1 2499 0
 9034 4ed4 FEFFFFEB 		bl	CyU3PDebugPrint
 9035              	.LVL1038:
2291:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9036              		.loc 1 2291 0
 9037 4ed8 FF20A0E3 		mov	r2, #255
 9038 4edc 910000EA 		b	.L772
 9039              	.LVL1039:
 9040              	.L962:
 9041              	.LBE270:
 9042              	.LBE307:
 9043              	.LBB308:
 9044              	.LBB262:
2297:../uvc.c      **** 		 {
 9045              		.loc 1 2297 0
 9046 4ee0 810054E3 		cmp	r4, #129
 9047 4ee4 F402000A 		beq	.L686
 9048 4ee8 3101008A 		bhi	.L687
 9049 4eec 010054E3 		cmp	r4, #1
 9050 4ef0 7AFEFF1A 		bne	.L683
2368:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9051              		.loc 1 2368 0
 9052 4ef4 00129FE5 		ldr	r1, .L981+108
 9053 4ef8 42208DE2 		add	r2, sp, #66
 9054 4efc 2000A0E3 		mov	r0, #32
 9055 4f00 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9056              	.LVL1040:
2499:../uvc.c      **** 			  		 break;
 9057              		.loc 1 2499 0
 9058 4f04 24E09DE5 		ldr	lr, [sp, #36]
2498:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9059              		.loc 1 2498 0
 9060 4f08 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
2499:../uvc.c      **** 			  		 break;
 9061              		.loc 1 2499 0
 9062 4f0c 0020A0E3 		mov	r2, #0
 9063 4f10 0030DEE5 		ldrb	r3, [lr]	@ zero_extendqisi2
 9064 4f14 0400A0E3 		mov	r0, #4
 9065 4f18 A8119FE5 		ldr	r1, .L981+56
2498:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9066              		.loc 1 2498 0
 9067 4f1c E5C5CAE5 		strb	ip, [r10, #1509]
2499:../uvc.c      **** 			  		 break;
 9068              		.loc 1 2499 0
 9069 4f20 FEFFFFEB 		bl	CyU3PDebugPrint
 9070              	.LVL1041:
2291:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9071              		.loc 1 2291 0
 9072 4f24 FF20A0E3 		mov	r2, #255
 9073 4f28 7E0000EA 		b	.L772
 9074              	.LVL1042:
 9075              	.L960:
 9076              	.LBE262:
 9077              	.LBE308:
 9078              	.LBB309:
 9079              	.LBB241:
2297:../uvc.c      **** 		 {
 9080              		.loc 1 2297 0
 9081 4f2c 810054E3 		cmp	r4, #129
 9082 4f30 1503000A 		beq	.L719
 9083 4f34 2D01008A 		bhi	.L720
 9084 4f38 010054E3 		cmp	r4, #1
 9085 4f3c F402001A 		bne	.L716
2368:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9086              		.loc 1 2368 0
 9087 4f40 B4119FE5 		ldr	r1, .L981+108
 9088 4f44 42208DE2 		add	r2, sp, #66
 9089 4f48 2000A0E3 		mov	r0, #32
 9090 4f4c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9091              	.LVL1043:
2499:../uvc.c      **** 			  		 break;
 9092              		.loc 1 2499 0
 9093 4f50 24009DE5 		ldr	r0, [sp, #36]
2498:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9094              		.loc 1 2498 0
 9095 4f54 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 9096 4f58 34E19FE5 		ldr	lr, .L981+4
2499:../uvc.c      **** 			  		 break;
 9097              		.loc 1 2499 0
 9098 4f5c 0030D0E5 		ldrb	r3, [r0]	@ zero_extendqisi2
 9099 4f60 0520A0E3 		mov	r2, #5
 9100 4f64 0400A0E3 		mov	r0, #4
 9101 4f68 58119FE5 		ldr	r1, .L981+56
2498:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9102              		.loc 1 2498 0
 9103 4f6c 5DC6CEE5 		strb	ip, [lr, #1629]
2499:../uvc.c      **** 			  		 break;
 9104              		.loc 1 2499 0
 9105 4f70 FEFFFFEB 		bl	CyU3PDebugPrint
 9106              	.LVL1044:
2291:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9107              		.loc 1 2291 0
 9108 4f74 FF20A0E3 		mov	r2, #255
 9109 4f78 6A0000EA 		b	.L772
 9110              	.LVL1045:
 9111              	.L965:
 9112              	.LBE241:
 9113              	.LBE309:
 9114              	.LBB310:
 9115              	.LBB288:
2297:../uvc.c      **** 		 {
 9116              		.loc 1 2297 0
 9117 4f7c 810054E3 		cmp	r4, #129
 9118 4f80 FE02000A 		beq	.L754
 9119 4f84 1601008A 		bhi	.L755
 9120 4f88 010054E3 		cmp	r4, #1
 9121 4f8c A6FEFF1A 		bne	.L751
2368:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9122              		.loc 1 2368 0
 9123 4f90 64119FE5 		ldr	r1, .L981+108
 9124 4f94 42208DE2 		add	r2, sp, #66
 9125 4f98 2000A0E3 		mov	r0, #32
 9126 4f9c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9127              	.LVL1046:
2499:../uvc.c      **** 			  		 break;
 9128              		.loc 1 2499 0
 9129 4fa0 24E09DE5 		ldr	lr, [sp, #36]
2498:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9130              		.loc 1 2498 0
 9131 4fa4 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
2499:../uvc.c      **** 			  		 break;
 9132              		.loc 1 2499 0
 9133 4fa8 0820A0E3 		mov	r2, #8
 9134 4fac 0030DEE5 		ldrb	r3, [lr]	@ zero_extendqisi2
 9135 4fb0 0400A0E3 		mov	r0, #4
 9136 4fb4 0C119FE5 		ldr	r1, .L981+56
2498:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9137              		.loc 1 2498 0
 9138 4fb8 A5C6CAE5 		strb	ip, [r10, #1701]
2499:../uvc.c      **** 			  		 break;
 9139              		.loc 1 2499 0
 9140 4fbc FEFFFFEB 		bl	CyU3PDebugPrint
 9141              	.LVL1047:
2291:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9142              		.loc 1 2291 0
 9143 4fc0 FF20A0E3 		mov	r2, #255
 9144 4fc4 570000EA 		b	.L772
 9145              	.LVL1048:
 9146              	.L966:
 9147              	.LBE288:
 9148              	.LBE310:
 9149              	.LBB311:
 9150              	.LBB296:
2297:../uvc.c      **** 		 {
 9151              		.loc 1 2297 0
 9152 4fc8 810054E3 		cmp	r4, #129
 9153 4fcc 5902000A 		beq	.L741
 9154 4fd0 EB00008A 		bhi	.L742
 9155 4fd4 010054E3 		cmp	r4, #1
 9156 4fd8 7802001A 		bne	.L738
2368:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9157              		.loc 1 2368 0
 9158 4fdc 18119FE5 		ldr	r1, .L981+108
 9159 4fe0 42208DE2 		add	r2, sp, #66
 9160 4fe4 2000A0E3 		mov	r0, #32
 9161 4fe8 20308DE5 		str	r3, [sp, #32]
 9162 4fec 1CC08DE5 		str	ip, [sp, #28]
 9163 4ff0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9164              	.LVL1049:
2460:../uvc.c      **** 					  {
 9165              		.loc 1 2460 0
 9166 4ff4 98109FE5 		ldr	r1, .L981+4
2370:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 9167              		.loc 1 2370 0
 9168 4ff8 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
2460:../uvc.c      **** 					  {
 9169              		.loc 1 2460 0
 9170 4ffc FD05D1E5 		ldrb	r0, [r1, #1533]	@ zero_extendqisi2
2371:../uvc.c      **** 			  value = Data1;
 9171              		.loc 1 2371 0
 9172 5000 29E0D7E5 		ldrb	lr, [r7, #41]	@ zero_extendqisi2
2460:../uvc.c      **** 					  {
 9173              		.loc 1 2460 0
 9174 5004 010050E3 		cmp	r0, #1
 9175 5008 08005013 		cmpne	r0, #8
2370:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 9176              		.loc 1 2370 0
 9177 500c 24208DE5 		str	r2, [sp, #36]
 9178              	.LVL1050:
2460:../uvc.c      **** 					  {
 9179              		.loc 1 2460 0
 9180 5010 0000A013 		movne	r0, #0
 9181 5014 0100A003 		moveq	r0, #1
2371:../uvc.c      **** 			  value = Data1;
 9182              		.loc 1 2371 0
 9183 5018 28E08DE5 		str	lr, [sp, #40]
 9184              	.LVL1051:
2460:../uvc.c      **** 					  {
 9185              		.loc 1 2460 0
 9186 501c F102001A 		bne	.L749
 9187              	.LVL1052:
2463:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 9188              		.loc 1 2463 0
 9189 5020 E0209FE5 		ldr	r2, .L981+120
 9190 5024 0010E0E3 		mvn	r1, #0
 9191 5028 1C0092E5 		ldr	r0, [r2, #28]
 9192 502c FEFFFFEB 		bl	_txe_mutex_get
 9193              	.LVL1053:
2464:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 9194              		.loc 1 2464 0
 9195 5030 24E09DE5 		ldr	lr, [sp, #36]
 9196 5034 1CC09DE5 		ldr	ip, [sp, #28]
 9197 5038 20309DE5 		ldr	r3, [sp, #32]
 9198 503c 0010A0E3 		mov	r1, #0
 9199 5040 00E08DE5 		str	lr, [sp]
 9200 5044 0320A0E1 		mov	r2, r3
 9201 5048 04108DE5 		str	r1, [sp, #4]
 9202 504c 0C30A0E1 		mov	r3, ip
 9203 5050 2210A0E3 		mov	r1, #34
 9204 5054 AC009FE5 		ldr	r0, .L981+120
 9205 5058 FEFFFFEB 		bl	cmdSet
 9206              	.LVL1054:
2465:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 9207              		.loc 1 2465 0
 9208 505c A4109FE5 		ldr	r1, .L981+120
 9209 5060 1C0091E5 		ldr	r0, [r1, #28]
 9210 5064 FEFFFFEB 		bl	_txe_mutex_put
 9211              	.LVL1055:
2468:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 9212              		.loc 1 2468 0
 9213 5068 24E09FE5 		ldr	lr, .L981+4
 9214 506c 24C09DE5 		ldr	ip, [sp, #36]
2470:../uvc.c      **** 					  }else{
 9215              		.loc 1 2470 0
 9216 5070 9046CEE5 		strb	r4, [lr, #1680]
2468:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 9217              		.loc 1 2468 0
 9218 5074 8DC6CEE5 		strb	ip, [lr, #1677]
2469:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 9219              		.loc 1 2469 0
 9220 5078 28C09DE5 		ldr	ip, [sp, #40]
 9221 507c 8EC6CEE5 		strb	ip, [lr, #1678]
 9222              	.LVL1056:
 9223              	.L750:
2474:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
 9224              		.loc 1 2474 0
 9225 5080 2830D7E5 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
 9226              	.LVL1057:
2475:../uvc.c      **** 
 9227              		.loc 1 2475 0
 9228 5084 2920D7E5 		ldrb	r2, [r7, #41]	@ zero_extendqisi2
 9229              	.LVL1058:
2291:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9230              		.loc 1 2291 0
 9231 5088 FFC0A0E3 		mov	ip, #255
 9232 508c 98FEFFEA 		b	.L748
 9233              	.L982:
 9234              		.align	2
 9235              	.L981:
 9236 5090 00000000 		.word	.LANCHOR0
 9237 5094 00000000 		.word	.LANCHOR1
 9238 5098 00000000 		.word	glInterStaBuffer
 9239 509c 00000000 		.word	wIndex
 9240 50a0 00000000 		.word	wValue
 9241 50a4 AC0C0000 		.word	.LC70
 9242 50a8 00000000 		.word	bmReqType
 9243 50ac 00000000 		.word	wLength
 9244 50b0 300C0000 		.word	.LC69
 9245 50b4 00000000 		.word	glChHandleInterStat
 9246 50b8 880D0000 		.word	.LC76
 9247 50bc D80C0000 		.word	.LC71
 9248 50c0 180D0000 		.word	.LC73
 9249 50c4 D00D0000 		.word	.LC78
 9250 50c8 A4060000 		.word	.LC37
 9251 50cc EC060000 		.word	.LC39
 9252 50d0 F80C0000 		.word	.LC72
 9253 50d4 B00D0000 		.word	.LC77
 9254 50d8 00000000 		.word	bRequest
 9255 50dc F00D0000 		.word	.LC79
 9256 50e0 600D0000 		.word	.LC75
 9257 50e4 2C060000 		.word	.LC35
 9258 50e8 3C0D0000 		.word	.LC74
 9259 50ec 64050000 		.word	.LC31
 9260 50f0 C8060000 		.word	.LC38
 9261 50f4 00000000 		.word	.LANCHOR1
 9262 50f8 38040000 		.word	.LC26
 9263 50fc 28000000 		.word	.LANCHOR0+40
 9264 5100 FC050000 		.word	.LC34
 9265 5104 68040000 		.word	.LC27
 9266 5108 00000000 		.word	cmdQu
 9267              	.LVL1059:
 9268              	.L768:
 9269              	.LBE296:
 9270              	.LBE311:
 9271              	.LBB312:
 9272              	.LBB252:
2302:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9273              		.loc 1 2302 0
 9274 510c 0030A0E3 		mov	r3, #0
2303:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9275              		.loc 1 2303 0
 9276 5110 0200A0E3 		mov	r0, #2
 9277 5114 20101FE5 		ldr	r1, .L981+108
2301:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9278              		.loc 1 2301 0
 9279 5118 2850C7E5 		strb	r5, [r7, #40]
2302:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9280              		.loc 1 2302 0
 9281 511c 2930C7E5 		strb	r3, [r7, #41]
2303:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9282              		.loc 1 2303 0
 9283 5120 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9284              	.LVL1060:
2304:../uvc.c      **** 			  break;
 9285              		.loc 1 2304 0
 9286 5124 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 9287              	.LVL1061:
 9288              	.L772:
2510:../uvc.c      **** }
 9289              		.loc 1 2510 0
 9290 5128 2A10D7E5 		ldrb	r1, [r7, #42]	@ zero_extendqisi2
 9291 512c FF30A0E3 		mov	r3, #255
 9292 5130 08208DE5 		str	r2, [sp, #8]
 9293 5134 04108DE5 		str	r1, [sp, #4]
 9294 5138 10108DE5 		str	r1, [sp, #16]
 9295 513c 00308DE5 		str	r3, [sp]
 9296 5140 0C308DE5 		str	r3, [sp, #12]
 9297 5144 14508DE5 		str	r5, [sp, #20]
 9298 5148 0420A0E1 		mov	r2, r4
 9299              	.LVL1062:
 9300 514c 0400A0E3 		mov	r0, #4
 9301 5150 8C101FE5 		ldr	r1, .L981+60
 9302 5154 FEFFFFEB 		bl	CyU3PDebugPrint
 9303              	.LVL1063:
 9304 5158 44309DE5 		ldr	r3, [sp, #68]
 9305 515c 0BFCFFEA 		b	.L630
 9306              	.LVL1064:
 9307              	.L791:
 9308              	.LBE252:
 9309              	.LBE312:
 9310              	.LBE362:
 9311              	.LBE398:
 9312              	.LBB399:
 9313              	.LBB224:
4260:../uvc.c      ****     		break;
 9314              		.loc 1 4260 0
 9315 5160 1A00A0E3 		mov	r0, #26
 9316 5164 FEFFFFEB 		bl	ControlHandle
 9317              	.LVL1065:
 9318 5168 44309DE5 		ldr	r3, [sp, #68]
 9319 516c 07FCFFEA 		b	.L630
 9320              	.L787:
 9321              	.LVL1066:
4249:../uvc.c      ****      		break;
 9322              		.loc 1 4249 0
 9323 5170 1800A0E3 		mov	r0, #24
 9324 5174 FEFFFFEB 		bl	ControlHandle
 9325              	.LVL1067:
 9326 5178 44309DE5 		ldr	r3, [sp, #68]
 9327 517c 03FCFFEA 		b	.L630
 9328              	.L779:
 9329              	.LVL1068:
4237:../uvc.c      ****      		break;
 9330              		.loc 1 4237 0
 9331 5180 1500A0E3 		mov	r0, #21
 9332 5184 FEFFFFEB 		bl	ControlHandle
 9333              	.LVL1069:
 9334 5188 44309DE5 		ldr	r3, [sp, #68]
 9335 518c FFFBFFEA 		b	.L630
 9336              	.L777:
 9337              	.LVL1070:
4270:../uvc.c      ****     		break;
 9338              		.loc 1 4270 0
 9339 5190 1C00A0E3 		mov	r0, #28
 9340 5194 FEFFFFEB 		bl	ControlHandle
 9341              	.LVL1071:
 9342 5198 44309DE5 		ldr	r3, [sp, #68]
 9343 519c FBFBFFEA 		b	.L630
 9344              	.L794:
4303:../uvc.c      **** 			CyU3PDebugPrint (4, "The ctrlspd command 0x%x 0x%x\r\n", wValue, bRequest);
 9345              		.loc 1 4303 0
 9346 51a0 2800A0E3 		mov	r0, #40
 9347 51a4 FEFFFFEB 		bl	ControlHandle
 9348              	.LVL1072:
4304:../uvc.c      ****     		break;
 9349              		.loc 1 4304 0
 9350 51a8 D8301FE5 		ldr	r3, .L981+72
 9351 51ac B020D4E1 		ldrh	r2, [r4]
 9352 51b0 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 9353 51b4 0400A0E3 		mov	r0, #4
 9354 51b8 F0101FE5 		ldr	r1, .L981+64
 9355 51bc FEFFFFEB 		bl	CyU3PDebugPrint
 9356              	.LVL1073:
 9357 51c0 44309DE5 		ldr	r3, [sp, #68]
 9358 51c4 F1FBFFEA 		b	.L630
 9359              	.L800:
 9360              	.LVL1074:
4294:../uvc.c      ****     		break;
 9361              		.loc 1 4294 0
 9362 51c8 2600A0E3 		mov	r0, #38
 9363 51cc FEFFFFEB 		bl	ControlHandle
 9364              	.LVL1075:
 9365 51d0 44309DE5 		ldr	r3, [sp, #68]
 9366 51d4 EDFBFFEA 		b	.L630
 9367              	.L796:
 9368              	.LVL1076:
4286:../uvc.c      ****     		break;
 9369              		.loc 1 4286 0
 9370 51d8 2400A0E3 		mov	r0, #36
 9371 51dc FEFFFFEB 		bl	ControlHandle
 9372              	.LVL1077:
 9373 51e0 44309DE5 		ldr	r3, [sp, #68]
 9374 51e4 E9FBFFEA 		b	.L630
 9375              	.L781:
 9376              	.LVL1078:
4225:../uvc.c      ****      		break;
 9377              		.loc 1 4225 0
 9378 51e8 1200A0E3 		mov	r0, #18
 9379 51ec FEFFFFEB 		bl	ControlHandle
 9380              	.LVL1079:
 9381 51f0 44309DE5 		ldr	r3, [sp, #68]
 9382 51f4 E5FBFFEA 		b	.L630
 9383              	.L807:
4328:../uvc.c      **** 			CyU3PDebugPrint (4, "The gamma command 0x%x 0x%x\r\n", wValue, bRequest);
 9384              		.loc 1 4328 0
 9385 51f8 2E00A0E3 		mov	r0, #46
 9386 51fc FEFFFFEB 		bl	ControlHandle
 9387              	.LVL1080:
4329:../uvc.c      ****     		break;
 9388              		.loc 1 4329 0
 9389 5200 30311FE5 		ldr	r3, .L981+72
 9390 5204 B020D4E1 		ldrh	r2, [r4]
 9391 5208 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 9392 520c 0400A0E3 		mov	r0, #4
 9393 5210 44111FE5 		ldr	r1, .L981+68
 9394 5214 FEFFFFEB 		bl	CyU3PDebugPrint
 9395              	.LVL1081:
 9396 5218 44309DE5 		ldr	r3, [sp, #68]
 9397 521c DBFBFFEA 		b	.L630
 9398              	.L803:
 9399              	.LVL1082:
 9400              	.LBB178:
 9401              	.LBB179:
1359:../uvc.c      ****     /*
 9402              		.loc 1 1359 0
 9403 5220 50C11FE5 		ldr	ip, .L981+72
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 9404              		.loc 1 1341 0
 9405 5224 8017DAE5 		ldrb	r1, [r10, #1920]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 9406              		.loc 1 1359 0
 9407 5228 0040DCE5 		ldrb	r4, [ip]	@ zero_extendqisi2
 9408 522c 24C08DE5 		str	ip, [sp, #36]
 9409 5230 2C408DE5 		str	r4, [sp, #44]
1367:../uvc.c      **** 		 {
 9410              		.loc 1 1367 0
 9411 5234 2CC09DE5 		ldr	ip, [sp, #44]
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 9412              		.loc 1 1342 0
 9413 5238 8147DAE5 		ldrb	r4, [r10, #1921]	@ zero_extendqisi2
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 9414              		.loc 1 1343 0
 9415 523c 8F27DAE5 		ldrb	r2, [r10, #1935]	@ zero_extendqisi2
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 9416              		.loc 1 1344 0
 9417 5240 8237DAE5 		ldrb	r3, [r10, #1922]	@ zero_extendqisi2
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 9418              		.loc 1 1341 0
 9419 5244 FF1001E2 		and	r1, r1, #255
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 9420              		.loc 1 1343 0
 9421 5248 FF2002E2 		and	r2, r2, #255
1367:../uvc.c      **** 		 {
 9422              		.loc 1 1367 0
 9423 524c 83005CE3 		cmp	ip, #131
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 9424              		.loc 1 1341 0
 9425 5250 34108DE5 		str	r1, [sp, #52]
 9426              	.LVL1083:
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 9427              		.loc 1 1342 0
 9428 5254 FF4004E2 		and	r4, r4, #255
 9429              	.LVL1084:
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 9430              		.loc 1 1343 0
 9431 5258 30208DE5 		str	r2, [sp, #48]
 9432              	.LVL1085:
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 9433              		.loc 1 1344 0
 9434 525c FF3003E2 		and	r3, r3, #255
 9435              	.LVL1086:
1367:../uvc.c      **** 		 {
 9436              		.loc 1 1367 0
 9437 5260 4D02000A 		beq	.L859
 9438 5264 C300009A 		bls	.L968
 9439 5268 2C409DE5 		ldr	r4, [sp, #44]
 9440              	.LVL1087:
 9441 526c 850054E3 		cmp	r4, #133
 9442 5270 8A00000A 		beq	.L864
 9443 5274 CC02003A 		bcc	.L865
 9444 5278 860054E3 		cmp	r4, #134
 9445 527c BC02000A 		beq	.L866
 9446 5280 870054E3 		cmp	r4, #135
 9447 5284 B102001A 		bne	.L858
1789:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 9448              		.loc 1 1789 0
 9449 5288 020053E3 		cmp	r3, #2
1790:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 9450              		.loc 1 1790 0
 9451 528c 8BC7DAE5 		ldrb	ip, [r10, #1931]	@ zero_extendqisi2
1814:../uvc.c      **** 		 	 if(Len == 2){
 9452              		.loc 1 1814 0
 9453 5290 0300A0E1 		mov	r0, r3
1791:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 9454              		.loc 1 1791 0
 9455 5294 8C27DAE5 		ldrb	r2, [r10, #1932]	@ zero_extendqisi2
1789:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 9456              		.loc 1 1789 0
 9457 5298 4A03000A 		beq	.L937
 9458              	.L873:
1796:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 9459              		.loc 1 1796 0
 9460 529c 0030A0E3 		mov	r3, #0
 9461              	.LVL1088:
1814:../uvc.c      **** 		 	 if(Len == 2){
 9462              		.loc 1 1814 0
 9463 52a0 AC111FE5 		ldr	r1, .L981+108
1795:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9464              		.loc 1 1795 0
 9465 52a4 28C0C7E5 		strb	ip, [r7, #40]
1797:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 9466              		.loc 1 1797 0
 9467 52a8 2A20C7E5 		strb	r2, [r7, #42]
1796:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 9468              		.loc 1 1796 0
 9469 52ac 2930C7E5 		strb	r3, [r7, #41]
1798:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 9470              		.loc 1 1798 0
 9471 52b0 2B30C7E5 		strb	r3, [r7, #43]
1820:../uvc.c      **** 		 	 }
 9472              		.loc 1 1820 0
 9473 52b4 28308DE5 		str	r3, [sp, #40]
1814:../uvc.c      **** 		 	 if(Len == 2){
 9474              		.loc 1 1814 0
 9475 52b8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9476              	.LVL1089:
1820:../uvc.c      **** 		 	 }
 9477              		.loc 1 1820 0
 9478 52bc 00C0A0E3 		mov	ip, #0
1819:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 9479              		.loc 1 1819 0
 9480 52c0 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 9481              	.LVL1090:
1820:../uvc.c      **** 		 	 }
 9482              		.loc 1 1820 0
 9483 52c4 2A40D7E5 		ldrb	r4, [r7, #42]	@ zero_extendqisi2
 9484              	.LVL1091:
 9485 52c8 7E0000EA 		b	.L868
 9486              	.LVL1092:
 9487              	.L954:
 9488 52cc 0250A0E1 		mov	r5, r2
 9489              	.LBE179:
 9490              	.LBE178:
 9491              	.LBE224:
 9492              	.LBE399:
4874:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 9493              		.loc 1 4874 0
 9494 52d0 0C00A0E1 		mov	r0, ip
 9495              	.LVL1093:
 9496 52d4 00121FE5 		ldr	r1, .L981+76
 9497 52d8 FEFFFFEB 		bl	CyU3PDebugPrint
 9498              	.LVL1094:
4875:../uvc.c      **** 					}
 9499              		.loc 1 4875 0
 9500 52dc 0500A0E1 		mov	r0, r5
 9501 52e0 FEFFFFEB 		bl	CyFxAppErrorHandler
 9502              	.LVL1095:
 9503              	.L659:
 9504              	.LBB400:
 9505              	.LBB382:
 9506              	.LBB375:
 9507              	.LBB371:
1776:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9508              		.loc 1 1776 0
 9509 52e4 5125DAE5 		ldrb	r2, [r10, #1361]	@ zero_extendqisi2
1782:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9510              		.loc 1 1782 0
 9511 52e8 F4111FE5 		ldr	r1, .L981+108
1777:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9512              		.loc 1 1777 0
 9513 52ec 0030A0E3 		mov	r3, #0
 9514              	.LVL1096:
1782:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9515              		.loc 1 1782 0
 9516 52f0 0100A0E3 		mov	r0, #1
1776:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9517              		.loc 1 1776 0
 9518 52f4 2820C7E5 		strb	r2, [r7, #40]
1777:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9519              		.loc 1 1777 0
 9520 52f8 2930C7E5 		strb	r3, [r7, #41]
1778:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9521              		.loc 1 1778 0
 9522 52fc 2A30C7E5 		strb	r3, [r7, #42]
1779:../uvc.c      **** 		 	 }
 9523              		.loc 1 1779 0
 9524 5300 2B30C7E5 		strb	r3, [r7, #43]
 9525              	.LVL1097:
 9526              	.L922:
1744:../uvc.c      **** 				  }else{
 9527              		.loc 1 1744 0
 9528 5304 0040A0E3 		mov	r4, #0
 9529 5308 24408DE5 		str	r4, [sp, #36]
1741:../uvc.c      **** 				  if(Len == 2){
 9530              		.loc 1 1741 0
 9531 530c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9532              	.LVL1098:
1743:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 9533              		.loc 1 1743 0
 9534 5310 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 9535              	.LVL1099:
1744:../uvc.c      **** 				  }else{
 9536              		.loc 1 1744 0
 9537 5314 2930D7E5 		ldrb	r3, [r7, #41]	@ zero_extendqisi2
 9538              	.LVL1100:
 9539 5318 24C09DE5 		ldr	ip, [sp, #36]
 9540 531c 99FEFFEA 		b	.L661
 9541              	.LVL1101:
 9542              	.L655:
1693:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9543              		.loc 1 1693 0
 9544 5320 020053E3 		cmp	r3, #2
1694:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 9545              		.loc 1 1694 0
 9546 5324 4BC5DAE5 		ldrb	ip, [r10, #1355]	@ zero_extendqisi2
 9547              	.LVL1102:
1705:../uvc.c      **** 		 	 if(Len == 2){
 9548              		.loc 1 1705 0
 9549 5328 0300A0E1 		mov	r0, r3
 9550              	.LVL1103:
1695:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9551              		.loc 1 1695 0
 9552 532c 4C25DAE5 		ldrb	r2, [r10, #1356]	@ zero_extendqisi2
1693:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9553              		.loc 1 1693 0
 9554 5330 7001000A 		beq	.L921
 9555              	.LVL1104:
1701:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9556              		.loc 1 1701 0
 9557 5334 0030A0E3 		mov	r3, #0
1705:../uvc.c      **** 		 	 if(Len == 2){
 9558              		.loc 1 1705 0
 9559 5338 44121FE5 		ldr	r1, .L981+108
1698:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9560              		.loc 1 1698 0
 9561 533c 28C0C7E5 		strb	ip, [r7, #40]
1700:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 9562              		.loc 1 1700 0
 9563 5340 2920C7E5 		strb	r2, [r7, #41]
1701:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9564              		.loc 1 1701 0
 9565 5344 2B30C7E5 		strb	r3, [r7, #43]
1711:../uvc.c      **** 			  }
 9566              		.loc 1 1711 0
 9567 5348 24308DE5 		str	r3, [sp, #36]
 9568 534c 0040A0E3 		mov	r4, #0
1705:../uvc.c      **** 		 	 if(Len == 2){
 9569              		.loc 1 1705 0
 9570 5350 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9571              	.LVL1105:
1710:../uvc.c      **** 				  sendData1 = glEp0Buffer[2];
 9572              		.loc 1 1710 0
 9573 5354 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 9574              	.LVL1106:
1711:../uvc.c      **** 			  }
 9575              		.loc 1 1711 0
 9576 5358 2A30D7E5 		ldrb	r3, [r7, #42]	@ zero_extendqisi2
 9577              	.LVL1107:
 9578 535c 24C09DE5 		ldr	ip, [sp, #36]
 9579 5360 88FEFFEA 		b	.L661
 9580              	.LVL1108:
 9581              	.L759:
 9582              	.LBE371:
 9583              	.LBE375:
 9584              	.LBE382:
 9585              	.LBE400:
 9586              	.LBB401:
 9587              	.LBB363:
 9588              	.LBB313:
 9589              	.LBB289:
2353:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9590              		.loc 1 2353 0
 9591 5364 A136DAE5 		ldrb	r3, [r10, #1697]	@ zero_extendqisi2
 9592              	.LVL1109:
 9593              	.L940:
 9594              	.LBE289:
 9595              	.LBE313:
 9596              	.LBB314:
 9597              	.LBB253:
2354:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9598              		.loc 1 2354 0
 9599 5368 0100A0E3 		mov	r0, #1
 9600 536c 78121FE5 		ldr	r1, .L981+108
2353:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9601              		.loc 1 2353 0
 9602 5370 2830C7E5 		strb	r3, [r7, #40]
2356:../uvc.c      **** 			  break;
 9603              		.loc 1 2356 0
 9604 5374 0150A0E3 		mov	r5, #1
2354:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9605              		.loc 1 2354 0
 9606 5378 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9607              	.LVL1110:
2355:../uvc.c      **** 			  Len = 1;
 9608              		.loc 1 2355 0
 9609 537c 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 9610              	.LVL1111:
 9611 5380 68FFFFEA 		b	.L772
 9612              	.LVL1112:
 9613              	.L742:
 9614              	.LBE253:
 9615              	.LBE314:
 9616              	.LBB315:
 9617              	.LBB297:
2326:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9618              		.loc 1 2326 0
 9619 5384 98021FE5 		ldr	r0, .L981+100
 9620 5388 8316D0E5 		ldrb	r1, [r0, #1667]	@ zero_extendqisi2
2327:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9621              		.loc 1 2327 0
 9622 538c 8426D0E5 		ldrb	r2, [r0, #1668]	@ zero_extendqisi2
 9623 5390 CCFDFFEA 		b	.L929
 9624              	.LVL1113:
 9625              	.L770:
 9626              	.LBE297:
 9627              	.LBE315:
 9628              	.LBB316:
 9629              	.LBB254:
2353:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9630              		.loc 1 2353 0
 9631 5394 B936DAE5 		ldrb	r3, [r10, #1721]	@ zero_extendqisi2
 9632 5398 F2FFFFEA 		b	.L940
 9633              	.LVL1114:
 9634              	.L713:
 9635              	.LBE254:
 9636              	.LBE316:
 9637              	.LBB317:
 9638              	.LBB234:
 9639 539c 4136DAE5 		ldrb	r3, [r10, #1601]	@ zero_extendqisi2
 9640 53a0 F0FFFFEA 		b	.L940
 9641              	.LVL1115:
 9642              	.L766:
 9643              	.LBE234:
 9644              	.LBE317:
 9645              	.LBB318:
 9646              	.LBB255:
2326:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9647              		.loc 1 2326 0
 9648 53a4 B8E21FE5 		ldr	lr, .L981+100
 9649 53a8 B316DEE5 		ldrb	r1, [lr, #1715]	@ zero_extendqisi2
2327:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9650              		.loc 1 2327 0
 9651 53ac B426DEE5 		ldrb	r2, [lr, #1716]	@ zero_extendqisi2
 9652 53b0 67FDFFEA 		b	.L931
 9653              	.LVL1116:
 9654              	.L687:
 9655              	.LBE255:
 9656              	.LBE318:
 9657              	.LBB319:
 9658              	.LBB263:
2326:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9659              		.loc 1 2326 0
 9660 53b4 C8E21FE5 		ldr	lr, .L981+100
 9661 53b8 DB15DEE5 		ldrb	r1, [lr, #1499]	@ zero_extendqisi2
2327:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9662              		.loc 1 2327 0
 9663 53bc DC25DEE5 		ldrb	r2, [lr, #1500]	@ zero_extendqisi2
 9664 53c0 63FDFFEA 		b	.L931
 9665              	.LVL1117:
 9666              	.L731:
 9667              	.LBE263:
 9668              	.LBE319:
 9669              	.LBB320:
 9670              	.LBB281:
2326:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9671              		.loc 1 2326 0
 9672 53c4 D8E21FE5 		ldr	lr, .L981+100
 9673 53c8 6B16DEE5 		ldrb	r1, [lr, #1643]	@ zero_extendqisi2
2327:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9674              		.loc 1 2327 0
 9675 53cc 6C26DEE5 		ldrb	r2, [lr, #1644]	@ zero_extendqisi2
 9676 53d0 5FFDFFEA 		b	.L931
 9677              	.LVL1118:
 9678              	.L698:
 9679              	.LBE281:
 9680              	.LBE320:
 9681              	.LBB321:
 9682              	.LBB271:
2326:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9683              		.loc 1 2326 0
 9684 53d4 E8E21FE5 		ldr	lr, .L981+100
 9685 53d8 0B16DEE5 		ldrb	r1, [lr, #1547]	@ zero_extendqisi2
2327:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9686              		.loc 1 2327 0
 9687 53dc 0C26DEE5 		ldrb	r2, [lr, #1548]	@ zero_extendqisi2
 9688 53e0 5BFDFFEA 		b	.L931
 9689              	.LVL1119:
 9690              	.L755:
 9691              	.LBE271:
 9692              	.LBE321:
 9693              	.LBB322:
 9694              	.LBB290:
2326:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9695              		.loc 1 2326 0
 9696 53e4 9B16DAE5 		ldrb	r1, [r10, #1691]	@ zero_extendqisi2
2327:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9697              		.loc 1 2327 0
 9698 53e8 9C26DAE5 		ldrb	r2, [r10, #1692]	@ zero_extendqisi2
 9699 53ec 58FDFFEA 		b	.L931
 9700              	.LVL1120:
 9701              	.L720:
 9702              	.LBE290:
 9703              	.LBE322:
 9704              	.LBB323:
 9705              	.LBB242:
2326:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9706              		.loc 1 2326 0
 9707 53f0 04E31FE5 		ldr	lr, .L981+100
 9708 53f4 5316DEE5 		ldrb	r1, [lr, #1619]	@ zero_extendqisi2
2327:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9709              		.loc 1 2327 0
 9710 53f8 5426DEE5 		ldrb	r2, [lr, #1620]	@ zero_extendqisi2
 9711 53fc 54FDFFEA 		b	.L931
 9712              	.LVL1121:
 9713              	.L709:
 9714              	.LBE242:
 9715              	.LBE323:
 9716              	.LBB324:
 9717              	.LBB235:
2326:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9718              		.loc 1 2326 0
 9719 5400 3B16DAE5 		ldrb	r1, [r10, #1595]	@ zero_extendqisi2
2327:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9720              		.loc 1 2327 0
 9721 5404 3C26DAE5 		ldrb	r2, [r10, #1596]	@ zero_extendqisi2
 9722 5408 51FDFFEA 		b	.L931
 9723              	.LVL1122:
 9724              	.L724:
 9725              	.LBE235:
 9726              	.LBE324:
 9727              	.LBB325:
 9728              	.LBB243:
2353:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9729              		.loc 1 2353 0
 9730 540c 20C31FE5 		ldr	ip, .L981+100
 9731 5410 5936DCE5 		ldrb	r3, [ip, #1625]	@ zero_extendqisi2
 9732 5414 D3FFFFEA 		b	.L940
 9733              	.LVL1123:
 9734              	.L746:
 9735              	.LBE243:
 9736              	.LBE325:
 9737              	.LBB326:
 9738              	.LBB298:
 9739 5418 2CC31FE5 		ldr	ip, .L981+100
2354:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9740              		.loc 1 2354 0
 9741 541c 0100A0E3 		mov	r0, #1
2353:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9742              		.loc 1 2353 0
 9743 5420 8936DCE5 		ldrb	r3, [ip, #1673]	@ zero_extendqisi2
2354:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9744              		.loc 1 2354 0
 9745 5424 30131FE5 		ldr	r1, .L981+108
2353:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9746              		.loc 1 2353 0
 9747 5428 2830C7E5 		strb	r3, [r7, #40]
2354:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9748              		.loc 1 2354 0
 9749 542c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9750              	.LVL1124:
2291:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9751              		.loc 1 2291 0
 9752 5430 FF20A0E3 		mov	r2, #255
 9753 5434 0230A0E1 		mov	r3, r2
2355:../uvc.c      **** 			  Len = 1;
 9754              		.loc 1 2355 0
 9755 5438 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 9756              	.LVL1125:
2356:../uvc.c      **** 			  break;
 9757              		.loc 1 2356 0
 9758 543c 0150A0E3 		mov	r5, #1
 9759 5440 ABFDFFEA 		b	.L748
 9760              	.LVL1126:
 9761              	.L735:
 9762              	.LBE298:
 9763              	.LBE326:
 9764              	.LBB327:
 9765              	.LBB282:
2353:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9766              		.loc 1 2353 0
 9767 5444 7136DAE5 		ldrb	r3, [r10, #1649]	@ zero_extendqisi2
 9768 5448 C6FFFFEA 		b	.L940
 9769              	.LVL1127:
 9770              	.L691:
 9771              	.LBE282:
 9772              	.LBE327:
 9773              	.LBB328:
 9774              	.LBB264:
 9775 544c E135DAE5 		ldrb	r3, [r10, #1505]	@ zero_extendqisi2
 9776 5450 C4FFFFEA 		b	.L940
 9777              	.LVL1128:
 9778              	.L702:
 9779              	.LBE264:
 9780              	.LBE328:
 9781              	.LBB329:
 9782              	.LBB272:
 9783 5454 68C31FE5 		ldr	ip, .L981+100
 9784 5458 1136DCE5 		ldrb	r3, [ip, #1553]	@ zero_extendqisi2
 9785 545c C1FFFFEA 		b	.L940
 9786              	.LVL1129:
 9787              	.L816:
 9788              	.LBE272:
 9789              	.LBE329:
 9790              	.LBE363:
 9791              	.LBE401:
 9792              	.LBB402:
 9793              	.LBB225:
 9794              	.LBB191:
 9795              	.LBB170:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9796              		.loc 1 1372 0
 9797 5460 0020A0E3 		mov	r2, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9798              		.loc 1 1373 0
 9799 5464 0200A0E3 		mov	r0, #2
 9800 5468 74131FE5 		ldr	r1, .L981+108
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9801              		.loc 1 1371 0
 9802 546c 2830C7E5 		strb	r3, [r7, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9803              		.loc 1 1372 0
 9804 5470 2920C7E5 		strb	r2, [r7, #41]
1374:../uvc.c      **** 			  break;
 9805              		.loc 1 1374 0
 9806 5474 0240A0E1 		mov	r4, r2
 9807 5478 24208DE5 		str	r2, [sp, #36]
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9808              		.loc 1 1373 0
 9809 547c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9810              	.LVL1130:
1374:../uvc.c      **** 			  break;
 9811              		.loc 1 1374 0
 9812 5480 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 9813              	.LVL1131:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9814              		.loc 1 1355 0
 9815 5484 FF50A0E3 		mov	r5, #255
 9816              	.LVL1132:
 9817              	.L820:
2271:../uvc.c      **** }
 9818              		.loc 1 2271 0
 9819 5488 24E09DE5 		ldr	lr, [sp, #36]
 9820 548c 04C08DE5 		str	ip, [sp, #4]
 9821 5490 00E08DE5 		str	lr, [sp]
 9822 5494 08508DE5 		str	r5, [sp, #8]
 9823 5498 28209DE5 		ldr	r2, [sp, #40]
 9824 549c 3CFEFFEA 		b	.L938
 9825              	.LVL1133:
 9826              	.L864:
 9827              	.LBE170:
 9828              	.LBE191:
 9829              	.LBB192:
 9830              	.LBB180:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9831              		.loc 1 1372 0
 9832 54a0 0020A0E3 		mov	r2, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9833              		.loc 1 1373 0
 9834 54a4 0200A0E3 		mov	r0, #2
 9835 54a8 B4131FE5 		ldr	r1, .L981+108
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9836              		.loc 1 1371 0
 9837 54ac 2830C7E5 		strb	r3, [r7, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9838              		.loc 1 1372 0
 9839 54b0 2920C7E5 		strb	r2, [r7, #41]
1374:../uvc.c      **** 			  break;
 9840              		.loc 1 1374 0
 9841 54b4 28208DE5 		str	r2, [sp, #40]
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9842              		.loc 1 1373 0
 9843 54b8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9844              	.LVL1134:
1374:../uvc.c      **** 			  break;
 9845              		.loc 1 1374 0
 9846 54bc 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 9847              	.LVL1135:
 9848 54c0 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9849              		.loc 1 1355 0
 9850 54c4 FF40A0E3 		mov	r4, #255
 9851              	.LVL1136:
 9852              	.L868:
2271:../uvc.c      **** }
 9853              		.loc 1 2271 0
 9854 54c8 28E09DE5 		ldr	lr, [sp, #40]
 9855 54cc 0C30A0E1 		mov	r3, ip
 9856 54d0 00E08DE5 		str	lr, [sp]
 9857 54d4 08408DE5 		str	r4, [sp, #8]
 9858 54d8 2C209DE5 		ldr	r2, [sp, #44]
 9859 54dc 00141FE5 		ldr	r1, .L981+84
 9860 54e0 04508DE5 		str	r5, [sp, #4]
 9861 54e4 0400A0E3 		mov	r0, #4
 9862 54e8 FEFFFFEB 		bl	CyU3PDebugPrint
 9863              	.LVL1137:
 9864              	.LBE180:
 9865              	.LBE192:
4319:../uvc.c      ****     		break;
 9866              		.loc 1 4319 0
 9867 54ec 24409DE5 		ldr	r4, [sp, #36]
 9868              	.LVL1138:
 9869 54f0 0400A0E3 		mov	r0, #4
 9870 54f4 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 9871 54f8 20141FE5 		ldr	r1, .L981+80
 9872 54fc B020D8E1 		ldrh	r2, [r8]
 9873 5500 FEFFFFEB 		bl	CyU3PDebugPrint
 9874              	.LVL1139:
 9875 5504 44309DE5 		ldr	r3, [sp, #68]
 9876 5508 20FBFFEA 		b	.L630
 9877              	.LVL1140:
 9878              	.L840:
 9879              	.LBB193:
 9880              	.LBB158:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9881              		.loc 1 1372 0
 9882 550c 0020A0E3 		mov	r2, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9883              		.loc 1 1373 0
 9884 5510 0200A0E3 		mov	r0, #2
 9885 5514 20141FE5 		ldr	r1, .L981+108
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9886              		.loc 1 1371 0
 9887 5518 2830C7E5 		strb	r3, [r7, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9888              		.loc 1 1372 0
 9889 551c 2920C7E5 		strb	r2, [r7, #41]
1374:../uvc.c      **** 			  break;
 9890              		.loc 1 1374 0
 9891 5520 28208DE5 		str	r2, [sp, #40]
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9892              		.loc 1 1373 0
 9893 5524 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9894              	.LVL1141:
1374:../uvc.c      **** 			  break;
 9895              		.loc 1 1374 0
 9896 5528 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 9897              	.LVL1142:
 9898 552c 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9899              		.loc 1 1355 0
 9900 5530 FF40A0E3 		mov	r4, #255
 9901              	.LVL1143:
 9902              	.L844:
2271:../uvc.c      **** }
 9903              		.loc 1 2271 0
 9904 5534 28E09DE5 		ldr	lr, [sp, #40]
 9905 5538 0C30A0E1 		mov	r3, ip
 9906 553c 00E08DE5 		str	lr, [sp]
 9907 5540 08408DE5 		str	r4, [sp, #8]
 9908 5544 2C209DE5 		ldr	r2, [sp, #44]
 9909 5548 6C141FE5 		ldr	r1, .L981+84
 9910 554c 04508DE5 		str	r5, [sp, #4]
 9911 5550 0400A0E3 		mov	r0, #4
 9912 5554 FEFFFFEB 		bl	CyU3PDebugPrint
 9913              	.LVL1144:
 9914              	.LBE158:
 9915              	.LBE193:
4314:../uvc.c      ****    		break;
 9916              		.loc 1 4314 0
 9917 5558 24409DE5 		ldr	r4, [sp, #36]
 9918              	.LVL1145:
 9919 555c 0400A0E3 		mov	r0, #4
 9920 5560 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 9921 5564 84141FE5 		ldr	r1, .L981+88
 9922 5568 B020D8E1 		ldrh	r2, [r8]
 9923 556c FEFFFFEB 		bl	CyU3PDebugPrint
 9924              	.LVL1146:
 9925 5570 44309DE5 		ldr	r3, [sp, #68]
 9926 5574 05FBFFEA 		b	.L630
 9927              	.LVL1147:
 9928              	.L968:
 9929              	.LBB194:
 9930              	.LBB181:
1367:../uvc.c      **** 		 {
 9931              		.loc 1 1367 0
 9932 5578 81005CE3 		cmp	ip, #129
 9933 557c 3A02000A 		beq	.L861
 9934 5580 2D02008A 		bhi	.L862
 9935 5584 01005CE3 		cmp	ip, #1
 9936 5588 F001001A 		bne	.L858
1824:../uvc.c      **** 				  glEp0Buffer, &readCount);
 9937              		.loc 1 1824 0
 9938 558c 2000A0E3 		mov	r0, #32
 9939 5590 9C141FE5 		ldr	r1, .L981+108
 9940 5594 42208DE2 		add	r2, sp, #66
 9941 5598 20308DE5 		str	r3, [sp, #32]
 9942 559c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9943              	.LVL1148:
1826:../uvc.c      **** 			   {
 9944              		.loc 1 1826 0
 9945 55a0 20309DE5 		ldr	r3, [sp, #32]
 9946 55a4 000050E3 		cmp	r0, #0
 9947 55a8 38008DE5 		str	r0, [sp, #56]
 9948 55ac 9B02001A 		bne	.L874
1828:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 9949              		.loc 1 1828 0
 9950 55b0 020053E3 		cmp	r3, #2
1829:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 9951              		.loc 1 1829 0
 9952 55b4 28C0DBE5 		ldrb	ip, [fp, #40]	@ zero_extendqisi2
1828:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 9953              		.loc 1 1828 0
 9954 55b8 AE02000A 		beq	.L969
 9955              	.LVL1149:
1833:../uvc.c      **** 				 }
 9956              		.loc 1 1833 0
 9957 55bc 2AE0DBE5 		ldrb	lr, [fp, #42]	@ zero_extendqisi2
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 9958              		.loc 1 1836 0
 9959 55c0 30009DE5 		ldr	r0, [sp, #48]
 9960              	.LVL1150:
 9961 55c4 3C308DE5 		str	r3, [sp, #60]
 9962 55c8 08308DE5 		str	r3, [sp, #8]
 9963 55cc 04008DE5 		str	r0, [sp, #4]
 9964 55d0 0CC08DE5 		str	ip, [sp, #12]
 9965 55d4 D8141FE5 		ldr	r1, .L981+116
 9966 55d8 00408DE5 		str	r4, [sp]
 9967 55dc 10E08DE5 		str	lr, [sp, #16]
 9968 55e0 0400A0E3 		mov	r0, #4
 9969 55e4 2B20A0E3 		mov	r2, #43
 9970 55e8 34309DE5 		ldr	r3, [sp, #52]
 9971 55ec 1CC08DE5 		str	ip, [sp, #28]
1833:../uvc.c      **** 				 }
 9972              		.loc 1 1833 0
 9973 55f0 28E08DE5 		str	lr, [sp, #40]
 9974              	.LVL1151:
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 9975              		.loc 1 1836 0
 9976 55f4 FEFFFFEB 		bl	CyU3PDebugPrint
 9977              	.LVL1152:
2047:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 9978              		.loc 1 2047 0
 9979 55f8 3C109DE5 		ldr	r1, [sp, #60]
 9980 55fc 1CC09DE5 		ldr	ip, [sp, #28]
 9981 5600 040051E3 		cmp	r1, #4
 9982 5604 6003000A 		beq	.L970
 9983              	.LVL1153:
 9984              	.L879:
2064:../uvc.c      **** 				 	 			 break;
 9985              		.loc 1 2064 0
 9986 5608 8E27DAE5 		ldrb	r2, [r10, #1934]	@ zero_extendqisi2
2063:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 9987              		.loc 1 2063 0
 9988 560c 3C409DE5 		ldr	r4, [sp, #60]
2064:../uvc.c      **** 				 	 			 break;
 9989              		.loc 1 2064 0
 9990 5610 8D37DAE5 		ldrb	r3, [r10, #1933]	@ zero_extendqisi2
2063:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 9991              		.loc 1 2063 0
 9992 5614 0400A0E3 		mov	r0, #4
 9993 5618 1C008DE8 		stmia	sp, {r2, r3, r4}
 9994 561c 38151FE5 		ldr	r1, .L981+92
 9995 5620 0C20A0E1 		mov	r2, ip
 9996 5624 28309DE5 		ldr	r3, [sp, #40]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9997              		.loc 1 1355 0
 9998 5628 FF40A0E3 		mov	r4, #255
2063:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 9999              		.loc 1 2063 0
 10000 562c 1CC08DE5 		str	ip, [sp, #28]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10001              		.loc 1 1355 0
 10002 5630 0450A0E1 		mov	r5, r4
2063:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10003              		.loc 1 2063 0
 10004 5634 FEFFFFEB 		bl	CyU3PDebugPrint
 10005              	.LVL1154:
 10006 5638 1CC09DE5 		ldr	ip, [sp, #28]
 10007 563c A1FFFFEA 		b	.L868
 10008              	.LVL1155:
 10009              	.L967:
 10010              	.LBE181:
 10011              	.LBE194:
 10012              	.LBB195:
 10013              	.LBB171:
1367:../uvc.c      **** 		 {
 10014              		.loc 1 1367 0
 10015 5640 810054E3 		cmp	r4, #129
 10016 5644 9E01000A 		beq	.L813
 10017 5648 9401008A 		bhi	.L814
 10018 564c 010054E3 		cmp	r4, #1
 10019 5650 B501001A 		bne	.L810
1824:../uvc.c      **** 				  glEp0Buffer, &readCount);
 10020              		.loc 1 1824 0
 10021 5654 2000A0E3 		mov	r0, #32
 10022 5658 64151FE5 		ldr	r1, .L981+108
 10023 565c 42208DE2 		add	r2, sp, #66
 10024 5660 20308DE5 		str	r3, [sp, #32]
 10025 5664 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10026              	.LVL1156:
1826:../uvc.c      **** 			   {
 10027              		.loc 1 1826 0
 10028 5668 20309DE5 		ldr	r3, [sp, #32]
 10029 566c 000050E3 		cmp	r0, #0
 10030 5670 38008DE5 		str	r0, [sp, #56]
 10031 5674 6002001A 		bne	.L826
1828:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 10032              		.loc 1 1828 0
 10033 5678 020053E3 		cmp	r3, #2
1829:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 10034              		.loc 1 1829 0
 10035 567c 2840DBE5 		ldrb	r4, [fp, #40]	@ zero_extendqisi2
1828:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 10036              		.loc 1 1828 0
 10037 5680 D402000A 		beq	.L971
 10038              	.LVL1157:
1833:../uvc.c      **** 				 }
 10039              		.loc 1 1833 0
 10040 5684 2AC0DBE5 		ldrb	ip, [fp, #42]	@ zero_extendqisi2
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 10041              		.loc 1 1836 0
 10042 5688 3C308DE5 		str	r3, [sp, #60]
1833:../uvc.c      **** 				 }
 10043              		.loc 1 1833 0
 10044 568c 24C08DE5 		str	ip, [sp, #36]
 10045              	.LVL1158:
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 10046              		.loc 1 1836 0
 10047 5690 34C09DE5 		ldr	ip, [sp, #52]
 10048 5694 08308DE5 		str	r3, [sp, #8]
 10049 5698 00C08DE5 		str	ip, [sp]
 10050 569c 2CC09DE5 		ldr	ip, [sp, #44]
 10051 56a0 0C408DE5 		str	r4, [sp, #12]
 10052 56a4 04C08DE5 		str	ip, [sp, #4]
 10053 56a8 24C09DE5 		ldr	ip, [sp, #36]
 10054 56ac 0400A0E3 		mov	r0, #4
 10055              	.LVL1159:
 10056 56b0 10C08DE5 		str	ip, [sp, #16]
 10057 56b4 B8151FE5 		ldr	r1, .L981+116
 10058 56b8 1620A0E3 		mov	r2, #22
 10059 56bc 30309DE5 		ldr	r3, [sp, #48]
 10060 56c0 FEFFFFEB 		bl	CyU3PDebugPrint
 10061              	.LVL1160:
2047:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 10062              		.loc 1 2047 0
 10063 56c4 3CC09DE5 		ldr	ip, [sp, #60]
 10064 56c8 04005CE3 		cmp	ip, #4
 10065 56cc EA02000A 		beq	.L972
 10066              	.LVL1161:
 10067              	.L831:
2064:../uvc.c      **** 				 	 			 break;
 10068              		.loc 1 2064 0
 10069 56d0 6627DAE5 		ldrb	r2, [r10, #1894]	@ zero_extendqisi2
2063:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10070              		.loc 1 2063 0
 10071 56d4 3CC09DE5 		ldr	ip, [sp, #60]
2064:../uvc.c      **** 				 	 			 break;
 10072              		.loc 1 2064 0
 10073 56d8 6537DAE5 		ldrb	r3, [r10, #1893]	@ zero_extendqisi2
2063:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10074              		.loc 1 2063 0
 10075 56dc 0400A0E3 		mov	r0, #4
 10076 56e0 0C108DE8 		stmia	sp, {r2, r3, ip}
 10077 56e4 00161FE5 		ldr	r1, .L981+92
 10078 56e8 0420A0E1 		mov	r2, r4
 10079 56ec 24309DE5 		ldr	r3, [sp, #36]
 10080 56f0 FEFFFFEB 		bl	CyU3PDebugPrint
 10081              	.LVL1162:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10082              		.loc 1 1355 0
 10083 56f4 FF50A0E3 		mov	r5, #255
 10084 56f8 05C0A0E1 		mov	ip, r5
 10085 56fc 61FFFFEA 		b	.L820
 10086              	.LVL1163:
 10087              	.L959:
 10088              	.LBE171:
 10089              	.LBE195:
 10090              	.LBB196:
 10091              	.LBB159:
1367:../uvc.c      **** 		 {
 10092              		.loc 1 1367 0
 10093 5700 81005CE3 		cmp	ip, #129
 10094 5704 1702000A 		beq	.L837
 10095 5708 0D02008A 		bhi	.L838
 10096 570c 01005CE3 		cmp	ip, #1
 10097 5710 C001001A 		bne	.L834
1824:../uvc.c      **** 				  glEp0Buffer, &readCount);
 10098              		.loc 1 1824 0
 10099 5714 2000A0E3 		mov	r0, #32
 10100 5718 24161FE5 		ldr	r1, .L981+108
 10101 571c 42208DE2 		add	r2, sp, #66
 10102 5720 20308DE5 		str	r3, [sp, #32]
 10103 5724 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10104              	.LVL1164:
1826:../uvc.c      **** 			   {
 10105              		.loc 1 1826 0
 10106 5728 20309DE5 		ldr	r3, [sp, #32]
 10107 572c 000050E3 		cmp	r0, #0
 10108 5730 38008DE5 		str	r0, [sp, #56]
 10109 5734 2702001A 		bne	.L850
1828:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 10110              		.loc 1 1828 0
 10111 5738 020053E3 		cmp	r3, #2
1829:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 10112              		.loc 1 1829 0
 10113 573c 28C0DBE5 		ldrb	ip, [fp, #40]	@ zero_extendqisi2
1828:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 10114              		.loc 1 1828 0
 10115 5740 7802000A 		beq	.L973
 10116              	.LVL1165:
1833:../uvc.c      **** 				 }
 10117              		.loc 1 1833 0
 10118 5744 2AE0DBE5 		ldrb	lr, [fp, #42]	@ zero_extendqisi2
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 10119              		.loc 1 1836 0
 10120 5748 30009DE5 		ldr	r0, [sp, #48]
 10121              	.LVL1166:
 10122 574c 3C308DE5 		str	r3, [sp, #60]
 10123 5750 08308DE5 		str	r3, [sp, #8]
 10124 5754 04008DE5 		str	r0, [sp, #4]
 10125 5758 0CC08DE5 		str	ip, [sp, #12]
 10126 575c 60161FE5 		ldr	r1, .L981+116
 10127 5760 00408DE5 		str	r4, [sp]
 10128 5764 10E08DE5 		str	lr, [sp, #16]
 10129 5768 0400A0E3 		mov	r0, #4
 10130 576c 2A20A0E3 		mov	r2, #42
 10131 5770 34309DE5 		ldr	r3, [sp, #52]
 10132 5774 1CC08DE5 		str	ip, [sp, #28]
1833:../uvc.c      **** 				 }
 10133              		.loc 1 1833 0
 10134 5778 28E08DE5 		str	lr, [sp, #40]
 10135              	.LVL1167:
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 10136              		.loc 1 1836 0
 10137 577c FEFFFFEB 		bl	CyU3PDebugPrint
 10138              	.LVL1168:
2047:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 10139              		.loc 1 2047 0
 10140 5780 3C109DE5 		ldr	r1, [sp, #60]
 10141 5784 1CC09DE5 		ldr	ip, [sp, #28]
 10142 5788 040051E3 		cmp	r1, #4
 10143 578c 2B03000A 		beq	.L974
 10144              	.LVL1169:
 10145              	.L855:
2064:../uvc.c      **** 				 	 			 break;
 10146              		.loc 1 2064 0
 10147 5790 7A27DAE5 		ldrb	r2, [r10, #1914]	@ zero_extendqisi2
2063:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10148              		.loc 1 2063 0
 10149 5794 3C409DE5 		ldr	r4, [sp, #60]
2064:../uvc.c      **** 				 	 			 break;
 10150              		.loc 1 2064 0
 10151 5798 7937DAE5 		ldrb	r3, [r10, #1913]	@ zero_extendqisi2
2063:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10152              		.loc 1 2063 0
 10153 579c 0400A0E3 		mov	r0, #4
 10154 57a0 1C008DE8 		stmia	sp, {r2, r3, r4}
 10155 57a4 C0161FE5 		ldr	r1, .L981+92
 10156 57a8 0C20A0E1 		mov	r2, ip
 10157 57ac 28309DE5 		ldr	r3, [sp, #40]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10158              		.loc 1 1355 0
 10159 57b0 FF40A0E3 		mov	r4, #255
2063:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10160              		.loc 1 2063 0
 10161 57b4 1CC08DE5 		str	ip, [sp, #28]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10162              		.loc 1 1355 0
 10163 57b8 0450A0E1 		mov	r5, r4
2063:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10164              		.loc 1 2063 0
 10165 57bc FEFFFFEB 		bl	CyU3PDebugPrint
 10166              	.LVL1170:
 10167 57c0 1CC09DE5 		ldr	ip, [sp, #28]
 10168 57c4 5AFFFFEA 		b	.L844
 10169              	.LVL1171:
 10170              	.L654:
 10171              	.LBE159:
 10172              	.LBE196:
 10173              	.LBE225:
 10174              	.LBE402:
 10175              	.LBB403:
 10176              	.LBB383:
 10177              	.LBB376:
 10178              	.LBB372:
1540:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 10179              		.loc 1 1540 0
 10180 57c8 0C00A0E1 		mov	r0, ip
 10181 57cc 28109DE5 		ldr	r1, [sp, #40]
 10182 57d0 20308DE5 		str	r3, [sp, #32]
 10183 57d4 FEFFFFEB 		bl	SensorGetControl
 10184              	.LVL1172:
1672:../uvc.c      **** 
 10185              		.loc 1 1672 0
 10186 57d8 20309DE5 		ldr	r3, [sp, #32]
1541:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 10187              		.loc 1 1541 0
 10188 57dc F0C61FE5 		ldr	ip, .L981+100
1553:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 10189              		.loc 1 1553 0
 10190 57e0 0020A0E3 		mov	r2, #0
1672:../uvc.c      **** 
 10191              		.loc 1 1672 0
 10192 57e4 F0161FE5 		ldr	r1, .L981+108
1553:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 10193              		.loc 1 1553 0
 10194 57e8 2920C7E5 		strb	r2, [r7, #41]
1540:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 10195              		.loc 1 1540 0
 10196 57ec 0040A0E1 		mov	r4, r0
 10197              	.LVL1173:
1672:../uvc.c      **** 
 10198              		.loc 1 1672 0
 10199 57f0 0300A0E1 		mov	r0, r3
 10200              	.LVL1174:
1541:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 10201              		.loc 1 1541 0
 10202 57f4 5545CCE5 		strb	r4, [ip, #1365]
 10203              	.LVL1175:
1552:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 10204              		.loc 1 1552 0
 10205 57f8 2840C7E5 		strb	r4, [r7, #40]
1672:../uvc.c      **** 
 10206              		.loc 1 1672 0
 10207 57fc 20308DE5 		str	r3, [sp, #32]
 10208 5800 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10209              	.LVL1176:
1675:../uvc.c      **** //#endif
 10210              		.loc 1 1675 0
 10211 5804 29C0D7E5 		ldrb	ip, [r7, #41]	@ zero_extendqisi2
 10212 5808 2B00D7E5 		ldrb	r0, [r7, #43]	@ zero_extendqisi2
 10213 580c 2C10D7E5 		ldrb	r1, [r7, #44]	@ zero_extendqisi2
 10214 5810 20309DE5 		ldr	r3, [sp, #32]
 10215 5814 03008DE8 		stmia	sp, {r0, r1}
 10216 5818 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 10217 581c 08308DE5 		str	r3, [sp, #8]
 10218 5820 0400A0E3 		mov	r0, #4
 10219 5824 0C30A0E1 		mov	r3, ip
 10220 5828 38171FE5 		ldr	r1, .L981+104
 10221 582c FEFFFFEB 		bl	CyU3PDebugPrint
 10222              	.LVL1177:
 10223 5830 00C0A0E3 		mov	ip, #0
 10224 5834 24C08DE5 		str	ip, [sp, #36]
 10225 5838 0420A0E1 		mov	r2, r4
 10226 583c FF30A0E3 		mov	r3, #255
 10227 5840 50FDFFEA 		b	.L661
 10228              	.LVL1178:
 10229              	.L658:
1758:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10230              		.loc 1 1758 0
 10231 5844 4FC5DAE5 		ldrb	ip, [r10, #1359]	@ zero_extendqisi2
 10232              	.LVL1179:
1763:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10233              		.loc 1 1763 0
 10234 5848 54171FE5 		ldr	r1, .L981+108
1759:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 10235              		.loc 1 1759 0
 10236 584c 5025DAE5 		ldrb	r2, [r10, #1360]	@ zero_extendqisi2
1763:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10237              		.loc 1 1763 0
 10238 5850 0300A0E1 		mov	r0, r3
 10239              	.LVL1180:
1760:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 10240              		.loc 1 1760 0
 10241 5854 0030A0E3 		mov	r3, #0
 10242              	.LVL1181:
1758:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10243              		.loc 1 1758 0
 10244 5858 28C0C7E5 		strb	ip, [r7, #40]
1759:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 10245              		.loc 1 1759 0
 10246 585c 2920C7E5 		strb	r2, [r7, #41]
1760:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 10247              		.loc 1 1760 0
 10248 5860 2A30C7E5 		strb	r3, [r7, #42]
1761:../uvc.c      **** 		 	 }
 10249              		.loc 1 1761 0
 10250 5864 2B30C7E5 		strb	r3, [r7, #43]
 10251              	.L923:
1817:../uvc.c      **** 		 	 }else{
 10252              		.loc 1 1817 0
 10253 5868 00C0A0E3 		mov	ip, #0
 10254 586c 24C08DE5 		str	ip, [sp, #36]
 10255 5870 0040A0E3 		mov	r4, #0
1814:../uvc.c      **** 		 	 if(Len == 2){
 10256              		.loc 1 1814 0
 10257 5874 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10258              	.LVL1182:
1816:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[1];
 10259              		.loc 1 1816 0
 10260 5878 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 10261              	.LVL1183:
1817:../uvc.c      **** 		 	 }else{
 10262              		.loc 1 1817 0
 10263 587c 2930D7E5 		ldrb	r3, [r7, #41]	@ zero_extendqisi2
 10264              	.LVL1184:
 10265 5880 24C09DE5 		ldr	ip, [sp, #36]
 10266 5884 3FFDFFEA 		b	.L661
 10267              	.LVL1185:
 10268              	.L657:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10269              		.loc 1 1372 0
 10270 5888 0020A0E3 		mov	r2, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10271              		.loc 1 1373 0
 10272 588c 0200A0E3 		mov	r0, #2
 10273 5890 9C171FE5 		ldr	r1, .L981+108
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10274              		.loc 1 1371 0
 10275 5894 2830C7E5 		strb	r3, [r7, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10276              		.loc 1 1372 0
 10277 5898 2920C7E5 		strb	r2, [r7, #41]
1374:../uvc.c      **** 			  break;
 10278              		.loc 1 1374 0
 10279 589c 0240A0E1 		mov	r4, r2
 10280 58a0 24208DE5 		str	r2, [sp, #36]
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10281              		.loc 1 1373 0
 10282 58a4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10283              	.LVL1186:
1374:../uvc.c      **** 			  break;
 10284              		.loc 1 1374 0
 10285 58a8 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 10286              	.LVL1187:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10287              		.loc 1 1355 0
 10288 58ac FF30A0E3 		mov	r3, #255
 10289 58b0 24C09DE5 		ldr	ip, [sp, #36]
 10290 58b4 33FDFFEA 		b	.L661
 10291              	.LVL1188:
 10292              	.L651:
2268:../uvc.c      **** 			  break;
 10293              		.loc 1 2268 0
 10294 58b8 0000A0E3 		mov	r0, #0
 10295 58bc 0020A0E1 		mov	r2, r0
 10296 58c0 0110A0E3 		mov	r1, #1
 10297 58c4 FEFFFFEB 		bl	CyU3PUsbStall
 10298              	.LVL1189:
 10299 58c8 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10300              		.loc 1 1355 0
 10301 58cc FF30A0E3 		mov	r3, #255
 10302 58d0 0320A0E1 		mov	r2, r3
2268:../uvc.c      **** 			  break;
 10303              		.loc 1 2268 0
 10304 58d4 24C08DE5 		str	ip, [sp, #36]
 10305 58d8 0C40A0E1 		mov	r4, ip
 10306 58dc 29FDFFEA 		b	.L661
 10307              	.LVL1190:
 10308              	.L652:
1730:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10309              		.loc 1 1730 0
 10310 58e0 F4E71FE5 		ldr	lr, .L981+100
1729:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10311              		.loc 1 1729 0
 10312 58e4 020053E3 		cmp	r3, #2
1730:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10313              		.loc 1 1730 0
 10314 58e8 4DC5DEE5 		ldrb	ip, [lr, #1357]	@ zero_extendqisi2
 10315              	.LVL1191:
1741:../uvc.c      **** 				  if(Len == 2){
 10316              		.loc 1 1741 0
 10317 58ec 0300A0E1 		mov	r0, r3
 10318              	.LVL1192:
1731:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 10319              		.loc 1 1731 0
 10320 58f0 4E25DEE5 		ldrb	r2, [lr, #1358]	@ zero_extendqisi2
1729:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10321              		.loc 1 1729 0
 10322 58f4 61FAFF1A 		bne	.L664
 10323              	.LVL1193:
 10324              	.L921:
1741:../uvc.c      **** 				  if(Len == 2){
 10325              		.loc 1 1741 0
 10326 58f8 04181FE5 		ldr	r1, .L981+108
1730:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10327              		.loc 1 1730 0
 10328 58fc 28C0C7E5 		strb	ip, [r7, #40]
1731:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 10329              		.loc 1 1731 0
 10330 5900 2920C7E5 		strb	r2, [r7, #41]
 10331 5904 7EFEFFEA 		b	.L922
 10332              	.LVL1194:
 10333              	.L694:
 10334              	.LBE372:
 10335              	.LBE376:
 10336              	.LBE383:
 10337              	.LBE403:
 10338              	.LBB404:
 10339              	.LBB364:
 10340              	.LBB330:
 10341              	.LBB273:
2504:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 10342              		.loc 1 2504 0
 10343 5908 0000A0E3 		mov	r0, #0
 10344 590c 0020A0E1 		mov	r2, r0
 10345 5910 0110A0E3 		mov	r1, #1
 10346 5914 FEFFFFEB 		bl	CyU3PUsbStall
 10347              	.LVL1195:
2505:../uvc.c      **** 			  break;
 10348              		.loc 1 2505 0
 10349 5918 24C09DE5 		ldr	ip, [sp, #36]
 10350 591c 0220A0E3 		mov	r2, #2
 10351 5920 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 10352 5924 0400A0E3 		mov	r0, #4
 10353 5928 40181FE5 		ldr	r1, .L981+96
 10354 592c FEFFFFEB 		bl	CyU3PDebugPrint
 10355              	.LVL1196:
2291:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10356              		.loc 1 2291 0
 10357 5930 FF20A0E3 		mov	r2, #255
 10358              	.LVL1197:
 10359 5934 FBFDFFEA 		b	.L772
 10360              	.LVL1198:
 10361              	.L741:
 10362              	.LBE273:
 10363              	.LBE330:
 10364              	.LBB331:
 10365              	.LBB299:
2311:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10366              		.loc 1 2311 0
 10367 5938 4CE81FE5 		ldr	lr, .L981+100
2313:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10368              		.loc 1 2313 0
 10369 593c 0030A0E3 		mov	r3, #0
2311:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10370              		.loc 1 2311 0
 10371 5940 8DC6DEE5 		ldrb	ip, [lr, #1677]	@ zero_extendqisi2
2312:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10372              		.loc 1 2312 0
 10373 5944 8E26DEE5 		ldrb	r2, [lr, #1678]	@ zero_extendqisi2
2319:../uvc.c      **** 
 10374              		.loc 1 2319 0
 10375 5948 0500A0E1 		mov	r0, r5
 10376 594c 58181FE5 		ldr	r1, .L981+108
2311:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10377              		.loc 1 2311 0
 10378 5950 28C0C7E5 		strb	ip, [r7, #40]
2312:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10379              		.loc 1 2312 0
 10380 5954 2920C7E5 		strb	r2, [r7, #41]
2313:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10381              		.loc 1 2313 0
 10382 5958 2A30C7E5 		strb	r3, [r7, #42]
2314:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 10383              		.loc 1 2314 0
 10384 595c 2B30C7E5 		strb	r3, [r7, #43]
 10385              	.LVL1199:
2319:../uvc.c      **** 
 10386              		.loc 1 2319 0
 10387 5960 1CC08DE5 		str	ip, [sp, #28]
 10388 5964 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10389              	.LVL1200:
2291:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10390              		.loc 1 2291 0
 10391 5968 FF20A0E3 		mov	r2, #255
 10392 596c 0230A0E1 		mov	r3, r2
 10393 5970 1CC09DE5 		ldr	ip, [sp, #28]
 10394 5974 5EFCFFEA 		b	.L748
 10395              	.LVL1201:
 10396              	.L730:
 10397              	.LBE299:
 10398              	.LBE331:
 10399              	.LBB332:
 10400              	.LBB283:
2311:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10401              		.loc 1 2311 0
 10402 5978 8CC81FE5 		ldr	ip, .L981+100
 10403 597c 7526DCE5 		ldrb	r2, [ip, #1653]	@ zero_extendqisi2
2312:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10404              		.loc 1 2312 0
 10405 5980 7616DCE5 		ldrb	r1, [ip, #1654]	@ zero_extendqisi2
 10406              	.LVL1202:
 10407              	.L939:
 10408              	.LBE283:
 10409              	.LBE332:
 10410              	.LBB333:
 10411              	.LBB256:
2313:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10412              		.loc 1 2313 0
 10413 5984 0030A0E3 		mov	r3, #0
2312:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10414              		.loc 1 2312 0
 10415 5988 2910C7E5 		strb	r1, [r7, #41]
2319:../uvc.c      **** 
 10416              		.loc 1 2319 0
 10417 598c 0500A0E1 		mov	r0, r5
 10418 5990 9C181FE5 		ldr	r1, .L981+108
2311:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10419              		.loc 1 2311 0
 10420 5994 2820C7E5 		strb	r2, [r7, #40]
2319:../uvc.c      **** 
 10421              		.loc 1 2319 0
 10422 5998 20208DE5 		str	r2, [sp, #32]
2313:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10423              		.loc 1 2313 0
 10424 599c 2A30C7E5 		strb	r3, [r7, #42]
2314:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 10425              		.loc 1 2314 0
 10426 59a0 2B30C7E5 		strb	r3, [r7, #43]
 10427              	.LVL1203:
2319:../uvc.c      **** 
 10428              		.loc 1 2319 0
 10429 59a4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10430              	.LVL1204:
 10431 59a8 20209DE5 		ldr	r2, [sp, #32]
 10432 59ac DDFDFFEA 		b	.L772
 10433              	.LVL1205:
 10434              	.L697:
 10435              	.LBE256:
 10436              	.LBE333:
 10437              	.LBB334:
 10438              	.LBB274:
2311:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10439              		.loc 1 2311 0
 10440 59b0 C4C81FE5 		ldr	ip, .L981+100
 10441 59b4 1526DCE5 		ldrb	r2, [ip, #1557]	@ zero_extendqisi2
2312:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10442              		.loc 1 2312 0
 10443 59b8 1616DCE5 		ldrb	r1, [ip, #1558]	@ zero_extendqisi2
 10444 59bc F0FFFFEA 		b	.L939
 10445              	.LVL1206:
 10446              	.L738:
 10447              	.LBE274:
 10448              	.LBE334:
 10449              	.LBB335:
 10450              	.LBB300:
2504:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 10451              		.loc 1 2504 0
 10452 59c0 0000A0E3 		mov	r0, #0
 10453 59c4 0020A0E1 		mov	r2, r0
 10454 59c8 0110A0E3 		mov	r1, #1
 10455 59cc FEFFFFEB 		bl	CyU3PUsbStall
 10456              	.LVL1207:
2505:../uvc.c      **** 			  break;
 10457              		.loc 1 2505 0
 10458 59d0 24C09DE5 		ldr	ip, [sp, #36]
 10459 59d4 0720A0E3 		mov	r2, #7
 10460 59d8 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 10461 59dc 0400A0E3 		mov	r0, #4
2291:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10462              		.loc 1 2291 0
 10463 59e0 FFC0A0E3 		mov	ip, #255
2505:../uvc.c      **** 			  break;
 10464              		.loc 1 2505 0
 10465 59e4 FC181FE5 		ldr	r1, .L981+96
 10466 59e8 1CC08DE5 		str	ip, [sp, #28]
 10467 59ec FEFFFFEB 		bl	CyU3PDebugPrint
 10468              	.LVL1208:
2291:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10469              		.loc 1 2291 0
 10470 59f0 1CC09DE5 		ldr	ip, [sp, #28]
 10471 59f4 0C20A0E1 		mov	r2, ip
 10472 59f8 0C30A0E1 		mov	r3, ip
 10473 59fc 3CFCFFEA 		b	.L748
 10474              	.LVL1209:
 10475              	.L765:
 10476              	.LBE300:
 10477              	.LBE335:
 10478              	.LBB336:
 10479              	.LBB257:
2311:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10480              		.loc 1 2311 0
 10481 5a00 14C91FE5 		ldr	ip, .L981+100
 10482 5a04 BD26DCE5 		ldrb	r2, [ip, #1725]	@ zero_extendqisi2
2312:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10483              		.loc 1 2312 0
 10484 5a08 BE16DCE5 		ldrb	r1, [ip, #1726]	@ zero_extendqisi2
 10485 5a0c DCFFFFEA 		b	.L939
 10486              	.LVL1210:
 10487              	.L690:
 10488              	.LBE257:
 10489              	.LBE336:
 10490              	.LBB337:
 10491              	.LBB265:
2344:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10492              		.loc 1 2344 0
 10493 5a10 24291FE5 		ldr	r2, .L981+100
 10494 5a14 DF15D2E5 		ldrb	r1, [r2, #1503]	@ zero_extendqisi2
2345:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10495              		.loc 1 2345 0
 10496 5a18 E025D2E5 		ldrb	r2, [r2, #1504]	@ zero_extendqisi2
 10497 5a1c CCFBFFEA 		b	.L931
 10498              	.LVL1211:
 10499              	.L706:
 10500              	.LBE265:
 10501              	.LBE337:
 10502              	.LBB338:
 10503              	.LBB236:
2335:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10504              		.loc 1 2335 0
 10505 5a20 34E91FE5 		ldr	lr, .L981+100
 10506 5a24 3D16DEE5 		ldrb	r1, [lr, #1597]	@ zero_extendqisi2
2336:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10507              		.loc 1 2336 0
 10508 5a28 3E26DEE5 		ldrb	r2, [lr, #1598]	@ zero_extendqisi2
 10509 5a2c C8FBFFEA 		b	.L931
 10510              	.LVL1212:
 10511              	.L763:
 10512              	.LBE236:
 10513              	.LBE338:
 10514              	.LBB339:
 10515              	.LBB258:
2335:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10516              		.loc 1 2335 0
 10517 5a30 44091FE5 		ldr	r0, .L981+100
 10518 5a34 B516D0E5 		ldrb	r1, [r0, #1717]	@ zero_extendqisi2
2336:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10519              		.loc 1 2336 0
 10520 5a38 B626D0E5 		ldrb	r2, [r0, #1718]	@ zero_extendqisi2
 10521 5a3c C4FBFFEA 		b	.L931
 10522              	.LVL1213:
 10523              	.L739:
 10524              	.LBE258:
 10525              	.LBE339:
 10526              	.LBB340:
 10527              	.LBB301:
2335:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10528              		.loc 1 2335 0
 10529 5a40 54291FE5 		ldr	r2, .L981+100
 10530 5a44 8516D2E5 		ldrb	r1, [r2, #1669]	@ zero_extendqisi2
2336:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10531              		.loc 1 2336 0
 10532 5a48 8626D2E5 		ldrb	r2, [r2, #1670]	@ zero_extendqisi2
 10533 5a4c 1DFCFFEA 		b	.L929
 10534              	.LVL1214:
 10535              	.L684:
 10536              	.LBE301:
 10537              	.LBE340:
 10538              	.LBB341:
 10539              	.LBB266:
2335:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10540              		.loc 1 2335 0
 10541 5a50 64091FE5 		ldr	r0, .L981+100
 10542 5a54 DD15D0E5 		ldrb	r1, [r0, #1501]	@ zero_extendqisi2
2336:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10543              		.loc 1 2336 0
 10544 5a58 DE25D0E5 		ldrb	r2, [r0, #1502]	@ zero_extendqisi2
 10545 5a5c BCFBFFEA 		b	.L931
 10546              	.LVL1215:
 10547              	.L695:
 10548              	.LBE266:
 10549              	.LBE341:
 10550              	.LBB342:
 10551              	.LBB275:
2335:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10552              		.loc 1 2335 0
 10553 5a60 74091FE5 		ldr	r0, .L981+100
 10554 5a64 0D16D0E5 		ldrb	r1, [r0, #1549]	@ zero_extendqisi2
2336:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10555              		.loc 1 2336 0
 10556 5a68 0E26D0E5 		ldrb	r2, [r0, #1550]	@ zero_extendqisi2
 10557 5a6c B8FBFFEA 		b	.L931
 10558              	.LVL1216:
 10559              	.L728:
 10560              	.LBE275:
 10561              	.LBE342:
 10562              	.LBB343:
 10563              	.LBB284:
2335:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10564              		.loc 1 2335 0
 10565 5a70 84091FE5 		ldr	r0, .L981+100
 10566 5a74 6D16D0E5 		ldrb	r1, [r0, #1645]	@ zero_extendqisi2
2336:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10567              		.loc 1 2336 0
 10568 5a78 6E26D0E5 		ldrb	r2, [r0, #1646]	@ zero_extendqisi2
 10569 5a7c B4FBFFEA 		b	.L931
 10570              	.LVL1217:
 10571              	.L717:
 10572              	.LBE284:
 10573              	.LBE343:
 10574              	.LBB344:
 10575              	.LBB244:
2335:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10576              		.loc 1 2335 0
 10577 5a80 94091FE5 		ldr	r0, .L981+100
 10578 5a84 5516D0E5 		ldrb	r1, [r0, #1621]	@ zero_extendqisi2
2336:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10579              		.loc 1 2336 0
 10580 5a88 5626D0E5 		ldrb	r2, [r0, #1622]	@ zero_extendqisi2
 10581 5a8c B0FBFFEA 		b	.L931
 10582              	.LVL1218:
 10583              	.L769:
 10584              	.LBE244:
 10585              	.LBE344:
 10586              	.LBB345:
 10587              	.LBB259:
2344:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10588              		.loc 1 2344 0
 10589 5a90 A4291FE5 		ldr	r2, .L981+100
 10590 5a94 B716D2E5 		ldrb	r1, [r2, #1719]	@ zero_extendqisi2
2345:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10591              		.loc 1 2345 0
 10592 5a98 B826D2E5 		ldrb	r2, [r2, #1720]	@ zero_extendqisi2
 10593 5a9c ACFBFFEA 		b	.L931
 10594              	.LVL1219:
 10595              	.L712:
 10596              	.LBE259:
 10597              	.LBE345:
 10598              	.LBB346:
 10599              	.LBB237:
2344:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10600              		.loc 1 2344 0
 10601 5aa0 3F16DAE5 		ldrb	r1, [r10, #1599]	@ zero_extendqisi2
2345:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10602              		.loc 1 2345 0
 10603 5aa4 4026DAE5 		ldrb	r2, [r10, #1600]	@ zero_extendqisi2
 10604 5aa8 A9FBFFEA 		b	.L931
 10605              	.LVL1220:
 10606              	.L752:
 10607              	.LBE237:
 10608              	.LBE346:
 10609              	.LBB347:
 10610              	.LBB291:
2335:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10611              		.loc 1 2335 0
 10612 5aac C0C91FE5 		ldr	ip, .L981+100
 10613 5ab0 9D16DCE5 		ldrb	r1, [ip, #1693]	@ zero_extendqisi2
2336:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10614              		.loc 1 2336 0
 10615 5ab4 9E26DCE5 		ldrb	r2, [ip, #1694]	@ zero_extendqisi2
 10616 5ab8 A5FBFFEA 		b	.L931
 10617              	.LVL1221:
 10618              	.L686:
 10619              	.LBE291:
 10620              	.LBE347:
 10621              	.LBB348:
 10622              	.LBB267:
2311:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10623              		.loc 1 2311 0
 10624 5abc D0C91FE5 		ldr	ip, .L981+100
 10625 5ac0 E525DCE5 		ldrb	r2, [ip, #1509]	@ zero_extendqisi2
2312:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10626              		.loc 1 2312 0
 10627 5ac4 E615DCE5 		ldrb	r1, [ip, #1510]	@ zero_extendqisi2
 10628 5ac8 ADFFFFEA 		b	.L939
 10629              	.LVL1222:
 10630              	.L708:
 10631              	.LBE267:
 10632              	.LBE348:
 10633              	.LBB349:
 10634              	.LBB238:
2311:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10635              		.loc 1 2311 0
 10636 5acc E0C91FE5 		ldr	ip, .L981+100
 10637 5ad0 4526DCE5 		ldrb	r2, [ip, #1605]	@ zero_extendqisi2
2312:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10638              		.loc 1 2312 0
 10639 5ad4 4616DCE5 		ldrb	r1, [ip, #1606]	@ zero_extendqisi2
 10640 5ad8 A9FFFFEA 		b	.L939
 10641              	.LVL1223:
 10642              	.L745:
 10643              	.LBE238:
 10644              	.LBE349:
 10645              	.LBB350:
 10646              	.LBB302:
2344:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10647              		.loc 1 2344 0
 10648 5adc F0391FE5 		ldr	r3, .L981+100
 10649 5ae0 8716D3E5 		ldrb	r1, [r3, #1671]	@ zero_extendqisi2
2345:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10650              		.loc 1 2345 0
 10651 5ae4 8826D3E5 		ldrb	r2, [r3, #1672]	@ zero_extendqisi2
 10652 5ae8 F6FBFFEA 		b	.L929
 10653              	.L744:
2302:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10654              		.loc 1 2302 0
 10655 5aec 0030A0E3 		mov	r3, #0
2303:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10656              		.loc 1 2303 0
 10657 5af0 0200A0E3 		mov	r0, #2
 10658 5af4 001A1FE5 		ldr	r1, .L981+108
2302:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10659              		.loc 1 2302 0
 10660 5af8 2930C7E5 		strb	r3, [r7, #41]
2301:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10661              		.loc 1 2301 0
 10662 5afc 2850C7E5 		strb	r5, [r7, #40]
2303:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10663              		.loc 1 2303 0
 10664 5b00 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10665              	.LVL1224:
2291:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10666              		.loc 1 2291 0
 10667 5b04 FF20A0E3 		mov	r2, #255
 10668 5b08 0230A0E1 		mov	r3, r2
2304:../uvc.c      **** 			  break;
 10669              		.loc 1 2304 0
 10670 5b0c 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 10671              	.LVL1225:
 10672 5b10 F7FBFFEA 		b	.L748
 10673              	.LVL1226:
 10674              	.L716:
 10675              	.LBE302:
 10676              	.LBE350:
 10677              	.LBB351:
 10678              	.LBB245:
2504:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 10679              		.loc 1 2504 0
 10680 5b14 0000A0E3 		mov	r0, #0
 10681 5b18 0020A0E1 		mov	r2, r0
 10682 5b1c 0110A0E3 		mov	r1, #1
 10683 5b20 FEFFFFEB 		bl	CyU3PUsbStall
 10684              	.LVL1227:
2505:../uvc.c      **** 			  break;
 10685              		.loc 1 2505 0
 10686 5b24 24C09DE5 		ldr	ip, [sp, #36]
 10687 5b28 0520A0E3 		mov	r2, #5
 10688 5b2c 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 10689 5b30 0400A0E3 		mov	r0, #4
 10690 5b34 4C1A1FE5 		ldr	r1, .L981+96
 10691 5b38 FEFFFFEB 		bl	CyU3PDebugPrint
 10692              	.LVL1228:
2291:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10693              		.loc 1 2291 0
 10694 5b3c FF20A0E3 		mov	r2, #255
 10695              	.LVL1229:
 10696 5b40 78FDFFEA 		b	.L772
 10697              	.LVL1230:
 10698              	.L734:
 10699              	.LBE245:
 10700              	.LBE351:
 10701              	.LBB352:
 10702              	.LBB285:
2344:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10703              		.loc 1 2344 0
 10704 5b44 582A1FE5 		ldr	r2, .L981+100
 10705 5b48 6F16D2E5 		ldrb	r1, [r2, #1647]	@ zero_extendqisi2
2345:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10706              		.loc 1 2345 0
 10707 5b4c 7026D2E5 		ldrb	r2, [r2, #1648]	@ zero_extendqisi2
 10708 5b50 7FFBFFEA 		b	.L931
 10709              	.LVL1231:
 10710              	.L758:
 10711              	.LBE285:
 10712              	.LBE352:
 10713              	.LBB353:
 10714              	.LBB292:
2344:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10715              		.loc 1 2344 0
 10716 5b54 9F16DAE5 		ldrb	r1, [r10, #1695]	@ zero_extendqisi2
2345:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10717              		.loc 1 2345 0
 10718 5b58 A026DAE5 		ldrb	r2, [r10, #1696]	@ zero_extendqisi2
 10719 5b5c 7CFBFFEA 		b	.L931
 10720              	.LVL1232:
 10721              	.L701:
 10722              	.LBE292:
 10723              	.LBE353:
 10724              	.LBB354:
 10725              	.LBB276:
2344:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10726              		.loc 1 2344 0
 10727 5b60 742A1FE5 		ldr	r2, .L981+100
 10728 5b64 0F16D2E5 		ldrb	r1, [r2, #1551]	@ zero_extendqisi2
2345:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10729              		.loc 1 2345 0
 10730 5b68 1026D2E5 		ldrb	r2, [r2, #1552]	@ zero_extendqisi2
 10731 5b6c 78FBFFEA 		b	.L931
 10732              	.LVL1233:
 10733              	.L723:
 10734              	.LBE276:
 10735              	.LBE354:
 10736              	.LBB355:
 10737              	.LBB246:
2344:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10738              		.loc 1 2344 0
 10739 5b70 842A1FE5 		ldr	r2, .L981+100
 10740 5b74 5716D2E5 		ldrb	r1, [r2, #1623]	@ zero_extendqisi2
2345:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10741              		.loc 1 2345 0
 10742 5b78 5826D2E5 		ldrb	r2, [r2, #1624]	@ zero_extendqisi2
 10743 5b7c 74FBFFEA 		b	.L931
 10744              	.LVL1234:
 10745              	.L754:
 10746              	.LBE246:
 10747              	.LBE355:
 10748              	.LBB356:
 10749              	.LBB293:
2311:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10750              		.loc 1 2311 0
 10751 5b80 A526DAE5 		ldrb	r2, [r10, #1701]	@ zero_extendqisi2
2312:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10752              		.loc 1 2312 0
 10753 5b84 A616DAE5 		ldrb	r1, [r10, #1702]	@ zero_extendqisi2
 10754 5b88 7DFFFFEA 		b	.L939
 10755              	.LVL1235:
 10756              	.L719:
 10757              	.LBE293:
 10758              	.LBE356:
 10759              	.LBB357:
 10760              	.LBB247:
2311:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10761              		.loc 1 2311 0
 10762 5b8c A0CA1FE5 		ldr	ip, .L981+100
 10763 5b90 5D26DCE5 		ldrb	r2, [ip, #1629]	@ zero_extendqisi2
2312:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10764              		.loc 1 2312 0
 10765 5b94 5E16DCE5 		ldrb	r1, [ip, #1630]	@ zero_extendqisi2
 10766 5b98 79FFFFEA 		b	.L939
 10767              	.LVL1236:
 10768              	.L859:
 10769              	.LBE247:
 10770              	.LBE357:
 10771              	.LBE364:
 10772              	.LBE404:
 10773              	.LBB405:
 10774              	.LBB226:
 10775              	.LBB197:
 10776              	.LBB182:
1717:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10777              		.loc 1 1717 0
 10778 5b9c B0EA1FE5 		ldr	lr, .L981+100
1716:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10779              		.loc 1 1716 0
 10780 5ba0 020053E3 		cmp	r3, #2
1717:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10781              		.loc 1 1717 0
 10782 5ba4 85C7DEE5 		ldrb	ip, [lr, #1925]	@ zero_extendqisi2
1741:../uvc.c      **** 				  if(Len == 2){
 10783              		.loc 1 1741 0
 10784 5ba8 0300A0E1 		mov	r0, r3
1718:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10785              		.loc 1 1718 0
 10786 5bac 8627DEE5 		ldrb	r2, [lr, #1926]	@ zero_extendqisi2
1716:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10787              		.loc 1 1716 0
 10788 5bb0 0401000A 		beq	.L937
 10789              	.LVL1237:
1723:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10790              		.loc 1 1723 0
 10791 5bb4 0030A0E3 		mov	r3, #0
1747:../uvc.c      **** 				  }
 10792              		.loc 1 1747 0
 10793 5bb8 0340A0E1 		mov	r4, r3
 10794              	.LVL1238:
1741:../uvc.c      **** 				  if(Len == 2){
 10795              		.loc 1 1741 0
 10796 5bbc C81A1FE5 		ldr	r1, .L981+108
1722:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 10797              		.loc 1 1722 0
 10798 5bc0 28C0C7E5 		strb	ip, [r7, #40]
1724:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10799              		.loc 1 1724 0
 10800 5bc4 2A20C7E5 		strb	r2, [r7, #42]
1723:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10801              		.loc 1 1723 0
 10802 5bc8 2930C7E5 		strb	r3, [r7, #41]
1725:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10803              		.loc 1 1725 0
 10804 5bcc 2B30C7E5 		strb	r3, [r7, #43]
1747:../uvc.c      **** 				  }
 10805              		.loc 1 1747 0
 10806 5bd0 28308DE5 		str	r3, [sp, #40]
1741:../uvc.c      **** 				  if(Len == 2){
 10807              		.loc 1 1741 0
 10808 5bd4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10809              	.LVL1239:
1747:../uvc.c      **** 				  }
 10810              		.loc 1 1747 0
 10811 5bd8 04C0A0E1 		mov	ip, r4
1746:../uvc.c      **** 					  sendData1 = glEp0Buffer[2];
 10812              		.loc 1 1746 0
 10813 5bdc 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 10814              	.LVL1240:
1747:../uvc.c      **** 				  }
 10815              		.loc 1 1747 0
 10816 5be0 2A40D7E5 		ldrb	r4, [r7, #42]	@ zero_extendqisi2
 10817              	.LVL1241:
 10818 5be4 37FEFFEA 		b	.L868
 10819              	.LVL1242:
 10820              	.L749:
 10821              	.LBE182:
 10822              	.LBE197:
 10823              	.LBE226:
 10824              	.LBE405:
 10825              	.LBB406:
 10826              	.LBB365:
 10827              	.LBB358:
 10828              	.LBB303:
2472:../uvc.c      **** 					  }
 10829              		.loc 1 2472 0
 10830 5be8 0020A0E1 		mov	r2, r0
 10831 5bec 0410A0E1 		mov	r1, r4
 10832 5bf0 FEFFFFEB 		bl	CyU3PUsbStall
 10833              	.LVL1243:
 10834 5bf4 21FDFFEA 		b	.L750
 10835              	.LVL1244:
 10836              	.L835:
 10837              	.LBE303:
 10838              	.LBE358:
 10839              	.LBE365:
 10840              	.LBE406:
 10841              	.LBB407:
 10842              	.LBB227:
 10843              	.LBB198:
 10844              	.LBB160:
1716:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10845              		.loc 1 1716 0
 10846 5bf8 020053E3 		cmp	r3, #2
1722:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 10847              		.loc 1 1722 0
 10848 5bfc 71C7DA15 		ldrneb	ip, [r10, #1905]	@ zero_extendqisi2
1741:../uvc.c      **** 				  if(Len == 2){
 10849              		.loc 1 1741 0
 10850 5c00 0300A011 		movne	r0, r3
1724:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10851              		.loc 1 1724 0
 10852 5c04 7227DA15 		ldrneb	r2, [r10, #1906]	@ zero_extendqisi2
1716:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10853              		.loc 1 1716 0
 10854 5c08 DAFAFF1A 		bne	.L849
1717:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10855              		.loc 1 1717 0
 10856 5c0c 7127DAE5 		ldrb	r2, [r10, #1905]	@ zero_extendqisi2
1718:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10857              		.loc 1 1718 0
 10858 5c10 7237DAE5 		ldrb	r3, [r10, #1906]	@ zero_extendqisi2
 10859              	.LVL1245:
1741:../uvc.c      **** 				  if(Len == 2){
 10860              		.loc 1 1741 0
 10861 5c14 0200A0E3 		mov	r0, #2
 10862 5c18 241B1FE5 		ldr	r1, .L981+108
1717:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10863              		.loc 1 1717 0
 10864 5c1c 2820C7E5 		strb	r2, [r7, #40]
1718:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10865              		.loc 1 1718 0
 10866 5c20 2930C7E5 		strb	r3, [r7, #41]
 10867 5c24 160000EA 		b	.L935
 10868              	.LVL1246:
 10869              	.L842:
1770:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 10870              		.loc 1 1770 0
 10871 5c28 7527DAE5 		ldrb	r2, [r10, #1909]	@ zero_extendqisi2
1771:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10872              		.loc 1 1771 0
 10873 5c2c 0030A0E3 		mov	r3, #0
 10874              	.LVL1247:
1782:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 10875              		.loc 1 1782 0
 10876 5c30 0100A0E3 		mov	r0, #1
 10877 5c34 401B1FE5 		ldr	r1, .L981+108
1770:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 10878              		.loc 1 1770 0
 10879 5c38 2820C7E5 		strb	r2, [r7, #40]
1771:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10880              		.loc 1 1771 0
 10881 5c3c 2930C7E5 		strb	r3, [r7, #41]
1772:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 10882              		.loc 1 1772 0
 10883 5c40 2A30C7E5 		strb	r3, [r7, #42]
1773:../uvc.c      **** 		 	 }
 10884              		.loc 1 1773 0
 10885 5c44 2B30C7E5 		strb	r3, [r7, #43]
 10886              	.LVL1248:
1784:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
 10887              		.loc 1 1784 0
 10888 5c48 28308DE5 		str	r3, [sp, #40]
1782:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 10889              		.loc 1 1782 0
 10890 5c4c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10891              	.LVL1249:
1784:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
 10892              		.loc 1 1784 0
 10893 5c50 00C0A0E3 		mov	ip, #0
1783:../uvc.c      **** 		 	 sendData1 = glEp0Buffer[1];
 10894              		.loc 1 1783 0
 10895 5c54 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 10896              	.LVL1250:
1784:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
 10897              		.loc 1 1784 0
 10898 5c58 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
 10899              	.LVL1251:
 10900 5c5c 34FEFFEA 		b	.L844
 10901              	.LVL1252:
 10902              	.L841:
1752:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10903              		.loc 1 1752 0
 10904 5c60 73C7DAE5 		ldrb	ip, [r10, #1907]	@ zero_extendqisi2
1763:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10905              		.loc 1 1763 0
 10906 5c64 701B1FE5 		ldr	r1, .L981+108
1753:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10907              		.loc 1 1753 0
 10908 5c68 7427DAE5 		ldrb	r2, [r10, #1908]	@ zero_extendqisi2
1763:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10909              		.loc 1 1763 0
 10910 5c6c 0300A0E1 		mov	r0, r3
1754:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 10911              		.loc 1 1754 0
 10912 5c70 0030A0E3 		mov	r3, #0
 10913              	.LVL1253:
1752:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10914              		.loc 1 1752 0
 10915 5c74 28C0C7E5 		strb	ip, [r7, #40]
1753:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10916              		.loc 1 1753 0
 10917 5c78 2920C7E5 		strb	r2, [r7, #41]
1754:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 10918              		.loc 1 1754 0
 10919 5c7c 2A30C7E5 		strb	r3, [r7, #42]
1755:../uvc.c      **** 		 	 }
 10920              		.loc 1 1755 0
 10921 5c80 2B30C7E5 		strb	r3, [r7, #43]
 10922              	.LVL1254:
 10923              	.L935:
1744:../uvc.c      **** 				  }else{
 10924              		.loc 1 1744 0
 10925 5c84 0040A0E3 		mov	r4, #0
 10926 5c88 28408DE5 		str	r4, [sp, #40]
1741:../uvc.c      **** 				  if(Len == 2){
 10927              		.loc 1 1741 0
 10928 5c8c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10929              	.LVL1255:
1744:../uvc.c      **** 				  }else{
 10930              		.loc 1 1744 0
 10931 5c90 04C0A0E1 		mov	ip, r4
1743:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 10932              		.loc 1 1743 0
 10933 5c94 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 10934              	.LVL1256:
1744:../uvc.c      **** 				  }else{
 10935              		.loc 1 1744 0
 10936 5c98 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
 10937              	.LVL1257:
 10938 5c9c 24FEFFEA 		b	.L844
 10939              	.LVL1258:
 10940              	.L814:
 10941              	.LBE160:
 10942              	.LBE198:
 10943              	.LBB199:
 10944              	.LBB172:
1680:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 10945              		.loc 1 1680 0
 10946 5ca0 020053E3 		cmp	r3, #2
1681:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 10947              		.loc 1 1681 0
 10948 5ca4 5BC7DAE5 		ldrb	ip, [r10, #1883]	@ zero_extendqisi2
1705:../uvc.c      **** 		 	 if(Len == 2){
 10949              		.loc 1 1705 0
 10950 5ca8 0300A0E1 		mov	r0, r3
1682:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10951              		.loc 1 1682 0
 10952 5cac 5C27DAE5 		ldrb	r2, [r10, #1884]	@ zero_extendqisi2
1680:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 10953              		.loc 1 1680 0
 10954 5cb0 E5FBFF1A 		bne	.L825
 10955              	.LVL1259:
 10956              	.L934:
1705:../uvc.c      **** 		 	 if(Len == 2){
 10957              		.loc 1 1705 0
 10958 5cb4 C01B1FE5 		ldr	r1, .L981+108
1681:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 10959              		.loc 1 1681 0
 10960 5cb8 28C0C7E5 		strb	ip, [r7, #40]
1682:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10961              		.loc 1 1682 0
 10962 5cbc 2920C7E5 		strb	r2, [r7, #41]
 10963 5cc0 980000EA 		b	.L932
 10964              	.LVL1260:
 10965              	.L813:
1498:../uvc.c      **** 			 	 			 {
 10966              		.loc 1 1498 0
 10967 5cc4 020053E3 		cmp	r3, #2
 10968 5cc8 A301000A 		beq	.L975
1506:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 10969              		.loc 1 1506 0
 10970 5ccc 040053E3 		cmp	r3, #4
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10971              		.loc 1 1355 0
 10972 5cd0 FF50A013 		movne	r5, #255
 10973 5cd4 05C0A011 		movne	ip, r5
1506:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 10974              		.loc 1 1506 0
 10975 5cd8 8C01000A 		beq	.L976
 10976              	.LVL1261:
 10977              	.L822:
1672:../uvc.c      **** 
 10978              		.loc 1 1672 0
 10979 5cdc 0300A0E1 		mov	r0, r3
 10980 5ce0 EC1B1FE5 		ldr	r1, .L981+108
 10981 5ce4 1CC08DE5 		str	ip, [sp, #28]
 10982 5ce8 20308DE5 		str	r3, [sp, #32]
 10983 5cec FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10984              	.LVL1262:
1675:../uvc.c      **** //#endif
 10985              		.loc 1 1675 0
 10986 5cf0 2B00D7E5 		ldrb	r0, [r7, #43]	@ zero_extendqisi2
 10987 5cf4 2C10D7E5 		ldrb	r1, [r7, #44]	@ zero_extendqisi2
 10988 5cf8 20309DE5 		ldr	r3, [sp, #32]
 10989 5cfc 29E0D7E5 		ldrb	lr, [r7, #41]	@ zero_extendqisi2
 10990 5d00 03008DE8 		stmia	sp, {r0, r1}
 10991 5d04 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 10992 5d08 08308DE5 		str	r3, [sp, #8]
 10993 5d0c 0400A0E3 		mov	r0, #4
 10994 5d10 0E30A0E1 		mov	r3, lr
 10995 5d14 241C1FE5 		ldr	r1, .L981+104
 10996 5d18 FEFFFFEB 		bl	CyU3PDebugPrint
 10997              	.LVL1263:
 10998 5d1c 0040A0E3 		mov	r4, #0
 10999 5d20 24408DE5 		str	r4, [sp, #36]
 11000 5d24 1CC09DE5 		ldr	ip, [sp, #28]
 11001 5d28 D6FDFFEA 		b	.L820
 11002              	.LVL1264:
 11003              	.L810:
2268:../uvc.c      **** 			  break;
 11004              		.loc 1 2268 0
 11005 5d2c 0000A0E3 		mov	r0, #0
 11006 5d30 0020A0E1 		mov	r2, r0
 11007 5d34 0110A0E3 		mov	r1, #1
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11008              		.loc 1 1355 0
 11009 5d38 FF50A0E3 		mov	r5, #255
2268:../uvc.c      **** 			  break;
 11010              		.loc 1 2268 0
 11011 5d3c 0040A0E3 		mov	r4, #0
 11012 5d40 FEFFFFEB 		bl	CyU3PUsbStall
 11013              	.LVL1265:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11014              		.loc 1 1355 0
 11015 5d44 05C0A0E1 		mov	ip, r5
2268:../uvc.c      **** 			  break;
 11016              		.loc 1 2268 0
 11017 5d48 24408DE5 		str	r4, [sp, #36]
 11018 5d4c CDFDFFEA 		b	.L820
 11019              	.LVL1266:
 11020              	.L858:
 11021              	.LBE172:
 11022              	.LBE199:
 11023              	.LBB200:
 11024              	.LBB183:
 11025 5d50 0000A0E3 		mov	r0, #0
 11026 5d54 0020A0E1 		mov	r2, r0
 11027 5d58 0110A0E3 		mov	r1, #1
 11028 5d5c FEFFFFEB 		bl	CyU3PUsbStall
 11029              	.LVL1267:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11030              		.loc 1 1355 0
 11031 5d60 FF40A0E3 		mov	r4, #255
2268:../uvc.c      **** 			  break;
 11032              		.loc 1 2268 0
 11033 5d64 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11034              		.loc 1 1355 0
 11035 5d68 0450A0E1 		mov	r5, r4
2268:../uvc.c      **** 			  break;
 11036              		.loc 1 2268 0
 11037 5d6c 28C08DE5 		str	ip, [sp, #40]
 11038 5d70 D4FDFFEA 		b	.L868
 11039              	.LVL1268:
 11040              	.L866:
1770:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 11041              		.loc 1 1770 0
 11042 5d74 8927DAE5 		ldrb	r2, [r10, #1929]	@ zero_extendqisi2
1771:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11043              		.loc 1 1771 0
 11044 5d78 0030A0E3 		mov	r3, #0
 11045              	.LVL1269:
1782:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 11046              		.loc 1 1782 0
 11047 5d7c 0100A0E3 		mov	r0, #1
 11048 5d80 8C1C1FE5 		ldr	r1, .L981+108
1770:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 11049              		.loc 1 1770 0
 11050 5d84 2820C7E5 		strb	r2, [r7, #40]
1771:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11051              		.loc 1 1771 0
 11052 5d88 2930C7E5 		strb	r3, [r7, #41]
1772:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11053              		.loc 1 1772 0
 11054 5d8c 2A30C7E5 		strb	r3, [r7, #42]
1773:../uvc.c      **** 		 	 }
 11055              		.loc 1 1773 0
 11056 5d90 2B30C7E5 		strb	r3, [r7, #43]
 11057              	.LVL1270:
1784:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
 11058              		.loc 1 1784 0
 11059 5d94 28308DE5 		str	r3, [sp, #40]
1782:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 11060              		.loc 1 1782 0
 11061 5d98 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11062              	.LVL1271:
1784:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
 11063              		.loc 1 1784 0
 11064 5d9c 00C0A0E3 		mov	ip, #0
1783:../uvc.c      **** 		 	 sendData1 = glEp0Buffer[1];
 11065              		.loc 1 1783 0
 11066 5da0 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 11067              	.LVL1272:
1784:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
 11068              		.loc 1 1784 0
 11069 5da4 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
 11070              	.LVL1273:
 11071 5da8 C6FDFFEA 		b	.L868
 11072              	.LVL1274:
 11073              	.L865:
1752:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11074              		.loc 1 1752 0
 11075 5dac C0EC1FE5 		ldr	lr, .L981+100
1763:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11076              		.loc 1 1763 0
 11077 5db0 BC1C1FE5 		ldr	r1, .L981+108
1752:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11078              		.loc 1 1752 0
 11079 5db4 87C7DEE5 		ldrb	ip, [lr, #1927]	@ zero_extendqisi2
1753:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11080              		.loc 1 1753 0
 11081 5db8 8827DEE5 		ldrb	r2, [lr, #1928]	@ zero_extendqisi2
1763:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11082              		.loc 1 1763 0
 11083 5dbc 0300A0E1 		mov	r0, r3
1754:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11084              		.loc 1 1754 0
 11085 5dc0 0030A0E3 		mov	r3, #0
 11086              	.LVL1275:
1752:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11087              		.loc 1 1752 0
 11088 5dc4 28C0C7E5 		strb	ip, [r7, #40]
1753:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11089              		.loc 1 1753 0
 11090 5dc8 2920C7E5 		strb	r2, [r7, #41]
1754:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11091              		.loc 1 1754 0
 11092 5dcc 2A30C7E5 		strb	r3, [r7, #42]
1755:../uvc.c      **** 		 	 }
 11093              		.loc 1 1755 0
 11094 5dd0 2B30C7E5 		strb	r3, [r7, #43]
 11095              	.LVL1276:
 11096              	.L936:
1744:../uvc.c      **** 				  }else{
 11097              		.loc 1 1744 0
 11098 5dd4 0040A0E3 		mov	r4, #0
 11099 5dd8 28408DE5 		str	r4, [sp, #40]
1741:../uvc.c      **** 				  if(Len == 2){
 11100              		.loc 1 1741 0
 11101 5ddc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11102              	.LVL1277:
1744:../uvc.c      **** 				  }else{
 11103              		.loc 1 1744 0
 11104 5de0 04C0A0E1 		mov	ip, r4
1743:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 11105              		.loc 1 1743 0
 11106 5de4 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 11107              	.LVL1278:
1744:../uvc.c      **** 				  }else{
 11108              		.loc 1 1744 0
 11109 5de8 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
 11110              	.LVL1279:
 11111 5dec B5FDFFEA 		b	.L868
 11112              	.LVL1280:
 11113              	.L811:
 11114              	.LBE183:
 11115              	.LBE200:
 11116              	.LBB201:
 11117              	.LBB173:
1717:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 11118              		.loc 1 1717 0
 11119 5df0 04ED1FE5 		ldr	lr, .L981+100
1716:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 11120              		.loc 1 1716 0
 11121 5df4 020053E3 		cmp	r3, #2
1717:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 11122              		.loc 1 1717 0
 11123 5df8 5DC7DEE5 		ldrb	ip, [lr, #1885]	@ zero_extendqisi2
1741:../uvc.c      **** 				  if(Len == 2){
 11124              		.loc 1 1741 0
 11125 5dfc 0300A0E1 		mov	r0, r3
1718:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11126              		.loc 1 1718 0
 11127 5e00 5E27DEE5 		ldrb	r2, [lr, #1886]	@ zero_extendqisi2
1716:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 11128              		.loc 1 1716 0
 11129 5e04 90FBFF1A 		bne	.L825
 11130              	.LVL1281:
1741:../uvc.c      **** 				  if(Len == 2){
 11131              		.loc 1 1741 0
 11132 5e08 141D1FE5 		ldr	r1, .L981+108
1717:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 11133              		.loc 1 1717 0
 11134 5e0c 28C0C7E5 		strb	ip, [r7, #40]
1718:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11135              		.loc 1 1718 0
 11136 5e10 2920C7E5 		strb	r2, [r7, #41]
 11137 5e14 340000EA 		b	.L933
 11138              	.LVL1282:
 11139              	.L834:
 11140              	.LBE173:
 11141              	.LBE201:
 11142              	.LBB202:
 11143              	.LBB161:
2268:../uvc.c      **** 			  break;
 11144              		.loc 1 2268 0
 11145 5e18 0000A0E3 		mov	r0, #0
 11146 5e1c 0020A0E1 		mov	r2, r0
 11147 5e20 0110A0E3 		mov	r1, #1
 11148 5e24 FEFFFFEB 		bl	CyU3PUsbStall
 11149              	.LVL1283:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11150              		.loc 1 1355 0
 11151 5e28 FF40A0E3 		mov	r4, #255
2268:../uvc.c      **** 			  break;
 11152              		.loc 1 2268 0
 11153 5e2c 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11154              		.loc 1 1355 0
 11155 5e30 0450A0E1 		mov	r5, r4
2268:../uvc.c      **** 			  break;
 11156              		.loc 1 2268 0
 11157 5e34 28C08DE5 		str	ip, [sp, #40]
 11158 5e38 BDFDFFEA 		b	.L844
 11159              	.LVL1284:
 11160              	.L862:
 11161              	.LBE161:
 11162              	.LBE202:
 11163              	.LBB203:
 11164              	.LBB184:
1680:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 11165              		.loc 1 1680 0
 11166 5e3c 020053E3 		cmp	r3, #2
1686:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 11167              		.loc 1 1686 0
 11168 5e40 83C7DA15 		ldrneb	ip, [r10, #1923]	@ zero_extendqisi2
1705:../uvc.c      **** 		 	 if(Len == 2){
 11169              		.loc 1 1705 0
 11170 5e44 0300A011 		movne	r0, r3
1688:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11171              		.loc 1 1688 0
 11172 5e48 8427DA15 		ldrneb	r2, [r10, #1924]	@ zero_extendqisi2
1680:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 11173              		.loc 1 1680 0
 11174 5e4c 12FDFF1A 		bne	.L873
1681:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 11175              		.loc 1 1681 0
 11176 5e50 8327DAE5 		ldrb	r2, [r10, #1923]	@ zero_extendqisi2
1682:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11177              		.loc 1 1682 0
 11178 5e54 8437DAE5 		ldrb	r3, [r10, #1924]	@ zero_extendqisi2
 11179              	.LVL1285:
1705:../uvc.c      **** 		 	 if(Len == 2){
 11180              		.loc 1 1705 0
 11181 5e58 0200A0E3 		mov	r0, #2
 11182 5e5c 681D1FE5 		ldr	r1, .L981+108
1681:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 11183              		.loc 1 1681 0
 11184 5e60 2820C7E5 		strb	r2, [r7, #40]
1682:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11185              		.loc 1 1682 0
 11186 5e64 2930C7E5 		strb	r3, [r7, #41]
 11187 5e68 D9FFFFEA 		b	.L936
 11188              	.LVL1286:
 11189              	.L861:
1498:../uvc.c      **** 			 	 			 {
 11190              		.loc 1 1498 0
 11191 5e6c 020053E3 		cmp	r3, #2
 11192 5e70 B201000A 		beq	.L977
1506:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11193              		.loc 1 1506 0
 11194 5e74 040053E3 		cmp	r3, #4
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11195              		.loc 1 1355 0
 11196 5e78 FF40A013 		movne	r4, #255
 11197              	.LVL1287:
 11198 5e7c 0450A011 		movne	r5, r4
1506:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11199              		.loc 1 1506 0
 11200 5e80 C701000A 		beq	.L978
 11201              	.LVL1288:
 11202              	.L870:
1672:../uvc.c      **** 
 11203              		.loc 1 1672 0
 11204 5e84 0300A0E1 		mov	r0, r3
 11205 5e88 941D1FE5 		ldr	r1, .L981+108
 11206 5e8c 20308DE5 		str	r3, [sp, #32]
 11207 5e90 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11208              	.LVL1289:
1675:../uvc.c      **** //#endif
 11209              		.loc 1 1675 0
 11210 5e94 29C0D7E5 		ldrb	ip, [r7, #41]	@ zero_extendqisi2
 11211 5e98 2B00D7E5 		ldrb	r0, [r7, #43]	@ zero_extendqisi2
 11212 5e9c 2C10D7E5 		ldrb	r1, [r7, #44]	@ zero_extendqisi2
 11213 5ea0 20309DE5 		ldr	r3, [sp, #32]
 11214 5ea4 03008DE8 		stmia	sp, {r0, r1}
 11215 5ea8 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 11216 5eac 08308DE5 		str	r3, [sp, #8]
 11217 5eb0 0400A0E3 		mov	r0, #4
 11218 5eb4 0C30A0E1 		mov	r3, ip
 11219 5eb8 C81D1FE5 		ldr	r1, .L981+104
 11220 5ebc FEFFFFEB 		bl	CyU3PDebugPrint
 11221              	.LVL1290:
 11222 5ec0 00C0A0E3 		mov	ip, #0
 11223 5ec4 28C08DE5 		str	ip, [sp, #40]
 11224 5ec8 7EFDFFEA 		b	.L868
 11225              	.LVL1291:
 11226              	.L818:
 11227              	.LBE184:
 11228              	.LBE203:
 11229              	.LBB204:
 11230              	.LBB174:
1770:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 11231              		.loc 1 1770 0
 11232 5ecc 6127DAE5 		ldrb	r2, [r10, #1889]	@ zero_extendqisi2
1782:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 11233              		.loc 1 1782 0
 11234 5ed0 DC1D1FE5 		ldr	r1, .L981+108
1771:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11235              		.loc 1 1771 0
 11236 5ed4 0030A0E3 		mov	r3, #0
 11237              	.LVL1292:
1782:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 11238              		.loc 1 1782 0
 11239 5ed8 0100A0E3 		mov	r0, #1
1770:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 11240              		.loc 1 1770 0
 11241 5edc 2820C7E5 		strb	r2, [r7, #40]
1771:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11242              		.loc 1 1771 0
 11243 5ee0 2930C7E5 		strb	r3, [r7, #41]
1772:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11244              		.loc 1 1772 0
 11245 5ee4 2A30C7E5 		strb	r3, [r7, #42]
1773:../uvc.c      **** 		 	 }
 11246              		.loc 1 1773 0
 11247 5ee8 2B30C7E5 		strb	r3, [r7, #43]
 11248              	.LVL1293:
 11249              	.L933:
1744:../uvc.c      **** 				  }else{
 11250              		.loc 1 1744 0
 11251 5eec 0040A0E3 		mov	r4, #0
 11252 5ef0 24408DE5 		str	r4, [sp, #36]
1741:../uvc.c      **** 				  if(Len == 2){
 11253              		.loc 1 1741 0
 11254 5ef4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11255              	.LVL1294:
1743:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 11256              		.loc 1 1743 0
 11257 5ef8 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 11258              	.LVL1295:
1744:../uvc.c      **** 				  }else{
 11259              		.loc 1 1744 0
 11260 5efc 2950D7E5 		ldrb	r5, [r7, #41]	@ zero_extendqisi2
 11261              	.LVL1296:
 11262 5f00 60FDFFEA 		b	.L820
 11263              	.LVL1297:
 11264              	.L817:
1752:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11265              		.loc 1 1752 0
 11266 5f04 5FC7DAE5 		ldrb	ip, [r10, #1887]	@ zero_extendqisi2
1763:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11267              		.loc 1 1763 0
 11268 5f08 141E1FE5 		ldr	r1, .L981+108
1753:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11269              		.loc 1 1753 0
 11270 5f0c 6027DAE5 		ldrb	r2, [r10, #1888]	@ zero_extendqisi2
1763:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11271              		.loc 1 1763 0
 11272 5f10 0300A0E1 		mov	r0, r3
1754:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11273              		.loc 1 1754 0
 11274 5f14 0030A0E3 		mov	r3, #0
 11275              	.LVL1298:
1752:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11276              		.loc 1 1752 0
 11277 5f18 28C0C7E5 		strb	ip, [r7, #40]
1753:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11278              		.loc 1 1753 0
 11279 5f1c 2920C7E5 		strb	r2, [r7, #41]
1754:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11280              		.loc 1 1754 0
 11281 5f20 2A30C7E5 		strb	r3, [r7, #42]
1755:../uvc.c      **** 		 	 }
 11282              		.loc 1 1755 0
 11283 5f24 2B30C7E5 		strb	r3, [r7, #43]
 11284              	.L932:
1708:../uvc.c      **** 		 	 }else{
 11285              		.loc 1 1708 0
 11286 5f28 00C0A0E3 		mov	ip, #0
 11287 5f2c 24C08DE5 		str	ip, [sp, #36]
 11288 5f30 0040A0E3 		mov	r4, #0
1705:../uvc.c      **** 		 	 if(Len == 2){
 11289              		.loc 1 1705 0
 11290 5f34 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11291              	.LVL1299:
1707:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[1];
 11292              		.loc 1 1707 0
 11293 5f38 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 11294              	.LVL1300:
1708:../uvc.c      **** 		 	 }else{
 11295              		.loc 1 1708 0
 11296 5f3c 2950D7E5 		ldrb	r5, [r7, #41]	@ zero_extendqisi2
 11297              	.LVL1301:
 11298 5f40 50FDFFEA 		b	.L820
 11299              	.LVL1302:
 11300              	.L838:
 11301              	.LBE174:
 11302              	.LBE204:
 11303              	.LBB205:
 11304              	.LBB162:
1680:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 11305              		.loc 1 1680 0
 11306 5f44 020053E3 		cmp	r3, #2
1681:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 11307              		.loc 1 1681 0
 11308 5f48 6FC7DAE5 		ldrb	ip, [r10, #1903]	@ zero_extendqisi2
1705:../uvc.c      **** 		 	 if(Len == 2){
 11309              		.loc 1 1705 0
 11310 5f4c 0300A0E1 		mov	r0, r3
1682:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11311              		.loc 1 1682 0
 11312 5f50 7027DAE5 		ldrb	r2, [r10, #1904]	@ zero_extendqisi2
1680:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 11313              		.loc 1 1680 0
 11314 5f54 07FAFF1A 		bne	.L849
 11315              	.LVL1303:
 11316              	.L941:
1814:../uvc.c      **** 		 	 if(Len == 2){
 11317              		.loc 1 1814 0
 11318 5f58 641E1FE5 		ldr	r1, .L981+108
1790:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 11319              		.loc 1 1790 0
 11320 5f5c 28C0C7E5 		strb	ip, [r7, #40]
1791:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 11321              		.loc 1 1791 0
 11322 5f60 2920C7E5 		strb	r2, [r7, #41]
 11323 5f64 46FFFFEA 		b	.L935
 11324              	.LVL1304:
 11325              	.L837:
1498:../uvc.c      **** 			 	 			 {
 11326              		.loc 1 1498 0
 11327 5f68 020053E3 		cmp	r3, #2
 11328 5f6c 8001000A 		beq	.L979
1506:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11329              		.loc 1 1506 0
 11330 5f70 040053E3 		cmp	r3, #4
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11331              		.loc 1 1355 0
 11332 5f74 FF40A013 		movne	r4, #255
 11333              	.LVL1305:
 11334 5f78 0450A011 		movne	r5, r4
1506:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11335              		.loc 1 1506 0
 11336 5f7c 5C01000A 		beq	.L980
 11337              	.LVL1306:
 11338              	.L846:
1672:../uvc.c      **** 
 11339              		.loc 1 1672 0
 11340 5f80 0300A0E1 		mov	r0, r3
 11341 5f84 901E1FE5 		ldr	r1, .L981+108
 11342 5f88 20308DE5 		str	r3, [sp, #32]
 11343 5f8c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11344              	.LVL1307:
1675:../uvc.c      **** //#endif
 11345              		.loc 1 1675 0
 11346 5f90 29C0D7E5 		ldrb	ip, [r7, #41]	@ zero_extendqisi2
 11347 5f94 2B00D7E5 		ldrb	r0, [r7, #43]	@ zero_extendqisi2
 11348 5f98 2C10D7E5 		ldrb	r1, [r7, #44]	@ zero_extendqisi2
 11349 5f9c 20309DE5 		ldr	r3, [sp, #32]
 11350 5fa0 03008DE8 		stmia	sp, {r0, r1}
 11351 5fa4 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 11352 5fa8 08308DE5 		str	r3, [sp, #8]
 11353 5fac 0400A0E3 		mov	r0, #4
 11354 5fb0 0C30A0E1 		mov	r3, ip
 11355 5fb4 C41E1FE5 		ldr	r1, .L981+104
 11356 5fb8 FEFFFFEB 		bl	CyU3PDebugPrint
 11357              	.LVL1308:
 11358 5fbc 00C0A0E3 		mov	ip, #0
 11359 5fc0 28C08DE5 		str	ip, [sp, #40]
 11360 5fc4 5AFDFFEA 		b	.L844
 11361              	.LVL1309:
 11362              	.L937:
 11363              	.LBE162:
 11364              	.LBE205:
 11365              	.LBB206:
 11366              	.LBB185:
1741:../uvc.c      **** 				  if(Len == 2){
 11367              		.loc 1 1741 0
 11368 5fc8 D41E1FE5 		ldr	r1, .L981+108
1717:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 11369              		.loc 1 1717 0
 11370 5fcc 28C0C7E5 		strb	ip, [r7, #40]
1718:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11371              		.loc 1 1718 0
 11372 5fd0 2920C7E5 		strb	r2, [r7, #41]
 11373 5fd4 7EFFFFEA 		b	.L936
 11374              	.LVL1310:
 11375              	.L850:
 11376              	.LBE185:
 11377              	.LBE206:
 11378              	.LBB207:
 11379              	.LBB163:
2260:../uvc.c      **** 			   }
 11380              		.loc 1 2260 0
 11381 5fd8 38209DE5 		ldr	r2, [sp, #56]
 11382 5fdc 0400A0E3 		mov	r0, #4
 11383              	.LVL1311:
 11384 5fe0 E81E1FE5 		ldr	r1, .L981+112
 11385 5fe4 FEFFFFEB 		bl	CyU3PDebugPrint
 11386              	.LVL1312:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11387              		.loc 1 1355 0
 11388 5fe8 FF40A0E3 		mov	r4, #255
 11389              	.LVL1313:
2260:../uvc.c      **** 			   }
 11390              		.loc 1 2260 0
 11391 5fec 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11392              		.loc 1 1355 0
 11393 5ff0 0450A0E1 		mov	r5, r4
2260:../uvc.c      **** 			   }
 11394              		.loc 1 2260 0
 11395 5ff4 28C08DE5 		str	ip, [sp, #40]
 11396 5ff8 4DFDFFEA 		b	.L844
 11397              	.LVL1314:
 11398              	.L826:
 11399              	.LBE163:
 11400              	.LBE207:
 11401              	.LBB208:
 11402              	.LBB175:
 11403 5ffc 38209DE5 		ldr	r2, [sp, #56]
 11404 6000 0400A0E3 		mov	r0, #4
 11405              	.LVL1315:
 11406 6004 0C1F1FE5 		ldr	r1, .L981+112
 11407 6008 FEFFFFEB 		bl	CyU3PDebugPrint
 11408              	.LVL1316:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11409              		.loc 1 1355 0
 11410 600c FF50A0E3 		mov	r5, #255
2260:../uvc.c      **** 			   }
 11411              		.loc 1 2260 0
 11412 6010 0040A0E3 		mov	r4, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11413              		.loc 1 1355 0
 11414 6014 05C0A0E1 		mov	ip, r5
2260:../uvc.c      **** 			   }
 11415              		.loc 1 2260 0
 11416 6018 24408DE5 		str	r4, [sp, #36]
 11417 601c 19FDFFEA 		b	.L820
 11418              	.LVL1317:
 11419              	.L874:
 11420              	.LBE175:
 11421              	.LBE208:
 11422              	.LBB209:
 11423              	.LBB186:
 11424 6020 38209DE5 		ldr	r2, [sp, #56]
 11425 6024 0400A0E3 		mov	r0, #4
 11426              	.LVL1318:
 11427 6028 301F1FE5 		ldr	r1, .L981+112
 11428 602c FEFFFFEB 		bl	CyU3PDebugPrint
 11429              	.LVL1319:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11430              		.loc 1 1355 0
 11431 6030 FF40A0E3 		mov	r4, #255
 11432              	.LVL1320:
2260:../uvc.c      **** 			   }
 11433              		.loc 1 2260 0
 11434 6034 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11435              		.loc 1 1355 0
 11436 6038 0450A0E1 		mov	r5, r4
2260:../uvc.c      **** 			   }
 11437              		.loc 1 2260 0
 11438 603c 28C08DE5 		str	ip, [sp, #40]
 11439 6040 20FDFFEA 		b	.L868
 11440              	.LVL1321:
 11441              	.L950:
 11442              	.LBE186:
 11443              	.LBE209:
 11444              	.LBE227:
 11445              	.LBE407:
 11446              	.LBB408:
 11447              	.LBB384:
 11448              	.LBB377:
 11449              	.LBB373:
1814:../uvc.c      **** 		 	 if(Len == 2){
 11450              		.loc 1 1814 0
 11451 6044 501F1FE5 		ldr	r1, .L981+108
1803:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 11452              		.loc 1 1803 0
 11453 6048 28C0C7E5 		strb	ip, [r7, #40]
1804:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 11454              		.loc 1 1804 0
 11455 604c 2920C7E5 		strb	r2, [r7, #41]
 11456 6050 04FEFFEA 		b	.L923
 11457              	.LVL1322:
 11458              	.L665:
2260:../uvc.c      **** 			   }
 11459              		.loc 1 2260 0
 11460 6054 0400A0E3 		mov	r0, #4
 11461              	.LVL1323:
 11462 6058 601F1FE5 		ldr	r1, .L981+112
 11463 605c FEFFFFEB 		bl	CyU3PDebugPrint
 11464              	.LVL1324:
 11465 6060 0040A0E3 		mov	r4, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11466              		.loc 1 1355 0
 11467 6064 FF30A0E3 		mov	r3, #255
 11468 6068 0320A0E1 		mov	r2, r3
2260:../uvc.c      **** 			   }
 11469              		.loc 1 2260 0
 11470 606c 24408DE5 		str	r4, [sp, #36]
 11471 6070 04C0A0E1 		mov	ip, r4
 11472 6074 43FBFFEA 		b	.L661
 11473              	.LVL1325:
 11474              	.L969:
 11475              	.LBE373:
 11476              	.LBE377:
 11477              	.LBE384:
 11478              	.LBE408:
 11479              	.LBB409:
 11480              	.LBB228:
 11481              	.LBB210:
 11482              	.LBB187:
1830:../uvc.c      **** 				 }else{
 11483              		.loc 1 1830 0
 11484 6078 29E0DBE5 		ldrb	lr, [fp, #41]	@ zero_extendqisi2
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11485              		.loc 1 1836 0
 11486 607c 00408DE5 		str	r4, [sp]
 11487 6080 30409DE5 		ldr	r4, [sp, #48]
 11488              	.LVL1326:
 11489 6084 08308DE5 		str	r3, [sp, #8]
 11490 6088 0CC08DE5 		str	ip, [sp, #12]
 11491 608c 34309DE5 		ldr	r3, [sp, #52]
 11492 6090 04408DE5 		str	r4, [sp, #4]
 11493 6094 10E08DE5 		str	lr, [sp, #16]
 11494 6098 0400A0E3 		mov	r0, #4
 11495              	.LVL1327:
 11496 609c A01F1FE5 		ldr	r1, .L981+116
 11497 60a0 2B20A0E3 		mov	r2, #43
 11498 60a4 1CC08DE5 		str	ip, [sp, #28]
1830:../uvc.c      **** 				 }else{
 11499              		.loc 1 1830 0
 11500 60a8 28E08DE5 		str	lr, [sp, #40]
 11501              	.LVL1328:
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11502              		.loc 1 1836 0
 11503 60ac FEFFFFEB 		bl	CyU3PDebugPrint
 11504              	.LVL1329:
2039:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 11505              		.loc 1 2039 0
 11506 60b0 8D37DAE5 		ldrb	r3, [r10, #1933]	@ zero_extendqisi2
 11507 60b4 1CC09DE5 		ldr	ip, [sp, #28]
 11508 60b8 03005CE1 		cmp	ip, r3
 11509 60bc 1400000A 		beq	.L877
2040:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 11510              		.loc 1 2040 0
 11511 60c0 C04F1FE5 		ldr	r4, .L981+120
 11512 60c4 0010E0E3 		mvn	r1, #0
 11513 60c8 1C0094E5 		ldr	r0, [r4, #28]
 11514 60cc 1CC08DE5 		str	ip, [sp, #28]
 11515              	.LVL1330:
 11516 60d0 FEFFFFEB 		bl	_txe_mutex_get
 11517              	.LVL1331:
2041:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11518              		.loc 1 2041 0
 11519 60d4 1CC09DE5 		ldr	ip, [sp, #28]
 11520 60d8 38209DE5 		ldr	r2, [sp, #56]
 11521 60dc 00C08DE5 		str	ip, [sp]
 11522 60e0 30309DE5 		ldr	r3, [sp, #48]
 11523 60e4 04208DE5 		str	r2, [sp, #4]
 11524 60e8 0400A0E1 		mov	r0, r4
 11525 60ec 34209DE5 		ldr	r2, [sp, #52]
 11526 60f0 2B10A0E3 		mov	r1, #43
 11527 60f4 FEFFFFEB 		bl	cmdSet
 11528              	.LVL1332:
2042:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 11529              		.loc 1 2042 0
 11530 60f8 1C0094E5 		ldr	r0, [r4, #28]
 11531 60fc FEFFFFEB 		bl	_txe_mutex_put
 11532              	.LVL1333:
2043:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11533              		.loc 1 2043 0
 11534 6100 1CC09DE5 		ldr	ip, [sp, #28]
 11535 6104 E4349FE5 		ldr	r3, .L983
2044:../uvc.c      **** 									 }
 11536              		.loc 1 2044 0
 11537 6108 38409DE5 		ldr	r4, [sp, #56]
2043:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11538              		.loc 1 2043 0
 11539 610c 8DC7C3E5 		strb	ip, [r3, #1933]
2044:../uvc.c      **** 									 }
 11540              		.loc 1 2044 0
 11541 6110 8E47C3E5 		strb	r4, [r3, #1934]
 11542              	.L877:
2046:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11543              		.loc 1 2046 0
 11544 6114 0130A0E3 		mov	r3, #1
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11545              		.loc 1 1836 0
 11546 6118 0240A0E3 		mov	r4, #2
2046:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11547              		.loc 1 2046 0
 11548 611c 9137CAE5 		strb	r3, [r10, #1937]
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11549              		.loc 1 1836 0
 11550 6120 3C408DE5 		str	r4, [sp, #60]
 11551 6124 37FDFFEA 		b	.L879
 11552              	.LVL1334:
 11553              	.L973:
 11554              	.LBE187:
 11555              	.LBE210:
 11556              	.LBB211:
 11557              	.LBB164:
1830:../uvc.c      **** 				 }else{
 11558              		.loc 1 1830 0
 11559 6128 29E0DBE5 		ldrb	lr, [fp, #41]	@ zero_extendqisi2
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11560              		.loc 1 1836 0
 11561 612c 00408DE5 		str	r4, [sp]
 11562 6130 30409DE5 		ldr	r4, [sp, #48]
 11563              	.LVL1335:
 11564 6134 08308DE5 		str	r3, [sp, #8]
 11565 6138 0CC08DE5 		str	ip, [sp, #12]
 11566 613c 34309DE5 		ldr	r3, [sp, #52]
 11567 6140 04408DE5 		str	r4, [sp, #4]
 11568 6144 10E08DE5 		str	lr, [sp, #16]
 11569 6148 0400A0E3 		mov	r0, #4
 11570              	.LVL1336:
 11571 614c A0149FE5 		ldr	r1, .L983+4
 11572 6150 2A20A0E3 		mov	r2, #42
 11573 6154 1CC08DE5 		str	ip, [sp, #28]
1830:../uvc.c      **** 				 }else{
 11574              		.loc 1 1830 0
 11575 6158 28E08DE5 		str	lr, [sp, #40]
 11576              	.LVL1337:
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11577              		.loc 1 1836 0
 11578 615c FEFFFFEB 		bl	CyU3PDebugPrint
 11579              	.LVL1338:
2039:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 11580              		.loc 1 2039 0
 11581 6160 7937DAE5 		ldrb	r3, [r10, #1913]	@ zero_extendqisi2
 11582 6164 1CC09DE5 		ldr	ip, [sp, #28]
 11583 6168 03005CE1 		cmp	ip, r3
 11584 616c 1400000A 		beq	.L853
2040:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 11585              		.loc 1 2040 0
 11586 6170 80449FE5 		ldr	r4, .L983+8
 11587 6174 0010E0E3 		mvn	r1, #0
 11588 6178 1C0094E5 		ldr	r0, [r4, #28]
 11589 617c 1CC08DE5 		str	ip, [sp, #28]
 11590              	.LVL1339:
 11591 6180 FEFFFFEB 		bl	_txe_mutex_get
 11592              	.LVL1340:
2041:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11593              		.loc 1 2041 0
 11594 6184 1CC09DE5 		ldr	ip, [sp, #28]
 11595 6188 38209DE5 		ldr	r2, [sp, #56]
 11596 618c 00C08DE5 		str	ip, [sp]
 11597 6190 30309DE5 		ldr	r3, [sp, #48]
 11598 6194 04208DE5 		str	r2, [sp, #4]
 11599 6198 0400A0E1 		mov	r0, r4
 11600 619c 34209DE5 		ldr	r2, [sp, #52]
 11601 61a0 2A10A0E3 		mov	r1, #42
 11602 61a4 FEFFFFEB 		bl	cmdSet
 11603              	.LVL1341:
2042:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 11604              		.loc 1 2042 0
 11605 61a8 1C0094E5 		ldr	r0, [r4, #28]
 11606 61ac FEFFFFEB 		bl	_txe_mutex_put
 11607              	.LVL1342:
2043:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11608              		.loc 1 2043 0
 11609 61b0 1CC09DE5 		ldr	ip, [sp, #28]
 11610 61b4 34349FE5 		ldr	r3, .L983
2044:../uvc.c      **** 									 }
 11611              		.loc 1 2044 0
 11612 61b8 38409DE5 		ldr	r4, [sp, #56]
2043:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11613              		.loc 1 2043 0
 11614 61bc 79C7C3E5 		strb	ip, [r3, #1913]
2044:../uvc.c      **** 									 }
 11615              		.loc 1 2044 0
 11616 61c0 7A47C3E5 		strb	r4, [r3, #1914]
 11617              	.L853:
2046:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11618              		.loc 1 2046 0
 11619 61c4 0130A0E3 		mov	r3, #1
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11620              		.loc 1 1836 0
 11621 61c8 0240A0E3 		mov	r4, #2
2046:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11622              		.loc 1 2046 0
 11623 61cc 7D37CAE5 		strb	r3, [r10, #1917]
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11624              		.loc 1 1836 0
 11625 61d0 3C408DE5 		str	r4, [sp, #60]
 11626 61d4 6DFDFFEA 		b	.L855
 11627              	.LVL1343:
 11628              	.L971:
 11629              	.LBE164:
 11630              	.LBE211:
 11631              	.LBB212:
 11632              	.LBB176:
1830:../uvc.c      **** 				 }else{
 11633              		.loc 1 1830 0
 11634 61d8 29C0DBE5 		ldrb	ip, [fp, #41]	@ zero_extendqisi2
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11635              		.loc 1 1836 0
 11636 61dc 0400A0E3 		mov	r0, #4
 11637              	.LVL1344:
1830:../uvc.c      **** 				 }else{
 11638              		.loc 1 1830 0
 11639 61e0 24C08DE5 		str	ip, [sp, #36]
 11640              	.LVL1345:
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11641              		.loc 1 1836 0
 11642 61e4 34C09DE5 		ldr	ip, [sp, #52]
 11643 61e8 08308DE5 		str	r3, [sp, #8]
 11644 61ec 00C08DE5 		str	ip, [sp]
 11645 61f0 2CC09DE5 		ldr	ip, [sp, #44]
 11646 61f4 30309DE5 		ldr	r3, [sp, #48]
 11647 61f8 04C08DE5 		str	ip, [sp, #4]
 11648 61fc 24C09DE5 		ldr	ip, [sp, #36]
 11649 6200 0C408DE5 		str	r4, [sp, #12]
 11650 6204 10C08DE5 		str	ip, [sp, #16]
 11651 6208 E4139FE5 		ldr	r1, .L983+4
 11652 620c 1620A0E3 		mov	r2, #22
 11653 6210 FEFFFFEB 		bl	CyU3PDebugPrint
 11654              	.LVL1346:
2039:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 11655              		.loc 1 2039 0
 11656 6214 6537DAE5 		ldrb	r3, [r10, #1893]	@ zero_extendqisi2
 11657 6218 030054E1 		cmp	r4, r3
 11658 621c 1100000A 		beq	.L829
2040:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 11659              		.loc 1 2040 0
 11660 6220 D0539FE5 		ldr	r5, .L983+8
 11661 6224 0010E0E3 		mvn	r1, #0
 11662 6228 1C0095E5 		ldr	r0, [r5, #28]
 11663 622c FEFFFFEB 		bl	_txe_mutex_get
 11664              	.LVL1347:
2041:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11665              		.loc 1 2041 0
 11666 6230 38C09DE5 		ldr	ip, [sp, #56]
 11667 6234 30209DE5 		ldr	r2, [sp, #48]
 11668 6238 04C08DE5 		str	ip, [sp, #4]
 11669 623c 2C309DE5 		ldr	r3, [sp, #44]
 11670 6240 1610A0E3 		mov	r1, #22
 11671 6244 00408DE5 		str	r4, [sp]
 11672 6248 0500A0E1 		mov	r0, r5
 11673 624c FEFFFFEB 		bl	cmdSet
 11674              	.LVL1348:
2042:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 11675              		.loc 1 2042 0
 11676 6250 1C0095E5 		ldr	r0, [r5, #28]
 11677 6254 FEFFFFEB 		bl	_txe_mutex_put
 11678              	.LVL1349:
2043:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11679              		.loc 1 2043 0
 11680 6258 90E39FE5 		ldr	lr, .L983
2044:../uvc.c      **** 									 }
 11681              		.loc 1 2044 0
 11682 625c 38C09DE5 		ldr	ip, [sp, #56]
2043:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11683              		.loc 1 2043 0
 11684 6260 6547CEE5 		strb	r4, [lr, #1893]
2044:../uvc.c      **** 									 }
 11685              		.loc 1 2044 0
 11686 6264 66C7CEE5 		strb	ip, [lr, #1894]
 11687              	.L829:
2046:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11688              		.loc 1 2046 0
 11689 6268 0130A0E3 		mov	r3, #1
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11690              		.loc 1 1836 0
 11691 626c 02C0A0E3 		mov	ip, #2
2046:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11692              		.loc 1 2046 0
 11693 6270 6937CAE5 		strb	r3, [r10, #1897]
1836:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11694              		.loc 1 1836 0
 11695 6274 3CC08DE5 		str	ip, [sp, #60]
 11696 6278 14FDFFEA 		b	.L831
 11697              	.L972:
2048:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 11698              		.loc 1 2048 0
 11699 627c 74539FE5 		ldr	r5, .L983+8
 11700 6280 0010E0E3 		mvn	r1, #0
 11701 6284 1C0095E5 		ldr	r0, [r5, #28]
 11702 6288 FEFFFFEB 		bl	_txe_mutex_get
 11703              	.LVL1350:
2049:../uvc.c      **** 									 {
 11704              		.loc 1 2049 0
 11705 628c 6537DAE5 		ldrb	r3, [r10, #1893]	@ zero_extendqisi2
 11706 6290 030054E1 		cmp	r4, r3
1835:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x 
 11707              		.loc 1 1835 0
 11708 6294 38309D05 		ldreq	r3, [sp, #56]
2049:../uvc.c      **** 									 {
 11709              		.loc 1 2049 0
 11710 6298 0A00000A 		beq	.L832
2052:../uvc.c      **** 										 dataIdx++;
 11711              		.loc 1 2052 0
 11712 629c 38C09DE5 		ldr	ip, [sp, #56]
2051:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11713              		.loc 1 2051 0
 11714 62a0 48E39FE5 		ldr	lr, .L983
2052:../uvc.c      **** 										 dataIdx++;
 11715              		.loc 1 2052 0
 11716 62a4 00408DE5 		str	r4, [sp]
 11717 62a8 04C08DE5 		str	ip, [sp, #4]
 11718 62ac 2C309DE5 		ldr	r3, [sp, #44]
 11719 62b0 30209DE5 		ldr	r2, [sp, #48]
 11720 62b4 0500A0E1 		mov	r0, r5
 11721 62b8 1610A0E3 		mov	r1, #22
2051:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11722              		.loc 1 2051 0
 11723 62bc 6547CEE5 		strb	r4, [lr, #1893]
2052:../uvc.c      **** 										 dataIdx++;
 11724              		.loc 1 2052 0
 11725 62c0 FEFFFFEB 		bl	cmdSet
 11726              	.LVL1351:
2053:../uvc.c      **** 									 }
 11727              		.loc 1 2053 0
 11728 62c4 28309DE5 		ldr	r3, [sp, #40]
 11729              	.LVL1352:
 11730              	.L832:
2055:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 11731              		.loc 1 2055 0
 11732 62c8 6627DAE5 		ldrb	r2, [r10, #1894]	@ zero_extendqisi2
 11733 62cc 24C09DE5 		ldr	ip, [sp, #36]
 11734 62d0 02005CE1 		cmp	ip, r2
 11735 62d4 0800000A 		beq	.L833
2056:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11736              		.loc 1 2056 0
 11737 62d8 10E39FE5 		ldr	lr, .L983
2057:../uvc.c      **** 									 }
 11738              		.loc 1 2057 0
 11739 62dc 04308DE5 		str	r3, [sp, #4]
 11740 62e0 00C08DE5 		str	ip, [sp]
 11741 62e4 34209DE5 		ldr	r2, [sp, #52]
 11742 62e8 2C309DE5 		ldr	r3, [sp, #44]
 11743              	.LVL1353:
 11744 62ec 04039FE5 		ldr	r0, .L983+8
 11745 62f0 1610A0E3 		mov	r1, #22
2056:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11746              		.loc 1 2056 0
 11747 62f4 66C7CEE5 		strb	ip, [lr, #1894]
2057:../uvc.c      **** 									 }
 11748              		.loc 1 2057 0
 11749 62f8 FEFFFFEB 		bl	cmdSet
 11750              	.LVL1354:
 11751              	.L833:
2059:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11752              		.loc 1 2059 0
 11753 62fc 0130A0E3 		mov	r3, #1
2060:../uvc.c      **** 
 11754              		.loc 1 2060 0
 11755 6300 1C0095E5 		ldr	r0, [r5, #28]
2059:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11756              		.loc 1 2059 0
 11757 6304 6937CAE5 		strb	r3, [r10, #1897]
2060:../uvc.c      **** 
 11758              		.loc 1 2060 0
 11759 6308 FEFFFFEB 		bl	_txe_mutex_put
 11760              	.LVL1355:
 11761 630c EFFCFFEA 		b	.L831
 11762              	.LVL1356:
 11763              	.L976:
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11764              		.loc 1 1507 0
 11765 6310 2C109DE5 		ldr	r1, [sp, #44]
 11766 6314 34009DE5 		ldr	r0, [sp, #52]
 11767 6318 20308DE5 		str	r3, [sp, #32]
 11768 631c FEFFFFEB 		bl	SensorGetControl
 11769              	.LVL1357:
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11770              		.loc 1 1509 0
 11771 6320 2C109DE5 		ldr	r1, [sp, #44]
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11772              		.loc 1 1507 0
 11773 6324 0020A0E1 		mov	r2, r0
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11774              		.loc 1 1509 0
 11775 6328 30009DE5 		ldr	r0, [sp, #48]
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11776              		.loc 1 1507 0
 11777 632c 2820C7E5 		strb	r2, [r7, #40]
1508:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 11778              		.loc 1 1508 0
 11779 6330 6527CAE5 		strb	r2, [r10, #1893]
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11780              		.loc 1 1509 0
 11781 6334 FEFFFFEB 		bl	SensorGetControl
 11782              	.LVL1358:
1511:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11783              		.loc 1 1511 0
 11784 6338 0020A0E3 		mov	r2, #0
 11785 633c 2920C7E5 		strb	r2, [r7, #41]
1512:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11786              		.loc 1 1512 0
 11787 6340 2B20C7E5 		strb	r2, [r7, #43]
1513:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 11788              		.loc 1 1513 0
 11789 6344 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 11790              	.LVL1359:
 11791 6348 20309DE5 		ldr	r3, [sp, #32]
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11792              		.loc 1 1509 0
 11793 634c 0050A0E1 		mov	r5, r0
 11794              	.LVL1360:
 11795 6350 2A00C7E5 		strb	r0, [r7, #42]
1510:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11796              		.loc 1 1510 0
 11797 6354 6607CAE5 		strb	r0, [r10, #1894]
 11798 6358 5FFEFFEA 		b	.L822
 11799              	.LVL1361:
 11800              	.L975:
1500:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11801              		.loc 1 1500 0
 11802 635c 30009DE5 		ldr	r0, [sp, #48]
 11803 6360 2C109DE5 		ldr	r1, [sp, #44]
 11804 6364 20308DE5 		str	r3, [sp, #32]
 11805 6368 FEFFFFEB 		bl	SensorGetControl
 11806              	.LVL1362:
1502:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 11807              		.loc 1 1502 0
 11808 636c 0050A0E3 		mov	r5, #0
 11809 6370 2950C7E5 		strb	r5, [r7, #41]
 11810 6374 20309DE5 		ldr	r3, [sp, #32]
1501:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11811              		.loc 1 1501 0
 11812 6378 6507CAE5 		strb	r0, [r10, #1893]
1500:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11813              		.loc 1 1500 0
 11814 637c 00C0A0E1 		mov	ip, r0
 11815 6380 2800C7E5 		strb	r0, [r7, #40]
1503:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11816              		.loc 1 1503 0
 11817 6384 6657CAE5 		strb	r5, [r10, #1894]
 11818              	.LVL1363:
 11819 6388 53FEFFEA 		b	.L822
 11820              	.LVL1364:
 11821              	.L970:
 11822              	.LBE176:
 11823              	.LBE212:
 11824              	.LBB213:
 11825              	.LBB188:
2048:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 11826              		.loc 1 2048 0
 11827 638c 64529FE5 		ldr	r5, .L983+8
 11828 6390 0010E0E3 		mvn	r1, #0
 11829 6394 1C0095E5 		ldr	r0, [r5, #28]
 11830 6398 1CC08DE5 		str	ip, [sp, #28]
 11831              	.LVL1365:
 11832 639c FEFFFFEB 		bl	_txe_mutex_get
 11833              	.LVL1366:
2049:../uvc.c      **** 									 {
 11834              		.loc 1 2049 0
 11835 63a0 8D37DAE5 		ldrb	r3, [r10, #1933]	@ zero_extendqisi2
 11836 63a4 1CC09DE5 		ldr	ip, [sp, #28]
 11837 63a8 03005CE1 		cmp	ip, r3
1835:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x 
 11838              		.loc 1 1835 0
 11839 63ac 38309D05 		ldreq	r3, [sp, #56]
2049:../uvc.c      **** 									 {
 11840              		.loc 1 2049 0
 11841 63b0 0C00000A 		beq	.L880
2052:../uvc.c      **** 										 dataIdx++;
 11842              		.loc 1 2052 0
 11843 63b4 38E09DE5 		ldr	lr, [sp, #56]
 11844 63b8 00C08DE5 		str	ip, [sp]
 11845 63bc 04E08DE5 		str	lr, [sp, #4]
2051:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11846              		.loc 1 2051 0
 11847 63c0 28E29FE5 		ldr	lr, .L983
2052:../uvc.c      **** 										 dataIdx++;
 11848              		.loc 1 2052 0
 11849 63c4 30309DE5 		ldr	r3, [sp, #48]
2051:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11850              		.loc 1 2051 0
 11851 63c8 8DC7CEE5 		strb	ip, [lr, #1933]
2052:../uvc.c      **** 										 dataIdx++;
 11852              		.loc 1 2052 0
 11853 63cc 34209DE5 		ldr	r2, [sp, #52]
 11854 63d0 0500A0E1 		mov	r0, r5
 11855 63d4 2B10A0E3 		mov	r1, #43
 11856 63d8 1CC08DE5 		str	ip, [sp, #28]
 11857 63dc FEFFFFEB 		bl	cmdSet
 11858              	.LVL1367:
 11859 63e0 1CC09DE5 		ldr	ip, [sp, #28]
2053:../uvc.c      **** 									 }
 11860              		.loc 1 2053 0
 11861 63e4 0130A0E3 		mov	r3, #1
 11862              	.LVL1368:
 11863              	.L880:
2055:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 11864              		.loc 1 2055 0
 11865 63e8 8E27DAE5 		ldrb	r2, [r10, #1934]	@ zero_extendqisi2
 11866 63ec 28009DE5 		ldr	r0, [sp, #40]
 11867 63f0 020050E1 		cmp	r0, r2
 11868 63f4 0A00000A 		beq	.L881
2057:../uvc.c      **** 									 }
 11869              		.loc 1 2057 0
 11870 63f8 0420A0E1 		mov	r2, r4
2056:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11871              		.loc 1 2056 0
 11872 63fc ECE19FE5 		ldr	lr, .L983
 11873 6400 28409DE5 		ldr	r4, [sp, #40]
 11874              	.LVL1369:
2057:../uvc.c      **** 									 }
 11875              		.loc 1 2057 0
 11876 6404 09008DE8 		stmia	sp, {r0, r3}
 11877 6408 30309DE5 		ldr	r3, [sp, #48]
 11878              	.LVL1370:
2056:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11879              		.loc 1 2056 0
 11880 640c 8E47CEE5 		strb	r4, [lr, #1934]
2057:../uvc.c      **** 									 }
 11881              		.loc 1 2057 0
 11882 6410 E0019FE5 		ldr	r0, .L983+8
 11883 6414 2B10A0E3 		mov	r1, #43
 11884 6418 1CC08DE5 		str	ip, [sp, #28]
 11885 641c FEFFFFEB 		bl	cmdSet
 11886              	.LVL1371:
 11887 6420 1CC09DE5 		ldr	ip, [sp, #28]
 11888              	.L881:
2060:../uvc.c      **** 
 11889              		.loc 1 2060 0
 11890 6424 1C0095E5 		ldr	r0, [r5, #28]
2059:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11891              		.loc 1 2059 0
 11892 6428 0130A0E3 		mov	r3, #1
2060:../uvc.c      **** 
 11893              		.loc 1 2060 0
 11894 642c 1CC08DE5 		str	ip, [sp, #28]
2059:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11895              		.loc 1 2059 0
 11896 6430 9137CAE5 		strb	r3, [r10, #1937]
2060:../uvc.c      **** 
 11897              		.loc 1 2060 0
 11898 6434 FEFFFFEB 		bl	_txe_mutex_put
 11899              	.LVL1372:
 11900 6438 1CC09DE5 		ldr	ip, [sp, #28]
 11901 643c 71FCFFEA 		b	.L879
 11902              	.LVL1373:
 11903              	.L974:
 11904              	.LBE188:
 11905              	.LBE213:
 11906              	.LBB214:
 11907              	.LBB165:
2048:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 11908              		.loc 1 2048 0
 11909 6440 B0519FE5 		ldr	r5, .L983+8
 11910 6444 0010E0E3 		mvn	r1, #0
 11911 6448 1C0095E5 		ldr	r0, [r5, #28]
 11912 644c 1CC08DE5 		str	ip, [sp, #28]
 11913              	.LVL1374:
 11914 6450 FEFFFFEB 		bl	_txe_mutex_get
 11915              	.LVL1375:
2049:../uvc.c      **** 									 {
 11916              		.loc 1 2049 0
 11917 6454 7937DAE5 		ldrb	r3, [r10, #1913]	@ zero_extendqisi2
 11918 6458 1CC09DE5 		ldr	ip, [sp, #28]
 11919 645c 03005CE1 		cmp	ip, r3
1835:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x 
 11920              		.loc 1 1835 0
 11921 6460 38309D05 		ldreq	r3, [sp, #56]
2049:../uvc.c      **** 									 {
 11922              		.loc 1 2049 0
 11923 6464 0C00000A 		beq	.L856
2052:../uvc.c      **** 										 dataIdx++;
 11924              		.loc 1 2052 0
 11925 6468 38E09DE5 		ldr	lr, [sp, #56]
 11926 646c 00C08DE5 		str	ip, [sp]
 11927 6470 04E08DE5 		str	lr, [sp, #4]
2051:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11928              		.loc 1 2051 0
 11929 6474 74E19FE5 		ldr	lr, .L983
2052:../uvc.c      **** 										 dataIdx++;
 11930              		.loc 1 2052 0
 11931 6478 30309DE5 		ldr	r3, [sp, #48]
2051:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11932              		.loc 1 2051 0
 11933 647c 79C7CEE5 		strb	ip, [lr, #1913]
2052:../uvc.c      **** 										 dataIdx++;
 11934              		.loc 1 2052 0
 11935 6480 34209DE5 		ldr	r2, [sp, #52]
 11936 6484 0500A0E1 		mov	r0, r5
 11937 6488 2A10A0E3 		mov	r1, #42
 11938 648c 1CC08DE5 		str	ip, [sp, #28]
 11939 6490 FEFFFFEB 		bl	cmdSet
 11940              	.LVL1376:
2053:../uvc.c      **** 									 }
 11941              		.loc 1 2053 0
 11942 6494 2C309DE5 		ldr	r3, [sp, #44]
 11943 6498 1CC09DE5 		ldr	ip, [sp, #28]
 11944              	.LVL1377:
 11945              	.L856:
2055:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 11946              		.loc 1 2055 0
 11947 649c 7A27DAE5 		ldrb	r2, [r10, #1914]	@ zero_extendqisi2
 11948 64a0 28009DE5 		ldr	r0, [sp, #40]
 11949 64a4 020050E1 		cmp	r0, r2
 11950 64a8 0A00000A 		beq	.L857
2057:../uvc.c      **** 									 }
 11951              		.loc 1 2057 0
 11952 64ac 0420A0E1 		mov	r2, r4
2056:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11953              		.loc 1 2056 0
 11954 64b0 38E19FE5 		ldr	lr, .L983
 11955 64b4 28409DE5 		ldr	r4, [sp, #40]
 11956              	.LVL1378:
2057:../uvc.c      **** 									 }
 11957              		.loc 1 2057 0
 11958 64b8 09008DE8 		stmia	sp, {r0, r3}
 11959 64bc 30309DE5 		ldr	r3, [sp, #48]
 11960              	.LVL1379:
2056:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11961              		.loc 1 2056 0
 11962 64c0 7A47CEE5 		strb	r4, [lr, #1914]
2057:../uvc.c      **** 									 }
 11963              		.loc 1 2057 0
 11964 64c4 2C019FE5 		ldr	r0, .L983+8
 11965 64c8 2A10A0E3 		mov	r1, #42
 11966 64cc 1CC08DE5 		str	ip, [sp, #28]
 11967 64d0 FEFFFFEB 		bl	cmdSet
 11968              	.LVL1380:
 11969 64d4 1CC09DE5 		ldr	ip, [sp, #28]
 11970              	.L857:
2060:../uvc.c      **** 
 11971              		.loc 1 2060 0
 11972 64d8 1C0095E5 		ldr	r0, [r5, #28]
2059:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11973              		.loc 1 2059 0
 11974 64dc 0130A0E3 		mov	r3, #1
2060:../uvc.c      **** 
 11975              		.loc 1 2060 0
 11976 64e0 1CC08DE5 		str	ip, [sp, #28]
2059:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11977              		.loc 1 2059 0
 11978 64e4 7D37CAE5 		strb	r3, [r10, #1917]
2060:../uvc.c      **** 
 11979              		.loc 1 2060 0
 11980 64e8 FEFFFFEB 		bl	_txe_mutex_put
 11981              	.LVL1381:
 11982 64ec 1CC09DE5 		ldr	ip, [sp, #28]
 11983 64f0 A6FCFFEA 		b	.L855
 11984              	.LVL1382:
 11985              	.L980:
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11986              		.loc 1 1507 0
 11987 64f4 0400A0E1 		mov	r0, r4
 11988 64f8 30109DE5 		ldr	r1, [sp, #48]
 11989 64fc 20308DE5 		str	r3, [sp, #32]
 11990 6500 FEFFFFEB 		bl	SensorGetControl
 11991              	.LVL1383:
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11992              		.loc 1 1509 0
 11993 6504 30109DE5 		ldr	r1, [sp, #48]
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11994              		.loc 1 1507 0
 11995 6508 0020A0E1 		mov	r2, r0
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11996              		.loc 1 1509 0
 11997 650c 34009DE5 		ldr	r0, [sp, #52]
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11998              		.loc 1 1507 0
 11999 6510 2820C7E5 		strb	r2, [r7, #40]
1508:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 12000              		.loc 1 1508 0
 12001 6514 7927CAE5 		strb	r2, [r10, #1913]
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12002              		.loc 1 1509 0
 12003 6518 FEFFFFEB 		bl	SensorGetControl
 12004              	.LVL1384:
1511:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 12005              		.loc 1 1511 0
 12006 651c 0020A0E3 		mov	r2, #0
 12007 6520 2920C7E5 		strb	r2, [r7, #41]
1512:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12008              		.loc 1 1512 0
 12009 6524 2B20C7E5 		strb	r2, [r7, #43]
1513:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 12010              		.loc 1 1513 0
 12011 6528 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 12012              	.LVL1385:
 12013 652c 20309DE5 		ldr	r3, [sp, #32]
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12014              		.loc 1 1509 0
 12015 6530 0040A0E1 		mov	r4, r0
 12016              	.LVL1386:
 12017 6534 2A00C7E5 		strb	r0, [r7, #42]
1510:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12018              		.loc 1 1510 0
 12019 6538 7A07CAE5 		strb	r0, [r10, #1914]
 12020 653c 8FFEFFEA 		b	.L846
 12021              	.LVL1387:
 12022              	.L977:
 12023              	.LBE165:
 12024              	.LBE214:
 12025              	.LBB215:
 12026              	.LBB189:
1500:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12027              		.loc 1 1500 0
 12028 6540 34009DE5 		ldr	r0, [sp, #52]
 12029 6544 30109DE5 		ldr	r1, [sp, #48]
 12030 6548 20308DE5 		str	r3, [sp, #32]
 12031 654c FEFFFFEB 		bl	SensorGetControl
 12032              	.LVL1388:
1501:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12033              		.loc 1 1501 0
 12034 6550 98E09FE5 		ldr	lr, .L983
1502:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 12035              		.loc 1 1502 0
 12036 6554 0040A0E3 		mov	r4, #0
 12037              	.LVL1389:
 12038 6558 2940C7E5 		strb	r4, [r7, #41]
1501:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12039              		.loc 1 1501 0
 12040 655c 8D07CEE5 		strb	r0, [lr, #1933]
1503:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12041              		.loc 1 1503 0
 12042 6560 8E47CEE5 		strb	r4, [lr, #1934]
1500:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12043              		.loc 1 1500 0
 12044 6564 0050A0E1 		mov	r5, r0
 12045              	.LVL1390:
 12046 6568 2800C7E5 		strb	r0, [r7, #40]
 12047 656c 20309DE5 		ldr	r3, [sp, #32]
 12048 6570 43FEFFEA 		b	.L870
 12049              	.LVL1391:
 12050              	.L979:
 12051              	.LBE189:
 12052              	.LBE215:
 12053              	.LBB216:
 12054              	.LBB166:
 12055 6574 34009DE5 		ldr	r0, [sp, #52]
 12056 6578 30109DE5 		ldr	r1, [sp, #48]
 12057 657c 20308DE5 		str	r3, [sp, #32]
 12058 6580 FEFFFFEB 		bl	SensorGetControl
 12059              	.LVL1392:
1502:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 12060              		.loc 1 1502 0
 12061 6584 0040A0E3 		mov	r4, #0
 12062              	.LVL1393:
 12063 6588 2940C7E5 		strb	r4, [r7, #41]
 12064 658c 20309DE5 		ldr	r3, [sp, #32]
1501:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12065              		.loc 1 1501 0
 12066 6590 7907CAE5 		strb	r0, [r10, #1913]
1500:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12067              		.loc 1 1500 0
 12068 6594 0050A0E1 		mov	r5, r0
 12069 6598 2800C7E5 		strb	r0, [r7, #40]
1503:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12070              		.loc 1 1503 0
 12071 659c 7A47CAE5 		strb	r4, [r10, #1914]
 12072              	.LVL1394:
 12073 65a0 76FEFFEA 		b	.L846
 12074              	.LVL1395:
 12075              	.L978:
 12076              	.LBE166:
 12077              	.LBE216:
 12078              	.LBB217:
 12079              	.LBB190:
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12080              		.loc 1 1507 0
 12081 65a4 0400A0E1 		mov	r0, r4
 12082 65a8 30109DE5 		ldr	r1, [sp, #48]
 12083 65ac 20308DE5 		str	r3, [sp, #32]
 12084 65b0 FEFFFFEB 		bl	SensorGetControl
 12085              	.LVL1396:
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12086              		.loc 1 1509 0
 12087 65b4 30109DE5 		ldr	r1, [sp, #48]
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12088              		.loc 1 1507 0
 12089 65b8 0020A0E1 		mov	r2, r0
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12090              		.loc 1 1509 0
 12091 65bc 34009DE5 		ldr	r0, [sp, #52]
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12092              		.loc 1 1507 0
 12093 65c0 2820C7E5 		strb	r2, [r7, #40]
1508:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 12094              		.loc 1 1508 0
 12095 65c4 8D27CAE5 		strb	r2, [r10, #1933]
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12096              		.loc 1 1509 0
 12097 65c8 FEFFFFEB 		bl	SensorGetControl
 12098              	.LVL1397:
1511:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 12099              		.loc 1 1511 0
 12100 65cc 0020A0E3 		mov	r2, #0
 12101 65d0 2920C7E5 		strb	r2, [r7, #41]
1512:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12102              		.loc 1 1512 0
 12103 65d4 2B20C7E5 		strb	r2, [r7, #43]
1513:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 12104              		.loc 1 1513 0
 12105 65d8 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 12106              	.LVL1398:
 12107 65dc 20309DE5 		ldr	r3, [sp, #32]
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12108              		.loc 1 1509 0
 12109 65e0 0040A0E1 		mov	r4, r0
 12110              	.LVL1399:
 12111 65e4 2A00C7E5 		strb	r0, [r7, #42]
1510:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12112              		.loc 1 1510 0
 12113 65e8 8E07CAE5 		strb	r0, [r10, #1934]
 12114 65ec 24FEFFEA 		b	.L870
 12115              	.L984:
 12116              		.align	2
 12117              	.L983:
 12118 65f0 00000000 		.word	.LANCHOR1
 12119 65f4 68040000 		.word	.LC27
 12120 65f8 00000000 		.word	cmdQu
 12121              	.LBE190:
 12122              	.LBE217:
 12123              	.LBE228:
 12124              	.LBE409:
 12125              		.cfi_endproc
 12126              	.LFE25:
 12128              		.align	2
 12129              		.global	CyFxGpifCB
 12131              	CyFxGpifCB:
 12132              	.LFB13:
3034:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 12133              		.loc 1 3034 0
 12134              		.cfi_startproc
 12135              		@ args = 0, pretend = 0, frame = 0
 12136              		@ frame_needed = 0, uses_anonymous_args = 0
3035:../uvc.c      ****     {
 12137              		.loc 1 3035 0
 12138 65fc 010050E3 		cmp	r0, #1
3034:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 12139              		.loc 1 3034 0
 12140 6600 10402DE9 		stmfd	sp!, {r4, lr}
 12141              	.LCFI29:
 12142              		.cfi_def_cfa_offset 8
 12143              		.cfi_offset 4, -8
 12144              		.cfi_offset 14, -4
3035:../uvc.c      ****     {
 12145              		.loc 1 3035 0
 12146 6604 1080BD18 		ldmnefd	sp!, {r4, pc}
 12147              	.LBB414:
 12148              	.LBB415:
2932:../uvc.c      ****     {
 12149              		.loc 1 2932 0
 12150 6608 C4309FE5 		ldr	r3, .L1002
 12151 660c 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 12152 6610 030053E3 		cmp	r3, #3
 12153 6614 1000000A 		beq	.L1001
2958:../uvc.c      ****     {
 12154              		.loc 1 2958 0
 12155 6618 020053E3 		cmp	r3, #2
 12156 661c 1080BD18 		ldmnefd	sp!, {r4, pc}
2960:../uvc.c      ****         {
 12157              		.loc 1 2960 0
 12158 6620 083041E2 		sub	r3, r1, #8
 12159 6624 0A0053E3 		cmp	r3, #10
 12160 6628 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 12161 662c 200000EA 		b	.L994
 12162              	.L996:
 12163 6630 AC660000 		.word	.L989
 12164 6634 B4660000 		.word	.L994
 12165 6638 B4660000 		.word	.L994
 12166 663c 7C660000 		.word	.L985
 12167 6640 B4660000 		.word	.L994
 12168 6644 B4660000 		.word	.L994
 12169 6648 B4660000 		.word	.L994
 12170 664c 80660000 		.word	.L1000
 12171 6650 B4660000 		.word	.L994
 12172 6654 B4660000 		.word	.L994
 12173 6658 7C660000 		.word	.L985
 12174              	.L1001:
2934:../uvc.c      ****         {
 12175              		.loc 1 2934 0
 12176 665c 0B1041E2 		sub	r1, r1, #11
 12177 6660 030051E3 		cmp	r1, #3
 12178 6664 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 12179 6668 150000EA 		b	.L988
 12180              	.L990:
 12181 666c AC660000 		.word	.L989
 12182 6670 80660000 		.word	.L1000
 12183 6674 7C660000 		.word	.L985
 12184 6678 7C660000 		.word	.L985
 12185              	.L985:
 12186 667c 1080BDE8 		ldmfd	sp!, {r4, pc}
 12187              	.L1000:
2960:../uvc.c      ****         {
 12188              		.loc 1 2960 0
 12189 6680 0110A0E3 		mov	r1, #1
 12190              	.L991:
3017:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 12191              		.loc 1 3017 0
 12192 6684 4C009FE5 		ldr	r0, .L1002+4
 12193 6688 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
3018:../uvc.c      ****         {
 12194              		.loc 1 3018 0
 12195 668c 004050E2 		subs	r4, r0, #0
 12196 6690 1080BD08 		ldmeqfd	sp!, {r4, pc}
3020:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
 12197              		.loc 1 3020 0
 12198 6694 0400A0E3 		mov	r0, #4
 12199 6698 3C109FE5 		ldr	r1, .L1002+8
 12200 669c 0420A0E1 		mov	r2, r4
 12201 66a0 FEFFFFEB 		bl	CyU3PDebugPrint
3021:../uvc.c      ****         }
 12202              		.loc 1 3021 0
 12203 66a4 0400A0E1 		mov	r0, r4
 12204 66a8 FEFFFFEB 		bl	CyFxAppErrorHandler
 12205              	.L989:
2934:../uvc.c      ****         {
 12206              		.loc 1 2934 0
 12207 66ac 0010A0E3 		mov	r1, #0
 12208 66b0 F3FFFFEA 		b	.L991
 12209              	.L994:
3006:../uvc.c      ****                 /* Unexpected current state. Return error. */
 12210              		.loc 1 3006 0
 12211 66b4 0120A0E1 		mov	r2, r1
 12212 66b8 0100A0E3 		mov	r0, #1
 12213 66bc 1C109FE5 		ldr	r1, .L1002+12
 12214 66c0 FEFFFFEB 		bl	CyU3PDebugPrint
 12215              	.L988:
 12216              	.LBE415:
 12217              	.LBE414:
 12218              	.LBB416:
 12219              	.LBB417:
3041:../uvc.c      ****     }
 12220              		.loc 1 3041 0
 12221 66c4 0400A0E3 		mov	r0, #4
 12222 66c8 14109FE5 		ldr	r1, .L1002+16
 12223              	.LBE417:
 12224              	.LBE416:
3044:../uvc.c      **** 
 12225              		.loc 1 3044 0
 12226 66cc 1040BDE8 		ldmfd	sp!, {r4, lr}
 12227              	.LBB419:
 12228              	.LBB418:
3041:../uvc.c      ****     }
 12229              		.loc 1 3041 0
 12230 66d0 FEFFFFEA 		b	CyU3PDebugPrint
 12231              	.L1003:
 12232              		.align	2
 12233              	.L1002:
 12234 66d4 00000000 		.word	.LANCHOR0
 12235 66d8 00000000 		.word	glChHandleUVCStream
 12236 66dc 3C0E0000 		.word	.LC81
 12237 66e0 240E0000 		.word	.LC80
 12238 66e4 6C0E0000 		.word	.LC82
 12239              	.LBE418:
 12240              	.LBE419:
 12241              		.cfi_endproc
 12242              	.LFE13:
 12244              		.align	2
 12245              		.global	CyFxApplicationDefine
 12247              	CyFxApplicationDefine:
 12248              	.LFB27:
5271:../uvc.c      **** }
5272:../uvc.c      **** 
5273:../uvc.c      **** 
5274:../uvc.c      **** /*
5275:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
5276:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
5277:../uvc.c      ****  */
5278:../uvc.c      **** void
5279:../uvc.c      **** CyFxApplicationDefine (
5280:../uvc.c      ****         void)
5281:../uvc.c      **** {
 12249              		.loc 1 5281 0
 12250              		.cfi_startproc
 12251              		@ args = 0, pretend = 0, frame = 32
 12252              		@ frame_needed = 0, uses_anonymous_args = 0
 12253              	.LVL1400:
 12254 66e8 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 12255              	.LCFI30:
 12256              		.cfi_def_cfa_offset 32
 12257              		.cfi_offset 4, -32
 12258              		.cfi_offset 5, -28
 12259              		.cfi_offset 6, -24
 12260              		.cfi_offset 7, -20
 12261              		.cfi_offset 8, -16
 12262              		.cfi_offset 9, -12
 12263              		.cfi_offset 10, -8
 12264              		.cfi_offset 14, -4
5282:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
5283:../uvc.c      ****     uint32_t retThrdCreate;
5284:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
5285:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
5286:../uvc.c      **** 
5287:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
5288:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12265              		.loc 1 5288 0
 12266 66ec 010AA0E3 		mov	r0, #4096
5281:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
 12267              		.loc 1 5281 0
 12268 66f0 40D04DE2 		sub	sp, sp, #64
 12269              	.LCFI31:
 12270              		.cfi_def_cfa_offset 96
 12271              		.loc 1 5288 0
 12272 66f4 FEFFFFEB 		bl	CyU3PMemAlloc
 12273              	.LVL1401:
 12274 66f8 0070A0E1 		mov	r7, r0
 12275              	.LVL1402:
5289:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12276              		.loc 1 5289 0
 12277 66fc 010AA0E3 		mov	r0, #4096
 12278              	.LVL1403:
 12279 6700 FEFFFFEB 		bl	CyU3PMemAlloc
 12280              	.LVL1404:
 12281 6704 0060A0E1 		mov	r6, r0
 12282              	.LVL1405:
5290:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12283              		.loc 1 5290 0
 12284 6708 010AA0E3 		mov	r0, #4096
 12285              	.LVL1406:
 12286 670c FEFFFFEB 		bl	CyU3PMemAlloc
 12287              	.LVL1407:
5291:../uvc.c      **** 
5292:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 12288              		.loc 1 5292 0
 12289 6710 000056E3 		cmp	r6, #0
 12290 6714 00005713 		cmpne	r7, #0
 12291 6718 00A0A013 		movne	r10, #0
 12292 671c 01A0A003 		moveq	r10, #1
5290:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12293              		.loc 1 5290 0
 12294 6720 0090A0E1 		mov	r9, r0
 12295              	.LVL1408:
 12296              		.loc 1 5292 0
 12297 6724 0000001A 		bne	.L1015
 12298              	.LVL1409:
 12299              	.L1005:
 12300              	.L1007:
 12301 6728 FEFFFFEA 		b	.L1007
 12302              	.LVL1410:
 12303              	.L1015:
 12304              		.loc 1 5292 0 is_stmt 0 discriminator 1
 12305 672c 000050E3 		cmp	r0, #0
 12306 6730 FCFFFF0A 		beq	.L1005
 12307              	.LVL1411:
5293:../uvc.c      ****         goto fatalErrorHandler;
5294:../uvc.c      **** 
5295:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
5296:../uvc.c      ****     char *cmdName = "I2CcmdQue";
5297:../uvc.c      ****     char *staName = "I2CstaQue";
5298:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 12308              		.loc 1 5298 0 is_stmt 1
 12309 6734 F4309FE5 		ldr	r3, .L1016
 12310 6738 20008DE2 		add	r0, sp, #32
 12311              	.LVL1412:
 12312 673c 00308DE5 		str	r3, [sp]
 12313 6740 4010A0E3 		mov	r1, #64
 12314 6744 E8209FE5 		ldr	r2, .L1016+4
 12315 6748 0A30A0E1 		mov	r3, r10
 12316 674c FEFFFFEB 		bl	cmdbufCreate
 12317              	.LVL1413:
 12318 6750 20E08DE2 		add	lr, sp, #32
 12319 6754 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 12320 6758 D8C09FE5 		ldr	ip, .L1016+8
5299:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
5300:../uvc.c      **** 	//VdRingBuf  cmdbufCreate(uint16_t size, char * name, uint8_t id, CyU3PMutex *muxPtr);
5301:../uvc.c      **** 
5302:../uvc.c      **** 	/****** initialize command descriptor ***********/
5303:../uvc.c      **** 	cmdquInit(cmdQuptr);
5304:../uvc.c      **** 	cmdquInit(statQuptr);
5305:../uvc.c      **** 
5306:../uvc.c      ****     /* Create the UVC application thread. */
5307:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 12321              		.loc 1 5307 0
 12322 675c 0840A0E3 		mov	r4, #8
5298:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 12323              		.loc 1 5298 0
 12324 6760 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 12325 6764 0F009EE8 		ldmia	lr, {r0, r1, r2, r3}
 12326              		.loc 1 5307 0
 12327 6768 0150A0E3 		mov	r5, #1
5298:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 12328              		.loc 1 5298 0
 12329 676c 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
5303:../uvc.c      **** 	cmdquInit(statQuptr);
 12330              		.loc 1 5303 0
 12331 6770 10004CE2 		sub	r0, ip, #16
 12332 6774 FEFFFFEB 		bl	cmdquInit
 12333              	.LVL1414:
5304:../uvc.c      **** 
 12334              		.loc 1 5304 0
 12335 6778 BC009FE5 		ldr	r0, .L1016+12
 12336 677c FEFFFFEB 		bl	cmdquInit
 12337              	.LVL1415:
 12338              		.loc 1 5307 0
 12339 6780 A880A0E3 		mov	r8, #168
 12340 6784 012AA0E3 		mov	r2, #4096
 12341 6788 0A30A0E1 		mov	r3, r10
 12342 678c 14008DE9 		stmib	sp, {r2, r4}
 12343 6790 A8009FE5 		ldr	r0, .L1016+16
 12344 6794 00708DE5 		str	r7, [sp]
 12345 6798 10A08DE5 		str	r10, [sp, #16]
 12346 679c 0C408DE5 		str	r4, [sp, #12]
 12347 67a0 14508DE5 		str	r5, [sp, #20]
 12348 67a4 18808DE5 		str	r8, [sp, #24]
 12349 67a8 94109FE5 		ldr	r1, .L1016+20
 12350 67ac 94209FE5 		ldr	r2, .L1016+24
 12351 67b0 FEFFFFEB 		bl	_txe_thread_create
 12352              	.LVL1416:
5308:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
5309:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
5310:../uvc.c      ****             0,                                          /* No input parameter to thread */
5311:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
5312:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
5313:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
5314:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
5315:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
5316:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
5317:../uvc.c      ****             );
5318:../uvc.c      ****     if (retThrdCreate != 0)
 12353              		.loc 1 5318 0
 12354 67b4 003050E2 		subs	r3, r0, #0
 12355 67b8 DAFFFF1A 		bne	.L1005
5319:../uvc.c      ****     {
5320:../uvc.c      ****         goto fatalErrorHandler;
5321:../uvc.c      ****     }
5322:../uvc.c      **** 
5323:../uvc.c      ****     /* Create the control request handling thread. */
5324:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 12356              		.loc 1 5324 0
 12357 67bc 027BA0E3 		mov	r7, #2048
 12358              	.LVL1417:
 12359 67c0 10308DE5 		str	r3, [sp, #16]
 12360 67c4 00608DE5 		str	r6, [sp]
 12361 67c8 08408DE5 		str	r4, [sp, #8]
 12362 67cc 0C408DE5 		str	r4, [sp, #12]
 12363 67d0 14508DE5 		str	r5, [sp, #20]
 12364 67d4 18808DE5 		str	r8, [sp, #24]
 12365 67d8 04708DE5 		str	r7, [sp, #4]
 12366 67dc 68009FE5 		ldr	r0, .L1016+28
 12367              	.LVL1418:
 12368 67e0 68109FE5 		ldr	r1, .L1016+32
 12369 67e4 68209FE5 		ldr	r2, .L1016+36
 12370 67e8 FEFFFFEB 		bl	_txe_thread_create
 12371              	.LVL1419:
5325:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
5326:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
5327:../uvc.c      ****             0,                                                  /* No input parameter to thread */
5328:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
5329:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
5330:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
5331:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
5332:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
5333:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
5334:../uvc.c      ****             );
5335:../uvc.c      ****     if (retThrdCreate != 0)
 12372              		.loc 1 5335 0
 12373 67ec 003050E2 		subs	r3, r0, #0
 12374 67f0 CCFFFF1A 		bne	.L1005
5336:../uvc.c      ****     {
5337:../uvc.c      ****         goto fatalErrorHandler;
5338:../uvc.c      ****     }
5339:../uvc.c      **** #if 1
5340:../uvc.c      ****     /* Create the I2C control command handling thread. */
5341:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 12375              		.loc 1 5341 0
 12376 67f4 00908DE5 		str	r9, [sp]
 12377 67f8 04708DE5 		str	r7, [sp, #4]
 12378 67fc 08408DE5 		str	r4, [sp, #8]
 12379 6800 0C408DE5 		str	r4, [sp, #12]
 12380 6804 10308DE5 		str	r3, [sp, #16]
 12381 6808 14508DE5 		str	r5, [sp, #20]
 12382 680c 18808DE5 		str	r8, [sp, #24]
 12383 6810 40009FE5 		ldr	r0, .L1016+40
 12384              	.LVL1420:
 12385 6814 40109FE5 		ldr	r1, .L1016+44
 12386 6818 40209FE5 		ldr	r2, .L1016+48
 12387 681c FEFFFFEB 		bl	_txe_thread_create
 12388              	.LVL1421:
5342:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
5343:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
5344:../uvc.c      ****             0,                                          /* No input parameter to thread */
5345:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
5346:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
5347:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
5348:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
5349:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
5350:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
5351:../uvc.c      ****             );
5352:../uvc.c      ****     if (retThrdCreate != 0)
 12389              		.loc 1 5352 0
 12390 6820 000050E3 		cmp	r0, #0
 12391 6824 BFFFFF1A 		bne	.L1005
5353:../uvc.c      ****     {
5354:../uvc.c      ****         goto fatalErrorHandler;
5355:../uvc.c      ****     }
5356:../uvc.c      **** #endif
5357:../uvc.c      **** 
5358:../uvc.c      ****     return;
5359:../uvc.c      **** 
5360:../uvc.c      **** fatalErrorHandler:
5361:../uvc.c      ****     /* Add custom recovery or debug actions here */
5362:../uvc.c      ****     /* Loop indefinitely */
5363:../uvc.c      ****     while (1);
5364:../uvc.c      **** }
 12392              		.loc 1 5364 0
 12393 6828 40D08DE2 		add	sp, sp, #64
 12394              		@ sp needed
 12395 682c F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, pc}
 12396              	.LVL1422:
 12397              	.L1017:
 12398              		.align	2
 12399              	.L1016:
 12400 6830 00000000 		.word	cmdQuMux
 12401 6834 840E0000 		.word	.LC83
 12402 6838 00000000 		.word	cmdQu
 12403 683c 00000000 		.word	statQu
 12404 6840 A4000000 		.word	.LANCHOR0+164
 12405 6844 900E0000 		.word	.LC84
 12406 6848 00000000 		.word	UVCAppThread_Entry
 12407 684c 4C010000 		.word	.LANCHOR0+332
 12408 6850 A40E0000 		.word	.LC85
 12409 6854 00000000 		.word	UVCAppEP0Thread_Entry
 12410 6858 F4010000 		.word	.LANCHOR0+500
 12411 685c BC0E0000 		.word	.LC86
 12412 6860 00000000 		.word	I2cAppThread_Entry
 12413              		.cfi_endproc
 12414              	.LFE27:
 12416              		.section	.text.startup,"ax",%progbits
 12417              		.align	2
 12418              		.global	main
 12420              	main:
 12421              	.LFB28:
5365:../uvc.c      **** 
5366:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
5367:../uvc.c      ****  * the ThreadX RTOS here.
5368:../uvc.c      ****  */
5369:../uvc.c      **** int
5370:../uvc.c      **** main (
5371:../uvc.c      ****         void)
5372:../uvc.c      **** {
 12422              		.loc 1 5372 0
 12423              		.cfi_startproc
 12424              		@ args = 0, pretend = 0, frame = 56
 12425              		@ frame_needed = 0, uses_anonymous_args = 0
 12426 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 12427              	.LCFI32:
 12428              		.cfi_def_cfa_offset 12
 12429              		.cfi_offset 4, -12
 12430              		.cfi_offset 5, -8
 12431              		.cfi_offset 14, -4
 12432 0004 3CD04DE2 		sub	sp, sp, #60
 12433              	.LCFI33:
 12434              		.cfi_def_cfa_offset 72
5373:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
5374:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
5375:../uvc.c      **** 
5376:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
5377:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
5378:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 12435              		.loc 1 5378 0
 12436 0008 0230A0E3 		mov	r3, #2
5379:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
5380:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
5381:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 12437              		.loc 1 5381 0
 12438 000c 0010A0E3 		mov	r1, #0
5382:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 12439              		.loc 1 5382 0
 12440 0010 0320A0E3 		mov	r2, #3
5377:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 12441              		.loc 1 5377 0
 12442 0014 0150A0E3 		mov	r5, #1
5383:../uvc.c      **** 
5384:../uvc.c      ****     /* Initialize the device */
5385:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 12443              		.loc 1 5385 0
 12444 0018 0D00A0E1 		mov	r0, sp
5377:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 12445              		.loc 1 5377 0
 12446 001c 00508DE5 		str	r5, [sp]
5378:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 12447              		.loc 1 5378 0
 12448 0020 0430CDE5 		strb	r3, [sp, #4]
5379:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 12449              		.loc 1 5379 0
 12450 0024 0530CDE5 		strb	r3, [sp, #5]
5380:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 12451              		.loc 1 5380 0
 12452 0028 0630CDE5 		strb	r3, [sp, #6]
5381:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 12453              		.loc 1 5381 0
 12454 002c 08108DE5 		str	r1, [sp, #8]
5382:../uvc.c      **** 
 12455              		.loc 1 5382 0
 12456 0030 0C20CDE5 		strb	r2, [sp, #12]
 12457              		.loc 1 5385 0
 12458 0034 FEFFFFEB 		bl	CyU3PDeviceInit
 12459              	.LVL1423:
5386:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 12460              		.loc 1 5386 0
 12461 0038 004050E2 		subs	r4, r0, #0
 12462 003c 0000000A 		beq	.L1023
 12463              	.L1019:
 12464              	.L1020:
 12465 0040 FEFFFFEA 		b	.L1020
 12466              	.L1023:
5387:../uvc.c      ****     {
5388:../uvc.c      ****         goto handle_fatal_error;
5389:../uvc.c      ****     }
5390:../uvc.c      **** 
5391:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
5392:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 12467              		.loc 1 5392 0
 12468 0044 0410A0E1 		mov	r1, r4
 12469 0048 0420A0E1 		mov	r2, r4
 12470 004c 0500A0E1 		mov	r0, r5
 12471              	.LVL1424:
 12472 0050 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 12473              	.LVL1425:
5393:../uvc.c      **** 
5394:../uvc.c      ****     /* Configure the IO matrix for the device. */
5395:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
5396:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
5397:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
5398:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
5399:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
5400:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
5401:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
5402:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
5403:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
5404:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
5405:../uvc.c      **** 
5406:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 12474              		.loc 1 5406 0
 12475 0054 10008DE2 		add	r0, sp, #16
5396:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 12476              		.loc 1 5396 0
 12477 0058 2640CDE5 		strb	r4, [sp, #38]
5397:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 12478              		.loc 1 5397 0
 12479 005c 28408DE5 		str	r4, [sp, #40]
5398:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 12480              		.loc 1 5398 0
 12481 0060 2C408DE5 		str	r4, [sp, #44]
5399:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 12482              		.loc 1 5399 0
 12483 0064 30408DE5 		str	r4, [sp, #48]
5400:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 12484              		.loc 1 5400 0
 12485 0068 34408DE5 		str	r4, [sp, #52]
5403:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 12486              		.loc 1 5403 0
 12487 006c 1C408DE5 		str	r4, [sp, #28]
5404:../uvc.c      **** 
 12488              		.loc 1 5404 0
 12489 0070 20408DE5 		str	r4, [sp, #32]
5395:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 12490              		.loc 1 5395 0
 12491 0074 10508DE5 		str	r5, [sp, #16]
5401:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 12492              		.loc 1 5401 0
 12493 0078 14508DE5 		str	r5, [sp, #20]
5402:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 12494              		.loc 1 5402 0
 12495 007c 18508DE5 		str	r5, [sp, #24]
 12496              		.loc 1 5406 0
 12497 0080 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 12498              	.LVL1426:
5407:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 12499              		.loc 1 5407 0
 12500 0084 004050E2 		subs	r4, r0, #0
 12501 0088 ECFFFF1A 		bne	.L1019
5408:../uvc.c      ****     {
5409:../uvc.c      ****         goto handle_fatal_error;
5410:../uvc.c      ****     }
5411:../uvc.c      **** 
5412:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
5413:../uvc.c      ****     CyU3PKernelEntry ();
 12502              		.loc 1 5413 0
 12503 008c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 12504              	.LVL1427:
5414:../uvc.c      **** 
5415:../uvc.c      ****     /* Dummy return to make the compiler happy */
5416:../uvc.c      ****     return 0;
5417:../uvc.c      **** 
5418:../uvc.c      **** handle_fatal_error:
5419:../uvc.c      ****     /* Cannot recover from this error. */
5420:../uvc.c      ****     while (1);
5421:../uvc.c      **** }
 12505              		.loc 1 5421 0
 12506 0090 0400A0E1 		mov	r0, r4
 12507 0094 3CD08DE2 		add	sp, sp, #60
 12508              		@ sp needed
 12509 0098 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 12510              		.cfi_endproc
 12511              	.LFE28:
 12513              		.comm	I2CCmdTimer,44,4
 12514              		.comm	posTick,4,4
 12515              		.global	glUVCHeader
 12516              		.global	glProbeStilCtrl20
 12517              		.global	glProbeCtrl20
 12518              		.global	glProbeStilCtrl
 12519              		.global	glProbeCtrlFull
 12520              		.global	glProbeCtrl
 12521              		.global	streamingStarted
 12522              		.global	clearFeatureRqtReceived
 12523              		.global	usbSpeed
 12524              		.global	isUsbConnected
 12525              		.global	pbcpbak
 12526              		.global	pbcbak
 12527              		.global	pbbak
 12528              		.global	fbbak
 12529              		.global	pbc
 12530              		.global	pb
 12531              		.global	fb
 12532              		.comm	wLength,2,2
 12533              		.comm	wIndex,2,2
 12534              		.comm	wValue,2,2
 12535              		.comm	bRequest,1,1
 12536              		.comm	bmReqType,1,1
 12537              		.comm	imgHdMux,56,4
 12538              		.comm	timMux,56,4
 12539              		.comm	staQuMux,56,4
 12540              		.comm	cmdQuMux,56,4
 12541              		.comm	statQu,32,4
 12542              		.comm	cmdQu,32,4
 12543              		.global	testSnap
 12544              		.global	snapButFlag
 12545              		.comm	glInterStaBuffer,4,4
 12546              		.comm	glChHandleInterStat,172,4
 12547              		.comm	glChHandleStillStream,232,4
 12548              		.comm	glChHandleUVCStream,232,4
 12549              		.global	CyFxGpifConfig_usb2
 12550              		.global	CyFxGpifRegValue_usb2
 12551              		.global	CyFxGpifWavedataPosition_usb2
 12552              		.global	CyFxGpifWavedata_usb2
 12553              		.global	CyFxGpifTransition_usb2
 12554              		.global	CyFxGpifConfig
 12555              		.global	CyFxGpifRegValue
 12556              		.global	CyFxGpifWavedataPosition
 12557              		.global	CyFxGpifWavedata
 12558              		.global	CyFxGpifTransition
 12559              		.section	.rodata
 12560              		.align	2
 12561              		.set	.LANCHOR2,. + 0
 12564              	ShutSp:
 12565 0000 3582     		.short	-32203
 12566 0002 1B41     		.short	16667
 12567 0004 8D20     		.short	8333
 12568 0006 A00F     		.short	4000
 12569 0008 D007     		.short	2000
 12570 000a E803     		.short	1000
 12571 000c F401     		.short	500
 12572 000e C800     		.short	200
 12573 0010 6400     		.short	100
 12574 0012 0A00     		.short	10
 12575 0014 0000     		.short	0
 12576 0016 00000000 		.space	10
 12576      00000000 
 12576      0000
 12579              	pEXTSenCtrl:
 12580 0020 B0050000 		.word	EXTShutter
 12581 0024 E8080000 		.word	EXTSensUp
 12582 0028 D4080000 		.word	EXTMirror
 12583 002c C0080000 		.word	EXT3DnoiseReduceMode
 12584 0030 AC080000 		.word	EXT3DNoiseLev
 12585 0034 98080000 		.word	EXTDayNightMode
 12586 0038 58070000 		.word	EXTDayNightdely
 12587 003c 84080000 		.word	EXTDayNightlev
 12588 0040 70080000 		.word	EXTNightDaylev
 12589 0044 0C050000 		.word	EXTAexModGainlev
 12590 0048 5C080000 		.word	EXTExpReflev
 12591 004c C4050000 		.word	EXTShutlev
 12592 0050 48080000 		.word	EXTCamMode
 12593 0054 00000000 		.word	0
 12594 0058 34080000 		.word	EXTSensorPare
 12595 005c 20080000 		.word	EXTI2Ccmd
 12596 0060 00000000 		.word	0
 12597 0064 00000000 		.word	0
 12598 0068 00000000 		.word	0
 12599 006c 00000000 		.word	0
 12600 0070 34050000 		.word	EXTBLCWinPos
 12601 0074 0C080000 		.word	EXTBLCWeight
 12602 0078 F8040000 		.word	EXTBLCGrid
 12603 007c F8070000 		.word	EXTExHyster
 12604 0080 20050000 		.word	EXTExCtrlSped
 12605 0084 E4070000 		.word	EXTEnhanceMode
 12606 0088 6C070000 		.word	EXTEnhanceGain
 12607 008c 80070000 		.word	EXTEnhanceSTED
 12608 0090 D0070000 		.word	EXT2DNRGain
 12609 0094 BC070000 		.word	EXT2DNRSTED
 12610 0098 A8070000 		.word	EXTGammaCor
 12611 009c 94070000 		.word	EXTAGCMaxLimit
 12612 00a0 00000000 		.word	0
 12613 00a4 00000000 		.space	124
 12613      00000000 
 12613      00000000 
 12613      00000000 
 12613      00000000 
 12616              	pPUCSenCtrl:
 12617 0120 9C050000 		.word	PUCBLC
 12618 0124 48050000 		.word	PUCBright
 12619 0128 4C090000 		.word	PUCContrast
 12620 012c 00000000 		.word	0
 12621 0130 70050000 		.word	PUCPLFreq
 12622 0134 5C050000 		.word	PUCHueC
 12623 0138 38090000 		.word	PUCSaturation
 12624 013c 88050000 		.word	PUCSharp
 12625 0140 00000000 		.word	0
 12626 0144 24090000 		.word	PUCWBMd
 12627 0148 00000000 		.word	0
 12628 014c 10090000 		.word	PUCWBLC
 12629 0150 00000000 		.word	0
 12630 0154 00000000 		.word	0
 12631 0158 FC080000 		.word	PUCDZoom
 12632 015c 00000000 		.word	0
 12635              	curFlag:
 12636 0160 00000000 		.space	64
 12636      00000000 
 12636      00000000 
 12636      00000000 
 12636      00000000 
 12639              	CyFxGpifConfig:
 12640 01a0 0F00     		.short	15
 12641 01a2 0000     		.space	2
 12642 01a4 00000000 		.word	CyFxGpifWavedata
 12643 01a8 00000000 		.word	CyFxGpifWavedataPosition
 12644 01ac 0500     		.short	5
 12645 01ae 0000     		.space	2
 12646 01b0 00000000 		.word	CyFxGpifTransition
 12647 01b4 4C00     		.short	76
 12648 01b6 0000     		.space	2
 12649 01b8 00000000 		.word	CyFxGpifRegValue
 12652              	CyFxGpifConfig_usb2:
 12653 01bc 9300     		.short	147
 12654 01be 0000     		.space	2
 12655 01c0 00000000 		.word	CyFxGpifWavedata_usb2
 12656 01c4 00000000 		.word	CyFxGpifWavedataPosition_usb2
 12657 01c8 0800     		.short	8
 12658 01ca 0000     		.space	2
 12659 01cc 00000000 		.word	CyFxGpifTransition_usb2
 12660 01d0 4C00     		.short	76
 12661 01d2 0000     		.space	2
 12662 01d4 00000000 		.word	CyFxGpifRegValue_usb2
 12663              		.data
 12664              		.align	2
 12665              		.set	.LANCHOR1,. + 0
 12668              	glProbeCtrlFull:
 12669 0000 00       		.byte	0
 12670 0001 00       		.byte	0
 12671 0002 01       		.byte	1
 12672 0003 01       		.byte	1
 12673 0004 15       		.byte	21
 12674 0005 16       		.byte	22
 12675 0006 05       		.byte	5
 12676 0007 00       		.byte	0
 12677 0008 00       		.byte	0
 12678 0009 00       		.byte	0
 12679 000a 00       		.byte	0
 12680 000b 00       		.byte	0
 12681 000c 00       		.byte	0
 12682 000d 00       		.byte	0
 12683 000e 00       		.byte	0
 12684 000f 00       		.byte	0
 12685 0010 00       		.byte	0
 12686 0011 00       		.byte	0
 12687 0012 00       		.byte	0
 12688 0013 C6       		.byte	-58
 12689 0014 99       		.byte	-103
 12690 0015 00       		.byte	0
 12691 0016 00       		.byte	0
 12692 0017 40       		.byte	64
 12693 0018 00       		.byte	0
 12694 0019 00       		.byte	0
 12695 001a 0000     		.space	2
 12698              	glProbeCtrl20:
 12699 001c 00       		.byte	0
 12700 001d 00       		.byte	0
 12701 001e 01       		.byte	1
 12702 001f 01       		.byte	1
 12703 0020 80       		.byte	-128
 12704 0021 1A       		.byte	26
 12705 0022 06       		.byte	6
 12706 0023 00       		.byte	0
 12707 0024 00       		.byte	0
 12708 0025 00       		.byte	0
 12709 0026 00       		.byte	0
 12710 0027 00       		.byte	0
 12711 0028 00       		.byte	0
 12712 0029 00       		.byte	0
 12713 002a 00       		.byte	0
 12714 002b 00       		.byte	0
 12715 002c 00       		.byte	0
 12716 002d 00       		.byte	0
 12717 002e 00       		.byte	0
 12718 002f D2       		.byte	-46
 12719 0030 0F       		.byte	15
 12720 0031 00       		.byte	0
 12721 0032 00       		.byte	0
 12722 0033 40       		.byte	64
 12723 0034 00       		.byte	0
 12724 0035 00       		.byte	0
 12725 0036 0000     		.space	2
 12728              	glProbeCtrl:
 12729 0038 00       		.byte	0
 12730 0039 00       		.byte	0
 12731 003a 01       		.byte	1
 12732 003b 01       		.byte	1
 12733 003c 15       		.byte	21
 12734 003d 16       		.byte	22
 12735 003e 05       		.byte	5
 12736 003f 00       		.byte	0
 12737 0040 00       		.byte	0
 12738 0041 00       		.byte	0
 12739 0042 00       		.byte	0
 12740 0043 00       		.byte	0
 12741 0044 00       		.byte	0
 12742 0045 00       		.byte	0
 12743 0046 00       		.byte	0
 12744 0047 00       		.byte	0
 12745 0048 00       		.byte	0
 12746 0049 00       		.byte	0
 12747 004a 00       		.byte	0
 12748 004b 48       		.byte	72
 12749 004c 3F       		.byte	63
 12750 004d 00       		.byte	0
 12751 004e 00       		.byte	0
 12752 004f 40       		.byte	64
 12753 0050 00       		.byte	0
 12754 0051 00       		.byte	0
 12757              	ROIMode:
 12758 0052 01       		.byte	1
 12759 0053 00       		.space	1
 12762              	glProbeStilCtrl:
 12763 0054 01       		.byte	1
 12764 0055 02       		.byte	2
 12765 0056 00       		.byte	0
 12766 0057 00       		.byte	0
 12767 0058 C6       		.byte	-58
 12768 0059 99       		.byte	-103
 12769 005a 00       		.byte	0
 12770 005b 00       		.byte	0
 12771 005c 40       		.byte	64
 12772 005d 00       		.byte	0
 12773 005e 00       		.byte	0
 12774 005f 00       		.space	1
 12777              	glProbeStilCtrl20:
 12778 0060 01       		.byte	1
 12779 0061 01       		.byte	1
 12780 0062 00       		.byte	0
 12781 0063 00       		.byte	0
 12782 0064 D2       		.byte	-46
 12783 0065 0F       		.byte	15
 12784 0066 00       		.byte	0
 12785 0067 00       		.byte	0
 12786 0068 40       		.byte	64
 12787 0069 00       		.byte	0
 12788 006a 00       		.byte	0
 12789 006b 00       		.space	1
 12792              	ExUCtrlParArry:
 12793 006c 00       		.byte	0
 12794 006d 00       		.byte	0
 12795 006e 04       		.byte	4
 12796 006f 01       		.byte	1
 12797 0070 00       		.byte	0
 12798 0071 38       		.byte	56
 12799 0072 01       		.byte	1
 12800 0073 01       		.byte	1
 12801 0074 00       		.byte	0
 12802 0075 03       		.byte	3
 12803 0076 00       		.byte	0
 12804 0077 4E       		.byte	78
 12805 0078 00       		.byte	0
 12806 0079 4E       		.byte	78
 12807 007a 00       		.byte	0
 12808 007b 30       		.byte	48
 12809 007c 01       		.byte	1
 12810 007d 00       		.byte	0
 12811 007e 00       		.byte	0
 12812 007f 00000000 		.space	5
 12812      00
 12813 0084 00       		.byte	0
 12814 0085 00       		.byte	0
 12815 0086 01       		.byte	1
 12816 0087 00       		.byte	0
 12817 0088 00       		.byte	0
 12818 0089 00       		.byte	0
 12819 008a 00       		.byte	0
 12820 008b 01       		.byte	1
 12821 008c 00       		.byte	0
 12822 008d 03       		.byte	3
 12823 008e 00       		.byte	0
 12824 008f 00       		.byte	0
 12825 0090 00       		.byte	0
 12826 0091 00       		.byte	0
 12827 0092 00       		.byte	0
 12828 0093 30       		.byte	48
 12829 0094 01       		.byte	1
 12830 0095 00       		.byte	0
 12831 0096 00       		.byte	0
 12832 0097 00000000 		.space	5
 12832      00
 12833 009c 00       		.byte	0
 12834 009d 00       		.byte	0
 12835 009e 02       		.byte	2
 12836 009f 00       		.byte	0
 12837 00a0 00       		.byte	0
 12838 00a1 FF       		.byte	-1
 12839 00a2 00       		.byte	0
 12840 00a3 01       		.byte	1
 12841 00a4 00       		.byte	0
 12842 00a5 03       		.byte	3
 12843 00a6 00       		.byte	0
 12844 00a7 01       		.byte	1
 12845 00a8 00       		.byte	0
 12846 00a9 00       		.byte	0
 12847 00aa 00       		.byte	0
 12848 00ab 30       		.byte	48
 12849 00ac 01       		.byte	1
 12850 00ad 01       		.byte	1
 12851 00ae 00       		.byte	0
 12852 00af 00000000 		.space	5
 12852      00
 12853 00b4 00       		.byte	0
 12854 00b5 00       		.byte	0
 12855 00b6 02       		.byte	2
 12856 00b7 00       		.byte	0
 12857 00b8 00       		.byte	0
 12858 00b9 00       		.byte	0
 12859 00ba 00       		.byte	0
 12860 00bb 00       		.byte	0
 12861 00bc 00       		.byte	0
 12862 00bd 03       		.byte	3
 12863 00be 00       		.byte	0
 12864 00bf 00       		.byte	0
 12865 00c0 00       		.byte	0
 12866 00c1 00       		.byte	0
 12867 00c2 00       		.byte	0
 12868 00c3 30       		.byte	48
 12869 00c4 01       		.byte	1
 12870 00c5 01       		.byte	1
 12871 00c6 00       		.byte	0
 12872 00c7 00000000 		.space	5
 12872      00
 12873 00cc 13       		.byte	19
 12874 00cd 14       		.byte	20
 12875 00ce 02       		.byte	2
 12876 00cf 00       		.byte	0
 12877 00d0 00       		.byte	0
 12878 00d1 FF       		.byte	-1
 12879 00d2 FF       		.byte	-1
 12880 00d3 01       		.byte	1
 12881 00d4 00       		.byte	0
 12882 00d5 03       		.byte	3
 12883 00d6 00       		.byte	0
 12884 00d7 66       		.byte	102
 12885 00d8 66       		.byte	102
 12886 00d9 66       		.byte	102
 12887 00da 66       		.byte	102
 12888 00db 30       		.byte	48
 12889 00dc 01       		.byte	1
 12890 00dd 00       		.byte	0
 12891 00de 00       		.byte	0
 12892 00df 00000000 		.space	5
 12892      00
 12893 00e4 11       		.byte	17
 12894 00e5 00       		.byte	0
 12895 00e6 02       		.byte	2
 12896 00e7 01       		.byte	1
 12897 00e8 00       		.byte	0
 12898 00e9 03       		.byte	3
 12899 00ea 00       		.byte	0
 12900 00eb 01       		.byte	1
 12901 00ec 00       		.byte	0
 12902 00ed 03       		.byte	3
 12903 00ee 00       		.byte	0
 12904 00ef 80       		.byte	-128
 12905 00f0 00       		.byte	0
 12906 00f1 80       		.byte	-128
 12907 00f2 00       		.byte	0
 12908 00f3 30       		.byte	48
 12909 00f4 01       		.byte	1
 12910 00f5 01       		.byte	1
 12911 00f6 00       		.byte	0
 12912 00f7 00000000 		.space	5
 12912      00
 12913 00fc 10       		.byte	16
 12914 00fd 00       		.byte	0
 12915 00fe 01       		.byte	1
 12916 00ff 01       		.byte	1
 12917 0100 00       		.byte	0
 12918 0101 02       		.byte	2
 12919 0102 00       		.byte	0
 12920 0103 01       		.byte	1
 12921 0104 00       		.byte	0
 12922 0105 03       		.byte	3
 12923 0106 00       		.byte	0
 12924 0107 00       		.byte	0
 12925 0108 00       		.byte	0
 12926 0109 00       		.byte	0
 12927 010a 00       		.byte	0
 12928 010b 30       		.byte	48
 12929 010c 01       		.byte	1
 12930 010d 01       		.byte	1
 12931 010e 00       		.byte	0
 12932 010f 00000000 		.space	5
 12932      00
 12933 0114 00       		.byte	0
 12934 0115 00       		.byte	0
 12935 0116 04       		.byte	4
 12936 0117 01       		.byte	1
 12937 0118 00       		.byte	0
 12938 0119 38       		.byte	56
 12939 011a 01       		.byte	1
 12940 011b 01       		.byte	1
 12941 011c 00       		.byte	0
 12942 011d 03       		.byte	3
 12943 011e 00       		.byte	0
 12944 011f 4E       		.byte	78
 12945 0120 00       		.byte	0
 12946 0121 4E       		.byte	78
 12947 0122 00       		.byte	0
 12948 0123 30       		.byte	48
 12949 0124 01       		.byte	1
 12950 0125 00       		.byte	0
 12951 0126 00       		.byte	0
 12952 0127 00000000 		.space	5
 12952      00
 12953 012c 00       		.byte	0
 12954 012d 00       		.byte	0
 12955 012e 01       		.byte	1
 12956 012f 00       		.byte	0
 12957 0130 00       		.byte	0
 12958 0131 00       		.byte	0
 12959 0132 00       		.byte	0
 12960 0133 01       		.byte	1
 12961 0134 00       		.byte	0
 12962 0135 03       		.byte	3
 12963 0136 00       		.byte	0
 12964 0137 00       		.byte	0
 12965 0138 00       		.byte	0
 12966 0139 00       		.byte	0
 12967 013a 00       		.byte	0
 12968 013b 30       		.byte	48
 12969 013c 01       		.byte	1
 12970 013d 00       		.byte	0
 12971 013e 00       		.byte	0
 12972 013f 00000000 		.space	5
 12972      00
 12973 0144 00       		.byte	0
 12974 0145 00       		.byte	0
 12975 0146 02       		.byte	2
 12976 0147 00       		.byte	0
 12977 0148 00       		.byte	0
 12978 0149 05       		.byte	5
 12979 014a 00       		.byte	0
 12980 014b 01       		.byte	1
 12981 014c 00       		.byte	0
 12982 014d 03       		.byte	3
 12983 014e 00       		.byte	0
 12984 014f 00       		.byte	0
 12985 0150 00       		.byte	0
 12986 0151 00       		.byte	0
 12987 0152 00       		.byte	0
 12988 0153 30       		.byte	48
 12989 0154 01       		.byte	1
 12990 0155 00       		.byte	0
 12991 0156 00       		.byte	0
 12992 0157 00000000 		.space	5
 12992      00
 12993 015c 00       		.byte	0
 12994 015d 00       		.byte	0
 12995 015e 03       		.byte	3
 12996 015f 00       		.byte	0
 12997 0160 00       		.byte	0
 12998 0161 0A       		.byte	10
 12999 0162 00       		.byte	0
 13000 0163 01       		.byte	1
 13001 0164 00       		.byte	0
 13002 0165 03       		.byte	3
 13003 0166 00       		.byte	0
 13004 0167 00       		.byte	0
 13005 0168 00       		.byte	0
 13006 0169 00       		.byte	0
 13007 016a 00       		.byte	0
 13008 016b 30       		.byte	48
 13009 016c 01       		.byte	1
 13010 016d 00       		.byte	0
 13011 016e 00       		.byte	0
 13012 016f 00000000 		.space	5
 13012      00
 13013 0174 00       		.byte	0
 13014 0175 00       		.byte	0
 13015 0176 02       		.byte	2
 13016 0177 00       		.byte	0
 13017 0178 00       		.byte	0
 13018 0179 40       		.byte	64
 13019 017a 00       		.byte	0
 13020 017b 01       		.byte	1
 13021 017c 00       		.byte	0
 13022 017d 03       		.byte	3
 13023 017e 00       		.byte	0
 13024 017f 0F       		.byte	15
 13025 0180 11       		.byte	17
 13026 0181 00       		.byte	0
 13027 0182 00       		.byte	0
 13028 0183 30       		.byte	48
 13029 0184 01       		.byte	1
 13030 0185 00       		.byte	0
 13031 0186 00       		.byte	0
 13032 0187 00000000 		.space	5
 13032      00
 13033 018c 00       		.byte	0
 13034 018d 00       		.byte	0
 13035 018e 02       		.byte	2
 13036 018f 00       		.byte	0
 13037 0190 00       		.byte	0
 13038 0191 64       		.byte	100
 13039 0192 00       		.byte	0
 13040 0193 01       		.byte	1
 13041 0194 00       		.byte	0
 13042 0195 03       		.byte	3
 13043 0196 00       		.byte	0
 13044 0197 00       		.byte	0
 13045 0198 00       		.byte	0
 13046 0199 00       		.byte	0
 13047 019a 00       		.byte	0
 13048 019b 30       		.byte	48
 13049 019c 01       		.byte	1
 13050 019d 00       		.byte	0
 13051 019e 00       		.byte	0
 13052 019f 00000000 		.space	5
 13052      00
 13053 01a4 00       		.byte	0
 13054 01a5 00       		.byte	0
 13055 01a6 02       		.byte	2
 13056 01a7 00       		.byte	0
 13057 01a8 00       		.byte	0
 13058 01a9 64       		.byte	100
 13059 01aa 00       		.byte	0
 13060 01ab 01       		.byte	1
 13061 01ac 00       		.byte	0
 13062 01ad 03       		.byte	3
 13063 01ae 00       		.byte	0
 13064 01af 00       		.byte	0
 13065 01b0 00       		.byte	0
 13066 01b1 00       		.byte	0
 13067 01b2 00       		.byte	0
 13068 01b3 30       		.byte	48
 13069 01b4 01       		.byte	1
 13070 01b5 00       		.byte	0
 13071 01b6 00       		.byte	0
 13072 01b7 00000000 		.space	5
 13072      00
 13073 01bc 00       		.byte	0
 13074 01bd 00       		.byte	0
 13075 01be 02       		.byte	2
 13076 01bf 00       		.byte	0
 13077 01c0 00       		.byte	0
 13078 01c1 64       		.byte	100
 13079 01c2 00       		.byte	0
 13080 01c3 01       		.byte	1
 13081 01c4 00       		.byte	0
 13082 01c5 03       		.byte	3
 13083 01c6 00       		.byte	0
 13084 01c7 00       		.byte	0
 13085 01c8 00       		.byte	0
 13086 01c9 00       		.byte	0
 13087 01ca 00       		.byte	0
 13088 01cb 30       		.byte	48
 13089 01cc 01       		.byte	1
 13090 01cd 00       		.byte	0
 13091 01ce 00       		.byte	0
 13092 01cf 00000000 		.space	5
 13092      00
 13093 01d4 00       		.byte	0
 13094 01d5 00       		.byte	0
 13095 01d6 02       		.byte	2
 13096 01d7 00       		.byte	0
 13097 01d8 00       		.byte	0
 13098 01d9 64       		.byte	100
 13099 01da 00       		.byte	0
 13100 01db 01       		.byte	1
 13101 01dc 00       		.byte	0
 13102 01dd 03       		.byte	3
 13103 01de 00       		.byte	0
 13104 01df 00       		.byte	0
 13105 01e0 00       		.byte	0
 13106 01e1 00       		.byte	0
 13107 01e2 00       		.byte	0
 13108 01e3 30       		.byte	48
 13109 01e4 01       		.byte	1
 13110 01e5 00       		.byte	0
 13111 01e6 00       		.byte	0
 13112 01e7 00000000 		.space	5
 13112      00
 13115              	CtrlParArry:
 13116 01ec 10       		.byte	16
 13117 01ed 10       		.byte	16
 13118 01ee 02       		.byte	2
 13119 01ef 00       		.byte	0
 13120 01f0 00       		.byte	0
 13121 01f1 03       		.byte	3
 13122 01f2 00       		.byte	0
 13123 01f3 01       		.byte	1
 13124 01f4 00       		.byte	0
 13125 01f5 03       		.byte	3
 13126 01f6 00       		.byte	0
 13127 01f7 03       		.byte	3
 13128 01f8 00       		.byte	0
 13129 01f9 03       		.byte	3
 13130 01fa 00       		.byte	0
 13131 01fb 30       		.byte	48
 13132 01fc 01       		.byte	1
 13133 01fd 00       		.byte	0
 13134 01fe 00       		.byte	0
 13135 01ff 00000000 		.space	5
 13135      00
 13136 0204 15       		.byte	21
 13137 0205 15       		.byte	21
 13138 0206 02       		.byte	2
 13139 0207 00       		.byte	0
 13140 0208 00       		.byte	0
 13141 0209 FF       		.byte	-1
 13142 020a 00       		.byte	0
 13143 020b 01       		.byte	1
 13144 020c 00       		.byte	0
 13145 020d 03       		.byte	3
 13146 020e 00       		.byte	0
 13147 020f 76       		.byte	118
 13148 0210 00       		.byte	0
 13149 0211 76       		.byte	118
 13150 0212 C7       		.byte	-57
 13151 0213 30       		.byte	48
 13152 0214 01       		.byte	1
 13153 0215 01       		.byte	1
 13154 0216 00       		.byte	0
 13155 0217 00000000 		.space	5
 13155      00
 13156 021c 04       		.byte	4
 13157 021d 04       		.byte	4
 13158 021e 02       		.byte	2
 13159 021f 00       		.byte	0
 13160 0220 00       		.byte	0
 13161 0221 FF       		.byte	-1
 13162 0222 00       		.byte	0
 13163 0223 01       		.byte	1
 13164 0224 00       		.byte	0
 13165 0225 03       		.byte	3
 13166 0226 00       		.byte	0
 13167 0227 70       		.byte	112
 13168 0228 00       		.byte	0
 13169 0229 70       		.byte	112
 13170 022a 00       		.byte	0
 13171 022b 30       		.byte	48
 13172 022c 01       		.byte	1
 13173 022d 01       		.byte	1
 13174 022e 00       		.byte	0
 13175 022f 00000000 		.space	5
 13175      00
 13176 0234 00       		.byte	0
 13177 0235 00       		.byte	0
 13178 0236 02       		.byte	2
 13179 0237 00       		.byte	0
 13180 0238 00       		.byte	0
 13181 0239 64       		.byte	100
 13182 023a 00       		.byte	0
 13183 023b 01       		.byte	1
 13184 023c 00       		.byte	0
 13185 023d 03       		.byte	3
 13186 023e 00       		.byte	0
 13187 023f 00       		.byte	0
 13188 0240 00       		.byte	0
 13189 0241 00       		.byte	0
 13190 0242 00       		.byte	0
 13191 0243 30       		.byte	48
 13192 0244 01       		.byte	1
 13193 0245 00       		.byte	0
 13194 0246 00       		.byte	0
 13195 0247 00000000 		.space	5
 13195      00
 13196 024c 07       		.byte	7
 13197 024d 07       		.byte	7
 13198 024e 02       		.byte	2
 13199 024f 00       		.byte	0
 13200 0250 00       		.byte	0
 13201 0251 01       		.byte	1
 13202 0252 00       		.byte	0
 13203 0253 01       		.byte	1
 13204 0254 00       		.byte	0
 13205 0255 03       		.byte	3
 13206 0256 00       		.byte	0
 13207 0257 01       		.byte	1
 13208 0258 00       		.byte	0
 13209 0259 01       		.byte	1
 13210 025a 00       		.byte	0
 13211 025b 30       		.byte	48
 13212 025c 01       		.byte	1
 13213 025d 00       		.byte	0
 13214 025e 00       		.byte	0
 13215 025f 00000000 		.space	5
 13215      00
 13216 0264 DF       		.byte	-33
 13217 0265 E1       		.byte	-31
 13218 0266 02       		.byte	2
 13219 0267 00       		.byte	0
 13220 0268 00       		.byte	0
 13221 0269 FF       		.byte	-1
 13222 026a 00       		.byte	0
 13223 026b 01       		.byte	1
 13224 026c 00       		.byte	0
 13225 026d 03       		.byte	3
 13226 026e 00       		.byte	0
 13227 026f 80       		.byte	-128
 13228 0270 00       		.byte	0
 13229 0271 00       		.byte	0
 13230 0272 00       		.byte	0
 13231 0273 C6       		.byte	-58
 13232 0274 01       		.byte	1
 13233 0275 01       		.byte	1
 13234 0276 00       		.byte	0
 13235 0277 00000000 		.space	5
 13235      00
 13236 027c 85       		.byte	-123
 13237 027d 86       		.byte	-122
 13238 027e 02       		.byte	2
 13239 027f 00       		.byte	0
 13240 0280 00       		.byte	0
 13241 0281 64       		.byte	100
 13242 0282 00       		.byte	0
 13243 0283 01       		.byte	1
 13244 0284 00       		.byte	0
 13245 0285 03       		.byte	3
 13246 0286 00       		.byte	0
 13247 0287 32       		.byte	50
 13248 0288 00       		.byte	0
 13249 0289 32       		.byte	50
 13250 028a 00       		.byte	0
 13251 028b F2       		.byte	-14
 13252 028c 01       		.byte	1
 13253 028d 01       		.byte	1
 13254 028e 00       		.byte	0
 13255 028f 00000000 		.space	5
 13255      00
 13256 0294 06       		.byte	6
 13257 0295 07       		.byte	7
 13258 0296 02       		.byte	2
 13259 0297 00       		.byte	0
 13260 0298 00       		.byte	0
 13261 0299 FF       		.byte	-1
 13262 029a 00       		.byte	0
 13263 029b 01       		.byte	1
 13264 029c 00       		.byte	0
 13265 029d 03       		.byte	3
 13266 029e 00       		.byte	0
 13267 029f 20       		.byte	32
 13268 02a0 00       		.byte	0
 13269 02a1 20       		.byte	32
 13270 02a2 00       		.byte	0
 13271 02a3 30       		.byte	48
 13272 02a4 01       		.byte	1
 13273 02a5 01       		.byte	1
 13274 02a6 00       		.byte	0
 13275 02a7 00000000 		.space	5
 13275      00
 13276 02ac 00       		.byte	0
 13277 02ad 00       		.byte	0
 13278 02ae 02       		.byte	2
 13279 02af 00       		.byte	0
 13280 02b0 00       		.byte	0
 13281 02b1 64       		.byte	100
 13282 02b2 00       		.byte	0
 13283 02b3 01       		.byte	1
 13284 02b4 00       		.byte	0
 13285 02b5 03       		.byte	3
 13286 02b6 00       		.byte	0
 13287 02b7 00       		.byte	0
 13288 02b8 00       		.byte	0
 13289 02b9 00       		.byte	0
 13290 02ba 00       		.byte	0
 13291 02bb 30       		.byte	48
 13292 02bc 01       		.byte	1
 13293 02bd 00       		.byte	0
 13294 02be 00       		.byte	0
 13295 02bf 00000000 		.space	5
 13295      00
 13296 02c4 08       		.byte	8
 13297 02c5 08       		.byte	8
 13298 02c6 02       		.byte	2
 13299 02c7 00       		.byte	0
 13300 02c8 00       		.byte	0
 13301 02c9 05       		.byte	5
 13302 02ca 00       		.byte	0
 13303 02cb 01       		.byte	1
 13304 02cc 00       		.byte	0
 13305 02cd 03       		.byte	3
 13306 02ce 00       		.byte	0
 13307 02cf 00       		.byte	0
 13308 02d0 00       		.byte	0
 13309 02d1 00       		.byte	0
 13310 02d2 00       		.byte	0
 13311 02d3 30       		.byte	48
 13312 02d4 01       		.byte	1
 13313 02d5 00       		.byte	0
 13314 02d6 00       		.byte	0
 13315 02d7 00000000 		.space	5
 13315      00
 13316 02dc 00       		.byte	0
 13317 02dd 00       		.byte	0
 13318 02de 02       		.byte	2
 13319 02df 00       		.byte	0
 13320 02e0 00       		.byte	0
 13321 02e1 40       		.byte	64
 13322 02e2 00       		.byte	0
 13323 02e3 01       		.byte	1
 13324 02e4 00       		.byte	0
 13325 02e5 03       		.byte	3
 13326 02e6 00       		.byte	0
 13327 02e7 00       		.byte	0
 13328 02e8 00       		.byte	0
 13329 02e9 00       		.byte	0
 13330 02ea 00       		.byte	0
 13331 02eb 30       		.byte	48
 13332 02ec 01       		.byte	1
 13333 02ed 00       		.byte	0
 13334 02ee 00       		.byte	0
 13335 02ef 00000000 		.space	5
 13335      00
 13336 02f4 09       		.byte	9
 13337 02f5 0A       		.byte	10
 13338 02f6 04       		.byte	4
 13339 02f7 00       		.byte	0
 13340 02f8 00       		.byte	0
 13341 02f9 40       		.byte	64
 13342 02fa 00       		.byte	0
 13343 02fb 01       		.byte	1
 13344 02fc 00       		.byte	0
 13345 02fd 03       		.byte	3
 13346 02fe 00       		.byte	0
 13347 02ff 20       		.byte	32
 13348 0300 38       		.byte	56
 13349 0301 20       		.byte	32
 13350 0302 38       		.byte	56
 13351 0303 30       		.byte	48
 13352 0304 01       		.byte	1
 13353 0305 00       		.byte	0
 13354 0306 00       		.byte	0
 13355 0307 00000000 		.space	5
 13355      00
 13356 030c 00       		.byte	0
 13357 030d 00       		.byte	0
 13358 030e 02       		.byte	2
 13359 030f 00       		.byte	0
 13360 0310 00       		.byte	0
 13361 0311 64       		.byte	100
 13362 0312 00       		.byte	0
 13363 0313 01       		.byte	1
 13364 0314 00       		.byte	0
 13365 0315 03       		.byte	3
 13366 0316 00       		.byte	0
 13367 0317 00       		.byte	0
 13368 0318 00       		.byte	0
 13369 0319 00       		.byte	0
 13370 031a 00       		.byte	0
 13371 031b 30       		.byte	48
 13372 031c 01       		.byte	1
 13373 031d 00       		.byte	0
 13374 031e 00       		.byte	0
 13375 031f 00000000 		.space	5
 13375      00
 13376 0324 00       		.byte	0
 13377 0325 00       		.byte	0
 13378 0326 02       		.byte	2
 13379 0327 00       		.byte	0
 13380 0328 00       		.byte	0
 13381 0329 64       		.byte	100
 13382 032a 00       		.byte	0
 13383 032b 01       		.byte	1
 13384 032c 00       		.byte	0
 13385 032d 03       		.byte	3
 13386 032e 00       		.byte	0
 13387 032f 00       		.byte	0
 13388 0330 00       		.byte	0
 13389 0331 00       		.byte	0
 13390 0332 00       		.byte	0
 13391 0333 30       		.byte	48
 13392 0334 01       		.byte	1
 13393 0335 00       		.byte	0
 13394 0336 00       		.byte	0
 13395 0337 00000000 		.space	5
 13395      00
 13396 033c 2A       		.byte	42
 13397 033d 2A       		.byte	42
 13398 033e 02       		.byte	2
 13399 033f 00       		.byte	0
 13400 0340 00       		.byte	0
 13401 0341 1B       		.byte	27
 13402 0342 00       		.byte	0
 13403 0343 01       		.byte	1
 13404 0344 00       		.byte	0
 13405 0345 03       		.byte	3
 13406 0346 00       		.byte	0
 13407 0347 00       		.byte	0
 13408 0348 00       		.byte	0
 13409 0349 00       		.byte	0
 13410 034a 00       		.byte	0
 13411 034b 30       		.byte	48
 13412 034c 01       		.byte	1
 13413 034d 00       		.byte	0
 13414 034e 00       		.byte	0
 13415 034f 00000000 		.space	5
 13415      00
 13416 0354 00       		.byte	0
 13417 0355 00       		.byte	0
 13418 0356 02       		.byte	2
 13419 0357 00       		.byte	0
 13420 0358 00       		.byte	0
 13421 0359 64       		.byte	100
 13422 035a 00       		.byte	0
 13423 035b 01       		.byte	1
 13424 035c 00       		.byte	0
 13425 035d 03       		.byte	3
 13426 035e 00       		.byte	0
 13427 035f 00       		.byte	0
 13428 0360 00       		.byte	0
 13429 0361 00       		.byte	0
 13430 0362 00       		.byte	0
 13431 0363 30       		.byte	48
 13432 0364 01       		.byte	1
 13433 0365 00       		.byte	0
 13434 0366 00       		.byte	0
 13435 0367 00000000 		.space	5
 13435      00
 13436 036c 00       		.byte	0
 13437 036d 00       		.byte	0
 13438 036e 02       		.byte	2
 13439 036f 00       		.byte	0
 13440 0370 00       		.byte	0
 13441 0371 12       		.byte	18
 13442 0372 00       		.byte	0
 13443 0373 01       		.byte	1
 13444 0374 00       		.byte	0
 13445 0375 03       		.byte	3
 13446 0376 00       		.byte	0
 13447 0377 00       		.byte	0
 13448 0378 00       		.byte	0
 13449 0379 00       		.byte	0
 13450 037a 00       		.byte	0
 13451 037b 30       		.byte	48
 13452 037c 01       		.byte	1
 13453 037d 00       		.byte	0
 13454 037e 00       		.byte	0
 13455 037f 00000000 		.space	5
 13455      00
 13456 0384 01       		.byte	1
 13457 0385 01       		.byte	1
 13458 0386 02       		.byte	2
 13459 0387 00       		.byte	0
 13460 0388 00       		.byte	0
 13461 0389 09       		.byte	9
 13462 038a 00       		.byte	0
 13463 038b 01       		.byte	1
 13464 038c 00       		.byte	0
 13465 038d 03       		.byte	3
 13466 038e 00       		.byte	0
 13467 038f 00       		.byte	0
 13468 0390 00       		.byte	0
 13469 0391 01       		.byte	1
 13470 0392 00       		.byte	0
 13471 0393 30       		.byte	48
 13472 0394 01       		.byte	1
 13473 0395 00       		.byte	0
 13474 0396 00       		.byte	0
 13475 0397 00000000 		.space	5
 13475      00
 13476 039c 05       		.byte	5
 13477 039d 05       		.byte	5
 13478 039e 02       		.byte	2
 13479 039f 00       		.byte	0
 13480 03a0 00       		.byte	0
 13481 03a1 03       		.byte	3
 13482 03a2 00       		.byte	0
 13483 03a3 01       		.byte	1
 13484 03a4 00       		.byte	0
 13485 03a5 03       		.byte	3
 13486 03a6 00       		.byte	0
 13487 03a7 00       		.byte	0
 13488 03a8 00       		.byte	0
 13489 03a9 00       		.byte	0
 13490 03aa 00       		.byte	0
 13491 03ab 30       		.byte	48
 13492 03ac 01       		.byte	1
 13493 03ad 00       		.byte	0
 13494 03ae 00       		.byte	0
 13495 03af 00000000 		.space	5
 13495      00
 13496 03b4 18       		.byte	24
 13497 03b5 18       		.byte	24
 13498 03b6 02       		.byte	2
 13499 03b7 00       		.byte	0
 13500 03b8 00       		.byte	0
 13501 03b9 01       		.byte	1
 13502 03ba 00       		.byte	0
 13503 03bb 01       		.byte	1
 13504 03bc 00       		.byte	0
 13505 03bd 03       		.byte	3
 13506 03be 00       		.byte	0
 13507 03bf 00       		.byte	0
 13508 03c0 00       		.byte	0
 13509 03c1 00       		.byte	0
 13510 03c2 00       		.byte	0
 13511 03c3 30       		.byte	48
 13512 03c4 01       		.byte	1
 13513 03c5 00       		.byte	0
 13514 03c6 00       		.byte	0
 13515 03c7 00000000 		.space	5
 13515      00
 13516 03cc 19       		.byte	25
 13517 03cd 19       		.byte	25
 13518 03ce 01       		.byte	1
 13519 03cf 00       		.byte	0
 13520 03d0 00       		.byte	0
 13521 03d1 40       		.byte	64
 13522 03d2 00       		.byte	0
 13523 03d3 01       		.byte	1
 13524 03d4 00       		.byte	0
 13525 03d5 03       		.byte	3
 13526 03d6 00       		.byte	0
 13527 03d7 20       		.byte	32
 13528 03d8 00       		.byte	0
 13529 03d9 20       		.byte	32
 13530 03da 00       		.byte	0
 13531 03db 30       		.byte	48
 13532 03dc 01       		.byte	1
 13533 03dd 00       		.byte	0
 13534 03de 00       		.byte	0
 13535 03df 00000000 		.space	5
 13535      00
 13536 03e4 20       		.byte	32
 13537 03e5 20       		.byte	32
 13538 03e6 02       		.byte	2
 13539 03e7 00       		.byte	0
 13540 03e8 00       		.byte	0
 13541 03e9 02       		.byte	2
 13542 03ea 00       		.byte	0
 13543 03eb 01       		.byte	1
 13544 03ec 00       		.byte	0
 13545 03ed 03       		.byte	3
 13546 03ee 00       		.byte	0
 13547 03ef 00       		.byte	0
 13548 03f0 00       		.byte	0
 13549 03f1 00       		.byte	0
 13550 03f2 00       		.byte	0
 13551 03f3 30       		.byte	48
 13552 03f4 01       		.byte	1
 13553 03f5 00       		.byte	0
 13554 03f6 00       		.byte	0
 13555 03f7 00000000 		.space	5
 13555      00
 13556 03fc 22       		.byte	34
 13557 03fd 22       		.byte	34
 13558 03fe 02       		.byte	2
 13559 03ff 00       		.byte	0
 13560 0400 00       		.byte	0
 13561 0401 3F       		.byte	63
 13562 0402 00       		.byte	0
 13563 0403 01       		.byte	1
 13564 0404 00       		.byte	0
 13565 0405 03       		.byte	3
 13566 0406 00       		.byte	0
 13567 0407 00       		.byte	0
 13568 0408 00       		.byte	0
 13569 0409 00       		.byte	0
 13570 040a 00       		.byte	0
 13571 040b 30       		.byte	48
 13572 040c 01       		.byte	1
 13573 040d 00       		.byte	0
 13574 040e 00       		.byte	0
 13575 040f 00000000 		.space	5
 13575      00
 13576 0414 23       		.byte	35
 13577 0415 23       		.byte	35
 13578 0416 02       		.byte	2
 13579 0417 00       		.byte	0
 13580 0418 00       		.byte	0
 13581 0419 64       		.byte	100
 13582 041a 00       		.byte	0
 13583 041b 01       		.byte	1
 13584 041c 00       		.byte	0
 13585 041d 03       		.byte	3
 13586 041e 00       		.byte	0
 13587 041f 10       		.byte	16
 13588 0420 00       		.byte	0
 13589 0421 10       		.byte	16
 13590 0422 00       		.byte	0
 13591 0423 30       		.byte	48
 13592 0424 01       		.byte	1
 13593 0425 00       		.byte	0
 13594 0426 00       		.byte	0
 13595 0427 00000000 		.space	5
 13595      00
 13596 042c 24       		.byte	36
 13597 042d 24       		.byte	36
 13598 042e 02       		.byte	2
 13599 042f 00       		.byte	0
 13600 0430 00       		.byte	0
 13601 0431 64       		.byte	100
 13602 0432 00       		.byte	0
 13603 0433 01       		.byte	1
 13604 0434 00       		.byte	0
 13605 0435 03       		.byte	3
 13606 0436 00       		.byte	0
 13607 0437 10       		.byte	16
 13608 0438 00       		.byte	0
 13609 0439 10       		.byte	16
 13610 043a 00       		.byte	0
 13611 043b 30       		.byte	48
 13612 043c 01       		.byte	1
 13613 043d 00       		.byte	0
 13614 043e 00       		.byte	0
 13615 043f 00000000 		.space	5
 13615      00
 13616 0444 00       		.byte	0
 13617 0445 03       		.byte	3
 13618 0446 04       		.byte	4
 13619 0447 00       		.byte	0
 13620 0448 00       		.byte	0
 13621 0449 7F       		.byte	127
 13622 044a 00       		.byte	0
 13623 044b 01       		.byte	1
 13624 044c 00       		.byte	0
 13625 044d 03       		.byte	3
 13626 044e 00       		.byte	0
 13627 044f 00       		.byte	0
 13628 0450 20       		.byte	32
 13629 0451 00       		.byte	0
 13630 0452 20       		.byte	32
 13631 0453 30       		.byte	48
 13632 0454 01       		.byte	1
 13633 0455 00       		.byte	0
 13634 0456 00       		.byte	0
 13635 0457 00000000 		.space	5
 13635      00
 13636 045c 04       		.byte	4
 13637 045d 04       		.byte	4
 13638 045e 02       		.byte	2
 13639 045f 00       		.byte	0
 13640 0460 00       		.byte	0
 13641 0461 FF       		.byte	-1
 13642 0462 00       		.byte	0
 13643 0463 01       		.byte	1
 13644 0464 00       		.byte	0
 13645 0465 03       		.byte	3
 13646 0466 00       		.byte	0
 13647 0467 60       		.byte	96
 13648 0468 00       		.byte	0
 13649 0469 60       		.byte	96
 13650 046a 00       		.byte	0
 13651 046b 30       		.byte	48
 13652 046c 01       		.byte	1
 13653 046d 00       		.byte	0
 13654 046e 00       		.byte	0
 13655 046f 00000000 		.space	5
 13655      00
 13656 0474 00       		.byte	0
 13657 0475 00       		.byte	0
 13658 0476 02       		.byte	2
 13659 0477 00       		.byte	0
 13660 0478 00       		.byte	0
 13661 0479 19       		.byte	25
 13662 047a 00       		.byte	0
 13663 047b 01       		.byte	1
 13664 047c 00       		.byte	0
 13665 047d 03       		.byte	3
 13666 047e 00       		.byte	0
 13667 047f 00       		.byte	0
 13668 0480 00       		.byte	0
 13669 0481 00       		.byte	0
 13670 0482 00       		.byte	0
 13671 0483 30       		.byte	48
 13672 0484 01       		.byte	1
 13673 0485 00       		.byte	0
 13674 0486 00       		.byte	0
 13675 0487 00000000 		.space	5
 13675      00
 13676 048c 10       		.byte	16
 13677 048d 10       		.byte	16
 13678 048e 02       		.byte	2
 13679 048f 00       		.byte	0
 13680 0490 00       		.byte	0
 13681 0491 06       		.byte	6
 13682 0492 00       		.byte	0
 13683 0493 01       		.byte	1
 13684 0494 00       		.byte	0
 13685 0495 03       		.byte	3
 13686 0496 00       		.byte	0
 13687 0497 03       		.byte	3
 13688 0498 00       		.byte	0
 13689 0499 03       		.byte	3
 13690 049a 00       		.byte	0
 13691 049b 30       		.byte	48
 13692 049c 01       		.byte	1
 13693 049d 00       		.byte	0
 13694 049e 00       		.byte	0
 13695 049f 00000000 		.space	5
 13695      00
 13696 04a4 00       		.byte	0
 13697 04a5 00       		.byte	0
 13698 04a6 02       		.byte	2
 13699 04a7 00       		.byte	0
 13700 04a8 00       		.byte	0
 13701 04a9 03       		.byte	3
 13702 04aa 00       		.byte	0
 13703 04ab 01       		.byte	1
 13704 04ac 00       		.byte	0
 13705 04ad 03       		.byte	3
 13706 04ae 00       		.byte	0
 13707 04af 00       		.byte	0
 13708 04b0 00       		.byte	0
 13709 04b1 00       		.byte	0
 13710 04b2 00       		.byte	0
 13711 04b3 30       		.byte	48
 13712 04b4 01       		.byte	1
 13713 04b5 00       		.byte	0
 13714 04b6 00       		.byte	0
 13715 04b7 00000000 		.space	5
 13715      00
 13716 04bc 50       		.byte	80
 13717 04bd 50       		.byte	80
 13718 04be 01       		.byte	1
 13719 04bf 00       		.byte	0
 13720 04c0 00       		.byte	0
 13721 04c1 03       		.byte	3
 13722 04c2 00       		.byte	0
 13723 04c3 01       		.byte	1
 13724 04c4 00       		.byte	0
 13725 04c5 03       		.byte	3
 13726 04c6 00       		.byte	0
 13727 04c7 00       		.byte	0
 13728 04c8 00       		.byte	0
 13729 04c9 00       		.byte	0
 13730 04ca 00       		.byte	0
 13731 04cb 30       		.byte	48
 13732 04cc 01       		.byte	1
 13733 04cd 00       		.byte	0
 13734 04ce 00       		.byte	0
 13735 04cf 00000000 		.space	5
 13735      00
 13736 04d4 00       		.byte	0
 13737 04d5 00       		.byte	0
 13738 04d6 0B       		.byte	11
 13739 04d7 00       		.byte	0
 13740 04d8 00       		.byte	0
 13741 04d9 FF       		.byte	-1
 13742 04da FF       		.byte	-1
 13743 04db 01       		.byte	1
 13744 04dc 00       		.byte	0
 13745 04dd 03       		.byte	3
 13746 04de 00       		.byte	0
 13747 04df 00       		.byte	0
 13748 04e0 00       		.byte	0
 13749 04e1 00       		.byte	0
 13750 04e2 00       		.byte	0
 13751 04e3 00       		.byte	0
 13752 04e4 01       		.byte	1
 13753 04e5 00       		.byte	0
 13754 04e6 00       		.byte	0
 13755 04e7 00000000 		.space	5
 13755      00
 13758              	glUVCHeader:
 13759 04ec 0C       		.byte	12
 13760 04ed 8C       		.byte	-116
 13761 04ee 00       		.byte	0
 13762 04ef 00       		.byte	0
 13763 04f0 00       		.byte	0
 13764 04f1 00       		.byte	0
 13765 04f2 00       		.byte	0
 13766 04f3 00       		.byte	0
 13767 04f4 00       		.byte	0
 13768 04f5 00       		.byte	0
 13769 04f6 00       		.byte	0
 13770 04f7 00       		.byte	0
 13773              	EXTBLCGrid:
 13774 04f8 10       		.byte	16
 13775 04f9 10       		.byte	16
 13776 04fa 02       		.byte	2
 13777 04fb 01       		.byte	1
 13778 04fc 00       		.byte	0
 13779 04fd 02       		.byte	2
 13780 04fe 00       		.byte	0
 13781 04ff 01       		.byte	1
 13782 0500 00       		.byte	0
 13783 0501 03       		.byte	3
 13784 0502 00       		.byte	0
 13785 0503 00       		.byte	0
 13786 0504 00       		.byte	0
 13787 0505 00       		.byte	0
 13788 0506 00       		.byte	0
 13789 0507 30       		.byte	48
 13790 0508 01       		.byte	1
 13791 0509 00       		.byte	0
 13792 050a 0000     		.space	2
 13795              	EXTAexModGainlev:
 13796 050c 00       		.byte	0
 13797 050d 03       		.byte	3
 13798 050e 04       		.byte	4
 13799 050f 00       		.byte	0
 13800 0510 00       		.byte	0
 13801 0511 7F       		.byte	127
 13802 0512 00       		.byte	0
 13803 0513 01       		.byte	1
 13804 0514 00       		.byte	0
 13805 0515 03       		.byte	3
 13806 0516 00       		.byte	0
 13807 0517 00       		.byte	0
 13808 0518 3F       		.byte	63
 13809 0519 00       		.byte	0
 13810 051a 3F       		.byte	63
 13811 051b 30       		.byte	48
 13812 051c 01       		.byte	1
 13813 051d 00       		.byte	0
 13814 051e 0000     		.space	2
 13817              	EXTExCtrlSped:
 13818 0520 02       		.byte	2
 13819 0521 02       		.byte	2
 13820 0522 02       		.byte	2
 13821 0523 00       		.byte	0
 13822 0524 00       		.byte	0
 13823 0525 FF       		.byte	-1
 13824 0526 00       		.byte	0
 13825 0527 01       		.byte	1
 13826 0528 00       		.byte	0
 13827 0529 03       		.byte	3
 13828 052a 00       		.byte	0
 13829 052b 80       		.byte	-128
 13830 052c 00       		.byte	0
 13831 052d 80       		.byte	-128
 13832 052e 00       		.byte	0
 13833 052f 30       		.byte	48
 13834 0530 01       		.byte	1
 13835 0531 00       		.byte	0
 13836 0532 0000     		.space	2
 13839              	EXTBLCWinPos:
 13840 0534 14       		.byte	20
 13841 0535 13       		.byte	19
 13842 0536 02       		.byte	2
 13843 0537 00       		.byte	0
 13844 0538 00       		.byte	0
 13845 0539 FF       		.byte	-1
 13846 053a FF       		.byte	-1
 13847 053b 01       		.byte	1
 13848 053c 00       		.byte	0
 13849 053d 03       		.byte	3
 13850 053e 00       		.byte	0
 13851 053f 66       		.byte	102
 13852 0540 66       		.byte	102
 13853 0541 66       		.byte	102
 13854 0542 66       		.byte	102
 13855 0543 30       		.byte	48
 13856 0544 01       		.byte	1
 13857 0545 00       		.byte	0
 13858 0546 0000     		.space	2
 13861              	PUCBright:
 13862 0548 15       		.byte	21
 13863 0549 15       		.byte	21
 13864 054a 02       		.byte	2
 13865 054b 00       		.byte	0
 13866 054c 00       		.byte	0
 13867 054d FF       		.byte	-1
 13868 054e 00       		.byte	0
 13869 054f 01       		.byte	1
 13870 0550 00       		.byte	0
 13871 0551 03       		.byte	3
 13872 0552 00       		.byte	0
 13873 0553 76       		.byte	118
 13874 0554 00       		.byte	0
 13875 0555 76       		.byte	118
 13876 0556 77       		.byte	119
 13877 0557 30       		.byte	48
 13878 0558 01       		.byte	1
 13879 0559 00       		.byte	0
 13880 055a 0000     		.space	2
 13883              	PUCHueC:
 13884 055c DF       		.byte	-33
 13885 055d E1       		.byte	-31
 13886 055e 02       		.byte	2
 13887 055f 00       		.byte	0
 13888 0560 00       		.byte	0
 13889 0561 FF       		.byte	-1
 13890 0562 00       		.byte	0
 13891 0563 01       		.byte	1
 13892 0564 00       		.byte	0
 13893 0565 03       		.byte	3
 13894 0566 00       		.byte	0
 13895 0567 80       		.byte	-128
 13896 0568 00       		.byte	0
 13897 0569 00       		.byte	0
 13898 056a 00       		.byte	0
 13899 056b 30       		.byte	48
 13900 056c 01       		.byte	1
 13901 056d 00       		.byte	0
 13902 056e 0000     		.space	2
 13905              	PUCPLFreq:
 13906 0570 07       		.byte	7
 13907 0571 07       		.byte	7
 13908 0572 02       		.byte	2
 13909 0573 00       		.byte	0
 13910 0574 00       		.byte	0
 13911 0575 01       		.byte	1
 13912 0576 00       		.byte	0
 13913 0577 01       		.byte	1
 13914 0578 00       		.byte	0
 13915 0579 03       		.byte	3
 13916 057a 00       		.byte	0
 13917 057b 01       		.byte	1
 13918 057c 00       		.byte	0
 13919 057d 01       		.byte	1
 13920 057e 00       		.byte	0
 13921 057f 30       		.byte	48
 13922 0580 01       		.byte	1
 13923 0581 00       		.byte	0
 13924 0582 0000     		.space	2
 13927              	WBMenuCmpArry:
 13928 0584 20       		.byte	32
 13929 0585 0F       		.byte	15
 13930 0586 38       		.byte	56
 13931 0587 F0       		.byte	-16
 13934              	PUCSharp:
 13935 0588 06       		.byte	6
 13936 0589 07       		.byte	7
 13937 058a 02       		.byte	2
 13938 058b 00       		.byte	0
 13939 058c 00       		.byte	0
 13940 058d FF       		.byte	-1
 13941 058e 00       		.byte	0
 13942 058f 01       		.byte	1
 13943 0590 00       		.byte	0
 13944 0591 03       		.byte	3
 13945 0592 00       		.byte	0
 13946 0593 00       		.byte	0
 13947 0594 00       		.byte	0
 13948 0595 00       		.byte	0
 13949 0596 00       		.byte	0
 13950 0597 30       		.byte	48
 13951 0598 01       		.byte	1
 13952 0599 00       		.byte	0
 13953 059a 0000     		.space	2
 13956              	PUCBLC:
 13957 059c 10       		.byte	16
 13958 059d 11       		.byte	17
 13959 059e 02       		.byte	2
 13960 059f 00       		.byte	0
 13961 05a0 00       		.byte	0
 13962 05a1 03       		.byte	3
 13963 05a2 00       		.byte	0
 13964 05a3 01       		.byte	1
 13965 05a4 00       		.byte	0
 13966 05a5 03       		.byte	3
 13967 05a6 00       		.byte	0
 13968 05a7 03       		.byte	3
 13969 05a8 00       		.byte	0
 13970 05a9 03       		.byte	3
 13971 05aa 00       		.byte	0
 13972 05ab 30       		.byte	48
 13973 05ac 01       		.byte	1
 13974 05ad 00       		.byte	0
 13975 05ae 0000     		.space	2
 13978              	EXTShutter:
 13979 05b0 00       		.byte	0
 13980 05b1 02       		.byte	2
 13981 05b2 02       		.byte	2
 13982 05b3 00       		.byte	0
 13983 05b4 00       		.byte	0
 13984 05b5 08       		.byte	8
 13985 05b6 00       		.byte	0
 13986 05b7 01       		.byte	1
 13987 05b8 00       		.byte	0
 13988 05b9 03       		.byte	3
 13989 05ba 00       		.byte	0
 13990 05bb 00       		.byte	0
 13991 05bc 00       		.byte	0
 13992 05bd 00       		.byte	0
 13993 05be 00       		.byte	0
 13994 05bf 30       		.byte	48
 13995 05c0 01       		.byte	1
 13996 05c1 00       		.byte	0
 13997 05c2 0000     		.space	2
 14000              	EXTShutlev:
 14001 05c4 12       		.byte	18
 14002 05c5 12       		.byte	18
 14003 05c6 02       		.byte	2
 14004 05c7 00       		.byte	0
 14005 05c8 00       		.byte	0
 14006 05c9 FF       		.byte	-1
 14007 05ca 7F       		.byte	127
 14008 05cb 01       		.byte	1
 14009 05cc 00       		.byte	0
 14010 05cd 03       		.byte	3
 14011 05ce 00       		.byte	0
 14012 05cf 3F       		.byte	63
 14013 05d0 00       		.byte	0
 14014 05d1 3F       		.byte	63
 14015 05d2 00       		.byte	0
 14016 05d3 30       		.byte	48
 14017 05d4 01       		.byte	1
 14018 05d5 00       		.byte	0
 14019 05d6 0000     		.space	2
 14022              	CTCtrlParArry:
 14023 05d8 00       		.byte	0
 14024 05d9 00       		.byte	0
 14025 05da 01       		.byte	1
 14026 05db 00       		.byte	0
 14027 05dc 00       		.byte	0
 14028 05dd 03       		.byte	3
 14029 05de 00       		.byte	0
 14030 05df 01       		.byte	1
 14031 05e0 00       		.byte	0
 14032 05e1 03       		.byte	3
 14033 05e2 00       		.byte	0
 14034 05e3 03       		.byte	3
 14035 05e4 00       		.byte	0
 14036 05e5 03       		.byte	3
 14037 05e6 00       		.byte	0
 14038 05e7 30       		.byte	48
 14039 05e8 01       		.byte	1
 14040 05e9 00       		.byte	0
 14041 05ea 00       		.byte	0
 14042 05eb 00000000 		.space	5
 14042      00
 14043 05f0 00       		.byte	0
 14044 05f1 00       		.byte	0
 14045 05f2 01       		.byte	1
 14046 05f3 01       		.byte	1
 14047 05f4 00       		.byte	0
 14048 05f5 0F       		.byte	15
 14049 05f6 00       		.byte	0
 14050 05f7 0F       		.byte	15
 14051 05f8 00       		.byte	0
 14052 05f9 03       		.byte	3
 14053 05fa 00       		.byte	0
 14054 05fb 02       		.byte	2
 14055 05fc 00       		.byte	0
 14056 05fd 02       		.byte	2
 14057 05fe 00       		.byte	0
 14058 05ff 30       		.byte	48
 14059 0600 01       		.byte	1
 14060 0601 01       		.byte	1
 14061 0602 00       		.byte	0
 14062 0603 00000000 		.space	5
 14062      00
 14063 0608 02       		.byte	2
 14064 0609 00       		.byte	0
 14065 060a 01       		.byte	1
 14066 060b 00       		.byte	0
 14067 060c 00       		.byte	0
 14068 060d 01       		.byte	1
 14069 060e 00       		.byte	0
 14070 060f 01       		.byte	1
 14071 0610 00       		.byte	0
 14072 0611 03       		.byte	3
 14073 0612 00       		.byte	0
 14074 0613 00       		.byte	0
 14075 0614 00       		.byte	0
 14076 0615 00       		.byte	0
 14077 0616 00       		.byte	0
 14078 0617 30       		.byte	48
 14079 0618 01       		.byte	1
 14080 0619 01       		.byte	1
 14081 061a 00       		.byte	0
 14082 061b 00000000 		.space	5
 14082      00
 14083 0620 00       		.byte	0
 14084 0621 00       		.byte	0
 14085 0622 04       		.byte	4
 14086 0623 01       		.byte	1
 14087 0624 00       		.byte	0
 14088 0625 38       		.byte	56
 14089 0626 01       		.byte	1
 14090 0627 01       		.byte	1
 14091 0628 00       		.byte	0
 14092 0629 03       		.byte	3
 14093 062a 00       		.byte	0
 14094 062b 4E       		.byte	78
 14095 062c 00       		.byte	0
 14096 062d 4E       		.byte	78
 14097 062e 00       		.byte	0
 14098 062f 30       		.byte	48
 14099 0630 01       		.byte	1
 14100 0631 00       		.byte	0
 14101 0632 00       		.byte	0
 14102 0633 00000000 		.space	5
 14102      00
 14103 0638 04       		.byte	4
 14104 0639 00       		.byte	0
 14105 063a 01       		.byte	1
 14106 063b 00       		.byte	0
 14107 063c 00       		.byte	0
 14108 063d 00       		.byte	0
 14109 063e 00       		.byte	0
 14110 063f 01       		.byte	1
 14111 0640 00       		.byte	0
 14112 0641 03       		.byte	3
 14113 0642 00       		.byte	0
 14114 0643 00       		.byte	0
 14115 0644 00       		.byte	0
 14116 0645 00       		.byte	0
 14117 0646 00       		.byte	0
 14118 0647 30       		.byte	48
 14119 0648 01       		.byte	1
 14120 0649 00       		.byte	0
 14121 064a 00       		.byte	0
 14122 064b 00000000 		.space	5
 14122      00
 14123 0650 05       		.byte	5
 14124 0651 00       		.byte	0
 14125 0652 02       		.byte	2
 14126 0653 00       		.byte	0
 14127 0654 00       		.byte	0
 14128 0655 FF       		.byte	-1
 14129 0656 00       		.byte	0
 14130 0657 01       		.byte	1
 14131 0658 00       		.byte	0
 14132 0659 03       		.byte	3
 14133 065a 00       		.byte	0
 14134 065b 01       		.byte	1
 14135 065c 00       		.byte	0
 14136 065d 00       		.byte	0
 14137 065e 00       		.byte	0
 14138 065f 30       		.byte	48
 14139 0660 01       		.byte	1
 14140 0661 01       		.byte	1
 14141 0662 00       		.byte	0
 14142 0663 00000000 		.space	5
 14142      00
 14143 0668 06       		.byte	6
 14144 0669 00       		.byte	0
 14145 066a 02       		.byte	2
 14146 066b 00       		.byte	0
 14147 066c 00       		.byte	0
 14148 066d 00       		.byte	0
 14149 066e 00       		.byte	0
 14150 066f 00       		.byte	0
 14151 0670 00       		.byte	0
 14152 0671 03       		.byte	3
 14153 0672 00       		.byte	0
 14154 0673 00       		.byte	0
 14155 0674 00       		.byte	0
 14156 0675 00       		.byte	0
 14157 0676 00       		.byte	0
 14158 0677 30       		.byte	48
 14159 0678 01       		.byte	1
 14160 0679 01       		.byte	1
 14161 067a 00       		.byte	0
 14162 067b 00000000 		.space	5
 14162      00
 14163 0680 23       		.byte	35
 14164 0681 00       		.byte	0
 14165 0682 02       		.byte	2
 14166 0683 00       		.byte	0
 14167 0684 00       		.byte	0
 14168 0685 30       		.byte	48
 14169 0686 00       		.byte	0
 14170 0687 01       		.byte	1
 14171 0688 00       		.byte	0
 14172 0689 03       		.byte	3
 14173 068a 0A       		.byte	10
 14174 068b 00       		.byte	0
 14175 068c 00       		.byte	0
 14176 068d 0A       		.byte	10
 14177 068e 00       		.byte	0
 14178 068f 30       		.byte	48
 14179 0690 01       		.byte	1
 14180 0691 01       		.byte	1
 14181 0692 00       		.byte	0
 14182 0693 00000000 		.space	5
 14182      00
 14183 0698 08       		.byte	8
 14184 0699 00       		.byte	0
 14185 069a 01       		.byte	1
 14186 069b 00       		.byte	0
 14187 069c 00       		.byte	0
 14188 069d 7F       		.byte	127
 14189 069e 00       		.byte	0
 14190 069f 01       		.byte	1
 14191 06a0 00       		.byte	0
 14192 06a1 03       		.byte	3
 14193 06a2 00       		.byte	0
 14194 06a3 00       		.byte	0
 14195 06a4 00       		.byte	0
 14196 06a5 00       		.byte	0
 14197 06a6 00       		.byte	0
 14198 06a7 30       		.byte	48
 14199 06a8 01       		.byte	1
 14200 06a9 00       		.byte	0
 14201 06aa 00       		.byte	0
 14202 06ab 00000000 		.space	5
 14202      00
 14203 06b0 09       		.byte	9
 14204 06b1 00       		.byte	0
 14205 06b2 02       		.byte	2
 14206 06b3 00       		.byte	0
 14207 06b4 00       		.byte	0
 14208 06b5 05       		.byte	5
 14209 06b6 00       		.byte	0
 14210 06b7 01       		.byte	1
 14211 06b8 00       		.byte	0
 14212 06b9 03       		.byte	3
 14213 06ba 00       		.byte	0
 14214 06bb 00       		.byte	0
 14215 06bc 00       		.byte	0
 14216 06bd 00       		.byte	0
 14217 06be 00       		.byte	0
 14218 06bf 30       		.byte	48
 14219 06c0 01       		.byte	1
 14220 06c1 00       		.byte	0
 14221 06c2 00       		.byte	0
 14222 06c3 00000000 		.space	5
 14222      00
 14223 06c8 10       		.byte	16
 14224 06c9 00       		.byte	0
 14225 06ca 03       		.byte	3
 14226 06cb 00       		.byte	0
 14227 06cc 00       		.byte	0
 14228 06cd 00       		.byte	0
 14229 06ce 00       		.byte	0
 14230 06cf 00       		.byte	0
 14231 06d0 00       		.byte	0
 14232 06d1 03       		.byte	3
 14233 06d2 00       		.byte	0
 14234 06d3 00       		.byte	0
 14235 06d4 00       		.byte	0
 14236 06d5 00       		.byte	0
 14237 06d6 00       		.byte	0
 14238 06d7 30       		.byte	48
 14239 06d8 01       		.byte	1
 14240 06d9 00       		.byte	0
 14241 06da 00       		.byte	0
 14242 06db 00000000 		.space	5
 14242      00
 14243 06e0 00       		.byte	0
 14244 06e1 00       		.byte	0
 14245 06e2 02       		.byte	2
 14246 06e3 00       		.byte	0
 14247 06e4 00       		.byte	0
 14248 06e5 40       		.byte	64
 14249 06e6 00       		.byte	0
 14250 06e7 01       		.byte	1
 14251 06e8 00       		.byte	0
 14252 06e9 03       		.byte	3
 14253 06ea 00       		.byte	0
 14254 06eb 0F       		.byte	15
 14255 06ec 11       		.byte	17
 14256 06ed 00       		.byte	0
 14257 06ee 00       		.byte	0
 14258 06ef 30       		.byte	48
 14259 06f0 01       		.byte	1
 14260 06f1 00       		.byte	0
 14261 06f2 00       		.byte	0
 14262 06f3 00000000 		.space	5
 14262      00
 14263 06f8 00       		.byte	0
 14264 06f9 00       		.byte	0
 14265 06fa 02       		.byte	2
 14266 06fb 00       		.byte	0
 14267 06fc 00       		.byte	0
 14268 06fd 64       		.byte	100
 14269 06fe 00       		.byte	0
 14270 06ff 01       		.byte	1
 14271 0700 00       		.byte	0
 14272 0701 03       		.byte	3
 14273 0702 00       		.byte	0
 14274 0703 00       		.byte	0
 14275 0704 00       		.byte	0
 14276 0705 00       		.byte	0
 14277 0706 00       		.byte	0
 14278 0707 30       		.byte	48
 14279 0708 01       		.byte	1
 14280 0709 00       		.byte	0
 14281 070a 00       		.byte	0
 14282 070b 00000000 		.space	5
 14282      00
 14283 0710 00       		.byte	0
 14284 0711 00       		.byte	0
 14285 0712 02       		.byte	2
 14286 0713 00       		.byte	0
 14287 0714 00       		.byte	0
 14288 0715 64       		.byte	100
 14289 0716 00       		.byte	0
 14290 0717 01       		.byte	1
 14291 0718 00       		.byte	0
 14292 0719 03       		.byte	3
 14293 071a 00       		.byte	0
 14294 071b 00       		.byte	0
 14295 071c 00       		.byte	0
 14296 071d 00       		.byte	0
 14297 071e 00       		.byte	0
 14298 071f 30       		.byte	48
 14299 0720 01       		.byte	1
 14300 0721 00       		.byte	0
 14301 0722 00       		.byte	0
 14302 0723 00000000 		.space	5
 14302      00
 14303 0728 00       		.byte	0
 14304 0729 00       		.byte	0
 14305 072a 02       		.byte	2
 14306 072b 00       		.byte	0
 14307 072c 00       		.byte	0
 14308 072d 64       		.byte	100
 14309 072e 00       		.byte	0
 14310 072f 01       		.byte	1
 14311 0730 00       		.byte	0
 14312 0731 03       		.byte	3
 14313 0732 00       		.byte	0
 14314 0733 00       		.byte	0
 14315 0734 00       		.byte	0
 14316 0735 00       		.byte	0
 14317 0736 00       		.byte	0
 14318 0737 30       		.byte	48
 14319 0738 01       		.byte	1
 14320 0739 00       		.byte	0
 14321 073a 00       		.byte	0
 14322 073b 00000000 		.space	5
 14322      00
 14323 0740 00       		.byte	0
 14324 0741 00       		.byte	0
 14325 0742 02       		.byte	2
 14326 0743 00       		.byte	0
 14327 0744 00       		.byte	0
 14328 0745 64       		.byte	100
 14329 0746 00       		.byte	0
 14330 0747 01       		.byte	1
 14331 0748 00       		.byte	0
 14332 0749 03       		.byte	3
 14333 074a 00       		.byte	0
 14334 074b 00       		.byte	0
 14335 074c 00       		.byte	0
 14336 074d 00       		.byte	0
 14337 074e 00       		.byte	0
 14338 074f 30       		.byte	48
 14339 0750 01       		.byte	1
 14340 0751 00       		.byte	0
 14341 0752 00       		.byte	0
 14342 0753 00000000 		.space	5
 14342      00
 14345              	EXTDayNightdely:
 14346 0758 22       		.byte	34
 14347 0759 22       		.byte	34
 14348 075a 02       		.byte	2
 14349 075b 00       		.byte	0
 14350 075c 00       		.byte	0
 14351 075d 3F       		.byte	63
 14352 075e 00       		.byte	0
 14353 075f 01       		.byte	1
 14354 0760 00       		.byte	0
 14355 0761 03       		.byte	3
 14356 0762 00       		.byte	0
 14357 0763 00       		.byte	0
 14358 0764 00       		.byte	0
 14359 0765 00       		.byte	0
 14360 0766 00       		.byte	0
 14361 0767 30       		.byte	48
 14362 0768 01       		.byte	1
 14363 0769 00       		.byte	0
 14364 076a 0000     		.space	2
 14367              	EXTEnhanceGain:
 14368 076c 07       		.byte	7
 14369 076d 07       		.byte	7
 14370 076e 02       		.byte	2
 14371 076f 00       		.byte	0
 14372 0770 00       		.byte	0
 14373 0771 FF       		.byte	-1
 14374 0772 00       		.byte	0
 14375 0773 01       		.byte	1
 14376 0774 00       		.byte	0
 14377 0775 03       		.byte	3
 14378 0776 00       		.byte	0
 14379 0777 80       		.byte	-128
 14380 0778 00       		.byte	0
 14381 0779 80       		.byte	-128
 14382 077a 00       		.byte	0
 14383 077b 30       		.byte	48
 14384 077c 01       		.byte	1
 14385 077d 00       		.byte	0
 14386 077e 0000     		.space	2
 14389              	EXTEnhanceSTED:
 14390 0780 08       		.byte	8
 14391 0781 09       		.byte	9
 14392 0782 04       		.byte	4
 14393 0783 00       		.byte	0
 14394 0784 00       		.byte	0
 14395 0785 FF       		.byte	-1
 14396 0786 00       		.byte	0
 14397 0787 01       		.byte	1
 14398 0788 00       		.byte	0
 14399 0789 03       		.byte	3
 14400 078a 00       		.byte	0
 14401 078b 80       		.byte	-128
 14402 078c 00       		.byte	0
 14403 078d 80       		.byte	-128
 14404 078e 00       		.byte	0
 14405 078f 30       		.byte	48
 14406 0790 01       		.byte	1
 14407 0791 00       		.byte	0
 14410              	snapButFlag:
 14411 0792 01       		.byte	1
 14412 0793 00       		.space	1
 14415              	EXTAGCMaxLimit:
 14416 0794 0C       		.byte	12
 14417 0795 0C       		.byte	12
 14418 0796 02       		.byte	2
 14419 0797 00       		.byte	0
 14420 0798 00       		.byte	0
 14421 0799 10       		.byte	16
 14422 079a 00       		.byte	0
 14423 079b 01       		.byte	1
 14424 079c 00       		.byte	0
 14425 079d 03       		.byte	3
 14426 079e 00       		.byte	0
 14427 079f 00       		.byte	0
 14428 07a0 00       		.byte	0
 14429 07a1 00       		.byte	0
 14430 07a2 00       		.byte	0
 14431 07a3 30       		.byte	48
 14432 07a4 01       		.byte	1
 14433 07a5 00       		.byte	0
 14434 07a6 0000     		.space	2
 14437              	EXTGammaCor:
 14438 07a8 17       		.byte	23
 14439 07a9 17       		.byte	23
 14440 07aa 02       		.byte	2
 14441 07ab 00       		.byte	0
 14442 07ac 00       		.byte	0
 14443 07ad 10       		.byte	16
 14444 07ae 00       		.byte	0
 14445 07af 01       		.byte	1
 14446 07b0 00       		.byte	0
 14447 07b1 03       		.byte	3
 14448 07b2 00       		.byte	0
 14449 07b3 00       		.byte	0
 14450 07b4 00       		.byte	0
 14451 07b5 00       		.byte	0
 14452 07b6 00       		.byte	0
 14453 07b7 30       		.byte	48
 14454 07b8 01       		.byte	1
 14455 07b9 00       		.byte	0
 14456 07ba 0000     		.space	2
 14459              	EXT2DNRSTED:
 14460 07bc 1A       		.byte	26
 14461 07bd 1B       		.byte	27
 14462 07be 04       		.byte	4
 14463 07bf 00       		.byte	0
 14464 07c0 00       		.byte	0
 14465 07c1 FF       		.byte	-1
 14466 07c2 00       		.byte	0
 14467 07c3 01       		.byte	1
 14468 07c4 00       		.byte	0
 14469 07c5 03       		.byte	3
 14470 07c6 00       		.byte	0
 14471 07c7 80       		.byte	-128
 14472 07c8 00       		.byte	0
 14473 07c9 80       		.byte	-128
 14474 07ca 00       		.byte	0
 14475 07cb 30       		.byte	48
 14476 07cc 01       		.byte	1
 14477 07cd 00       		.byte	0
 14478 07ce 0000     		.space	2
 14481              	EXT2DNRGain:
 14482 07d0 18       		.byte	24
 14483 07d1 19       		.byte	25
 14484 07d2 02       		.byte	2
 14485 07d3 00       		.byte	0
 14486 07d4 00       		.byte	0
 14487 07d5 FF       		.byte	-1
 14488 07d6 00       		.byte	0
 14489 07d7 01       		.byte	1
 14490 07d8 00       		.byte	0
 14491 07d9 03       		.byte	3
 14492 07da 00       		.byte	0
 14493 07db 80       		.byte	-128
 14494 07dc 00       		.byte	0
 14495 07dd 80       		.byte	-128
 14496 07de 00       		.byte	0
 14497 07df 30       		.byte	48
 14498 07e0 01       		.byte	1
 14499 07e1 00       		.byte	0
 14500 07e2 0000     		.space	2
 14503              	EXTEnhanceMode:
 14504 07e4 06       		.byte	6
 14505 07e5 06       		.byte	6
 14506 07e6 02       		.byte	2
 14507 07e7 00       		.byte	0
 14508 07e8 00       		.byte	0
 14509 07e9 FF       		.byte	-1
 14510 07ea 00       		.byte	0
 14511 07eb 01       		.byte	1
 14512 07ec 00       		.byte	0
 14513 07ed 03       		.byte	3
 14514 07ee 00       		.byte	0
 14515 07ef 80       		.byte	-128
 14516 07f0 00       		.byte	0
 14517 07f1 80       		.byte	-128
 14518 07f2 00       		.byte	0
 14519 07f3 30       		.byte	48
 14520 07f4 01       		.byte	1
 14521 07f5 00       		.byte	0
 14522 07f6 0000     		.space	2
 14525              	EXTExHyster:
 14526 07f8 0B       		.byte	11
 14527 07f9 0B       		.byte	11
 14528 07fa 02       		.byte	2
 14529 07fb 00       		.byte	0
 14530 07fc 00       		.byte	0
 14531 07fd FF       		.byte	-1
 14532 07fe 00       		.byte	0
 14533 07ff 01       		.byte	1
 14534 0800 00       		.byte	0
 14535 0801 03       		.byte	3
 14536 0802 00       		.byte	0
 14537 0803 80       		.byte	-128
 14538 0804 00       		.byte	0
 14539 0805 80       		.byte	-128
 14540 0806 00       		.byte	0
 14541 0807 30       		.byte	48
 14542 0808 01       		.byte	1
 14543 0809 00       		.byte	0
 14544 080a 0000     		.space	2
 14547              	EXTBLCWeight:
 14548 080c 11       		.byte	17
 14549 080d 11       		.byte	17
 14550 080e 02       		.byte	2
 14551 080f 00       		.byte	0
 14552 0810 00       		.byte	0
 14553 0811 FF       		.byte	-1
 14554 0812 00       		.byte	0
 14555 0813 01       		.byte	1
 14556 0814 00       		.byte	0
 14557 0815 03       		.byte	3
 14558 0816 00       		.byte	0
 14559 0817 80       		.byte	-128
 14560 0818 00       		.byte	0
 14561 0819 80       		.byte	-128
 14562 081a 00       		.byte	0
 14563 081b 30       		.byte	48
 14564 081c 01       		.byte	1
 14565 081d 00       		.byte	0
 14566 081e 0000     		.space	2
 14569              	EXTI2Ccmd:
 14570 0820 00       		.byte	0
 14571 0821 00       		.byte	0
 14572 0822 0B       		.byte	11
 14573 0823 00       		.byte	0
 14574 0824 00       		.byte	0
 14575 0825 FF       		.byte	-1
 14576 0826 FF       		.byte	-1
 14577 0827 01       		.byte	1
 14578 0828 00       		.byte	0
 14579 0829 03       		.byte	3
 14580 082a 00       		.byte	0
 14581 082b 00       		.byte	0
 14582 082c 00       		.byte	0
 14583 082d 00       		.byte	0
 14584 082e 00       		.byte	0
 14585 082f 00       		.byte	0
 14586 0830 01       		.byte	1
 14587 0831 00       		.byte	0
 14588 0832 0000     		.space	2
 14591              	EXTSensorPare:
 14592 0834 50       		.byte	80
 14593 0835 50       		.byte	80
 14594 0836 02       		.byte	2
 14595 0837 00       		.byte	0
 14596 0838 00       		.byte	0
 14597 0839 03       		.byte	3
 14598 083a 00       		.byte	0
 14599 083b 01       		.byte	1
 14600 083c 00       		.byte	0
 14601 083d 03       		.byte	3
 14602 083e 00       		.byte	0
 14603 083f 00       		.byte	0
 14604 0840 00       		.byte	0
 14605 0841 00       		.byte	0
 14606 0842 00       		.byte	0
 14607 0843 30       		.byte	48
 14608 0844 01       		.byte	1
 14609 0845 00       		.byte	0
 14610 0846 0000     		.space	2
 14613              	EXTCamMode:
 14614 0848 10       		.byte	16
 14615 0849 10       		.byte	16
 14616 084a 02       		.byte	2
 14617 084b 00       		.byte	0
 14618 084c 00       		.byte	0
 14619 084d 06       		.byte	6
 14620 084e 00       		.byte	0
 14621 084f 01       		.byte	1
 14622 0850 00       		.byte	0
 14623 0851 03       		.byte	3
 14624 0852 00       		.byte	0
 14625 0853 03       		.byte	3
 14626 0854 00       		.byte	0
 14627 0855 03       		.byte	3
 14628 0856 00       		.byte	0
 14629 0857 30       		.byte	48
 14630 0858 01       		.byte	1
 14631 0859 00       		.byte	0
 14632 085a 0000     		.space	2
 14635              	EXTExpReflev:
 14636 085c 04       		.byte	4
 14637 085d 04       		.byte	4
 14638 085e 02       		.byte	2
 14639 085f 00       		.byte	0
 14640 0860 00       		.byte	0
 14641 0861 FF       		.byte	-1
 14642 0862 00       		.byte	0
 14643 0863 01       		.byte	1
 14644 0864 00       		.byte	0
 14645 0865 03       		.byte	3
 14646 0866 00       		.byte	0
 14647 0867 3C       		.byte	60
 14648 0868 00       		.byte	0
 14649 0869 3C       		.byte	60
 14650 086a 00       		.byte	0
 14651 086b 30       		.byte	48
 14652 086c 01       		.byte	1
 14653 086d 00       		.byte	0
 14654 086e 0000     		.space	2
 14657              	EXTNightDaylev:
 14658 0870 24       		.byte	36
 14659 0871 24       		.byte	36
 14660 0872 02       		.byte	2
 14661 0873 00       		.byte	0
 14662 0874 00       		.byte	0
 14663 0875 64       		.byte	100
 14664 0876 00       		.byte	0
 14665 0877 01       		.byte	1
 14666 0878 00       		.byte	0
 14667 0879 03       		.byte	3
 14668 087a 00       		.byte	0
 14669 087b 10       		.byte	16
 14670 087c 00       		.byte	0
 14671 087d 10       		.byte	16
 14672 087e 00       		.byte	0
 14673 087f 30       		.byte	48
 14674 0880 01       		.byte	1
 14675 0881 00       		.byte	0
 14676 0882 0000     		.space	2
 14679              	EXTDayNightlev:
 14680 0884 23       		.byte	35
 14681 0885 23       		.byte	35
 14682 0886 02       		.byte	2
 14683 0887 00       		.byte	0
 14684 0888 00       		.byte	0
 14685 0889 64       		.byte	100
 14686 088a 00       		.byte	0
 14687 088b 01       		.byte	1
 14688 088c 00       		.byte	0
 14689 088d 03       		.byte	3
 14690 088e 00       		.byte	0
 14691 088f 10       		.byte	16
 14692 0890 00       		.byte	0
 14693 0891 10       		.byte	16
 14694 0892 00       		.byte	0
 14695 0893 30       		.byte	48
 14696 0894 01       		.byte	1
 14697 0895 00       		.byte	0
 14698 0896 0000     		.space	2
 14701              	EXTDayNightMode:
 14702 0898 20       		.byte	32
 14703 0899 20       		.byte	32
 14704 089a 02       		.byte	2
 14705 089b 00       		.byte	0
 14706 089c 00       		.byte	0
 14707 089d 02       		.byte	2
 14708 089e 00       		.byte	0
 14709 089f 01       		.byte	1
 14710 08a0 00       		.byte	0
 14711 08a1 03       		.byte	3
 14712 08a2 00       		.byte	0
 14713 08a3 00       		.byte	0
 14714 08a4 00       		.byte	0
 14715 08a5 00       		.byte	0
 14716 08a6 00       		.byte	0
 14717 08a7 30       		.byte	48
 14718 08a8 01       		.byte	1
 14719 08a9 00       		.byte	0
 14720 08aa 0000     		.space	2
 14723              	EXT3DNoiseLev:
 14724 08ac 19       		.byte	25
 14725 08ad 19       		.byte	25
 14726 08ae 02       		.byte	2
 14727 08af 00       		.byte	0
 14728 08b0 00       		.byte	0
 14729 08b1 40       		.byte	64
 14730 08b2 00       		.byte	0
 14731 08b3 01       		.byte	1
 14732 08b4 00       		.byte	0
 14733 08b5 03       		.byte	3
 14734 08b6 00       		.byte	0
 14735 08b7 20       		.byte	32
 14736 08b8 00       		.byte	0
 14737 08b9 20       		.byte	32
 14738 08ba 00       		.byte	0
 14739 08bb 30       		.byte	48
 14740 08bc 01       		.byte	1
 14741 08bd 00       		.byte	0
 14742 08be 0000     		.space	2
 14745              	EXT3DnoiseReduceMode:
 14746 08c0 18       		.byte	24
 14747 08c1 18       		.byte	24
 14748 08c2 02       		.byte	2
 14749 08c3 00       		.byte	0
 14750 08c4 00       		.byte	0
 14751 08c5 01       		.byte	1
 14752 08c6 00       		.byte	0
 14753 08c7 01       		.byte	1
 14754 08c8 00       		.byte	0
 14755 08c9 03       		.byte	3
 14756 08ca 00       		.byte	0
 14757 08cb 00       		.byte	0
 14758 08cc 00       		.byte	0
 14759 08cd 00       		.byte	0
 14760 08ce 00       		.byte	0
 14761 08cf 30       		.byte	48
 14762 08d0 01       		.byte	1
 14763 08d1 00       		.byte	0
 14764 08d2 0000     		.space	2
 14767              	EXTMirror:
 14768 08d4 05       		.byte	5
 14769 08d5 05       		.byte	5
 14770 08d6 02       		.byte	2
 14771 08d7 00       		.byte	0
 14772 08d8 00       		.byte	0
 14773 08d9 03       		.byte	3
 14774 08da 00       		.byte	0
 14775 08db 01       		.byte	1
 14776 08dc 00       		.byte	0
 14777 08dd 03       		.byte	3
 14778 08de 00       		.byte	0
 14779 08df 00       		.byte	0
 14780 08e0 00       		.byte	0
 14781 08e1 00       		.byte	0
 14782 08e2 00       		.byte	0
 14783 08e3 30       		.byte	48
 14784 08e4 01       		.byte	1
 14785 08e5 00       		.byte	0
 14786 08e6 0000     		.space	2
 14789              	EXTSensUp:
 14790 08e8 01       		.byte	1
 14791 08e9 01       		.byte	1
 14792 08ea 02       		.byte	2
 14793 08eb 00       		.byte	0
 14794 08ec 00       		.byte	0
 14795 08ed 09       		.byte	9
 14796 08ee 00       		.byte	0
 14797 08ef 01       		.byte	1
 14798 08f0 00       		.byte	0
 14799 08f1 03       		.byte	3
 14800 08f2 00       		.byte	0
 14801 08f3 00       		.byte	0
 14802 08f4 00       		.byte	0
 14803 08f5 01       		.byte	1
 14804 08f6 00       		.byte	0
 14805 08f7 30       		.byte	48
 14806 08f8 01       		.byte	1
 14807 08f9 00       		.byte	0
 14808 08fa 0000     		.space	2
 14811              	PUCDZoom:
 14812 08fc 2A       		.byte	42
 14813 08fd 2A       		.byte	42
 14814 08fe 02       		.byte	2
 14815 08ff 00       		.byte	0
 14816 0900 00       		.byte	0
 14817 0901 1B       		.byte	27
 14818 0902 00       		.byte	0
 14819 0903 01       		.byte	1
 14820 0904 00       		.byte	0
 14821 0905 03       		.byte	3
 14822 0906 00       		.byte	0
 14823 0907 00       		.byte	0
 14824 0908 00       		.byte	0
 14825 0909 00       		.byte	0
 14826 090a 00       		.byte	0
 14827 090b 30       		.byte	48
 14828 090c 01       		.byte	1
 14829 090d 00       		.byte	0
 14830 090e 0000     		.space	2
 14833              	PUCWBLC:
 14834 0910 09       		.byte	9
 14835 0911 0A       		.byte	10
 14836 0912 04       		.byte	4
 14837 0913 00       		.byte	0
 14838 0914 00       		.byte	0
 14839 0915 40       		.byte	64
 14840 0916 00       		.byte	0
 14841 0917 01       		.byte	1
 14842 0918 00       		.byte	0
 14843 0919 03       		.byte	3
 14844 091a 00       		.byte	0
 14845 091b 20       		.byte	32
 14846 091c 00       		.byte	0
 14847 091d 38       		.byte	56
 14848 091e 00       		.byte	0
 14849 091f 30       		.byte	48
 14850 0920 01       		.byte	1
 14851 0921 00       		.byte	0
 14852 0922 0000     		.space	2
 14855              	PUCWBMd:
 14856 0924 08       		.byte	8
 14857 0925 08       		.byte	8
 14858 0926 02       		.byte	2
 14859 0927 00       		.byte	0
 14860 0928 00       		.byte	0
 14861 0929 05       		.byte	5
 14862 092a 00       		.byte	0
 14863 092b 01       		.byte	1
 14864 092c 00       		.byte	0
 14865 092d 03       		.byte	3
 14866 092e 00       		.byte	0
 14867 092f 00       		.byte	0
 14868 0930 00       		.byte	0
 14869 0931 00       		.byte	0
 14870 0932 00       		.byte	0
 14871 0933 30       		.byte	48
 14872 0934 01       		.byte	1
 14873 0935 00       		.byte	0
 14874 0936 0000     		.space	2
 14877              	PUCSaturation:
 14878 0938 85       		.byte	-123
 14879 0939 86       		.byte	-122
 14880 093a 02       		.byte	2
 14881 093b 00       		.byte	0
 14882 093c 00       		.byte	0
 14883 093d 64       		.byte	100
 14884 093e 00       		.byte	0
 14885 093f 01       		.byte	1
 14886 0940 00       		.byte	0
 14887 0941 03       		.byte	3
 14888 0942 00       		.byte	0
 14889 0943 32       		.byte	50
 14890 0944 00       		.byte	0
 14891 0945 32       		.byte	50
 14892 0946 00       		.byte	0
 14893 0947 30       		.byte	48
 14894 0948 01       		.byte	1
 14895 0949 00       		.byte	0
 14896 094a 0000     		.space	2
 14899              	PUCContrast:
 14900 094c 0D       		.byte	13
 14901 094d 0D       		.byte	13
 14902 094e 02       		.byte	2
 14903 094f 00       		.byte	0
 14904 0950 00       		.byte	0
 14905 0951 FF       		.byte	-1
 14906 0952 00       		.byte	0
 14907 0953 01       		.byte	1
 14908 0954 00       		.byte	0
 14909 0955 03       		.byte	3
 14910 0956 00       		.byte	0
 14911 0957 70       		.byte	112
 14912 0958 00       		.byte	0
 14913 0959 70       		.byte	112
 14914 095a 00       		.byte	0
 14915 095b 30       		.byte	48
 14916 095c 01       		.byte	1
 14917 095d 00       		.byte	0
 14918 095e 0000     		.space	2
 14921              	CyFxGpifRegValue_usb2:
 14922 0960 08830080 		.word	-2147450104
 14923 0964 67000000 		.word	103
 14924 0968 01000000 		.word	1
 14925 096c 46000000 		.word	70
 14926 0970 00000000 		.word	0
 14927 0974 00000000 		.word	0
 14928 0978 02000000 		.word	2
 14929 097c 82000000 		.word	130
 14930 0980 82070000 		.word	1922
 14931 0984 40040000 		.word	1088
 14932 0988 FCFF0000 		.word	65532
 14933 098c 28000000 		.word	40
 14934 0990 00000000 		.word	0
 14935 0994 00000000 		.word	0
 14936 0998 00000000 		.word	0
 14937 099c 00000000 		.word	0
 14938 09a0 01000000 		.word	1
 14939 09a4 00000000 		.word	0
 14940 09a8 00000000 		.word	0
 14941 09ac 00000000 		.word	0
 14942 09b0 00000000 		.word	0
 14943 09b4 00000000 		.word	0
 14944 09b8 00000000 		.word	0
 14945 09bc 00000000 		.word	0
 14946 09c0 00000000 		.word	0
 14947 09c4 00000000 		.word	0
 14948 09c8 00000000 		.word	0
 14949 09cc 00000000 		.word	0
 14950 09d0 00000000 		.word	0
 14951 09d4 06000000 		.word	6
 14952 09d8 00000000 		.word	0
 14953 09dc FFFF0000 		.word	65535
 14954 09e0 09010000 		.word	265
 14955 09e4 00000000 		.word	0
 14956 09e8 F71F0000 		.word	8183
 14957 09ec 00000000 		.word	0
 14958 09f0 FFFF0000 		.word	65535
 14959 09f4 09010000 		.word	265
 14960 09f8 00000000 		.word	0
 14961 09fc F71F0000 		.word	8183
 14962 0a00 00000000 		.word	0
 14963 0a04 00000000 		.word	0
 14964 0a08 00000000 		.word	0
 14965 0a0c 00000000 		.word	0
 14966 0a10 00000000 		.word	0
 14967 0a14 00000000 		.word	0
 14968 0a18 00000000 		.word	0
 14969 0a1c 00000000 		.word	0
 14970 0a20 00000000 		.word	0
 14971 0a24 00000000 		.word	0
 14972 0a28 00000000 		.word	0
 14973 0a2c 00000000 		.word	0
 14974 0a30 00000000 		.word	0
 14975 0a34 00000000 		.word	0
 14976 0a38 00000000 		.word	0
 14977 0a3c 00000000 		.word	0
 14978 0a40 00000000 		.word	0
 14979 0a44 00000000 		.word	0
 14980 0a48 00000000 		.word	0
 14981 0a4c 00000000 		.word	0
 14982 0a50 00000000 		.word	0
 14983 0a54 00000000 		.word	0
 14984 0a58 00000000 		.word	0
 14985 0a5c 00040180 		.word	-2147417088
 14986 0a60 01040180 		.word	-2147417087
 14987 0a64 02040180 		.word	-2147417086
 14988 0a68 03040180 		.word	-2147417085
 14989 0a6c 00000000 		.word	0
 14990 0a70 00000000 		.word	0
 14991 0a74 00000000 		.word	0
 14992 0a78 00000000 		.word	0
 14993 0a7c 00000000 		.word	0
 14994 0a80 00000000 		.word	0
 14995 0a84 00000000 		.word	0
 14996 0a88 00000000 		.word	0
 14997 0a8c C1FFFFFF 		.word	-63
 15000              	CyFxGpifWavedataPosition_usb2:
 15001 0a90 00       		.byte	0
 15002 0a91 01       		.byte	1
 15003 0a92 02       		.byte	2
 15004 0a93 03       		.byte	3
 15005 0a94 04       		.byte	4
 15006 0a95 05       		.byte	5
 15007 0a96 06       		.byte	6
 15008 0a97 07       		.byte	7
 15009 0a98 08       		.byte	8
 15010 0a99 09       		.byte	9
 15011 0a9a 0A       		.byte	10
 15012 0a9b 08       		.byte	8
 15013 0a9c 0B       		.byte	11
 15014 0a9d 0C       		.byte	12
 15015 0a9e 0D       		.byte	13
 15016 0a9f 08       		.byte	8
 15017 0aa0 0E       		.byte	14
 15018 0aa1 0F       		.byte	15
 15019 0aa2 08       		.byte	8
 15020 0aa3 08       		.byte	8
 15021 0aa4 08       		.byte	8
 15022 0aa5 08       		.byte	8
 15023 0aa6 08       		.byte	8
 15024 0aa7 08       		.byte	8
 15025 0aa8 08       		.byte	8
 15026 0aa9 08       		.byte	8
 15027 0aaa 08       		.byte	8
 15028 0aab 08       		.byte	8
 15029 0aac 08       		.byte	8
 15030 0aad 08       		.byte	8
 15031 0aae 08       		.byte	8
 15032 0aaf 08       		.byte	8
 15033 0ab0 08       		.byte	8
 15034 0ab1 08       		.byte	8
 15035 0ab2 08       		.byte	8
 15036 0ab3 08       		.byte	8
 15037 0ab4 08       		.byte	8
 15038 0ab5 08       		.byte	8
 15039 0ab6 08       		.byte	8
 15040 0ab7 08       		.byte	8
 15041 0ab8 08       		.byte	8
 15042 0ab9 08       		.byte	8
 15043 0aba 08       		.byte	8
 15044 0abb 08       		.byte	8
 15045 0abc 08       		.byte	8
 15046 0abd 08       		.byte	8
 15047 0abe 08       		.byte	8
 15048 0abf 08       		.byte	8
 15049 0ac0 08       		.byte	8
 15050 0ac1 08       		.byte	8
 15051 0ac2 08       		.byte	8
 15052 0ac3 08       		.byte	8
 15053 0ac4 08       		.byte	8
 15054 0ac5 08       		.byte	8
 15055 0ac6 08       		.byte	8
 15056 0ac7 08       		.byte	8
 15057 0ac8 08       		.byte	8
 15058 0ac9 08       		.byte	8
 15059 0aca 08       		.byte	8
 15060 0acb 08       		.byte	8
 15061 0acc 08       		.byte	8
 15062 0acd 08       		.byte	8
 15063 0ace 08       		.byte	8
 15064 0acf 08       		.byte	8
 15065 0ad0 08       		.byte	8
 15066 0ad1 08       		.byte	8
 15067 0ad2 08       		.byte	8
 15068 0ad3 08       		.byte	8
 15069 0ad4 08       		.byte	8
 15070 0ad5 08       		.byte	8
 15071 0ad6 08       		.byte	8
 15072 0ad7 08       		.byte	8
 15073 0ad8 08       		.byte	8
 15074 0ad9 08       		.byte	8
 15075 0ada 08       		.byte	8
 15076 0adb 08       		.byte	8
 15077 0adc 08       		.byte	8
 15078 0add 08       		.byte	8
 15079 0ade 08       		.byte	8
 15080 0adf 08       		.byte	8
 15081 0ae0 08       		.byte	8
 15082 0ae1 08       		.byte	8
 15083 0ae2 08       		.byte	8
 15084 0ae3 08       		.byte	8
 15085 0ae4 08       		.byte	8
 15086 0ae5 08       		.byte	8
 15087 0ae6 08       		.byte	8
 15088 0ae7 08       		.byte	8
 15089 0ae8 08       		.byte	8
 15090 0ae9 08       		.byte	8
 15091 0aea 08       		.byte	8
 15092 0aeb 08       		.byte	8
 15093 0aec 08       		.byte	8
 15094 0aed 08       		.byte	8
 15095 0aee 08       		.byte	8
 15096 0aef 08       		.byte	8
 15097 0af0 08       		.byte	8
 15098 0af1 08       		.byte	8
 15099 0af2 08       		.byte	8
 15100 0af3 08       		.byte	8
 15101 0af4 08       		.byte	8
 15102 0af5 08       		.byte	8
 15103 0af6 08       		.byte	8
 15104 0af7 08       		.byte	8
 15105 0af8 08       		.byte	8
 15106 0af9 08       		.byte	8
 15107 0afa 08       		.byte	8
 15108 0afb 08       		.byte	8
 15109 0afc 08       		.byte	8
 15110 0afd 08       		.byte	8
 15111 0afe 08       		.byte	8
 15112 0aff 08       		.byte	8
 15113 0b00 08       		.byte	8
 15114 0b01 08       		.byte	8
 15115 0b02 08       		.byte	8
 15116 0b03 08       		.byte	8
 15117 0b04 08       		.byte	8
 15118 0b05 08       		.byte	8
 15119 0b06 08       		.byte	8
 15120 0b07 08       		.byte	8
 15121 0b08 08       		.byte	8
 15122 0b09 08       		.byte	8
 15123 0b0a 08       		.byte	8
 15124 0b0b 08       		.byte	8
 15125 0b0c 08       		.byte	8
 15126 0b0d 08       		.byte	8
 15127 0b0e 08       		.byte	8
 15128 0b0f 08       		.byte	8
 15129 0b10 00       		.byte	0
 15130 0b11 01       		.byte	1
 15131 0b12 02       		.byte	2
 15132 0b13 10       		.byte	16
 15133 0b14 04       		.byte	4
 15134 0b15 05       		.byte	5
 15135 0b16 06       		.byte	6
 15136 0b17 07       		.byte	7
 15137 0b18 08       		.byte	8
 15138 0b19 09       		.byte	9
 15139 0b1a 0A       		.byte	10
 15140 0b1b 08       		.byte	8
 15141 0b1c 11       		.byte	17
 15142 0b1d 0C       		.byte	12
 15143 0b1e 0D       		.byte	13
 15144 0b1f 08       		.byte	8
 15145 0b20 0E       		.byte	14
 15146 0b21 0F       		.byte	15
 15147 0b22 08       		.byte	8
 15148 0b23 00       		.space	1
 15151              	CyFxGpifWavedata_usb2:
 15152 0b24 0181731E 		.word	510886145
 15153 0b28 00000000 		.word	0
 15154 0b2c 00000080 		.word	-2147483648
 15155 0b30 00000000 		.word	0
 15156 0b34 00000000 		.word	0
 15157 0b38 00000000 		.word	0
 15158 0b3c 0201703E 		.word	1047527682
 15159 0b40 00010000 		.word	256
 15160 0b44 A00000C0 		.word	-1073741664
 15161 0b48 00000000 		.word	0
 15162 0b4c 00000000 		.word	0
 15163 0b50 00000000 		.word	0
 15164 0b54 0394731E 		.word	510891011
 15165 0b58 04000020 		.word	536870916
 15166 0b5c 60004080 		.word	-2143289248
 15167 0b60 00000000 		.word	0
 15168 0b64 00000000 		.word	0
 15169 0b68 00000000 		.word	0
 15170 0b6c 0620702E 		.word	779100166
 15171 0b70 0C000000 		.word	12
 15172 0b74 00000080 		.word	-2147483648
 15173 0b78 0620702E 		.word	779100166
 15174 0b7c 0C000000 		.word	12
 15175 0b80 00000080 		.word	-2147483648
 15176 0b84 0394731E 		.word	510891011
 15177 0b88 04000020 		.word	536870916
 15178 0b8c 60004080 		.word	-2143289248
 15179 0b90 0620702E 		.word	779100166
 15180 0b94 0C000000 		.word	12
 15181 0b98 00000080 		.word	-2147483648
 15182 0b9c 0C93731E 		.word	510890764
 15183 0ba0 04000024 		.word	603979780
 15184 0ba4 90004080 		.word	-2143289200
 15185 0ba8 0D20702E 		.word	779100173
 15186 0bac 0C000000 		.word	12
 15187 0bb0 00000080 		.word	-2147483648
 15188 0bb4 0780724E 		.word	1316126727
 15189 0bb8 0A000000 		.word	10
 15190 0bbc 00000080 		.word	-2147483648
 15191 0bc0 08000000 		.word	8
 15192 0bc4 00000000 		.word	0
 15193 0bc8 00010080 		.word	-2147483392
 15194 0bcc 0920702E 		.word	779100169
 15195 0bd0 0C010000 		.word	268
 15196 0bd4 00000080 		.word	-2147483648
 15197 0bd8 0A01701E 		.word	510656778
 15198 0bdc 0E000100 		.word	65550
 15199 0be0 00000080 		.word	-2147483648
 15200 0be4 00000000 		.word	0
 15201 0be8 00000000 		.word	0
 15202 0bec 00000000 		.word	0
 15203 0bf0 00000000 		.word	0
 15204 0bf4 00000000 		.word	0
 15205 0bf8 00000000 		.word	0
 15206 0bfc 0394731E 		.word	510891011
 15207 0c00 04000020 		.word	536870916
 15208 0c04 60004080 		.word	-2143289248
 15209 0c08 08000000 		.word	8
 15210 0c0c 00000000 		.word	0
 15211 0c10 00010080 		.word	-2147483392
 15212 0c14 0B000000 		.word	11
 15213 0c18 00000000 		.word	0
 15214 0c1c 00010080 		.word	-2147483392
 15215 0c20 0C93731E 		.word	510890764
 15216 0c24 04000024 		.word	603979780
 15217 0c28 90004080 		.word	-2143289200
 15218 0c2c 0D20702E 		.word	779100173
 15219 0c30 0C000000 		.word	12
 15220 0c34 00000080 		.word	-2147483648
 15221 0c38 0D20702E 		.word	779100173
 15222 0c3c 0C000000 		.word	12
 15223 0c40 00000080 		.word	-2147483648
 15224 0c44 0E60724E 		.word	1316118542
 15225 0c48 0A000000 		.word	10
 15226 0c4c 00000080 		.word	-2147483648
 15227 0c50 0F000000 		.word	15
 15228 0c54 00000000 		.word	0
 15229 0c58 00010080 		.word	-2147483392
 15230 0c5c 1020702E 		.word	779100176
 15231 0c60 0C010000 		.word	268
 15232 0c64 00000080 		.word	-2147483648
 15233 0c68 1101701E 		.word	510656785
 15234 0c6c 0E000100 		.word	65550
 15235 0c70 00000080 		.word	-2147483648
 15236 0c74 0C93731E 		.word	510890764
 15237 0c78 04000024 		.word	603979780
 15238 0c7c 90004080 		.word	-2143289200
 15239 0c80 0F000000 		.word	15
 15240 0c84 00000000 		.word	0
 15241 0c88 00010080 		.word	-2147483392
 15242 0c8c 12000000 		.word	18
 15243 0c90 00000000 		.word	0
 15244 0c94 00010080 		.word	-2147483392
 15245 0c98 0394731E 		.word	510891011
 15246 0c9c 04000020 		.word	536870916
 15247 0ca0 60004080 		.word	-2143289248
 15248 0ca4 0480732E 		.word	779321348
 15249 0ca8 02010000 		.word	258
 15250 0cac 0000C0C0 		.word	-1061158912
 15251 0cb0 0580732E 		.word	779321349
 15252 0cb4 02010000 		.word	258
 15253 0cb8 0000C0C0 		.word	-1061158912
 15254 0cbc 0580732E 		.word	779321349
 15255 0cc0 02010000 		.word	258
 15256 0cc4 0000C0C0 		.word	-1061158912
 15257 0cc8 0480732E 		.word	779321348
 15258 0ccc 02010000 		.word	258
 15259 0cd0 0000C0C0 		.word	-1061158912
 15262              	CyFxGpifTransition_usb2:
 15263 0cd4 0000     		.short	0
 15264 0cd6 5555     		.short	21845
 15265 0cd8 AAAA     		.short	-21846
 15266 0cda 8888     		.short	-30584
 15267 0cdc 1111     		.short	4369
 15268 0cde 4444     		.short	17476
 15269 0ce0 3333     		.short	13107
 15270 0ce2 CCCC     		.short	-13108
 15273              	CyFxGpifRegValue:
 15274 0ce4 08830080 		.word	-2147450104
 15275 0ce8 67000000 		.word	103
 15276 0cec 00000000 		.word	0
 15277 0cf0 46000000 		.word	70
 15278 0cf4 00000000 		.word	0
 15279 0cf8 00000000 		.word	0
 15280 0cfc 02000000 		.word	2
 15281 0d00 82000000 		.word	130
 15282 0d04 82070000 		.word	1922
 15283 0d08 40040000 		.word	1088
 15284 0d0c FCFF0000 		.word	65532
 15285 0d10 28000000 		.word	40
 15286 0d14 00000000 		.word	0
 15287 0d18 00000000 		.word	0
 15288 0d1c 00000000 		.word	0
 15289 0d20 00000000 		.word	0
 15290 0d24 01000000 		.word	1
 15291 0d28 00000000 		.word	0
 15292 0d2c 00000000 		.word	0
 15293 0d30 00000000 		.word	0
 15294 0d34 00000000 		.word	0
 15295 0d38 00000000 		.word	0
 15296 0d3c 00000000 		.word	0
 15297 0d40 00000000 		.word	0
 15298 0d44 00000000 		.word	0
 15299 0d48 00000000 		.word	0
 15300 0d4c 00000000 		.word	0
 15301 0d50 00000000 		.word	0
 15302 0d54 00000000 		.word	0
 15303 0d58 06000000 		.word	6
 15304 0d5c 00000000 		.word	0
 15305 0d60 FFFF0000 		.word	65535
 15306 0d64 09010000 		.word	265
 15307 0d68 00000000 		.word	0
 15308 0d6c F71F0000 		.word	8183
 15309 0d70 00000000 		.word	0
 15310 0d74 FFFF0000 		.word	65535
 15311 0d78 09010000 		.word	265
 15312 0d7c 00000000 		.word	0
 15313 0d80 F71F0000 		.word	8183
 15314 0d84 00000000 		.word	0
 15315 0d88 00000000 		.word	0
 15316 0d8c 00000000 		.word	0
 15317 0d90 00000000 		.word	0
 15318 0d94 00000000 		.word	0
 15319 0d98 00000000 		.word	0
 15320 0d9c 00000000 		.word	0
 15321 0da0 00000000 		.word	0
 15322 0da4 00000000 		.word	0
 15323 0da8 00000000 		.word	0
 15324 0dac 00000000 		.word	0
 15325 0db0 00000000 		.word	0
 15326 0db4 00000000 		.word	0
 15327 0db8 00000000 		.word	0
 15328 0dbc 00000000 		.word	0
 15329 0dc0 00000000 		.word	0
 15330 0dc4 00000000 		.word	0
 15331 0dc8 00000000 		.word	0
 15332 0dcc 00000000 		.word	0
 15333 0dd0 00000000 		.word	0
 15334 0dd4 00000000 		.word	0
 15335 0dd8 00000000 		.word	0
 15336 0ddc 00000000 		.word	0
 15337 0de0 00040180 		.word	-2147417088
 15338 0de4 01040180 		.word	-2147417087
 15339 0de8 02040180 		.word	-2147417086
 15340 0dec 03040180 		.word	-2147417085
 15341 0df0 00000000 		.word	0
 15342 0df4 00000000 		.word	0
 15343 0df8 00000000 		.word	0
 15344 0dfc 00000000 		.word	0
 15345 0e00 00000000 		.word	0
 15346 0e04 00000000 		.word	0
 15347 0e08 00000000 		.word	0
 15348 0e0c 00000000 		.word	0
 15349 0e10 C1FFFFFF 		.word	-63
 15352              	CyFxGpifWavedataPosition:
 15353 0e14 00       		.byte	0
 15354 0e15 01       		.byte	1
 15355 0e16 02       		.byte	2
 15356 0e17 03       		.byte	3
 15357 0e18 04       		.byte	4
 15358 0e19 05       		.byte	5
 15359 0e1a 06       		.byte	6
 15360 0e1b 07       		.byte	7
 15361 0e1c 08       		.byte	8
 15362 0e1d 09       		.byte	9
 15363 0e1e 0A       		.byte	10
 15364 0e1f 0B       		.byte	11
 15365 0e20 0B       		.byte	11
 15366 0e21 0B       		.byte	11
 15367 0e22 0B       		.byte	11
 15368 0e23 00       		.space	1
 15371              	CyFxGpifWavedata:
 15372 0e24 0181731E 		.word	510886145
 15373 0e28 00000000 		.word	0
 15374 0e2c 00000080 		.word	-2147483648
 15375 0e30 00000000 		.word	0
 15376 0e34 00000000 		.word	0
 15377 0e38 00000000 		.word	0
 15378 0e3c 0201702E 		.word	779092226
 15379 0e40 00010000 		.word	256
 15380 0e44 A0000080 		.word	-2147483488
 15381 0e48 00000000 		.word	0
 15382 0e4c 00000000 		.word	0
 15383 0e50 00000000 		.word	0
 15384 0e54 0380722E 		.word	779255811
 15385 0e58 02010020 		.word	536871170
 15386 0e5c 60000080 		.word	-2147483552
 15387 0e60 00000000 		.word	0
 15388 0e64 00000000 		.word	0
 15389 0e68 00000000 		.word	0
 15390 0e6c 0460722E 		.word	779247620
 15391 0e70 02010024 		.word	603980034
 15392 0e74 90000080 		.word	-2147483504
 15393 0e78 0594731E 		.word	510891013
 15394 0e7c 06000000 		.word	6
 15395 0e80 00000080 		.word	-2147483648
 15396 0e84 0380722E 		.word	779255811
 15397 0e88 02010020 		.word	536871170
 15398 0e8c 60000080 		.word	-2147483552
 15399 0e90 0693731E 		.word	510890758
 15400 0e94 06000000 		.word	6
 15401 0e98 00000080 		.word	-2147483648
 15402 0e9c 0720703E 		.word	1047535623
 15403 0ea0 08010000 		.word	264
 15404 0ea4 00000080 		.word	-2147483648
 15405 0ea8 0820703E 		.word	1047535624
 15406 0eac 08010000 		.word	264
 15407 0eb0 00000080 		.word	-2147483648
 15408 0eb4 0920703E 		.word	1047535625
 15409 0eb8 08010000 		.word	264
 15410 0ebc 00000080 		.word	-2147483648
 15411 0ec0 0A20703E 		.word	1047535626
 15412 0ec4 08010000 		.word	264
 15413 0ec8 00000080 		.word	-2147483648
 15414 0ecc 0380722E 		.word	779255811
 15415 0ed0 02010020 		.word	536871170
 15416 0ed4 60000080 		.word	-2147483552
 15417 0ed8 0B000000 		.word	11
 15418 0edc 00000000 		.word	0
 15419 0ee0 00010080 		.word	-2147483392
 15420 0ee4 0460722E 		.word	779247620
 15421 0ee8 02010024 		.word	603980034
 15422 0eec 90000080 		.word	-2147483504
 15423 0ef0 0D000000 		.word	13
 15424 0ef4 00000000 		.word	0
 15425 0ef8 00010080 		.word	-2147483392
 15426 0efc 0460722E 		.word	779247620
 15427 0f00 02010024 		.word	603980034
 15428 0f04 90000080 		.word	-2147483504
 15429 0f08 0C000000 		.word	12
 15430 0f0c 00000000 		.word	0
 15431 0f10 00010080 		.word	-2147483392
 15432 0f14 0380722E 		.word	779255811
 15433 0f18 02010020 		.word	536871170
 15434 0f1c 60000080 		.word	-2147483552
 15435 0f20 0E000000 		.word	14
 15436 0f24 00000000 		.word	0
 15437 0f28 00010080 		.word	-2147483392
 15438 0f2c 00000000 		.word	0
 15439 0f30 00000000 		.word	0
 15440 0f34 00000000 		.word	0
 15441 0f38 00000000 		.word	0
 15442 0f3c 00000000 		.word	0
 15443 0f40 00000000 		.word	0
 15446              	CyFxGpifTransition:
 15447 0f44 0000     		.short	0
 15448 0f46 5555     		.short	21845
 15449 0f48 8888     		.short	-30584
 15450 0f4a AAAA     		.short	-21846
 15451 0f4c 3333     		.short	13107
 15452 0f4e 0000     		.section	.rodata.str1.4,"aMS",%progbits,1
 15453              		.align	2
 15454              	.LC0:
 15455 0000 49324320 		.ascii	"I2C pos-timer %d %d\015\012\000"
 15455      706F732D 
 15455      74696D65 
 15455      72202564 
 15455      2025640D 
 15456 0016 0000     		.space	2
 15457              	.LC1:
 15458 0018 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 15458      6F207374 
 15458      7265616D 
 15458      20474554 
 15458      20726571 
 15459 003d 000000   		.space	3
 15460              	.LC2:
 15461 0040 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 15461      74686520 
 15461      76696465 
 15461      6F206D6F 
 15461      64652066 
 15462 0061 000000   		.space	3
 15463              	.LC3:
 15464 0064 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 15464      74686520 
 15464      76696465 
 15464      6F206D6F 
 15464      64652066 
 15465 0089 000000   		.space	3
 15466              	.LC4:
 15467 008c 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 15467      43595F46 
 15467      585F5556 
 15467      435F5354 
 15467      5245414D 
 15468 00b2 0000     		.space	2
 15469              	.LC5:
 15470 00b4 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 15470      55564320 
 15470      7374696C 
 15470      6C205072 
 15470      6F622873 
 15471 00df 00       		.space	1
 15472              	.LC6:
 15473 00e0 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 15473      74686520 
 15473      7374696C 
 15473      6C206D6F 
 15473      64652066 
 15474 0101 000000   		.space	3
 15475              	.LC7:
 15476 0104 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 15476      7374696C 
 15476      6C20636F 
 15476      6D6D6974 
 15476      20636F6E 
 15477              	.LC8:
 15478 012c 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 15478      43595F46 
 15478      585F5556 
 15478      435F5354 
 15478      494C5F45 
 15479              	.LC9:
 15480 0150 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 15480      55564320 
 15480      7374696C 
 15480      6C207472 
 15480      69676765 
 15481 0179 000000   		.space	3
 15482              	.LC10:
 15483 017c 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 15483      7374696C 
 15483      6C207472 
 15483      69676765 
 15483      7220636F 
 15484 01a3 00       		.space	1
 15485              	.LC11:
 15486 01a4 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 15486      7065722D 
 15486      74696D65 
 15486      72202564 
 15486      0D0A00
 15487 01b7 00       		.space	1
 15488              	.LC12:
 15489 01b8 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 15489      636F6D6D 
 15489      616E6420 
 15489      71756575 
 15489      65206973 
 15490 01db 00       		.space	1
 15491              	.LC13:
 15492 01dc 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 15492      7220696E 
 15492      206D756C 
 15492      74696368 
 15492      616E6E65 
 15493 020f 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 15493      2025782C 
 15493      20646D61 
 15493      446F6E65 
 15493      20256420 
 15494              	.LC14:
 15495 0228 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 15495      5420656E 
 15495      636F756E 
 15495      74657265 
 15495      642E2E2E 
 15496              	.LC15:
 15497 0248 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 15497      454E4420 
 15497      656E636F 
 15497      756E7465 
 15497      7265642E 
 15498 026a 0000     		.space	2
 15499              	.LC16:
 15500 026c 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 15500      64697363 
 15500      6F6E6E65 
 15500      63746564 
 15500      2E2E2E30 
 15501 028b 00       		.space	1
 15502              	.LC17:
 15503 028c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 15503      43595F46 
 15503      585F5556 
 15503      435F5649 
 15503      44454F5F 
 15504 02bf 0A00     		.ascii	"\012\000"
 15505 02c1 000000   		.space	3
 15506              	.LC18:
 15507 02c4 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 15507      43595F46 
 15507      585F5556 
 15507      435F5649 
 15507      44454F5F 
 15508 02f7 00       		.ascii	"\000"
 15509              	.LC19:
 15510 02f8 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 15510      726E6174 
 15510      65207365 
 15510      7474696E 
 15510      6720302E 
 15511              	.LC20:
 15512 0310 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 15512      72206665 
 15512      61747572 
 15512      65207265 
 15512      71756573 
 15513 0333 00       		.space	1
 15514              	.LC21:
 15515 0334 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 15515      49324320 
 15515      636F6D6D 
 15515      616E6420 
 15515      69732030 
 15516 0367 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 15516      78257820 
 15516      30782578 
 15516      20307825 
 15516      78203078 
 15517              	.LC22:
 15518 0380 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 15518      49324320 
 15518      636F6D6D 
 15518      616E6420 
 15518      73657474 
 15519 03a6 0000     		.space	2
 15520              	.LC23:
 15521 03a8 54686520 		.ascii	"The shutter set value %d 0x%x 0x%x 0x%x\015\012\000"
 15521      73687574 
 15521      74657220 
 15521      73657420 
 15521      76616C75 
 15522 03d2 0000     		.space	2
 15523              	.LC24:
 15524 03d4 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 15524      26414743 
 15524      2073656E 
 15524      7420746F 
 15524      20686F73 
 15525 03fa 0000     		.space	2
 15526              	.LC25:
 15527 03fc 54686520 		.ascii	"The I2C current data is not available. try again. %"
 15527      49324320 
 15527      63757272 
 15527      656E7420 
 15527      64617461 
 15528 042f 64202564 		.ascii	"d %d\015\012\000"
 15528      0D0A00
 15529 0436 0000     		.space	2
 15530              	.LC26:
 15531 0438 54686520 		.ascii	"The current value 0x%x 0x%x 0x%x, 0x%x, %d\015\012\000"
 15531      63757272 
 15531      656E7420 
 15531      76616C75 
 15531      65203078 
 15532 0465 000000   		.space	3
 15533              	.LC27:
 15534 0468 54686520 		.ascii	"The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x d"
 15534      73657420 
 15534      636F6E74 
 15534      726F6C20 
 15534      6374726C 
 15535 049b 65764144 		.ascii	"evADD: 0x%x Len: 0x%x Data0: 0x%x Data1: 0x%x\015\012"
 15535      443A2030 
 15535      78257820 
 15535      4C656E3A 
 15535      20307825 
 15536 04ca 00       		.ascii	"\000"
 15537 04cb 00       		.space	1
 15538              	.LC28:
 15539 04cc 4578704D 		.ascii	"ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\015"
 15539      26414743 
 15539      20676F74 
 15539      74656E20 
 15539      66726F6D 
 15540 04fd 0A00     		.ascii	"\012\000"
 15541 04ff 00       		.space	1
 15542              	.LC29:
 15543 0500 54686520 		.ascii	"The shutter&exposure 0x%x 0x%x 0x%x 0x%x\015\012\000"
 15543      73687574 
 15543      74657226 
 15543      6578706F 
 15543      73757265 
 15544 052b 00       		.space	1
 15545              	.LC30:
 15546 052c 53687574 		.ascii	"Shutter level gotten from host. 0x%x %d; 0x%x 0x%x "
 15546      74657220 
 15546      6C657665 
 15546      6C20676F 
 15546      7474656E 
 15547 055f 25640D0A 		.ascii	"%d\015\012\000"
 15547      00
 15548              	.LC31:
 15549 0564 54686520 		.ascii	"The data gets from host. [0]: 0x%x [1]: 0x%x curLo:"
 15549      64617461 
 15549      20676574 
 15549      73206672 
 15549      6F6D2068 
 15550 0597 20307825 		.ascii	" 0x%x curHi: 0x%x Len: 0x%x\015\012\000"
 15550      78206375 
 15550      7248693A 
 15550      20307825 
 15550      78204C65 
 15551 05b5 000000   		.space	3
 15552              	.LC32:
 15553 05b8 46726571 		.ascii	"Frequency setting is  %d %d\015\012\000"
 15553      75656E63 
 15553      79207365 
 15553      7474696E 
 15553      67206973 
 15554 05d6 0000     		.space	2
 15555              	.LC33:
 15556 05d8 46536574 		.ascii	"FSet the video mode format %x %d\012\000"
 15556      20746865 
 15556      20766964 
 15556      656F206D 
 15556      6F646520 
 15557 05fa 0000     		.space	2
 15558              	.LC34:
 15559 05fc 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 15559      67657420 
 15559      64617461 
 15559      2066726F 
 15559      6D20686F 
 15560 0629 000000   		.space	3
 15561              	.LC35:
 15562 062c 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 15562      52657175 
 15562      65737420 
 15562      30782578 
 15562      20706172 
 15563 065f 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 15563      6E642074 
 15563      6F20686F 
 15563      73742030 
 15563      78257820 
 15564 067a 0000     		.space	2
 15565              	.LC36:
 15566 067c 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 15566      204F7020 
 15566      72656365 
 15566      69766573 
 15566      20284354 
 15567 06a3 00       		.space	1
 15568              	.LC37:
 15569 06a4 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 15569      756C7420 
 15569      73656C65 
 15569      63746F72 
 15569      20284354 
 15570 06c6 0000     		.space	2
 15571              	.LC38:
 15572 06c8 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 15572      756C7420 
 15572      72657175 
 15572      65737420 
 15572      28435429 
 15573 06e9 000000   		.space	3
 15574              	.LC39:
 15575 06ec 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 15575      52657175 
 15575      65737420 
 15575      30782578 
 15575      20706172 
 15576 071f 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 15576      20307825 
 15576      78202F20 
 15576      73656E64 
 15576      20746F20 
 15577 074c 00       		.ascii	"\000"
 15578 074d 000000   		.space	3
 15579              	.LC40:
 15580 0750 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 15580      73657420 
 15580      64656620 
 15580      64617461 
 15580      20307825 
 15581 076f 00       		.space	1
 15582              	.LC41:
 15583 0770 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 15583      73657420 
 15583      64656620 
 15583      64617461 
 15583      20307825 
 15584 07a3 2E0D0A00 		.ascii	".\015\012\000"
 15585 07a7 00       		.space	1
 15586              	.LC42:
 15587 07a8 4572726F 		.ascii	"Error handler...\015\012\000"
 15587      72206861 
 15587      6E646C65 
 15587      722E2E2E 
 15587      0D0A00
 15588 07bb 00       		.space	1
 15589              	.LC43:
 15590 07bc 55415254 		.ascii	"UART initialization failed!\012\000"
 15590      20696E69 
 15590      7469616C 
 15590      697A6174 
 15590      696F6E20 
 15591 07d9 000000   		.space	3
 15592              	.LC44:
 15593 07dc 49324320 		.ascii	"I2C initialization failed!\012\000"
 15593      696E6974 
 15593      69616C69 
 15593      7A617469 
 15593      6F6E2066 
 15594              	.LC45:
 15595 07f8 49324320 		.ascii	"I2C configuration failed!\012\000"
 15595      636F6E66 
 15595      69677572 
 15595      6174696F 
 15595      6E206661 
 15596 0813 00       		.space	1
 15597              	.LC46:
 15598 0814 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 15598      43726561 
 15598      74652045 
 15598      76656E74 
 15598      20666169 
 15599 083e 0000     		.space	2
 15600              	.LC47:
 15601 0840 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 15601      20496E69 
 15601      74206661 
 15601      696C6564 
 15601      2C204572 
 15602 0863 00       		.space	1
 15603              	.LC48:
 15604 0864 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 15604      204F7665 
 15604      72726964 
 15604      65206661 
 15604      696C6564 
 15605 088b 00       		.space	1
 15606              	.LC49:
 15607 088c 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 15607      28323029 
 15607      204F7665 
 15607      72726964 
 15607      65206661 
 15608 08b7 00       		.space	1
 15609              	.LC50:
 15610 08b8 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 15610      28323429 
 15610      204F7665 
 15610      72726964 
 15610      65206661 
 15611 08e3 00       		.space	1
 15612              	.LC51:
 15613 08e4 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 15613      20536574 
 15613      20287265 
 15613      73657420 
 15613      32322920 
 15614 0916 00       		.ascii	"\000"
 15615 0917 00       		.space	1
 15616              	.LC52:
 15617 0918 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 15617      20536574 
 15617      2028706F 
 15617      77657220 
 15617      32302920 
 15618 094a 00       		.ascii	"\000"
 15619 094b 00       		.space	1
 15620              	.LC53:
 15621 094c 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 15621      20536574 
 15621      2028736E 
 15621      61702073 
 15621      686F7420 
 15622 097f 25640A00 		.ascii	"%d\012\000"
 15623 0983 00       		.space	1
 15624              	.LC54:
 15625 0984 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 15625      46756E63 
 15625      74696F6E 
 15625      20466169 
 15625      6C656420 
 15626 09b3 00       		.space	1
 15627              	.LC55:
 15628 09b4 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 15628      46756E63 
 15628      74696F6E 
 15628      20466169 
 15628      6C656420 
 15629 09e3 00       		.space	1
 15630              	.LC56:
 15631 09e4 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 15631      53657420 
 15631      456E6470 
 15631      6F696E74 
 15631      20636F6E 
 15632 0a14 00       		.ascii	"\000"
 15633 0a15 000000   		.space	3
 15634              	.LC57:
 15635 0a18 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 15635      496E7465 
 15635      72727570 
 15635      74205374 
 15635      61747573 
 15636 0a4b 20436F64 		.ascii	" Code = %d\012\000"
 15636      65203D20 
 15636      25640A00 
 15637 0a57 00       		.space	1
 15638              	.LC58:
 15639 0a58 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 15639      65642074 
 15639      6F20616C 
 15639      6C6F6361 
 15639      7465206D 
 15640 0a8b 65720D0A 		.ascii	"er\015\012\000"
 15640      00
 15641              	.LC59:
 15642 0a90 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 15642      4368616E 
 15642      6E656C20 
 15642      43726561 
 15642      74696F6E 
 15643 0abe 0000     		.space	2
 15644              	.LC60:
 15645 0ac0 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 15645      436F6E6E 
 15645      65637420 
 15645      6661696C 
 15645      65642C20 
 15646 0ae5 000000   		.space	3
 15647              	.LC61:
 15648 0ae8 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 15648      74686520 
 15648      76696465 
 15648      6F206D6F 
 15648      64652066 
 15649 0b0a 0000     		.space	2
 15650              	.LC62:
 15651 0b0c 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 15651      4368616E 
 15651      6E656C20 
 15651      52657365 
 15651      74204661 
 15652 0b37 00       		.space	1
 15653              	.LC63:
 15654 0b38 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 15654      4368616E 
 15654      6E656C20 
 15654      53657420 
 15654      5472616E 
 15655 0b69 00       		.ascii	"\000"
 15656 0b6a 0000     		.space	2
 15657              	.LC64:
 15658 0b6c 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 15658      4368616E 
 15658      6E656C20 
 15658      53657420 
 15658      5472616E 
 15659 0b9d 0A00     		.ascii	"\012\000"
 15660 0b9f 00       		.space	1
 15661              	.LC65:
 15662 0ba0 0D0A2073 		.ascii	"\015\012 super gpif\000"
 15662      75706572 
 15662      20677069 
 15662      6600
 15663 0bae 0000     		.space	2
 15664              	.LC66:
 15665 0bb0 0D0A2068 		.ascii	"\015\012 high gpif\000"
 15665      69676820 
 15665      67706966 
 15665      00
 15666 0bbd 000000   		.space	3
 15667              	.LC67:
 15668 0bc0 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 15668      696E6720 
 15668      47504946 
 15668      20436F6E 
 15668      66696775 
 15669 0bf3 0A00     		.ascii	"\012\000"
 15670 0bf5 000000   		.space	3
 15671              	.LC68:
 15672 0bf8 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 15672      74696E67 
 15672      20475049 
 15672      46207374 
 15672      61746520 
 15673 0c2b 0D0A00   		.ascii	"\015\012\000"
 15674 0c2e 0000     		.space	2
 15675              	.LC69:
 15676 0c30 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 15676      73706565 
 15676      64203D20 
 15676      25642065 
 15676      76656E66 
 15677 0c60 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 15677      71756573 
 15677      74203D20 
 15677      30782578 
 15677      20775661 
 15678 0c90 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 15678      203D2030 
 15678      78257820 
 15678      6973666C 
 15678      61672030 
 15679 0caa 0000     		.space	2
 15680              	.LC70:
 15681 0cac 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 15681      64656661 
 15681      756C7420 
 15681      73657475 
 15681      70207265 
 15682              	.LC71:
 15683 0cd8 54686520 		.ascii	"The hyster command 0x%x 0x%x\015\012\000"
 15683      68797374 
 15683      65722063 
 15683      6F6D6D61 
 15683      6E642030 
 15684 0cf7 00       		.space	1
 15685              	.LC72:
 15686 0cf8 54686520 		.ascii	"The ctrlspd command 0x%x 0x%x\015\012\000"
 15686      6374726C 
 15686      73706420 
 15686      636F6D6D 
 15686      616E6420 
 15687              	.LC73:
 15688 0d18 54686520 		.ascii	"The edgeMode command 0x%x 0x%x\015\012\000"
 15688      65646765 
 15688      4D6F6465 
 15688      20636F6D 
 15688      6D616E64 
 15689 0d39 000000   		.space	3
 15690              	.LC74:
 15691 0d3c 54686520 		.ascii	"The edgegain command 0x%x 0x%x\015\012\000"
 15691      65646765 
 15691      6761696E 
 15691      20636F6D 
 15691      6D616E64 
 15692 0d5d 000000   		.space	3
 15693              	.LC75:
 15694 0d60 54686520 		.ascii	"The edge start/end command 0x%x 0x%x\015\012\000"
 15694      65646765 
 15694      20737461 
 15694      72742F65 
 15694      6E642063 
 15695 0d87 00       		.space	1
 15696              	.LC76:
 15697 0d88 54686520 		.ascii	"The 2DNR start/end command 0x%x 0x%x\015\012\000"
 15697      32444E52 
 15697      20737461 
 15697      72742F65 
 15697      6E642063 
 15698 0daf 00       		.space	1
 15699              	.LC77:
 15700 0db0 54686520 		.ascii	"The gamma command 0x%x 0x%x\015\012\000"
 15700      67616D6D 
 15700      6120636F 
 15700      6D6D616E 
 15700      64203078 
 15701 0dce 0000     		.space	2
 15702              	.LC78:
 15703 0dd0 54686520 		.ascii	"The AGC Max command 0x%x 0x%x\015\012\000"
 15703      41474320 
 15703      4D617820 
 15703      636F6D6D 
 15703      616E6420 
 15704              	.LC79:
 15705 0df0 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 15705      65642074 
 15705      6F207365 
 15705      6E642069 
 15705      6E746572 
 15706 0e21 0A00     		.ascii	"\012\000"
 15707 0e23 00       		.space	1
 15708              	.LC80:
 15709 0e24 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 15709      6F6D6D69 
 15709      74656F66 
 15709      20737461 
 15709      7465203D 
 15710              	.LC81:
 15711 0e3c 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 15711      6E656C20 
 15711      53657420 
 15711      57726170 
 15711      55702066 
 15712 0e69 000000   		.space	3
 15713              	.LC82:
 15714 0e6c 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 15714      69742045 
 15714      4F462066 
 15714      61696C65 
 15714      64210D0A 
 15715 0e81 000000   		.space	3
 15716              	.LC83:
 15717 0e84 49324363 		.ascii	"I2CcmdQue\000"
 15717      6D645175 
 15717      6500
 15718 0e8e 0000     		.space	2
 15719              	.LC84:
 15720 0e90 33303A55 		.ascii	"30:UVC App Thread\000"
 15720      56432041 
 15720      70702054 
 15720      68726561 
 15720      6400
 15721 0ea2 0000     		.space	2
 15722              	.LC85:
 15723 0ea4 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 15723      56432041 
 15723      70702045 
 15723      50302054 
 15723      68726561 
 15724 0eba 0000     		.space	2
 15725              	.LC86:
 15726 0ebc 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 15726      32432041 
 15726      70702043 
 15726      54524C20 
 15726      54687265 
 15727 0ed3 00       		.bss
 15728              		.align	2
 15729              		.set	.LANCHOR0,. + 0
 15732              	glFxUVCEvent:
 15733 0000 00000000 		.space	40
 15733      00000000 
 15733      00000000 
 15733      00000000 
 15733      00000000 
 15736              	glEp0Buffer:
 15737 0028 00000000 		.space	32
 15737      00000000 
 15737      00000000 
 15737      00000000 
 15737      00000000 
 15740              	usbSpeed:
 15741 0048 00       		.space	1
 15742 0049 000000   		.space	3
 15745              	glCommitCtrl:
 15746 004c 00000000 		.space	32
 15746      00000000 
 15746      00000000 
 15746      00000000 
 15746      00000000 
 15749              	is60Hz:
 15750 006c 00000000 		.space	4
 15753              	setRes:
 15754 0070 00       		.space	1
 15757              	setstilRes:
 15758 0071 00       		.space	1
 15761              	stiflag:
 15762 0072 00       		.space	1
 15763 0073 00       		.space	1
 15766              	fb:
 15767 0074 0000     		.space	2
 15770              	pb:
 15771 0076 0000     		.space	2
 15774              	pbc:
 15775 0078 0000     		.space	2
 15776 007a 0000     		.space	2
 15779              	hitFV:
 15780 007c 00000000 		.space	4
 15783              	prodCount:
 15784 0080 0000     		.space	2
 15787              	consCount:
 15788 0082 0000     		.space	2
 15791              	streamingStarted:
 15792 0084 00000000 		.space	4
 15795              	gpif_initialized:
 15796 0088 00000000 		.space	4
 15799              	isUsbConnected:
 15800 008c 00000000 		.space	4
 15803              	clearFeatureRqtReceived:
 15804 0090 00000000 		.space	4
 15807              	I2CCMDArry:
 15808 0094 00000000 		.space	12
 15808      00000000 
 15808      00000000 
 15811              	IMcount.8243:
 15812 00a0 00       		.space	1
 15813 00a1 000000   		.space	3
 15816              	uvcAppThread:
 15817 00a4 00000000 		.space	168
 15817      00000000 
 15817      00000000 
 15817      00000000 
 15817      00000000 
 15820              	uvcAppEP0Thread:
 15821 014c 00000000 		.space	168
 15821      00000000 
 15821      00000000 
 15821      00000000 
 15821      00000000 
 15824              	i2cAppThread:
 15825 01f4 00000000 		.space	168
 15825      00000000 
 15825      00000000 
 15825      00000000 
 15825      00000000 
 15828              	pbcpbak:
 15829 029c 0000     		.space	2
 15832              	pbcbak:
 15833 029e 0000     		.space	2
 15836              	pbbak:
 15837 02a0 0000     		.space	2
 15840              	fbbak:
 15841 02a2 0000     		.space	2
 15844              	testSnap:
 15845 02a4 00       		.space	1
 15846 02a5 000000   		.text
 15847              	.Letext0:
 15848              		.file 2 "c:\\program files (x86)\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\s
 15849              		.file 3 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15850              		.file 4 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyfx
 15851              		.file 5 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_p
 15852              		.file 6 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_a
 15853              		.file 7 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15854              		.file 8 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15855              		.file 9 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15856              		.file 10 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15857              		.file 11 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15858              		.file 12 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15859              		.file 13 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15860              		.file 14 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15861              		.file 15 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15862              		.file 16 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15863              		.file 17 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15864              		.file 18 "../sensor.h"
 15865              		.file 19 "../cmdqu.h"
 15866              		.file 20 "../uvc.h"
 15867              		.file 21 "../cyfxgpif2config.h"
 15868              		.file 22 "../cyfxgpif2config_usb2_720.h"
 15869              		.file 23 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:16     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:19     .text:00000000 I2CCmdCb
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:57     .text:00000030 $d
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:63     .text:0000003c $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:65     .text:0000003c UVCHandleVideoStreamingRqts
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:211    .text:00000190 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:218    .text:000001a0 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:404    .text:00000374 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:411    .text:00000384 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:742    .text:000006ec $d
                            *COM*:00000002 wValue
                            *COM*:00000001 bRequest
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:763    .text:00000734 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:766    .text:00000734 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:935    .text:00000894 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:941    .text:000008a4 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:1054   .text:00000974 $d
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:1065   .text:00000994 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:1068   .text:00000994 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:1303   .text:00000b24 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000e8 glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:1313   .text:00000b40 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:1315   .text:00000b40 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:1530   .text:00000cbc $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:1541   .text:00000ccc $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:1543   .text:00000ccc CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:1901   .text:00000f88 $d
                            *COM*:00000002 wLength
                            *COM*:00000002 wIndex
                            *COM*:00000001 bmReqType
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:1919   .text:00000fb4 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:1922   .text:00000fb4 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:2150   .text:000011b8 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:2158   .text:000011cc $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:2161   .text:000011cc setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:2229   .text:00001248 getShutCtrl
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:2254   .text:00001264 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:2267   .text:0000128c $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:2368   .text:00001364 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:2376   .text:00001378 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:2379   .text:00001378 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:2550   .text:000014dc $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:2578   .text:00001540 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:2664   .text:00001600 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:2682   .text:00001640 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:2804   .text:00001744 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:2817   .text:00001770 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:2876   .text:000017f0 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:2891   .text:00001820 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:4096   .text:00002314 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:4118   .text:00002360 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:4430   .text:00002658 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:4436   .text:00002668 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:4778   .text:000029d0 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:4925   .text:00002af8 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:4938   .text:00002b20 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:5354   .text:00002f50 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:5365   .text:00002f70 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:5635   .text:00003204 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:5647   .text:00003228 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:5650   .text:00003228 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:5951   .text:000034e4 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:5958   .text:000034f4 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:5961   .text:000034f4 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:6005   .text:00003538 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:6010   .text:00003540 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:6013   .text:00003540 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:6041   .text:0000355c $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:6045   .text:00003560 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:6048   .text:00003560 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:6833   .text:00003bdc $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:6839   .text:00003bec $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:7314   .text:00003fd4 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12131  .text:000065fc CyFxGpifCB
                            *COM*:000000ac glChHandleInterStat
                            *COM*:00000004 glInterStaBuffer
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:7373   .text:000040ac $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:7376   .text:000040ac UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:7445   .text:00004124 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:7453   .text:00004134 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:9236   .text:00005090 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:9274   .text:0000510c $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12118  .text:000065f0 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12128  .text:000065fc $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12163  .text:00006630 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12176  .text:0000665c $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12181  .text:0000666c $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12186  .text:0000667c $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12234  .text:000066d4 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12244  .text:000066e8 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12247  .text:000066e8 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12400  .text:00006830 $d
                            *COM*:00000038 cmdQuMux
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12417  .text.startup:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12420  .text.startup:00000000 main
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:13758  .data:000004ec glUVCHeader
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12777  .data:00000060 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12698  .data:0000001c glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12762  .data:00000054 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12668  .data:00000000 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12728  .data:00000038 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15791  .bss:00000084 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15803  .bss:00000090 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15740  .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15799  .bss:0000008c isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15828  .bss:0000029c pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15832  .bss:0000029e pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15836  .bss:000002a0 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15840  .bss:000002a2 fbbak
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15774  .bss:00000078 pbc
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15770  .bss:00000076 pb
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15766  .bss:00000074 fb
                            *COM*:00000038 timMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15844  .bss:000002a4 testSnap
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14410  .data:00000792 snapButFlag
                            *COM*:000000e8 glChHandleStillStream
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12652  .rodata:000001bc CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14921  .data:00000960 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15000  .data:00000a90 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15151  .data:00000b24 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15262  .data:00000cd4 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12639  .rodata:000001a0 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15273  .data:00000ce4 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15352  .data:00000e14 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15371  .data:00000e24 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15446  .data:00000f44 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12560  .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12564  .rodata:00000000 ShutSp
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12579  .rodata:00000020 pEXTSenCtrl
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:13978  .data:000005b0 EXTShutter
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14789  .data:000008e8 EXTSensUp
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14767  .data:000008d4 EXTMirror
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14745  .data:000008c0 EXT3DnoiseReduceMode
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14723  .data:000008ac EXT3DNoiseLev
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14701  .data:00000898 EXTDayNightMode
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14345  .data:00000758 EXTDayNightdely
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14679  .data:00000884 EXTDayNightlev
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14657  .data:00000870 EXTNightDaylev
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:13795  .data:0000050c EXTAexModGainlev
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14635  .data:0000085c EXTExpReflev
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14000  .data:000005c4 EXTShutlev
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14613  .data:00000848 EXTCamMode
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14591  .data:00000834 EXTSensorPare
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14569  .data:00000820 EXTI2Ccmd
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:13839  .data:00000534 EXTBLCWinPos
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14547  .data:0000080c EXTBLCWeight
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:13773  .data:000004f8 EXTBLCGrid
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14525  .data:000007f8 EXTExHyster
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:13817  .data:00000520 EXTExCtrlSped
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14503  .data:000007e4 EXTEnhanceMode
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14367  .data:0000076c EXTEnhanceGain
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14389  .data:00000780 EXTEnhanceSTED
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14481  .data:000007d0 EXT2DNRGain
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14459  .data:000007bc EXT2DNRSTED
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14437  .data:000007a8 EXTGammaCor
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14415  .data:00000794 EXTAGCMaxLimit
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12616  .rodata:00000120 pPUCSenCtrl
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:13956  .data:0000059c PUCBLC
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:13861  .data:00000548 PUCBright
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14899  .data:0000094c PUCContrast
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:13905  .data:00000570 PUCPLFreq
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:13883  .data:0000055c PUCHueC
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14877  .data:00000938 PUCSaturation
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:13934  .data:00000588 PUCSharp
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14855  .data:00000924 PUCWBMd
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14833  .data:00000910 PUCWBLC
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14811  .data:000008fc PUCDZoom
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12635  .rodata:00000160 curFlag
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12664  .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12757  .data:00000052 ROIMode
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:12792  .data:0000006c ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:13115  .data:000001ec CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:13927  .data:00000584 WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:14022  .data:000005d8 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15453  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15728  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15732  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15736  .bss:00000028 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15745  .bss:0000004c glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15749  .bss:0000006c is60Hz
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15753  .bss:00000070 setRes
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15757  .bss:00000071 setstilRes
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15761  .bss:00000072 stiflag
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15779  .bss:0000007c hitFV
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15783  .bss:00000080 prodCount
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15787  .bss:00000082 consCount
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15795  .bss:00000088 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15807  .bss:00000094 I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15811  .bss:000000a0 IMcount.8243
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15816  .bss:000000a4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15820  .bss:0000014c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccCBiJgF.s:15824  .bss:000001f4 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
CyU3PDebugPrint
_txe_event_flags_set
CyU3PUsbSendEP0Data
CyU3PUsbStall
CyU3PUsbGetEP0Data
SensorSetIrisControl
_tx_thread_sleep
_txe_timer_create
_tx_time_get
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
_txe_timer_change
SensorSetControl
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyFx3BusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbAckSetup
SensorWrite2B
SensorRead2B
SensorWrite2B2
cmdSet
SensorGetControl
memcpy
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PUsbGetSpeed
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PDmaMultiChannelSetWrapUp
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
