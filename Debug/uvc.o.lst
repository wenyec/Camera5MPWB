   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB25:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** 
  98:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
  99:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 100:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 101:../uvc.c      **** 
 102:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 103:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 104:../uvc.c      **** //uint16_t lineCount = 0; //res test
 105:../uvc.c      **** 
 106:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 107:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 108:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 109:../uvc.c      ****                                                            received. */
 110:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 111:../uvc.c      **** #ifdef BACKFLOW_DETECT
 112:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 113:../uvc.c      **** #endif
 114:../uvc.c      **** 
 115:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 116:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 117:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 118:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 119:../uvc.c      **** #endif
 120:../uvc.c      **** 
 121:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 122:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 123:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 124:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 126:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 127:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 128:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 129:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 130:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 131:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 132:../uvc.c      ****                                    with adjustable compression parameters */
 133:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 134:../uvc.c      ****                                    streaming with adjustable compression parameters */
 135:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 136:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 137:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 138:../uvc.c      **** };
 139:../uvc.c      **** 
 140:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 141:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 142:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 144:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 145:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 146:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 147:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 148:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 149:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 150:../uvc.c      ****                                    with adjustable compression parameters */
 151:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 152:../uvc.c      ****                                    streaming with adjustable compression parameters */
 153:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 154:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 155:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 156:../uvc.c      **** };
 157:../uvc.c      **** 
 158:../uvc.c      **** 
 159:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 160:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 161:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 162:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 163:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 164:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 165:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 166:../uvc.c      **** };
 167:../uvc.c      **** 
 168:../uvc.c      **** 
 169:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 170:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 171:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 172:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 174:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 175:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 176:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 177:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 178:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 179:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 180:../uvc.c      ****                                    with adjustable compression parameters */
 181:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 182:../uvc.c      ****                                    streaming with adjustable compression parameters */
 183:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 184:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 185:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 186:../uvc.c      **** };
 187:../uvc.c      **** 
 188:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 189:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 190:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 191:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 192:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 193:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 194:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 195:../uvc.c      **** };
 196:../uvc.c      **** 
 197:../uvc.c      **** 
 198:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 199:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 200:../uvc.c      **** 
 201:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 202:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 203:../uvc.c      **** {
 204:../uvc.c      ****     0x0C,                               /* Header Length */
 205:../uvc.c      ****     0x8C,                               /* Bit field header field */
 206:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 208:../uvc.c      **** };
 209:../uvc.c      **** 
 210:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 211:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 212:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 213:../uvc.c      ****                                                            the current video frame. */
 214:../uvc.c      **** volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 215:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 216:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 217:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 218:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 219:../uvc.c      **** 
 220:../uvc.c      **** /************ control parameters array ***********
 221:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 222:../uvc.c      ****  *    e.g.
 223:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 224:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 225:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 226:../uvc.c      ****  **************************************************/
 227:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 228:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 229:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 230:../uvc.c      **** 		{BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,
 231:../uvc.c      **** 		{0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 0, 3,
 232:../uvc.c      **** 		{ContrastReg         , ContrastReg          , 2,    0,    0,  255,    0, 1, 0, 3, 0, 112, 0, 112,
 233:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 234:../uvc.c      **** 		{MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,   1,
 235:../uvc.c      **** 		{HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,   0,
 236:../uvc.c      **** 		{SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,  50,
 237:../uvc.c      **** 		{SharpnessReg        , SharpnessReg         , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 238:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 239:../uvc.c      **** 		{WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 240:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,   0,
 241:../uvc.c      **** 		{ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,  32,
 242:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 243:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 244:../uvc.c      **** 		{DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,   0,
 245:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 246:../uvc.c      **** 		{ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0,   0,
 247:../uvc.c      **** 		{SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0,   1,
 248:../uvc.c      **** 		{MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   2,
 249:../uvc.c      **** 		{NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,   0,
 250:../uvc.c      **** 		{NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 251:../uvc.c      **** 		{DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0,
 252:../uvc.c      **** 		{DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0,   0,
 253:../uvc.c      **** 		{DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 254:../uvc.c      **** 		{NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 255:../uvc.c      **** 		{AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32,   0,
 256:../uvc.c      **** 		{AExReferleveReg     , AExReferleveReg      , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 257:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0,   0,
 258:../uvc.c      **** 		{SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0,   3,
 259:../uvc.c      **** 		{0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 260:../uvc.c      **** 		{SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 261:../uvc.c      **** 		/**********************************
 262:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 263:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 264:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 265:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 266:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 267:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 268:../uvc.c      **** 		 *
 269:../uvc.c      **** 		 *********************************/
 270:../uvc.c      **** 		{0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 0,   0
 271:../uvc.c      **** };
 272:../uvc.c      **** 
 273:../uvc.c      **** #ifndef CAM720
 274:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 275:../uvc.c      **** #else
 276:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 277:../uvc.c      **** #endif
 278:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
 279:../uvc.c      **** 
 280:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 281:../uvc.c      **** 		{0x13/*Ext1BLCRangeCtlID0 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0, 0x23
 282:../uvc.c      **** 		{0x11/*Ext1BLCWeightCtlID1*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,   1, 
 283:../uvc.c      **** 		{0x17/*Ext1BLCGridCtlID2*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0, 
 284:../uvc.c      **** 		{0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,0x4
 285:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,   0,
 286:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,   0,
 287:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,   0,
 288:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0xa,
 289:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,   0,
 290:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 291:../uvc.c      **** 		{0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0,   0,
 292:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 293:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 294:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 295:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 296:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 297:../uvc.c      **** };
 298:../uvc.c      **** 
 299:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 300:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 301:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 302:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 303:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 304:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 305:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 306:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 307:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 308:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 309:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 310:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 311:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 312:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 313:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 314:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 315:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 316:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 317:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 318:../uvc.c      **** };
 319:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 320:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 321:../uvc.c      **** /*
 322:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 323:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 324:../uvc.c      ****  */
 325:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 326:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 327:../uvc.c      **** };
 328:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 329:../uvc.c      **** 		0
 330:../uvc.c      **** };
 331:../uvc.c      **** 
 332:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 333:../uvc.c      **** 
 334:../uvc.c      **** void I2CCmdHandler(){
 335:../uvc.c      **** 	uint8_t buf[2];
 336:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 337:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 338:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 339:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 340:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 341:../uvc.c      **** 	uint8_t i;
 342:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 343:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 344:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 345:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 346:../uvc.c      **** 	{
 347:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 348:../uvc.c      **** 		if(is60Hz==CyFalse)
 349:../uvc.c      **** 			{
 350:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 351:../uvc.c      **** 			}
 352:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 353:../uvc.c      **** 
 354:../uvc.c      **** 	}
 355:../uvc.c      **** 	if(CmdType == 0)//I2C read
 356:../uvc.c      **** 	{
 357:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 358:../uvc.c      **** #if 0 //for debugging
 359:../uvc.c      **** 		/* test still image operation */
 360:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 361:../uvc.c      **** 			snapButFlag = 0; //press
 362:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 363:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 364:../uvc.c      **** 			snapButFlag = 0xf; //release
 365:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 366:../uvc.c      **** 		}
 367:../uvc.c      **** 
 368:../uvc.c      **** 		/* end of the test */
 369:../uvc.c      **** #endif
 370:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 371:../uvc.c      **** 			/*
 372:../uvc.c      **** 			if(CmdRegLen == 2){
 373:../uvc.c      **** 				SensorRead2B2(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|0x1, 0, I2CCMDArry[4], I2CCMDArry[9]);
 374:../uvc.c      **** 			}
 375:../uvc.c      **** 			else{
 376:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 377:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 378:../uvc.c      **** 				if(CmdDataLen == 2){
 379:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 380:../uvc.c      **** 				}
 381:../uvc.c      **** 			}*/
 382:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 383:../uvc.c      **** 		}else{//not support currently
 384:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 385:../uvc.c      **** 		}
 386:../uvc.c      **** 	}else if(CmdType == 1){
 387:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 388:../uvc.c      **** 			if(CmdRegLen == 2){
 389:../uvc.c      **** 				for(i = 0; i<4; i++)
 390:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 391:../uvc.c      **** 			}
 392:../uvc.c      **** 			else{
 393:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 394:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 395:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 396:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 397:../uvc.c      **** 				}
 398:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 399:../uvc.c      **** 			}
 400:../uvc.c      **** 		}else{//not support currently
 401:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 402:../uvc.c      **** 		}
 403:../uvc.c      **** 
 404:../uvc.c      **** 	}
 405:../uvc.c      **** }
 406:../uvc.c      **** 
 407:../uvc.c      **** /************************************
 408:../uvc.c      ****  * set Iris mode
 409:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 410:../uvc.c      ****  */
 411:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 412:../uvc.c      **** 	uint8_t dataIdx;
 413:../uvc.c      **** 	  dataIdx = 0;
 414:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 415:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 416:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 417:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 418:../uvc.c      **** }
 419:../uvc.c      **** 
 420:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 421:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 422:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 423:../uvc.c      ****     uint16_t readCount;
 424:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 425:../uvc.c      ****     uint8_t devAdd;
 426:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 427:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 428:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 429:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 430:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 431:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 432:../uvc.c      ****     }else{
 433:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 434:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 435:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 436:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 437:../uvc.c      ****     }
 438:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 439:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 440:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 441:../uvc.c      **** #endif
 442:../uvc.c      ****     reqData = bRequest;
 443:../uvc.c      ****     /*
 444:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 445:../uvc.c      ****      */
 446:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 447:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 448:../uvc.c      ****     	goto EndofSet;
 449:../uvc.c      ****     }
 450:../uvc.c      ****     switch (bRequest)
 451:../uvc.c      **** 		 {
 452:../uvc.c      **** 
 453:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 454:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 455:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 456:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 457:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 458:../uvc.c      **** 			  break;
 459:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 460:../uvc.c      **** 
 461:../uvc.c      **** 			 switch(CtrlID)
 462:../uvc.c      **** 			 {
 463:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 464:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID0:
 465:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID1:
 466:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID2:
 467:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 468:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 469:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 470:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 471:../uvc.c      **** 			 	 		 break;
 472:../uvc.c      **** 			 	 }
 473:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 474:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 475:../uvc.c      **** 					 if(CamMode == 1){//720p
 476:../uvc.c      **** 						if(sendData >= 3){
 477:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 478:../uvc.c      **** 							sendData = 0; //set back to default
 479:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 480:../uvc.c      **** 						}
 481:../uvc.c      **** 						sendData += 4;
 482:../uvc.c      **** 					 }
 483:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 484:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 485:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 486:../uvc.c      **** 					 break;
 487:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 488:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 489:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 490:../uvc.c      **** 			 		 }
 491:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 492:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 493:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 494:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 495:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 496:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 497:../uvc.c      **** #endif
 498:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 499:../uvc.c      **** 			 		 {
 500:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 501:../uvc.c      **** 			 		 }
 502:../uvc.c      **** 			 		 break;
 503:../uvc.c      **** 				 case ExtAexModCtlID9:
 504:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 505:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 506:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 507:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 508:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 509:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 510:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 511:../uvc.c      **** 					 break;
 512:../uvc.c      **** 
 513:../uvc.c      **** 			 	 case BrgtCtlID1:
 514:../uvc.c      **** 			 		 /* cancel for 5MP w/b camera
 515:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 516:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 517:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 518:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 519:../uvc.c      **** 					 }else{
 520:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 521:../uvc.c      **** 					 }
 522:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 523:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 524:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 525:../uvc.c      **** 					 */
 526:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 527:../uvc.c      **** 					  if(Data0&0x80){
 528:../uvc.c      **** 						  Data0 = ~Data0;
 529:../uvc.c      **** 					  }else{
 530:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 531:../uvc.c      **** 					  }
 532:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 533:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 534:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 535:../uvc.c      **** 			 		 break;
 536:../uvc.c      **** 				 case HueCtlID5:
 537:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 538:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 539:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 540:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 541:../uvc.c      **** 					 break;
 542:../uvc.c      **** 				 case WBTLevCtlID11:
 543:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 544:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 545:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 546:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 547:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 548:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 549:../uvc.c      **** 					 break;
 550:../uvc.c      **** 				 case SaturCtlID6:
 551:../uvc.c      **** 				 default:
 552:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 553:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 554:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 555:../uvc.c      **** 					 break;
 556:../uvc.c      **** 			 }
 557:../uvc.c      **** 
 558:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 559:../uvc.c      **** 
 560:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 561:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 562:../uvc.c      **** #endif
 563:../uvc.c      **** 			  break;
 564:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 565:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 566:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 567:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 568:../uvc.c      **** 		 	 }
 569:../uvc.c      **** 
 570:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 571:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 572:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 573:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 574:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 575:../uvc.c      **** 			 }else
 576:../uvc.c      **** 			 {
 577:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 578:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 579:../uvc.c      **** 			 }
 580:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 581:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 582:../uvc.c      **** 			  break;
 583:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 584:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 585:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 586:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 587:../uvc.c      **** 		 	 }
 588:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 589:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 590:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 591:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 592:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 593:../uvc.c      **** 			 }else
 594:../uvc.c      **** 			 {
 595:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 596:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 597:../uvc.c      **** 			 }
 598:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 599:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 600:../uvc.c      **** 			  break;
 601:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 602:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 603:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 604:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 605:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 606:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 607:../uvc.c      **** 		 	 }
 608:../uvc.c      **** 		 	 else{
 609:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 610:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 611:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 612:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 613:../uvc.c      **** 		 	 }
 614:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 615:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 616:../uvc.c      **** 			  break;
 617:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 618:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 619:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 620:../uvc.c      **** 		 	 }
 621:../uvc.c      **** 		 	 else{
 622:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 623:../uvc.c      **** 		 	 }
 624:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 625:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 626:../uvc.c      **** 			  Len = 1;
 627:../uvc.c      **** 			  break;
 628:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 629:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 630:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 631:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 632:../uvc.c      **** 		 	 }
 633:../uvc.c      **** 
 634:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 635:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 636:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 637:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 638:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 639:../uvc.c      **** 			 }else{
 640:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 641:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 642:../uvc.c      **** 			 }
 643:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 644:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 645:../uvc.c      **** 			  break;
 646:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 647:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 648:../uvc.c      **** 				  glEp0Buffer, &readCount);
 649:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 650:../uvc.c      **** 			   {
 651:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 652:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 653:../uvc.c      **** 				  getData = glEp0Buffer[0];
 654:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 655:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 656:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 657:../uvc.c      **** #endif
 658:../uvc.c      **** 				  switch(CtrlID)
 659:../uvc.c      **** 					 {
 660:../uvc.c      **** 						 case ExtShutCtlID0:
 661:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 662:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 663:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 664:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 665:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 666:../uvc.c      **** 									 }else{
 667:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 668:../uvc.c      **** 									 }
 669:../uvc.c      **** 								 }
 670:../uvc.c      **** 							 }else{
 671:../uvc.c      **** 								 Data1 = Data0 - 1;
 672:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 673:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 674:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 675:../uvc.c      **** 									 }else{
 676:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 677:../uvc.c      **** 									 }
 678:../uvc.c      **** 								 }
 679:../uvc.c      **** 								 if(Data1 < 8){
 680:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 681:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 682:../uvc.c      **** 								 }else{
 683:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 684:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 685:../uvc.c      **** 								 }
 686:../uvc.c      **** 							 }
 687:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 688:../uvc.c      **** 							 dataIdx = 0;
 689:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 690:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 691:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 692:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 693:../uvc.c      **** 							 break;
 694:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 695:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 696:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 697:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 698:../uvc.c      **** 							 dataIdx = 0;
 699:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 700:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 701:../uvc.c      **** 							 if(getData != 0){
 702:../uvc.c      **** 								 dataIdx++;
 703:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 704:../uvc.c      **** 							 }
 705:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 706:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 707:../uvc.c      **** 							 break;
 708:../uvc.c      **** 						 case ExtCamMCtlID12:
 709:../uvc.c      **** 							 dataIdx = 0;
 710:../uvc.c      **** 							 if(Data0 <= 3){
 711:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 712:../uvc.c      **** 								 Data1 = Data0;
 713:../uvc.c      **** 							 }else{
 714:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 715:../uvc.c      **** 								 Data1 = Data0-4;
 716:../uvc.c      **** 							 }
 717:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 718:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 719:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 720:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 721:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 722:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 723:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 724:../uvc.c      **** 							 break;
 725:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 726:../uvc.c      **** 							 dataIdx = 0;
 727:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
 728:../uvc.c      **** 								 Data0 = 1;
 729:../uvc.c      **** 							 }else{ //save current sensor parameters.
 730:../uvc.c      **** 								 Data0 = 0;
 731:../uvc.c      **** 							 }
 732:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 733:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 734:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 735:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 736:../uvc.c      **** 							 break;
 737:../uvc.c      **** 						 case ExtI2CCtlID15:
 738:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 739:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 740:../uvc.c      **** 					 		 }
 741:../uvc.c      **** 					 		I2CCmdHandler();
 742:../uvc.c      **** 							 break;
 743:../uvc.c      **** 						 case Ext1BLCRangeCtlID0: //registers value BLD window enable (0x17); position (0x13); size (
 744:../uvc.c      **** 							 dataIdx = 0;
 745:../uvc.c      **** #if 0 //seperate version
 746:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
 747:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
 748:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 749:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
 750:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
 751:../uvc.c      **** 							 }else{ //disable BLD window
 752:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
 753:../uvc.c      **** 							 }
 754:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
 755:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
 756:../uvc.c      **** 							 dataIdx++;
 757:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
 758:../uvc.c      **** 							 dataIdx++;
 759:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
 760:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
 761:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
 762:../uvc.c      **** 							 dataIdx++;
 763:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
 764:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 765:../uvc.c      **** #else //combination version
 766:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 767:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 768:../uvc.c      **** 						     /* end test */
 769:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 770:../uvc.c      **** 							 dataIdx++;
 771:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 772:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 773:../uvc.c      **** 							 getData1 = Data1;
 774:../uvc.c      **** #endif
 775:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 776:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 777:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 778:../uvc.c      **** 							 break;
 779:../uvc.c      **** 						 case Ext1BLCWeightCtlID1: //register value 0x11 (need check).
 780:../uvc.c      **** 							 dataIdx = 0;
 781:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 782:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 783:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 784:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 785:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 786:../uvc.c      **** 							 break;
 787:../uvc.c      **** 						 case Ext1BLCGridCtlID2:
 788:../uvc.c      **** 							 dataIdx = 0;
 789:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 790:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 791:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 792:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 793:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 794:../uvc.c      **** 							 break;
 795:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 796:../uvc.c      **** #if 0 //cancel for 5MP w/b camera
 797:../uvc.c      **** 							 dataIdx = 0;
 798:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 799:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 800:../uvc.c      **** 							  if(Data0&0x80){
 801:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 802:../uvc.c      **** 							  }else{
 803:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 804:../uvc.c      **** 							  }
 805:../uvc.c      **** 							 Data1 |= ~0x03;
 806:../uvc.c      **** 							 Data1 &= 0xC7;
 807:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 808:../uvc.c      **** 						  	 dataIdx++;
 809:../uvc.c      **** 
 810:../uvc.c      **** 							 Data0 = (Data0 << 2);
 811:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 812:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 813:../uvc.c      **** 
 814:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 815:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 816:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 817:../uvc.c      **** #endif
 818:../uvc.c      **** 							 dataIdx = 0;
 819:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 820:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 821:../uvc.c      **** 							  if(Data0&0x80){
 822:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 823:../uvc.c      **** 							  }else{
 824:../uvc.c      **** 								  Data0 = ~Data0;
 825:../uvc.c      **** 							  }
 826:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 827:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 828:../uvc.c      **** 
 829:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 830:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 831:../uvc.c      **** 
 832:../uvc.c      **** 
 833:../uvc.c      **** 							 break;
 834:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 835:../uvc.c      **** 							 dataIdx = 0;
 836:../uvc.c      **** 
 837:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 838:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 839:../uvc.c      **** 							 dataIdx++;
 840:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 841:../uvc.c      **** 							 dataIdx++;
 842:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 843:../uvc.c      **** 							 dataIdx++;
 844:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 845:../uvc.c      **** 							 dataIdx++;
 846:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 847:../uvc.c      **** 							 dataIdx++;
 848:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 849:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 850:../uvc.c      **** 
 851:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 852:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 853:../uvc.c      **** 							 break;
 854:../uvc.c      **** 						 case SaturCtlID6:
 855:../uvc.c      **** 							 dataIdx = 0;
 856:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
 857:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 858:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 859:../uvc.c      **** 							 dataIdx++;
 860:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 861:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 862:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 863:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 864:../uvc.c      **** 							 break;
 865:../uvc.c      **** 
 866:../uvc.c      **** 						 case WBTLevCtlID11:
 867:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
 868:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
 869:../uvc.c      **** 							 dataIdx = 0;
 870:../uvc.c      **** 
 871:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 872:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 873:../uvc.c      **** 							 dataIdx++;
 874:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 875:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 876:../uvc.c      **** 
 877:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 878:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 879:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 880:../uvc.c      **** 							 break;
 881:../uvc.c      **** 						 case MFreqCtlID4:
 882:../uvc.c      **** 							 dataIdx = 0;
 883:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 884:../uvc.c      **** 							 Data0 = Data0 - 1;
 885:../uvc.c      **** 							 is60Hz = Data0;
 886:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 887:../uvc.c      **** 							 {
 888:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
 889:../uvc.c      **** 								 is60Hz = CyFalse;
 890:../uvc.c      **** 							 }
 891:../uvc.c      **** 							 else if(Data0 >2)
 892:../uvc.c      **** 							 {
 893:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
 894:../uvc.c      **** 								 is60Hz = CyTrue;
 895:../uvc.c      **** 							 }
 896:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
 897:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 898:../uvc.c      **** 							 {
 899:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 900:../uvc.c      **** 			                       switch (setRes)
 901:../uvc.c      **** 			                         {
 902:../uvc.c      **** 			                         	case 1: //1944
 903:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 904:../uvc.c      **** 			                         		CyU3PThreadSleep(1000);
 905:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 906:../uvc.c      **** 			                         		break;
 907:../uvc.c      **** 			                         	case 2: //1080
 908:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 909:../uvc.c      **** 			                         		CyU3PThreadSleep(1000);
 910:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 911:../uvc.c      **** 			                         		break;
 912:../uvc.c      **** 			                         	case 3: //720
 913:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
 914:../uvc.c      **** 			                         		CyU3PThreadSleep(1000);
 915:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 916:../uvc.c      **** 			                         		break;
 917:../uvc.c      **** 			                         	default:
 918:../uvc.c      **** 			                         		break;
 919:../uvc.c      **** 			                         }
 920:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 921:../uvc.c      **** 							 }
 922:../uvc.c      **** 
 923:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 924:../uvc.c      **** 							 break;
 925:../uvc.c      **** 					 	 case BLCCtlID0:
 926:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 927:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 928:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 929:../uvc.c      **** 							 {
 930:../uvc.c      **** 								 if(Data0 < 3){
 931:../uvc.c      **** 					 				 Data0 += 4;
 932:../uvc.c      **** 					 			 }else{
 933:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 934:../uvc.c      **** 									Data0 = 4; //set to default.
 935:../uvc.c      **** 					 			 }
 936:../uvc.c      **** 					 		 }
 937:../uvc.c      **** 							 CtrlParArry[CamModeIndex][13] = Data0;
 938:../uvc.c      **** 							 dataIdx = 0;
 939:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 940:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 941:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 942:../uvc.c      **** 
 943:../uvc.c      **** 					 		 break;
 944:../uvc.c      **** 						 default:
 945:../uvc.c      **** 							 dataIdx = 0;
 946:../uvc.c      **** 
 947:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 948:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 949:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 950:../uvc.c      **** 
 951:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 952:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 953:../uvc.c      **** 							 break;
 954:../uvc.c      **** 					 }
 955:../uvc.c      **** 			   }else{
 956:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 957:../uvc.c      **** 			   }
 958:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 959:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
 960:../uvc.c      **** #endif
 961:../uvc.c      **** 
 962:../uvc.c      **** 			  break;
 963:../uvc.c      **** 		  default:
 964:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 965:../uvc.c      **** 			  break;
 966:../uvc.c      **** 		 }
 967:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 968:../uvc.c      **** }
 969:../uvc.c      **** /************** CT control requests handler *************************/
 970:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
 971:../uvc.c      **** 
 972:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 973:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 974:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 975:../uvc.c      ****     uint16_t readCount;
 976:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
 977:../uvc.c      ****     uint16_t diff, value, diffRd;
 978:../uvc.c      ****     uint8_t i, shutter, index;
 979:../uvc.c      ****     diff = 0xffff;
 980:../uvc.c      ****     shutter = 1;
 981:../uvc.c      ****     index = 1;
 982:../uvc.c      **** 
 983:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 984:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 985:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 986:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 987:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 988:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 989:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
 990:../uvc.c      **** #endif
 991:../uvc.c      ****     reqData = bRequest;
 992:../uvc.c      **** 
 993:../uvc.c      ****     switch (bRequest)
 994:../uvc.c      **** 		 {
 995:../uvc.c      **** 
 996:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 997:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 998:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 999:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1000:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1001:../uvc.c      **** 			  break;
1002:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1003:../uvc.c      **** 
1004:../uvc.c      **** 			 switch(CtrlID)
1005:../uvc.c      **** 			 {
1006:../uvc.c      **** 				 default:
1007:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
1008:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
1009:../uvc.c      **** 					 glEp0Buffer[2] = 0;
1010:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1011:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1012:../uvc.c      **** 					 break;
1013:../uvc.c      **** 			 }
1014:../uvc.c      **** 
1015:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1016:../uvc.c      **** 
1017:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1018:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
1019:../uvc.c      **** #endif
1020:../uvc.c      **** 			  break;
1021:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
1022:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
1023:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
1024:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
1025:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1026:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1027:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1028:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1029:../uvc.c      **** 			  break;
1030:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1031:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
1032:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
1033:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1034:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1035:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1036:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1037:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1038:../uvc.c      **** 			  break;
1039:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1040:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1041:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1042:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1043:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1044:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1045:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1046:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1047:../uvc.c      **** 			  break;
1048:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1049:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1050:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1051:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1052:../uvc.c      **** 			  Len = 1;
1053:../uvc.c      **** 			  break;
1054:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1055:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1056:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1057:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1058:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1059:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1060:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1061:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1062:../uvc.c      **** 			  break;
1063:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1064:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1065:../uvc.c      **** 			  glEp0Buffer, &readCount);
1066:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1067:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1068:../uvc.c      **** 			  value = Data1;
1069:../uvc.c      **** 
1070:../uvc.c      **** 			  switch(CtrlID)
1071:../uvc.c      **** 			  {
1072:../uvc.c      **** 		  	      case AutoExMCtlID1:
1073:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1074:../uvc.c      **** 
1075:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1076:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1077:../uvc.c      **** 				    getData = glEp0Buffer[0];
1078:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1079:../uvc.c      **** 		  		    switch (getData){
1080:../uvc.c      **** 						case 1:
1081:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1082:../uvc.c      **** 							break;
1083:../uvc.c      **** 						case 2:
1084:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1085:../uvc.c      **** 							dataIdx = 0;
1086:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1087:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1088:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1089:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1090:../uvc.c      **** 
1091:../uvc.c      **** 							break;
1092:../uvc.c      **** 						case 4:
1093:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1094:../uvc.c      **** 							break;
1095:../uvc.c      **** 						case 8:
1096:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1097:../uvc.c      **** 			  		    	dataIdx = 0;
1098:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1099:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1100:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1101:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1102:../uvc.c      **** 							break;
1103:../uvc.c      **** 		  		    }
1104:../uvc.c      **** #if 0
1105:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1106:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1107:../uvc.c      **** 						  dataIdx = 0;
1108:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1109:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1110:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1111:../uvc.c      **** 		  		    }
1112:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1113:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1114:../uvc.c      **** 		  		    }
1115:../uvc.c      **** #endif
1116:../uvc.c      **** 				    break;
1117:../uvc.c      **** 
1118:../uvc.c      **** 			  	  case ExTmACtlID3:
1119:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1120:../uvc.c      **** 
1121:../uvc.c      **** 					  value = (value << 8)|Data0;
1122:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1123:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1124:../uvc.c      **** 					  {
1125:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1126:../uvc.c      **** 						  {
1127:../uvc.c      **** 							if(value > ShutValueArry[i]){
1128:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1129:../uvc.c      **** 							}else{
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1131:../uvc.c      **** 							}
1132:../uvc.c      **** 							  if(diff > diffRd){
1133:../uvc.c      **** 								  diff = diffRd;
1134:../uvc.c      **** 								  index = i;
1135:../uvc.c      **** 							  }
1136:../uvc.c      **** 						  }
1137:../uvc.c      **** 						  shutter = shutter+index;
1138:../uvc.c      **** 
1139:../uvc.c      **** 						  dataIdx = 0;
1140:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1141:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1142:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1143:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1144:../uvc.c      **** 
1145:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1146:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1147:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1148:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1149:../uvc.c      **** 					  }else{
1150:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1151:../uvc.c      **** 					  }
1152:../uvc.c      **** 					  getData = glEp0Buffer[0];
1153:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1154:../uvc.c      **** 					  break;
1155:../uvc.c      **** 			  	  case IriACtlID7:
1156:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1157:../uvc.c      **** 					  {
1158:../uvc.c      **** 							 dataIdx = 0;
1159:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1160:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
1161:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1162:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1163:../uvc.c      **** 
1164:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1165:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1166:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1167:../uvc.c      **** 					  }else{
1168:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1169:../uvc.c      **** 					  }
1170:../uvc.c      **** 					  getData = glEp0Buffer[0];
1171:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1172:../uvc.c      **** 
1173:../uvc.c      **** 					  break;
1174:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1175:../uvc.c      **** 					  getData = glEp0Buffer[0];
1176:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1177:../uvc.c      **** #if 1
1178:../uvc.c      **** 					  dataIdx = 0;
1179:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1180:../uvc.c      **** 					  if(getData == 1)
1181:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1182:../uvc.c      **** 					  else if(getData == 0xff)
1183:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1184:../uvc.c      **** 					  else
1185:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
1186:../uvc.c      **** 					  //dataIdx++;
1187:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1188:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1189:../uvc.c      **** #endif
1190:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1191:../uvc.c      **** 					  break;
1192:../uvc.c      **** 
1193:../uvc.c      **** 			  	  default:
1194:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1195:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1196:../uvc.c      **** 			  		 break;
1197:../uvc.c      **** 			  }
1198:../uvc.c      **** 			  break;
1199:../uvc.c      **** 		  default:
1200:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1201:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1202:../uvc.c      **** 			  break;
1203:../uvc.c      **** 		 }
1204:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1205:../uvc.c      **** 
1206:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1207:../uvc.c      **** }
1208:../uvc.c      **** 
1209:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1210:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1211:../uvc.c      **** {
1212:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1213:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1214:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1215:../uvc.c      **** 
1216:../uvc.c      ****     CtrlID = BrgtCtlID1;
1217:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1218:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1219:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1220:../uvc.c      ****     Data1 = Data0;
1221:../uvc.c      **** 
1222:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1223:../uvc.c      ****     if(Data1&0x80){
1224:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1225:../uvc.c      ****     }else{
1226:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1227:../uvc.c      ****     }
1228:../uvc.c      ****     Data0 = (Data0 << 2);
1229:../uvc.c      **** 
1230:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1231:../uvc.c      **** 
1232:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1233:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1234:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1235:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1236:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1237:../uvc.c      **** 
1238:../uvc.c      ****     CtrlID = ConsCtlID2;
1239:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1240:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1241:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1242:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1243:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1244:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1245:../uvc.c      **** 
1246:../uvc.c      ****     CtrlID = HueCtlID5;
1247:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1248:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1249:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1250:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1251:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1252:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1253:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1254:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1255:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1256:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1257:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1258:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1259:../uvc.c      **** 
1260:../uvc.c      ****     CtrlID = SaturCtlID6;
1261:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1262:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1263:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1264:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1265:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1266:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1267:../uvc.c      **** 
1268:../uvc.c      ****     CtrlID = ShapCtlID7;
1269:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1270:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1271:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1272:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1273:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1274:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1275:../uvc.c      **** 
1276:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1277:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1278:../uvc.c      **** 	return;
1279:../uvc.c      **** }
1280:../uvc.c      **** 
1281:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1282:../uvc.c      **** void
1283:../uvc.c      **** CyFxUVCAddHeader (
1284:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1285:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1286:../uvc.c      ****         )
1287:../uvc.c      **** {
1288:../uvc.c      ****     /* Copy header to buffer */
1289:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1290:../uvc.c      **** 
1291:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1292:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1293:../uvc.c      ****     {
1294:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1295:../uvc.c      ****     }
1296:../uvc.c      **** }
1297:../uvc.c      **** 
1298:../uvc.c      **** 
1299:../uvc.c      **** /* Application Error Handler */
1300:../uvc.c      **** void
1301:../uvc.c      **** CyFxAppErrorHandler (
1302:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1303:../uvc.c      ****         )
1304:../uvc.c      **** {
1305:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1306:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1307:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1308:../uvc.c      **** 
1309:../uvc.c      ****        This function can be modified to take additional error handling actions such
1310:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1311:../uvc.c      ****      */
1312:../uvc.c      ****     for (;;)
1313:../uvc.c      ****     {
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
1316:../uvc.c      ****     }
1317:../uvc.c      **** }
1318:../uvc.c      **** 
1319:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1320:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1321:../uvc.c      ****  */
1322:../uvc.c      **** static void
1323:../uvc.c      **** CyFxUVCApplnAbortHandler (
1324:../uvc.c      ****         void)
1325:../uvc.c      **** {
1326:../uvc.c      **** 	uint32_t flag;
1327:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1328:../uvc.c      **** 	{
1329:../uvc.c      ****         /* Clear the Video Stream Request Event */
1330:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1331:../uvc.c      **** 
1332:../uvc.c      ****         /* Set Video Stream Abort Event */
1333:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1334:../uvc.c      **** 	}
1335:../uvc.c      **** }
1336:../uvc.c      **** 
1337:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1338:../uvc.c      **** static void
1339:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1340:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1341:../uvc.c      ****         uint16_t             evdata  /* Event data */
1342:../uvc.c      ****         )
1343:../uvc.c      **** {
1344:../uvc.c      ****     switch (evtype)
1345:../uvc.c      ****     {
1346:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1347:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1348:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1349:../uvc.c      ****             gpif_initialized = 0;
1350:../uvc.c      ****             streamingStarted = CyFalse;
1351:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1352:../uvc.c      ****             break;
1353:../uvc.c      **** 
1354:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1355:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1356:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1357:../uvc.c      ****             gpif_initialized = 0;
1358:../uvc.c      ****             streamingStarted = CyFalse;
1359:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1360:../uvc.c      ****             break;
1361:../uvc.c      **** 
1362:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1363:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1364:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1365:../uvc.c      ****             gpif_initialized = 0;
1366:../uvc.c      ****             isUsbConnected = CyFalse;
1367:../uvc.c      ****             streamingStarted = CyFalse;
1368:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1369:../uvc.c      ****             break;
1370:../uvc.c      **** 
1371:../uvc.c      **** #ifdef BACKFLOW_DETECT
1372:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1373:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1374:../uvc.c      ****             break;
1375:../uvc.c      **** #endif
1376:../uvc.c      **** 
1377:../uvc.c      ****         default:
1378:../uvc.c      ****             break;
1379:../uvc.c      ****     }
1380:../uvc.c      **** }
1381:../uvc.c      **** 
1382:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1383:../uvc.c      **** static CyBool_t
1384:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1385:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1386:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1387:../uvc.c      ****         )
1388:../uvc.c      **** {
1389:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1390:../uvc.c      ****     uint32_t status;
1391:../uvc.c      **** 
1392:../uvc.c      ****     /* Obtain Request Type and Request */
1393:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1394:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1395:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1396:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1397:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1398:../uvc.c      **** 
1399:../uvc.c      ****     /* Check for UVC Class Requests */
1400:../uvc.c      ****     switch (bmReqType)
1401:../uvc.c      ****     {
1402:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1403:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1404:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1405:../uvc.c      ****             switch (wIndex & 0xFF)
1406:../uvc.c      ****             {
1407:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1408:../uvc.c      ****                     {
1409:../uvc.c      ****                         uvcHandleReq = CyTrue;
1410:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1411:../uvc.c      ****                                 CYU3P_EVENT_OR);
1412:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1413:../uvc.c      ****                         {
1414:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1415:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1416:../uvc.c      ****                         }
1417:../uvc.c      ****                     }
1418:../uvc.c      ****                     break;
1419:../uvc.c      **** 
1420:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1421:../uvc.c      ****                     {
1422:../uvc.c      ****                         uvcHandleReq = CyTrue;
1423:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1424:../uvc.c      ****                                 CYU3P_EVENT_OR);
1425:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1426:../uvc.c      ****                         {
1427:../uvc.c      ****                             /* Error handling */
1428:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1429:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1430:../uvc.c      ****                         }
1431:../uvc.c      ****                     }
1432:../uvc.c      ****                     break;
1433:../uvc.c      **** 
1434:../uvc.c      ****                 default:
1435:../uvc.c      ****                     break;
1436:../uvc.c      ****             }
1437:../uvc.c      ****             break;
1438:../uvc.c      **** 
1439:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1440:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1441:../uvc.c      ****             {
1442:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1443:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1444:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1445:../uvc.c      ****                 {
1446:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1447:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1448:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1449:../uvc.c      ****                     gpif_initialized = 0;
1450:../uvc.c      ****                     streamingStarted = CyFalse;
1451:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1452:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1453:../uvc.c      ****                     CyU3PBusyWait (100);
1454:../uvc.c      **** 
1455:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1456:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1457:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1458:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1459:../uvc.c      ****                     CyU3PBusyWait (100);
1460:../uvc.c      **** 
1461:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1462:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1463:../uvc.c      ****                     uvcHandleReq = CyTrue;
1464:../uvc.c      ****                     /* Complete Control request handshake */
1465:../uvc.c      ****                     CyU3PUsbAckSetup ();
1466:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1467:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1468:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1469:../uvc.c      **** 
1470:../uvc.c      ****                 }
1471:../uvc.c      ****             }
1472:../uvc.c      ****             break;
1473:../uvc.c      **** 
1474:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1475:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1476:../uvc.c      ****             {
1477:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1478:../uvc.c      ****                 {
1479:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1480:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1481:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1482:../uvc.c      ****                 	 * has started. */
1483:../uvc.c      ****                     if (streamingStarted == CyTrue)
1484:../uvc.c      ****                     {
1485:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1486:../uvc.c      **** 
1487:../uvc.c      ****                         /* Disable the GPIF state machine. */
1488:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1489:../uvc.c      ****                         gpif_initialized = 0;
1490:../uvc.c      ****                         streamingStarted = CyFalse;
1491:../uvc.c      **** 
1492:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1493:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1494:../uvc.c      ****                         CyU3PBusyWait (100);
1495:../uvc.c      **** 
1496:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1497:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1498:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1499:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1500:../uvc.c      ****                         CyU3PBusyWait (100);
1501:../uvc.c      **** 
1502:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1503:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1504:../uvc.c      **** 
1505:../uvc.c      ****                         uvcHandleReq = CyTrue;
1506:../uvc.c      ****                         /* Complete Control request handshake */
1507:../uvc.c      ****                         CyU3PUsbAckSetup ();
1508:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1509:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1510:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1511:../uvc.c      ****                     }
1512:../uvc.c      ****                     else
1513:../uvc.c      ****                     {
1514:../uvc.c      ****                         uvcHandleReq = CyTrue;
1515:../uvc.c      ****                         CyU3PUsbAckSetup ();
1516:../uvc.c      ****                     }
1517:../uvc.c      ****                 }
1518:../uvc.c      ****             }
1519:../uvc.c      ****             break;
1520:../uvc.c      **** 
1521:../uvc.c      ****         default:
1522:../uvc.c      ****             break;
1523:../uvc.c      ****     }
1524:../uvc.c      **** 
1525:../uvc.c      ****     /* Return status of request handling to the USB driver */
1526:../uvc.c      ****     return uvcHandleReq;
1527:../uvc.c      **** }
1528:../uvc.c      **** 
1529:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1530:../uvc.c      **** 
1531:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1532:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1533:../uvc.c      ****  */
1534:../uvc.c      **** void
1535:../uvc.c      **** CyFxUvcApplnDmaCallback (
1536:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1537:../uvc.c      ****         CyU3PDmaCbType_t      type,
1538:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1539:../uvc.c      ****         )
1540:../uvc.c      **** {
1541:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1542:../uvc.c      **** #if 1
1543:../uvc.c      ****     CyU3PReturnStatus_t status;
1544:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
1545:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
1546:../uvc.c      **** 
1547:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1548:../uvc.c      ****     {
1549:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
1550:../uvc.c      ****             {
1551:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
1552:../uvc.c      ****                 fb++;
1553:../uvc.c      ****             }
1554:../uvc.c      ****             else
1555:../uvc.c      ****             {
1556:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1557:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1558:../uvc.c      ****                 pb++;
1559:../uvc.c      ****                 pbc = input->buffer_p.count;
1560:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
1561:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
1562:../uvc.c      ****                 //lineCount = 0; //res test
1563:../uvc.c      ****                hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been co
1564:../uvc.c      ****             }
1565:../uvc.c      **** 
1566:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1567:../uvc.c      ****             prodCount++;
1568:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1569:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1570:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
1571:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
1572:../uvc.c      ****             {
1573:../uvc.c      ****                 prodCount--;
1574:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
1575:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
1576:../uvc.c      ****             }
1577:../uvc.c      ****     }
1578:../uvc.c      **** #endif
1579:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1580:../uvc.c      ****     {
1581:../uvc.c      ****         consCount++;
1582:../uvc.c      ****         streamingStarted = CyTrue;
1583:../uvc.c      ****     }
1584:../uvc.c      **** }
1585:../uvc.c      **** 
1586:../uvc.c      **** /*
1587:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1588:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1589:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1590:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1591:../uvc.c      ****  * to commit the buffer.
1592:../uvc.c      ****  */
1593:../uvc.c      **** static uint8_t
1594:../uvc.c      **** CyFxUvcAppCommitEOF (
1595:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1596:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1597:../uvc.c      ****         )
1598:../uvc.c      **** {
1599:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1600:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1601:../uvc.c      **** 
1602:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1603:../uvc.c      **** 
1604:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1605:../uvc.c      ****     {
1606:../uvc.c      ****         switch (stateId)
1607:../uvc.c      ****         {
1608:../uvc.c      **** 
1609:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
1610:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1611:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1612:../uvc.c      ****                 break;
1613:../uvc.c      **** 
1614:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1615:../uvc.c      ****                 socket = 0;
1616:../uvc.c      ****                 break;
1617:../uvc.c      **** 
1618:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1619:../uvc.c      ****                 socket = 1;
1620:../uvc.c      ****                 break;
1621:../uvc.c      **** 
1622:../uvc.c      ****             default:
1623:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1624:../uvc.c      ****                 /* Unexpected current state. Return error. */
1625:../uvc.c      ****             	//lineCount++;
1626:../uvc.c      ****             	return 1;
1627:../uvc.c      ****         }
1628:../uvc.c      ****     }
1629:../uvc.c      **** 
1630:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1631:../uvc.c      ****     {
1632:../uvc.c      ****         switch (stateId)
1633:../uvc.c      ****         {
1634:../uvc.c      **** #ifndef CAM720
1635:../uvc.c      **** #ifdef GPIFIIM
1636:../uvc.c      ****             case 13:
1637:../uvc.c      ****             case 24:
1638:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1639:../uvc.c      ****                 break;
1640:../uvc.c      **** 
1641:../uvc.c      ****             case 8:
1642:../uvc.c      ****                 socket = 0;
1643:../uvc.c      ****                 break;
1644:../uvc.c      **** 
1645:../uvc.c      ****             case 20:
1646:../uvc.c      ****                 socket = 1;
1647:../uvc.c      ****                 break;
1648:../uvc.c      **** #else
1649:../uvc.c      ****             case 11:
1650:../uvc.c      ****             case 18:
1651:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1652:../uvc.c      ****                 break;
1653:../uvc.c      **** 
1654:../uvc.c      ****             case 8:
1655:../uvc.c      ****                 socket = 0;
1656:../uvc.c      ****                 break;
1657:../uvc.c      **** 
1658:../uvc.c      ****             case 15:
1659:../uvc.c      ****                 socket = 1;
1660:../uvc.c      ****                 break;
1661:../uvc.c      **** #endif
1662:../uvc.c      **** #else
1663:../uvc.c      ****             case 11:
1664:../uvc.c      ****             case 18:
1665:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1666:../uvc.c      ****                 break;
1667:../uvc.c      **** 
1668:../uvc.c      ****             case 8:
1669:../uvc.c      ****                 socket = 0;
1670:../uvc.c      ****                 break;
1671:../uvc.c      **** 
1672:../uvc.c      ****             case 15:
1673:../uvc.c      ****                 socket = 1;
1674:../uvc.c      ****                 break;
1675:../uvc.c      **** 
1676:../uvc.c      **** #endif
1677:../uvc.c      ****              default:
1678:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1679:../uvc.c      ****                 /* Unexpected current state. Return error. */
1680:../uvc.c      ****                return 1;
1681:../uvc.c      ****         }
1682:../uvc.c      ****     }
1683:../uvc.c      **** 
1684:../uvc.c      ****     if (socket != 0xFF)
1685:../uvc.c      ****     {
1686:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1687:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1688:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1689:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1690:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
1691:../uvc.c      ****         {
1692:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
1693:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
1694:../uvc.c      ****         }
1695:../uvc.c      ****     }
1696:../uvc.c      **** 
1697:../uvc.c      ****     return 0;
1698:../uvc.c      **** }
1699:../uvc.c      **** 
1700:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
1701:../uvc.c      **** void
1702:../uvc.c      **** CyFxGpifCB (
1703:../uvc.c      ****         CyU3PGpifEventType event,
1704:../uvc.c      ****         uint8_t currentState
1705:../uvc.c      ****         )
1706:../uvc.c      **** {
1707:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
1708:../uvc.c      ****     {
1709:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
1710:../uvc.c      ****     	           in the UVC implementation. */
1711:../uvc.c      ****     	//hitFV = CyTrue;
1712:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
1713:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
1714:../uvc.c      ****     }
1715:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
1716:../uvc.c      **** }
1717:../uvc.c      **** 
1718:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
1719:../uvc.c      **** static void
1720:../uvc.c      **** CyFxUVCApplnDebugInit (
1721:../uvc.c      ****         void)
1722:../uvc.c      **** {
1723:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
1724:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
1725:../uvc.c      **** 
1726:../uvc.c      ****     /* Initialize the UART for printing debug messages */
1727:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
1728:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1729:../uvc.c      ****     {
1730:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
1731:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1732:../uvc.c      ****     }
1733:../uvc.c      **** 
1734:../uvc.c      ****     /* Set UART Configuration */
1735:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1736:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1737:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1738:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1739:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1740:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1741:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1742:../uvc.c      **** 
1743:../uvc.c      ****     /* Set the UART configuration */
1744:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1745:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1746:../uvc.c      ****     {
1747:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1748:../uvc.c      ****     }
1749:../uvc.c      **** 
1750:../uvc.c      ****     /* Set the UART transfer */
1751:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
1752:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1753:../uvc.c      ****     {
1754:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1755:../uvc.c      ****     }
1756:../uvc.c      **** 
1757:../uvc.c      ****     /* Initialize the Debug logger module. */
1758:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
1759:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1760:../uvc.c      ****     {
1761:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1762:../uvc.c      ****     }
1763:../uvc.c      **** 
1764:../uvc.c      ****     /* Disable log message headers. */
1765:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
1766:../uvc.c      **** }
1767:../uvc.c      **** 
1768:../uvc.c      **** /* I2C initialization. */
1769:../uvc.c      **** static void
1770:../uvc.c      **** CyFxUVCApplnI2CInit (void)
1771:../uvc.c      **** {
1772:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
1773:../uvc.c      ****     CyU3PReturnStatus_t status;
1774:../uvc.c      **** 
1775:../uvc.c      ****     status = CyU3PI2cInit ();
1776:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
1777:../uvc.c      ****     {
1778:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
1779:../uvc.c      ****         CyFxAppErrorHandler (status);
1780:../uvc.c      ****     }
1781:../uvc.c      **** 
1782:../uvc.c      ****     /*  Set I2C Configuration */
1783:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
1784:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
1785:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
1786:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
1787:../uvc.c      **** 
1788:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
1789:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
1790:../uvc.c      ****     {
1791:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
1792:../uvc.c      ****         CyFxAppErrorHandler (status);
1793:../uvc.c      ****     }
1794:../uvc.c      **** }
1795:../uvc.c      **** 
1796:../uvc.c      **** #ifdef BACKFLOW_DETECT
1797:../uvc.c      **** static void CyFxUvcAppPibCallback (
1798:../uvc.c      ****         CyU3PPibIntrType cbType,
1799:../uvc.c      ****         uint16_t cbArg)
1800:../uvc.c      **** {
1801:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
1802:../uvc.c      ****     {
1803:../uvc.c      ****         if (!back_flow_detected)
1804:../uvc.c      ****         {
1805:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
1806:../uvc.c      ****             back_flow_detected = 1;
1807:../uvc.c      ****         }
1808:../uvc.c      ****     }
1809:../uvc.c      **** }
1810:../uvc.c      **** #endif
1811:../uvc.c      **** 
1812:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1813:../uvc.c      **** static void
1814:../uvc.c      **** CyFxUvcAppDebugCallback (
1815:../uvc.c      ****         CyU3PDmaChannel   *handle,
1816:../uvc.c      ****         CyU3PDmaCbType_t   type,
1817:../uvc.c      ****         CyU3PDmaCBInput_t *input)
1818:../uvc.c      **** {
1819:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1820:../uvc.c      ****     {
1821:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
1822:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
1823:../uvc.c      ****     }
1824:../uvc.c      **** }
1825:../uvc.c      **** #endif
1826:../uvc.c      **** 
1827:../uvc.c      **** #if 0
1828:../uvc.c      **** static void CyFxAppIntEpCb(
1829:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
1830:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
1831:../uvc.c      **** 		uint8_t  ebNum)
1832:../uvc.c      **** 		{
1833:../uvc.c      **** 			//CyBool_t value;
1834:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
1835:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
1836:../uvc.c      **** 
1837:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
1838:../uvc.c      **** 		}
1839:../uvc.c      **** #endif
1840:../uvc.c      **** 
1841:../uvc.c      **** /* This function initializes the USB Module, creates event group,
1842:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
1843:../uvc.c      ****    configures the DMA module for the UVC Application */
1844:../uvc.c      **** static void
1845:../uvc.c      **** CyFxUVCApplnInit (void)
1846:../uvc.c      **** {
1847:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
1848:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
1849:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
1850:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
1851:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
1852:../uvc.c      ****     CyU3PPibClock_t              pibclock;
1853:../uvc.c      **** 
1854:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
1855:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
1856:../uvc.c      **** 
1857:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1858:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
1859:../uvc.c      **** #endif
1860:../uvc.c      **** 
1861:../uvc.c      ****     /* Create UVC event group */
1862:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
1863:../uvc.c      ****     if (apiRetStatus != 0)
1864:../uvc.c      ****     {
1865:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
1866:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1867:../uvc.c      ****     }
1868:../uvc.c      **** 
1869:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
1870:../uvc.c      ****     CyFxUvcAppPTZInit ();
1871:../uvc.c      **** #endif
1872:../uvc.c      **** 
1873:../uvc.c      ****     isUsbConnected = CyFalse;
1874:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
1875:../uvc.c      **** 
1876:../uvc.c      ****     /* Init the GPIO module */
1877:../uvc.c      ****     gpioClock.fastClkDiv = 2;
1878:../uvc.c      ****     gpioClock.slowClkDiv = 2;
1879:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
1880:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
1881:../uvc.c      ****     gpioClock.halfDiv    = 0;
1882:../uvc.c      **** 
1883:../uvc.c      ****     /* Initialize Gpio interface */
1884:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
1885:../uvc.c      ****     if (apiRetStatus != 0)
1886:../uvc.c      ****     {
1887:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
1888:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1889:../uvc.c      ****     }
1890:../uvc.c      **** 
1891:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
1892:../uvc.c      ****      * must use GpioOverride to configure it */
1893:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
1894:../uvc.c      ****     if (apiRetStatus != 0)
1895:../uvc.c      ****     {
1896:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
1897:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1898:../uvc.c      ****     }
1899:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
1900:../uvc.c      ****     if (apiRetStatus != 0)
1901:../uvc.c      ****     {
1902:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
1903:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1904:../uvc.c      ****     }
1905:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
1906:../uvc.c      ****     if (apiRetStatus != 0)
1907:../uvc.c      ****     {
1908:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
1909:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1910:../uvc.c      ****     }
1911:../uvc.c      **** 
1912:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
1913:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1914:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1915:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1916:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1917:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1918:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
1919:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1920:../uvc.c      ****     {
1921:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
1922:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1923:../uvc.c      ****     }
1924:../uvc.c      **** 
1925:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
1926:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1927:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1928:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1929:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1930:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1931:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1932:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
1933:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1934:../uvc.c      ****     {
1935:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
1936:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1937:../uvc.c      ****     }
1938:../uvc.c      **** 
1939:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
1940:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1941:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
1942:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
1943:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
1944:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
1945:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1946:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
1947:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1948:../uvc.c      ****     {
1949:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
1950:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1951:../uvc.c      ****     }
1952:../uvc.c      **** 
1953:../uvc.c      ****     /* Initialize the P-port. */
1954:../uvc.c      ****     pibclock.clkDiv      = 2;
1955:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
1956:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
1957:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
1958:../uvc.c      **** 
1959:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
1960:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1961:../uvc.c      ****     {
1962:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1963:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1964:../uvc.c      ****     }
1965:../uvc.c      **** 
1966:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
1967:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
1968:../uvc.c      **** 
1969:../uvc.c      **** #ifdef BACKFLOW_DETECT
1970:../uvc.c      ****     back_flow_detected = 0;
1971:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
1972:../uvc.c      **** #endif
1973:../uvc.c      **** 
1974:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
1975:../uvc.c      ****     SensorReset ();
1976:../uvc.c      ****     CyU3PThreadSleep(5000);
1977:../uvc.c      ****     //SensorInit ();
1978:../uvc.c      **** 
1979:../uvc.c      ****     /* USB initialization. */
1980:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
1981:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1982:../uvc.c      ****     {
1983:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1984:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1985:../uvc.c      ****     }
1986:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
1987:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
1988:../uvc.c      **** 
1989:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
1990:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
1991:../uvc.c      **** 
1992:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
1993:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
1994:../uvc.c      **** 
1995:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
1996:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
1997:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
1998:../uvc.c      **** 
1999:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
2000:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
2001:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
2002:../uvc.c      **** 
2003:../uvc.c      ****     /* Configuration descriptors. */
2004:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
2005:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
2006:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
2007:../uvc.c      **** 
2008:../uvc.c      ****     /* String Descriptors */
2009:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
2010:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
2011:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
2012:../uvc.c      **** 
2013:../uvc.c      ****     /* Configure the status interrupt endpoint.
2014:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
2015:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
2016:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
2017:../uvc.c      ****      */
2018:../uvc.c      ****     endPointConfig.enable   = 1;
2019:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
2020:../uvc.c      ****     endPointConfig.pcktSize = 64;
2021:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2022:../uvc.c      ****     endPointConfig.streams  = 0;
2023:../uvc.c      ****     endPointConfig.burstLen = 1;
2024:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
2025:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2026:../uvc.c      ****     {
2027:../uvc.c      ****         /* Error Handling */
2028:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2029:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2030:../uvc.c      ****     }
2031:../uvc.c      **** 
2032:../uvc.c      ****     /* create a DMA for interrupt endpoint */
2033:../uvc.c      ****     dmaInterConfig.size           = 1024;
2034:../uvc.c      ****     dmaInterConfig.count          = 1;
2035:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2036:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
2037:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
2038:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
2039:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
2040:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2041:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2042:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2043:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2044:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2045:../uvc.c      ****             &dmaInterConfig);
2046:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2047:../uvc.c      ****     {
2048:../uvc.c      ****         /* Error handling */
2049:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2050:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2051:../uvc.c      ****     }
2052:../uvc.c      **** 
2053:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2054:../uvc.c      ****     if (glInterStaBuffer == 0)
2055:../uvc.c      ****     {
2056:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2057:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2058:../uvc.c      ****     }
2059:../uvc.c      **** 
2060:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2061:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2062:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2063:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2064:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2065:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2066:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2067:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2068:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2069:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2070:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2071:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2072:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2073:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2074:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2075:../uvc.c      ****             &dmaMultiConfig);
2076:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2077:../uvc.c      ****     {
2078:../uvc.c      ****         /* Error handling */
2079:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2080:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2081:../uvc.c      ****     }
2082:../uvc.c      **** 
2083:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2084:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2085:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2086:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2087:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2088:../uvc.c      ****      */
2089:../uvc.c      **** 
2090:../uvc.c      ****     endPointConfig.enable   = 1;
2091:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2092:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2093:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2094:../uvc.c      ****     endPointConfig.streams  = 0;
2095:../uvc.c      ****     endPointConfig.burstLen = 1;
2096:../uvc.c      **** 
2097:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2098:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2099:../uvc.c      ****     {
2100:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2101:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2102:../uvc.c      ****     }
2103:../uvc.c      **** 
2104:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2105:../uvc.c      **** 
2106:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2107:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2108:../uvc.c      ****     {
2109:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2110:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2111:../uvc.c      ****     }
2112:../uvc.c      **** 
2113:../uvc.c      ****     channelConfig.size           = 1024;
2114:../uvc.c      ****     channelConfig.count          = 1;
2115:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2116:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2117:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2118:../uvc.c      ****     channelConfig.prodHeader     = 0;
2119:../uvc.c      ****     channelConfig.prodFooter     = 0;
2120:../uvc.c      ****     channelConfig.consHeader     = 0;
2121:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2122:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2123:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2124:../uvc.c      **** 
2125:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2126:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2127:../uvc.c      ****     {
2128:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2129:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2130:../uvc.c      ****     }
2131:../uvc.c      **** 
2132:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2133:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2134:../uvc.c      ****     {
2135:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2136:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2137:../uvc.c      ****     }
2138:../uvc.c      **** 
2139:../uvc.c      ****     channelConfig.size           = 1024;
2140:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2141:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2142:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2143:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2144:../uvc.c      ****     channelConfig.prodHeader     = 0;
2145:../uvc.c      ****     channelConfig.prodFooter     = 0;
2146:../uvc.c      ****     channelConfig.consHeader     = 0;
2147:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2148:../uvc.c      ****     channelConfig.notification   = 0;
2149:../uvc.c      ****     channelConfig.cb             = 0;
2150:../uvc.c      **** 
2151:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2152:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2153:../uvc.c      ****     {
2154:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2155:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2156:../uvc.c      ****     }
2157:../uvc.c      **** 
2158:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2159:../uvc.c      ****     if (glDebugRspBuffer == 0)
2160:../uvc.c      ****     {
2161:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2162:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2163:../uvc.c      ****     }
2164:../uvc.c      **** #endif
2165:../uvc.c      **** 
2166:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2167:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2168:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2169:../uvc.c      ****     {
2170:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2171:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2172:../uvc.c      ****     }
2173:../uvc.c      **** 
2174:../uvc.c      ****     CyU3PBusyWait(100);
2175:../uvc.c      **** 
2176:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2177:../uvc.c      **** 
2178:../uvc.c      ****     endPointConfig.enable   = 1;
2179:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2180:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2181:../uvc.c      ****     {
2182:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2183:../uvc.c      ****     	endPointConfig.burstLen = 16;
2184:../uvc.c      ****     }
2185:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2186:../uvc.c      ****     {
2187:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2188:../uvc.c      ****     	endPointConfig.burstLen = 1;
2189:../uvc.c      ****     }
2190:../uvc.c      ****     endPointConfig.streams  = 0;
2191:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2192:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2193:../uvc.c      ****     {
2194:../uvc.c      ****         /* Error Handling */
2195:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2196:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2197:../uvc.c      ****     }
2198:../uvc.c      **** #if 0    //for still image method 3 using
2199:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2200:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2201:../uvc.c      ****     {
2202:../uvc.c      ****         /* Error Handling */
2203:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2204:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2205:../uvc.c      ****     }
2206:../uvc.c      **** #endif
2207:../uvc.c      **** 
2208:../uvc.c      **** }
2209:../uvc.c      **** 
2210:../uvc.c      **** /*
2211:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2212:../uvc.c      ****  * streaming session is started.
2213:../uvc.c      ****  */
2214:../uvc.c      **** static void
2215:../uvc.c      **** CyFxUvcAppGpifInit (
2216:../uvc.c      ****         void)
2217:../uvc.c      **** {
2218:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2219:../uvc.c      **** 
2220:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2221:../uvc.c      ****     {
2222:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2223:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2224:../uvc.c      ****     }
2225:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2226:../uvc.c      ****     {
2227:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2228:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2229:../uvc.c      ****     }
2230:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2231:../uvc.c      ****     {
2232:../uvc.c      ****         /* Error Handling */
2233:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2234:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2235:../uvc.c      ****     }
2236:../uvc.c      **** 
2237:../uvc.c      ****     /* Start the state machine from the designated start state. */
2238:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2239:../uvc.c      ****     {
2240:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2241:../uvc.c      ****     }
2242:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2243:../uvc.c      ****     {
2244:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2245:../uvc.c      ****     }
2246:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2247:../uvc.c      ****     {
2248:../uvc.c      ****         /* Error Handling */
2249:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2250:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2251:../uvc.c      ****     }
2252:../uvc.c      **** }
2253:../uvc.c      **** 
2254:../uvc.c      **** /*
2255:../uvc.c      ****  * Entry function for the UVC Application Thread
2256:../uvc.c      ****  */
2257:../uvc.c      **** 
2258:../uvc.c      **** uint32_t posTick;
2259:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2260:../uvc.c      **** 
2261:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2262:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2263:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2264:../uvc.c      **** }
2265:../uvc.c      **** 
2266:../uvc.c      **** 
2267:../uvc.c      **** void
2268:../uvc.c      **** UVCAppThread_Entry (
2269:../uvc.c      ****         uint32_t input)
2270:../uvc.c      **** {
2271:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2272:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2273:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2274:../uvc.c      ****     uint8_t i = 0;
2275:../uvc.c      ****     uint32_t flag;
2276:../uvc.c      ****     uint32_t prinflag = 0;
2277:../uvc.c      **** 
2278:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2279:../uvc.c      ****     uint32_t frameCnt = 0;
2280:../uvc.c      **** #endif
2281:../uvc.c      ****     /* Initialize the Uart Debug Module */
2282:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2283:../uvc.c      **** 
2284:../uvc.c      ****     /* Initialize the I2C interface */
2285:../uvc.c      **** 	while (i++ < 6){
2286:../uvc.c      **** 		CyU3PThreadSleep(500);
2287:../uvc.c      **** 	}
2288:../uvc.c      **** 
2289:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2290:../uvc.c      **** 
2291:../uvc.c      ****     /* Initialize the UVC Application */
2292:../uvc.c      ****     CyFxUVCApplnInit ();
2293:../uvc.c      ****     /*
2294:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2295:../uvc.c      **** 
2296:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2297:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2298:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2299:../uvc.c      **** 
2300:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2301:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2302:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2303:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2304:../uvc.c      **** 
2305:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2306:../uvc.c      ****        of handling the abort request.
2307:../uvc.c      ****      */
2308:../uvc.c      **** 
2309:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
2310:../uvc.c      ****     //CyU3PThreadSleep(1000);
2311:../uvc.c      **** 
2312:../uvc.c      ****     for (;;)
2313:../uvc.c      ****     {
2314:../uvc.c      ****         /* Waiting for the Video Stream Event */
2315:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2316:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2317:../uvc.c      ****         {
2318:../uvc.c      **** #if 0 //test for new firmware no video bring up
2319:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2320:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2321:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2322:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2323:../uvc.c      ****             {
2324:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2325:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2326:../uvc.c      ****                 {
2327:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2328:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2329:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2330:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2331:../uvc.c      **** #endif
2332:../uvc.c      **** #endif
2333:../uvc.c      ****                     }
2334:../uvc.c      ****                 else
2335:../uvc.c      ****                 {
2336:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2337:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2338:../uvc.c      **** #ifdef USB_LOWRES_IMG
2339:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2340:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2341:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2342:../uvc.c      **** #endif
2343:../uvc.c      **** #endif
2344:../uvc.c      ****                 }
2345:../uvc.c      **** 
2346:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2347:../uvc.c      ****                 prodCount++;
2348:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2349:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2350:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2351:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2352:../uvc.c      ****                 {
2353:../uvc.c      ****                     prodCount--;
2354:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2355:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2356:../uvc.c      ****                 }
2357:../uvc.c      ****             }
2358:../uvc.c      **** #endif
2359:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2360:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2361:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2362:../uvc.c      ****             {
2363:../uvc.c      ****             	if(0&&(prinflag == 0)){
2364:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2365:../uvc.c      ****             		prinflag = 1;
2366:../uvc.c      ****             	}
2367:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2368:../uvc.c      ****             	fb=0;
2369:../uvc.c      ****             	pb=0;
2370:../uvc.c      ****             	pbc=0;
2371:../uvc.c      ****                 prodCount = 0;
2372:../uvc.c      ****                 consCount = 0;
2373:../uvc.c      ****                 hitFV     = CyFalse;
2374:../uvc.c      **** 
2375:../uvc.c      **** #ifdef BACKFLOW_DETECT
2376:../uvc.c      ****                 back_flow_detected = 0;
2377:../uvc.c      **** #endif
2378:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2379:../uvc.c      ****                 frameCnt++;
2380:../uvc.c      **** #endif
2381:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2382:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2383:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2384:../uvc.c      ****                 //}
2385:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2386:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2387:../uvc.c      ****                 if(stiflag){
2388:../uvc.c      ****                 	if (CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3P_EVENT_AND_CLEAR, &fl
2389:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){
2390:../uvc.c      ****                 		glUVCHeader[1] |= (1<<5);    //set still image flag
2391:../uvc.c      ****                 		stiflag = CyFalse;
2392:../uvc.c      ****                 	}
2393:../uvc.c      ****                 }else{
2394:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2395:../uvc.c      ****                 }
2396:../uvc.c      ****                 /* Reset the DMA channel. */
2397:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2398:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2399:../uvc.c      ****                 {
2400:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2401:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2402:../uvc.c      ****                 }
2403:../uvc.c      **** 
2404:../uvc.c      ****                 /* Start Channel Immediately */
2405:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2406:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2407:../uvc.c      ****                 {
2408:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2409:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2410:../uvc.c      ****                 }
2411:../uvc.c      **** 
2412:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2413:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2414:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2415:../uvc.c      ****                 }
2416:../uvc.c      ****         }
2417:../uvc.c      ****         else
2418:../uvc.c      ****         {
2419:../uvc.c      ****             /* If we have a stream abort request pending. */
2420:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2421:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2422:../uvc.c      ****             {
2423:../uvc.c      ****                 hitFV     = CyFalse;
2424:../uvc.c      ****                 prodCount = 0;
2425:../uvc.c      ****                 consCount = 0;
2426:../uvc.c      ****                 if(0&&(prinflag == 0)){
2427:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2428:../uvc.c      ****                 	prinflag = 1;
2429:../uvc.c      ****                 }
2430:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2431:../uvc.c      ****                 fb=0;
2432:../uvc.c      ****                 pb=0;
2433:../uvc.c      ****                 pbc=0;
2434:../uvc.c      **** 
2435:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2436:../uvc.c      ****                 {
2437:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2438:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2439:../uvc.c      ****                     {
2440:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2441:../uvc.c      ****                     }
2442:../uvc.c      **** 
2443:../uvc.c      ****                     /* Flush the Endpoint memory */
2444:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2445:../uvc.c      ****                 }
2446:../uvc.c      **** 
2447:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2448:../uvc.c      ****             }
2449:../uvc.c      ****             else
2450:../uvc.c      ****             {
2451:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2452:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2453:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2454:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2455:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2456:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2457:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2458:../uvc.c      ****                 {
2459:../uvc.c      ****                     /* Error handling */
2460:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2461:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2462:../uvc.c      ****                 }
2463:../uvc.c      **** 
2464:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2465:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2466:../uvc.c      ****                 {
2467:../uvc.c      **** #if 0
2468:../uvc.c      ****                 	//for start up of the AF Lens
2469:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2470:../uvc.c      ****                     CyU3PThreadSleep(500);
2471:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2472:../uvc.c      ****                     CyU3PThreadSleep(500);
2473:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2474:../uvc.c      ****                    	CyU3PThreadSleep(300);
2475:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2476:../uvc.c      ****                     CyU3PThreadSleep(500);
2477:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2478:../uvc.c      ****                     CyU3PThreadSleep(500);
2479:../uvc.c      **** #endif
2480:../uvc.c      **** #if 0
2481:../uvc.c      ****                     switch (setRes)
2482:../uvc.c      ****                     {
2483:../uvc.c      ****                     	case 1: //1944
2484:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x64, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
2485:../uvc.c      ****                     		CyU3PThreadSleep(1000);
2486:../uvc.c      ****                     		break;
2487:../uvc.c      ****                     	case 2: //1080
2488:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x54, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
2489:../uvc.c      ****                     		CyU3PThreadSleep(1000);
2490:../uvc.c      ****                     		break;
2491:../uvc.c      ****                     	case 3: //720
2492:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x45, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
2493:../uvc.c      ****                     		CyU3PThreadSleep(1000);
2494:../uvc.c      ****                     		break;
2495:../uvc.c      ****                     	default:
2496:../uvc.c      ****                     		break;
2497:../uvc.c      ****                     }
2498:../uvc.c      **** #endif
2499:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2500:../uvc.c      **** 
2501:../uvc.c      ****                     gpif_initialized = CyTrue;
2502:../uvc.c      ****                     CyU3PThreadSleep(200);
2503:../uvc.c      ****                     
2504:../uvc.c      ****                 }
2505:../uvc.c      ****                 else
2506:../uvc.c      ****                 {
2507:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2508:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2509:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2510:../uvc.c      ****                 }
2511:../uvc.c      ****             }
2512:../uvc.c      ****         }
2513:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2514:../uvc.c      **** 
2515:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2516:../uvc.c      ****         CyU3PThreadRelinquish ();
2517:../uvc.c      ****     }
2518:../uvc.c      **** }
2519:../uvc.c      **** 
2520:../uvc.c      **** /*
2521:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2522:../uvc.c      ****  */
2523:../uvc.c      **** 
2524:../uvc.c      **** static void
2525:../uvc.c      **** UVCHandleProcessingUnitRqts (
2526:../uvc.c      ****         void)
2527:../uvc.c      **** {
2528:../uvc.c      ****     uint8_t CtrlAdd;
2529:../uvc.c      **** #ifdef DbgInfo
2530:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2531:../uvc.c      **** #endif
2532:../uvc.c      ****     switch (wValue)
2533:../uvc.c      ****     {
2534:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2535:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2536:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2537:../uvc.c      ****     		break;
2538:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2539:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
2540:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
2541:../uvc.c      ****     		break;
2542:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2543:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2544:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2545:../uvc.c      **** 			break;
2546:../uvc.c      **** 
2547:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2548:../uvc.c      **** 
2549:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2550:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2551:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2552:../uvc.c      ****       		break;
2553:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2554:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2555:../uvc.c      ****      		ControlHandle(HueCtlID5);
2556:../uvc.c      ****      		break;
2557:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2558:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2559:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2560:../uvc.c      ****           		break;
2561:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2562:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2563:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2564:../uvc.c      ****           		break;
2565:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2566:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2567:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2568:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2569:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2570:../uvc.c      ****     		break;
2571:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2572:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2573:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2574:../uvc.c      ****     		break;
2575:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2576:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2577:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2578:../uvc.c      ****     		break;
2579:../uvc.c      **** 
2580:../uvc.c      ****         default:
2581:../uvc.c      ****             /*
2582:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2583:../uvc.c      ****              * other controls.
2584:../uvc.c      ****              */
2585:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2586:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2587:../uvc.c      ****             break;
2588:../uvc.c      ****     }
2589:../uvc.c      **** }
2590:../uvc.c      **** 
2591:../uvc.c      **** /*
2592:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2593:../uvc.c      ****  */
2594:../uvc.c      **** static void
2595:../uvc.c      **** UVCHandleCameraTerminalRqts (
2596:../uvc.c      ****         void)
2597:../uvc.c      **** {
2598:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2599:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2600:../uvc.c      ****     uint16_t readCount;
2601:../uvc.c      ****     uint16_t zoomVal;
2602:../uvc.c      ****     int32_t  panVal, tiltVal;
2603:../uvc.c      ****     CyBool_t sendData = CyFalse;
2604:../uvc.c      **** #endif
2605:../uvc.c      ****     uint8_t CtrlAdd;
2606:../uvc.c      **** 
2607:../uvc.c      ****     switch (wValue)
2608:../uvc.c      ****     {
2609:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2610:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2611:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2612:../uvc.c      ****     		break;
2613:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2614:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2615:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2616:../uvc.c      ****     		break;
2617:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2618:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2619:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2620:../uvc.c      **** 			break;
2621:../uvc.c      **** 
2622:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2623:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2624:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2625:../uvc.c      **** 			break;
2626:../uvc.c      **** 
2627:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2628:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2629:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2630:../uvc.c      ****       		break;
2631:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2632:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2633:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2634:../uvc.c      ****      		break;
2635:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2636:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2637:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2638:../uvc.c      ****           		break;
2639:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2640:../uvc.c      ****           		break;
2641:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2642:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
2643:../uvc.c      ****      		CTControlHandle(IriACtlID7);
2644:../uvc.c      ****      		break;
2645:../uvc.c      **** 
2646:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
2647:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
2648:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
2649:../uvc.c      ****     		break;
2650:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2651:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
2652:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
2653:../uvc.c      ****     		break;
2654:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
2655:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
2656:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
2657:../uvc.c      ****     		break;
2658:../uvc.c      **** 
2659:../uvc.c      ****         default:
2660:../uvc.c      ****             /*
2661:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2662:../uvc.c      ****              * other controls.
2663:../uvc.c      ****              */
2664:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2665:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2666:../uvc.c      ****             break;
2667:../uvc.c      ****     }
2668:../uvc.c      **** 
2669:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2670:../uvc.c      ****     switch (wValue)
2671:../uvc.c      ****     {
2672:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2673:../uvc.c      ****             switch (bRequest)
2674:../uvc.c      ****             {
2675:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2676:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
2677:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2678:../uvc.c      ****                     break;
2679:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
2680:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
2681:../uvc.c      ****                     sendData = CyTrue;
2682:../uvc.c      ****                     break;
2683:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
2684:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
2685:../uvc.c      ****                     sendData = CyTrue;
2686:../uvc.c      ****                     break;
2687:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
2688:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
2689:../uvc.c      ****                     sendData = CyTrue;
2690:../uvc.c      ****                     break;
2691:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
2692:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
2693:../uvc.c      ****                     sendData = CyTrue;
2694:../uvc.c      ****                     break;
2695:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
2696:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
2697:../uvc.c      ****                     sendData = CyTrue;
2698:../uvc.c      ****                     break;
2699:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2700:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2701:../uvc.c      ****                             glEp0Buffer, &readCount);
2702:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2703:../uvc.c      ****                     {
2704:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
2705:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
2706:../uvc.c      ****                     }
2707:../uvc.c      ****                     break;
2708:../uvc.c      ****                 default:
2709:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2710:../uvc.c      ****                     break;
2711:../uvc.c      ****             }
2712:../uvc.c      **** 
2713:../uvc.c      ****             if (sendData)
2714:../uvc.c      ****             {
2715:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
2716:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
2717:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
2718:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2719:../uvc.c      ****             }
2720:../uvc.c      ****             break;
2721:../uvc.c      **** 
2722:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
2723:../uvc.c      ****             switch (bRequest)
2724:../uvc.c      ****             {
2725:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2726:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
2727:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2728:../uvc.c      ****                     break;
2729:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2730:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
2731:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
2732:../uvc.c      ****                     sendData = CyTrue;
2733:../uvc.c      ****                     break;
2734:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2735:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
2736:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
2737:../uvc.c      ****                     sendData = CyTrue;
2738:../uvc.c      ****                     break;
2739:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2740:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
2741:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
2742:../uvc.c      ****                     sendData = CyTrue;
2743:../uvc.c      ****                     break;
2744:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
2745:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
2746:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
2747:../uvc.c      ****                     sendData = CyTrue;
2748:../uvc.c      ****                     break;
2749:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
2750:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
2751:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
2752:../uvc.c      ****                     sendData = CyTrue;
2753:../uvc.c      ****                     break;
2754:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2755:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2756:../uvc.c      ****                             glEp0Buffer, &readCount);
2757:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2758:../uvc.c      ****                     {
2759:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
2760:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
2761:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
2762:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
2763:../uvc.c      **** 
2764:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
2765:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
2766:../uvc.c      ****                     }
2767:../uvc.c      ****                     break;
2768:../uvc.c      ****                 default:
2769:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2770:../uvc.c      ****                     break;
2771:../uvc.c      ****             }
2772:../uvc.c      **** 
2773:../uvc.c      ****             if (sendData)
2774:../uvc.c      ****             {
2775:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
2776:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
2777:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
2778:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
2779:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
2780:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
2781:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
2782:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
2783:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
2784:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2785:../uvc.c      ****             }
2786:../uvc.c      ****             break;
2787:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
2788:../uvc.c      ****         default:
2789:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
2790:../uvc.c      ****             break;
2791:../uvc.c      ****     }
2792:../uvc.c      **** #endif
2793:../uvc.c      **** }
2794:../uvc.c      **** 
2795:../uvc.c      **** /*
2796:../uvc.c      ****  * Handler for UVC Interface control requests.
2797:../uvc.c      ****  */
2798:../uvc.c      **** static void
2799:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
2800:../uvc.c      ****         void)
2801:../uvc.c      **** {
2802:../uvc.c      **** 
2803:../uvc.c      ****     switch (wValue)
2804:../uvc.c      ****     {
2805:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
2806:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2807:../uvc.c      ****     		break;
2808:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
2809:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
2810:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
2811:../uvc.c      ****     		break;
2812:../uvc.c      ****     	default:
2813:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
2814:../uvc.c      ****      		break;
2815:../uvc.c      ****     }
2816:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
2817:../uvc.c      **** 
2818:../uvc.c      **** }
2819:../uvc.c      **** 
2820:../uvc.c      **** /*
2821:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
2822:../uvc.c      ****  */
2823:../uvc.c      **** static void
2824:../uvc.c      **** UVCHandleExtensionUnitRqts (
2825:../uvc.c      ****         void)
2826:../uvc.c      **** {
2827:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
2828:../uvc.c      **** 
2829:../uvc.c      **** #ifdef DbgInfo
2830:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2831:../uvc.c      **** #endif
2832:../uvc.c      ****     switch (wValue)
2833:../uvc.c      ****     {
2834:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
2835:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
2836:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
2837:../uvc.c      ****     		break;
2838:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
2839:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
2840:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
2841:../uvc.c      ****     		break;
2842:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
2843:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
2844:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
2845:../uvc.c      ****      		break;
2846:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
2847:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
2848:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
2849:../uvc.c      ****     		break;
2850:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
2851:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
2852:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
2853:../uvc.c      ****     		break;
2854:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
2855:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
2856:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
2857:../uvc.c      ****      		break;
2858:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
2859:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
2860:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
2861:../uvc.c      ****     		break;
2862:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
2863:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
2864:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
2865:../uvc.c      ****     		break;
2866:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
2867:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
2868:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
2869:../uvc.c      ****      		break;
2870:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
2871:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
2872:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
2873:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
2874:../uvc.c      ****     		}else/* no support for 1080p camera */
2875:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
2876:../uvc.c      ****     		break;
2877:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
2878:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
2879:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
2880:../uvc.c      ****     		break;
2881:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
2882:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
2883:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
2884:../uvc.c      ****     		break;
2885:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
2886:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
2887:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
2888:../uvc.c      ****     		//break;
2889:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
2890:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
2891:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
2892:../uvc.c      ****     		break;
2893:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
2894:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
2895:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
2896:../uvc.c      ****     		break;
2897:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
2898:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID0-EXUAOFFSET][0];
2899:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
2900:../uvc.c      ****     		break;
2901:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
2902:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID1-EXUAOFFSET][0];
2903:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
2904:../uvc.c      ****     		break;
2905:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
2906:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID2-EXUAOFFSET][0];
2907:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
2908:../uvc.c      ****     		break;
2909:../uvc.c      ****    	default:
2910:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
2911:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2912:../uvc.c      ****     		break;
2913:../uvc.c      ****     }
2914:../uvc.c      **** 
2915:../uvc.c      **** }
2916:../uvc.c      **** 
2917:../uvc.c      **** /*
2918:../uvc.c      ****  * Handler for the video streaming control requests.
2919:../uvc.c      ****  */
2920:../uvc.c      **** static void
2921:../uvc.c      **** UVCHandleVideoStreamingRqts (
2922:../uvc.c      ****         void)
2923:../uvc.c      **** {
2924:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2925:../uvc.c      ****     uint16_t readCount;
2926:../uvc.c      **** 
2927:../uvc.c      ****     switch (wValue)
2928:../uvc.c      ****     {
2929:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
2930:../uvc.c      ****             switch (bRequest)
2931:../uvc.c      ****             {
2932:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2933:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2934:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2935:../uvc.c      ****                     break;
2936:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2937:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2938:../uvc.c      ****                     glEp0Buffer[1] = 0;
2939:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2940:../uvc.c      ****                     break;
2941:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2942:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2943:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2944:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2945:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
2946:../uvc.c      ****                     {
2947:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
2948:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
2949:../uvc.c      **** 
2950:../uvc.c      ****                     }
2951:../uvc.c      ****                     else
2952:../uvc.c      ****                     {
2953:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2954:../uvc.c      ****                     }
2955:../uvc.c      ****                     break;
2956:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2957:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2958:../uvc.c      ****                             glCommitCtrl, &readCount);
2959:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2960:../uvc.c      ****                     {
2961:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2962:../uvc.c      ****                         {
2963:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
2964:../uvc.c      ****                                active data structure. */
2965:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
2966:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
2967:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
2968:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
2969:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
2970:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
2971:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
2972:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
2973:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
2974:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
2975:../uvc.c      **** #if 0
2976:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
2977:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
2978:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
2979:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
2980:../uvc.c      **** #endif
2981:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
2982:../uvc.c      ****                        }
2983:../uvc.c      ****                     }
2984:../uvc.c      ****                     break;
2985:../uvc.c      ****                 default:
2986:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2987:../uvc.c      ****                     break;
2988:../uvc.c      ****             }
2989:../uvc.c      ****             break;
2990:../uvc.c      **** 
2991:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
2992:../uvc.c      ****             switch (bRequest)
2993:../uvc.c      ****             {
2994:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2995:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
2996:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2997:../uvc.c      ****                     break;
2998:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2999:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3000:../uvc.c      ****                     glEp0Buffer[1] = 0;
3001:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3002:../uvc.c      ****                     break;
3003:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3004:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3005:../uvc.c      ****                     {
3006:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
3007:../uvc.c      ****                     }
3008:../uvc.c      ****                     else
3009:../uvc.c      ****                     {
3010:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3011:../uvc.c      ****                     }
3012:../uvc.c      ****                     break;
3013:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3014:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
3015:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
3016:../uvc.c      ****                        */
3017:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3018:../uvc.c      ****                             glCommitCtrl, &readCount);
3019:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3020:../uvc.c      ****                     {
3021:../uvc.c      ****                         switch (glCommitCtrl[3])
3022:../uvc.c      ****                          {
3023:../uvc.c      ****                          	case 1: //1944
3024:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
3025:../uvc.c      ****                          		CyU3PThreadSleep(1000);
3026:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3027:../uvc.c      ****                          		break;
3028:../uvc.c      ****                          	case 2: //1080
3029:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
3030:../uvc.c      ****                          		CyU3PThreadSleep(1000);
3031:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3032:../uvc.c      ****                          		break;
3033:../uvc.c      ****                          	case 3: //720
3034:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
3035:../uvc.c      ****                          		CyU3PThreadSleep(1000);
3036:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3037:../uvc.c      ****                          		break;
3038:../uvc.c      ****                          	default:
3039:../uvc.c      ****                          		break;
3040:../uvc.c      ****                          }
3041:../uvc.c      ****                         setRes = glCommitCtrl[3];
3042:../uvc.c      **** #if 0
3043:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
3044:../uvc.c      ****                         {
3045:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
3046:../uvc.c      ****                         }
3047:../uvc.c      ****                         else
3048:../uvc.c      ****                         {
3049:../uvc.c      ****                             SensorScaling_VGA ();
3050:../uvc.c      ****                         }
3051:../uvc.c      **** #endif
3052:../uvc.c      ****                         /* We can start streaming video now. */
3053:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
3054:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
3055:../uvc.c      ****                         {
3056:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
3057:../uvc.c      ****                         }
3058:../uvc.c      ****                     }
3059:../uvc.c      ****                     break;
3060:../uvc.c      **** 
3061:../uvc.c      ****                 default:
3062:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3063:../uvc.c      ****                     break;
3064:../uvc.c      ****             }
3065:../uvc.c      ****             break;
3066:../uvc.c      **** 
3067:../uvc.c      **** /* still image streaming handler */
3068:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
3069:../uvc.c      ****                 switch (bRequest)
3070:../uvc.c      ****                 {
3071:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3072:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3073:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3074:../uvc.c      ****                         break;
3075:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3076:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3077:../uvc.c      ****                         glEp0Buffer[1] = 0;
3078:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3079:../uvc.c      ****                         break;
3080:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3081:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3082:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3083:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3084:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3085:../uvc.c      ****                         {
3086:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3087:../uvc.c      ****                         }
3088:../uvc.c      ****                         else
3089:../uvc.c      ****                         {
3090:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3091:../uvc.c      ****                         }
3092:../uvc.c      ****                         break;
3093:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3094:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3095:../uvc.c      ****                                 glCommitCtrl, &readCount);
3096:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3097:../uvc.c      ****                         {
3098:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
3099:../uvc.c      ****                             {
3100:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
3101:../uvc.c      ****                                    active data structure. */
3102:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3103:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3104:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
3105:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
3106:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
3107:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
3108:../uvc.c      ****                             }
3109:../uvc.c      ****                         }
3110:../uvc.c      ****                         break;
3111:../uvc.c      ****                     default:
3112:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3113:../uvc.c      ****                         break;
3114:../uvc.c      ****                 }
3115:../uvc.c      ****                 break;
3116:../uvc.c      **** 
3117:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
3118:../uvc.c      ****                 switch (bRequest)
3119:../uvc.c      ****                 {
3120:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3121:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3122:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3123:../uvc.c      ****                         break;
3124:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3125:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3126:../uvc.c      ****                         glEp0Buffer[1] = 0;
3127:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3128:../uvc.c      ****                         break;
3129:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3130:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3131:../uvc.c      ****                         {
3132:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3133:../uvc.c      ****                         }
3134:../uvc.c      ****                         else
3135:../uvc.c      ****                         {
3136:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3137:../uvc.c      ****                         }
3138:../uvc.c      ****                         break;
3139:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3140:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3141:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3142:../uvc.c      ****                            */
3143:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3144:../uvc.c      ****                                 glCommitCtrl, &readCount);
3145:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3146:../uvc.c      ****                         {
3147:../uvc.c      ****     #if 0
3148:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3149:../uvc.c      ****                             {
3150:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3151:../uvc.c      ****                             }
3152:../uvc.c      ****                             else
3153:../uvc.c      ****                             {
3154:../uvc.c      ****                                 SensorScaling_VGA ();
3155:../uvc.c      ****                             }
3156:../uvc.c      ****     #endif
3157:../uvc.c      ****                             /* We can start streaming video now. */
3158:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3159:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3160:../uvc.c      ****                             {
3161:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3162:../uvc.c      ****                             }
3163:../uvc.c      ****                         }
3164:../uvc.c      ****                         break;
3165:../uvc.c      **** 
3166:../uvc.c      ****                     default:
3167:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3168:../uvc.c      ****                         break;
3169:../uvc.c      ****                 }
3170:../uvc.c      ****                 break;
3171:../uvc.c      **** 
3172:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3173:../uvc.c      ****                 switch (bRequest)
3174:../uvc.c      ****                 {
3175:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3176:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3177:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3178:../uvc.c      ****                         break;
3179:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3180:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3181:../uvc.c      ****                         glEp0Buffer[1] = 0;
3182:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3183:../uvc.c      ****                         break;
3184:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3185:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3186:../uvc.c      ****                         {
3187:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3188:../uvc.c      ****                         }
3189:../uvc.c      ****                         else
3190:../uvc.c      ****                         {
3191:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3192:../uvc.c      ****                         }
3193:../uvc.c      ****                         break;
3194:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3195:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3196:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3197:../uvc.c      ****                            */
3198:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3199:../uvc.c      ****                                 glCommitCtrl, &readCount);
3200:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3201:../uvc.c      ****                         {
3202:../uvc.c      ****     #if 1
3203:../uvc.c      ****                             /* We can start still streaming video now. */
3204:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3205:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3206:../uvc.c      ****                             {
3207:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3208:../uvc.c      ****                             }
3209:../uvc.c      ****     #endif
3210:../uvc.c      ****                             stiflag = CyTrue;//set still flag
3211:../uvc.c      ****                             //stillcont = 0;
3212:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
3213:../uvc.c      ****                         }else{
3214:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3215:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3216:../uvc.c      ****                         }
3217:../uvc.c      ****                         break;
3218:../uvc.c      **** 
3219:../uvc.c      ****                     default:
3220:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3221:../uvc.c      ****                         break;
3222:../uvc.c      ****                 }
3223:../uvc.c      ****                 break;
3224:../uvc.c      **** 
3225:../uvc.c      ****         default:
3226:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3227:../uvc.c      ****             break;
3228:../uvc.c      ****     }
3229:../uvc.c      **** }
3230:../uvc.c      **** 
3231:../uvc.c      **** /*
3232:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3233:../uvc.c      ****  */
3234:../uvc.c      **** void
3235:../uvc.c      **** UVCAppEP0Thread_Entry (
3236:../uvc.c      ****         uint32_t input)
3237:../uvc.c      **** {
3238:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3239:../uvc.c      ****     uint32_t eventFlag;
3240:../uvc.c      **** 	CyBool_t value;
3241:../uvc.c      **** 	CyBool_t *valueptr = &value;
3242:../uvc.c      **** 
3243:../uvc.c      **** 
3244:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3245:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3246:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3247:../uvc.c      **** 
3248:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3249:../uvc.c      **** #endif
3250:../uvc.c      **** 
3251:../uvc.c      ****     /* for interrupt status test */
3252:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3253:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3254:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3255:../uvc.c      **** 
3256:../uvc.c      ****     for (;;)
3257:../uvc.c      ****     {
3258:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3259:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3260:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3261:../uvc.c      ****         {
3262:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3263:../uvc.c      ****             if (!isUsbConnected)
3264:../uvc.c      ****             {
3265:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3266:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3267:../uvc.c      ****                 {
3268:../uvc.c      ****                     isUsbConnected = CyTrue;
3269:../uvc.c      ****                 }
3270:../uvc.c      ****             }
3271:../uvc.c      **** //#ifdef DbgInfo
3272:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3273:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3274:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3275:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3276:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3277:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3278:../uvc.c      **** //#endif
3279:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3280:../uvc.c      ****             {
3281:../uvc.c      ****             	switch ((wIndex >> 8))
3282:../uvc.c      ****                 {
3283:../uvc.c      **** 
3284:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3285:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3286:../uvc.c      ****                         break;
3287:../uvc.c      **** 
3288:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3289:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3290:../uvc.c      ****                         break;
3291:../uvc.c      **** 
3292:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3293:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3294:../uvc.c      ****                         break;
3295:../uvc.c      **** 
3296:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3297:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3298:../uvc.c      ****                         break;
3299:../uvc.c      **** 
3300:../uvc.c      ****                     default:
3301:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3302:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3303:../uvc.c      ****                         break;
3304:../uvc.c      ****                 }
3305:../uvc.c      ****             }
3306:../uvc.c      **** 
3307:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3308:../uvc.c      ****             {
3309:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3310:../uvc.c      **** 
3311:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3312:../uvc.c      ****                 {
3313:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3314:../uvc.c      ****                 }
3315:../uvc.c      ****                 else
3316:../uvc.c      ****                 {
3317:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3318:../uvc.c      ****                 }
3319:../uvc.c      ****             }
3320:../uvc.c      **** 
3321:../uvc.c      ****             /* handle interrupt status event */
3322:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3323:../uvc.c      ****             {
3324:../uvc.c      **** 
3325:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3326:../uvc.c      ****             	/** preparing interrupt status data **/
3327:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3328:../uvc.c      **** 
3329:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3330:../uvc.c      **** 
3331:../uvc.c      **** #if 1 //for real button
3332:../uvc.c      **** 				if(value&&(!snapButFlag)){
3333:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3334:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3335:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3336:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3337:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3338:../uvc.c      **** 
3339:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3340:../uvc.c      **** 					interStabuf.size   = 1024;
3341:../uvc.c      **** 					interStabuf.status = 0;
3342:../uvc.c      **** 
3343:../uvc.c      **** 					interStabuf.count = 4;
3344:../uvc.c      **** 
3345:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3346:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3347:../uvc.c      **** 
3348:../uvc.c      **** 					/** send a interrupt status data **/
3349:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3350:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3351:../uvc.c      **** 					{
3352:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3353:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3354:../uvc.c      **** 					}
3355:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3356:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3357:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3358:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3359:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3360:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3361:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3362:../uvc.c      **** 
3363:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3364:../uvc.c      **** 					interStabuf.size   = 1024;
3365:../uvc.c      **** 					interStabuf.status = 0;
3366:../uvc.c      **** 
3367:../uvc.c      **** 					interStabuf.count = 4;
3368:../uvc.c      **** 
3369:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3370:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3371:../uvc.c      **** 
3372:../uvc.c      **** 					/** send a interrupt status data **/
3373:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3374:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3375:../uvc.c      **** 					{
3376:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3377:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3378:../uvc.c      **** 					}
3379:../uvc.c      **** 
3380:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3381:../uvc.c      **** 					stiflag = CyTrue;
3382:../uvc.c      **** 				}
3383:../uvc.c      **** #else			//for botton simulation
3384:../uvc.c      **** 				if(snapButFlag == 0x0f){
3385:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3386:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3387:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3388:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3389:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3390:../uvc.c      **** 
3391:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3392:../uvc.c      **** 					interStabuf.size   = 1024;
3393:../uvc.c      **** 					interStabuf.status = 0;
3394:../uvc.c      **** 
3395:../uvc.c      **** 					interStabuf.count = 4;
3396:../uvc.c      **** 
3397:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3398:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3399:../uvc.c      **** 
3400:../uvc.c      **** 					/** send a interrupt status data **/
3401:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3402:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3403:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3404:../uvc.c      **** 					{
3405:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3406:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3407:../uvc.c      **** 					}
3408:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3409:../uvc.c      **** 
3410:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3411:../uvc.c      **** 				}else if(!snapButFlag){
3412:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3413:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3414:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3415:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3416:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3417:../uvc.c      **** 
3418:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3419:../uvc.c      **** 					interStabuf.size   = 1024;
3420:../uvc.c      **** 					interStabuf.status = 0;
3421:../uvc.c      **** 
3422:../uvc.c      **** 					interStabuf.count = 4;
3423:../uvc.c      **** 
3424:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3425:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3426:../uvc.c      **** 
3427:../uvc.c      **** 					/** send a interrupt status data **/
3428:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3429:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3430:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3431:../uvc.c      **** 					{
3432:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3433:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3434:../uvc.c      **** 					}
3435:../uvc.c      **** 
3436:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3437:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3438:../uvc.c      **** 				}
3439:../uvc.c      **** #endif
3440:../uvc.c      **** 
3441:../uvc.c      ****             }
3442:../uvc.c      **** 
3443:../uvc.c      **** 
3444:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3445:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3446:../uvc.c      ****             {
3447:../uvc.c      ****                 /* Get the command buffer */
3448:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3449:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3450:../uvc.c      ****                 {
3451:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3452:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3453:../uvc.c      ****                 }
3454:../uvc.c      **** 
3455:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3456:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3457:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3458:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3459:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3460:../uvc.c      ****                  * register value high byte and register value low byte.
3461:../uvc.c      ****                  */
3462:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3463:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3464:../uvc.c      ****                 {
3465:../uvc.c      ****                     if (dmaInfo.count == 3)
3466:../uvc.c      ****                     {
3467:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3468:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3469:../uvc.c      ****                         dmaInfo.count = 3;
3470:../uvc.c      ****                     }
3471:../uvc.c      ****                     else if (dmaInfo.count == 4)
3472:../uvc.c      ****                     {
3473:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3474:../uvc.c      ****                         {
3475:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3476:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3477:../uvc.c      ****                         }
3478:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3479:../uvc.c      ****                     }
3480:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3481:../uvc.c      ****                 }
3482:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3483:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3484:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3485:../uvc.c      ****                  */
3486:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3487:../uvc.c      ****                 {
3488:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3489:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3490:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3491:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3492:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3493:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3494:../uvc.c      ****                         	break;
3495:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3496:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3497:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3498:../uvc.c      ****                         	break;*/
3499:../uvc.c      ****                     dmaInfo.count -= 2;
3500:../uvc.c      ****                 }
3501:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3502:../uvc.c      ****                 else
3503:../uvc.c      ****                 {
3504:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3505:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3506:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3507:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3508:../uvc.c      ****                 }
3509:../uvc.c      **** 
3510:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3511:../uvc.c      ****                 dmaInfo.size   = 1024;
3512:../uvc.c      ****                 dmaInfo.status = 0;
3513:../uvc.c      **** 
3514:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3515:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3516:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3517:../uvc.c      ****                 {
3518:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3519:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3520:../uvc.c      ****                 }
3521:../uvc.c      **** 
3522:../uvc.c      ****                 /* Wait until the response has gone out. */
3523:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3524:../uvc.c      **** 
3525:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3526:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3527:../uvc.c      ****                 {
3528:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3529:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3530:../uvc.c      ****                 }
3531:../uvc.c      ****             }
3532:../uvc.c      **** #endif
3533:../uvc.c      ****         }
3534:../uvc.c      ****         /* Allow other ready threads to run. */
3535:../uvc.c      ****         CyU3PThreadRelinquish ();
3536:../uvc.c      ****     }
3537:../uvc.c      **** }
3538:../uvc.c      **** 
3539:../uvc.c      **** /*
3540:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3541:../uvc.c      ****  * added 10/2013
3542:../uvc.c      ****  */
3543:../uvc.c      **** /*
3544:../uvc.c      **** static uint8_t timeDelay[64] = {
3545:../uvc.c      **** 
3546:../uvc.c      **** };
3547:../uvc.c      **** */
3548:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 3548 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
3549:../uvc.c      **** 
3550:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3551:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3552:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3553:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3554:../uvc.c      **** 	VdstateDes *lcStaDes;
3555:../uvc.c      **** 	uint32_t flag = 0;
3556:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3557:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3558:../uvc.c      **** 	uint8_t i;
3559:../uvc.c      **** 	uint16_t delaytime;
3560:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3561:../uvc.c      **** 
3562:../uvc.c      **** #if 0 //for test the command queue
3563:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3564:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3565:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3566:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3567:../uvc.c      **** 		lcCmdDes += 1;
3568:../uvc.c      **** 	}
3569:../uvc.c      **** #endif
3570:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3571:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 3571 0
  36 0004 10229FE5 		ldr	r2, .L22
3555:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 3555 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
3548:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 3548 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 3571 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 F8019FE5 		ldr	r0, .L22+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
3555:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 3555 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 3571 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
3572:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 3572 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 DC119FE5 		ldr	r1, .L22+8
  71 0044 DC519FE5 		ldr	r5, .L22+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
3573:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 3573 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
3574:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 3574 0
  79 005c BC019FE5 		ldr	r0, .L22+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
3575:../uvc.c      **** 
3576:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 3576 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
3577:../uvc.c      ****         /* Allow other ready threads to run. */
3578:../uvc.c      **** 
3579:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 3579 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
3576:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 3576 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
3580:../uvc.c      **** 	}
3581:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 3581 0
  92 0078 A8019FE5 		ldr	r0, .L22+12
  93 007c A8119FE5 		ldr	r1, .L22+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 98719FE5 		ldr	r7, .L22+20
  99 0094 98B19FE5 		ldr	fp, .L22+24
3582:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3583:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3584:../uvc.c      **** 	//CyU3PThreadSleep(100);
3585:../uvc.c      **** 	//SetCurCmd();
3586:../uvc.c      **** 	/*********** the loop of the thread ***********/
3587:../uvc.c      **** 	for(;;){
3588:../uvc.c      **** 
3589:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 3589 0
 101 0098 0060E0E3 		mvn	r6, #0
3590:../uvc.c      **** /*  // for test GPIO output
3591:../uvc.c      **** 		if(trigger)
3592:../uvc.c      **** 		{
3593:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3594:../uvc.c      **** 			{
3595:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3596:../uvc.c      **** 			}
3597:../uvc.c      **** 
3598:../uvc.c      **** 		}else{
3599:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3600:../uvc.c      **** 			{
3601:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3602:../uvc.c      **** 			}
3603:../uvc.c      **** 
3604:../uvc.c      **** 		}
3605:../uvc.c      **** */
3606:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3607:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3608:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
3609:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
3610:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
3611:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
3612:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
3613:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
3614:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3615:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
3616:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
3617:../uvc.c      **** #endif
3618:../uvc.c      **** 				}
3619:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
3620:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
3621:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
3622:../uvc.c      **** 			}
3623:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
3624:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
3625:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3626:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
3627:../uvc.c      **** 
3628:../uvc.c      **** 				/*
3629:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3630:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3631:../uvc.c      **** 				*/
3632:../uvc.c      **** 
3633:../uvc.c      **** 				/* find a available command */
3634:../uvc.c      **** 				i = 0;
3635:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 3635 0
 103 009c 0090A0E3 		mov	r9, #0
3636:../uvc.c      **** 					i++;
3637:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
3638:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
3639:../uvc.c      **** 				}
3640:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
3641:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
3642:../uvc.c      **** 					i = lcCmdDes->curNum;
3643:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
3644:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
3645:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
3646:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
3647:../uvc.c      **** #if 1
3648:../uvc.c      **** 					switch(lcCmdDes->CmdID){
3649:../uvc.c      **** 						case 20:
3650:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
3651:../uvc.c      **** 							delaytime = 500;
3652:../uvc.c      **** 							break;
3653:../uvc.c      **** 						case 21:
3654:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3655:../uvc.c      **** 							delaytime = 500;
3656:../uvc.c      **** 							break;
3657:../uvc.c      **** 						case 22:
3658:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3659:../uvc.c      **** 							delaytime = 300;
3660:../uvc.c      **** 							break;
3661:../uvc.c      **** 						case 23:
3662:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3663:../uvc.c      **** 							delaytime = 300;
3664:../uvc.c      **** 							break;
3665:../uvc.c      **** 						default:
3666:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
3667:../uvc.c      **** 							break;
3668:../uvc.c      **** 					}
3669:../uvc.c      **** #endif
3670:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
3671:../uvc.c      **** 					/** timer's ticket modify **/
3672:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
3673:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
3674:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
3675:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
3676:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
3677:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3678:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
3679:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
3680:../uvc.c      **** #endif
3681:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
3682:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
3683:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
3684:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
3685:../uvc.c      **** 						}else{
3686:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
3687:../uvc.c      **** 						}
3688:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
3689:../uvc.c      **** 					}else{
3690:../uvc.c      **** 						lcCmdDes->curNum ++;
3691:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 3691 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L18:
3589:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 3589 0
 108 00a4 0320A0E3 		mov	r2, #3
 109 00a8 14308DE2 		add	r3, sp, #20
 110 00ac 2010A0E3 		mov	r1, #32
 111 00b0 80019FE5 		ldr	r0, .L22+28
 112 00b4 00608DE5 		str	r6, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
3606:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 3606 0
 115 00bc 0610A0E1 		mov	r1, r6
 116 00c0 1C0097E5 		ldr	r0, [r7, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
3623:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 119              		.loc 1 3623 0
 120 00c8 1C0097E5 		ldr	r0, [r7, #28]
 121 00cc FEFFFFEB 		bl	_txe_mutex_put
 122              	.LVL4:
3625:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 123              		.loc 1 3625 0
 124 00d0 1C0095E5 		ldr	r0, [r5, #28]
 125 00d4 0610A0E1 		mov	r1, r6
 126 00d8 FEFFFFEB 		bl	_txe_mutex_get
3626:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 127              		.loc 1 3626 0
 128 00dc 104095E5 		ldr	r4, [r5, #16]
 129              	.LVL5:
3635:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 3635 0
 131 00e0 3C2094E5 		ldr	r2, [r4, #60]
 132 00e4 000052E3 		cmp	r2, #0
 133 00e8 0800001A 		bne	.L4
 134 00ec 0030A0E3 		mov	r3, #0
 135              	.LVL6:
 136              	.L5:
3637:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 137              		.loc 1 3637 0
 138 00f0 344094E5 		ldr	r4, [r4, #52]
 139              	.LVL7:
3636:../uvc.c      **** 					i++;
 140              		.loc 1 3636 0
 141 00f4 011083E2 		add	r1, r3, #1
3635:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 142              		.loc 1 3635 0
 143 00f8 3C2094E5 		ldr	r2, [r4, #60]
3636:../uvc.c      **** 					i++;
 144              		.loc 1 3636 0
 145 00fc FF3001E2 		and	r3, r1, #255
 146              	.LVL8:
3635:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 147              		.loc 1 3635 0
 148 0100 3F0053E3 		cmp	r3, #63
 149 0104 00005293 		cmpls	r2, #0
 150 0108 F8FFFF0A 		beq	.L5
 151 010c 104085E5 		str	r4, [r5, #16]
 152              	.LVL9:
 153              	.L4:
3641:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
 154              		.loc 1 3641 0
 155 0110 000052E3 		cmp	r2, #0
 156 0114 2D00000A 		beq	.L6
 157              	.LVL10:
3643:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 158              		.loc 1 3643 0
 159 0118 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
3648:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 160              		.loc 1 3648 0
 161 011c 0020D4E5 		ldrb	r2, [r4, #0]	@ zero_extendqisi2
3643:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 162              		.loc 1 3643 0
 163 0120 83E083E0 		add	lr, r3, r3, asl #1
 164 0124 8EA084E0 		add	sl, r4, lr, asl #1
3648:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 165              		.loc 1 3648 0
 166 0128 14C042E2 		sub	ip, r2, #20
3643:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 167              		.loc 1 3643 0
 168 012c 0400DAE5 		ldrb	r0, [sl, #4]	@ zero_extendqisi2
 169              	.LVL11:
3644:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 170              		.loc 1 3644 0
 171 0130 0510DAE5 		ldrb	r1, [sl, #5]	@ zero_extendqisi2
 172              	.LVL12:
3645:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 173              		.loc 1 3645 0
 174 0134 0620DAE5 		ldrb	r2, [sl, #6]	@ zero_extendqisi2
 175              	.LVL13:
3646:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 176              		.loc 1 3646 0
 177 0138 B8A0DAE1 		ldrh	sl, [sl, #8]
 178              	.LVL14:
3648:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 179              		.loc 1 3648 0
 180 013c 03005CE3 		cmp	ip, #3
 181 0140 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 182 0144 1A0000EA 		b	.L7
 183              	.L12:
 184 0148 C0010000 		.word	.L8
 185 014c A4010000 		.word	.L9
 186 0150 58010000 		.word	.L11
 187 0154 58010000 		.word	.L11
 188              	.LVL15:
 189              	.L11:
3662:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 190              		.loc 1 3662 0
 191 0158 8230A0E3 		mov	r3, #130
 192 015c FEFFFFEB 		bl	SensorSetIrisControl
 193              	.LVL16:
3664:../uvc.c      **** 							break;
 194              		.loc 1 3664 0
 195 0160 4B1FA0E3 		mov	r1, #300
 196              	.LVL17:
 197              	.L13:
3673:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 198              		.loc 1 3673 0
 199 0164 0020A0E3 		mov	r2, #0
 200 0168 B0009FE5 		ldr	r0, .L22+4
 201 016c FEFFFFEB 		bl	_txe_timer_change
3674:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 202              		.loc 1 3674 0
 203 0170 A8009FE5 		ldr	r0, .L22+4
 204 0174 FEFFFFEB 		bl	_txe_timer_activate
 205              	.LVL18:
3681:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 206              		.loc 1 3681 0
 207 0178 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 208 017c 0210D4E5 		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 209 0180 000051E1 		cmp	r1, r0
3690:../uvc.c      **** 						lcCmdDes->curNum ++;
 210              		.loc 1 3690 0
 211 0184 01008012 		addne	r0, r0, #1
 212 0188 0100C415 		strneb	r0, [r4, #1]
 213              		.loc 1 3691 0
 214 018c 3C808415 		strne	r8, [r4, #60]
3681:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 215              		.loc 1 3681 0
 216 0190 1400000A 		beq	.L21
 217              	.LVL19:
 218              	.L17:
3692:../uvc.c      **** 					}
3693:../uvc.c      **** 				}else{
3694:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
3695:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
3696:../uvc.c      **** 				}
3697:../uvc.c      **** 			}
3698:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 219              		.loc 1 3698 0
 220 0194 1C0095E5 		ldr	r0, [r5, #28]
 221 0198 FEFFFFEB 		bl	_txe_mutex_put
 222              	.LVL20:
3699:../uvc.c      **** /*
3700:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3701:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3702:../uvc.c      **** */
3703:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3704:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
3705:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
3706:../uvc.c      **** #endif
3707:../uvc.c      **** 
3708:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
3709:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
3710:../uvc.c      **** #if 0
3711:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
3712:../uvc.c      **** 
3713:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
3714:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
3715:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
3716:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
3717:../uvc.c      **** 			    i = 0;
3718:../uvc.c      **** 				 switch(cmdCopyIdx)
3719:../uvc.c      **** 				 {
3720:../uvc.c      **** 					 case BrgtCtlID1:
3721:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
3722:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3723:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
3724:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3725:../uvc.c      **** 							 i++;
3726:../uvc.c      **** 						 }
3727:../uvc.c      **** 						 else{
3728:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3729:../uvc.c      **** 						 }
3730:../uvc.c      **** 
3731:../uvc.c      **** 						 CyU3PBusyWait(500);
3732:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
3733:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3734:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3735:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3736:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3737:../uvc.c      **** 						 }
3738:../uvc.c      **** 						 else{
3739:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3740:../uvc.c      **** 						 }
3741:../uvc.c      **** 						 break;
3742:../uvc.c      **** 					 case HueCtlID5:
3743:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3744:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3745:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3746:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3747:../uvc.c      **** 						 }
3748:../uvc.c      **** 						 else{
3749:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3750:../uvc.c      **** 						 }
3751:../uvc.c      **** 						 break;
3752:../uvc.c      **** 					 case SaturCtlID6:
3753:../uvc.c      **** 					 case WBTLevCtlID10:
3754:../uvc.c      **** 					 default:
3755:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
3756:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3757:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3758:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3759:../uvc.c      **** 						 }
3760:../uvc.c      **** 						 else{
3761:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3762:../uvc.c      **** 						 }
3763:../uvc.c      **** 						 break;
3764:../uvc.c      **** 				 }
3765:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
3766:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
3767:../uvc.c      **** 			}
3768:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
3769:../uvc.c      **** #endif
3770:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
3771:../uvc.c      **** 		/* Allow other ready threads to run. */
3772:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3773:../uvc.c      **** 			CyU3PThreadRelinquish ();
 223              		.loc 1 3773 0
 224 019c FEFFFFEB 		bl	_txe_thread_relinquish
3774:../uvc.c      **** 		}
 225              		.loc 1 3774 0
 226 01a0 BFFFFFEA 		b	.L18
 227              	.LVL21:
 228              	.L9:
3654:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 229              		.loc 1 3654 0
 230 01a4 5230A0E3 		mov	r3, #82
 231 01a8 FEFFFFEB 		bl	SensorSetIrisControl
 232              	.LVL22:
3656:../uvc.c      **** 							break;
 233              		.loc 1 3656 0
 234 01ac 7D1FA0E3 		mov	r1, #500
 235 01b0 EBFFFFEA 		b	.L13
 236              	.LVL23:
 237              	.L7:
3666:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 238              		.loc 1 3666 0
 239 01b4 FEFFFFEB 		bl	SensorSetControl
 240              	.LVL24:
 241 01b8 0A10A0E1 		mov	r1, sl
3667:../uvc.c      **** 							break;
 242              		.loc 1 3667 0
 243 01bc E8FFFFEA 		b	.L13
 244              	.LVL25:
 245              	.L8:
3650:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
 246              		.loc 1 3650 0
 247 01c0 8230A0E3 		mov	r3, #130
 248 01c4 FEFFFFEB 		bl	SensorSetIrisControl
 249              	.LVL26:
3652:../uvc.c      **** 							break;
 250              		.loc 1 3652 0
 251 01c8 7D1FA0E3 		mov	r1, #500
 252 01cc E4FFFFEA 		b	.L13
 253              	.LVL27:
 254              	.L6:
3694:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 255              		.loc 1 3694 0
 256 01d0 FA1FA0E3 		mov	r1, #1000
 257 01d4 44009FE5 		ldr	r0, .L22+4
 258 01d8 FEFFFFEB 		bl	_txe_timer_change
3695:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 259              		.loc 1 3695 0
 260 01dc 3C009FE5 		ldr	r0, .L22+4
 261 01e0 FEFFFFEB 		bl	_txe_timer_activate
 262 01e4 EAFFFFEA 		b	.L17
 263              	.LVL28:
 264              	.L21:
3683:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 265              		.loc 1 3683 0
 266 01e8 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
3682:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 267              		.loc 1 3682 0
 268 01ec 3C9084E5 		str	r9, [r4, #60]
3683:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 269              		.loc 1 3683 0
 270 01f0 1F005CE3 		cmp	ip, #31
3684:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 271              		.loc 1 3684 0
 272 01f4 20C04C82 		subhi	ip, ip, #32
 273 01f8 8CC08C80 		addhi	ip, ip, ip, asl #1
3686:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 274              		.loc 1 3686 0
 275 01fc 8CC08C90 		addls	ip, ip, ip, asl #1
3684:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 276              		.loc 1 3684 0
 277 0200 8CC18B80 		addhi	ip, fp, ip, asl #3
3686:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 278              		.loc 1 3686 0
 279 0204 8CC18B90 		addls	ip, fp, ip, asl #3
3684:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 280              		.loc 1 3684 0
 281 0208 1090CC85 		strhib	r9, [ip, #16]
3686:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 282              		.loc 1 3686 0
 283 020c 9091CC95 		strlsb	r9, [ip, #400]
3688:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 284              		.loc 1 3688 0
 285 0210 344094E5 		ldr	r4, [r4, #52]
 286              	.LVL29:
 287 0214 104085E5 		str	r4, [r5, #16]
 288 0218 DDFFFFEA 		b	.L17
 289              	.L23:
 290              		.align	2
 291              	.L22:
 292 021c 00000000 		.word	I2CCmdCb
 293 0220 00000000 		.word	I2CCmdTimer
 294 0224 00000000 		.word	.LC0
 295 0228 00000000 		.word	cmdQu
 296 022c 14000000 		.word	.LC1
 297 0230 00000000 		.word	statQu
 298 0234 00000000 		.word	.LANCHOR1
 299 0238 00000000 		.word	.LANCHOR0
 300              		.cfi_endproc
 301              	.LFE25:
 303              		.align	2
 304              		.global	I2CCmdCb
 306              	I2CCmdCb:
 307              	.LFB17:
2261:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 308              		.loc 1 2261 0
 309              		.cfi_startproc
 310              		@ args = 0, pretend = 0, frame = 0
 311              		@ frame_needed = 0, uses_anonymous_args = 0
 312              		@ link register save eliminated.
 313              	.LVL30:
2263:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 314              		.loc 1 2263 0
 315 023c 08009FE5 		ldr	r0, .L25
 316              	.LVL31:
 317 0240 2010A0E3 		mov	r1, #32
 318 0244 0020A0E3 		mov	r2, #0
2264:../uvc.c      **** }
 319              		.loc 1 2264 0
2263:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 320              		.loc 1 2263 0
 321 0248 FEFFFFEA 		b	_txe_event_flags_set
 322              	.L26:
 323              		.align	2
 324              	.L25:
 325 024c 00000000 		.word	.LANCHOR0
 326              		.cfi_endproc
 327              	.LFE17:
 329              		.align	2
 330              		.global	CyFxUvcApplnDmaCallback
 332              	CyFxUvcApplnDmaCallback:
 333              	.LFB10:
1540:../uvc.c      **** {
 334              		.loc 1 1540 0
 335              		.cfi_startproc
 336              		@ args = 0, pretend = 0, frame = 0
 337              		@ frame_needed = 0, uses_anonymous_args = 0
 338              	.LVL32:
1547:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 339              		.loc 1 1547 0
 340 0250 080051E3 		cmp	r1, #8
1540:../uvc.c      **** {
 341              		.loc 1 1540 0
 342 0254 30402DE9 		stmfd	sp!, {r4, r5, lr}
 343              	.LCFI2:
 344              		.cfi_def_cfa_offset 12
 345 0258 0240A0E1 		mov	r4, r2
 346              		.cfi_offset 14, -4
 347              		.cfi_offset 5, -8
 348              		.cfi_offset 4, -12
 349 025c 0CD04DE2 		sub	sp, sp, #12
 350              	.LCFI3:
 351              		.cfi_def_cfa_offset 24
1547:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 352              		.loc 1 1547 0
 353 0260 0B00000A 		beq	.L32
1579:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 354              		.loc 1 1579 0
 355 0264 100051E3 		cmp	r1, #16
 356 0268 0700001A 		bne	.L27
1581:../uvc.c      ****         consCount++;
 357              		.loc 1 1581 0
 358 026c 0C319FE5 		ldr	r3, .L34
1582:../uvc.c      ****         streamingStarted = CyTrue;
 359              		.loc 1 1582 0
 360 0270 0110A0E3 		mov	r1, #1
 361              	.LVL33:
1581:../uvc.c      ****         consCount++;
 362              		.loc 1 1581 0
 363 0274 B603D3E1 		ldrh	r0, [r3, #54]
 364              	.LVL34:
1582:../uvc.c      ****         streamingStarted = CyTrue;
 365              		.loc 1 1582 0
 366 0278 381083E5 		str	r1, [r3, #56]
1581:../uvc.c      ****         consCount++;
 367              		.loc 1 1581 0
 368 027c 01C080E0 		add	ip, r0, r1
 369 0280 0C28A0E1 		mov	r2, ip, asl #16
 370              	.LVL35:
 371 0284 2218A0E1 		mov	r1, r2, lsr #16
 372 0288 B613C3E1 		strh	r1, [r3, #54]	@ movhi
 373              	.L27:
1584:../uvc.c      **** }
 374              		.loc 1 1584 0
 375 028c 0CD08DE2 		add	sp, sp, #12
 376 0290 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 377              	.LVL36:
 378              	.L32:
1549:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 379              		.loc 1 1549 0
 380 0294 B420D2E1 		ldrh	r2, [r2, #4]
 381 0298 E4309FE5 		ldr	r3, .L34+4
 382 029c 030052E1 		cmp	r2, r3
 383 02a0 2B00000A 		beq	.L33
1557:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 384              		.loc 1 1557 0
 385 02a4 005094E5 		ldr	r5, [r4, #0]
 386              	.LVL37:
 387              	.LBB14:
 388              	.LBB15:
1289:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 389              		.loc 1 1289 0
 390 02a8 D8109FE5 		ldr	r1, .L34+8
 391              	.LVL38:
 392 02ac 0C0045E2 		sub	r0, r5, #12
 393              	.LVL39:
 394 02b0 0C20A0E3 		mov	r2, #12
 395 02b4 FEFFFFEB 		bl	CyU3PMemCopy
 396              	.LVL40:
1294:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 397              		.loc 1 1294 0
 398 02b8 0B2055E5 		ldrb	r2, [r5, #-11]	@ zero_extendqisi2
 399              	.LBE15:
 400              	.LBE14:
1558:../uvc.c      ****                 pb++;
 401              		.loc 1 1558 0
 402 02bc BC309FE5 		ldr	r3, .L34
 403              	.LBB17:
 404              	.LBB16:
1294:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 405              		.loc 1 1294 0
 406 02c0 021082E3 		orr	r1, r2, #2
 407 02c4 0B1045E5 		strb	r1, [r5, #-11]
 408              	.LBE16:
 409              	.LBE17:
1558:../uvc.c      ****                 pb++;
 410              		.loc 1 1558 0
 411 02c8 BAC2D3E1 		ldrh	ip, [r3, #42]
1559:../uvc.c      ****                 pbc = input->buffer_p.count;
 412              		.loc 1 1559 0
 413 02cc B410D4E1 		ldrh	r1, [r4, #4]
1558:../uvc.c      ****                 pb++;
 414              		.loc 1 1558 0
 415 02d0 01008CE2 		add	r0, ip, #1
1563:../uvc.c      ****                hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been co
 416              		.loc 1 1563 0
 417 02d4 0120A0E3 		mov	r2, #1
1558:../uvc.c      ****                 pb++;
 418              		.loc 1 1558 0
 419 02d8 BA02C3E1 		strh	r0, [r3, #42]	@ movhi
1559:../uvc.c      ****                 pbc = input->buffer_p.count;
 420              		.loc 1 1559 0
 421 02dc BC12C3E1 		strh	r1, [r3, #44]	@ movhi
1563:../uvc.c      ****                hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been co
 422              		.loc 1 1563 0
 423 02e0 302083E5 		str	r2, [r3, #48]
 424              	.LVL41:
 425              	.L30:
1567:../uvc.c      ****             prodCount++;
 426              		.loc 1 1567 0
 427 02e4 B4E3D3E1 		ldrh	lr, [r3, #52]
1568:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 428              		.loc 1 1568 0
 429 02e8 0C2081E2 		add	r2, r1, #12
1567:../uvc.c      ****             prodCount++;
 430              		.loc 1 1567 0
 431 02ec 01C08EE2 		add	ip, lr, #1
 432 02f0 0C08A0E1 		mov	r0, ip, asl #16
 433 02f4 20E8A0E1 		mov	lr, r0, lsr #16
1568:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 434              		.loc 1 1568 0
 435 02f8 0218A0E1 		mov	r1, r2, asl #16
 436 02fc 2118A0E1 		mov	r1, r1, lsr #16
 437 0300 0020A0E3 		mov	r2, #0
 438 0304 80009FE5 		ldr	r0, .L34+12
1567:../uvc.c      ****             prodCount++;
 439              		.loc 1 1567 0
 440 0308 B4E3C3E1 		strh	lr, [r3, #52]	@ movhi
1568:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 441              		.loc 1 1568 0
 442 030c FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 443              	.LVL42:
1567:../uvc.c      ****             prodCount++;
 444              		.loc 1 1567 0
 445 0310 68109FE5 		ldr	r1, .L34
1571:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
 446              		.loc 1 1571 0
 447 0314 002050E2 		subs	r2, r0, #0
 448 0318 DBFFFF0A 		beq	.L27
1573:../uvc.c      ****                 prodCount--;
 449              		.loc 1 1573 0
 450 031c B403D1E1 		ldrh	r0, [r1, #52]
 451              	.LVL43:
1574:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 452              		.loc 1 1574 0
 453 0320 B430D4E1 		ldrh	r3, [r4, #4]
1573:../uvc.c      ****                 prodCount--;
 454              		.loc 1 1573 0
 455 0324 01E040E2 		sub	lr, r0, #1
 456 0328 0EC8A0E1 		mov	ip, lr, asl #16
 457 032c 2C08A0E1 		mov	r0, ip, lsr #16
 458 0330 B403C1E1 		strh	r0, [r1, #52]	@ movhi
1574:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 459              		.loc 1 1574 0
 460 0334 B4E3D1E1 		ldrh	lr, [r1, #52]
 461 0338 B6C3D1E1 		ldrh	ip, [r1, #54]
 462 033c 0400A0E3 		mov	r0, #4
 463 0340 48109FE5 		ldr	r1, .L34+16
 464 0344 00E08DE5 		str	lr, [sp, #0]
 465 0348 04C08DE5 		str	ip, [sp, #4]
 466 034c FEFFFFEB 		bl	CyU3PDebugPrint
 467              	.LVL44:
 468 0350 CDFFFFEA 		b	.L27
 469              	.LVL45:
 470              	.L33:
1551:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
 471              		.loc 1 1551 0
 472 0354 00E094E5 		ldr	lr, [r4, #0]
 473              	.LBB18:
 474              	.LBB19:
1289:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 475              		.loc 1 1289 0
 476 0358 28109FE5 		ldr	r1, .L34+8
 477              	.LVL46:
 478 035c 0C004EE2 		sub	r0, lr, #12
 479              	.LVL47:
 480 0360 0C20A0E3 		mov	r2, #12
 481 0364 FEFFFFEB 		bl	CyU3PMemCopy
 482              	.LVL48:
 483              	.LBE19:
 484              	.LBE18:
1552:../uvc.c      ****                 fb++;
 485              		.loc 1 1552 0
 486 0368 10309FE5 		ldr	r3, .L34
 487 036c B410D4E1 		ldrh	r1, [r4, #4]
 488 0370 B8C2D3E1 		ldrh	ip, [r3, #40]
 489 0374 01008CE2 		add	r0, ip, #1
 490 0378 B802C3E1 		strh	r0, [r3, #40]	@ movhi
 491 037c D8FFFFEA 		b	.L30
 492              	.L35:
 493              		.align	2
 494              	.L34:
 495 0380 00000000 		.word	.LANCHOR0
 496 0384 F03F0000 		.word	16368
 497 0388 80040000 		.word	.LANCHOR1+1152
 498 038c 00000000 		.word	glChHandleUVCStream
 499 0390 38000000 		.word	.LC2
 500              		.cfi_endproc
 501              	.LFE10:
 503              		.align	2
 505              	CyFxUVCApplnUSBEventCB:
 506              	.LFB8:
1343:../uvc.c      **** {
 507              		.loc 1 1343 0
 508              		.cfi_startproc
 509              		@ args = 0, pretend = 0, frame = 8
 510              		@ frame_needed = 0, uses_anonymous_args = 0
 511              	.LVL49:
1344:../uvc.c      ****     switch (evtype)
 512              		.loc 1 1344 0
 513 0394 020050E3 		cmp	r0, #2
1343:../uvc.c      **** {
 514              		.loc 1 1343 0
 515 0398 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 516              	.LCFI4:
 517              		.cfi_def_cfa_offset 16
 518 039c 0130A0E1 		mov	r3, r1
 519 03a0 10D04DE2 		sub	sp, sp, #16
 520              	.LCFI5:
 521              		.cfi_def_cfa_offset 32
1343:../uvc.c      **** {
 522              		.loc 1 1343 0
 523 03a4 0040A0E1 		mov	r4, r0
 524              		.cfi_offset 14, -4
 525              		.cfi_offset 6, -8
 526              		.cfi_offset 5, -12
 527              		.cfi_offset 4, -16
1344:../uvc.c      ****     switch (evtype)
 528              		.loc 1 1344 0
 529 03a8 3600000A 		beq	.L39
 530 03ac 040050E3 		cmp	r0, #4
 531 03b0 1F00000A 		beq	.L40
 532 03b4 010050E3 		cmp	r0, #1
 533 03b8 0100000A 		beq	.L42
 534              	.LVL50:
 535              	.L36:
1380:../uvc.c      **** }
 536              		.loc 1 1380 0
 537 03bc 10D08DE2 		add	sp, sp, #16
 538 03c0 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 539              	.LVL51:
 540              	.L42:
1365:../uvc.c      ****             gpif_initialized = 0;
 541              		.loc 1 1365 0
 542 03c4 28519FE5 		ldr	r5, .L43
1363:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 543              		.loc 1 1363 0
 544 03c8 0020A0E1 		mov	r2, r0
 545 03cc 24119FE5 		ldr	r1, .L43+4
 546              	.LVL52:
 547 03d0 0400A0E3 		mov	r0, #4
 548              	.LVL53:
 549 03d4 FEFFFFEB 		bl	CyU3PDebugPrint
1364:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 550              		.loc 1 1364 0
 551 03d8 0400A0E1 		mov	r0, r4
 552 03dc FEFFFFEB 		bl	CyU3PGpifDisable
1365:../uvc.c      ****             gpif_initialized = 0;
 553              		.loc 1 1365 0
 554 03e0 00C0A0E3 		mov	ip, #0
 555              	.LBB26:
 556              	.LBB27:
1327:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 557              		.loc 1 1327 0
 558 03e4 0410A0E1 		mov	r1, r4
 559 03e8 0500A0E1 		mov	r0, r5
 560 03ec 0220A0E3 		mov	r2, #2
 561 03f0 0C308DE2 		add	r3, sp, #12
 562              	.LBE27:
 563              	.LBE26:
1365:../uvc.c      ****             gpif_initialized = 0;
 564              		.loc 1 1365 0
 565 03f4 3CC085E5 		str	ip, [r5, #60]
1366:../uvc.c      ****             isUsbConnected = CyFalse;
 566              		.loc 1 1366 0
 567 03f8 40C085E5 		str	ip, [r5, #64]
1367:../uvc.c      ****             streamingStarted = CyFalse;
 568              		.loc 1 1367 0
 569 03fc 38C085E5 		str	ip, [r5, #56]
 570              	.LBB29:
 571              	.LBB28:
1327:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 572              		.loc 1 1327 0
 573 0400 00C08DE5 		str	ip, [sp, #0]
 574 0404 FEFFFFEB 		bl	_txe_event_flags_get
 575 0408 004050E2 		subs	r4, r0, #0
 576 040c EAFFFF1A 		bne	.L36
1330:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 577              		.loc 1 1330 0
 578 0410 0110E0E3 		mvn	r1, #1
 579 0414 0220A0E3 		mov	r2, #2
 580 0418 0500A0E1 		mov	r0, r5
 581              	.L41:
 582 041c FEFFFFEB 		bl	_txe_event_flags_set
1333:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 583              		.loc 1 1333 0
 584 0420 0500A0E1 		mov	r0, r5
 585 0424 0210A0E3 		mov	r1, #2
 586 0428 0420A0E1 		mov	r2, r4
 587 042c FEFFFFEB 		bl	_txe_event_flags_set
 588 0430 E1FFFFEA 		b	.L36
 589              	.LVL54:
 590              	.L40:
 591              	.LBE28:
 592              	.LBE29:
1349:../uvc.c      ****             gpif_initialized = 0;
 593              		.loc 1 1349 0
 594 0434 B8509FE5 		ldr	r5, .L43
1347:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 595              		.loc 1 1347 0
 596 0438 BC109FE5 		ldr	r1, .L43+8
 597              	.LVL55:
 598 043c 0020A0E1 		mov	r2, r0
 599 0440 FEFFFFEB 		bl	CyU3PDebugPrint
 600              	.LVL56:
1348:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 601              		.loc 1 1348 0
 602 0444 0100A0E3 		mov	r0, #1
 603 0448 FEFFFFEB 		bl	CyU3PGpifDisable
1349:../uvc.c      ****             gpif_initialized = 0;
 604              		.loc 1 1349 0
 605 044c 00C0A0E3 		mov	ip, #0
 606              	.LBB30:
 607              	.LBB31:
1327:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 608              		.loc 1 1327 0
 609 0450 0110A0E3 		mov	r1, #1
 610 0454 0220A0E3 		mov	r2, #2
 611 0458 0500A0E1 		mov	r0, r5
 612 045c 0C308DE2 		add	r3, sp, #12
 613              	.LBE31:
 614              	.LBE30:
1349:../uvc.c      ****             gpif_initialized = 0;
 615              		.loc 1 1349 0
 616 0460 3CC085E5 		str	ip, [r5, #60]
1350:../uvc.c      ****             streamingStarted = CyFalse;
 617              		.loc 1 1350 0
 618 0464 38C085E5 		str	ip, [r5, #56]
 619              	.LBB33:
 620              	.LBB32:
1327:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 621              		.loc 1 1327 0
 622 0468 00C08DE5 		str	ip, [sp, #0]
 623 046c FEFFFFEB 		bl	_txe_event_flags_get
 624 0470 004050E2 		subs	r4, r0, #0
1330:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 625              		.loc 1 1330 0
 626 0474 0500A001 		moveq	r0, r5
 627 0478 0110E003 		mvneq	r1, #1
 628 047c 0220A003 		moveq	r2, #2
1327:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 629              		.loc 1 1327 0
 630 0480 CDFFFF1A 		bne	.L36
 631 0484 E4FFFFEA 		b	.L41
 632              	.LVL57:
 633              	.L39:
 634              	.LBE32:
 635              	.LBE33:
1357:../uvc.c      ****             gpif_initialized = 0;
 636              		.loc 1 1357 0
 637 0488 64509FE5 		ldr	r5, .L43
1355:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 638              		.loc 1 1355 0
 639 048c 0020A0E1 		mov	r2, r0
 640 0490 68109FE5 		ldr	r1, .L43+12
 641              	.LVL58:
 642 0494 0400A0E3 		mov	r0, #4
 643              	.LVL59:
 644 0498 FEFFFFEB 		bl	CyU3PDebugPrint
1356:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 645              		.loc 1 1356 0
 646 049c 0100A0E3 		mov	r0, #1
 647 04a0 FEFFFFEB 		bl	CyU3PGpifDisable
1357:../uvc.c      ****             gpif_initialized = 0;
 648              		.loc 1 1357 0
 649 04a4 0060A0E3 		mov	r6, #0
 650              	.LBB34:
 651              	.LBB35:
1327:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 652              		.loc 1 1327 0
 653 04a8 0500A0E1 		mov	r0, r5
 654 04ac 0110A0E3 		mov	r1, #1
 655 04b0 0420A0E1 		mov	r2, r4
 656 04b4 0C308DE2 		add	r3, sp, #12
 657              	.LBE35:
 658              	.LBE34:
1357:../uvc.c      ****             gpif_initialized = 0;
 659              		.loc 1 1357 0
 660 04b8 3C6085E5 		str	r6, [r5, #60]
1358:../uvc.c      ****             streamingStarted = CyFalse;
 661              		.loc 1 1358 0
 662 04bc 386085E5 		str	r6, [r5, #56]
 663              	.LBB37:
 664              	.LBB36:
1327:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 665              		.loc 1 1327 0
 666 04c0 00608DE5 		str	r6, [sp, #0]
 667 04c4 FEFFFFEB 		bl	_txe_event_flags_get
 668 04c8 006050E2 		subs	r6, r0, #0
 669 04cc BAFFFF1A 		bne	.L36
1330:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 670              		.loc 1 1330 0
 671 04d0 0420A0E1 		mov	r2, r4
 672 04d4 0500A0E1 		mov	r0, r5
 673 04d8 0110E0E3 		mvn	r1, #1
 674 04dc FEFFFFEB 		bl	_txe_event_flags_set
1333:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 675              		.loc 1 1333 0
 676 04e0 0500A0E1 		mov	r0, r5
 677 04e4 0410A0E1 		mov	r1, r4
 678 04e8 0620A0E1 		mov	r2, r6
 679 04ec FEFFFFEB 		bl	_txe_event_flags_set
 680 04f0 B1FFFFEA 		b	.L36
 681              	.L44:
 682              		.align	2
 683              	.L43:
 684 04f4 00000000 		.word	.LANCHOR0
 685 04f8 C8000000 		.word	.LC5
 686 04fc 84000000 		.word	.LC3
 687 0500 A4000000 		.word	.LC4
 688              	.LBE36:
 689              	.LBE37:
 690              		.cfi_endproc
 691              	.LFE8:
 693              		.align	2
 695              	CyFxUVCApplnUSBSetupCB:
 696              	.LFB9:
1388:../uvc.c      **** {
 697              		.loc 1 1388 0
 698              		.cfi_startproc
 699              		@ args = 0, pretend = 0, frame = 8
 700              		@ frame_needed = 0, uses_anonymous_args = 0
 701              	.LVL60:
1393:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 702              		.loc 1 1393 0
 703 0504 C0329FE5 		ldr	r3, .L70
1388:../uvc.c      **** {
 704              		.loc 1 1388 0
 705 0508 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 706              	.LCFI6:
 707              		.cfi_def_cfa_offset 24
1394:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 708              		.loc 1 1394 0
 709 050c BCC29FE5 		ldr	ip, .L70+4
1393:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 710              		.loc 1 1393 0
 711 0510 FF4000E2 		and	r4, r0, #255
 712              		.cfi_offset 14, -4
 713              		.cfi_offset 8, -8
 714              		.cfi_offset 7, -12
 715              		.cfi_offset 6, -16
 716              		.cfi_offset 5, -20
 717              		.cfi_offset 4, -24
1394:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 718              		.loc 1 1394 0
 719 0514 FF8C00E2 		and	r8, r0, #65280
1395:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 720              		.loc 1 1395 0
 721 0518 2078A0E1 		mov	r7, r0, lsr #16
1393:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 722              		.loc 1 1393 0
 723 051c 0040C3E5 		strb	r4, [r3, #0]
1395:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 724              		.loc 1 1395 0
 725 0520 AC229FE5 		ldr	r2, .L70+8
1396:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 726              		.loc 1 1396 0
 727 0524 AC029FE5 		ldr	r0, .L70+12
 728              	.LVL61:
1397:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 729              		.loc 1 1397 0
 730 0528 AC329FE5 		ldr	r3, .L70+16
1396:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 731              		.loc 1 1396 0
 732 052c 0158A0E1 		mov	r5, r1, asl #16
1394:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 733              		.loc 1 1394 0
 734 0530 2884A0E1 		mov	r8, r8, lsr #8
1396:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 735              		.loc 1 1396 0
 736 0534 2558A0E1 		mov	r5, r5, lsr #16
1397:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 737              		.loc 1 1397 0
 738 0538 2118A0E1 		mov	r1, r1, lsr #16
 739              	.LVL62:
1400:../uvc.c      ****     switch (bmReqType)
 740              		.loc 1 1400 0
 741 053c 020054E3 		cmp	r4, #2
1388:../uvc.c      **** {
 742              		.loc 1 1388 0
 743 0540 10D04DE2 		sub	sp, sp, #16
 744              	.LCFI7:
 745              		.cfi_def_cfa_offset 40
1394:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 746              		.loc 1 1394 0
 747 0544 0080CCE5 		strb	r8, [ip, #0]
1395:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 748              		.loc 1 1395 0
 749 0548 B070C2E1 		strh	r7, [r2, #0]	@ movhi
1396:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 750              		.loc 1 1396 0
 751 054c B050C0E1 		strh	r5, [r0, #0]	@ movhi
1397:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 752              		.loc 1 1397 0
 753 0550 B010C3E1 		strh	r1, [r3, #0]	@ movhi
1400:../uvc.c      ****     switch (bmReqType)
 754              		.loc 1 1400 0
 755 0554 4F00000A 		beq	.L48
 756 0558 0600009A 		bls	.L66
 757 055c 210054E3 		cmp	r4, #33
 758 0560 3A00000A 		beq	.L49
 759 0564 A10054E3 		cmp	r4, #161
 760 0568 3800000A 		beq	.L49
 761              	.L63:
1389:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 762              		.loc 1 1389 0
 763 056c 0000A0E3 		mov	r0, #0
 764              	.LVL63:
 765              	.L46:
1527:../uvc.c      **** }
 766              		.loc 1 1527 0
 767 0570 10D08DE2 		add	sp, sp, #16
 768 0574 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 769              	.LVL64:
 770              	.L66:
1400:../uvc.c      ****     switch (bmReqType)
 771              		.loc 1 1400 0
 772 0578 010054E3 		cmp	r4, #1
 773 057c FAFFFF1A 		bne	.L63
1440:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 774              		.loc 1 1440 0
 775 0580 0B0058E3 		cmp	r8, #11
 776 0584 F8FFFF1A 		bne	.L63
1444:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 777              		.loc 1 1444 0
 778 0588 010055E3 		cmp	r5, #1
 779 058c F6FFFF1A 		bne	.L63
1444:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 780              		.loc 1 1444 0 is_stmt 0 discriminator 1
 781 0590 000057E3 		cmp	r7, #0
 782 0594 F4FFFF1A 		bne	.L63
1449:../uvc.c      ****                     gpif_initialized = 0;
 783              		.loc 1 1449 0 is_stmt 1
 784 0598 40429FE5 		ldr	r4, .L70+20
1447:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 785              		.loc 1 1447 0
 786 059c 40129FE5 		ldr	r1, .L70+24
 787 05a0 0400A0E3 		mov	r0, #4
 788 05a4 FEFFFFEB 		bl	CyU3PDebugPrint
1448:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 789              		.loc 1 1448 0
 790 05a8 0500A0E1 		mov	r0, r5
 791 05ac FEFFFFEB 		bl	CyU3PGpifDisable
1452:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 792              		.loc 1 1452 0
 793 05b0 0510A0E1 		mov	r1, r5
 794 05b4 8300A0E3 		mov	r0, #131
1449:../uvc.c      ****                     gpif_initialized = 0;
 795              		.loc 1 1449 0
 796 05b8 3C7084E5 		str	r7, [r4, #60]
1450:../uvc.c      ****                     streamingStarted = CyFalse;
 797              		.loc 1 1450 0
 798 05bc 387084E5 		str	r7, [r4, #56]
1452:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 799              		.loc 1 1452 0
 800 05c0 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1453:../uvc.c      ****                     CyU3PBusyWait (100);
 801              		.loc 1 1453 0
 802 05c4 6400A0E3 		mov	r0, #100
 803 05c8 FEFFFFEB 		bl	CyU3PBusyWait
1456:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 804              		.loc 1 1456 0
 805 05cc 14029FE5 		ldr	r0, .L70+28
 806 05d0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1457:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 807              		.loc 1 1457 0
 808 05d4 8300A0E3 		mov	r0, #131
 809 05d8 FEFFFFEB 		bl	CyU3PUsbFlushEp
1458:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 810              		.loc 1 1458 0
 811 05dc 0710A0E1 		mov	r1, r7
 812 05e0 8300A0E3 		mov	r0, #131
 813 05e4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1459:../uvc.c      ****                     CyU3PBusyWait (100);
 814              		.loc 1 1459 0
 815 05e8 6400A0E3 		mov	r0, #100
 816 05ec FEFFFFEB 		bl	CyU3PBusyWait
1462:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 817              		.loc 1 1462 0
 818 05f0 0710A0E1 		mov	r1, r7
 819 05f4 0520A0E1 		mov	r2, r5
 820 05f8 8300A0E3 		mov	r0, #131
 821 05fc FEFFFFEB 		bl	CyU3PUsbStall
 822              	.LVL65:
1465:../uvc.c      ****                     CyU3PUsbAckSetup ();
 823              		.loc 1 1465 0
 824 0600 FEFFFFEB 		bl	CyU3PUsbAckSetup
1467:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 825              		.loc 1 1467 0
 826 0604 445084E5 		str	r5, [r4, #68]
 827              	.LBB42:
 828              	.LBB43:
1327:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 829              		.loc 1 1327 0
 830 0608 0400A0E1 		mov	r0, r4
 831 060c 0510A0E1 		mov	r1, r5
 832 0610 0220A0E3 		mov	r2, #2
 833 0614 0C308DE2 		add	r3, sp, #12
 834 0618 00708DE5 		str	r7, [sp, #0]
 835 061c FEFFFFEB 		bl	_txe_event_flags_get
 836 0620 006050E2 		subs	r6, r0, #0
 837 0624 2E00001A 		bne	.L61
1330:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 838              		.loc 1 1330 0
 839 0628 0110E0E3 		mvn	r1, #1
 840 062c 0220A0E3 		mov	r2, #2
 841 0630 0400A0E1 		mov	r0, r4
 842 0634 FEFFFFEB 		bl	_txe_event_flags_set
1333:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 843              		.loc 1 1333 0
 844 0638 0400A0E1 		mov	r0, r4
 845 063c 0210A0E3 		mov	r1, #2
 846 0640 0620A0E1 		mov	r2, r6
 847 0644 FEFFFFEB 		bl	_txe_event_flags_set
1463:../uvc.c      ****                     uvcHandleReq = CyTrue;
 848              		.loc 1 1463 0
 849 0648 0500A0E1 		mov	r0, r5
 850 064c C7FFFFEA 		b	.L46
 851              	.LVL66:
 852              	.L49:
 853              	.LBE43:
 854              	.LBE42:
1405:../uvc.c      ****             switch (wIndex & 0xFF)
 855              		.loc 1 1405 0
 856 0650 FF5015E2 		ands	r5, r5, #255
 857 0654 1A00001A 		bne	.L67
 858              	.LVL67:
1410:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 859              		.loc 1 1410 0
 860 0658 0520A0E1 		mov	r2, r5
 861 065c 7C019FE5 		ldr	r0, .L70+20
 862 0660 0410A0E3 		mov	r1, #4
 863 0664 FEFFFFEB 		bl	_txe_event_flags_set
 864              	.LVL68:
1412:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 865              		.loc 1 1412 0
 866 0668 002050E2 		subs	r2, r0, #0
1409:../uvc.c      ****                         uvcHandleReq = CyTrue;
 867              		.loc 1 1409 0
 868 066c 0100A003 		moveq	r0, #1
 869              	.LVL69:
1412:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 870              		.loc 1 1412 0
 871 0670 BEFFFF0A 		beq	.L46
1414:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 872              		.loc 1 1414 0
 873 0674 70119FE5 		ldr	r1, .L70+32
 874 0678 0400A0E3 		mov	r0, #4
 875 067c FEFFFFEB 		bl	CyU3PDebugPrint
 876              	.LVL70:
1415:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 877              		.loc 1 1415 0
 878 0680 0500A0E1 		mov	r0, r5
 879 0684 0110A0E3 		mov	r1, #1
 880 0688 0520A0E1 		mov	r2, r5
 881 068c FEFFFFEB 		bl	CyU3PUsbStall
1409:../uvc.c      ****                         uvcHandleReq = CyTrue;
 882              		.loc 1 1409 0
 883 0690 0100A0E3 		mov	r0, #1
 884 0694 B5FFFFEA 		b	.L46
 885              	.LVL71:
 886              	.L48:
1475:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 887              		.loc 1 1475 0
 888 0698 010058E3 		cmp	r8, #1
 889 069c B2FFFF1A 		bne	.L63
1477:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 890              		.loc 1 1477 0
 891 06a0 830055E3 		cmp	r5, #131
 892 06a4 B0FFFF1A 		bne	.L63
1483:../uvc.c      ****                     if (streamingStarted == CyTrue)
 893              		.loc 1 1483 0
 894 06a8 30719FE5 		ldr	r7, .L70+20
 895 06ac 386097E5 		ldr	r6, [r7, #56]
 896 06b0 010056E3 		cmp	r6, #1
 897 06b4 1500000A 		beq	.L68
 898              	.LVL72:
1515:../uvc.c      ****                         CyU3PUsbAckSetup ();
 899              		.loc 1 1515 0
 900 06b8 FEFFFFEB 		bl	CyU3PUsbAckSetup
1514:../uvc.c      ****                         uvcHandleReq = CyTrue;
 901              		.loc 1 1514 0
 902 06bc 0800A0E1 		mov	r0, r8
 903 06c0 AAFFFFEA 		b	.L46
 904              	.LVL73:
 905              	.L67:
1405:../uvc.c      ****             switch (wIndex & 0xFF)
 906              		.loc 1 1405 0
 907 06c4 010055E3 		cmp	r5, #1
 908 06c8 A7FFFF1A 		bne	.L63
 909              	.LVL74:
1423:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 910              		.loc 1 1423 0
 911 06cc 0020A0E3 		mov	r2, #0
 912 06d0 08019FE5 		ldr	r0, .L70+20
 913 06d4 0810A0E3 		mov	r1, #8
 914 06d8 FEFFFFEB 		bl	_txe_event_flags_set
 915              	.LVL75:
1425:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 916              		.loc 1 1425 0
 917 06dc 002050E2 		subs	r2, r0, #0
 918 06e0 0100001A 		bne	.L69
 919              	.LVL76:
 920              	.L61:
 921              	.LBB45:
 922              	.LBB44:
1463:../uvc.c      ****                     uvcHandleReq = CyTrue;
 923              		.loc 1 1463 0
 924 06e4 0500A0E1 		mov	r0, r5
 925 06e8 A0FFFFEA 		b	.L46
 926              	.LVL77:
 927              	.L69:
 928              	.LBE44:
 929              	.LBE45:
1428:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 930              		.loc 1 1428 0
 931 06ec FC109FE5 		ldr	r1, .L70+36
 932 06f0 0400A0E3 		mov	r0, #4
 933              	.LVL78:
 934 06f4 FEFFFFEB 		bl	CyU3PDebugPrint
 935              	.LVL79:
1429:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 936              		.loc 1 1429 0
 937 06f8 0000A0E3 		mov	r0, #0
 938 06fc 0510A0E1 		mov	r1, r5
 939 0700 0020A0E1 		mov	r2, r0
 940 0704 FEFFFFEB 		bl	CyU3PUsbStall
1422:../uvc.c      ****                         uvcHandleReq = CyTrue;
 941              		.loc 1 1422 0
 942 0708 0500A0E1 		mov	r0, r5
 943 070c 97FFFFEA 		b	.L46
 944              	.LVL80:
 945              	.L68:
1485:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 946              		.loc 1 1485 0
 947 0710 DC109FE5 		ldr	r1, .L70+40
 948 0714 0400A0E3 		mov	r0, #4
 949 0718 FEFFFFEB 		bl	CyU3PDebugPrint
1489:../uvc.c      ****                         gpif_initialized = 0;
 950              		.loc 1 1489 0
 951 071c 0080A0E3 		mov	r8, #0
1488:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 952              		.loc 1 1488 0
 953 0720 0600A0E1 		mov	r0, r6
 954 0724 FEFFFFEB 		bl	CyU3PGpifDisable
1493:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 955              		.loc 1 1493 0
 956 0728 0610A0E1 		mov	r1, r6
 957 072c 0500A0E1 		mov	r0, r5
1489:../uvc.c      ****                         gpif_initialized = 0;
 958              		.loc 1 1489 0
 959 0730 3C8087E5 		str	r8, [r7, #60]
1490:../uvc.c      ****                         streamingStarted = CyFalse;
 960              		.loc 1 1490 0
 961 0734 388087E5 		str	r8, [r7, #56]
1493:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 962              		.loc 1 1493 0
 963 0738 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1494:../uvc.c      ****                         CyU3PBusyWait (100);
 964              		.loc 1 1494 0
 965 073c 6400A0E3 		mov	r0, #100
 966 0740 FEFFFFEB 		bl	CyU3PBusyWait
1497:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 967              		.loc 1 1497 0
 968 0744 9C009FE5 		ldr	r0, .L70+28
 969 0748 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1498:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 970              		.loc 1 1498 0
 971 074c 0500A0E1 		mov	r0, r5
 972 0750 FEFFFFEB 		bl	CyU3PUsbFlushEp
1499:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 973              		.loc 1 1499 0
 974 0754 0810A0E1 		mov	r1, r8
 975 0758 0500A0E1 		mov	r0, r5
 976 075c FEFFFFEB 		bl	CyU3PUsbSetEpNak
1500:../uvc.c      ****                         CyU3PBusyWait (100);
 977              		.loc 1 1500 0
 978 0760 6400A0E3 		mov	r0, #100
 979 0764 FEFFFFEB 		bl	CyU3PBusyWait
1503:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 980              		.loc 1 1503 0
 981 0768 0810A0E1 		mov	r1, r8
 982 076c 0620A0E1 		mov	r2, r6
 983 0770 0500A0E1 		mov	r0, r5
 984 0774 FEFFFFEB 		bl	CyU3PUsbStall
 985              	.LVL81:
1507:../uvc.c      ****                         CyU3PUsbAckSetup ();
 986              		.loc 1 1507 0
 987 0778 FEFFFFEB 		bl	CyU3PUsbAckSetup
1509:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 988              		.loc 1 1509 0
 989 077c 446087E5 		str	r6, [r7, #68]
 990              	.LBB46:
 991              	.LBB47:
1327:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 992              		.loc 1 1327 0
 993 0780 0700A0E1 		mov	r0, r7
 994 0784 0610A0E1 		mov	r1, r6
 995 0788 0420A0E1 		mov	r2, r4
 996 078c 0C308DE2 		add	r3, sp, #12
 997 0790 00808DE5 		str	r8, [sp, #0]
 998 0794 FEFFFFEB 		bl	_txe_event_flags_get
 999 0798 005050E2 		subs	r5, r0, #0
1505:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1000              		.loc 1 1505 0
 1001 079c 0600A011 		movne	r0, r6
1327:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1002              		.loc 1 1327 0
 1003 07a0 72FFFF1A 		bne	.L46
1330:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1004              		.loc 1 1330 0
 1005 07a4 0110E0E3 		mvn	r1, #1
 1006 07a8 0420A0E1 		mov	r2, r4
 1007 07ac 0700A0E1 		mov	r0, r7
 1008 07b0 FEFFFFEB 		bl	_txe_event_flags_set
1333:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1009              		.loc 1 1333 0
 1010 07b4 0700A0E1 		mov	r0, r7
 1011 07b8 0410A0E1 		mov	r1, r4
 1012 07bc 0520A0E1 		mov	r2, r5
 1013 07c0 FEFFFFEB 		bl	_txe_event_flags_set
1505:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1014              		.loc 1 1505 0
 1015 07c4 0600A0E1 		mov	r0, r6
 1016 07c8 68FFFFEA 		b	.L46
 1017              	.L71:
 1018              		.align	2
 1019              	.L70:
 1020 07cc 00000000 		.word	bmReqType
 1021 07d0 00000000 		.word	bRequest
 1022 07d4 00000000 		.word	wValue
 1023 07d8 00000000 		.word	wIndex
 1024 07dc 00000000 		.word	wLength
 1025 07e0 00000000 		.word	.LANCHOR0
 1026 07e4 54010000 		.word	.LC8
 1027 07e8 00000000 		.word	glChHandleUVCStream
 1028 07ec E8000000 		.word	.LC6
 1029 07f0 20010000 		.word	.LC7
 1030 07f4 6C010000 		.word	.LC9
 1031              	.LBE47:
 1032              	.LBE46:
 1033              		.cfi_endproc
 1034              	.LFE9:
 1036              		.align	2
 1037              		.global	CyFxGpifCB
 1039              	CyFxGpifCB:
 1040              	.LFB12:
1706:../uvc.c      **** {
 1041              		.loc 1 1706 0
 1042              		.cfi_startproc
 1043              		@ args = 0, pretend = 0, frame = 0
 1044              		@ frame_needed = 0, uses_anonymous_args = 0
 1045              	.LVL82:
1707:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1046              		.loc 1 1707 0
 1047 07f8 010050E3 		cmp	r0, #1
1706:../uvc.c      **** {
 1048              		.loc 1 1706 0
 1049 07fc 10402DE9 		stmfd	sp!, {r4, lr}
 1050              	.LCFI8:
 1051              		.cfi_def_cfa_offset 8
1706:../uvc.c      **** {
 1052              		.loc 1 1706 0
 1053 0800 0120A0E1 		mov	r2, r1
1707:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1054              		.loc 1 1707 0
 1055 0804 1080BD18 		ldmnefd	sp!, {r4, pc}
 1056              		.cfi_offset 14, -4
 1057              		.cfi_offset 4, -8
 1058              	.LVL83:
 1059              	.LBB52:
 1060              	.LBB53:
1604:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1061              		.loc 1 1604 0
 1062 0808 CC309FE5 		ldr	r3, .L87
 1063 080c 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 1064 0810 030053E3 		cmp	r3, #3
 1065 0814 2100000A 		beq	.L86
1630:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1066              		.loc 1 1630 0
 1067 0818 020053E3 		cmp	r3, #2
 1068 081c 1080BD18 		ldmnefd	sp!, {r4, pc}
1632:../uvc.c      ****         switch (stateId)
 1069              		.loc 1 1632 0
 1070 0820 080041E2 		sub	r0, r1, #8
 1071              	.LVL84:
 1072 0824 0A0050E3 		cmp	r0, #10
 1073 0828 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1074 082c 230000EA 		b	.L79
 1075              	.L81:
 1076 0830 60080000 		.word	.L76
 1077 0834 C0080000 		.word	.L79
 1078 0838 C0080000 		.word	.L79
 1079 083c 5C080000 		.word	.L72
 1080 0840 C0080000 		.word	.L79
 1081 0844 C0080000 		.word	.L79
 1082 0848 C0080000 		.word	.L79
 1083 084c 98080000 		.word	.L85
 1084 0850 C0080000 		.word	.L79
 1085 0854 C0080000 		.word	.L79
 1086 0858 5C080000 		.word	.L72
 1087              	.LVL85:
 1088              	.L72:
 1089 085c 1080BDE8 		ldmfd	sp!, {r4, pc}
 1090              	.LVL86:
 1091              	.L76:
1615:../uvc.c      ****                 socket = 0;
 1092              		.loc 1 1615 0
 1093 0860 0010A0E3 		mov	r1, #0
 1094              	.LVL87:
 1095              	.L77:
1689:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1096              		.loc 1 1689 0
 1097 0864 74009FE5 		ldr	r0, .L87+4
 1098 0868 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1099              	.LVL88:
1690:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1100              		.loc 1 1690 0
 1101 086c 002050E2 		subs	r2, r0, #0
 1102 0870 F9FFFF0A 		beq	.L72
1692:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1103              		.loc 1 1692 0
 1104 0874 0400A0E3 		mov	r0, #4
 1105              	.LVL89:
 1106 0878 64109FE5 		ldr	r1, .L87+8
 1107 087c FEFFFFEB 		bl	CyU3PDebugPrint
 1108              	.LVL90:
 1109              	.L82:
 1110              	.LBB54:
 1111              	.LBB55:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1112              		.loc 1 1314 0
 1113 0880 60109FE5 		ldr	r1, .L87+12
 1114 0884 0400A0E3 		mov	r0, #4
 1115 0888 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 1116              		.loc 1 1315 0
 1117 088c FA0FA0E3 		mov	r0, #1000
 1118 0890 FEFFFFEB 		bl	_tx_thread_sleep
 1119 0894 F9FFFFEA 		b	.L82
 1120              	.LVL91:
 1121              	.L85:
 1122              	.LBE55:
 1123              	.LBE54:
1659:../uvc.c      ****                 socket = 1;
 1124              		.loc 1 1659 0
 1125 0898 0110A0E3 		mov	r1, #1
 1126              	.LVL92:
 1127 089c F0FFFFEA 		b	.L77
 1128              	.LVL93:
 1129              	.L86:
1606:../uvc.c      ****         switch (stateId)
 1130              		.loc 1 1606 0
 1131 08a0 0B2041E2 		sub	r2, r1, #11
 1132 08a4 030052E3 		cmp	r2, #3
 1133 08a8 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 1134 08ac 060000EA 		b	.L75
 1135              	.L78:
 1136 08b0 60080000 		.word	.L76
 1137 08b4 98080000 		.word	.L85
 1138 08b8 5C080000 		.word	.L72
 1139 08bc 5C080000 		.word	.L72
 1140              	.LVL94:
 1141              	.L79:
1678:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1142              		.loc 1 1678 0
 1143 08c0 24109FE5 		ldr	r1, .L87+16
 1144              	.LVL95:
 1145 08c4 0100A0E3 		mov	r0, #1
 1146 08c8 FEFFFFEB 		bl	CyU3PDebugPrint
 1147              	.LVL96:
 1148              	.L75:
 1149              	.LBE53:
 1150              	.LBE52:
1713:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1151              		.loc 1 1713 0
 1152 08cc 1C109FE5 		ldr	r1, .L87+20
 1153 08d0 0400A0E3 		mov	r0, #4
1716:../uvc.c      **** }
 1154              		.loc 1 1716 0
 1155 08d4 1040BDE8 		ldmfd	sp!, {r4, lr}
1713:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1156              		.loc 1 1713 0
 1157 08d8 FEFFFFEA 		b	CyU3PDebugPrint
 1158              	.L88:
 1159              		.align	2
 1160              	.L87:
 1161 08dc 00000000 		.word	.LANCHOR0
 1162 08e0 00000000 		.word	glChHandleUVCStream
 1163 08e4 A8010000 		.word	.LC11
 1164 08e8 D8010000 		.word	.LC12
 1165 08ec 90010000 		.word	.LC10
 1166 08f0 EC010000 		.word	.LC13
 1167              		.cfi_endproc
 1168              	.LFE12:
 1170              		.align	2
 1171              		.global	I2CCmdHandler
 1173              	I2CCmdHandler:
 1174              	.LFB0:
 334:../uvc.c      **** void I2CCmdHandler(){
 1175              		.loc 1 334 0
 1176              		.cfi_startproc
 1177              		@ args = 0, pretend = 0, frame = 8
 1178              		@ frame_needed = 0, uses_anonymous_args = 0
 1179 08f4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1180              	.LCFI9:
 1181              		.cfi_def_cfa_offset 36
 337:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1182              		.loc 1 337 0
 1183 08f8 FC419FE5 		ldr	r4, .L102
 1184              		.cfi_offset 14, -4
 1185              		.cfi_offset 11, -8
 1186              		.cfi_offset 10, -12
 1187              		.cfi_offset 9, -16
 1188              		.cfi_offset 8, -20
 1189              		.cfi_offset 7, -24
 1190              		.cfi_offset 6, -28
 1191              		.cfi_offset 5, -32
 1192              		.cfi_offset 4, -36
 334:../uvc.c      **** void I2CCmdHandler(){
 1193              		.loc 1 334 0
 1194 08fc 34D04DE2 		sub	sp, sp, #52
 1195              	.LCFI10:
 1196              		.cfi_def_cfa_offset 88
 342:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1197              		.loc 1 342 0
 1198 0900 5410D4E5 		ldrb	r1, [r4, #84]	@ zero_extendqisi2
 337:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1199              		.loc 1 337 0
 1200 0904 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1201              	.LVL97:
 338:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1202              		.loc 1 338 0
 1203 0908 4D60D4E5 		ldrb	r6, [r4, #77]	@ zero_extendqisi2
 1204              	.LVL98:
 342:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1205              		.loc 1 342 0
 1206 090c 4E70D4E5 		ldrb	r7, [r4, #78]	@ zero_extendqisi2
 1207 0910 4FE0D4E5 		ldrb	lr, [r4, #79]	@ zero_extendqisi2
 1208 0914 5080D4E5 		ldrb	r8, [r4, #80]	@ zero_extendqisi2
 1209 0918 51A0D4E5 		ldrb	sl, [r4, #81]	@ zero_extendqisi2
 1210 091c 5290D4E5 		ldrb	r9, [r4, #82]	@ zero_extendqisi2
 1211 0920 53B0D4E5 		ldrb	fp, [r4, #83]	@ zero_extendqisi2
 1212 0924 18108DE5 		str	r1, [sp, #24]
 1213 0928 5530D4E5 		ldrb	r3, [r4, #85]	@ zero_extendqisi2
 1214 092c 0400A0E3 		mov	r0, #4
 1215 0930 1C308DE5 		str	r3, [sp, #28]
 1216 0934 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1217 0938 0630A0E1 		mov	r3, r6
 1218 093c BC119FE5 		ldr	r1, .L102+4
 1219 0940 0520A0E1 		mov	r2, r5
 1220 0944 80408DE8 		stmia	sp, {r7, lr}	@ phole stm
 1221 0948 08808DE5 		str	r8, [sp, #8]
 1222 094c 0CA08DE5 		str	sl, [sp, #12]
 1223 0950 10908DE5 		str	r9, [sp, #16]
 1224 0954 14B08DE5 		str	fp, [sp, #20]
 1225 0958 20C08DE5 		str	ip, [sp, #32]
 1226 095c FEFFFFEB 		bl	CyU3PDebugPrint
 1227              	.LVL99:
 345:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1228              		.loc 1 345 0
 1229 0960 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 1230 0964 520053E3 		cmp	r3, #82
 1231 0968 1A00000A 		beq	.L99
 1232              	.L90:
 355:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1233              		.loc 1 355 0
 1234 096c 000055E3 		cmp	r5, #0
 382:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1235              		.loc 1 382 0
 1236 0970 0030E003 		mvneq	r3, #0
 1237 0974 5730C405 		streqb	r3, [r4, #87]
 355:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1238              		.loc 1 355 0
 1239 0978 0100000A 		beq	.L89
 386:../uvc.c      **** 	}else if(CmdType == 1){
 1240              		.loc 1 386 0
 1241 097c 010055E3 		cmp	r5, #1
 1242 0980 0100000A 		beq	.L100
 1243              	.LVL100:
 1244              	.L89:
 405:../uvc.c      **** }
 1245              		.loc 1 405 0
 1246 0984 34D08DE2 		add	sp, sp, #52
 1247 0988 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1248              	.LVL101:
 1249              	.L100:
 388:../uvc.c      **** 			if(CmdRegLen == 2){
 1250              		.loc 1 388 0
 1251 098c 020056E3 		cmp	r6, #2
 1252 0990 2300000A 		beq	.L101
 393:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1253              		.loc 1 393 0
 1254 0994 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1255 0998 5C319FE5 		ldr	r3, .L102
 1256 099c FE1001E2 		and	r1, r1, #254
 1257 09a0 820051E3 		cmp	r1, #130
 396:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1258              		.loc 1 396 0
 1259 09a4 5050D315 		ldrneb	r5, [r3, #80]	@ zero_extendqisi2
 1260              	.LVL102:
 393:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1261              		.loc 1 393 0
 1262 09a8 0200001A 		bne	.L98
 393:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1263              		.loc 1 393 0 is_stmt 0 discriminator 1
 1264 09ac 5050D3E5 		ldrb	r5, [r3, #80]	@ zero_extendqisi2
 1265 09b0 300055E3 		cmp	r5, #48
 1266 09b4 3B00000A 		beq	.L96
 1267              	.L98:
 396:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1268              		.loc 1 396 0 is_stmt 1
 1269 09b8 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1270              	.L97:
 398:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 1271              		.loc 1 398 0
 1272 09bc 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1273 09c0 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1274 09c4 FE0002E2 		and	r0, r2, #254
 1275 09c8 0520A0E1 		mov	r2, r5
 1276 09cc 00E08DE5 		str	lr, [sp, #0]
 1277 09d0 FEFFFFEB 		bl	SensorWrite2B
 1278 09d4 EAFFFFEA 		b	.L89
 1279              	.LVL103:
 1280              	.L99:
 345:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1281              		.loc 1 345 0 discriminator 1
 1282 09d8 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1283 09dc 300053E3 		cmp	r3, #48
 1284 09e0 E1FFFF1A 		bne	.L90
 1285 09e4 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1286 09e8 010053E3 		cmp	r3, #1
 1287 09ec DEFFFF1A 		bne	.L90
 347:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 1288              		.loc 1 347 0
 1289 09f0 5520D4E5 		ldrb	r2, [r4, #85]	@ zero_extendqisi2
 1290 09f4 08019FE5 		ldr	r0, .L102+8
 1291 09f8 03E002E2 		and	lr, r2, #3
 1292 09fc 8CE4C0E5 		strb	lr, [r0, #1164]
 348:../uvc.c      **** 		if(is60Hz==CyFalse)
 1293              		.loc 1 348 0
 1294 0a00 58C094E5 		ldr	ip, [r4, #88]
 352:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1295              		.loc 1 352 0
 1296 0a04 FC109FE5 		ldr	r1, .L102+12
 348:../uvc.c      **** 		if(is60Hz==CyFalse)
 1297              		.loc 1 348 0
 1298 0a08 00005CE3 		cmp	ip, #0
 350:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 1299              		.loc 1 350 0
 1300 0a0c 80208203 		orreq	r2, r2, #128
 352:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1301              		.loc 1 352 0
 1302 0a10 8C34D0E5 		ldrb	r3, [r0, #1164]	@ zero_extendqisi2
 350:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 1303              		.loc 1 350 0
 1304 0a14 5520C405 		streqb	r2, [r4, #85]
 352:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1305              		.loc 1 352 0
 1306 0a18 0400A0E3 		mov	r0, #4
 1307 0a1c FEFFFFEB 		bl	CyU3PDebugPrint
 1308 0a20 D1FFFFEA 		b	.L90
 1309              	.L101:
 390:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 1310              		.loc 1 390 0
 1311 0a24 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1312 0a28 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1313 0a2c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1314 0a30 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1315 0a34 0020A0E3 		mov	r2, #0
 1316 0a38 FE0000E2 		and	r0, r0, #254
 1317 0a3c 00E08DE5 		str	lr, [sp, #0]
 1318 0a40 FEFFFFEB 		bl	SensorWrite2B2
 1319 0a44 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1320 0a48 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1321 0a4c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1322 0a50 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1323 0a54 FE0002E2 		and	r0, r2, #254
 1324 0a58 0020A0E3 		mov	r2, #0
 1325 0a5c 00C08DE5 		str	ip, [sp, #0]
 1326 0a60 FEFFFFEB 		bl	SensorWrite2B2
 1327              	.LVL104:
 1328 0a64 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1329 0a68 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1330 0a6c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1331 0a70 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1332 0a74 0020A0E3 		mov	r2, #0
 1333 0a78 FE0000E2 		and	r0, r0, #254
 1334 0a7c 00C08DE5 		str	ip, [sp, #0]
 1335 0a80 FEFFFFEB 		bl	SensorWrite2B2
 1336 0a84 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1337 0a88 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1338 0a8c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1339 0a90 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1340 0a94 FE0002E2 		and	r0, r2, #254
 1341 0a98 0020A0E3 		mov	r2, #0
 1342 0a9c 00C08DE5 		str	ip, [sp, #0]
 1343 0aa0 FEFFFFEB 		bl	SensorWrite2B2
 1344 0aa4 B6FFFFEA 		b	.L89
 1345              	.LVL105:
 1346              	.L96:
 393:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1347              		.loc 1 393 0 discriminator 1
 1348 0aa8 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1349 0aac 100053E3 		cmp	r3, #16
 1350 0ab0 C1FFFF1A 		bne	.L97
 394:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 1351              		.loc 1 394 0
 1352 0ab4 50409FE5 		ldr	r4, .L102+16
 1353 0ab8 0010E0E3 		mvn	r1, #0
 1354 0abc 1C0094E5 		ldr	r0, [r4, #28]
 1355 0ac0 2C308DE5 		str	r3, [sp, #44]
 1356 0ac4 FEFFFFEB 		bl	_txe_mutex_get
 395:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 1357              		.loc 1 395 0
 1358 0ac8 2C309DE5 		ldr	r3, [sp, #44]
 1359 0acc 00C0A0E3 		mov	ip, #0
 1360 0ad0 0320A0E1 		mov	r2, r3
 1361 0ad4 0400A0E1 		mov	r0, r4
 1362 0ad8 1710A0E3 		mov	r1, #23
 1363 0adc 0530A0E1 		mov	r3, r5
 1364 0ae0 00C08DE5 		str	ip, [sp, #0]
 1365 0ae4 04C08DE5 		str	ip, [sp, #4]
 1366 0ae8 FEFFFFEB 		bl	cmdSet
 396:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1367              		.loc 1 396 0
 1368 0aec 1C0094E5 		ldr	r0, [r4, #28]
 405:../uvc.c      **** }
 1369              		.loc 1 405 0
 1370 0af0 34D08DE2 		add	sp, sp, #52
 1371 0af4 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 396:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1372              		.loc 1 396 0
 1373 0af8 FEFFFFEA 		b	_txe_mutex_put
 1374              	.L103:
 1375              		.align	2
 1376              	.L102:
 1377 0afc 00000000 		.word	.LANCHOR0
 1378 0b00 04020000 		.word	.LC14
 1379 0b04 00000000 		.word	.LANCHOR1
 1380 0b08 50020000 		.word	.LC15
 1381 0b0c 00000000 		.word	cmdQu
 1382              		.cfi_endproc
 1383              	.LFE0:
 1385              		.align	2
 1386              		.global	setIrisauto
 1388              	setIrisauto:
 1389              	.LFB1:
 411:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1390              		.loc 1 411 0
 1391              		.cfi_startproc
 1392              		@ args = 0, pretend = 0, frame = 0
 1393              		@ frame_needed = 0, uses_anonymous_args = 0
 1394              	.LVL106:
 1395 0b10 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1396              	.LCFI11:
 1397              		.cfi_def_cfa_offset 16
 1398 0b14 0160A0E1 		mov	r6, r1
 1399              		.cfi_offset 14, -4
 1400              		.cfi_offset 6, -8
 1401              		.cfi_offset 5, -12
 1402              		.cfi_offset 4, -16
 1403 0b18 08D04DE2 		sub	sp, sp, #8
 1404              	.LCFI12:
 1405              		.cfi_def_cfa_offset 24
 415:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1406              		.loc 1 415 0
 1407 0b1c 0050A0E3 		mov	r5, #0
 411:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1408              		.loc 1 411 0
 1409 0b20 0040A0E1 		mov	r4, r0
 414:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1410              		.loc 1 414 0
 1411 0b24 0010E0E3 		mvn	r1, #0
 1412              	.LVL107:
 1413 0b28 1C0090E5 		ldr	r0, [r0, #28]
 1414              	.LVL108:
 1415 0b2c FEFFFFEB 		bl	_txe_mutex_get
 415:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1416              		.loc 1 415 0
 1417 0b30 060065E0 		rsb	r0, r5, r6
 1418 0b34 00C070E2 		rsbs	ip, r0, #0
 1419 0b38 00C0ACE0 		adc	ip, ip, r0
 1420 0b3c 1410A0E3 		mov	r1, #20
 1421 0b40 2720A0E3 		mov	r2, #39
 1422 0b44 3030A0E3 		mov	r3, #48
 1423 0b48 0400A0E1 		mov	r0, r4
 1424 0b4c 00C08DE5 		str	ip, [sp, #0]
 1425 0b50 04508DE5 		str	r5, [sp, #4]
 1426 0b54 FEFFFFEB 		bl	cmdSet
 416:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 1427              		.loc 1 416 0
 1428 0b58 050056E1 		cmp	r6, r5
 1429 0b5c 0260A003 		moveq	r6, #2
 1430 0b60 0560A011 		movne	r6, r5
 1431 0b64 0400A0E1 		mov	r0, r4
 1432 0b68 1510A0E3 		mov	r1, #21
 1433 0b6c 2520A0E3 		mov	r2, #37
 1434 0b70 3030A0E3 		mov	r3, #48
 1435 0b74 00608DE5 		str	r6, [sp, #0]
 1436 0b78 04508DE5 		str	r5, [sp, #4]
 1437 0b7c FEFFFFEB 		bl	cmdSet
 417:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1438              		.loc 1 417 0
 1439 0b80 1C0094E5 		ldr	r0, [r4, #28]
 418:../uvc.c      **** }
 1440              		.loc 1 418 0
 1441 0b84 08D08DE2 		add	sp, sp, #8
 1442 0b88 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 417:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1443              		.loc 1 417 0
 1444 0b8c FEFFFFEA 		b	_txe_mutex_put
 1445              		.cfi_endproc
 1446              	.LFE1:
 1448              		.align	2
 1449              		.global	ControlHandle
 1451              	ControlHandle:
 1452              	.LFB2:
 420:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1453              		.loc 1 420 0
 1454              		.cfi_startproc
 1455              		@ args = 0, pretend = 0, frame = 24
 1456              		@ frame_needed = 0, uses_anonymous_args = 0
 1457              	.LVL109:
 1458 0b90 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1459              	.LCFI13:
 1460              		.cfi_def_cfa_offset 36
 427:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1461              		.loc 1 427 0
 1462 0b94 1F0050E3 		cmp	r0, #31
 426:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1463              		.loc 1 426 0
 1464 0b98 207040E2 		sub	r7, r0, #32
 1465              		.cfi_offset 14, -4
 1466              		.cfi_offset 11, -8
 1467              		.cfi_offset 10, -12
 1468              		.cfi_offset 9, -16
 1469              		.cfi_offset 8, -20
 1470              		.cfi_offset 7, -24
 1471              		.cfi_offset 6, -28
 1472              		.cfi_offset 5, -32
 1473              		.cfi_offset 4, -36
 420:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1474              		.loc 1 420 0
 1475 0b9c 2CD04DE2 		sub	sp, sp, #44
 1476              	.LCFI14:
 1477              		.cfi_def_cfa_offset 80
 420:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1478              		.loc 1 420 0
 1479 0ba0 0040A0E1 		mov	r4, r0
 426:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1480              		.loc 1 426 0
 1481 0ba4 FF7007E2 		and	r7, r7, #255
 1482              	.LVL110:
 427:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1483              		.loc 1 427 0
 1484 0ba8 2300009A 		bls	.L108
 428:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1485              		.loc 1 428 0
 1486 0bac 206F9FE5 		ldr	r6, .L233
 1487 0bb0 872087E0 		add	r2, r7, r7, asl #1
 1488 0bb4 8221A0E1 		mov	r2, r2, asl #3
 1489 0bb8 023086E0 		add	r3, r6, r2
 429:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1490              		.loc 1 429 0
 1491 0bbc 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 430:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1492              		.loc 1 430 0
 1493 0bc0 0FA0D3E5 		ldrb	sl, [r3, #15]	@ zero_extendqisi2
 431:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1494              		.loc 1 431 0
 1495 0bc4 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 442:../uvc.c      ****     reqData = bRequest;
 1496              		.loc 1 442 0
 1497 0bc8 083F9FE5 		ldr	r3, .L233+4
 428:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1498              		.loc 1 428 0
 1499 0bcc 0290D6E7 		ldrb	r9, [r6, r2]	@ zero_extendqisi2
 1500              	.LVL111:
 442:../uvc.c      ****     reqData = bRequest;
 1501              		.loc 1 442 0
 1502 0bd0 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1503              	.LVL112:
 450:../uvc.c      ****     switch (bRequest)
 1504              		.loc 1 450 0
 1505 0bd4 830055E3 		cmp	r5, #131
 1506 0bd8 2200000A 		beq	.L114
 1507              	.LVL113:
 1508              	.L227:
 1509 0bdc 2B00009A 		bls	.L225
 1510 0be0 850055E3 		cmp	r5, #133
 1511 0be4 8400000A 		beq	.L116
 1512 0be8 7200003A 		bcc	.L115
 1513 0bec 860055E3 		cmp	r5, #134
 1514 0bf0 BD00000A 		beq	.L117
 1515 0bf4 870055E3 		cmp	r5, #135
 1516 0bf8 B100000A 		beq	.L226
 1517              	.L110:
 964:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1518              		.loc 1 964 0
 1519 0bfc 0000A0E3 		mov	r0, #0
 1520 0c00 0110A0E3 		mov	r1, #1
 1521 0c04 0020A0E1 		mov	r2, r0
 1522 0c08 FEFFFFEB 		bl	CyU3PUsbStall
 965:../uvc.c      **** 			  break;
 1523              		.loc 1 965 0
 1524 0c0c FFE0A0E3 		mov	lr, #255
 1525 0c10 0E40A0E1 		mov	r4, lr
 1526 0c14 0EC0A0E1 		mov	ip, lr
 1527 0c18 0E30A0E1 		mov	r3, lr
 1528              	.LVL114:
 1529              	.L120:
 967:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1530              		.loc 1 967 0
 1531 0c1c B81E9FE5 		ldr	r1, .L233+8
 1532 0c20 0520A0E1 		mov	r2, r5
 1533 0c24 0400A0E3 		mov	r0, #4
 1534 0c28 00C08DE5 		str	ip, [sp, #0]
 1535 0c2c 10408DE9 		stmib	sp, {r4, lr}	@ phole stm
 1536 0c30 FEFFFFEB 		bl	CyU3PDebugPrint
 968:../uvc.c      **** }
 1537              		.loc 1 968 0
 1538 0c34 2CD08DE2 		add	sp, sp, #44
 1539 0c38 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1540              	.LVL115:
 1541              	.L108:
 433:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1542              		.loc 1 433 0
 1543 0c3c 906E9FE5 		ldr	r6, .L233
 442:../uvc.c      ****     reqData = bRequest;
 1544              		.loc 1 442 0
 1545 0c40 903E9FE5 		ldr	r3, .L233+4
 433:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1546              		.loc 1 433 0
 1547 0c44 805080E0 		add	r5, r0, r0, asl #1
 1548 0c48 850186E0 		add	r0, r6, r5, asl #3
 1549              	.LVL116:
 442:../uvc.c      ****     reqData = bRequest;
 1550              		.loc 1 442 0
 1551 0c4c 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 433:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1552              		.loc 1 433 0
 1553 0c50 8091D0E5 		ldrb	r9, [r0, #384]	@ zero_extendqisi2
 1554              	.LVL117:
 450:../uvc.c      ****     switch (bRequest)
 1555              		.loc 1 450 0
 1556 0c54 830055E3 		cmp	r5, #131
 434:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1557              		.loc 1 434 0
 1558 0c58 81B1D0E5 		ldrb	fp, [r0, #385]	@ zero_extendqisi2
 1559              	.LVL118:
 435:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1560              		.loc 1 435 0
 1561 0c5c 8FA1D0E5 		ldrb	sl, [r0, #399]	@ zero_extendqisi2
 1562              	.LVL119:
 436:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1563              		.loc 1 436 0
 1564 0c60 8281D0E5 		ldrb	r8, [r0, #386]	@ zero_extendqisi2
 1565              	.LVL120:
 450:../uvc.c      ****     switch (bRequest)
 1566              		.loc 1 450 0
 1567 0c64 DCFFFF1A 		bne	.L227
 1568              	.LVL121:
 1569              	.L114:
 584:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1570              		.loc 1 584 0
 1571 0c68 1F0054E3 		cmp	r4, #31
 1572 0c6c BC00009A 		bls	.L145
 585:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1573              		.loc 1 585 0
 1574 0c70 877087E0 		add	r7, r7, r7, asl #1
 1575              	.LVL122:
 1576 0c74 876186E0 		add	r6, r6, r7, asl #3
 1577 0c78 94AE9FE5 		ldr	sl, .L233+64
 1578 0c7c 0500D6E5 		ldrb	r0, [r6, #5]	@ zero_extendqisi2
 586:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1579              		.loc 1 586 0
 1580 0c80 06C0D6E5 		ldrb	ip, [r6, #6]	@ zero_extendqisi2
 585:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1581              		.loc 1 585 0
 1582 0c84 5C00CAE5 		strb	r0, [sl, #92]
 586:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1583              		.loc 1 586 0
 1584 0c88 5DC0CAE5 		strb	ip, [sl, #93]
 1585 0c8c 0B0000EA 		b	.L153
 1586              	.LVL123:
 1587              	.L225:
 450:../uvc.c      ****     switch (bRequest)
 1588              		.loc 1 450 0
 1589 0c90 810055E3 		cmp	r5, #129
 1590 0c94 6400000A 		beq	.L112
 1591 0c98 1000009A 		bls	.L228
 565:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1592              		.loc 1 565 0
 1593 0c9c 1F0054E3 		cmp	r4, #31
 1594 0ca0 A300009A 		bls	.L142
 566:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1595              		.loc 1 566 0
 1596 0ca4 877087E0 		add	r7, r7, r7, asl #1
 1597              	.LVL124:
 1598 0ca8 876186E0 		add	r6, r6, r7, asl #3
 1599 0cac 60AE9FE5 		ldr	sl, .L233+64
 1600 0cb0 0320D6E5 		ldrb	r2, [r6, #3]	@ zero_extendqisi2
 567:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1601              		.loc 1 567 0
 1602 0cb4 04E0D6E5 		ldrb	lr, [r6, #4]	@ zero_extendqisi2
 566:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1603              		.loc 1 566 0
 1604 0cb8 5C20CAE5 		strb	r2, [sl, #92]
 567:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1605              		.loc 1 567 0
 1606 0cbc 5DE0CAE5 		strb	lr, [sl, #93]
 1607              	.L153:
 643:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1608              		.loc 1 643 0
 1609 0cc0 0800A0E1 		mov	r0, r8
 1610 0cc4 141E9FE5 		ldr	r1, .L233+12
 1611 0cc8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1612              	.LVL125:
 645:../uvc.c      **** 			  break;
 1613              		.loc 1 645 0
 1614 0ccc FFE0A0E3 		mov	lr, #255
 643:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1615              		.loc 1 643 0
 1616 0cd0 5C40DAE5 		ldrb	r4, [sl, #92]	@ zero_extendqisi2
 645:../uvc.c      **** 			  break;
 1617              		.loc 1 645 0
 1618 0cd4 0EC0A0E1 		mov	ip, lr
 1619 0cd8 0E30A0E1 		mov	r3, lr
 1620 0cdc CEFFFFEA 		b	.L120
 1621              	.LVL126:
 1622              	.L228:
 450:../uvc.c      ****     switch (bRequest)
 1623              		.loc 1 450 0
 1624 0ce0 010055E3 		cmp	r5, #1
 1625 0ce4 C4FFFF1A 		bne	.L110
 647:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1626              		.loc 1 647 0
 1627 0ce8 241E9FE5 		ldr	r1, .L233+64
 1628 0cec 26208DE2 		add	r2, sp, #38
 1629 0cf0 2000A0E3 		mov	r0, #32
 1630 0cf4 5C1081E2 		add	r1, r1, #92
 1631 0cf8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1632              	.LVL127:
 649:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1633              		.loc 1 649 0
 1634 0cfc 002050E2 		subs	r2, r0, #0
 1635 0d00 0603001A 		bne	.L155
 651:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1636              		.loc 1 651 0
 1637 0d04 08EE9FE5 		ldr	lr, .L233+64
 1638 0d08 5C30DEE5 		ldrb	r3, [lr, #92]	@ zero_extendqisi2
 652:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1639              		.loc 1 652 0
 1640 0d0c 00EE9FE5 		ldr	lr, .L233+64
 651:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1641              		.loc 1 651 0
 1642 0d10 18308DE5 		str	r3, [sp, #24]
 1643              	.LVL128:
 654:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1644              		.loc 1 654 0
 1645 0d14 5E00DEE5 		ldrb	r0, [lr, #94]	@ zero_extendqisi2
 1646              	.LVL129:
 652:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1647              		.loc 1 652 0
 1648 0d18 5DC0DEE5 		ldrb	ip, [lr, #93]	@ zero_extendqisi2
 1649              	.LVL130:
 654:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1650              		.loc 1 654 0
 1651 0d1c 1C008DE5 		str	r0, [sp, #28]
 1652              	.LVL131:
 658:../uvc.c      **** 				  switch(CtrlID)
 1653              		.loc 1 658 0
 1654 0d20 220054E3 		cmp	r4, #34
 1655 0d24 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1656 0d28 CE0200EA 		b	.L156
 1657              	.L171:
 1658 0d2c D0180000 		.word	.L157
 1659 0d30 00180000 		.word	.L158
 1660 0d34 68180000 		.word	.L156
 1661 0d38 68180000 		.word	.L156
 1662 0d3c 9C170000 		.word	.L159
 1663 0d40 58160000 		.word	.L160
 1664 0d44 DC150000 		.word	.L161
 1665 0d48 68180000 		.word	.L156
 1666 0d4c 68180000 		.word	.L156
 1667 0d50 68180000 		.word	.L156
 1668 0d54 68180000 		.word	.L156
 1669 0d58 54150000 		.word	.L162
 1670 0d5c 68180000 		.word	.L156
 1671 0d60 68180000 		.word	.L156
 1672 0d64 68180000 		.word	.L156
 1673 0d68 68180000 		.word	.L156
 1674 0d6c 5C140000 		.word	.L163
 1675 0d70 68180000 		.word	.L156
 1676 0d74 68180000 		.word	.L156
 1677 0d78 68180000 		.word	.L156
 1678 0d7c 68180000 		.word	.L156
 1679 0d80 68180000 		.word	.L156
 1680 0d84 68180000 		.word	.L156
 1681 0d88 68180000 		.word	.L156
 1682 0d8c 68180000 		.word	.L156
 1683 0d90 A0130000 		.word	.L164
 1684 0d94 68180000 		.word	.L156
 1685 0d98 68180000 		.word	.L156
 1686 0d9c E4140000 		.word	.L165
 1687 0da0 68180000 		.word	.L156
 1688 0da4 44130000 		.word	.L166
 1689 0da8 C0120000 		.word	.L167
 1690 0dac 28120000 		.word	.L168
 1691 0db0 10120000 		.word	.L169
 1692 0db4 AC110000 		.word	.L170
 1693              	.LVL132:
 1694              	.L115:
 602:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1695              		.loc 1 602 0
 1696 0db8 1F0054E3 		cmp	r4, #31
 603:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1697              		.loc 1 603 0
 1698 0dbc 87708780 		addhi	r7, r7, r7, asl #1
 1699              	.LVL133:
 609:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1700              		.loc 1 609 0
 1701 0dc0 84408490 		addls	r4, r4, r4, asl #1
 603:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1702              		.loc 1 603 0
 1703 0dc4 87618680 		addhi	r6, r6, r7, asl #3
 609:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1704              		.loc 1 609 0
 1705 0dc8 84618690 		addls	r6, r6, r4, asl #3
 603:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1706              		.loc 1 603 0
 1707 0dcc 40AD9F85 		ldrhi	sl, .L233+64
 609:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1708              		.loc 1 609 0
 1709 0dd0 3CAD9F95 		ldrls	sl, .L233+64
 603:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1710              		.loc 1 603 0
 1711 0dd4 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 604:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1712              		.loc 1 604 0
 1713 0dd8 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 609:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1714              		.loc 1 609 0
 1715 0ddc 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 610:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1716              		.loc 1 610 0
 1717 0de0 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 611:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1718              		.loc 1 611 0
 1719 0de4 0030A0E3 		mov	r3, #0
 609:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1720              		.loc 1 609 0
 1721 0de8 5C10CAE5 		strb	r1, [sl, #92]
 610:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1722              		.loc 1 610 0
 1723 0dec 5D20CAE5 		strb	r2, [sl, #93]
 611:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1724              		.loc 1 611 0
 1725 0df0 5E30CAE5 		strb	r3, [sl, #94]
 612:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1726              		.loc 1 612 0
 1727 0df4 5F30CAE5 		strb	r3, [sl, #95]
 1728 0df8 B0FFFFEA 		b	.L153
 1729              	.LVL134:
 1730              	.L116:
 454:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1731              		.loc 1 454 0
 1732 0dfc 104D9FE5 		ldr	r4, .L233+64
 455:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1733              		.loc 1 455 0
 1734 0e00 00C0A0E3 		mov	ip, #0
 1735 0e04 5DC0C4E5 		strb	ip, [r4, #93]
 456:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1736              		.loc 1 456 0
 1737 0e08 5C1084E2 		add	r1, r4, #92
 454:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1738              		.loc 1 454 0
 1739 0e0c 5C80C4E5 		strb	r8, [r4, #92]
 456:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1740              		.loc 1 456 0
 1741 0e10 0200A0E3 		mov	r0, #2
 1742 0e14 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1743              	.LVL135:
 458:../uvc.c      **** 			  break;
 1744              		.loc 1 458 0
 1745 0e18 FFE0A0E3 		mov	lr, #255
 456:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1746              		.loc 1 456 0
 1747 0e1c 5C40D4E5 		ldrb	r4, [r4, #92]	@ zero_extendqisi2
 458:../uvc.c      **** 			  break;
 1748              		.loc 1 458 0
 1749 0e20 0EC0A0E1 		mov	ip, lr
 1750 0e24 0E30A0E1 		mov	r3, lr
 1751 0e28 7BFFFFEA 		b	.L120
 1752              	.LVL136:
 1753              	.L112:
 461:../uvc.c      **** 			 switch(CtrlID)
 1754              		.loc 1 461 0
 1755 0e2c 011044E2 		sub	r1, r4, #1
 1756 0e30 210051E3 		cmp	r1, #33
 1757 0e34 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 1758 0e38 D20000EA 		b	.L121
 1759              	.L129:
 1760 0e3c 5C110000 		.word	.L122
 1761 0e40 88110000 		.word	.L121
 1762 0e44 88110000 		.word	.L121
 1763 0e48 88110000 		.word	.L121
 1764 0e4c 3C110000 		.word	.L123
 1765 0e50 88110000 		.word	.L121
 1766 0e54 88110000 		.word	.L121
 1767 0e58 88110000 		.word	.L121
 1768 0e5c 88110000 		.word	.L121
 1769 0e60 88110000 		.word	.L121
 1770 0e64 18110000 		.word	.L124
 1771 0e68 88110000 		.word	.L121
 1772 0e6c 88110000 		.word	.L121
 1773 0e70 88110000 		.word	.L121
 1774 0e74 88110000 		.word	.L121
 1775 0e78 88110000 		.word	.L121
 1776 0e7c 88110000 		.word	.L121
 1777 0e80 88110000 		.word	.L121
 1778 0e84 88110000 		.word	.L121
 1779 0e88 88110000 		.word	.L121
 1780 0e8c 88110000 		.word	.L121
 1781 0e90 88110000 		.word	.L121
 1782 0e94 88110000 		.word	.L121
 1783 0e98 88110000 		.word	.L121
 1784 0e9c DC100000 		.word	.L125
 1785 0ea0 88110000 		.word	.L121
 1786 0ea4 88110000 		.word	.L121
 1787 0ea8 B4100000 		.word	.L126
 1788 0eac 88110000 		.word	.L121
 1789 0eb0 88110000 		.word	.L121
 1790 0eb4 18100000 		.word	.L127
 1791 0eb8 E00F0000 		.word	.L128
 1792 0ebc E00F0000 		.word	.L128
 1793 0ec0 E00F0000 		.word	.L128
 1794              	.L226:
 629:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1795              		.loc 1 629 0
 1796 0ec4 1F0054E3 		cmp	r4, #31
 1797 0ec8 3100009A 		bls	.L152
 630:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1798              		.loc 1 630 0
 1799 0ecc 877087E0 		add	r7, r7, r7, asl #1
 1800              	.LVL137:
 1801 0ed0 876186E0 		add	r6, r6, r7, asl #3
 1802 0ed4 38AC9FE5 		ldr	sl, .L233+64
 1803 0ed8 0B10D6E5 		ldrb	r1, [r6, #11]	@ zero_extendqisi2
 631:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1804              		.loc 1 631 0
 1805 0edc 0C40D6E5 		ldrb	r4, [r6, #12]	@ zero_extendqisi2
 630:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1806              		.loc 1 630 0
 1807 0ee0 5C10CAE5 		strb	r1, [sl, #92]
 631:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1808              		.loc 1 631 0
 1809 0ee4 5D40CAE5 		strb	r4, [sl, #93]
 1810 0ee8 74FFFFEA 		b	.L153
 1811              	.LVL138:
 1812              	.L117:
 618:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1813              		.loc 1 618 0
 1814 0eec 1F0054E3 		cmp	r4, #31
 622:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1815              		.loc 1 622 0
 1816 0ef0 84408490 		addls	r4, r4, r4, asl #1
 619:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1817              		.loc 1 619 0
 1818 0ef4 87708780 		addhi	r7, r7, r7, asl #1
 1819              	.LVL139:
 622:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1820              		.loc 1 622 0
 1821 0ef8 84618690 		addls	r6, r6, r4, asl #3
 619:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1822              		.loc 1 619 0
 1823 0efc 87618680 		addhi	r6, r6, r7, asl #3
 1824 0f00 0C8C9F85 		ldrhi	r8, .L233+64
 1825 0f04 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 622:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1826              		.loc 1 622 0
 1827 0f08 048C9F95 		ldrls	r8, .L233+64
 1828 0f0c 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 624:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1829              		.loc 1 624 0
 1830 0f10 0100A0E3 		mov	r0, #1
 622:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1831              		.loc 1 622 0
 1832 0f14 5C30C8E5 		strb	r3, [r8, #92]
 624:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1833              		.loc 1 624 0
 1834 0f18 C01B9FE5 		ldr	r1, .L233+12
 1835 0f1c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1836              	.LVL140:
 627:../uvc.c      **** 			  break;
 1837              		.loc 1 627 0
 1838 0f20 FFE0A0E3 		mov	lr, #255
 624:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1839              		.loc 1 624 0
 1840 0f24 5C40D8E5 		ldrb	r4, [r8, #92]	@ zero_extendqisi2
 627:../uvc.c      **** 			  break;
 1841              		.loc 1 627 0
 1842 0f28 0EC0A0E1 		mov	ip, lr
 1843 0f2c 0E30A0E1 		mov	r3, lr
 1844 0f30 39FFFFEA 		b	.L120
 1845              	.LVL141:
 1846              	.L142:
 570:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1847              		.loc 1 570 0
 1848 0f34 0B0054E3 		cmp	r4, #11
 577:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1849              		.loc 1 577 0
 1850 0f38 84408410 		addne	r4, r4, r4, asl #1
 1851 0f3c 84618610 		addne	r6, r6, r4, asl #3
 1852 0f40 CCAB9F15 		ldrne	sl, .L233+64
 571:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1853              		.loc 1 571 0
 1854 0f44 C8AB9F05 		ldreq	sl, .L233+64
 1855 0f48 943B9F05 		ldreq	r3, .L233+16
 577:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1856              		.loc 1 577 0
 1857 0f4c 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 578:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1858              		.loc 1 578 0
 1859 0f50 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 571:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1860              		.loc 1 571 0
 1861 0f54 5C308A05 		streq	r3, [sl, #92]
 577:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1862              		.loc 1 577 0
 1863 0f58 5C20CA15 		strneb	r2, [sl, #92]
 578:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1864              		.loc 1 578 0
 1865 0f5c 5D30CA15 		strneb	r3, [sl, #93]
 1866 0f60 56FFFFEA 		b	.L153
 1867              	.L145:
 588:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1868              		.loc 1 588 0
 1869 0f64 0B0054E3 		cmp	r4, #11
 595:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1870              		.loc 1 595 0
 1871 0f68 84408410 		addne	r4, r4, r4, asl #1
 1872 0f6c 84618610 		addne	r6, r6, r4, asl #3
 1873 0f70 9CAB9F15 		ldrne	sl, .L233+64
 589:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1874              		.loc 1 589 0
 1875 0f74 98AB9F05 		ldreq	sl, .L233+64
 1876 0f78 683B9F05 		ldreq	r3, .L233+20
 595:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1877              		.loc 1 595 0
 1878 0f7c 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 596:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1879              		.loc 1 596 0
 1880 0f80 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 589:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1881              		.loc 1 589 0
 1882 0f84 5C308A05 		streq	r3, [sl, #92]
 595:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1883              		.loc 1 595 0
 1884 0f88 5C20CA15 		strneb	r2, [sl, #92]
 596:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1885              		.loc 1 596 0
 1886 0f8c 5D30CA15 		strneb	r3, [sl, #93]
 1887 0f90 4AFFFFEA 		b	.L153
 1888              	.L152:
 634:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1889              		.loc 1 634 0
 1890 0f94 0B0054E3 		cmp	r4, #11
 1891 0f98 0700000A 		beq	.L229
 640:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1892              		.loc 1 640 0
 1893 0f9c 84A084E0 		add	sl, r4, r4, asl #1
 1894 0fa0 8A6186E0 		add	r6, r6, sl, asl #3
 1895 0fa4 8B31D6E5 		ldrb	r3, [r6, #395]	@ zero_extendqisi2
 1896 0fa8 64AB9FE5 		ldr	sl, .L233+64
 641:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1897              		.loc 1 641 0
 1898 0fac 8C01D6E5 		ldrb	r0, [r6, #396]	@ zero_extendqisi2
 640:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1899              		.loc 1 640 0
 1900 0fb0 5C30CAE5 		strb	r3, [sl, #92]
 641:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1901              		.loc 1 641 0
 1902 0fb4 5D00CAE5 		strb	r0, [sl, #93]
 1903 0fb8 40FFFFEA 		b	.L153
 1904              	.L229:
 635:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1905              		.loc 1 635 0
 1906 0fbc 50AB9FE5 		ldr	sl, .L233+64
 1907 0fc0 93C2D6E5 		ldrb	ip, [r6, #659]	@ zero_extendqisi2
 637:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1908              		.loc 1 637 0
 1909 0fc4 9422D6E5 		ldrb	r2, [r6, #660]	@ zero_extendqisi2
 636:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1910              		.loc 1 636 0
 1911 0fc8 00E0A0E3 		mov	lr, #0
 635:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1912              		.loc 1 635 0
 1913 0fcc 5CC0CAE5 		strb	ip, [sl, #92]
 636:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1914              		.loc 1 636 0
 1915 0fd0 5DE0CAE5 		strb	lr, [sl, #93]
 637:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1916              		.loc 1 637 0
 1917 0fd4 5E20CAE5 		strb	r2, [sl, #94]
 638:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 1918              		.loc 1 638 0
 1919 0fd8 5FE0CAE5 		strb	lr, [sl, #95]
 1920 0fdc 37FFFFEA 		b	.L153
 1921              	.L128:
 467:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1922              		.loc 1 467 0
 1923 0fe0 877087E0 		add	r7, r7, r7, asl #1
 1924              	.LVL142:
 1925 0fe4 876186E0 		add	r6, r6, r7, asl #3
 1926 0fe8 24EB9FE5 		ldr	lr, .L233+64
 1927 0fec 0D40D6E5 		ldrb	r4, [r6, #13]	@ zero_extendqisi2
 468:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1928              		.loc 1 468 0
 1929 0ff0 0E60D6E5 		ldrb	r6, [r6, #14]	@ zero_extendqisi2
 467:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1930              		.loc 1 467 0
 1931 0ff4 5C40CEE5 		strb	r4, [lr, #92]
 468:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1932              		.loc 1 468 0
 1933 0ff8 5D60CEE5 		strb	r6, [lr, #93]
 1934              	.LVL143:
 1935              	.L132:
 558:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1936              		.loc 1 558 0
 1937 0ffc 0800A0E1 		mov	r0, r8
 1938 1000 D81A9FE5 		ldr	r1, .L233+12
 1939 1004 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 563:../uvc.c      **** 			  break;
 1940              		.loc 1 563 0
 1941 1008 FFC0A0E3 		mov	ip, #255
 558:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1942              		.loc 1 558 0
 1943 100c 06E0A0E1 		mov	lr, r6
 563:../uvc.c      **** 			  break;
 1944              		.loc 1 563 0
 1945 1010 0C30A0E1 		mov	r3, ip
 1946 1014 00FFFFEA 		b	.L120
 1947              	.LVL144:
 1948              	.L127:
 488:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1949              		.loc 1 488 0 discriminator 1
 1950 1018 000058E3 		cmp	r8, #0
 1951 101c 9202000A 		beq	.L221
 486:../uvc.c      **** 					 break;
 1952              		.loc 1 486 0
 1953 1020 28E1A0E1 		mov	lr, r8, lsr #2
 1954 1024 00005EE3 		cmp	lr, #0
 1955 1028 03005813 		cmpne	r8, #3
 1956 102c 0020A083 		movhi	r2, #0
 1957 1030 0120A093 		movls	r2, #1
 420:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1958              		.loc 1 420 0
 1959 1034 0E31A0E1 		mov	r3, lr, asl #2
 486:../uvc.c      **** 					 break;
 1960              		.loc 1 486 0
 1961 1038 CA02009A 		bls	.L203
 1962 103c 9C1A9FE5 		ldr	r1, .L233+12
 1963 1040 100041E2 		sub	r0, r1, #16
 1964              	.LVL145:
 1965              	.L137:
 489:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1966              		.loc 1 489 0 discriminator 2
 1967 1044 044090E4 		ldr	r4, [r0], #4
 1968 1048 01C082E2 		add	ip, r2, #1
 1969 104c FF200CE2 		and	r2, ip, #255
 1970 1050 02005EE1 		cmp	lr, r2
 1971 1054 044081E4 		str	r4, [r1], #4
 1972 1058 F9FFFF8A 		bhi	.L137
 489:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1973              		.loc 1 489 0 is_stmt 0
 1974 105c 030058E1 		cmp	r8, r3
 1975 1060 AC0A9F15 		ldrne	r0, .L233+64
 1976 1064 8002000A 		beq	.L221
 1977              	.L213:
 1978 1068 03E080E0 		add	lr, r0, r3
 1979 106c 4C10DEE5 		ldrb	r1, [lr, #76]	@ zero_extendqisi2
 488:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1980              		.loc 1 488 0 is_stmt 1
 1981 1070 016083E2 		add	r6, r3, #1
 1982 1074 FF3006E2 		and	r3, r6, #255
 1983              	.LVL146:
 1984 1078 030058E1 		cmp	r8, r3
 489:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1985              		.loc 1 489 0
 1986 107c 5C10CEE5 		strb	r1, [lr, #92]
 488:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1987              		.loc 1 488 0
 1988 1080 F8FFFF8A 		bhi	.L213
 1989              	.LVL147:
 1990              	.L131:
 498:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1991              		.loc 1 498 0
 1992 1084 5720D0E5 		ldrb	r2, [r0, #87]	@ zero_extendqisi2
 491:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1993              		.loc 1 491 0
 1994 1088 843A9FE5 		ldr	r3, .L233+64
 498:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1995              		.loc 1 498 0
 1996 108c FF0052E3 		cmp	r2, #255
 491:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1997              		.loc 1 491 0
 1998 1090 6540D0E5 		ldrb	r4, [r0, #101]	@ zero_extendqisi2
 1999              	.LVL148:
 492:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 2000              		.loc 1 492 0
 2001 1094 6660D0E5 		ldrb	r6, [r0, #102]	@ zero_extendqisi2
 2002              	.LVL149:
 498:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2003              		.loc 1 498 0
 2004 1098 D7FFFF0A 		beq	.L132
 500:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 2005              		.loc 1 500 0
 2006 109c 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 2007 10a0 441A9FE5 		ldr	r1, .L233+24
 2008 10a4 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 2009 10a8 0400A0E3 		mov	r0, #4
 2010 10ac FEFFFFEB 		bl	CyU3PDebugPrint
 2011 10b0 D1FFFFEA 		b	.L132
 2012              	.LVL150:
 2013              	.L126:
 475:../uvc.c      **** 					 if(CamMode == 1){//720p
 2014              		.loc 1 475 0
 2015 10b4 587A9FE5 		ldr	r7, .L233+64
 2016              	.LVL151:
 474:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 2017              		.loc 1 474 0
 2018 10b8 2D44D6E5 		ldrb	r4, [r6, #1069]	@ zero_extendqisi2
 2019              	.LVL152:
 475:../uvc.c      **** 					 if(CamMode == 1){//720p
 2020              		.loc 1 475 0
 2021 10bc 7C20D7E5 		ldrb	r2, [r7, #124]	@ zero_extendqisi2
 2022 10c0 010052E3 		cmp	r2, #1
 2023 10c4 1D02000A 		beq	.L230
 2024              	.LVL153:
 2025              	.L133:
 485:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2026              		.loc 1 485 0
 2027 10c8 0000A0E3 		mov	r0, #0
 484:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 2028              		.loc 1 484 0
 2029 10cc 5C40C7E5 		strb	r4, [r7, #92]
 485:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2030              		.loc 1 485 0
 2031 10d0 5D00C7E5 		strb	r0, [r7, #93]
 438:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2032              		.loc 1 438 0
 2033 10d4 FF60A0E3 		mov	r6, #255
 486:../uvc.c      **** 					 break;
 2034              		.loc 1 486 0
 2035 10d8 C7FFFFEA 		b	.L132
 2036              	.LVL154:
 2037              	.L125:
 504:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 2038              		.loc 1 504 0
 2039 10dc E543D6E5 		ldrb	r4, [r6, #997]	@ zero_extendqisi2
 2040 10e0 2CCA9FE5 		ldr	ip, .L233+64
 506:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 2041              		.loc 1 506 0
 2042 10e4 E663D6E5 		ldrb	r6, [r6, #998]	@ zero_extendqisi2
 505:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2043              		.loc 1 505 0
 2044 10e8 00E0A0E3 		mov	lr, #0
 504:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 2045              		.loc 1 504 0
 2046 10ec 5C40CCE5 		strb	r4, [ip, #92]
 505:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2047              		.loc 1 505 0
 2048 10f0 5DE0CCE5 		strb	lr, [ip, #93]
 506:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 2049              		.loc 1 506 0
 2050 10f4 5E60CCE5 		strb	r6, [ip, #94]
 507:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2051              		.loc 1 507 0
 2052 10f8 5FE0CCE5 		strb	lr, [ip, #95]
 2053              	.LVL155:
 510:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 2054              		.loc 1 510 0
 2055 10fc EC199FE5 		ldr	r1, .L233+28
 2056 1100 0420A0E1 		mov	r2, r4
 2057 1104 0E30A0E1 		mov	r3, lr
 2058 1108 0400A0E3 		mov	r0, #4
 2059 110c 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 2060 1110 FEFFFFEB 		bl	CyU3PDebugPrint
 511:../uvc.c      **** 					 break;
 2061              		.loc 1 511 0
 2062 1114 B8FFFFEA 		b	.L132
 2063              	.LVL156:
 2064              	.L124:
 543:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2065              		.loc 1 543 0
 2066 1118 F4C99FE5 		ldr	ip, .L233+64
 2067 111c 9044D6E5 		ldrb	r4, [r6, #1168]	@ zero_extendqisi2
 545:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2068              		.loc 1 545 0
 2069 1120 9264D6E5 		ldrb	r6, [r6, #1170]	@ zero_extendqisi2
 544:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2070              		.loc 1 544 0
 2071 1124 00E0A0E3 		mov	lr, #0
 543:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2072              		.loc 1 543 0
 2073 1128 5C40CCE5 		strb	r4, [ip, #92]
 544:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2074              		.loc 1 544 0
 2075 112c 5DE0CCE5 		strb	lr, [ip, #93]
 545:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2076              		.loc 1 545 0
 2077 1130 5E60CCE5 		strb	r6, [ip, #94]
 546:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2078              		.loc 1 546 0
 2079 1134 5FE0CCE5 		strb	lr, [ip, #95]
 2080              	.LVL157:
 549:../uvc.c      **** 					 break;
 2081              		.loc 1 549 0
 2082 1138 AFFFFFEA 		b	.L132
 2083              	.LVL158:
 2084              	.L123:
 538:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2085              		.loc 1 538 0
 2086 113c 0522D6E5 		ldrb	r2, [r6, #517]	@ zero_extendqisi2
 2087 1140 CC699FE5 		ldr	r6, .L233+64
 2088 1144 804022E2 		eor	r4, r2, #128
 539:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2089              		.loc 1 539 0
 2090 1148 0010A0E3 		mov	r1, #0
 538:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2091              		.loc 1 538 0
 2092 114c 5C40C6E5 		strb	r4, [r6, #92]
 539:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2093              		.loc 1 539 0
 2094 1150 5D10C6E5 		strb	r1, [r6, #93]
 2095              	.LVL159:
 438:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2096              		.loc 1 438 0
 2097 1154 FF60A0E3 		mov	r6, #255
 541:../uvc.c      **** 					 break;
 2098              		.loc 1 541 0
 2099 1158 A7FFFFEA 		b	.L132
 2100              	.LVL160:
 2101              	.L122:
 526:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 2102              		.loc 1 526 0
 2103 115c A541D6E5 		ldrb	r4, [r6, #421]	@ zero_extendqisi2
 2104              	.LVL161:
 532:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 2105              		.loc 1 532 0
 2106 1160 AC399FE5 		ldr	r3, .L233+64
 527:../uvc.c      **** 					  if(Data0&0x80){
 2107              		.loc 1 527 0
 2108 1164 800014E3 		tst	r4, #128
 528:../uvc.c      **** 						  Data0 = ~Data0;
 2109              		.loc 1 528 0
 2110 1168 0440E011 		mvnne	r4, r4
 2111              	.LVL162:
 530:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 2112              		.loc 1 530 0
 2113 116c 80404402 		subeq	r4, r4, #128
 2114 1170 FF4004E2 		and	r4, r4, #255
 2115              	.LVL163:
 533:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2116              		.loc 1 533 0
 2117 1174 0000A0E3 		mov	r0, #0
 532:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 2118              		.loc 1 532 0
 2119 1178 5C40C3E5 		strb	r4, [r3, #92]
 533:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2120              		.loc 1 533 0
 2121 117c 5D00C3E5 		strb	r0, [r3, #93]
 2122              	.LVL164:
 438:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2123              		.loc 1 438 0
 2124 1180 FF60A0E3 		mov	r6, #255
 535:../uvc.c      **** 			 		 break;
 2125              		.loc 1 535 0
 2126 1184 9CFFFFEA 		b	.L132
 2127              	.LVL165:
 2128              	.L121:
 552:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2129              		.loc 1 552 0
 2130 1188 841084E0 		add	r1, r4, r4, asl #1
 2131 118c 814186E0 		add	r4, r6, r1, asl #3
 2132 1190 7C399FE5 		ldr	r3, .L233+64
 2133 1194 8D41D4E5 		ldrb	r4, [r4, #397]	@ zero_extendqisi2
 553:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2134              		.loc 1 553 0
 2135 1198 0000A0E3 		mov	r0, #0
 438:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2136              		.loc 1 438 0
 2137 119c FF60A0E3 		mov	r6, #255
 552:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2138              		.loc 1 552 0
 2139 11a0 5C40C3E5 		strb	r4, [r3, #92]
 553:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2140              		.loc 1 553 0
 2141 11a4 5D00C3E5 		strb	r0, [r3, #93]
 2142              	.LVL166:
 555:../uvc.c      **** 					 break;
 2143              		.loc 1 555 0
 2144 11a8 93FFFFEA 		b	.L132
 2145              	.LVL167:
 2146              	.L170:
 789:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2147              		.loc 1 789 0
 2148 11ac 40499FE5 		ldr	r4, .L233+32
 2149 11b0 0010E0E3 		mvn	r1, #0
 2150 11b4 1C0094E5 		ldr	r0, [r4, #28]
 2151 11b8 FEFFFFEB 		bl	_txe_mutex_get
 2152              	.LVL168:
 790:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2153              		.loc 1 790 0
 2154 11bc 2210A0E3 		mov	r1, #34
 2155              	.L224:
 2156 11c0 18C09DE5 		ldr	ip, [sp, #24]
 2157 11c4 00E0A0E3 		mov	lr, #0
 2158 11c8 0A30A0E1 		mov	r3, sl
 2159 11cc 0920A0E1 		mov	r2, r9
 2160 11d0 0400A0E1 		mov	r0, r4
 2161 11d4 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2162 11d8 FEFFFFEB 		bl	cmdSet
 791:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2163              		.loc 1 791 0
 2164 11dc 1C0094E5 		ldr	r0, [r4, #28]
 2165 11e0 FEFFFFEB 		bl	_txe_mutex_put
 792:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2166              		.loc 1 792 0
 2167 11e4 18109DE5 		ldr	r1, [sp, #24]
 2168 11e8 877087E0 		add	r7, r7, r7, asl #1
 2169              	.LVL169:
 2170 11ec 876186E0 		add	r6, r6, r7, asl #3
 793:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2171              		.loc 1 793 0
 2172 11f0 0130A0E3 		mov	r3, #1
 794:../uvc.c      **** 							 break;
 2173              		.loc 1 794 0
 2174 11f4 FFE0A0E3 		mov	lr, #255
 793:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2175              		.loc 1 793 0
 2176 11f8 1030C6E5 		strb	r3, [r6, #16]
 792:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2177              		.loc 1 792 0
 2178 11fc 0D10C6E5 		strb	r1, [r6, #13]
 793:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2179              		.loc 1 793 0
 2180 1200 0130A0E1 		mov	r3, r1
 2181 1204 1CC09DE5 		ldr	ip, [sp, #28]
 794:../uvc.c      **** 							 break;
 2182              		.loc 1 794 0
 2183 1208 0E40A0E1 		mov	r4, lr
 2184 120c 82FEFFEA 		b	.L120
 2185              	.LVL170:
 2186              	.L169:
 781:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2187              		.loc 1 781 0
 2188 1210 DC489FE5 		ldr	r4, .L233+32
 2189 1214 0010E0E3 		mvn	r1, #0
 2190 1218 1C0094E5 		ldr	r0, [r4, #28]
 2191 121c FEFFFFEB 		bl	_txe_mutex_get
 2192              	.LVL171:
 782:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2193              		.loc 1 782 0
 2194 1220 2110A0E3 		mov	r1, #33
 2195 1224 E5FFFFEA 		b	.L224
 2196              	.LVL172:
 2197              	.L168:
 767:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2198              		.loc 1 767 0
 2199 1228 C4489FE5 		ldr	r4, .L233+32
 2200 122c 0010E0E3 		mvn	r1, #0
 2201 1230 1C0094E5 		ldr	r0, [r4, #28]
 2202 1234 14C08DE5 		str	ip, [sp, #20]
 2203 1238 FEFFFFEB 		bl	_txe_mutex_get
 2204              	.LVL173:
 766:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2205              		.loc 1 766 0
 2206 123c 18209DE5 		ldr	r2, [sp, #24]
 769:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2207              		.loc 1 769 0
 2208 1240 00E0A0E3 		mov	lr, #0
 766:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2209              		.loc 1 766 0
 2210 1244 7F8002E2 		and	r8, r2, #127
 2211 1248 1C808DE5 		str	r8, [sp, #28]
 2212              	.LVL174:
 769:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2213              		.loc 1 769 0
 2214 124c 1CC09DE5 		ldr	ip, [sp, #28]
 2215 1250 2010A0E3 		mov	r1, #32
 2216 1254 0920A0E1 		mov	r2, r9
 2217 1258 0A30A0E1 		mov	r3, sl
 2218 125c 0400A0E1 		mov	r0, r4
 2219 1260 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2220 1264 FEFFFFEB 		bl	cmdSet
 2221              	.LVL175:
 771:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2222              		.loc 1 771 0
 2223 1268 14C09DE5 		ldr	ip, [sp, #20]
 2224 126c 0A30A0E1 		mov	r3, sl
 2225 1270 0180A0E3 		mov	r8, #1
 2226 1274 2010A0E3 		mov	r1, #32
 2227 1278 0B20A0E1 		mov	r2, fp
 2228 127c 0400A0E1 		mov	r0, r4
 2229 1280 00C08DE5 		str	ip, [sp, #0]
 2230 1284 04808DE5 		str	r8, [sp, #4]
 2231 1288 FEFFFFEB 		bl	cmdSet
 772:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2232              		.loc 1 772 0
 2233 128c 1C0094E5 		ldr	r0, [r4, #28]
 2234 1290 FEFFFFEB 		bl	_txe_mutex_put
 2235              	.LVL176:
 775:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2236              		.loc 1 775 0
 2237 1294 1C009DE5 		ldr	r0, [sp, #28]
 2238 1298 877087E0 		add	r7, r7, r7, asl #1
 2239              	.LVL177:
 2240 129c 876186E0 		add	r6, r6, r7, asl #3
 2241 12a0 0D00C6E5 		strb	r0, [r6, #13]
 776:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2242              		.loc 1 776 0
 2243 12a4 14C09DE5 		ldr	ip, [sp, #20]
 778:../uvc.c      **** 							 break;
 2244              		.loc 1 778 0
 2245 12a8 FFE0A0E3 		mov	lr, #255
 776:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2246              		.loc 1 776 0
 2247 12ac 0EC0C6E5 		strb	ip, [r6, #14]
 777:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2248              		.loc 1 777 0
 2249 12b0 1080C6E5 		strb	r8, [r6, #16]
 2250 12b4 18309DE5 		ldr	r3, [sp, #24]
 778:../uvc.c      **** 							 break;
 2251              		.loc 1 778 0
 2252 12b8 0E40A0E1 		mov	r4, lr
 2253 12bc 56FEFFEA 		b	.L120
 2254              	.LVL178:
 2255              	.L167:
 738:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2256              		.loc 1 738 0 discriminator 1
 2257 12c0 000058E3 		cmp	r8, #0
 2258 12c4 1800000A 		beq	.L173
 736:../uvc.c      **** 							 break;
 2259              		.loc 1 736 0
 2260 12c8 28E1A0E1 		mov	lr, r8, lsr #2
 2261 12cc 00005EE3 		cmp	lr, #0
 2262 12d0 03005813 		cmpne	r8, #3
 2263 12d4 0020A083 		movhi	r2, #0
 2264 12d8 0120A093 		movls	r2, #1
 2265              	.LVL179:
 420:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2266              		.loc 1 420 0
 2267 12dc 0E31A0E1 		mov	r3, lr, asl #2
 736:../uvc.c      **** 							 break;
 2268              		.loc 1 736 0
 2269 12e0 2302009A 		bls	.L204
 2270 12e4 0C189FE5 		ldr	r1, .L233+36
 2271 12e8 100081E2 		add	r0, r1, #16
 2272              	.LVL180:
 2273              	.L184:
 739:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2274              		.loc 1 739 0 discriminator 2
 2275 12ec 044090E4 		ldr	r4, [r0], #4
 2276 12f0 012082E2 		add	r2, r2, #1
 2277 12f4 FF2002E2 		and	r2, r2, #255
 2278 12f8 02005EE1 		cmp	lr, r2
 2279 12fc 044081E4 		str	r4, [r1], #4
 2280 1300 F9FFFF8A 		bhi	.L184
 739:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2281              		.loc 1 739 0 is_stmt 0
 2282 1304 030058E1 		cmp	r8, r3
 2283 1308 0700000A 		beq	.L173
 2284              	.LVL181:
 2285              	.L214:
 2286 130c 00C89FE5 		ldr	ip, .L233+64
 2287 1310 03E08CE0 		add	lr, ip, r3
 2288 1314 5C10DEE5 		ldrb	r1, [lr, #92]	@ zero_extendqisi2
 738:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2289              		.loc 1 738 0 is_stmt 1
 2290 1318 013083E2 		add	r3, r3, #1
 2291 131c FF3003E2 		and	r3, r3, #255
 2292              	.LVL182:
 2293 1320 030058E1 		cmp	r8, r3
 739:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2294              		.loc 1 739 0
 2295 1324 4C10CEE5 		strb	r1, [lr, #76]
 738:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2296              		.loc 1 738 0
 2297 1328 F7FFFF8A 		bhi	.L214
 2298              	.LVL183:
 2299              	.L173:
 741:../uvc.c      **** 					 		I2CCmdHandler();
 2300              		.loc 1 741 0
 2301 132c FEFFFFEB 		bl	I2CCmdHandler
 742:../uvc.c      **** 							 break;
 2302              		.loc 1 742 0
 2303 1330 FFE0A0E3 		mov	lr, #255
 741:../uvc.c      **** 					 		I2CCmdHandler();
 2304              		.loc 1 741 0
 2305 1334 18309DE5 		ldr	r3, [sp, #24]
 2306 1338 1CC09DE5 		ldr	ip, [sp, #28]
 742:../uvc.c      **** 							 break;
 2307              		.loc 1 742 0
 2308 133c 0E40A0E1 		mov	r4, lr
 2309 1340 35FEFFEA 		b	.L120
 2310              	.LVL184:
 2311              	.L166:
 732:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2312              		.loc 1 732 0
 2313 1344 A8479FE5 		ldr	r4, .L233+32
 2314 1348 0010E0E3 		mvn	r1, #0
 2315 134c 1C0094E5 		ldr	r0, [r4, #28]
 2316 1350 FEFFFFEB 		bl	_txe_mutex_get
 2317              	.LVL185:
 733:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2318              		.loc 1 733 0
 2319 1354 18009DE5 		ldr	r0, [sp, #24]
 2320 1358 00E0A0E3 		mov	lr, #0
 2321 135c 01C070E2 		rsbs	ip, r0, #1
 2322 1360 00C0A033 		movcc	ip, #0
 2323 1364 0A30A0E1 		mov	r3, sl
 2324 1368 1E10A0E3 		mov	r1, #30
 2325 136c 0920A0E1 		mov	r2, r9
 2326 1370 0400A0E1 		mov	r0, r4
 2327 1374 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2328 1378 FEFFFFEB 		bl	cmdSet
 734:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2329              		.loc 1 734 0
 2330 137c 1C0094E5 		ldr	r0, [r4, #28]
 2331 1380 FEFFFFEB 		bl	_txe_mutex_put
 735:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2332              		.loc 1 735 0
 2333 1384 0130A0E3 		mov	r3, #1
 736:../uvc.c      **** 							 break;
 2334              		.loc 1 736 0
 2335 1388 FFE0A0E3 		mov	lr, #255
 735:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2336              		.loc 1 735 0
 2337 138c 6034C6E5 		strb	r3, [r6, #1120]
 2338 1390 1CC09DE5 		ldr	ip, [sp, #28]
 2339 1394 18309DE5 		ldr	r3, [sp, #24]
 736:../uvc.c      **** 							 break;
 2340              		.loc 1 736 0
 2341 1398 0E40A0E1 		mov	r4, lr
 2342 139c 1EFEFFEA 		b	.L120
 2343              	.LVL186:
 2344              	.L164:
 699:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2345              		.loc 1 699 0
 2346 13a0 4C479FE5 		ldr	r4, .L233+32
 695:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 2347              		.loc 1 695 0
 2348 13a4 E533C6E5 		strb	r3, [r6, #997]
 696:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2349              		.loc 1 696 0
 2350 13a8 1C309DE5 		ldr	r3, [sp, #28]
 697:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2351              		.loc 1 697 0
 2352 13ac 0170A0E3 		mov	r7, #1
 2353              	.LVL187:
 699:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2354              		.loc 1 699 0
 2355 13b0 0010E0E3 		mvn	r1, #0
 696:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2356              		.loc 1 696 0
 2357 13b4 E633C6E5 		strb	r3, [r6, #998]
 699:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2358              		.loc 1 699 0
 2359 13b8 1C0094E5 		ldr	r0, [r4, #28]
 697:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2360              		.loc 1 697 0
 2361 13bc E873C6E5 		strb	r7, [r6, #1000]
 2362              	.LVL188:
 699:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2363              		.loc 1 699 0
 2364 13c0 FEFFFFEB 		bl	_txe_mutex_get
 2365              	.LVL189:
 700:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2366              		.loc 1 700 0
 2367 13c4 18C09DE5 		ldr	ip, [sp, #24]
 2368 13c8 0400A0E1 		mov	r0, r4
 2369 13cc 00C08DE5 		str	ip, [sp, #0]
 2370 13d0 1910A0E3 		mov	r1, #25
 2371 13d4 00C0A0E3 		mov	ip, #0
 2372 13d8 0920A0E1 		mov	r2, r9
 2373 13dc 0A30A0E1 		mov	r3, sl
 2374 13e0 04C08DE5 		str	ip, [sp, #4]
 2375 13e4 FEFFFFEB 		bl	cmdSet
 701:../uvc.c      **** 							 if(getData != 0){
 2376              		.loc 1 701 0
 2377 13e8 18009DE5 		ldr	r0, [sp, #24]
 2378 13ec 000050E3 		cmp	r0, #0
 2379 13f0 0700000A 		beq	.L180
 2380              	.LVL190:
 703:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 2381              		.loc 1 703 0
 2382 13f4 1CE09DE5 		ldr	lr, [sp, #28]
 2383 13f8 0400A0E1 		mov	r0, r4
 2384 13fc 1910A0E3 		mov	r1, #25
 2385 1400 0B20A0E1 		mov	r2, fp
 2386 1404 0A30A0E1 		mov	r3, sl
 2387 1408 00E08DE5 		str	lr, [sp, #0]
 2388 140c 04708DE5 		str	r7, [sp, #4]
 2389 1410 FEFFFFEB 		bl	cmdSet
 2390              	.LVL191:
 2391              	.L180:
 705:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2392              		.loc 1 705 0
 2393 1414 1C0094E5 		ldr	r0, [r4, #28]
 2394 1418 FEFFFFEB 		bl	_txe_mutex_put
 706:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2395              		.loc 1 706 0
 2396 141c F0069FE5 		ldr	r0, .L233+64
 2397 1420 EC169FE5 		ldr	r1, .L233+64
 2398 1424 5EC0D0E5 		ldrb	ip, [r0, #94]	@ zero_extendqisi2
 2399 1428 5F40D1E5 		ldrb	r4, [r1, #95]	@ zero_extendqisi2
 2400 142c 5D30D0E5 		ldrb	r3, [r0, #93]	@ zero_extendqisi2
 2401 1430 5C20D0E5 		ldrb	r2, [r0, #92]	@ zero_extendqisi2
 2402 1434 C0169FE5 		ldr	r1, .L233+40
 2403 1438 0400A0E3 		mov	r0, #4
 2404 143c 00C08DE5 		str	ip, [sp, #0]
 2405 1440 04408DE5 		str	r4, [sp, #4]
 2406 1444 FEFFFFEB 		bl	CyU3PDebugPrint
 707:../uvc.c      **** 							 break;
 2407              		.loc 1 707 0
 2408 1448 FFE0A0E3 		mov	lr, #255
 706:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2409              		.loc 1 706 0
 2410 144c 18309DE5 		ldr	r3, [sp, #24]
 2411 1450 1CC09DE5 		ldr	ip, [sp, #28]
 707:../uvc.c      **** 							 break;
 2412              		.loc 1 707 0
 2413 1454 0E40A0E1 		mov	r4, lr
 2414 1458 EFFDFFEA 		b	.L120
 2415              	.LVL192:
 2416              	.L163:
 662:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2417              		.loc 1 662 0
 2418 145c 001053E2 		subs	r1, r3, #0
 661:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2419              		.loc 1 661 0
 2420 1460 0D13C6E5 		strb	r1, [r6, #781]
 2421 1464 68369FE5 		ldr	r3, .L233
 662:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2422              		.loc 1 662 0
 2423 1468 4101001A 		bne	.L174
 663:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2424              		.loc 1 663 0
 2425 146c B924D3E5 		ldrb	r2, [r3, #1209]	@ zero_extendqisi2
 2426              	.LVL193:
 2427 1470 020052E3 		cmp	r2, #2
 2428 1474 08005213 		cmpne	r2, #8
 2429 1478 0300000A 		beq	.L175
 664:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2430              		.loc 1 664 0
 2431 147c 010052E3 		cmp	r2, #1
 665:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 2432              		.loc 1 665 0
 2433 1480 07208202 		addeq	r2, r2, #7
 667:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 2434              		.loc 1 667 0
 2435 1484 0220A013 		movne	r2, #2
 2436 1488 B924C3E5 		strb	r2, [r3, #1209]
 2437              	.LVL194:
 2438              	.L175:
 689:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2439              		.loc 1 689 0
 2440 148c 60469FE5 		ldr	r4, .L233+32
 687:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2441              		.loc 1 687 0
 2442 1490 0120A0E3 		mov	r2, #1
 689:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2443              		.loc 1 689 0
 2444 1494 0010E0E3 		mvn	r1, #0
 687:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2445              		.loc 1 687 0
 2446 1498 1023C6E5 		strb	r2, [r6, #784]
 2447              	.LVL195:
 689:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2448              		.loc 1 689 0
 2449 149c 1C0094E5 		ldr	r0, [r4, #28]
 2450 14a0 FEFFFFEB 		bl	_txe_mutex_get
 690:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2451              		.loc 1 690 0
 2452 14a4 18C09DE5 		ldr	ip, [sp, #24]
 2453 14a8 1010A0E3 		mov	r1, #16
 2454 14ac 00C08DE5 		str	ip, [sp, #0]
 2455 14b0 0920A0E1 		mov	r2, r9
 2456 14b4 0A30A0E1 		mov	r3, sl
 2457 14b8 0400A0E1 		mov	r0, r4
 2458 14bc 00C0A0E3 		mov	ip, #0
 2459              	.LVL196:
 2460              	.L223:
 940:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2461              		.loc 1 940 0
 2462 14c0 04C08DE5 		str	ip, [sp, #4]
 2463 14c4 FEFFFFEB 		bl	cmdSet
 941:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2464              		.loc 1 941 0
 2465 14c8 1C0094E5 		ldr	r0, [r4, #28]
 2466 14cc FEFFFFEB 		bl	_txe_mutex_put
 943:../uvc.c      **** 					 		 break;
 2467              		.loc 1 943 0
 2468 14d0 FFE0A0E3 		mov	lr, #255
 941:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2469              		.loc 1 941 0
 2470 14d4 18309DE5 		ldr	r3, [sp, #24]
 2471 14d8 1CC09DE5 		ldr	ip, [sp, #28]
 943:../uvc.c      **** 					 		 break;
 2472              		.loc 1 943 0
 2473 14dc 0E40A0E1 		mov	r4, lr
 2474 14e0 CDFDFFEA 		b	.L120
 2475              	.LVL197:
 2476              	.L165:
 710:../uvc.c      **** 							 if(Data0 <= 3){
 2477              		.loc 1 710 0
 2478 14e4 030053E3 		cmp	r3, #3
 711:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2479              		.loc 1 711 0
 2480 14e8 24269F95 		ldrls	r2, .L233+64
 2481              	.LVL198:
 714:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2482              		.loc 1 714 0
 2483 14ec 20E69F85 		ldrhi	lr, .L233+64
 2484 14f0 0340A0E1 		mov	r4, r3
 2485              	.LVL199:
 711:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2486              		.loc 1 711 0
 2487 14f4 0030A093 		movls	r3, #0
 2488 14f8 7C30C295 		strlsb	r3, [r2, #124]
 2489              	.LVL200:
 714:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2490              		.loc 1 714 0
 2491 14fc 0120A083 		movhi	r2, #1
 2492 1500 18209D95 		ldrls	r2, [sp, #24]
 711:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2493              		.loc 1 711 0
 2494 1504 0430A091 		movls	r3, r4
 714:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2495              		.loc 1 714 0
 2496 1508 7C20CE85 		strhib	r2, [lr, #124]
 2497 150c 0420A081 		movhi	r2, r4
 720:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2498              		.loc 1 720 0
 2499 1510 DC459FE5 		ldr	r4, .L233+32
 715:../uvc.c      **** 								 Data1 = Data0-4;
 2500              		.loc 1 715 0
 2501 1514 04304382 		subhi	r3, r3, #4
 2502              	.LVL201:
 717:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2503              		.loc 1 717 0
 2504 1518 2D24C6E5 		strb	r2, [r6, #1069]
 719:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2505              		.loc 1 719 0
 2506 151c 0120A0E3 		mov	r2, #1
 720:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2507              		.loc 1 720 0
 2508 1520 0010E0E3 		mvn	r1, #0
 718:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 2509              		.loc 1 718 0
 2510 1524 8D31C6E5 		strb	r3, [r6, #397]
 719:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2511              		.loc 1 719 0
 2512 1528 3024C6E5 		strb	r2, [r6, #1072]
 720:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2513              		.loc 1 720 0
 2514 152c 1C0094E5 		ldr	r0, [r4, #28]
 2515 1530 FEFFFFEB 		bl	_txe_mutex_get
 2516              	.LVL202:
 721:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2517              		.loc 1 721 0
 2518 1534 18C09DE5 		ldr	ip, [sp, #24]
 2519 1538 1C10A0E3 		mov	r1, #28
 2520 153c 00C08DE5 		str	ip, [sp, #0]
 2521 1540 0920A0E1 		mov	r2, r9
 2522 1544 0A30A0E1 		mov	r3, sl
 2523 1548 0400A0E1 		mov	r0, r4
 2524 154c 00C0A0E3 		mov	ip, #0
 2525 1550 DAFFFFEA 		b	.L223
 2526              	.LVL203:
 2527              	.L162:
 871:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2528              		.loc 1 871 0
 2529 1554 98459FE5 		ldr	r4, .L233+32
 2530 1558 0010E0E3 		mvn	r1, #0
 2531 155c 1C0094E5 		ldr	r0, [r4, #28]
 2532 1560 FEFFFFEB 		bl	_txe_mutex_get
 2533              	.LVL204:
 872:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2534              		.loc 1 872 0
 2535 1564 18C09DE5 		ldr	ip, [sp, #24]
 2536 1568 0B10A0E3 		mov	r1, #11
 2537 156c 0920A0E1 		mov	r2, r9
 2538 1570 0A30A0E1 		mov	r3, sl
 2539 1574 0400A0E1 		mov	r0, r4
 2540 1578 00C08DE5 		str	ip, [sp, #0]
 2541 157c 00C0A0E3 		mov	ip, #0
 2542 1580 04C08DE5 		str	ip, [sp, #4]
 2543 1584 FEFFFFEB 		bl	cmdSet
 2544              	.LVL205:
 874:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 2545              		.loc 1 874 0
 2546 1588 1CE09DE5 		ldr	lr, [sp, #28]
 2547 158c 0B10A0E3 		mov	r1, #11
 2548 1590 0B20A0E1 		mov	r2, fp
 2549 1594 0A30A0E1 		mov	r3, sl
 2550 1598 0170A0E3 		mov	r7, #1
 2551              	.LVL206:
 2552 159c 0400A0E1 		mov	r0, r4
 2553 15a0 00E08DE5 		str	lr, [sp, #0]
 2554 15a4 04708DE5 		str	r7, [sp, #4]
 2555 15a8 FEFFFFEB 		bl	cmdSet
 875:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2556              		.loc 1 875 0
 2557 15ac 1C0094E5 		ldr	r0, [r4, #28]
 2558 15b0 FEFFFFEB 		bl	_txe_mutex_put
 877:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2559              		.loc 1 877 0
 2560 15b4 18109DE5 		ldr	r1, [sp, #24]
 878:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2561              		.loc 1 878 0
 2562 15b8 1C209DE5 		ldr	r2, [sp, #28]
 880:../uvc.c      **** 							 break;
 2563              		.loc 1 880 0
 2564 15bc FFE0A0E3 		mov	lr, #255
 877:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2565              		.loc 1 877 0
 2566 15c0 9014C6E5 		strb	r1, [r6, #1168]
 878:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2567              		.loc 1 878 0
 2568 15c4 9224C6E5 		strb	r2, [r6, #1170]
 879:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2569              		.loc 1 879 0
 2570 15c8 9872C6E5 		strb	r7, [r6, #664]
 2571 15cc 0130A0E1 		mov	r3, r1
 2572 15d0 02C0A0E1 		mov	ip, r2
 880:../uvc.c      **** 							 break;
 2573              		.loc 1 880 0
 2574 15d4 0E40A0E1 		mov	r4, lr
 2575 15d8 8FFDFFEA 		b	.L120
 2576              	.LVL207:
 2577              	.L161:
 857:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2578              		.loc 1 857 0
 2579 15dc 10459FE5 		ldr	r4, .L233+32
 2580 15e0 0010E0E3 		mvn	r1, #0
 2581 15e4 1C0094E5 		ldr	r0, [r4, #28]
 2582 15e8 FEFFFFEB 		bl	_txe_mutex_get
 2583              	.LVL208:
 858:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2584              		.loc 1 858 0
 2585 15ec 18C09DE5 		ldr	ip, [sp, #24]
 2586 15f0 00E0A0E3 		mov	lr, #0
 2587 15f4 0610A0E3 		mov	r1, #6
 2588 15f8 0920A0E1 		mov	r2, r9
 2589 15fc 0A30A0E1 		mov	r3, sl
 2590 1600 0400A0E1 		mov	r0, r4
 2591 1604 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2592 1608 FEFFFFEB 		bl	cmdSet
 2593              	.LVL209:
 860:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 2594              		.loc 1 860 0
 2595 160c 18C09DE5 		ldr	ip, [sp, #24]
 2596 1610 0A30A0E1 		mov	r3, sl
 2597 1614 0170A0E3 		mov	r7, #1
 2598              	.LVL210:
 2599 1618 0610A0E3 		mov	r1, #6
 2600 161c 0B20A0E1 		mov	r2, fp
 2601 1620 0400A0E1 		mov	r0, r4
 2602 1624 00C08DE5 		str	ip, [sp, #0]
 2603 1628 04708DE5 		str	r7, [sp, #4]
 2604 162c FEFFFFEB 		bl	cmdSet
 861:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2605              		.loc 1 861 0
 2606 1630 1C0094E5 		ldr	r0, [r4, #28]
 2607 1634 FEFFFFEB 		bl	_txe_mutex_put
 862:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2608              		.loc 1 862 0
 2609 1638 18409DE5 		ldr	r4, [sp, #24]
 864:../uvc.c      **** 							 break;
 2610              		.loc 1 864 0
 2611 163c FFE0A0E3 		mov	lr, #255
 862:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2612              		.loc 1 862 0
 2613 1640 1D42C6E5 		strb	r4, [r6, #541]
 863:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2614              		.loc 1 863 0
 2615 1644 0430A0E1 		mov	r3, r4
 2616 1648 2072C6E5 		strb	r7, [r6, #544]
 2617 164c 1CC09DE5 		ldr	ip, [sp, #28]
 864:../uvc.c      **** 							 break;
 2618              		.loc 1 864 0
 2619 1650 0E40A0E1 		mov	r4, lr
 2620 1654 70FDFFEA 		b	.L120
 2621              	.LVL211:
 2622              	.L160:
 837:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2623              		.loc 1 837 0
 2624 1658 94449FE5 		ldr	r4, .L233+32
 2625 165c 0010E0E3 		mvn	r1, #0
 2626 1660 1C0094E5 		ldr	r0, [r4, #28]
 2627 1664 FEFFFFEB 		bl	_txe_mutex_get
 2628              	.LVL212:
 838:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2629              		.loc 1 838 0
 2630 1668 18009DE5 		ldr	r0, [sp, #24]
 2631 166c 00C0A0E3 		mov	ip, #0
 2632 1670 803040E2 		sub	r3, r0, #128
 2633 1674 FF7003E2 		and	r7, r3, #255
 2634              	.LVL213:
 2635 1678 0510A0E3 		mov	r1, #5
 2636 167c 0920A0E1 		mov	r2, r9
 2637 1680 0A30A0E1 		mov	r3, sl
 2638 1684 0400A0E1 		mov	r0, r4
 2639 1688 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2640 168c FEFFFFEB 		bl	cmdSet
 2641              	.LVL214:
 840:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 2642              		.loc 1 840 0
 2643 1690 18109DE5 		ldr	r1, [sp, #24]
 2644 1694 DC20A0E3 		mov	r2, #220
 2645 1698 767041E2 		sub	r7, r1, #118
 2646 169c FFE007E2 		and	lr, r7, #255
 2647 16a0 0510A0E3 		mov	r1, #5
 2648 16a4 0170A0E3 		mov	r7, #1
 2649 16a8 0A30A0E1 		mov	r3, sl
 2650 16ac 0400A0E1 		mov	r0, r4
 2651 16b0 00E08DE5 		str	lr, [sp, #0]
 2652 16b4 04708DE5 		str	r7, [sp, #4]
 2653 16b8 FEFFFFEB 		bl	cmdSet
 2654              	.LVL215:
 842:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 2655              		.loc 1 842 0
 2656 16bc 18209DE5 		ldr	r2, [sp, #24]
 2657 16c0 0510A0E3 		mov	r1, #5
 2658 16c4 7E0082E2 		add	r0, r2, #126
 2659 16c8 FFC000E2 		and	ip, r0, #255
 2660 16cc DE20A0E3 		mov	r2, #222
 2661 16d0 0A30A0E1 		mov	r3, sl
 2662 16d4 0400A0E1 		mov	r0, r4
 2663 16d8 00C08DE5 		str	ip, [sp, #0]
 2664 16dc 02C0A0E3 		mov	ip, #2
 2665 16e0 04C08DE5 		str	ip, [sp, #4]
 2666 16e4 FEFFFFEB 		bl	cmdSet
 2667              	.LVL216:
 844:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 2668              		.loc 1 844 0
 2669 16e8 18309DE5 		ldr	r3, [sp, #24]
 2670 16ec E020A0E3 		mov	r2, #224
 2671 16f0 721083E2 		add	r1, r3, #114
 2672 16f4 FFC001E2 		and	ip, r1, #255
 2673 16f8 0A30A0E1 		mov	r3, sl
 2674 16fc 0510A0E3 		mov	r1, #5
 2675 1700 0400A0E1 		mov	r0, r4
 2676 1704 00C08DE5 		str	ip, [sp, #0]
 2677 1708 03C0A0E3 		mov	ip, #3
 2678 170c 04C08DE5 		str	ip, [sp, #4]
 2679 1710 FEFFFFEB 		bl	cmdSet
 2680              	.LVL217:
 846:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 2681              		.loc 1 846 0
 2682 1714 18209DE5 		ldr	r2, [sp, #24]
 2683 1718 0510A0E3 		mov	r1, #5
 2684 171c 6F0042E2 		sub	r0, r2, #111
 2685 1720 FFC000E2 		and	ip, r0, #255
 2686 1724 DD20A0E3 		mov	r2, #221
 2687 1728 0A30A0E1 		mov	r3, sl
 2688 172c 0400A0E1 		mov	r0, r4
 2689 1730 00C08DE5 		str	ip, [sp, #0]
 2690 1734 04C0A0E3 		mov	ip, #4
 2691 1738 04C08DE5 		str	ip, [sp, #4]
 2692 173c FEFFFFEB 		bl	cmdSet
 2693              	.LVL218:
 848:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 2694              		.loc 1 848 0
 2695 1740 CC339FE5 		ldr	r3, .L233+64
 2696 1744 05E0A0E3 		mov	lr, #5
 2697 1748 5C10D3E5 		ldrb	r1, [r3, #92]	@ zero_extendqisi2
 2698 174c 0400A0E1 		mov	r0, r4
 2699 1750 7F2081E2 		add	r2, r1, #127
 2700 1754 FFC002E2 		and	ip, r2, #255
 2701 1758 0E10A0E1 		mov	r1, lr
 2702 175c 0A30A0E1 		mov	r3, sl
 2703 1760 0B20A0E1 		mov	r2, fp
 2704 1764 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2705 1768 FEFFFFEB 		bl	cmdSet
 849:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2706              		.loc 1 849 0
 2707 176c 1C0094E5 		ldr	r0, [r4, #28]
 2708 1770 FEFFFFEB 		bl	_txe_mutex_put
 851:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2709              		.loc 1 851 0
 2710 1774 98039FE5 		ldr	r0, .L233+64
 853:../uvc.c      **** 							 break;
 2711              		.loc 1 853 0
 2712 1778 FFE0A0E3 		mov	lr, #255
 851:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2713              		.loc 1 851 0
 2714 177c 5C30D0E5 		ldrb	r3, [r0, #92]	@ zero_extendqisi2
 852:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2715              		.loc 1 852 0
 2716 1780 0872C6E5 		strb	r7, [r6, #520]
 851:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2717              		.loc 1 851 0
 2718 1784 801043E2 		sub	r1, r3, #128
 2719 1788 0512C6E5 		strb	r1, [r6, #517]
 852:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2720              		.loc 1 852 0
 2721 178c 18309DE5 		ldr	r3, [sp, #24]
 2722 1790 1CC09DE5 		ldr	ip, [sp, #28]
 853:../uvc.c      **** 							 break;
 2723              		.loc 1 853 0
 2724 1794 0E40A0E1 		mov	r4, lr
 2725 1798 1FFDFFEA 		b	.L120
 2726              	.LVL219:
 2727              	.L159:
 884:../uvc.c      **** 							 Data0 = Data0 - 1;
 2728              		.loc 1 884 0
 2729 179c 012043E2 		sub	r2, r3, #1
 2730              	.LVL220:
 2731 17a0 FF2002E2 		and	r2, r2, #255
 2732              	.LVL221:
 885:../uvc.c      **** 							 is60Hz = Data0;
 2733              		.loc 1 885 0
 2734 17a4 68039FE5 		ldr	r0, .L233+64
 891:../uvc.c      **** 							 else if(Data0 >2)
 2735              		.loc 1 891 0
 2736 17a8 020052E3 		cmp	r2, #2
 883:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2737              		.loc 1 883 0
 2738 17ac ED31C6E5 		strb	r3, [r6, #493]
 894:../uvc.c      **** 								 is60Hz = CyTrue;
 2739              		.loc 1 894 0
 2740 17b0 0130A083 		movhi	r3, #1
 885:../uvc.c      **** 							 is60Hz = Data0;
 2741              		.loc 1 885 0
 2742 17b4 582080E5 		str	r2, [r0, #88]
 2743              	.LVL222:
 894:../uvc.c      **** 								 is60Hz = CyTrue;
 2744              		.loc 1 894 0
 2745 17b8 58308085 		strhi	r3, [r0, #88]
 2746              	.LVL223:
 2747 17bc 0320A081 		movhi	r2, r3
 896:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
 2748              		.loc 1 896 0
 2749 17c0 4C339FE5 		ldr	r3, .L233+64
 897:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 2750              		.loc 1 897 0
 2751 17c4 48739FE5 		ldr	r7, .L233+64
 2752              	.LVL224:
 896:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
 2753              		.loc 1 896 0
 2754 17c8 583093E5 		ldr	r3, [r3, #88]
 2755 17cc 0400A0E3 		mov	r0, #4
 2756 17d0 28139FE5 		ldr	r1, .L233+44
 2757 17d4 FEFFFFEB 		bl	CyU3PDebugPrint
 2758              	.LVL225:
 897:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 2759              		.loc 1 897 0
 2760 17d8 3C4097E5 		ldr	r4, [r7, #60]
 2761 17dc 010054E3 		cmp	r4, #1
 2762 17e0 8200000A 		beq	.L231
 2763              	.L190:
 924:../uvc.c      **** 							 break;
 2764              		.loc 1 924 0
 2765 17e4 FFE0A0E3 		mov	lr, #255
 923:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2766              		.loc 1 923 0
 2767 17e8 0120A0E3 		mov	r2, #1
 2768 17ec F021C6E5 		strb	r2, [r6, #496]
 2769 17f0 18309DE5 		ldr	r3, [sp, #24]
 2770 17f4 1CC09DE5 		ldr	ip, [sp, #28]
 924:../uvc.c      **** 							 break;
 2771              		.loc 1 924 0
 2772 17f8 0E40A0E1 		mov	r4, lr
 2773 17fc 06FDFFEA 		b	.L120
 2774              	.LVL226:
 2775              	.L158:
 819:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2776              		.loc 1 819 0
 2777 1800 EC429FE5 		ldr	r4, .L233+32
 2778 1804 0010E0E3 		mvn	r1, #0
 2779 1808 1C0094E5 		ldr	r0, [r4, #28]
 2780 180c FEFFFFEB 		bl	_txe_mutex_get
 2781              	.LVL227:
 821:../uvc.c      **** 							  if(Data0&0x80){
 2782              		.loc 1 821 0
 2783 1810 18209DE5 		ldr	r2, [sp, #24]
 826:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2784              		.loc 1 826 0
 2785 1814 00C0A0E3 		mov	ip, #0
 821:../uvc.c      **** 							  if(Data0&0x80){
 2786              		.loc 1 821 0
 2787 1818 800012E3 		tst	r2, #128
 822:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 2788              		.loc 1 822 0
 2789 181c 80704212 		subne	r7, r2, #128
 2790              	.LVL228:
 824:../uvc.c      **** 								  Data0 = ~Data0;
 2791              		.loc 1 824 0
 2792 1820 0270E001 		mvneq	r7, r2
 826:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2793              		.loc 1 826 0
 2794 1824 0A30A0E1 		mov	r3, sl
 824:../uvc.c      **** 								  Data0 = ~Data0;
 2795              		.loc 1 824 0
 2796 1828 FF7007E2 		and	r7, r7, #255
 2797              	.LVL229:
 826:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2798              		.loc 1 826 0
 2799 182c 0110A0E3 		mov	r1, #1
 2800 1830 0B20A0E1 		mov	r2, fp
 2801 1834 B8029FE5 		ldr	r0, .L233+32
 2802 1838 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2803 183c FEFFFFEB 		bl	cmdSet
 827:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2804              		.loc 1 827 0
 2805 1840 1C0094E5 		ldr	r0, [r4, #28]
 2806 1844 FEFFFFEB 		bl	_txe_mutex_put
 833:../uvc.c      **** 							 break;
 2807              		.loc 1 833 0
 2808 1848 FFE0A0E3 		mov	lr, #255
 830:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2809              		.loc 1 830 0
 2810 184c 0100A0E3 		mov	r0, #1
 829:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2811              		.loc 1 829 0
 2812 1850 A571C6E5 		strb	r7, [r6, #421]
 830:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2813              		.loc 1 830 0
 2814 1854 A801C6E5 		strb	r0, [r6, #424]
 2815 1858 18309DE5 		ldr	r3, [sp, #24]
 2816 185c 1CC09DE5 		ldr	ip, [sp, #28]
 833:../uvc.c      **** 							 break;
 2817              		.loc 1 833 0
 2818 1860 0E40A0E1 		mov	r4, lr
 2819 1864 ECFCFFEA 		b	.L120
 2820              	.LVL230:
 2821              	.L156:
 947:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2822              		.loc 1 947 0
 2823 1868 84729FE5 		ldr	r7, .L233+32
 2824              	.LVL231:
 2825 186c 0010E0E3 		mvn	r1, #0
 2826 1870 1C0097E5 		ldr	r0, [r7, #28]
 2827 1874 FEFFFFEB 		bl	_txe_mutex_get
 2828              	.LVL232:
 948:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2829              		.loc 1 948 0
 2830 1878 18C09DE5 		ldr	ip, [sp, #24]
 2831 187c 0410A0E1 		mov	r1, r4
 2832 1880 0A30A0E1 		mov	r3, sl
 2833 1884 0920A0E1 		mov	r2, r9
 2834 1888 00C08DE5 		str	ip, [sp, #0]
 2835 188c 0700A0E1 		mov	r0, r7
 2836 1890 00C0A0E3 		mov	ip, #0
 2837 1894 04C08DE5 		str	ip, [sp, #4]
 2838 1898 FEFFFFEB 		bl	cmdSet
 949:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2839              		.loc 1 949 0
 2840 189c 1C0097E5 		ldr	r0, [r7, #28]
 2841 18a0 FEFFFFEB 		bl	_txe_mutex_put
 951:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2842              		.loc 1 951 0
 2843 18a4 18109DE5 		ldr	r1, [sp, #24]
 2844 18a8 843084E0 		add	r3, r4, r4, asl #1
 2845 18ac 836186E0 		add	r6, r6, r3, asl #3
 953:../uvc.c      **** 							 break;
 2846              		.loc 1 953 0
 2847 18b0 FFE0A0E3 		mov	lr, #255
 952:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2848              		.loc 1 952 0
 2849 18b4 0100A0E3 		mov	r0, #1
 951:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2850              		.loc 1 951 0
 2851 18b8 8D11C6E5 		strb	r1, [r6, #397]
 952:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2852              		.loc 1 952 0
 2853 18bc 9001C6E5 		strb	r0, [r6, #400]
 2854 18c0 0130A0E1 		mov	r3, r1
 2855 18c4 1CC09DE5 		ldr	ip, [sp, #28]
 953:../uvc.c      **** 							 break;
 2856              		.loc 1 953 0
 2857 18c8 0E40A0E1 		mov	r4, lr
 2858 18cc D2FCFFEA 		b	.L120
 2859              	.LVL233:
 2860              	.L157:
 928:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2861              		.loc 1 928 0
 2862 18d0 3CC29FE5 		ldr	ip, .L233+64
 2863              	.LVL234:
 927:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2864              		.loc 1 927 0
 2865 18d4 0140A0E3 		mov	r4, #1
 928:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2866              		.loc 1 928 0
 2867 18d8 7C20DCE5 		ldrb	r2, [ip, #124]	@ zero_extendqisi2
 2868              	.LVL235:
 926:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2869              		.loc 1 926 0
 2870 18dc 8D31C6E5 		strb	r3, [r6, #397]
 928:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2871              		.loc 1 928 0
 2872 18e0 010052E3 		cmp	r2, #1
 927:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2873              		.loc 1 927 0
 2874 18e4 9041C6E5 		strb	r4, [r6, #400]
 2875 18e8 0370A011 		movne	r7, r3
 2876              	.LVL236:
 928:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2877              		.loc 1 928 0
 2878 18ec 3500000A 		beq	.L232
 2879              	.LVL237:
 2880              	.L201:
 939:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2881              		.loc 1 939 0
 2882 18f0 FC419FE5 		ldr	r4, .L233+32
 2883 18f4 0010E0E3 		mvn	r1, #0
 2884 18f8 1C0094E5 		ldr	r0, [r4, #28]
 937:../uvc.c      **** 							 CtrlParArry[CamModeIndex][13] = Data0;
 2885              		.loc 1 937 0
 2886 18fc 2D74C6E5 		strb	r7, [r6, #1069]
 2887              	.LVL238:
 939:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2888              		.loc 1 939 0
 2889 1900 FEFFFFEB 		bl	_txe_mutex_get
 940:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2890              		.loc 1 940 0
 2891 1904 00C0A0E3 		mov	ip, #0
 2892 1908 0C10A0E1 		mov	r1, ip
 2893 190c 0920A0E1 		mov	r2, r9
 2894 1910 0A30A0E1 		mov	r3, sl
 2895 1914 0400A0E1 		mov	r0, r4
 2896 1918 00708DE5 		str	r7, [sp, #0]
 2897 191c E7FEFFEA 		b	.L223
 2898              	.LVL239:
 2899              	.L155:
 956:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 2900              		.loc 1 956 0
 2901 1920 0400A0E3 		mov	r0, #4
 2902              	.LVL240:
 2903 1924 D8119FE5 		ldr	r1, .L233+48
 2904 1928 FEFFFFEB 		bl	CyU3PDebugPrint
 2905              	.LVL241:
 2906 192c FFE0A0E3 		mov	lr, #255
 2907 1930 0E40A0E1 		mov	r4, lr
 2908 1934 0EC0A0E1 		mov	ip, lr
 2909 1938 0E30A0E1 		mov	r3, lr
 2910 193c B6FCFFEA 		b	.L120
 2911              	.LVL242:
 2912              	.L230:
 476:../uvc.c      **** 						if(sendData >= 3){
 2913              		.loc 1 476 0
 2914 1940 020054E3 		cmp	r4, #2
 2915 1944 04408492 		addls	r4, r4, #4
 2916              	.LVL243:
 2917 1948 FF400492 		andls	r4, r4, #255
 2918 194c DDFDFF9A 		bls	.L133
 477:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 2919              		.loc 1 477 0
 2920 1950 0430A0E1 		mov	r3, r4
 2921 1954 0400A0E3 		mov	r0, #4
 2922 1958 A8119FE5 		ldr	r1, .L233+52
 2923 195c FEFFFFEB 		bl	CyU3PDebugPrint
 2924              	.LVL244:
 479:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 2925              		.loc 1 479 0
 2926 1960 6C319FE5 		ldr	r3, .L233
 2927 1964 0020A0E3 		mov	r2, #0
 2928 1968 0440A0E3 		mov	r4, #4
 2929 196c 2D24C3E5 		strb	r2, [r3, #1069]
 2930              	.LVL245:
 2931 1970 D4FDFFEA 		b	.L133
 2932              	.LVL246:
 2933              	.L174:
 672:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2934              		.loc 1 672 0
 2935 1974 B924D3E5 		ldrb	r2, [r3, #1209]	@ zero_extendqisi2
 2936              	.LVL247:
 671:../uvc.c      **** 								 Data1 = Data0 - 1;
 2937              		.loc 1 671 0
 2938 1978 014041E2 		sub	r4, r1, #1
 672:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2939              		.loc 1 672 0
 2940 197c 040052E3 		cmp	r2, #4
 2941 1980 01005213 		cmpne	r2, #1
 671:../uvc.c      **** 								 Data1 = Data0 - 1;
 2942              		.loc 1 671 0
 2943 1984 FF1004E2 		and	r1, r4, #255
 2944              	.LVL248:
 672:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2945              		.loc 1 672 0
 2946 1988 0300000A 		beq	.L177
 673:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 2947              		.loc 1 673 0
 2948 198c 080052E3 		cmp	r2, #8
 674:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 2949              		.loc 1 674 0
 2950 1990 0120A003 		moveq	r2, #1
 676:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 2951              		.loc 1 676 0
 2952 1994 0420A013 		movne	r2, #4
 2953 1998 B924C3E5 		strb	r2, [r3, #1209]
 2954              	.L177:
 679:../uvc.c      **** 								 if(Data1 < 8){
 2955              		.loc 1 679 0
 2956 199c 070051E3 		cmp	r1, #7
 680:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2957              		.loc 1 680 0
 2958 19a0 64319F95 		ldrls	r3, .L233+56
 683:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2959              		.loc 1 683 0
 2960 19a4 0130A083 		movhi	r3, #1
 681:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2961              		.loc 1 681 0
 2962 19a8 81008390 		addls	r0, r3, r1, asl #1
 680:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2963              		.loc 1 680 0
 2964 19ac 8120D397 		ldrlsb	r2, [r3, r1, asl #1]	@ zero_extendqisi2
 681:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2965              		.loc 1 681 0
 2966 19b0 0130D095 		ldrlsb	r3, [r0, #1]	@ zero_extendqisi2
 683:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2967              		.loc 1 683 0
 2968 19b4 E934C685 		strhib	r3, [r6, #1257]
 684:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2969              		.loc 1 684 0
 2970 19b8 0030A083 		movhi	r3, #0
 680:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2971              		.loc 1 680 0
 2972 19bc E924C695 		strlsb	r2, [r6, #1257]
 684:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2973              		.loc 1 684 0
 2974 19c0 EA34C6E5 		strb	r3, [r6, #1258]
 2975 19c4 B0FEFFEA 		b	.L175
 2976              	.LVL249:
 2977              	.L232:
 930:../uvc.c      **** 								 if(Data0 < 3){
 2978              		.loc 1 930 0
 2979 19c8 020053E3 		cmp	r3, #2
 931:../uvc.c      **** 					 				 Data0 += 4;
 2980              		.loc 1 931 0
 2981 19cc 04708392 		addls	r7, r3, #4
 2982 19d0 FF700792 		andls	r7, r7, #255
 930:../uvc.c      **** 								 if(Data0 < 3){
 2983              		.loc 1 930 0
 2984 19d4 C5FFFF9A 		bls	.L201
 933:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 2985              		.loc 1 933 0
 2986 19d8 0400A0E3 		mov	r0, #4
 2987 19dc 24119FE5 		ldr	r1, .L233+52
 2988 19e0 18309DE5 		ldr	r3, [sp, #24]
 2989 19e4 FEFFFFEB 		bl	CyU3PDebugPrint
 2990              	.LVL250:
 934:../uvc.c      **** 									Data0 = 4; //set to default.
 2991              		.loc 1 934 0
 2992 19e8 0470A0E3 		mov	r7, #4
 2993 19ec BFFFFFEA 		b	.L201
 2994              	.LVL251:
 2995              	.L231:
 899:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2996              		.loc 1 899 0
 2997 19f0 FC809FE5 		ldr	r8, .L233+32
 2998 19f4 0010E0E3 		mvn	r1, #0
 2999 19f8 1C0098E5 		ldr	r0, [r8, #28]
 3000 19fc FEFFFFEB 		bl	_txe_mutex_get
 900:../uvc.c      **** 			                       switch (setRes)
 3001              		.loc 1 900 0
 3002 1a00 7D00D7E5 		ldrb	r0, [r7, #125]	@ zero_extendqisi2
 3003 1a04 020050E3 		cmp	r0, #2
 3004 1a08 4200000A 		beq	.L193
 3005 1a0c 030050E3 		cmp	r0, #3
 3006 1a10 1700000A 		beq	.L194
 3007 1a14 010050E3 		cmp	r0, #1
 3008 1a18 1000001A 		bne	.L191
 903:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 3009              		.loc 1 903 0
 3010 1a1c 582097E5 		ldr	r2, [r7, #88]
 3011 1a20 3010A0E3 		mov	r1, #48
 3012 1a24 000052E3 		cmp	r2, #0
 3013 1a28 E420A003 		moveq	r2, #228
 3014 1a2c 6420A013 		movne	r2, #100
 3015 1a30 5230A0E3 		mov	r3, #82
 3016 1a34 FEFFFFEB 		bl	SensorSetIrisControl
 904:../uvc.c      **** 			                         		CyU3PThreadSleep(1000);
 3017              		.loc 1 904 0
 3018 1a38 FA0FA0E3 		mov	r0, #1000
 3019 1a3c FEFFFFEB 		bl	_tx_thread_sleep
 905:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 3020              		.loc 1 905 0
 3021 1a40 582097E5 		ldr	r2, [r7, #88]
 3022 1a44 C4109FE5 		ldr	r1, .L233+60
 3023 1a48 000052E3 		cmp	r2, #0
 3024 1a4c 583097E5 		ldr	r3, [r7, #88]
 3025 1a50 E420A003 		moveq	r2, #228
 3026 1a54 6420A013 		movne	r2, #100
 3027 1a58 0400A0E3 		mov	r0, #4
 3028 1a5c FEFFFFEB 		bl	CyU3PDebugPrint
 3029              	.L191:
 920:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3030              		.loc 1 920 0
 3031 1a60 1C0098E5 		ldr	r0, [r8, #28]
 3032 1a64 FEFFFFEB 		bl	_txe_mutex_put
 3033 1a68 5DFFFFEA 		b	.L190
 3034              	.LVL252:
 3035              	.L221:
 3036 1a6c A0009FE5 		ldr	r0, .L233+64
 3037 1a70 83FDFFEA 		b	.L131
 3038              	.LVL253:
 3039              	.L194:
 913:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
 3040              		.loc 1 913 0
 3041 1a74 580097E5 		ldr	r0, [r7, #88]
 3042 1a78 8C34D6E5 		ldrb	r3, [r6, #1164]	@ zero_extendqisi2
 3043 1a7c 000050E3 		cmp	r0, #0
 3044 1a80 C400A003 		moveq	r0, #196
 3045 1a84 4400A013 		movne	r0, #68
 3046 1a88 032080E1 		orr	r2, r0, r3
 3047 1a8c 3010A0E3 		mov	r1, #48
 3048 1a90 5230A0E3 		mov	r3, #82
 3049 1a94 0400A0E1 		mov	r0, r4
 3050 1a98 FEFFFFEB 		bl	SensorSetIrisControl
 914:../uvc.c      **** 			                         		CyU3PThreadSleep(1000);
 3051              		.loc 1 914 0
 3052 1a9c FA0FA0E3 		mov	r0, #1000
 3053 1aa0 FEFFFFEB 		bl	_tx_thread_sleep
 915:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 3054              		.loc 1 915 0
 3055 1aa4 68E09FE5 		ldr	lr, .L233+64
 3056 1aa8 60109FE5 		ldr	r1, .L233+60
 3057 1aac 58C09EE5 		ldr	ip, [lr, #88]
 3058 1ab0 8C44D6E5 		ldrb	r4, [r6, #1164]	@ zero_extendqisi2
 3059 1ab4 00005CE3 		cmp	ip, #0
 3060 1ab8 C4C0A003 		moveq	ip, #196
 3061 1abc 44C0A013 		movne	ip, #68
 3062 1ac0 58309EE5 		ldr	r3, [lr, #88]
 3063 1ac4 04208CE1 		orr	r2, ip, r4
 3064 1ac8 0400A0E3 		mov	r0, #4
 3065 1acc FEFFFFEB 		bl	CyU3PDebugPrint
 916:../uvc.c      **** 			                         		break;
 3066              		.loc 1 916 0
 3067 1ad0 E2FFFFEA 		b	.L191
 3068              	.L234:
 3069              		.align	2
 3070              	.L233:
 3071 1ad4 00000000 		.word	.LANCHOR1
 3072 1ad8 00000000 		.word	bRequest
 3073 1adc B4030000 		.word	.LC23
 3074 1ae0 5C000000 		.word	.LANCHOR0+92
 3075 1ae4 01000100 		.word	65537
 3076 1ae8 FF00FF00 		.word	16711935
 3077 1aec B0020000 		.word	.LC17
 3078 1af0 EC020000 		.word	.LC18
 3079 1af4 00000000 		.word	cmdQu
 3080 1af8 4C000000 		.word	.LANCHOR0+76
 3081 1afc 14030000 		.word	.LC19
 3082 1b00 40030000 		.word	.LC20
 3083 1b04 84030000 		.word	.LC22
 3084 1b08 78020000 		.word	.LC16
 3085 1b0c 00000000 		.word	.LANCHOR2
 3086 1b10 60030000 		.word	.LC21
 3087 1b14 00000000 		.word	.LANCHOR0
 3088              	.L193:
 908:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 3089              		.loc 1 908 0
 3090 1b18 582097E5 		ldr	r2, [r7, #88]
 3091 1b1c 3010A0E3 		mov	r1, #48
 3092 1b20 000052E3 		cmp	r2, #0
 3093 1b24 D420A003 		moveq	r2, #212
 3094 1b28 5420A013 		movne	r2, #84
 3095 1b2c 5230A0E3 		mov	r3, #82
 3096 1b30 0400A0E1 		mov	r0, r4
 3097 1b34 FEFFFFEB 		bl	SensorSetIrisControl
 909:../uvc.c      **** 			                         		CyU3PThreadSleep(1000);
 3098              		.loc 1 909 0
 3099 1b38 FA0FA0E3 		mov	r0, #1000
 3100 1b3c FEFFFFEB 		bl	_tx_thread_sleep
 910:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 3101              		.loc 1 910 0
 3102 1b40 34101FE5 		ldr	r1, .L233+64
 3103 1b44 0400A0E3 		mov	r0, #4
 3104 1b48 582091E5 		ldr	r2, [r1, #88]
 3105 1b4c 583091E5 		ldr	r3, [r1, #88]
 3106 1b50 000052E3 		cmp	r2, #0
 3107 1b54 4C101FE5 		ldr	r1, .L233+60
 3108 1b58 D420A003 		moveq	r2, #212
 3109 1b5c 5420A013 		movne	r2, #84
 3110 1b60 FEFFFFEB 		bl	CyU3PDebugPrint
 911:../uvc.c      **** 			                         		break;
 3111              		.loc 1 911 0
 3112 1b64 BDFFFFEA 		b	.L191
 3113              	.LVL254:
 3114              	.L203:
 3115 1b68 5C001FE5 		ldr	r0, .L233+64
 420:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 3116              		.loc 1 420 0
 3117 1b6c 0030A0E3 		mov	r3, #0
 3118 1b70 3CFDFFEA 		b	.L213
 3119              	.LVL255:
 3120              	.L204:
 3121 1b74 0030A0E3 		mov	r3, #0
 3122 1b78 E3FDFFEA 		b	.L214
 3123              		.cfi_endproc
 3124              	.LFE2:
 3126              		.align	2
 3127              		.global	CTControlHandle
 3129              	CTControlHandle:
 3130              	.LFB3:
 972:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3131              		.loc 1 972 0
 3132              		.cfi_startproc
 3133              		@ args = 0, pretend = 0, frame = 64
 3134              		@ frame_needed = 0, uses_anonymous_args = 0
 3135              	.LVL256:
 3136 1b7c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3137              	.LCFI15:
 3138              		.cfi_def_cfa_offset 36
 991:../uvc.c      ****     reqData = bRequest;
 3139              		.loc 1 991 0
 3140 1b80 60A99FE5 		ldr	sl, .L320
 3141              		.cfi_offset 14, -4
 3142              		.cfi_offset 11, -8
 3143              		.cfi_offset 10, -12
 3144              		.cfi_offset 9, -16
 3145              		.cfi_offset 8, -20
 3146              		.cfi_offset 7, -24
 3147              		.cfi_offset 6, -28
 3148              		.cfi_offset 5, -32
 3149              		.cfi_offset 4, -36
 983:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3150              		.loc 1 983 0
 3151 1b84 60899FE5 		ldr	r8, .L320+4
 991:../uvc.c      ****     reqData = bRequest;
 3152              		.loc 1 991 0
 3153 1b88 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
 983:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3154              		.loc 1 983 0
 3155 1b8c 8090A0E1 		mov	r9, r0, asl #1
 3156 1b90 002089E0 		add	r2, r9, r0
 3157 1b94 822188E0 		add	r2, r8, r2, asl #3
 993:../uvc.c      ****     switch (bRequest)
 3158              		.loc 1 993 0
 3159 1b98 830055E3 		cmp	r5, #131
 972:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3160              		.loc 1 972 0
 3161 1b9c 5CD04DE2 		sub	sp, sp, #92
 3162              	.LCFI16:
 3163              		.cfi_def_cfa_offset 128
 972:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3164              		.loc 1 972 0
 3165 1ba0 0060A0E1 		mov	r6, r0
 983:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3166              		.loc 1 983 0
 3167 1ba4 A334D2E5 		ldrb	r3, [r2, #1187]	@ zero_extendqisi2
 3168              	.LVL257:
 984:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3169              		.loc 1 984 0
 3170 1ba8 94B4D2E5 		ldrb	fp, [r2, #1172]	@ zero_extendqisi2
 3171              	.LVL258:
 986:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 3172              		.loc 1 986 0
 3173 1bac 9674D2E5 		ldrb	r7, [r2, #1174]	@ zero_extendqisi2
 3174              	.LVL259:
 993:../uvc.c      ****     switch (bRequest)
 3175              		.loc 1 993 0
 3176 1bb0 7600000A 		beq	.L240
 3177 1bb4 2100009A 		bls	.L315
 3178 1bb8 850055E3 		cmp	r5, #133
 3179 1bbc 5900000A 		beq	.L242
 3180 1bc0 4E00003A 		bcc	.L241
 3181 1bc4 860055E3 		cmp	r5, #134
 3182 1bc8 8000000A 		beq	.L243
 3183 1bcc 870055E3 		cmp	r5, #135
 3184 1bd0 7600000A 		beq	.L316
 3185              	.L236:
1200:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 3186              		.loc 1 1200 0
 3187 1bd4 0000A0E3 		mov	r0, #0
 3188              	.LVL260:
 3189 1bd8 0110A0E3 		mov	r1, #1
 3190 1bdc 0020A0E1 		mov	r2, r0
 3191 1be0 FEFFFFEB 		bl	CyU3PUsbStall
 3192              	.LVL261:
 3193 1be4 04499FE5 		ldr	r4, .L320+8
1201:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3194              		.loc 1 1201 0
 3195 1be8 0620A0E1 		mov	r2, r6
 3196 1bec 0400A0E3 		mov	r0, #4
 3197 1bf0 FC189FE5 		ldr	r1, .L320+12
 3198 1bf4 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 3199 1bf8 FEFFFFEB 		bl	CyU3PDebugPrint
1202:../uvc.c      **** 			  break;
 3200              		.loc 1 1202 0
 3201 1bfc FFC0A0E3 		mov	ip, #255
 3202 1c00 0C60A0E1 		mov	r6, ip
 3203 1c04 0C80A0E1 		mov	r8, ip
 3204              	.LVL262:
 3205              	.L246:
1206:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 3206              		.loc 1 1206 0
 3207 1c08 5EE0D4E5 		ldrb	lr, [r4, #94]	@ zero_extendqisi2
 3208 1c0c 08C08DE5 		str	ip, [sp, #8]
 3209 1c10 E0189FE5 		ldr	r1, .L320+16
 3210 1c14 FFC0A0E3 		mov	ip, #255
 3211 1c18 0520A0E1 		mov	r2, r5
 3212 1c1c 0830A0E1 		mov	r3, r8
 3213 1c20 0400A0E3 		mov	r0, #4
 3214 1c24 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 3215 1c28 0CC08DE5 		str	ip, [sp, #12]
 3216 1c2c 10E08DE5 		str	lr, [sp, #16]
 3217 1c30 14708DE5 		str	r7, [sp, #20]
 3218 1c34 FEFFFFEB 		bl	CyU3PDebugPrint
1207:../uvc.c      **** }
 3219              		.loc 1 1207 0
 3220 1c38 5CD08DE2 		add	sp, sp, #92
 3221 1c3c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3222              	.LVL263:
 3223              	.L315:
 993:../uvc.c      ****     switch (bRequest)
 3224              		.loc 1 993 0
 3225 1c40 810055E3 		cmp	r5, #129
 3226 1c44 4200000A 		beq	.L238
 3227 1c48 1100009A 		bls	.L317
1022:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3228              		.loc 1 1022 0
 3229 1c4c 9C489FE5 		ldr	r4, .L320+8
 3230 1c50 9714D2E5 		ldrb	r1, [r2, #1175]	@ zero_extendqisi2
1023:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3231              		.loc 1 1023 0
 3232 1c54 9864D2E5 		ldrb	r6, [r2, #1176]	@ zero_extendqisi2
1024:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3233              		.loc 1 1024 0
 3234 1c58 0A0050E3 		cmp	r0, #10
1022:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3235              		.loc 1 1022 0
 3236 1c5c 5C10C4E5 		strb	r1, [r4, #92]
1023:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3237              		.loc 1 1023 0
 3238 1c60 5D60C4E5 		strb	r6, [r4, #93]
1024:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3239              		.loc 1 1024 0
 3240 1c64 2C00000A 		beq	.L314
 3241              	.LVL264:
 3242              	.L253:
1058:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3243              		.loc 1 1058 0
 3244 1c68 00E0A0E3 		mov	lr, #0
 3245 1c6c 5EE0C4E5 		strb	lr, [r4, #94]
 3246              	.L254:
1059:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3247              		.loc 1 1059 0
 3248 1c70 0030A0E3 		mov	r3, #0
1060:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3249              		.loc 1 1060 0
 3250 1c74 0700A0E1 		mov	r0, r7
 3251              	.LVL265:
 3252 1c78 7C189FE5 		ldr	r1, .L320+20
1062:../uvc.c      **** 			  break;
 3253              		.loc 1 1062 0
 3254 1c7c FF60A0E3 		mov	r6, #255
1059:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3255              		.loc 1 1059 0
 3256 1c80 5F30C4E5 		strb	r3, [r4, #95]
1062:../uvc.c      **** 			  break;
 3257              		.loc 1 1062 0
 3258 1c84 0680A0E1 		mov	r8, r6
1060:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3259              		.loc 1 1060 0
 3260 1c88 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3261              	.LVL266:
 3262 1c8c 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1062:../uvc.c      **** 			  break;
 3263              		.loc 1 1062 0
 3264 1c90 DCFFFFEA 		b	.L246
 3265              	.LVL267:
 3266              	.L317:
 993:../uvc.c      ****     switch (bRequest)
 3267              		.loc 1 993 0
 3268 1c94 010055E3 		cmp	r5, #1
 3269 1c98 CDFFFF1A 		bne	.L236
1064:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 3270              		.loc 1 1064 0
 3271 1c9c 4C489FE5 		ldr	r4, .L320+8
 3272 1ca0 56208DE2 		add	r2, sp, #86
 3273 1ca4 2000A0E3 		mov	r0, #32
 3274              	.LVL268:
 3275 1ca8 5C1084E2 		add	r1, r4, #92
 3276 1cac 2C308DE5 		str	r3, [sp, #44]
 3277 1cb0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3278              	.LVL269:
1066:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3279              		.loc 1 1066 0
 3280 1cb4 5C00D4E5 		ldrb	r0, [r4, #92]	@ zero_extendqisi2
1067:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3281              		.loc 1 1067 0
 3282 1cb8 5DC0D4E5 		ldrb	ip, [r4, #93]	@ zero_extendqisi2
1070:../uvc.c      **** 			  switch(CtrlID)
 3283              		.loc 1 1070 0
 3284 1cbc 012046E2 		sub	r2, r6, #1
1066:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3285              		.loc 1 1066 0
 3286 1cc0 30008DE5 		str	r0, [sp, #48]
 3287              	.LVL270:
1067:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3288              		.loc 1 1067 0
 3289 1cc4 34C08DE5 		str	ip, [sp, #52]
 3290              	.LVL271:
1070:../uvc.c      **** 			  switch(CtrlID)
 3291              		.loc 1 1070 0
 3292 1cc8 2C309DE5 		ldr	r3, [sp, #44]
 3293 1ccc 090052E3 		cmp	r2, #9
 3294 1cd0 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3295 1cd4 550100EA 		b	.L255
 3296              	.L260:
 3297 1cd8 EC210000 		.word	.L256
 3298 1cdc 30220000 		.word	.L255
 3299 1ce0 FC1E0000 		.word	.L257
 3300 1ce4 30220000 		.word	.L255
 3301 1ce8 30220000 		.word	.L255
 3302 1cec 30220000 		.word	.L255
 3303 1cf0 781E0000 		.word	.L258
 3304 1cf4 30220000 		.word	.L255
 3305 1cf8 30220000 		.word	.L255
 3306 1cfc FC1D0000 		.word	.L259
 3307              	.LVL272:
 3308              	.L241:
1040:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3309              		.loc 1 1040 0
 3310 1d00 E8479FE5 		ldr	r4, .L320+8
 3311 1d04 9B84D2E5 		ldrb	r8, [r2, #1179]	@ zero_extendqisi2
1041:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3312              		.loc 1 1041 0
 3313 1d08 9C24D2E5 		ldrb	r2, [r2, #1180]	@ zero_extendqisi2
1042:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3314              		.loc 1 1042 0
 3315 1d0c 0A0050E3 		cmp	r0, #10
1040:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3316              		.loc 1 1040 0
 3317 1d10 5C80C4E5 		strb	r8, [r4, #92]
1041:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3318              		.loc 1 1041 0
 3319 1d14 5D20C4E5 		strb	r2, [r4, #93]
1042:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3320              		.loc 1 1042 0
 3321 1d18 D2FFFF1A 		bne	.L253
 3322              	.LVL273:
 3323              	.L314:
1057:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3324              		.loc 1 1057 0 discriminator 1
 3325 1d1c 0110A0E3 		mov	r1, #1
 3326 1d20 5E10C4E5 		strb	r1, [r4, #94]
 3327 1d24 D1FFFFEA 		b	.L254
 3328              	.LVL274:
 3329              	.L242:
 997:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3330              		.loc 1 997 0
 3331 1d28 C0479FE5 		ldr	r4, .L320+8
 998:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3332              		.loc 1 998 0
 3333 1d2c 0030A0E3 		mov	r3, #0
 3334              	.LVL275:
 999:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3335              		.loc 1 999 0
 3336 1d30 0200A0E3 		mov	r0, #2
 3337              	.LVL276:
 3338 1d34 5C1084E2 		add	r1, r4, #92
1001:../uvc.c      **** 			  break;
 3339              		.loc 1 1001 0
 3340 1d38 FF60A0E3 		mov	r6, #255
 997:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3341              		.loc 1 997 0
 3342 1d3c 5C70C4E5 		strb	r7, [r4, #92]
 998:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3343              		.loc 1 998 0
 3344 1d40 5D30C4E5 		strb	r3, [r4, #93]
1001:../uvc.c      **** 			  break;
 3345              		.loc 1 1001 0
 3346 1d44 0680A0E1 		mov	r8, r6
 999:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3347              		.loc 1 999 0
 3348 1d48 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3349              	.LVL277:
 3350 1d4c 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1001:../uvc.c      **** 			  break;
 3351              		.loc 1 1001 0
 3352 1d50 ACFFFFEA 		b	.L246
 3353              	.LVL278:
 3354              	.L238:
1007:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3355              		.loc 1 1007 0
 3356 1d54 94479FE5 		ldr	r4, .L320+8
 3357 1d58 A1A4D2E5 		ldrb	sl, [r2, #1185]	@ zero_extendqisi2
1008:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3358              		.loc 1 1008 0
 3359 1d5c A2C4D2E5 		ldrb	ip, [r2, #1186]	@ zero_extendqisi2
1009:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3360              		.loc 1 1009 0
 3361 1d60 0080A0E3 		mov	r8, #0
1015:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3362              		.loc 1 1015 0
 3363 1d64 0700A0E1 		mov	r0, r7
 3364              	.LVL279:
 3365 1d68 5C1084E2 		add	r1, r4, #92
1020:../uvc.c      **** 			  break;
 3366              		.loc 1 1020 0
 3367 1d6c FF60A0E3 		mov	r6, #255
1008:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3368              		.loc 1 1008 0
 3369 1d70 5DC0C4E5 		strb	ip, [r4, #93]
1009:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3370              		.loc 1 1009 0
 3371 1d74 5E80C4E5 		strb	r8, [r4, #94]
1010:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3372              		.loc 1 1010 0
 3373 1d78 5F80C4E5 		strb	r8, [r4, #95]
 3374              	.LVL280:
1007:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3375              		.loc 1 1007 0
 3376 1d7c 5CA0C4E5 		strb	sl, [r4, #92]
1020:../uvc.c      **** 			  break;
 3377              		.loc 1 1020 0
 3378 1d80 0680A0E1 		mov	r8, r6
1015:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3379              		.loc 1 1015 0
 3380 1d84 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3381              	.LVL281:
 3382 1d88 0AC0A0E1 		mov	ip, sl
1020:../uvc.c      **** 			  break;
 3383              		.loc 1 1020 0
 3384 1d8c 9DFFFFEA 		b	.L246
 3385              	.LVL282:
 3386              	.L240:
1031:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3387              		.loc 1 1031 0
 3388 1d90 58479FE5 		ldr	r4, .L320+8
 3389 1d94 9934D2E5 		ldrb	r3, [r2, #1177]	@ zero_extendqisi2
 3390              	.LVL283:
1032:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3391              		.loc 1 1032 0
 3392 1d98 9AE4D2E5 		ldrb	lr, [r2, #1178]	@ zero_extendqisi2
1033:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3393              		.loc 1 1033 0
 3394 1d9c 0A0050E3 		cmp	r0, #10
1031:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3395              		.loc 1 1031 0
 3396 1da0 5C30C4E5 		strb	r3, [r4, #92]
1032:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3397              		.loc 1 1032 0
 3398 1da4 5DE0C4E5 		strb	lr, [r4, #93]
1033:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3399              		.loc 1 1033 0
 3400 1da8 AEFFFF1A 		bne	.L253
 3401 1dac DAFFFFEA 		b	.L314
 3402              	.LVL284:
 3403              	.L316:
1055:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3404              		.loc 1 1055 0
 3405 1db0 38479FE5 		ldr	r4, .L320+8
 3406 1db4 9F64D2E5 		ldrb	r6, [r2, #1183]	@ zero_extendqisi2
1056:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3407              		.loc 1 1056 0
 3408 1db8 A0C4D2E5 		ldrb	ip, [r2, #1184]	@ zero_extendqisi2
1057:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3409              		.loc 1 1057 0
 3410 1dbc 0A0050E3 		cmp	r0, #10
1055:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3411              		.loc 1 1055 0
 3412 1dc0 5C60C4E5 		strb	r6, [r4, #92]
1056:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3413              		.loc 1 1056 0
 3414 1dc4 5DC0C4E5 		strb	ip, [r4, #93]
1057:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3415              		.loc 1 1057 0
 3416 1dc8 A6FFFF1A 		bne	.L253
 3417 1dcc D2FFFFEA 		b	.L314
 3418              	.L243:
1049:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 3419              		.loc 1 1049 0
 3420 1dd0 18479FE5 		ldr	r4, .L320+8
 3421 1dd4 9D04D2E5 		ldrb	r0, [r2, #1181]	@ zero_extendqisi2
 3422              	.LVL285:
 3423 1dd8 0410A0E1 		mov	r1, r4
 3424 1ddc 5C00E1E5 		strb	r0, [r1, #92]!
1053:../uvc.c      **** 			  break;
 3425              		.loc 1 1053 0
 3426 1de0 FF60A0E3 		mov	r6, #255
1050:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3427              		.loc 1 1050 0
 3428 1de4 0100A0E3 		mov	r0, #1
 3429 1de8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3430              	.LVL286:
1053:../uvc.c      **** 			  break;
 3431              		.loc 1 1053 0
 3432 1dec 0680A0E1 		mov	r8, r6
1050:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3433              		.loc 1 1050 0
 3434 1df0 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1053:../uvc.c      **** 			  break;
 3435              		.loc 1 1053 0
 3436 1df4 0170A0E3 		mov	r7, #1
 3437 1df8 82FFFFEA 		b	.L246
 3438              	.LVL287:
 3439              	.L259:
1179:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3440              		.loc 1 1179 0
 3441 1dfc FC669FE5 		ldr	r6, .L320+24
 3442 1e00 0010E0E3 		mvn	r1, #0
 3443 1e04 1C0096E5 		ldr	r0, [r6, #28]
 3444 1e08 2C308DE5 		str	r3, [sp, #44]
 3445 1e0c FEFFFFEB 		bl	_txe_mutex_get
1180:../uvc.c      **** 					  if(getData == 1)
 3446              		.loc 1 1180 0
 3447 1e10 30E09DE5 		ldr	lr, [sp, #48]
 3448 1e14 2C309DE5 		ldr	r3, [sp, #44]
 3449 1e18 01005EE3 		cmp	lr, #1
 3450 1e1c A901000A 		beq	.L318
1182:../uvc.c      **** 					  else if(getData == 0xff)
 3451              		.loc 1 1182 0
 3452 1e20 FF005EE3 		cmp	lr, #255
 3453 1e24 9E01000A 		beq	.L319
1185:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
 3454              		.loc 1 1185 0
 3455 1e28 0080A0E3 		mov	r8, #0
 3456 1e2c 0600A0E1 		mov	r0, r6
 3457 1e30 1710A0E3 		mov	r1, #23
 3458 1e34 0B20A0E1 		mov	r2, fp
 3459 1e38 00808DE5 		str	r8, [sp, #0]
 3460 1e3c 04808DE5 		str	r8, [sp, #4]
 3461 1e40 FEFFFFEB 		bl	cmdSet
 3462              	.L312:
1188:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3463              		.loc 1 1188 0
 3464 1e44 1C0096E5 		ldr	r0, [r6, #28]
 3465 1e48 FEFFFFEB 		bl	_txe_mutex_put
1190:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 3466              		.loc 1 1190 0
 3467 1e4c 30809DE5 		ldr	r8, [sp, #48]
 3468 1e50 34609DE5 		ldr	r6, [sp, #52]
 3469 1e54 5EC0D4E5 		ldrb	ip, [r4, #94]	@ zero_extendqisi2
 3470 1e58 0400A0E3 		mov	r0, #4
 3471 1e5c A0169FE5 		ldr	r1, .L320+28
 3472 1e60 0820A0E1 		mov	r2, r8
 3473 1e64 0630A0E1 		mov	r3, r6
 3474 1e68 00C08DE5 		str	ip, [sp, #0]
 3475 1e6c FEFFFFEB 		bl	CyU3PDebugPrint
1191:../uvc.c      **** 					  break;
 3476              		.loc 1 1191 0
 3477 1e70 FFC0A0E3 		mov	ip, #255
 3478 1e74 63FFFFEA 		b	.L246
 3479              	.LVL288:
 3480              	.L258:
1156:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 3481              		.loc 1 1156 0
 3482 1e78 B984D8E5 		ldrb	r8, [r8, #1209]	@ zero_extendqisi2
 3483 1e7c 010058E3 		cmp	r8, #1
 3484 1e80 08005813 		cmpne	r8, #8
 3485 1e84 0000A013 		movne	r0, #0
 3486 1e88 0100A003 		moveq	r0, #1
 3487 1e8c 8001001A 		bne	.L309
 3488              	.LVL289:
1159:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3489              		.loc 1 1159 0
 3490 1e90 68869FE5 		ldr	r8, .L320+24
 3491 1e94 0010E0E3 		mvn	r1, #0
 3492 1e98 1C0098E5 		ldr	r0, [r8, #28]
 3493 1e9c 2C308DE5 		str	r3, [sp, #44]
 3494 1ea0 FEFFFFEB 		bl	_txe_mutex_get
1160:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
 3495              		.loc 1 1160 0
 3496 1ea4 30A09DE5 		ldr	sl, [sp, #48]
 3497 1ea8 1610A0E3 		mov	r1, #22
 3498 1eac 0B20A0E1 		mov	r2, fp
 3499 1eb0 2C309DE5 		ldr	r3, [sp, #44]
 3500 1eb4 00C0A0E3 		mov	ip, #0
 3501 1eb8 0800A0E1 		mov	r0, r8
 3502 1ebc 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 3503 1ec0 FEFFFFEB 		bl	cmdSet
1161:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3504              		.loc 1 1161 0
 3505 1ec4 1C0098E5 		ldr	r0, [r8, #28]
 3506 1ec8 FEFFFFEB 		bl	_txe_mutex_put
1164:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3507              		.loc 1 1164 0
 3508 1ecc 18069FE5 		ldr	r0, .L320+4
1165:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3509              		.loc 1 1165 0
 3510 1ed0 34209DE5 		ldr	r2, [sp, #52]
1164:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3511              		.loc 1 1164 0
 3512 1ed4 061089E0 		add	r1, r9, r6
 3513 1ed8 813180E0 		add	r3, r0, r1, asl #3
1166:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3514              		.loc 1 1166 0
 3515 1edc 0160A0E3 		mov	r6, #1
1164:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3516              		.loc 1 1164 0
 3517 1ee0 A1A4C3E5 		strb	sl, [r3, #1185]
1165:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3518              		.loc 1 1165 0
 3519 1ee4 A224C3E5 		strb	r2, [r3, #1186]
1166:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3520              		.loc 1 1166 0
 3521 1ee8 A464C3E5 		strb	r6, [r3, #1188]
 3522              	.LVL290:
 3523              	.L310:
1168:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3524              		.loc 1 1168 0
 3525 1eec 5C80D4E5 		ldrb	r8, [r4, #92]	@ zero_extendqisi2
 3526 1ef0 5D60D4E5 		ldrb	r6, [r4, #93]	@ zero_extendqisi2
1173:../uvc.c      **** 					  break;
 3527              		.loc 1 1173 0
 3528 1ef4 FFC0A0E3 		mov	ip, #255
 3529 1ef8 42FFFFEA 		b	.L246
 3530              	.LVL291:
 3531              	.L257:
1122:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 3532              		.loc 1 1122 0
 3533 1efc B904D8E5 		ldrb	r0, [r8, #1209]	@ zero_extendqisi2
 3534 1f00 010050E3 		cmp	r0, #1
 3535 1f04 04005013 		cmpne	r0, #4
 3536 1f08 5C01001A 		bne	.L267
1121:../uvc.c      **** 					  value = (value << 8)|Data0;
 3537              		.loc 1 1121 0
 3538 1f0c 30109DE5 		ldr	r1, [sp, #48]
 3539 1f10 34E09DE5 		ldr	lr, [sp, #52]
 3540 1f14 0E2481E1 		orr	r2, r1, lr, asl #8
1123:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 3541              		.loc 1 1123 0
 3542 1f18 F90052E3 		cmp	r2, #249
 3543 1f1c 5701008A 		bhi	.L267
1128:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3544              		.loc 1 1128 0
 3545 1f20 C8A042E2 		sub	sl, r2, #200
 3546 1f24 0AC8A0E1 		mov	ip, sl, asl #16
 3547 1f28 3CC08DE5 		str	ip, [sp, #60]
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3548              		.loc 1 1130 0
 3549 1f2c 27A062E2 		rsb	sl, r2, #39
 3550 1f30 38A08DE5 		str	sl, [sp, #56]
 3551 1f34 3CA09DE5 		ldr	sl, [sp, #60]
 3552 1f38 C81062E2 		rsb	r1, r2, #200
 3553 1f3c C80052E3 		cmp	r2, #200
1128:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3554              		.loc 1 1128 0
 3555 1f40 640042E2 		sub	r0, r2, #100
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3556              		.loc 1 1130 0
 3557 1f44 0118A0E1 		mov	r1, r1, asl #16
 3558 1f48 64E062E2 		rsb	lr, r2, #100
 3559 1f4c 2A18A081 		movhi	r1, sl, lsr #16
 3560 1f50 2118A091 		movls	r1, r1, lsr #16
1128:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3561              		.loc 1 1128 0
 3562 1f54 00C8A0E1 		mov	ip, r0, asl #16
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3563              		.loc 1 1130 0
 3564 1f58 640052E3 		cmp	r2, #100
 3565 1f5c 0E08A0E1 		mov	r0, lr, asl #16
 3566 1f60 2C08A081 		movhi	r0, ip, lsr #16
 3567 1f64 38C09DE5 		ldr	ip, [sp, #56]
1128:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3568              		.loc 1 1128 0
 3569 1f68 14A042E2 		sub	sl, r2, #20
 3570 1f6c 38A08DE5 		str	sl, [sp, #56]
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3571              		.loc 1 1130 0
 3572 1f70 2008A091 		movls	r0, r0, lsr #16
 3573 1f74 14A062E2 		rsb	sl, r2, #20
 3574 1f78 3CA08DE5 		str	sl, [sp, #60]
1128:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3575              		.loc 1 1128 0
 3576 1f7c 27E042E2 		sub	lr, r2, #39
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3577              		.loc 1 1130 0
 3578 1f80 000051E1 		cmp	r1, r0
 3579 1f84 01A0A031 		movcc	sl, r1
 3580 1f88 00A0A021 		movcs	sl, r0
 3581 1f8c 0CC8A0E1 		mov	ip, ip, asl #16
 3582 1f90 270052E3 		cmp	r2, #39
1128:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3583              		.loc 1 1128 0
 3584 1f94 0EE8A0E1 		mov	lr, lr, asl #16
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3585              		.loc 1 1130 0
 3586 1f98 2CE8A091 		movls	lr, ip, lsr #16
 3587 1f9c 64C59FE5 		ldr	ip, .L320+32
 3588 1fa0 20A08DE5 		str	sl, [sp, #32]
 3589 1fa4 01A06CE0 		rsb	sl, ip, r1
 3590 1fa8 2EE8A081 		movhi	lr, lr, lsr #16
 3591 1fac 00C07AE2 		rsbs	ip, sl, #0
 3592 1fb0 0AC0ACE0 		adc	ip, ip, sl
1128:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3593              		.loc 1 1128 0
 3594 1fb4 38A09DE5 		ldr	sl, [sp, #56]
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3595              		.loc 1 1130 0
 3596 1fb8 44C08DE5 		str	ip, [sp, #68]
 3597              	.LVL292:
1128:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3598              		.loc 1 1128 0
 3599 1fbc 0AC8A0E1 		mov	ip, sl, asl #16
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3600              		.loc 1 1130 0
 3601 1fc0 3CA09DE5 		ldr	sl, [sp, #60]
1128:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3602              		.loc 1 1128 0
 3603 1fc4 4CC08DE5 		str	ip, [sp, #76]
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3604              		.loc 1 1130 0
 3605 1fc8 0AC8A0E1 		mov	ip, sl, asl #16
1128:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3606              		.loc 1 1128 0
 3607 1fcc 0AA042E2 		sub	sl, r2, #10
 3608 1fd0 48A08DE5 		str	sl, [sp, #72]
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3609              		.loc 1 1130 0
 3610 1fd4 20A09DE5 		ldr	sl, [sp, #32]
 3611 1fd8 3CC08DE5 		str	ip, [sp, #60]
 3612 1fdc 0A005EE1 		cmp	lr, sl
 3613 1fe0 0EA0A031 		movcc	sl, lr
 3614 1fe4 0AC062E2 		rsb	ip, r2, #10
 3615 1fe8 40C08DE5 		str	ip, [sp, #64]
 3616 1fec 38A08DE5 		str	sl, [sp, #56]
 3617 1ff0 3CC09DE5 		ldr	ip, [sp, #60]
 3618 1ff4 4CA09DE5 		ldr	sl, [sp, #76]
 3619 1ff8 140052E3 		cmp	r2, #20
 3620 1ffc 2CA8A091 		movls	sl, ip, lsr #16
 3621 2000 2AA8A081 		movhi	sl, sl, lsr #16
 3622 2004 44C09DE5 		ldr	ip, [sp, #68]
 3623 2008 010050E1 		cmp	r0, r1
1128:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3624              		.loc 1 1128 0
 3625 200c 48109DE5 		ldr	r1, [sp, #72]
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3626              		.loc 1 1130 0
 3627 2010 01C0A033 		movcc	ip, #1
 3628 2014 3CA08DE5 		str	sl, [sp, #60]
 3629 2018 24C08DE5 		str	ip, [sp, #36]
1128:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3630              		.loc 1 1128 0
 3631 201c 01A8A0E1 		mov	sl, r1, asl #16
 3632 2020 05C042E2 		sub	ip, r2, #5
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3633              		.loc 1 1130 0
 3634 2024 051062E2 		rsb	r1, r2, #5
1128:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3635              		.loc 1 1128 0
 3636 2028 48A08DE5 		str	sl, [sp, #72]
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3637              		.loc 1 1130 0
 3638 202c 40009DE5 		ldr	r0, [sp, #64]
 3639 2030 38A09DE5 		ldr	sl, [sp, #56]
1128:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3640              		.loc 1 1128 0
 3641 2034 40C08DE5 		str	ip, [sp, #64]
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3642              		.loc 1 1130 0
 3643 2038 3CC09DE5 		ldr	ip, [sp, #60]
 3644 203c 4C108DE5 		str	r1, [sp, #76]
 3645 2040 48109DE5 		ldr	r1, [sp, #72]
 3646 2044 0008A0E1 		mov	r0, r0, asl #16
 3647 2048 0A005CE1 		cmp	ip, sl
 3648 204c 0AC0A021 		movcs	ip, sl
 3649 2050 0A0052E3 		cmp	r2, #10
 3650 2054 20A09DE5 		ldr	sl, [sp, #32]
 3651 2058 2108A081 		movhi	r0, r1, lsr #16
 3652 205c 2008A091 		movls	r0, r0, lsr #16
 3653 2060 48008DE5 		str	r0, [sp, #72]
 3654 2064 24009DE5 		ldr	r0, [sp, #36]
 3655 2068 0A005EE1 		cmp	lr, sl
 3656 206c 0200A033 		movcc	r0, #2
1128:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3657              		.loc 1 1128 0
 3658 2070 02E042E2 		sub	lr, r2, #2
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3659              		.loc 1 1130 0
 3660 2074 44C08DE5 		str	ip, [sp, #68]
 3661 2078 24008DE5 		str	r0, [sp, #36]
1128:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3662              		.loc 1 1128 0
 3663 207c 40C09DE5 		ldr	ip, [sp, #64]
 3664 2080 1CE08DE5 		str	lr, [sp, #28]
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3665              		.loc 1 1130 0
 3666 2084 44009DE5 		ldr	r0, [sp, #68]
 3667 2088 48E09DE5 		ldr	lr, [sp, #72]
 3668 208c 4C109DE5 		ldr	r1, [sp, #76]
 3669 2090 02A062E2 		rsb	sl, r2, #2
 3670 2094 00005EE1 		cmp	lr, r0
 3671 2098 00E0A021 		movcs	lr, r0
1128:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3672              		.loc 1 1128 0
 3673 209c 0CC8A0E1 		mov	ip, ip, asl #16
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3674              		.loc 1 1130 0
 3675 20a0 050052E3 		cmp	r2, #5
 3676 20a4 40A08DE5 		str	sl, [sp, #64]
 3677 20a8 0118A0E1 		mov	r1, r1, asl #16
 3678 20ac 3CA09DE5 		ldr	sl, [sp, #60]
 3679 20b0 2C18A081 		movhi	r1, ip, lsr #16
 3680 20b4 38C09DE5 		ldr	ip, [sp, #56]
 3681 20b8 4CE08DE5 		str	lr, [sp, #76]
 3682 20bc 24009DE5 		ldr	r0, [sp, #36]
 3683 20c0 40E09DE5 		ldr	lr, [sp, #64]
 3684 20c4 2118A091 		movls	r1, r1, lsr #16
 3685 20c8 0C005AE1 		cmp	sl, ip
 3686 20cc 20108DE5 		str	r1, [sp, #32]
 3687 20d0 0300A033 		movcc	r0, #3
 3688 20d4 38008DE5 		str	r0, [sp, #56]
 3689 20d8 4CA09DE5 		ldr	sl, [sp, #76]
 3690 20dc 0E08A0E1 		mov	r0, lr, asl #16
 3691 20e0 20E09DE5 		ldr	lr, [sp, #32]
1128:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3692              		.loc 1 1128 0
 3693 20e4 1C109DE5 		ldr	r1, [sp, #28]
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3694              		.loc 1 1130 0
 3695 20e8 0A005EE1 		cmp	lr, sl
 3696 20ec 0AE0A021 		movcs	lr, sl
 3697 20f0 44C09DE5 		ldr	ip, [sp, #68]
 3698 20f4 48A09DE5 		ldr	sl, [sp, #72]
 3699 20f8 020052E3 		cmp	r2, #2
1128:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3700              		.loc 1 1128 0
 3701 20fc 0118A0E1 		mov	r1, r1, asl #16
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3702              		.loc 1 1130 0
 3703 2100 2018A091 		movls	r1, r0, lsr #16
 3704 2104 38009DE5 		ldr	r0, [sp, #56]
 3705 2108 2118A081 		movhi	r1, r1, lsr #16
 3706 210c 0C005AE1 		cmp	sl, ip
 3707 2110 0400A033 		movcc	r0, #4
 3708 2114 40008DE5 		str	r0, [sp, #64]
1128:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3709              		.loc 1 1128 0
 3710 2118 010042E2 		sub	r0, r2, #1
 3711 211c 38008DE5 		str	r0, [sp, #56]
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3712              		.loc 1 1130 0
 3713 2120 4CA09DE5 		ldr	sl, [sp, #76]
 3714 2124 20009DE5 		ldr	r0, [sp, #32]
 3715 2128 01C062E2 		rsb	ip, r2, #1
 3716 212c 3CC08DE5 		str	ip, [sp, #60]
 3717 2130 0A0050E1 		cmp	r0, sl
1137:../uvc.c      **** 						  shutter = shutter+index;
 3718              		.loc 1 1137 0
 3719 2134 38A09DE5 		ldr	sl, [sp, #56]
 3720 2138 3C009DE5 		ldr	r0, [sp, #60]
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3721              		.loc 1 1130 0
 3722 213c 40C09DE5 		ldr	ip, [sp, #64]
 3723 2140 05C0A033 		movcc	ip, #5
1137:../uvc.c      **** 						  shutter = shutter+index;
 3724              		.loc 1 1137 0
 3725 2144 010052E3 		cmp	r2, #1
 3726 2148 0028A091 		movls	r2, r0, asl #16
 3727 214c 0A28A081 		movhi	r2, sl, asl #16
 3728 2150 0E0051E1 		cmp	r1, lr
 3729 2154 01A0A031 		movcc	sl, r1
 3730 2158 0EA0A021 		movcs	sl, lr
1130:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3731              		.loc 1 1130 0
 3732 215c 0E0051E1 		cmp	r1, lr
 3733 2160 0C10A021 		movcs	r1, ip
 3734 2164 0610A033 		movcc	r1, #6
1137:../uvc.c      **** 						  shutter = shutter+index;
 3735              		.loc 1 1137 0
 3736 2168 22085AE1 		cmp	sl, r2, lsr #16
1140:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3737              		.loc 1 1140 0
 3738 216c 8CA39FE5 		ldr	sl, .L320+24
1137:../uvc.c      **** 						  shutter = shutter+index;
 3739              		.loc 1 1137 0
 3740 2170 0120A091 		movls	r2, r1
 3741 2174 0720A083 		movhi	r2, #7
 3742 2178 012082E2 		add	r2, r2, #1
 3743 217c FFE002E2 		and	lr, r2, #255
1140:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3744              		.loc 1 1140 0
 3745 2180 0010E0E3 		mvn	r1, #0
 3746 2184 1C009AE5 		ldr	r0, [sl, #28]
1137:../uvc.c      **** 						  shutter = shutter+index;
 3747              		.loc 1 1137 0
 3748 2188 38E08DE5 		str	lr, [sp, #56]
 3749              	.LVL293:
1140:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3750              		.loc 1 1140 0
 3751 218c 2C308DE5 		str	r3, [sp, #44]
 3752 2190 FEFFFFEB 		bl	_txe_mutex_get
1141:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 3753              		.loc 1 1141 0
 3754 2194 38C09DE5 		ldr	ip, [sp, #56]
 3755 2198 0310A0E3 		mov	r1, #3
 3756 219c 0B20A0E1 		mov	r2, fp
 3757 21a0 2C309DE5 		ldr	r3, [sp, #44]
 3758 21a4 00C08DE5 		str	ip, [sp, #0]
 3759 21a8 0A00A0E1 		mov	r0, sl
 3760 21ac 00C0A0E3 		mov	ip, #0
 3761 21b0 04C08DE5 		str	ip, [sp, #4]
 3762 21b4 FEFFFFEB 		bl	cmdSet
1142:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3763              		.loc 1 1142 0
 3764 21b8 1C009AE5 		ldr	r0, [sl, #28]
 3765 21bc FEFFFFEB 		bl	_txe_mutex_put
1145:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3766              		.loc 1 1145 0
 3767 21c0 30009DE5 		ldr	r0, [sp, #48]
1146:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3768              		.loc 1 1146 0
 3769 21c4 34C09DE5 		ldr	ip, [sp, #52]
1148:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3770              		.loc 1 1148 0
 3771 21c8 38309DE5 		ldr	r3, [sp, #56]
1145:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3772              		.loc 1 1145 0
 3773 21cc 061089E0 		add	r1, r9, r6
 3774 21d0 816188E0 		add	r6, r8, r1, asl #3
1147:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3775              		.loc 1 1147 0
 3776 21d4 0120A0E3 		mov	r2, #1
1145:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3777              		.loc 1 1145 0
 3778 21d8 A104C6E5 		strb	r0, [r6, #1185]
1146:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3779              		.loc 1 1146 0
 3780 21dc A2C4C6E5 		strb	ip, [r6, #1186]
1147:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3781              		.loc 1 1147 0
 3782 21e0 A424C6E5 		strb	r2, [r6, #1188]
1148:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3783              		.loc 1 1148 0
 3784 21e4 0D33C8E5 		strb	r3, [r8, #781]
 3785 21e8 3FFFFFEA 		b	.L310
 3786              	.LVL294:
 3787              	.L256:
1075:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3788              		.loc 1 1075 0
 3789 21ec 062089E0 		add	r2, r9, r6
 3790 21f0 826188E0 		add	r6, r8, r2, asl #3
1076:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3791              		.loc 1 1076 0
 3792 21f4 0110A0E3 		mov	r1, #1
1079:../uvc.c      **** 		  		    switch (getData){
 3793              		.loc 1 1079 0
 3794 21f8 01E040E2 		sub	lr, r0, #1
1075:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3795              		.loc 1 1075 0
 3796 21fc A104C6E5 		strb	r0, [r6, #1185]
1076:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3797              		.loc 1 1076 0
 3798 2200 A414C6E5 		strb	r1, [r6, #1188]
 3799              	.LVL295:
1079:../uvc.c      **** 		  		    switch (getData){
 3800              		.loc 1 1079 0
 3801 2204 07005EE3 		cmp	lr, #7
 3802 2208 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 3803 220c 970000EA 		b	.L261
 3804              	.L266:
 3805 2210 04240000 		.word	.L262
 3806 2214 68230000 		.word	.L263
 3807 2218 70240000 		.word	.L261
 3808 221c 04230000 		.word	.L264
 3809 2220 70240000 		.word	.L261
 3810 2224 70240000 		.word	.L261
 3811 2228 70240000 		.word	.L261
 3812 222c 64220000 		.word	.L265
 3813              	.LVL296:
 3814              	.L255:
1195:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3815              		.loc 1 1195 0
 3816 2230 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1194:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3817              		.loc 1 1194 0
 3818 2234 30A09DE5 		ldr	sl, [sp, #48]
 3819 2238 069089E0 		add	r9, r9, r6
 3820 223c 89E188E0 		add	lr, r8, r9, asl #3
1195:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3821              		.loc 1 1195 0
 3822 2240 0620A0E1 		mov	r2, r6
 3823 2244 0400A0E3 		mov	r0, #4
 3824 2248 BC129FE5 		ldr	r1, .L320+36
1194:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3825              		.loc 1 1194 0
 3826 224c A1A4CEE5 		strb	sl, [lr, #1185]
1195:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3827              		.loc 1 1195 0
 3828 2250 FEFFFFEB 		bl	CyU3PDebugPrint
1196:../uvc.c      **** 			  		 break;
 3829              		.loc 1 1196 0
 3830 2254 FFC0A0E3 		mov	ip, #255
 3831 2258 0C60A0E1 		mov	r6, ip
 3832 225c 0C80A0E1 		mov	r8, ip
 3833 2260 68FEFFEA 		b	.L246
 3834              	.LVL297:
 3835              	.L265:
1098:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3836              		.loc 1 1098 0
 3837 2264 94629FE5 		ldr	r6, .L320+24
1096:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3838              		.loc 1 1096 0
 3839 2268 00A0A0E3 		mov	sl, #0
1098:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3840              		.loc 1 1098 0
 3841 226c 1C0096E5 		ldr	r0, [r6, #28]
1096:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3842              		.loc 1 1096 0
 3843 2270 0DA3C8E5 		strb	sl, [r8, #781]
 3844              	.LVL298:
1098:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3845              		.loc 1 1098 0
 3846 2274 0010E0E3 		mvn	r1, #0
 3847 2278 2C308DE5 		str	r3, [sp, #44]
 3848 227c FEFFFFEB 		bl	_txe_mutex_get
1099:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3849              		.loc 1 1099 0
 3850 2280 0B20A0E1 		mov	r2, fp
 3851 2284 2C309DE5 		ldr	r3, [sp, #44]
 3852 2288 1010A0E3 		mov	r1, #16
 3853 228c 0600A0E1 		mov	r0, r6
 3854 2290 00A08DE5 		str	sl, [sp, #0]
 3855 2294 04A08DE5 		str	sl, [sp, #4]
 3856 2298 FEFFFFEB 		bl	cmdSet
1100:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3857              		.loc 1 1100 0
 3858 229c 1C0096E5 		ldr	r0, [r6, #28]
 3859 22a0 FEFFFFEB 		bl	_txe_mutex_put
 3860              	.LVL299:
 3861              	.LBB64:
 3862              	.LBB65:
 414:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3863              		.loc 1 414 0
 3864 22a4 0010E0E3 		mvn	r1, #0
 3865 22a8 1C0096E5 		ldr	r0, [r6, #28]
 3866 22ac FEFFFFEB 		bl	_txe_mutex_get
 415:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3867              		.loc 1 415 0
 3868 22b0 0180A0E3 		mov	r8, #1
 3869 22b4 1410A0E3 		mov	r1, #20
 3870 22b8 2720A0E3 		mov	r2, #39
 3871 22bc 3030A0E3 		mov	r3, #48
 3872 22c0 0600A0E1 		mov	r0, r6
 3873 22c4 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3874 22c8 FEFFFFEB 		bl	cmdSet
 416:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3875              		.loc 1 416 0
 3876 22cc 02C0A0E3 		mov	ip, #2
 3877 22d0 1510A0E3 		mov	r1, #21
 3878 22d4 2520A0E3 		mov	r2, #37
 3879 22d8 3030A0E3 		mov	r3, #48
 3880 22dc 0600A0E1 		mov	r0, r6
 3881 22e0 00C08DE5 		str	ip, [sp, #0]
 3882 22e4 04A08DE5 		str	sl, [sp, #4]
 3883 22e8 FEFFFFEB 		bl	cmdSet
 417:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3884              		.loc 1 417 0
 3885 22ec 1C0096E5 		ldr	r0, [r6, #28]
 3886 22f0 FEFFFFEB 		bl	_txe_mutex_put
 3887              	.LBE65:
 3888              	.LBE64:
1102:../uvc.c      **** 							break;
 3889              		.loc 1 1102 0
 3890 22f4 FFC0A0E3 		mov	ip, #255
 3891 22f8 0C60A0E1 		mov	r6, ip
 3892 22fc 0880A0E3 		mov	r8, #8
 3893 2300 40FEFFEA 		b	.L246
 3894              	.LVL300:
 3895              	.L264:
 3896              	.LBB66:
 3897              	.LBB67:
 414:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3898              		.loc 1 414 0
 3899 2304 F4819FE5 		ldr	r8, .L320+24
 3900 2308 0010E0E3 		mvn	r1, #0
 3901 230c 1C0098E5 		ldr	r0, [r8, #28]
 3902 2310 FEFFFFEB 		bl	_txe_mutex_get
 415:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3903              		.loc 1 415 0
 3904 2314 0060A0E3 		mov	r6, #0
 3905 2318 1410A0E3 		mov	r1, #20
 3906 231c 2720A0E3 		mov	r2, #39
 3907 2320 3030A0E3 		mov	r3, #48
 3908 2324 0800A0E1 		mov	r0, r8
 3909 2328 00608DE5 		str	r6, [sp, #0]
 3910 232c 04608DE5 		str	r6, [sp, #4]
 3911 2330 FEFFFFEB 		bl	cmdSet
 416:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3912              		.loc 1 416 0
 3913 2334 1510A0E3 		mov	r1, #21
 3914 2338 2520A0E3 		mov	r2, #37
 3915 233c 3030A0E3 		mov	r3, #48
 3916 2340 0800A0E1 		mov	r0, r8
 3917 2344 00608DE5 		str	r6, [sp, #0]
 3918 2348 04608DE5 		str	r6, [sp, #4]
 3919 234c FEFFFFEB 		bl	cmdSet
 417:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3920              		.loc 1 417 0
 3921 2350 1C0098E5 		ldr	r0, [r8, #28]
 3922 2354 FEFFFFEB 		bl	_txe_mutex_put
 3923 2358 FFC0A0E3 		mov	ip, #255
 3924 235c 0C60A0E1 		mov	r6, ip
 3925 2360 0480A0E3 		mov	r8, #4
 3926 2364 27FEFFEA 		b	.L246
 3927              	.LVL301:
 3928              	.L263:
 3929              	.LBE67:
 3930              	.LBE66:
1086:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3931              		.loc 1 1086 0
 3932 2368 90A19FE5 		ldr	sl, .L320+24
1084:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3933              		.loc 1 1084 0
 3934 236c 0060A0E3 		mov	r6, #0
 3935 2370 0D63C8E5 		strb	r6, [r8, #781]
 3936              	.LVL302:
1086:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3937              		.loc 1 1086 0
 3938 2374 0010E0E3 		mvn	r1, #0
 3939 2378 1C009AE5 		ldr	r0, [sl, #28]
 3940 237c 2C308DE5 		str	r3, [sp, #44]
 3941 2380 FEFFFFEB 		bl	_txe_mutex_get
1087:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3942              		.loc 1 1087 0
 3943 2384 0B20A0E1 		mov	r2, fp
 3944 2388 2C309DE5 		ldr	r3, [sp, #44]
 3945 238c 1010A0E3 		mov	r1, #16
 3946 2390 0A00A0E1 		mov	r0, sl
 3947 2394 00608DE5 		str	r6, [sp, #0]
 3948 2398 04608DE5 		str	r6, [sp, #4]
 3949 239c FEFFFFEB 		bl	cmdSet
1088:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3950              		.loc 1 1088 0
 3951 23a0 1C009AE5 		ldr	r0, [sl, #28]
 3952 23a4 FEFFFFEB 		bl	_txe_mutex_put
 3953              	.LVL303:
 3954              	.LBB68:
 3955              	.LBB69:
 414:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3956              		.loc 1 414 0
 3957 23a8 0010E0E3 		mvn	r1, #0
 3958 23ac 1C009AE5 		ldr	r0, [sl, #28]
 3959 23b0 FEFFFFEB 		bl	_txe_mutex_get
 415:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3960              		.loc 1 415 0
 3961 23b4 1410A0E3 		mov	r1, #20
 3962 23b8 2720A0E3 		mov	r2, #39
 3963 23bc 3030A0E3 		mov	r3, #48
 3964 23c0 0A00A0E1 		mov	r0, sl
 3965 23c4 00608DE5 		str	r6, [sp, #0]
 3966 23c8 04608DE5 		str	r6, [sp, #4]
 3967 23cc FEFFFFEB 		bl	cmdSet
 416:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3968              		.loc 1 416 0
 3969 23d0 1510A0E3 		mov	r1, #21
 3970 23d4 2520A0E3 		mov	r2, #37
 3971 23d8 3030A0E3 		mov	r3, #48
 3972 23dc 0A00A0E1 		mov	r0, sl
 3973 23e0 00608DE5 		str	r6, [sp, #0]
 3974 23e4 04608DE5 		str	r6, [sp, #4]
 3975 23e8 FEFFFFEB 		bl	cmdSet
 417:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3976              		.loc 1 417 0
 3977 23ec 1C009AE5 		ldr	r0, [sl, #28]
 3978 23f0 FEFFFFEB 		bl	_txe_mutex_put
 3979 23f4 FFC0A0E3 		mov	ip, #255
 3980 23f8 0C60A0E1 		mov	r6, ip
 3981 23fc 0280A0E3 		mov	r8, #2
 3982 2400 00FEFFEA 		b	.L246
 3983              	.LVL304:
 3984              	.L262:
 3985              	.LBE69:
 3986              	.LBE68:
 3987              	.LBB70:
 3988              	.LBB71:
 414:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3989              		.loc 1 414 0
 3990 2404 F4609FE5 		ldr	r6, .L320+24
 3991 2408 0010E0E3 		mvn	r1, #0
 3992 240c 1C0096E5 		ldr	r0, [r6, #28]
 3993 2410 FEFFFFEB 		bl	_txe_mutex_get
 415:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3994              		.loc 1 415 0
 3995 2414 0080A0E3 		mov	r8, #0
 3996 2418 01A0A0E3 		mov	sl, #1
 3997 241c 1410A0E3 		mov	r1, #20
 3998 2420 2720A0E3 		mov	r2, #39
 3999 2424 3030A0E3 		mov	r3, #48
 4000 2428 0600A0E1 		mov	r0, r6
 4001 242c 04808DE5 		str	r8, [sp, #4]
 4002 2430 00A08DE5 		str	sl, [sp, #0]
 4003 2434 FEFFFFEB 		bl	cmdSet
 416:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 4004              		.loc 1 416 0
 4005 2438 02C0A0E3 		mov	ip, #2
 4006 243c 1510A0E3 		mov	r1, #21
 4007 2440 2520A0E3 		mov	r2, #37
 4008 2444 3030A0E3 		mov	r3, #48
 4009 2448 0600A0E1 		mov	r0, r6
 4010 244c 00C08DE5 		str	ip, [sp, #0]
 4011 2450 04808DE5 		str	r8, [sp, #4]
 4012 2454 FEFFFFEB 		bl	cmdSet
 417:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4013              		.loc 1 417 0
 4014 2458 1C0096E5 		ldr	r0, [r6, #28]
 4015 245c FEFFFFEB 		bl	_txe_mutex_put
 4016              	.LBE71:
 4017              	.LBE70:
1082:../uvc.c      **** 							break;
 4018              		.loc 1 1082 0
 4019 2460 FFC0A0E3 		mov	ip, #255
 4020 2464 0C60A0E1 		mov	r6, ip
 4021 2468 0A80A0E1 		mov	r8, sl
 4022 246c E5FDFFEA 		b	.L246
 4023              	.LVL305:
 4024              	.L261:
1079:../uvc.c      **** 		  		    switch (getData){
 4025              		.loc 1 1079 0
 4026 2470 FFC0A0E3 		mov	ip, #255
 4027 2474 0080A0E1 		mov	r8, r0
 4028 2478 0C60A0E1 		mov	r6, ip
 4029 247c E1FDFFEA 		b	.L246
 4030              	.LVL306:
 4031              	.L267:
1150:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4032              		.loc 1 1150 0
 4033 2480 0000A0E3 		mov	r0, #0
 4034 2484 0110A0E3 		mov	r1, #1
 4035 2488 0020A0E1 		mov	r2, r0
 4036 248c FEFFFFEB 		bl	CyU3PUsbStall
 4037              	.LVL307:
 4038 2490 95FEFFEA 		b	.L310
 4039              	.LVL308:
 4040              	.L309:
1168:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4041              		.loc 1 1168 0
 4042 2494 0110A0E3 		mov	r1, #1
 4043 2498 0020A0E1 		mov	r2, r0
 4044 249c FEFFFFEB 		bl	CyU3PUsbStall
 4045 24a0 91FEFFEA 		b	.L310
 4046              	.LVL309:
 4047              	.L319:
1183:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 4048              		.loc 1 1183 0
 4049 24a4 08E0A0E3 		mov	lr, #8
 4050 24a8 00C0A0E3 		mov	ip, #0
 4051 24ac 0600A0E1 		mov	r0, r6
 4052 24b0 1710A0E3 		mov	r1, #23
 4053 24b4 0B20A0E1 		mov	r2, fp
 4054 24b8 00E08DE5 		str	lr, [sp, #0]
 4055 24bc 04C08DE5 		str	ip, [sp, #4]
 4056 24c0 FEFFFFEB 		bl	cmdSet
 4057 24c4 5EFEFFEA 		b	.L312
 4058              	.L318:
1181:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 4059              		.loc 1 1181 0
 4060 24c8 0480A0E3 		mov	r8, #4
 4061 24cc 00E0A0E3 		mov	lr, #0
 4062 24d0 0600A0E1 		mov	r0, r6
 4063 24d4 1710A0E3 		mov	r1, #23
 4064 24d8 0B20A0E1 		mov	r2, fp
 4065 24dc 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 4066 24e0 FEFFFFEB 		bl	cmdSet
 4067 24e4 56FEFFEA 		b	.L312
 4068              	.L321:
 4069              		.align	2
 4070              	.L320:
 4071 24e8 00000000 		.word	bRequest
 4072 24ec 00000000 		.word	.LANCHOR1
 4073 24f0 00000000 		.word	.LANCHOR0
 4074 24f4 50040000 		.word	.LC26
 4075 24f8 74040000 		.word	.LC27
 4076 24fc 5C000000 		.word	.LANCHOR0+92
 4077 2500 00000000 		.word	cmdQu
 4078 2504 04040000 		.word	.LC24
 4079 2508 FFFF0000 		.word	65535
 4080 250c 2C040000 		.word	.LC25
 4081              		.cfi_endproc
 4082              	.LFE3:
 4084              		.align	2
 4085              		.global	UVCAppEP0Thread_Entry
 4087              	UVCAppEP0Thread_Entry:
 4088              	.LFB24:
3237:../uvc.c      **** {
 4089              		.loc 1 3237 0
 4090              		.cfi_startproc
 4091              		@ args = 0, pretend = 0, frame = 32
 4092              		@ frame_needed = 0, uses_anonymous_args = 0
 4093              	.LVL310:
 4094 2510 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4095              	.LCFI17:
 4096              		.cfi_def_cfa_offset 36
 4097 2514 4C4B9FE5 		ldr	r4, .L486
 4098              		.cfi_offset 14, -4
 4099              		.cfi_offset 11, -8
 4100              		.cfi_offset 10, -12
 4101              		.cfi_offset 9, -16
 4102              		.cfi_offset 8, -20
 4103              		.cfi_offset 7, -24
 4104              		.cfi_offset 6, -28
 4105              		.cfi_offset 5, -32
 4106              		.cfi_offset 4, -36
 4107 2518 4C6B9FE5 		ldr	r6, .L486+4
 4108 251c 4C8B9FE5 		ldr	r8, .L486+8
 4109 2520 4C9B9FE5 		ldr	r9, .L486+12
 4110 2524 4CAB9FE5 		ldr	sl, .L486+16
 4111 2528 4C7B9FE5 		ldr	r7, .L486+20
 4112 252c 3CD04DE2 		sub	sp, sp, #60
 4113              	.LCFI18:
 4114              		.cfi_def_cfa_offset 96
 4115              	.LVL311:
3259:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 4116              		.loc 1 3259 0
 4117 2530 0450A0E1 		mov	r5, r4
 4118              	.LVL312:
 4119              	.L457:
 4120 2534 00C0E0E3 		mvn	ip, #0
 4121 2538 280B9FE5 		ldr	r0, .L486
 4122 253c 4C10A0E3 		mov	r1, #76
 4123 2540 0120A0E3 		mov	r2, #1
 4124 2544 30308DE2 		add	r3, sp, #48
 4125 2548 00C08DE5 		str	ip, [sp, #0]
 4126 254c FEFFFFEB 		bl	_txe_event_flags_get
 4127 2550 000050E3 		cmp	r0, #0
 4128 2554 3000001A 		bne	.L323
3263:../uvc.c      ****             if (!isUsbConnected)
 4129              		.loc 1 3263 0
 4130 2558 403095E5 		ldr	r3, [r5, #64]
 4131 255c 000053E3 		cmp	r3, #0
 4132 2560 8900000A 		beq	.L476
 4133              	.L324:
3272:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 4134              		.loc 1 3272 0
 4135 2564 30309DE5 		ldr	r3, [sp, #48]
 4136 2568 0C0013E3 		tst	r3, #12
 4137 256c 7200001A 		bne	.L477
 4138              	.L325:
3279:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 4139              		.loc 1 3279 0
 4140 2570 040013E3 		tst	r3, #4
 4141 2574 1C00000A 		beq	.L326
3281:../uvc.c      ****             	switch ((wIndex >> 8))
 4142              		.loc 1 3281 0
 4143 2578 B0E0DAE1 		ldrh	lr, [sl, #0]
 4144 257c 2E24A0E1 		mov	r2, lr, lsr #8
 4145 2580 030052E3 		cmp	r2, #3
 4146 2584 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4147 2588 120000EA 		b	.L327
 4148              	.L332:
 4149 258c D8250000 		.word	.L327
 4150 2590 BC260000 		.word	.L329
 4151 2594 9C250000 		.word	.L330
 4152 2598 F8260000 		.word	.L331
 4153              	.L330:
 4154              	.LBB86:
 4155              	.LBB88:
2532:../uvc.c      ****     switch (wValue)
 4156              		.loc 1 2532 0
 4157 259c B020D9E1 		ldrh	r2, [r9, #0]
 4158 25a0 060C52E3 		cmp	r2, #1536
 4159 25a4 E001000A 		beq	.L338
 4160 25a8 D700008A 		bhi	.L344
 4161 25ac 030C52E3 		cmp	r2, #768
 4162 25b0 D901000A 		beq	.L336
 4163 25b4 D001008A 		bhi	.L345
 4164 25b8 010C52E3 		cmp	r2, #256
 4165 25bc 6F01000A 		beq	.L334
 4166 25c0 020C52E3 		cmp	r2, #512
 4167 25c4 6901000A 		beq	.L478
 4168              	.L347:
 4169              	.LBE88:
 4170              	.LBE86:
 4171              	.LBB91:
 4172              	.LBB95:
2664:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 4173              		.loc 1 2664 0
 4174 25c8 B01A9FE5 		ldr	r1, .L486+24
 4175 25cc 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4176 25d0 0400A0E3 		mov	r0, #4
 4177 25d4 FEFFFFEB 		bl	CyU3PDebugPrint
 4178              	.L327:
 4179              	.LBE95:
 4180              	.LBE91:
3302:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4181              		.loc 1 3302 0
 4182 25d8 0000A0E3 		mov	r0, #0
 4183 25dc 0110A0E3 		mov	r1, #1
 4184 25e0 0020A0E1 		mov	r2, r0
 4185 25e4 FEFFFFEB 		bl	CyU3PUsbStall
 4186 25e8 30309DE5 		ldr	r3, [sp, #48]
 4187              	.L326:
3307:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 4188              		.loc 1 3307 0
 4189 25ec 080013E3 		tst	r3, #8
 4190 25f0 0700000A 		beq	.L388
3311:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 4191              		.loc 1 3311 0
 4192 25f4 B030DAE1 		ldrh	r3, [sl, #0]
 4193 25f8 010053E3 		cmp	r3, #1
 4194 25fc 6800000A 		beq	.L389
 4195              	.L390:
 4196              	.LBB100:
 4197              	.LBB106:
3226:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4198              		.loc 1 3226 0
 4199 2600 0000A0E3 		mov	r0, #0
 4200 2604 0110A0E3 		mov	r1, #1
 4201 2608 0020A0E1 		mov	r2, r0
 4202 260c FEFFFFEB 		bl	CyU3PUsbStall
 4203              	.L466:
 4204 2610 30309DE5 		ldr	r3, [sp, #48]
 4205              	.L388:
 4206              	.LBE106:
 4207              	.LBE100:
3322:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 4208              		.loc 1 3322 0
 4209 2614 400013E3 		tst	r3, #64
 4210 2618 0100001A 		bne	.L479
 4211              	.L323:
3535:../uvc.c      ****         CyU3PThreadRelinquish ();
 4212              		.loc 1 3535 0
 4213 261c FEFFFFEB 		bl	_txe_thread_relinquish
3536:../uvc.c      ****     }
 4214              		.loc 1 3536 0
 4215 2620 C3FFFFEA 		b	.L457
 4216              	.L479:
3327:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 4217              		.loc 1 3327 0
 4218 2624 1800A0E3 		mov	r0, #24
 4219 2628 2C108DE2 		add	r1, sp, #44
 4220 262c FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
3332:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4221              		.loc 1 3332 0
 4222 2630 2C209DE5 		ldr	r2, [sp, #44]
 4223 2634 000052E3 		cmp	r2, #0
 4224 2638 6D00000A 		beq	.L452
3332:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4225              		.loc 1 3332 0 is_stmt 0 discriminator 1
 4226 263c 7F36D6E5 		ldrb	r3, [r6, #1663]	@ zero_extendqisi2
 4227 2640 000053E3 		cmp	r3, #0
 4228 2644 F4FFFF1A 		bne	.L323
3334:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4229              		.loc 1 3334 0 is_stmt 1
 4230 2648 002097E5 		ldr	r2, [r7, #0]
 4231 264c 02B0A0E3 		mov	fp, #2
 4232 2650 00B0C2E5 		strb	fp, [r2, #0]
3335:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4233              		.loc 1 3335 0
 4234 2654 001097E5 		ldr	r1, [r7, #0]
 4235 2658 01B0A0E3 		mov	fp, #1
 4236 265c 01B0C1E5 		strb	fp, [r1, #1]
3336:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4237              		.loc 1 3336 0
 4238 2660 000097E5 		ldr	r0, [r7, #0]
3340:../uvc.c      **** 					interStabuf.size   = 1024;
 4239              		.loc 1 3340 0
 4240 2664 01EBA0E3 		mov	lr, #1024	@ movhi
3336:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4241              		.loc 1 3336 0
 4242 2668 0230C0E5 		strb	r3, [r0, #2]
3337:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4243              		.loc 1 3337 0
 4244 266c 00C097E5 		ldr	ip, [r7, #0]
3346:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4245              		.loc 1 3346 0
 4246 2670 0010E0E3 		mvn	r1, #0
3337:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4247              		.loc 1 3337 0
 4248 2674 0330CCE5 		strb	r3, [ip, #3]
3339:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4249              		.loc 1 3339 0
 4250 2678 002097E5 		ldr	r2, [r7, #0]
3341:../uvc.c      **** 					interStabuf.status = 0;
 4251              		.loc 1 3341 0
 4252 267c B832CDE1 		strh	r3, [sp, #40]	@ movhi
3346:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4253              		.loc 1 3346 0
 4254 2680 FC099FE5 		ldr	r0, .L486+28
3343:../uvc.c      **** 					interStabuf.count = 4;
 4255              		.loc 1 3343 0
 4256 2684 0430A0E3 		mov	r3, #4	@ movhi
3339:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4257              		.loc 1 3339 0
 4258 2688 20208DE5 		str	r2, [sp, #32]
3340:../uvc.c      **** 					interStabuf.size   = 1024;
 4259              		.loc 1 3340 0
 4260 268c B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
3343:../uvc.c      **** 					interStabuf.count = 4;
 4261              		.loc 1 3343 0
 4262 2690 B432CDE1 		strh	r3, [sp, #36]	@ movhi
3346:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4263              		.loc 1 3346 0
 4264 2694 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3349:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4265              		.loc 1 3349 0
 4266 2698 E4099FE5 		ldr	r0, .L486+28
 4267 269c 20108DE2 		add	r1, sp, #32
 4268 26a0 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4269              	.LVL313:
3350:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4270              		.loc 1 3350 0
 4271 26a4 002050E2 		subs	r2, r0, #0
 4272 26a8 6E01001A 		bne	.L480
3355:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
 4273              		.loc 1 3355 0
 4274 26ac B8399FE5 		ldr	r3, .L486+4
 4275 26b0 7FB6C3E5 		strb	fp, [r3, #1663]
3535:../uvc.c      ****         CyU3PThreadRelinquish ();
 4276              		.loc 1 3535 0
 4277 26b4 FEFFFFEB 		bl	_txe_thread_relinquish
 4278              	.LVL314:
 4279 26b8 9DFFFFEA 		b	.L457
 4280              	.L329:
 4281              	.LBB112:
 4282              	.LBB96:
2607:../uvc.c      ****     switch (wValue)
 4283              		.loc 1 2607 0
 4284 26bc B020D9E1 		ldrh	r2, [r9, #0]
 4285 26c0 060C52E3 		cmp	r2, #1536
 4286 26c4 DC00000A 		beq	.L353
 4287 26c8 9A00008A 		bhi	.L359
 4288 26cc 030C52E3 		cmp	r2, #768
 4289 26d0 1E01000A 		beq	.L350
 4290 26d4 1501008A 		bhi	.L360
 4291 26d8 010C52E3 		cmp	r2, #256
 4292 26dc 5D01000A 		beq	.L348
 4293 26e0 020C52E3 		cmp	r2, #512
 4294 26e4 B7FFFF1A 		bne	.L347
 4295              	.LVL315:
2615:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 4296              		.loc 1 2615 0
 4297 26e8 0100A0E3 		mov	r0, #1
 4298 26ec FEFFFFEB 		bl	CTControlHandle
 4299              	.LVL316:
 4300 26f0 30309DE5 		ldr	r3, [sp, #48]
 4301 26f4 BCFFFFEA 		b	.L326
 4302              	.L331:
 4303              	.LBE96:
 4304              	.LBE112:
 4305              	.LBB113:
 4306              	.LBB118:
2832:../uvc.c      ****     switch (wValue)
 4307              		.loc 1 2832 0
 4308 26f8 B030D9E1 		ldrh	r3, [r9, #0]
 4309 26fc 090C53E3 		cmp	r3, #2304
 4310 2700 4502000A 		beq	.L374
 4311 2704 9300008A 		bhi	.L383
 4312 2708 010B53E3 		cmp	r3, #1024
 4313 270c 3E02000A 		beq	.L369
 4314 2710 8E01008A 		bhi	.L384
 4315 2714 020C53E3 		cmp	r3, #512
 4316 2718 3702000A 		beq	.L367
 4317 271c 030C53E3 		cmp	r3, #768
 4318 2720 3102000A 		beq	.L368
 4319 2724 010C53E3 		cmp	r3, #256
 4320 2728 AAFFFF1A 		bne	.L327
 4321              	.LVL317:
2836:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 4322              		.loc 1 2836 0
 4323 272c 1000A0E3 		mov	r0, #16
 4324 2730 FEFFFFEB 		bl	ControlHandle
 4325              	.LVL318:
 4326 2734 30309DE5 		ldr	r3, [sp, #48]
 4327 2738 ABFFFFEA 		b	.L326
 4328              	.L477:
 4329              	.LBE118:
 4330              	.LBE113:
3273:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 4331              		.loc 1 3273 0
 4332 273c 44B99FE5 		ldr	fp, .L486+32
 4333 2740 B0C0D9E1 		ldrh	ip, [r9, #0]
 4334 2744 B000DAE1 		ldrh	r0, [sl, #0]
 4335 2748 3C199FE5 		ldr	r1, .L486+36
 4336 274c 00E0DBE5 		ldrb	lr, [fp, #0]	@ zero_extendqisi2
 4337 2750 00B0D8E5 		ldrb	fp, [r8, #0]	@ zero_extendqisi2
 4338 2754 0C008DE5 		str	r0, [sp, #12]
 4339 2758 08C08DE5 		str	ip, [sp, #8]
 4340 275c B0C0D1E1 		ldrh	ip, [r1, #0]
 4341 2760 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
 4342 2764 04B08DE5 		str	fp, [sp, #4]
 4343 2768 0400A0E3 		mov	r0, #4
 4344 276c 1C199FE5 		ldr	r1, .L486+40
 4345 2770 00B0A0E3 		mov	fp, #0
 4346 2774 00E08DE5 		str	lr, [sp, #0]
 4347 2778 10C08DE5 		str	ip, [sp, #16]
 4348 277c 14B08DE5 		str	fp, [sp, #20]
 4349 2780 FEFFFFEB 		bl	CyU3PDebugPrint
 4350 2784 30309DE5 		ldr	r3, [sp, #48]
 4351 2788 78FFFFEA 		b	.L325
 4352              	.L476:
3265:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4353              		.loc 1 3265 0
 4354 278c FEFFFFEB 		bl	CyU3PUsbGetSpeed
3266:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4355              		.loc 1 3266 0
 4356 2790 000050E3 		cmp	r0, #0
3265:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4357              		.loc 1 3265 0
 4358 2794 4800C5E5 		strb	r0, [r5, #72]
3268:../uvc.c      ****                     isUsbConnected = CyTrue;
 4359              		.loc 1 3268 0
 4360 2798 0100A013 		movne	r0, #1
 4361 279c 40008515 		strne	r0, [r5, #64]
 4362 27a0 6FFFFFEA 		b	.L324
 4363              	.L389:
 4364              	.LVL319:
 4365              	.LBB124:
 4366              	.LBB105:
2927:../uvc.c      ****     switch (wValue)
 4367              		.loc 1 2927 0
 4368 27a4 B020D9E1 		ldrh	r2, [r9, #0]
 4369 27a8 030C52E3 		cmp	r2, #768
 4370 27ac 8800000A 		beq	.L393
 4371 27b0 3300008A 		bhi	.L396
 4372 27b4 010C52E3 		cmp	r2, #256
 4373 27b8 9200000A 		beq	.L391
 4374 27bc 020C52E3 		cmp	r2, #512
 4375 27c0 8EFFFF1A 		bne	.L390
2992:../uvc.c      ****             switch (bRequest)
 4376              		.loc 1 2992 0
 4377 27c4 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4378 27c8 810053E3 		cmp	r3, #129
 4379 27cc FE01000A 		beq	.L445
 4380 27d0 2D01008A 		bhi	.L411
 4381 27d4 010053E3 		cmp	r3, #1
 4382 27d8 A601000A 		beq	.L481
 4383              	.L434:
3167:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4384              		.loc 1 3167 0
 4385 27dc 0000A0E3 		mov	r0, #0
 4386 27e0 0110A0E3 		mov	r1, #1
 4387 27e4 0020A0E1 		mov	r2, r0
 4388 27e8 FEFFFFEB 		bl	CyU3PUsbStall
 4389 27ec 30309DE5 		ldr	r3, [sp, #48]
 4390 27f0 87FFFFEA 		b	.L388
 4391              	.LVL320:
 4392              	.L452:
 4393              	.LBE105:
 4394              	.LBE124:
3356:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
 4395              		.loc 1 3356 0
 4396 27f4 7FE6D6E5 		ldrb	lr, [r6, #1663]	@ zero_extendqisi2
 4397 27f8 00005EE3 		cmp	lr, #0
 4398 27fc 86FFFF0A 		beq	.L323
3358:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4399              		.loc 1 3358 0
 4400 2800 003097E5 		ldr	r3, [r7, #0]
 4401 2804 02B0A0E3 		mov	fp, #2
 4402 2808 00B0C3E5 		strb	fp, [r3, #0]
3359:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4403              		.loc 1 3359 0
 4404 280c 001097E5 		ldr	r1, [r7, #0]
 4405 2810 01B0A0E3 		mov	fp, #1
 4406 2814 01B0C1E5 		strb	fp, [r1, #1]
3360:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4407              		.loc 1 3360 0
 4408 2818 000097E5 		ldr	r0, [r7, #0]
3364:../uvc.c      **** 					interStabuf.size   = 1024;
 4409              		.loc 1 3364 0
 4410 281c 01EBA0E3 		mov	lr, #1024	@ movhi
3360:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4411              		.loc 1 3360 0
 4412 2820 0220C0E5 		strb	r2, [r0, #2]
3361:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4413              		.loc 1 3361 0
 4414 2824 00C097E5 		ldr	ip, [r7, #0]
3370:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4415              		.loc 1 3370 0
 4416 2828 0010E0E3 		mvn	r1, #0
3361:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4417              		.loc 1 3361 0
 4418 282c 03B0CCE5 		strb	fp, [ip, #3]
3363:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4419              		.loc 1 3363 0
 4420 2830 003097E5 		ldr	r3, [r7, #0]
3365:../uvc.c      **** 					interStabuf.status = 0;
 4421              		.loc 1 3365 0
 4422 2834 02C0A0E1 		mov	ip, r2	@ movhi
 4423 2838 B822CDE1 		strh	r2, [sp, #40]	@ movhi
3370:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4424              		.loc 1 3370 0
 4425 283c 40089FE5 		ldr	r0, .L486+28
3367:../uvc.c      **** 					interStabuf.count = 4;
 4426              		.loc 1 3367 0
 4427 2840 0420A0E3 		mov	r2, #4	@ movhi
3363:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4428              		.loc 1 3363 0
 4429 2844 20308DE5 		str	r3, [sp, #32]
3367:../uvc.c      **** 					interStabuf.count = 4;
 4430              		.loc 1 3367 0
 4431 2848 B422CDE1 		strh	r2, [sp, #36]	@ movhi
3364:../uvc.c      **** 					interStabuf.size   = 1024;
 4432              		.loc 1 3364 0
 4433 284c B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
3370:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4434              		.loc 1 3370 0
 4435 2850 1CC08DE5 		str	ip, [sp, #28]
 4436 2854 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3373:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4437              		.loc 1 3373 0
 4438 2858 24089FE5 		ldr	r0, .L486+28
 4439 285c 20108DE2 		add	r1, sp, #32
 4440 2860 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4441              	.LVL321:
3374:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4442              		.loc 1 3374 0
 4443 2864 1C309DE5 		ldr	r3, [sp, #28]
 4444 2868 002050E2 		subs	r2, r0, #0
 4445 286c C700001A 		bne	.L482
3380:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4446              		.loc 1 3380 0
 4447 2870 F4279FE5 		ldr	r2, .L486+4
3381:../uvc.c      **** 					stiflag = CyTrue;
 4448              		.loc 1 3381 0
 4449 2874 A0B084E5 		str	fp, [r4, #160]
3380:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4450              		.loc 1 3380 0
 4451 2878 7F36C2E5 		strb	r3, [r2, #1663]
3535:../uvc.c      ****         CyU3PThreadRelinquish ();
 4452              		.loc 1 3535 0
 4453 287c FEFFFFEB 		bl	_txe_thread_relinquish
 4454              	.LVL322:
 4455 2880 2BFFFFEA 		b	.L457
 4456              	.LVL323:
 4457              	.L396:
 4458              	.LBB125:
 4459              	.LBB107:
2927:../uvc.c      ****     switch (wValue)
 4460              		.loc 1 2927 0
 4461 2884 010B52E3 		cmp	r2, #1024
 4462 2888 3F00000A 		beq	.L394
 4463 288c 050C52E3 		cmp	r2, #1280
 4464 2890 5AFFFF1A 		bne	.L390
3173:../uvc.c      ****                 switch (bRequest)
 4465              		.loc 1 3173 0
 4466 2894 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4467 2898 810052E3 		cmp	r2, #129
 4468 289c CA01000A 		beq	.L445
 4469 28a0 2501008A 		bhi	.L448
 4470 28a4 010052E3 		cmp	r2, #1
 4471 28a8 54FFFF1A 		bne	.L390
3198:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4472              		.loc 1 3198 0
 4473 28ac 2000A0E3 		mov	r0, #32
 4474 28b0 DC179FE5 		ldr	r1, .L486+44
 4475 28b4 36208DE2 		add	r2, sp, #54
 4476 28b8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4477              	.LVL324:
3200:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4478              		.loc 1 3200 0
 4479 28bc 000050E3 		cmp	r0, #0
 4480 28c0 6601001A 		bne	.L450
3204:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 4481              		.loc 1 3204 0
 4482 28c4 0020A0E3 		mov	r2, #0
 4483 28c8 98079FE5 		ldr	r0, .L486
 4484              	.LVL325:
 4485 28cc 8010A0E3 		mov	r1, #128
 4486 28d0 FEFFFFEB 		bl	_txe_event_flags_set
 4487              	.LVL326:
3205:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4488              		.loc 1 3205 0
 4489 28d4 002050E2 		subs	r2, r0, #0
 4490 28d8 0200000A 		beq	.L451
3207:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
 4491              		.loc 1 3207 0
 4492 28dc 0400A0E3 		mov	r0, #4
 4493              	.LVL327:
 4494 28e0 B0179FE5 		ldr	r1, .L486+48
 4495 28e4 FEFFFFEB 		bl	CyU3PDebugPrint
 4496              	.LVL328:
 4497              	.L451:
3212:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
 4498              		.loc 1 3212 0
 4499 28e8 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
3210:../uvc.c      ****                             stiflag = CyTrue;//set still flag
 4500              		.loc 1 3210 0
 4501 28ec 01C0A0E3 		mov	ip, #1
3212:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
 4502              		.loc 1 3212 0
 4503 28f0 0400A0E3 		mov	r0, #4
 4504 28f4 A0179FE5 		ldr	r1, .L486+52
 4505 28f8 B623DDE1 		ldrh	r2, [sp, #54]
3210:../uvc.c      ****                             stiflag = CyTrue;//set still flag
 4506              		.loc 1 3210 0
 4507 28fc A0C084E5 		str	ip, [r4, #160]
3212:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
 4508              		.loc 1 3212 0
 4509 2900 FEFFFFEB 		bl	CyU3PDebugPrint
 4510 2904 30309DE5 		ldr	r3, [sp, #48]
 4511 2908 41FFFFEA 		b	.L388
 4512              	.L344:
 4513              	.LBE107:
 4514              	.LBE125:
 4515              	.LBB126:
 4516              	.LBB89:
2532:../uvc.c      ****     switch (wValue)
 4517              		.loc 1 2532 0
 4518 290c 0A0C52E3 		cmp	r2, #2560
 4519 2910 F100000A 		beq	.L341
 4520 2914 E600008A 		bhi	.L346
 4521 2918 070C52E3 		cmp	r2, #1792
 4522 291c E000000A 		beq	.L339
 4523 2920 020B52E3 		cmp	r2, #2048
 4524 2924 27FFFF1A 		bne	.L347
 4525              	.LVL329:
2563:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 4526              		.loc 1 2563 0
 4527 2928 0700A0E3 		mov	r0, #7
 4528 292c FEFFFFEB 		bl	ControlHandle
 4529              	.LVL330:
 4530 2930 30309DE5 		ldr	r3, [sp, #48]
 4531 2934 2CFFFFEA 		b	.L326
 4532              	.L359:
 4533              	.LBE89:
 4534              	.LBE126:
 4535              	.LBB127:
 4536              	.LBB94:
2607:../uvc.c      ****     switch (wValue)
 4537              		.loc 1 2607 0
 4538 2938 090C52E3 		cmp	r2, #2304
 4539 293c 2201000A 		beq	.L355
 4540 2940 1701008A 		bhi	.L361
 4541 2944 070C52E3 		cmp	r2, #1792
 4542 2948 0901000A 		beq	.L354
 4543 294c 020B52E3 		cmp	r2, #2048
 4544 2950 1CFFFF1A 		bne	.L347
 4545 2954 24FFFFEA 		b	.L326
 4546              	.L383:
 4547              	.LBE94:
 4548              	.LBE127:
 4549              	.LBB128:
 4550              	.LBB119:
2832:../uvc.c      ****     switch (wValue)
 4551              		.loc 1 2832 0
 4552 2958 0F0C53E3 		cmp	r3, #3840
 4553 295c 3B01000A 		beq	.L378
 4554 2960 3900008A 		bhi	.L386
 4555 2964 0B0C53E3 		cmp	r3, #2816
 4556 2968 3401000A 		beq	.L376
 4557 296c 0D0C53E3 		cmp	r3, #3328
 4558 2970 2E01000A 		beq	.L377
 4559 2974 0A0C53E3 		cmp	r3, #2560
 4560 2978 16FFFF1A 		bne	.L327
 4561              	.LVL331:
2873:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 4562              		.loc 1 2873 0
 4563 297c 1900A0E3 		mov	r0, #25
 4564 2980 FEFFFFEB 		bl	ControlHandle
 4565              	.LVL332:
 4566 2984 30309DE5 		ldr	r3, [sp, #48]
 4567 2988 17FFFFEA 		b	.L326
 4568              	.LVL333:
 4569              	.L394:
 4570              	.LBE119:
 4571              	.LBE128:
 4572              	.LBB129:
 4573              	.LBB104:
3118:../uvc.c      ****                 switch (bRequest)
 4574              		.loc 1 3118 0
 4575 298c 00B0D8E5 		ldrb	fp, [r8, #0]	@ zero_extendqisi2
 4576 2990 81005BE3 		cmp	fp, #129
 4577 2994 1300000A 		beq	.L436
 4578 2998 8500008A 		bhi	.L439
 4579 299c 01005BE3 		cmp	fp, #1
 4580 29a0 8DFFFF1A 		bne	.L434
3143:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4581              		.loc 1 3143 0
 4582 29a4 36208DE2 		add	r2, sp, #54
 4583 29a8 2000A0E3 		mov	r0, #32
 4584 29ac E0169FE5 		ldr	r1, .L486+44
 4585 29b0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4586              	.LVL334:
3145:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4587              		.loc 1 3145 0
 4588 29b4 002050E2 		subs	r2, r0, #0
 4589 29b8 14FFFF1A 		bne	.L466
3158:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
 4590              		.loc 1 3158 0
 4591 29bc A4069FE5 		ldr	r0, .L486
 4592              	.LVL335:
 4593 29c0 0B10A0E1 		mov	r1, fp
 4594 29c4 FEFFFFEB 		bl	_txe_event_flags_set
 4595              	.LVL336:
3159:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4596              		.loc 1 3159 0
 4597 29c8 002050E2 		subs	r2, r0, #0
 4598 29cc 0FFFFF0A 		beq	.L466
 4599 29d0 4E0100EA 		b	.L442
 4600              	.LVL337:
 4601              	.L393:
3069:../uvc.c      ****                 switch (bRequest)
 4602              		.loc 1 3069 0
 4603 29d4 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4604 29d8 830052E3 		cmp	r2, #131
 4605 29dc 9800008A 		bhi	.L430
 4606 29e0 810052E3 		cmp	r2, #129
 4607 29e4 7D00003A 		bcc	.L483
 4608              	.L436:
3130:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4609              		.loc 1 3130 0
 4610 29e8 48B0D4E5 		ldrb	fp, [r4, #72]	@ zero_extendqisi2
3132:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4611              		.loc 1 3132 0
 4612 29ec 0B00A0E3 		mov	r0, #11
3130:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4613              		.loc 1 3130 0
 4614 29f0 03005BE3 		cmp	fp, #3
3132:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4615              		.loc 1 3132 0
 4616 29f4 A4169F05 		ldreq	r1, .L486+56
3136:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4617              		.loc 1 3136 0
 4618 29f8 A4169F15 		ldrne	r1, .L486+60
 4619 29fc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4620 2a00 30309DE5 		ldr	r3, [sp, #48]
 4621 2a04 02FFFFEA 		b	.L388
 4622              	.L391:
2930:../uvc.c      ****             switch (bRequest)
 4623              		.loc 1 2930 0
 4624 2a08 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4625 2a0c 830052E3 		cmp	r2, #131
 4626 2a10 2F00008A 		bhi	.L402
 4627 2a14 810052E3 		cmp	r2, #129
 4628 2a18 1400003A 		bcc	.L484
 4629              	.L399:
2945:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
 4630              		.loc 1 2945 0
 4631 2a1c 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 4632 2a20 030053E3 		cmp	r3, #3
 4633 2a24 F800000A 		beq	.L485
 4634              	.L449:
3191:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4635              		.loc 1 3191 0
 4636 2a28 1A00A0E3 		mov	r0, #26
 4637 2a2c 74169FE5 		ldr	r1, .L486+64
 4638 2a30 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4639 2a34 30309DE5 		ldr	r3, [sp, #48]
 4640 2a38 F5FEFFEA 		b	.L388
 4641              	.LVL338:
 4642              	.L353:
 4643              	.LBE104:
 4644              	.LBE129:
 4645              	.LBB130:
 4646              	.LBB97:
2633:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 4647              		.loc 1 2633 0
 4648 2a3c 0500A0E3 		mov	r0, #5
 4649 2a40 FEFFFFEB 		bl	CTControlHandle
 4650              	.LVL339:
 4651 2a44 30309DE5 		ldr	r3, [sp, #48]
 4652 2a48 E7FEFFEA 		b	.L326
 4653              	.L386:
 4654              	.LBE97:
 4655              	.LBE130:
 4656              	.LBB131:
 4657              	.LBB117:
2832:../uvc.c      ****     switch (wValue)
 4658              		.loc 1 2832 0
 4659 2a4c 110C53E3 		cmp	r3, #4352
 4660 2a50 E900000A 		beq	.L380
 4661 2a54 2D00008A 		bhi	.L387
 4662 2a58 010A53E3 		cmp	r3, #4096
 4663 2a5c DDFEFF1A 		bne	.L327
 4664              	.LVL340:
2895:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 4665              		.loc 1 2895 0
 4666 2a60 1F00A0E3 		mov	r0, #31
 4667 2a64 FEFFFFEB 		bl	ControlHandle
 4668              	.LVL341:
 4669 2a68 30309DE5 		ldr	r3, [sp, #48]
 4670 2a6c DEFEFFEA 		b	.L326
 4671              	.LVL342:
 4672              	.L484:
 4673              	.LBE117:
 4674              	.LBE131:
 4675              	.LBB132:
 4676              	.LBB108:
2930:../uvc.c      ****             switch (bRequest)
 4677              		.loc 1 2930 0
 4678 2a70 010052E3 		cmp	r2, #1
 4679 2a74 58FFFF1A 		bne	.L434
2957:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4680              		.loc 1 2957 0
 4681 2a78 2000A0E3 		mov	r0, #32
 4682 2a7c 10169FE5 		ldr	r1, .L486+44
 4683 2a80 36208DE2 		add	r2, sp, #54
 4684 2a84 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4685              	.LVL343:
2959:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 4686              		.loc 1 2959 0
 4687 2a88 000050E3 		cmp	r0, #0
 4688 2a8c DFFEFF1A 		bne	.L466
2961:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4689              		.loc 1 2961 0
 4690 2a90 4810D5E5 		ldrb	r1, [r5, #72]	@ zero_extendqisi2
 4691 2a94 030051E3 		cmp	r1, #3
 4692 2a98 DCFEFF1A 		bne	.L466
2968:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 4693              		.loc 1 2968 0
 4694 2a9c 8530D4E5 		ldrb	r3, [r4, #133]	@ zero_extendqisi2
2965:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 4695              		.loc 1 2965 0
 4696 2aa0 82E0D4E5 		ldrb	lr, [r4, #130]	@ zero_extendqisi2
2966:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 4697              		.loc 1 2966 0
 4698 2aa4 83C0D4E5 		ldrb	ip, [r4, #131]	@ zero_extendqisi2
2967:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 4699              		.loc 1 2967 0
 4700 2aa8 8400D4E5 		ldrb	r0, [r4, #132]	@ zero_extendqisi2
 4701              	.LVL344:
2969:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 4702              		.loc 1 2969 0
 4703 2aac 8620D4E5 		ldrb	r2, [r4, #134]	@ zero_extendqisi2
2970:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 4704              		.loc 1 2970 0
 4705 2ab0 87B0D4E5 		ldrb	fp, [r4, #135]	@ zero_extendqisi2
2968:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 4706              		.loc 1 2968 0
 4707 2ab4 1936C6E5 		strb	r3, [r6, #1561]
2965:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 4708              		.loc 1 2965 0
 4709 2ab8 16E6C6E5 		strb	lr, [r6, #1558]
2966:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 4710              		.loc 1 2966 0
 4711 2abc 17C6C6E5 		strb	ip, [r6, #1559]
2967:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 4712              		.loc 1 2967 0
 4713 2ac0 1806C6E5 		strb	r0, [r6, #1560]
2969:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 4714              		.loc 1 2969 0
 4715 2ac4 1A26C6E5 		strb	r2, [r6, #1562]
2970:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 4716              		.loc 1 2970 0
 4717 2ac8 1BB6C6E5 		strb	fp, [r6, #1563]
 4718 2acc 30309DE5 		ldr	r3, [sp, #48]
 4719 2ad0 CFFEFFEA 		b	.L388
 4720              	.LVL345:
 4721              	.L402:
2930:../uvc.c      ****             switch (bRequest)
 4722              		.loc 1 2930 0
 4723 2ad4 860052E3 		cmp	r2, #134
 4724 2ad8 3900000A 		beq	.L470
 4725 2adc 870052E3 		cmp	r2, #135
 4726 2ae0 CDFFFF0A 		beq	.L399
 4727              	.L475:
3069:../uvc.c      ****                 switch (bRequest)
 4728              		.loc 1 3069 0
 4729 2ae4 850052E3 		cmp	r2, #133
 4730 2ae8 3BFFFF1A 		bne	.L434
 4731              	.L437:
3127:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4732              		.loc 1 3127 0
 4733 2aec B8159FE5 		ldr	r1, .L486+68
 4734 2af0 0200A0E3 		mov	r0, #2
3125:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 4735              		.loc 1 3125 0
 4736 2af4 1A30A0E3 		mov	r3, #26
 4737              	.L467:
3181:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4738              		.loc 1 3181 0
 4739 2af8 0020A0E3 		mov	r2, #0
3180:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 4740              		.loc 1 3180 0
 4741 2afc 5C30C4E5 		strb	r3, [r4, #92]
3181:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4742              		.loc 1 3181 0
 4743 2b00 5D20C4E5 		strb	r2, [r4, #93]
3182:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4744              		.loc 1 3182 0
 4745 2b04 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4746 2b08 30309DE5 		ldr	r3, [sp, #48]
 4747 2b0c C0FEFFEA 		b	.L388
 4748              	.LVL346:
 4749              	.L387:
 4750              	.LBE108:
 4751              	.LBE132:
 4752              	.LBB133:
 4753              	.LBB120:
2832:../uvc.c      ****     switch (wValue)
 4754              		.loc 1 2832 0
 4755 2b10 120C53E3 		cmp	r3, #4608
 4756 2b14 4F01000A 		beq	.L381
 4757 2b18 130C53E3 		cmp	r3, #4864
 4758 2b1c ADFEFF1A 		bne	.L327
 4759              	.LVL347:
2907:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
 4760              		.loc 1 2907 0
 4761 2b20 2200A0E3 		mov	r0, #34
 4762 2b24 FEFFFFEB 		bl	ControlHandle
 4763              	.LVL348:
 4764 2b28 30309DE5 		ldr	r3, [sp, #48]
 4765 2b2c AEFEFFEA 		b	.L326
 4766              	.L360:
 4767              	.LBE120:
 4768              	.LBE133:
 4769              	.LBB134:
 4770              	.LBB93:
2607:../uvc.c      ****     switch (wValue)
 4771              		.loc 1 2607 0
 4772 2b30 010B52E3 		cmp	r2, #1024
 4773 2b34 0900000A 		beq	.L351
 4774 2b38 050C52E3 		cmp	r2, #1280
 4775 2b3c A1FEFF1A 		bne	.L347
 4776              	.LVL349:
2629:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 4777              		.loc 1 2629 0
 4778 2b40 0400A0E3 		mov	r0, #4
 4779 2b44 FEFFFFEB 		bl	CTControlHandle
 4780              	.LVL350:
 4781 2b48 30309DE5 		ldr	r3, [sp, #48]
 4782 2b4c A6FEFFEA 		b	.L326
 4783              	.L350:
 4784              	.LVL351:
2619:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 4785              		.loc 1 2619 0
 4786 2b50 0200A0E3 		mov	r0, #2
 4787 2b54 FEFFFFEB 		bl	CTControlHandle
 4788              	.LVL352:
 4789 2b58 30309DE5 		ldr	r3, [sp, #48]
 4790 2b5c A2FEFFEA 		b	.L326
 4791              	.L351:
 4792              	.LVL353:
2624:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 4793              		.loc 1 2624 0
 4794 2b60 0300A0E3 		mov	r0, #3
 4795 2b64 FEFFFFEB 		bl	CTControlHandle
 4796              	.LVL354:
 4797 2b68 30309DE5 		ldr	r3, [sp, #48]
 4798 2b6c 9EFEFFEA 		b	.L326
 4799              	.L478:
 4800              	.LVL355:
 4801              	.LBE93:
 4802              	.LBE134:
 4803              	.LBB135:
 4804              	.LBB87:
2540:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 4805              		.loc 1 2540 0
 4806 2b70 0100A0E3 		mov	r0, #1
 4807 2b74 FEFFFFEB 		bl	ControlHandle
 4808              	.LVL356:
 4809 2b78 30309DE5 		ldr	r3, [sp, #48]
 4810 2b7c 9AFEFFEA 		b	.L326
 4811              	.L334:
 4812              	.LVL357:
2536:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 4813              		.loc 1 2536 0
 4814 2b80 0000A0E3 		mov	r0, #0
 4815 2b84 FEFFFFEB 		bl	ControlHandle
 4816              	.LVL358:
 4817 2b88 30309DE5 		ldr	r3, [sp, #48]
 4818 2b8c 96FEFFEA 		b	.L326
 4819              	.LVL359:
 4820              	.L482:
 4821              	.LBE87:
 4822              	.LBE135:
3376:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4823              		.loc 1 3376 0
 4824 2b90 0400A0E3 		mov	r0, #4
 4825              	.LVL360:
 4826 2b94 14159FE5 		ldr	r1, .L486+72
 4827 2b98 FEFFFFEB 		bl	CyU3PDebugPrint
 4828              	.LVL361:
 4829              	.L456:
 4830              	.LBB136:
 4831              	.LBB137:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4832              		.loc 1 1314 0
 4833 2b9c 10159FE5 		ldr	r1, .L486+76
 4834 2ba0 0400A0E3 		mov	r0, #4
 4835 2ba4 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 4836              		.loc 1 1315 0
 4837 2ba8 FA0FA0E3 		mov	r0, #1000
 4838 2bac FEFFFFEB 		bl	_tx_thread_sleep
 4839 2bb0 F9FFFFEA 		b	.L456
 4840              	.LVL362:
 4841              	.L439:
 4842              	.LBE137:
 4843              	.LBE136:
 4844              	.LBB138:
 4845              	.LBB103:
3118:../uvc.c      ****                 switch (bRequest)
 4846              		.loc 1 3118 0
 4847 2bb4 85005BE3 		cmp	fp, #133
 4848 2bb8 CBFFFF0A 		beq	.L437
 4849 2bbc 86005BE3 		cmp	fp, #134
 4850 2bc0 05FFFF1A 		bne	.L434
 4851              	.L470:
3122:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4852              		.loc 1 3122 0
 4853 2bc4 0300A0E1 		mov	r0, r3
 4854              	.L465:
2996:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4855              		.loc 1 2996 0
 4856 2bc8 DC149FE5 		ldr	r1, .L486+68
2995:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4857              		.loc 1 2995 0
 4858 2bcc 03B0A0E3 		mov	fp, #3
 4859 2bd0 5CB0C4E5 		strb	fp, [r4, #92]
2996:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4860              		.loc 1 2996 0
 4861 2bd4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4862 2bd8 30309DE5 		ldr	r3, [sp, #48]
 4863 2bdc 8CFEFFEA 		b	.L388
 4864              	.L483:
3069:../uvc.c      ****                 switch (bRequest)
 4865              		.loc 1 3069 0
 4866 2be0 010052E3 		cmp	r2, #1
 4867 2be4 FCFEFF1A 		bne	.L434
3094:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4868              		.loc 1 3094 0
 4869 2be8 2000A0E3 		mov	r0, #32
 4870 2bec A0149FE5 		ldr	r1, .L486+44
 4871 2bf0 36208DE2 		add	r2, sp, #54
 4872 2bf4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4873              	.LVL363:
3096:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4874              		.loc 1 3096 0
 4875 2bf8 000050E3 		cmp	r0, #0
 4876 2bfc 83FEFF1A 		bne	.L466
3098:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 4877              		.loc 1 3098 0
 4878 2c00 4810D5E5 		ldrb	r1, [r5, #72]	@ zero_extendqisi2
 4879 2c04 030051E3 		cmp	r1, #3
 4880 2c08 80FEFF1A 		bne	.L466
3105:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4881              		.loc 1 3105 0
 4882 2c0c 8430D5E5 		ldrb	r3, [r5, #132]	@ zero_extendqisi2
3102:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4883              		.loc 1 3102 0
 4884 2c10 81E0D5E5 		ldrb	lr, [r5, #129]	@ zero_extendqisi2
3103:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4885              		.loc 1 3103 0
 4886 2c14 82C0D5E5 		ldrb	ip, [r5, #130]	@ zero_extendqisi2
3104:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4887              		.loc 1 3104 0
 4888 2c18 8300D5E5 		ldrb	r0, [r5, #131]	@ zero_extendqisi2
 4889              	.LVL364:
3106:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4890              		.loc 1 3106 0
 4891 2c1c 8520D5E5 		ldrb	r2, [r5, #133]	@ zero_extendqisi2
3107:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4892              		.loc 1 3107 0
 4893 2c20 86B0D5E5 		ldrb	fp, [r5, #134]	@ zero_extendqisi2
3105:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4894              		.loc 1 3105 0
 4895 2c24 6C36C6E5 		strb	r3, [r6, #1644]
3102:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4896              		.loc 1 3102 0
 4897 2c28 69E6C6E5 		strb	lr, [r6, #1641]
3103:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4898              		.loc 1 3103 0
 4899 2c2c 6AC6C6E5 		strb	ip, [r6, #1642]
3104:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4900              		.loc 1 3104 0
 4901 2c30 6B06C6E5 		strb	r0, [r6, #1643]
3106:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4902              		.loc 1 3106 0
 4903 2c34 6D26C6E5 		strb	r2, [r6, #1645]
3107:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4904              		.loc 1 3107 0
 4905 2c38 6EB6C6E5 		strb	fp, [r6, #1646]
 4906 2c3c 30309DE5 		ldr	r3, [sp, #48]
 4907 2c40 73FEFFEA 		b	.L388
 4908              	.LVL365:
 4909              	.L430:
3069:../uvc.c      ****                 switch (bRequest)
 4910              		.loc 1 3069 0
 4911 2c44 860052E3 		cmp	r2, #134
 4912 2c48 DDFFFF0A 		beq	.L470
 4913 2c4c 870052E3 		cmp	r2, #135
 4914 2c50 A3FFFF1A 		bne	.L475
 4915 2c54 63FFFFEA 		b	.L436
 4916              	.LVL366:
 4917              	.L348:
 4918              	.LBE103:
 4919              	.LBE138:
 4920              	.LBB139:
 4921              	.LBB98:
2611:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 4922              		.loc 1 2611 0
 4923 2c58 0000A0E3 		mov	r0, #0
 4924 2c5c FEFFFFEB 		bl	CTControlHandle
 4925              	.LVL367:
 4926 2c60 30309DE5 		ldr	r3, [sp, #48]
 4927 2c64 60FEFFEA 		b	.L326
 4928              	.LVL368:
 4929              	.L480:
 4930              	.LBE98:
 4931              	.LBE139:
3352:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4932              		.loc 1 3352 0
 4933 2c68 0400A0E3 		mov	r0, #4
 4934              	.LVL369:
 4935 2c6c 3C149FE5 		ldr	r1, .L486+72
 4936 2c70 FEFFFFEB 		bl	CyU3PDebugPrint
 4937              	.LVL370:
 4938              	.L454:
 4939              	.LBB140:
 4940              	.LBB141:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4941              		.loc 1 1314 0
 4942 2c74 38149FE5 		ldr	r1, .L486+76
 4943 2c78 0400A0E3 		mov	r0, #4
 4944 2c7c FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 4945              		.loc 1 1315 0
 4946 2c80 FA0FA0E3 		mov	r0, #1000
 4947 2c84 FEFFFFEB 		bl	_tx_thread_sleep
 4948 2c88 F9FFFFEA 		b	.L454
 4949              	.LVL371:
 4950              	.L411:
 4951              	.LBE141:
 4952              	.LBE140:
 4953              	.LBB142:
 4954              	.LBB109:
2992:../uvc.c      ****             switch (bRequest)
 4955              		.loc 1 2992 0
 4956 2c8c 850053E3 		cmp	r3, #133
 4957 2c90 95FFFF0A 		beq	.L437
 4958 2c94 860053E3 		cmp	r3, #134
 4959 2c98 CFFEFF1A 		bne	.L434
 4960              	.L471:
2996:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4961              		.loc 1 2996 0
 4962 2c9c 0100A0E3 		mov	r0, #1
 4963 2ca0 C8FFFFEA 		b	.L465
 4964              	.LVL372:
 4965              	.L339:
 4966              	.LBE109:
 4967              	.LBE142:
 4968              	.LBB143:
 4969              	.LBB90:
2559:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 4970              		.loc 1 2559 0
 4971 2ca4 0600A0E3 		mov	r0, #6
 4972 2ca8 FEFFFFEB 		bl	ControlHandle
 4973              	.LVL373:
 4974 2cac 30309DE5 		ldr	r3, [sp, #48]
 4975 2cb0 4DFEFFEA 		b	.L326
 4976              	.L346:
2532:../uvc.c      ****     switch (wValue)
 4977              		.loc 1 2532 0
 4978 2cb4 0D0C52E3 		cmp	r2, #3328
 4979 2cb8 0700000A 		beq	.L341
 4980 2cbc 0E0C52E3 		cmp	r2, #3584
 4981 2cc0 0900000A 		beq	.L343
 4982 2cc4 030B52E3 		cmp	r2, #3072
 4983 2cc8 3EFEFF1A 		bne	.L347
 4984              	.LVL374:
2573:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 4985              		.loc 1 2573 0
 4986 2ccc 0B00A0E3 		mov	r0, #11
 4987 2cd0 FEFFFFEB 		bl	ControlHandle
 4988              	.LVL375:
 4989 2cd4 30309DE5 		ldr	r3, [sp, #48]
 4990 2cd8 43FEFFEA 		b	.L326
 4991              	.L341:
 4992              	.LVL376:
2569:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 4993              		.loc 1 2569 0
 4994 2cdc 0900A0E3 		mov	r0, #9
 4995 2ce0 FEFFFFEB 		bl	ControlHandle
 4996              	.LVL377:
 4997 2ce4 30309DE5 		ldr	r3, [sp, #48]
 4998 2ce8 3FFEFFEA 		b	.L326
 4999              	.L343:
 5000              	.LVL378:
2577:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 5001              		.loc 1 2577 0
 5002 2cec 0E00A0E3 		mov	r0, #14
 5003 2cf0 FEFFFFEB 		bl	ControlHandle
 5004              	.LVL379:
 5005 2cf4 30309DE5 		ldr	r3, [sp, #48]
 5006 2cf8 3BFEFFEA 		b	.L326
 5007              	.L345:
2532:../uvc.c      ****     switch (wValue)
 5008              		.loc 1 2532 0
 5009 2cfc 010B52E3 		cmp	r2, #1024
 5010 2d00 39FEFF0A 		beq	.L326
 5011 2d04 050C52E3 		cmp	r2, #1280
 5012 2d08 2EFEFF1A 		bne	.L347
 5013              	.LVL380:
2551:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 5014              		.loc 1 2551 0
 5015 2d0c 0400A0E3 		mov	r0, #4
 5016 2d10 FEFFFFEB 		bl	ControlHandle
 5017              	.LVL381:
 5018 2d14 30309DE5 		ldr	r3, [sp, #48]
 5019 2d18 33FEFFEA 		b	.L326
 5020              	.L336:
 5021              	.LVL382:
2544:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 5022              		.loc 1 2544 0
 5023 2d1c 0200A0E3 		mov	r0, #2
 5024 2d20 FEFFFFEB 		bl	ControlHandle
 5025              	.LVL383:
 5026 2d24 30309DE5 		ldr	r3, [sp, #48]
 5027 2d28 2FFEFFEA 		b	.L326
 5028              	.L338:
 5029              	.LVL384:
2555:../uvc.c      ****      		ControlHandle(HueCtlID5);
 5030              		.loc 1 2555 0
 5031 2d2c 0500A0E3 		mov	r0, #5
 5032 2d30 FEFFFFEB 		bl	ControlHandle
 5033              	.LVL385:
 5034 2d34 30309DE5 		ldr	r3, [sp, #48]
 5035 2d38 2BFEFFEA 		b	.L326
 5036              	.LVL386:
 5037              	.L448:
 5038              	.LBE90:
 5039              	.LBE143:
 5040              	.LBB144:
 5041              	.LBB102:
3173:../uvc.c      ****                 switch (bRequest)
 5042              		.loc 1 3173 0
 5043 2d3c 850052E3 		cmp	r2, #133
 5044 2d40 C100000A 		beq	.L446
 5045 2d44 860052E3 		cmp	r2, #134
 5046 2d48 2CFEFF1A 		bne	.L390
 5047 2d4c D2FFFFEA 		b	.L471
 5048              	.LVL387:
 5049              	.L384:
 5050              	.LBE102:
 5051              	.LBE144:
 5052              	.LBB145:
 5053              	.LBB116:
2832:../uvc.c      ****     switch (wValue)
 5054              		.loc 1 2832 0
 5055 2d50 060C53E3 		cmp	r3, #1536
 5056 2d54 B800000A 		beq	.L371
 5057 2d58 0900008A 		bhi	.L385
 5058 2d5c 050C53E3 		cmp	r3, #1280
 5059 2d60 1CFEFF1A 		bne	.L327
 5060              	.LVL388:
2852:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 5061              		.loc 1 2852 0
 5062 2d64 1400A0E3 		mov	r0, #20
 5063 2d68 FEFFFFEB 		bl	ControlHandle
 5064              	.LVL389:
 5065 2d6c 30309DE5 		ldr	r3, [sp, #48]
 5066 2d70 1DFEFFEA 		b	.L326
 5067              	.L354:
 5068              	.LVL390:
 5069              	.LBE116:
 5070              	.LBE145:
 5071              	.LBB146:
 5072              	.LBB92:
2637:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 5073              		.loc 1 2637 0
 5074 2d74 0600A0E3 		mov	r0, #6
 5075 2d78 FEFFFFEB 		bl	CTControlHandle
 5076              	.LVL391:
 5077 2d7c 30309DE5 		ldr	r3, [sp, #48]
 5078 2d80 19FEFFEA 		b	.L326
 5079              	.L385:
 5080              	.LBE92:
 5081              	.LBE146:
 5082              	.LBB147:
 5083              	.LBB121:
2832:../uvc.c      ****     switch (wValue)
 5084              		.loc 1 2832 0
 5085 2d84 070C53E3 		cmp	r3, #1792
 5086 2d88 A700000A 		beq	.L372
 5087 2d8c 020B53E3 		cmp	r3, #2048
 5088 2d90 10FEFF1A 		bne	.L327
 5089              	.LVL392:
2864:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 5090              		.loc 1 2864 0
 5091 2d94 1700A0E3 		mov	r0, #23
 5092 2d98 FEFFFFEB 		bl	ControlHandle
 5093              	.LVL393:
 5094 2d9c 30309DE5 		ldr	r3, [sp, #48]
 5095 2da0 11FEFFEA 		b	.L326
 5096              	.L361:
 5097              	.LBE121:
 5098              	.LBE147:
 5099              	.LBB148:
 5100              	.LBB99:
2607:../uvc.c      ****     switch (wValue)
 5101              		.loc 1 2607 0
 5102 2da4 0B0C52E3 		cmp	r2, #2816
 5103 2da8 0F00000A 		beq	.L357
 5104 2dac 030B52E3 		cmp	r2, #3072
 5105 2db0 0900000A 		beq	.L358
 5106 2db4 0A0C52E3 		cmp	r2, #2560
 5107 2db8 02FEFF1A 		bne	.L347
 5108              	.LVL394:
2648:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 5109              		.loc 1 2648 0
 5110 2dbc 0800A0E3 		mov	r0, #8
 5111 2dc0 FEFFFFEB 		bl	CTControlHandle
 5112              	.LVL395:
 5113 2dc4 30309DE5 		ldr	r3, [sp, #48]
 5114 2dc8 07FEFFEA 		b	.L326
 5115              	.L355:
 5116              	.LVL396:
2643:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 5117              		.loc 1 2643 0
 5118 2dcc 0700A0E3 		mov	r0, #7
 5119 2dd0 FEFFFFEB 		bl	CTControlHandle
 5120              	.LVL397:
 5121 2dd4 30309DE5 		ldr	r3, [sp, #48]
 5122 2dd8 03FEFFEA 		b	.L326
 5123              	.L358:
 5124              	.LVL398:
2656:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 5125              		.loc 1 2656 0
 5126 2ddc 0A00A0E3 		mov	r0, #10
 5127 2de0 FEFFFFEB 		bl	CTControlHandle
 5128              	.LVL399:
 5129 2de4 30309DE5 		ldr	r3, [sp, #48]
 5130 2de8 FFFDFFEA 		b	.L326
 5131              	.L357:
 5132              	.LVL400:
2652:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 5133              		.loc 1 2652 0
 5134 2dec 0900A0E3 		mov	r0, #9
 5135 2df0 FEFFFFEB 		bl	CTControlHandle
 5136              	.LVL401:
 5137 2df4 30309DE5 		ldr	r3, [sp, #48]
 5138 2df8 FBFDFFEA 		b	.L326
 5139              	.L380:
 5140              	.LVL402:
 5141              	.LBE99:
 5142              	.LBE148:
 5143              	.LBB149:
 5144              	.LBB115:
2899:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
 5145              		.loc 1 2899 0
 5146 2dfc 2000A0E3 		mov	r0, #32
 5147 2e00 FEFFFFEB 		bl	ControlHandle
 5148              	.LVL403:
 5149 2e04 30309DE5 		ldr	r3, [sp, #48]
 5150 2e08 F7FDFFEA 		b	.L326
 5151              	.LVL404:
 5152              	.L485:
 5153              	.LBE115:
 5154              	.LBE149:
 5155              	.LBB150:
 5156              	.LBB110:
2947:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
 5157              		.loc 1 2947 0
 5158 2e0c A4129FE5 		ldr	r1, .L486+80
 5159 2e10 1A00A0E3 		mov	r0, #26
 5160 2e14 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
2948:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 5161              		.loc 1 2948 0
 5162 2e18 0400A0E3 		mov	r0, #4
 5163 2e1c 98129FE5 		ldr	r1, .L486+84
 5164 2e20 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5165 2e24 FEFFFFEB 		bl	CyU3PDebugPrint
 5166 2e28 30309DE5 		ldr	r3, [sp, #48]
 5167 2e2c F8FDFFEA 		b	.L388
 5168              	.LVL405:
 5169              	.L377:
 5170              	.LBE110:
 5171              	.LBE150:
 5172              	.LBB151:
 5173              	.LBB122:
2883:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 5174              		.loc 1 2883 0
 5175 2e30 1C00A0E3 		mov	r0, #28
 5176 2e34 FEFFFFEB 		bl	ControlHandle
 5177              	.LVL406:
 5178 2e38 30309DE5 		ldr	r3, [sp, #48]
 5179 2e3c EAFDFFEA 		b	.L326
 5180              	.L376:
 5181              	.LVL407:
2879:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 5182              		.loc 1 2879 0
 5183 2e40 1A00A0E3 		mov	r0, #26
 5184 2e44 FEFFFFEB 		bl	ControlHandle
 5185              	.LVL408:
 5186 2e48 30309DE5 		ldr	r3, [sp, #48]
 5187 2e4c E6FDFFEA 		b	.L326
 5188              	.L378:
 5189              	.LVL409:
2891:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 5190              		.loc 1 2891 0
 5191 2e50 1E00A0E3 		mov	r0, #30
 5192 2e54 FEFFFFEB 		bl	ControlHandle
 5193              	.LVL410:
 5194 2e58 30309DE5 		ldr	r3, [sp, #48]
 5195 2e5c E2FDFFEA 		b	.L326
 5196              	.LVL411:
 5197              	.L450:
 5198              	.LBE122:
 5199              	.LBE151:
 5200              	.LBB152:
 5201              	.LBB101:
3214:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 5202              		.loc 1 3214 0
 5203 2e60 58129FE5 		ldr	r1, .L486+88
 5204 2e64 B623DDE1 		ldrh	r2, [sp, #54]
 5205 2e68 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 5206 2e6c 0400A0E3 		mov	r0, #4
 5207              	.LVL412:
 5208 2e70 FEFFFFEB 		bl	CyU3PDebugPrint
 5209 2e74 E1FDFFEA 		b	.L390
 5210              	.LVL413:
 5211              	.L481:
3017:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5212              		.loc 1 3017 0
 5213 2e78 2000A0E3 		mov	r0, #32
 5214 2e7c 10129FE5 		ldr	r1, .L486+44
 5215 2e80 36208DE2 		add	r2, sp, #54
 5216 2e84 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5217              	.LVL414:
3019:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5218              		.loc 1 3019 0
 5219 2e88 000050E3 		cmp	r0, #0
 5220 2e8c DFFDFF1A 		bne	.L466
3021:../uvc.c      ****                         switch (glCommitCtrl[3])
 5221              		.loc 1 3021 0
 5222 2e90 8300D4E5 		ldrb	r0, [r4, #131]	@ zero_extendqisi2
 5223              	.LVL415:
 5224 2e94 020050E3 		cmp	r0, #2
 5225 2e98 3800000A 		beq	.L416
 5226 2e9c 030050E3 		cmp	r0, #3
 5227 2ea0 1F00000A 		beq	.L417
 5228 2ea4 010050E3 		cmp	r0, #1
 5229 2ea8 1000001A 		bne	.L414
3024:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
 5230              		.loc 1 3024 0
 5231 2eac 582095E5 		ldr	r2, [r5, #88]
 5232 2eb0 3010A0E3 		mov	r1, #48
 5233 2eb4 000052E3 		cmp	r2, #0
 5234 2eb8 E420A003 		moveq	r2, #228
 5235 2ebc 6420A013 		movne	r2, #100
 5236 2ec0 5230A0E3 		mov	r3, #82
 5237 2ec4 FEFFFFEB 		bl	SensorSetIrisControl
3025:../uvc.c      ****                          		CyU3PThreadSleep(1000);
 5238              		.loc 1 3025 0
 5239 2ec8 FA0FA0E3 		mov	r0, #1000
 5240 2ecc FEFFFFEB 		bl	_tx_thread_sleep
3026:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 5241              		.loc 1 3026 0
 5242 2ed0 582094E5 		ldr	r2, [r4, #88]
 5243 2ed4 E8119FE5 		ldr	r1, .L486+92
 5244 2ed8 000052E3 		cmp	r2, #0
 5245 2edc 583094E5 		ldr	r3, [r4, #88]
 5246 2ee0 E420A003 		moveq	r2, #228
 5247 2ee4 6420A013 		movne	r2, #100
 5248 2ee8 0400A0E3 		mov	r0, #4
 5249 2eec FEFFFFEB 		bl	CyU3PDebugPrint
 5250              	.L414:
3041:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5251              		.loc 1 3041 0
 5252 2ef0 83E0D4E5 		ldrb	lr, [r4, #131]	@ zero_extendqisi2
3053:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5253              		.loc 1 3053 0
 5254 2ef4 0020A0E3 		mov	r2, #0
 5255 2ef8 68019FE5 		ldr	r0, .L486
 5256 2efc 0110A0E3 		mov	r1, #1
3041:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5257              		.loc 1 3041 0
 5258 2f00 7DE0C4E5 		strb	lr, [r4, #125]
3053:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5259              		.loc 1 3053 0
 5260 2f04 FEFFFFEB 		bl	_txe_event_flags_set
 5261              	.LVL416:
3054:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5262              		.loc 1 3054 0
 5263 2f08 002050E2 		subs	r2, r0, #0
 5264 2f0c BFFDFF0A 		beq	.L466
 5265              	.L442:
3161:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
 5266              		.loc 1 3161 0
 5267 2f10 0400A0E3 		mov	r0, #4
 5268              	.LVL417:
 5269 2f14 7C119FE5 		ldr	r1, .L486+48
 5270 2f18 FEFFFFEB 		bl	CyU3PDebugPrint
 5271              	.LVL418:
 5272 2f1c 30309DE5 		ldr	r3, [sp, #48]
 5273 2f20 BBFDFFEA 		b	.L388
 5274              	.L417:
3034:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
 5275              		.loc 1 3034 0
 5276 2f24 580095E5 		ldr	r0, [r5, #88]
 5277 2f28 8C34D6E5 		ldrb	r3, [r6, #1164]	@ zero_extendqisi2
 5278 2f2c 000050E3 		cmp	r0, #0
 5279 2f30 C400A003 		moveq	r0, #196
 5280 2f34 4400A013 		movne	r0, #68
 5281 2f38 032080E1 		orr	r2, r0, r3
 5282 2f3c 3010A0E3 		mov	r1, #48
 5283 2f40 5230A0E3 		mov	r3, #82
 5284 2f44 0100A0E3 		mov	r0, #1
 5285 2f48 FEFFFFEB 		bl	SensorSetIrisControl
3035:../uvc.c      ****                          		CyU3PThreadSleep(1000);
 5286              		.loc 1 3035 0
 5287 2f4c FA0FA0E3 		mov	r0, #1000
 5288 2f50 FEFFFFEB 		bl	_tx_thread_sleep
3036:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 5289              		.loc 1 3036 0
 5290 2f54 58C094E5 		ldr	ip, [r4, #88]
 5291 2f58 8C24D6E5 		ldrb	r2, [r6, #1164]	@ zero_extendqisi2
 5292 2f5c 00005CE3 		cmp	ip, #0
 5293 2f60 C4C0A003 		moveq	ip, #196
 5294 2f64 44C0A013 		movne	ip, #68
 5295 2f68 583094E5 		ldr	r3, [r4, #88]
 5296 2f6c 50119FE5 		ldr	r1, .L486+92
 5297 2f70 02208CE1 		orr	r2, ip, r2
 5298 2f74 0400A0E3 		mov	r0, #4
 5299 2f78 FEFFFFEB 		bl	CyU3PDebugPrint
 5300 2f7c DBFFFFEA 		b	.L414
 5301              	.L416:
3029:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
 5302              		.loc 1 3029 0
 5303 2f80 582095E5 		ldr	r2, [r5, #88]
 5304 2f84 3010A0E3 		mov	r1, #48
 5305 2f88 000052E3 		cmp	r2, #0
 5306 2f8c D420A003 		moveq	r2, #212
 5307 2f90 5420A013 		movne	r2, #84
 5308 2f94 5230A0E3 		mov	r3, #82
 5309 2f98 0100A0E3 		mov	r0, #1
 5310 2f9c FEFFFFEB 		bl	SensorSetIrisControl
3030:../uvc.c      ****                          		CyU3PThreadSleep(1000);
 5311              		.loc 1 3030 0
 5312 2fa0 FA0FA0E3 		mov	r0, #1000
 5313 2fa4 FEFFFFEB 		bl	_tx_thread_sleep
3031:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 5314              		.loc 1 3031 0
 5315 2fa8 582094E5 		ldr	r2, [r4, #88]
 5316 2fac 10119FE5 		ldr	r1, .L486+92
 5317 2fb0 000052E3 		cmp	r2, #0
 5318 2fb4 583094E5 		ldr	r3, [r4, #88]
 5319 2fb8 D420A003 		moveq	r2, #212
 5320 2fbc 5420A013 		movne	r2, #84
 5321 2fc0 0400A0E3 		mov	r0, #4
 5322 2fc4 FEFFFFEB 		bl	CyU3PDebugPrint
 5323 2fc8 C8FFFFEA 		b	.L414
 5324              	.LVL419:
 5325              	.L445:
3185:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5326              		.loc 1 3185 0
 5327 2fcc 4810D4E5 		ldrb	r1, [r4, #72]	@ zero_extendqisi2
 5328 2fd0 030051E3 		cmp	r1, #3
 5329 2fd4 93FEFF1A 		bne	.L449
3187:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 5330              		.loc 1 3187 0
 5331 2fd8 1A00A0E3 		mov	r0, #26
 5332 2fdc E4109FE5 		ldr	r1, .L486+96
 5333 2fe0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5334 2fe4 30309DE5 		ldr	r3, [sp, #48]
 5335 2fe8 89FDFFEA 		b	.L388
 5336              	.LVL420:
 5337              	.L368:
 5338              	.LBE101:
 5339              	.LBE152:
 5340              	.LBB153:
 5341              	.LBB114:
2844:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 5342              		.loc 1 2844 0
 5343 2fec 1200A0E3 		mov	r0, #18
 5344 2ff0 FEFFFFEB 		bl	ControlHandle
 5345              	.LVL421:
 5346 2ff4 30309DE5 		ldr	r3, [sp, #48]
 5347 2ff8 7BFDFFEA 		b	.L326
 5348              	.L367:
 5349              	.LVL422:
2840:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 5350              		.loc 1 2840 0
 5351 2ffc 1100A0E3 		mov	r0, #17
 5352 3000 FEFFFFEB 		bl	ControlHandle
 5353              	.LVL423:
 5354 3004 30309DE5 		ldr	r3, [sp, #48]
 5355 3008 77FDFFEA 		b	.L326
 5356              	.L369:
 5357              	.LVL424:
2848:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 5358              		.loc 1 2848 0
 5359 300c 1300A0E3 		mov	r0, #19
 5360 3010 FEFFFFEB 		bl	ControlHandle
 5361              	.LVL425:
 5362 3014 30309DE5 		ldr	r3, [sp, #48]
 5363 3018 73FDFFEA 		b	.L326
 5364              	.L374:
 5365              	.LVL426:
2868:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 5366              		.loc 1 2868 0
 5367 301c 1800A0E3 		mov	r0, #24
 5368 3020 FEFFFFEB 		bl	ControlHandle
 5369              	.LVL427:
 5370 3024 30309DE5 		ldr	r3, [sp, #48]
 5371 3028 6FFDFFEA 		b	.L326
 5372              	.L372:
 5373              	.LVL428:
2860:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 5374              		.loc 1 2860 0
 5375 302c 1600A0E3 		mov	r0, #22
 5376 3030 FEFFFFEB 		bl	ControlHandle
 5377              	.LVL429:
 5378 3034 30309DE5 		ldr	r3, [sp, #48]
 5379 3038 6BFDFFEA 		b	.L326
 5380              	.L371:
 5381              	.LVL430:
2856:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 5382              		.loc 1 2856 0
 5383 303c 1500A0E3 		mov	r0, #21
 5384 3040 FEFFFFEB 		bl	ControlHandle
 5385              	.LVL431:
 5386 3044 30309DE5 		ldr	r3, [sp, #48]
 5387 3048 67FDFFEA 		b	.L326
 5388              	.LVL432:
 5389              	.L446:
 5390              	.LBE114:
 5391              	.LBE153:
 5392              	.LBB154:
 5393              	.LBB111:
3182:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5394              		.loc 1 3182 0
 5395 304c 0200A0E3 		mov	r0, #2
 5396 3050 54109FE5 		ldr	r1, .L486+68
 5397 3054 A7FEFFEA 		b	.L467
 5398              	.LVL433:
 5399              	.L381:
 5400              	.LBE111:
 5401              	.LBE154:
 5402              	.LBB155:
 5403              	.LBB123:
2903:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
 5404              		.loc 1 2903 0
 5405 3058 2100A0E3 		mov	r0, #33
 5406 305c FEFFFFEB 		bl	ControlHandle
 5407              	.LVL434:
 5408 3060 30309DE5 		ldr	r3, [sp, #48]
 5409 3064 60FDFFEA 		b	.L326
 5410              	.L487:
 5411              		.align	2
 5412              	.L486:
 5413 3068 00000000 		.word	.LANCHOR0
 5414 306c 00000000 		.word	.LANCHOR1
 5415 3070 00000000 		.word	bRequest
 5416 3074 00000000 		.word	wValue
 5417 3078 00000000 		.word	wIndex
 5418 307c 00000000 		.word	glInterStaBuffer
 5419 3080 54050000 		.word	.LC29
 5420 3084 00000000 		.word	glChHandleInterStat
 5421 3088 00000000 		.word	bmReqType
 5422 308c 00000000 		.word	wLength
 5423 3090 D8040000 		.word	.LC28
 5424 3094 80000000 		.word	.LANCHOR0+128
 5425 3098 CC050000 		.word	.LC32
 5426 309c F4050000 		.word	.LC33
 5427 30a0 68060000 		.word	.LANCHOR1+1640
 5428 30a4 74060000 		.word	.LANCHOR1+1652
 5429 30a8 30060000 		.word	.LANCHOR1+1584
 5430 30ac 5C000000 		.word	.LANCHOR0+92
 5431 30b0 44060000 		.word	.LC35
 5432 30b4 D8010000 		.word	.LC12
 5433 30b8 14060000 		.word	.LANCHOR1+1556
 5434 30bc 80050000 		.word	.LC30
 5435 30c0 1C060000 		.word	.LC34
 5436 30c4 A8050000 		.word	.LC31
 5437 30c8 4C060000 		.word	.LANCHOR1+1612
 5438              	.LBE123:
 5439              	.LBE155:
 5440              		.cfi_endproc
 5441              	.LFE24:
 5443              		.align	2
 5444              		.global	CamDefSet
 5446              	CamDefSet:
 5447              	.LFB4:
1211:../uvc.c      **** {
 5448              		.loc 1 1211 0
 5449              		.cfi_startproc
 5450              		@ args = 0, pretend = 0, frame = 24
 5451              		@ frame_needed = 0, uses_anonymous_args = 0
 5452              	.LVL435:
 5453 30cc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5454              	.LCFI19:
 5455              		.cfi_def_cfa_offset 36
1217:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5456              		.loc 1 1217 0
 5457 30d0 AC429FE5 		ldr	r4, .L491
 5458              		.cfi_offset 14, -4
 5459              		.cfi_offset 11, -8
 5460              		.cfi_offset 10, -12
 5461              		.cfi_offset 9, -16
 5462              		.cfi_offset 8, -20
 5463              		.cfi_offset 7, -24
 5464              		.cfi_offset 6, -28
 5465              		.cfi_offset 5, -32
 5466              		.cfi_offset 4, -36
1222:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5467              		.loc 1 1222 0
 5468 30d4 AC229FE5 		ldr	r2, .L491+4
1219:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5469              		.loc 1 1219 0
 5470 30d8 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1211:../uvc.c      **** {
 5471              		.loc 1 1211 0
 5472 30dc 2CD04DE2 		sub	sp, sp, #44
 5473              	.LCFI20:
 5474              		.cfi_def_cfa_offset 80
1222:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5475              		.loc 1 1222 0
 5476 30e0 1C0092E5 		ldr	r0, [r2, #28]
 5477 30e4 0010E0E3 		mvn	r1, #0
1224:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5478              		.loc 1 1224 0
 5479 30e8 2963A0E1 		mov	r6, r9, lsr #6
1218:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5480              		.loc 1 1218 0
 5481 30ec A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1217:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5482              		.loc 1 1217 0
 5483 30f0 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 5484              	.LVL436:
1222:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5485              		.loc 1 1222 0
 5486 30f4 FEFFFFEB 		bl	_txe_mutex_get
1223:../uvc.c      ****     if(Data1&0x80){
 5487              		.loc 1 1223 0
 5488 30f8 800019E3 		tst	r9, #128
1224:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5489              		.loc 1 1224 0
 5490 30fc 01600612 		andne	r6, r6, #1
 5491 3100 0660E011 		mvnne	r6, r6
 5492 3104 3B600612 		andne	r6, r6, #59
 5493 3108 0660E011 		mvnne	r6, r6
 5494 310c FF600612 		andne	r6, r6, #255
 5495              	.LVL437:
1226:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 5496              		.loc 1 1226 0
 5497 3110 C6608603 		orreq	r6, r6, #198
 5498              	.LVL438:
1230:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5499              		.loc 1 1230 0
 5500 3114 0080A0E3 		mov	r8, #0
 5501 3118 0A20A0E1 		mov	r2, sl
 5502 311c 0730A0E1 		mov	r3, r7
 5503 3120 0110A0E3 		mov	r1, #1
1228:../uvc.c      ****     Data0 = (Data0 << 2);
 5504              		.loc 1 1228 0
 5505 3124 0951A0E1 		mov	r5, r9, asl #2
1230:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5506              		.loc 1 1230 0
 5507 3128 58029FE5 		ldr	r0, .L491+4
1233:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5508              		.loc 1 1233 0
 5509 312c 0190A0E3 		mov	r9, #1
 5510              	.LVL439:
1228:../uvc.c      ****     Data0 = (Data0 << 2);
 5511              		.loc 1 1228 0
 5512 3130 FF5005E2 		and	r5, r5, #255
 5513              	.LVL440:
1230:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5514              		.loc 1 1230 0
 5515 3134 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5516 3138 FEFFFFEB 		bl	cmdSet
 5517              	.LVL441:
1233:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5518              		.loc 1 1233 0
 5519 313c 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 5520 3140 0910A0E1 		mov	r1, r9
 5521 3144 0730A0E1 		mov	r3, r7
 5522 3148 38029FE5 		ldr	r0, .L491+4
 5523 314c 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 5524 3150 FEFFFFEB 		bl	cmdSet
 5525              	.LVL442:
1236:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5526              		.loc 1 1236 0
 5527 3154 0620A0E1 		mov	r2, r6
 5528 3158 0530A0E1 		mov	r3, r5
 5529 315c 28129FE5 		ldr	r1, .L491+8
 5530 3160 0400A0E3 		mov	r0, #4
1235:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5531              		.loc 1 1235 0
 5532 3164 A661C4E5 		strb	r6, [r4, #422]
1234:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5533              		.loc 1 1234 0
 5534 3168 A551C4E5 		strb	r5, [r4, #421]
1236:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5535              		.loc 1 1236 0
 5536 316c FEFFFFEB 		bl	CyU3PDebugPrint
 5537              	.LVL443:
1241:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5538              		.loc 1 1241 0
 5539 3170 BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 5540              	.LVL444:
1242:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5541              		.loc 1 1242 0
 5542 3174 B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 5543 3178 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 5544 317c 0210A0E3 		mov	r1, #2
 5545 3180 00029FE5 		ldr	r0, .L491+4
 5546 3184 00B08DE5 		str	fp, [sp, #0]
 5547 3188 04808DE5 		str	r8, [sp, #4]
 5548 318c FEFFFFEB 		bl	cmdSet
 5549              	.LVL445:
1244:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5550              		.loc 1 1244 0
 5551 3190 0B20A0E1 		mov	r2, fp
 5552 3194 0530A0E1 		mov	r3, r5
 5553 3198 EC119FE5 		ldr	r1, .L491+8
 5554 319c 0400A0E3 		mov	r0, #4
1243:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5555              		.loc 1 1243 0
 5556 31a0 BD51C4E5 		strb	r5, [r4, #445]
1244:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5557              		.loc 1 1244 0
 5558 31a4 FEFFFFEB 		bl	CyU3PDebugPrint
 5559              	.LVL446:
1249:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5560              		.loc 1 1249 0
 5561 31a8 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1248:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5562              		.loc 1 1248 0
 5563 31ac 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 5564              	.LVL447:
1250:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5565              		.loc 1 1250 0
 5566 31b0 80B047E2 		sub	fp, r7, #128
 5567 31b4 FF100BE2 		and	r1, fp, #255
 5568 31b8 14108DE5 		str	r1, [sp, #20]
 5569 31bc 14C09DE5 		ldr	ip, [sp, #20]
1251:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5570              		.loc 1 1251 0
 5571 31c0 760047E2 		sub	r0, r7, #118
1252:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5572              		.loc 1 1252 0
 5573 31c4 7EE087E2 		add	lr, r7, #126
1250:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5574              		.loc 1 1250 0
 5575 31c8 0630A0E1 		mov	r3, r6
1251:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5576              		.loc 1 1251 0
 5577 31cc 18008DE5 		str	r0, [sp, #24]
1250:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5578              		.loc 1 1250 0
 5579 31d0 0510A0E3 		mov	r1, #5
 5580 31d4 DF20A0E3 		mov	r2, #223
 5581 31d8 A8019FE5 		ldr	r0, .L491+4
1252:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5582              		.loc 1 1252 0
 5583 31dc 1CE08DE5 		str	lr, [sp, #28]
1250:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5584              		.loc 1 1250 0
 5585 31e0 00C08DE5 		str	ip, [sp, #0]
 5586 31e4 04808DE5 		str	r8, [sp, #4]
 5587 31e8 FEFFFFEB 		bl	cmdSet
 5588              	.LVL448:
1251:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5589              		.loc 1 1251 0
 5590 31ec 18A09DE5 		ldr	sl, [sp, #24]
1253:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5591              		.loc 1 1253 0
 5592 31f0 72E087E2 		add	lr, r7, #114
1251:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5593              		.loc 1 1251 0
 5594 31f4 FFC00AE2 		and	ip, sl, #255
 5595 31f8 0630A0E1 		mov	r3, r6
 5596 31fc 0510A0E3 		mov	r1, #5
 5597 3200 DC20A0E3 		mov	r2, #220
 5598 3204 7C019FE5 		ldr	r0, .L491+4
1253:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5599              		.loc 1 1253 0
 5600 3208 20E08DE5 		str	lr, [sp, #32]
1251:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5601              		.loc 1 1251 0
 5602 320c 00C08DE5 		str	ip, [sp, #0]
 5603 3210 04908DE5 		str	r9, [sp, #4]
 5604 3214 FEFFFFEB 		bl	cmdSet
1252:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5605              		.loc 1 1252 0
 5606 3218 1C009DE5 		ldr	r0, [sp, #28]
 5607 321c 02E0A0E3 		mov	lr, #2
 5608 3220 FFC000E2 		and	ip, r0, #255
 5609 3224 0630A0E1 		mov	r3, r6
1254:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5610              		.loc 1 1254 0
 5611 3228 6FA047E2 		sub	sl, r7, #111
1252:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5612              		.loc 1 1252 0
 5613 322c 0510A0E3 		mov	r1, #5
 5614 3230 DE20A0E3 		mov	r2, #222
 5615 3234 4C019FE5 		ldr	r0, .L491+4
 5616 3238 04E08DE5 		str	lr, [sp, #4]
1254:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5617              		.loc 1 1254 0
 5618 323c 24A08DE5 		str	sl, [sp, #36]
1252:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5619              		.loc 1 1252 0
 5620 3240 00C08DE5 		str	ip, [sp, #0]
 5621 3244 FEFFFFEB 		bl	cmdSet
1253:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5622              		.loc 1 1253 0
 5623 3248 20A09DE5 		ldr	sl, [sp, #32]
 5624 324c 0630A0E1 		mov	r3, r6
 5625 3250 FFC00AE2 		and	ip, sl, #255
 5626 3254 00C08DE5 		str	ip, [sp, #0]
 5627 3258 0510A0E3 		mov	r1, #5
 5628 325c 03C0A0E3 		mov	ip, #3
 5629 3260 E020A0E3 		mov	r2, #224
 5630 3264 1C019FE5 		ldr	r0, .L491+4
 5631 3268 04C08DE5 		str	ip, [sp, #4]
 5632 326c FEFFFFEB 		bl	cmdSet
1254:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5633              		.loc 1 1254 0
 5634 3270 24009DE5 		ldr	r0, [sp, #36]
 5635 3274 04A0A0E3 		mov	sl, #4
 5636 3278 FFC000E2 		and	ip, r0, #255
 5637 327c 0630A0E1 		mov	r3, r6
 5638 3280 0510A0E3 		mov	r1, #5
 5639 3284 DD20A0E3 		mov	r2, #221
 5640 3288 F8009FE5 		ldr	r0, .L491+4
 5641 328c 00C08DE5 		str	ip, [sp, #0]
1255:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5642              		.loc 1 1255 0
 5643 3290 7F7087E2 		add	r7, r7, #127
 5644              	.LVL449:
1254:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5645              		.loc 1 1254 0
 5646 3294 04A08DE5 		str	sl, [sp, #4]
 5647 3298 FEFFFFEB 		bl	cmdSet
1255:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5648              		.loc 1 1255 0
 5649 329c 05E0A0E3 		mov	lr, #5
 5650 32a0 0E10A0E1 		mov	r1, lr
 5651 32a4 0630A0E1 		mov	r3, r6
 5652 32a8 E120A0E3 		mov	r2, #225
 5653 32ac FF6007E2 		and	r6, r7, #255
 5654              	.LVL450:
 5655 32b0 D0009FE5 		ldr	r0, .L491+4
 5656 32b4 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 5657 32b8 FEFFFFEB 		bl	cmdSet
 5658              	.LVL451:
1256:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5659              		.loc 1 1256 0
 5660 32bc 14C09DE5 		ldr	ip, [sp, #20]
1257:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5661              		.loc 1 1257 0
 5662 32c0 24E09DE5 		ldr	lr, [sp, #36]
 5663 32c4 1C609DE5 		ldr	r6, [sp, #28]
1256:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5664              		.loc 1 1256 0
 5665 32c8 05C2C4E5 		strb	ip, [r4, #517]
1257:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5666              		.loc 1 1257 0
 5667 32cc 20C09DE5 		ldr	ip, [sp, #32]
 5668 32d0 0B20A0E1 		mov	r2, fp
 5669 32d4 18309DE5 		ldr	r3, [sp, #24]
 5670 32d8 B0109FE5 		ldr	r1, .L491+12
 5671 32dc 0A00A0E1 		mov	r0, sl
 5672 32e0 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 5673 32e4 0C708DE5 		str	r7, [sp, #12]
 5674 32e8 FEFFFFEB 		bl	CyU3PDebugPrint
 5675              	.LVL452:
1261:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5676              		.loc 1 1261 0
 5677 32ec 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 5678              	.LVL453:
1262:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5679              		.loc 1 1262 0
 5680 32f0 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 5681              	.LVL454:
1263:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5682              		.loc 1 1263 0
 5683 32f4 0730A0E1 		mov	r3, r7
 5684 32f8 0610A0E3 		mov	r1, #6
 5685 32fc 8520A0E3 		mov	r2, #133
 5686 3300 80009FE5 		ldr	r0, .L491+4
 5687 3304 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5688 3308 FEFFFFEB 		bl	cmdSet
1264:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5689              		.loc 1 1264 0
 5690 330c 0730A0E1 		mov	r3, r7
 5691 3310 0610A0E3 		mov	r1, #6
 5692 3314 8620A0E3 		mov	r2, #134
 5693 3318 68009FE5 		ldr	r0, .L491+4
 5694 331c 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 5695 3320 FEFFFFEB 		bl	cmdSet
1266:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5696              		.loc 1 1266 0
 5697 3324 0620A0E1 		mov	r2, r6
 5698 3328 0530A0E1 		mov	r3, r5
 5699 332c 58109FE5 		ldr	r1, .L491+8
 5700 3330 0A00A0E1 		mov	r0, sl
1265:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5701              		.loc 1 1265 0
 5702 3334 1D62C4E5 		strb	r6, [r4, #541]
1266:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5703              		.loc 1 1266 0
 5704 3338 FEFFFFEB 		bl	CyU3PDebugPrint
 5705              	.LVL455:
1271:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5706              		.loc 1 1271 0
 5707 333c 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 5708              	.LVL456:
1272:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5709              		.loc 1 1272 0
 5710 3340 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 5711 3344 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 5712 3348 0710A0E3 		mov	r1, #7
 5713 334c 34009FE5 		ldr	r0, .L491+4
 5714 3350 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5715 3354 FEFFFFEB 		bl	cmdSet
 5716              	.LVL457:
1274:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5717              		.loc 1 1274 0
 5718 3358 0530A0E1 		mov	r3, r5
 5719 335c 0A00A0E1 		mov	r0, sl
 5720 3360 24109FE5 		ldr	r1, .L491+8
 5721 3364 0620A0E1 		mov	r2, r6
1273:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5722              		.loc 1 1273 0
 5723 3368 3552C4E5 		strb	r5, [r4, #565]
1274:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5724              		.loc 1 1274 0
 5725 336c FEFFFFEB 		bl	CyU3PDebugPrint
1276:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5726              		.loc 1 1276 0
 5727 3370 10309FE5 		ldr	r3, .L491+4
 5728 3374 1C0093E5 		ldr	r0, [r3, #28]
1279:../uvc.c      **** }
 5729              		.loc 1 1279 0
 5730 3378 2CD08DE2 		add	sp, sp, #44
 5731 337c F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1276:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5732              		.loc 1 1276 0
 5733 3380 FEFFFFEA 		b	_txe_mutex_put
 5734              	.L492:
 5735              		.align	2
 5736              	.L491:
 5737 3384 00000000 		.word	.LANCHOR1
 5738 3388 00000000 		.word	cmdQu
 5739 338c 78060000 		.word	.LC36
 5740 3390 98060000 		.word	.LC37
 5741              		.cfi_endproc
 5742              	.LFE4:
 5744              		.align	2
 5745              		.global	CyFxUVCAddHeader
 5747              	CyFxUVCAddHeader:
 5748              	.LFB5:
1287:../uvc.c      **** {
 5749              		.loc 1 1287 0
 5750              		.cfi_startproc
 5751              		@ args = 0, pretend = 0, frame = 0
 5752              		@ frame_needed = 0, uses_anonymous_args = 0
 5753              	.LVL458:
 5754 3394 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5755              	.LCFI21:
 5756              		.cfi_def_cfa_offset 16
1289:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5757              		.loc 1 1289 0
 5758 3398 0C20A0E3 		mov	r2, #12
1287:../uvc.c      **** {
 5759              		.loc 1 1287 0
 5760 339c 0150A0E1 		mov	r5, r1
 5761              		.cfi_offset 14, -4
 5762              		.cfi_offset 5, -8
 5763              		.cfi_offset 4, -12
 5764              		.cfi_offset 3, -16
1289:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5765              		.loc 1 1289 0
 5766 33a0 18109FE5 		ldr	r1, .L495
 5767              	.LVL459:
1287:../uvc.c      **** {
 5768              		.loc 1 1287 0
 5769 33a4 0040A0E1 		mov	r4, r0
1289:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5770              		.loc 1 1289 0
 5771 33a8 FEFFFFEB 		bl	CyU3PMemCopy
 5772              	.LVL460:
1292:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 5773              		.loc 1 1292 0
 5774 33ac 020015E3 		tst	r5, #2
1294:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 5775              		.loc 1 1294 0
 5776 33b0 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5777 33b4 02308313 		orrne	r3, r3, #2
 5778 33b8 0130C415 		strneb	r3, [r4, #1]
 5779 33bc 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 5780              	.L496:
 5781              		.align	2
 5782              	.L495:
 5783 33c0 80040000 		.word	.LANCHOR1+1152
 5784              		.cfi_endproc
 5785              	.LFE5:
 5787              		.align	2
 5788              		.global	CyFxAppErrorHandler
 5790              	CyFxAppErrorHandler:
 5791              	.LFB6:
1304:../uvc.c      **** {
 5792              		.loc 1 1304 0
 5793              		.cfi_startproc
 5794              		@ args = 0, pretend = 0, frame = 0
 5795              		@ frame_needed = 0, uses_anonymous_args = 0
 5796              	.LVL461:
 5797 33c4 08402DE9 		stmfd	sp!, {r3, lr}
 5798              	.LCFI22:
 5799              		.cfi_def_cfa_offset 8
 5800              	.LVL462:
 5801              	.L498:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5802              		.loc 1 1314 0 discriminator 1
 5803 33c8 10109FE5 		ldr	r1, .L499
 5804 33cc 0400A0E3 		mov	r0, #4
 5805              		.cfi_offset 14, -4
 5806              		.cfi_offset 3, -8
 5807 33d0 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 5808              		.loc 1 1315 0 discriminator 1
 5809 33d4 FA0FA0E3 		mov	r0, #1000
 5810 33d8 FEFFFFEB 		bl	_tx_thread_sleep
 5811 33dc F9FFFFEA 		b	.L498
 5812              	.L500:
 5813              		.align	2
 5814              	.L499:
 5815 33e0 D8010000 		.word	.LC12
 5816              		.cfi_endproc
 5817              	.LFE6:
 5819              		.align	2
 5820              		.global	UVCAppThread_Entry
 5822              	UVCAppThread_Entry:
 5823              	.LFB18:
2270:../uvc.c      **** {
 5824              		.loc 1 2270 0
 5825              		.cfi_startproc
 5826              		@ args = 0, pretend = 0, frame = 176
 5827              		@ frame_needed = 0, uses_anonymous_args = 0
 5828              	.LVL463:
 5829 33e4 F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 5830              	.LCFI23:
 5831              		.cfi_def_cfa_offset 28
 5832 33e8 BCD04DE2 		sub	sp, sp, #188
 5833              	.LCFI24:
 5834              		.cfi_def_cfa_offset 216
 5835              	.LBB208:
 5836              	.LBB209:
1727:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 5837              		.loc 1 1727 0
 5838              		.cfi_offset 14, -4
 5839              		.cfi_offset 10, -8
 5840              		.cfi_offset 8, -12
 5841              		.cfi_offset 7, -16
 5842              		.cfi_offset 6, -20
 5843              		.cfi_offset 5, -24
 5844              		.cfi_offset 4, -28
 5845 33ec FEFFFFEB 		bl	CyU3PUartInit
 5846              	.LVL464:
1728:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5847              		.loc 1 1728 0
 5848 33f0 004050E2 		subs	r4, r0, #0
 5849 33f4 0400000A 		beq	.L502
1730:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 5850              		.loc 1 1730 0
 5851 33f8 0400A0E3 		mov	r0, #4
 5852              	.LVL465:
 5853 33fc 281A9FE5 		ldr	r1, .L592
 5854 3400 FEFFFFEB 		bl	CyU3PDebugPrint
1731:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5855              		.loc 1 1731 0
 5856 3404 0400A0E1 		mov	r0, r4
 5857 3408 FEFFFFEB 		bl	CyFxAppErrorHandler
 5858              	.L502:
1735:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5859              		.loc 1 1735 0
 5860 340c 1CCA9FE5 		ldr	ip, .L592+4
1737:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5861              		.loc 1 1737 0
 5862 3410 0030A0E3 		mov	r3, #0
1736:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5863              		.loc 1 1736 0
 5864 3414 0120A0E3 		mov	r2, #1
1744:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5865              		.loc 1 1744 0
 5866 3418 50008DE2 		add	r0, sp, #80
 5867 341c 0310A0E1 		mov	r1, r3
1735:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5868              		.loc 1 1735 0
 5869 3420 60C08DE5 		str	ip, [sp, #96]
1736:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5870              		.loc 1 1736 0
 5871 3424 6420CDE5 		strb	r2, [sp, #100]
1737:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5872              		.loc 1 1737 0
 5873 3428 6530CDE5 		strb	r3, [sp, #101]
1738:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 5874              		.loc 1 1738 0
 5875 342c 50208DE5 		str	r2, [sp, #80]
1739:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 5876              		.loc 1 1739 0
 5877 3430 54308DE5 		str	r3, [sp, #84]
1740:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 5878              		.loc 1 1740 0
 5879 3434 58308DE5 		str	r3, [sp, #88]
1741:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 5880              		.loc 1 1741 0
 5881 3438 5C208DE5 		str	r2, [sp, #92]
1744:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5882              		.loc 1 1744 0
 5883 343c FEFFFFEB 		bl	CyU3PUartSetConfig
 5884              	.LVL466:
1745:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5885              		.loc 1 1745 0
 5886 3440 000050E3 		cmp	r0, #0
 5887 3444 0000000A 		beq	.L503
1747:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5888              		.loc 1 1747 0
 5889 3448 FEFFFFEB 		bl	CyFxAppErrorHandler
 5890              	.LVL467:
 5891              	.L503:
1751:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 5892              		.loc 1 1751 0
 5893 344c 0000E0E3 		mvn	r0, #0
 5894 3450 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 5895              	.LVL468:
1752:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5896              		.loc 1 1752 0
 5897 3454 000050E3 		cmp	r0, #0
 5898 3458 0000000A 		beq	.L504
1754:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5899              		.loc 1 1754 0
 5900 345c FEFFFFEB 		bl	CyFxAppErrorHandler
 5901              	.LVL469:
 5902              	.L504:
1758:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 5903              		.loc 1 1758 0
 5904 3460 0300A0E3 		mov	r0, #3
 5905 3464 0410A0E3 		mov	r1, #4
 5906 3468 FEFFFFEB 		bl	CyU3PDebugInit
 5907              	.LVL470:
1759:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5908              		.loc 1 1759 0
 5909 346c 000050E3 		cmp	r0, #0
 5910 3470 0000000A 		beq	.L505
1761:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5911              		.loc 1 1761 0
 5912 3474 FEFFFFEB 		bl	CyFxAppErrorHandler
 5913              	.LVL471:
 5914              	.L505:
1765:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 5915              		.loc 1 1765 0
 5916 3478 0000A0E3 		mov	r0, #0
 5917 347c FEFFFFEB 		bl	CyU3PDebugPreamble
 5918              	.LVL472:
 5919              	.LBE209:
 5920              	.LBE208:
2286:../uvc.c      **** 		CyU3PThreadSleep(500);
 5921              		.loc 1 2286 0
 5922 3480 7D0FA0E3 		mov	r0, #500
 5923 3484 FEFFFFEB 		bl	_tx_thread_sleep
 5924              	.LVL473:
 5925 3488 7D0FA0E3 		mov	r0, #500
 5926 348c FEFFFFEB 		bl	_tx_thread_sleep
 5927 3490 7D0FA0E3 		mov	r0, #500
 5928 3494 FEFFFFEB 		bl	_tx_thread_sleep
 5929 3498 7D0FA0E3 		mov	r0, #500
 5930 349c FEFFFFEB 		bl	_tx_thread_sleep
 5931 34a0 7D0FA0E3 		mov	r0, #500
 5932 34a4 FEFFFFEB 		bl	_tx_thread_sleep
 5933 34a8 7D0FA0E3 		mov	r0, #500
 5934 34ac FEFFFFEB 		bl	_tx_thread_sleep
 5935              	.LBB210:
 5936              	.LBB211:
1775:../uvc.c      ****     status = CyU3PI2cInit ();
 5937              		.loc 1 1775 0
 5938 34b0 FEFFFFEB 		bl	CyU3PI2cInit
 5939              	.LVL474:
1776:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 5940              		.loc 1 1776 0
 5941 34b4 004050E2 		subs	r4, r0, #0
 5942 34b8 0400000A 		beq	.L506
1778:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 5943              		.loc 1 1778 0
 5944 34bc 0400A0E3 		mov	r0, #4
 5945              	.LVL475:
 5946 34c0 6C199FE5 		ldr	r1, .L592+8
 5947 34c4 FEFFFFEB 		bl	CyU3PDebugPrint
1779:../uvc.c      ****         CyFxAppErrorHandler (status);
 5948              		.loc 1 1779 0
 5949 34c8 0400A0E1 		mov	r0, r4
 5950 34cc FEFFFFEB 		bl	CyFxAppErrorHandler
 5951              	.L506:
1783:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5952              		.loc 1 1783 0
 5953 34d0 60699FE5 		ldr	r6, .L592+12
1784:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5954              		.loc 1 1784 0
 5955 34d4 0050A0E3 		mov	r5, #0
1785:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5956              		.loc 1 1785 0
 5957 34d8 0040E0E3 		mvn	r4, #0
 5958              	.LVL476:
1788:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5959              		.loc 1 1788 0
 5960 34dc 8C008DE2 		add	r0, sp, #140
 5961 34e0 0510A0E1 		mov	r1, r5
1785:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5962              		.loc 1 1785 0
 5963 34e4 94408DE5 		str	r4, [sp, #148]
1786:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 5964              		.loc 1 1786 0
 5965 34e8 B849CDE1 		strh	r4, [sp, #152]	@ movhi
1783:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5966              		.loc 1 1783 0
 5967 34ec 8C608DE5 		str	r6, [sp, #140]
1784:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5968              		.loc 1 1784 0
 5969 34f0 90508DE5 		str	r5, [sp, #144]
1788:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5970              		.loc 1 1788 0
 5971 34f4 FEFFFFEB 		bl	CyU3PI2cSetConfig
 5972              	.LVL477:
1789:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 5973              		.loc 1 1789 0
 5974 34f8 004050E2 		subs	r4, r0, #0
 5975 34fc 0400000A 		beq	.L507
1791:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 5976              		.loc 1 1791 0
 5977 3500 0400A0E3 		mov	r0, #4
 5978              	.LVL478:
 5979 3504 30199FE5 		ldr	r1, .L592+16
 5980 3508 FEFFFFEB 		bl	CyU3PDebugPrint
1792:../uvc.c      ****         CyFxAppErrorHandler (status);
 5981              		.loc 1 1792 0
 5982 350c 0400A0E1 		mov	r0, r4
 5983 3510 FEFFFFEB 		bl	CyFxAppErrorHandler
 5984              	.L507:
 5985              	.LBE211:
 5986              	.LBE210:
 5987              	.LBB212:
 5988              	.LBB215:
1862:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 5989              		.loc 1 1862 0
 5990 3514 24699FE5 		ldr	r6, .L592+20
 5991 3518 2820A0E3 		mov	r2, #40
 5992 351c 0010A0E3 		mov	r1, #0
 5993 3520 0600A0E1 		mov	r0, r6
 5994 3524 FEFFFFEB 		bl	_txe_event_flags_create
 5995              	.LVL479:
1863:../uvc.c      ****     if (apiRetStatus != 0)
 5996              		.loc 1 1863 0
 5997 3528 002050E2 		subs	r2, r0, #0
 5998 352c F300001A 		bne	.L569
1877:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5999              		.loc 1 1877 0
 6000 3530 0250A0E3 		mov	r5, #2
1884:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6001              		.loc 1 1884 0
 6002 3534 0210A0E1 		mov	r1, r2
1873:../uvc.c      ****     isUsbConnected = CyFalse;
 6003              		.loc 1 1873 0
 6004 3538 402086E5 		str	r2, [r6, #64]
1874:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 6005              		.loc 1 1874 0
 6006 353c 442086E5 		str	r2, [r6, #68]
1880:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6007              		.loc 1 1880 0
 6008 3540 0370A0E3 		mov	r7, #3
1884:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6009              		.loc 1 1884 0
 6010 3544 9C008DE2 		add	r0, sp, #156
 6011              	.LVL480:
1879:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 6012              		.loc 1 1879 0
 6013 3548 A420CDE5 		strb	r2, [sp, #164]
1881:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6014              		.loc 1 1881 0
 6015 354c A0208DE5 		str	r2, [sp, #160]
1877:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 6016              		.loc 1 1877 0
 6017 3550 9C50CDE5 		strb	r5, [sp, #156]
1878:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6018              		.loc 1 1878 0
 6019 3554 9D50CDE5 		strb	r5, [sp, #157]
1880:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6020              		.loc 1 1880 0
 6021 3558 A570CDE5 		strb	r7, [sp, #165]
1884:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6022              		.loc 1 1884 0
 6023 355c FEFFFFEB 		bl	CyU3PGpioInit
 6024              	.LVL481:
1885:../uvc.c      ****     if (apiRetStatus != 0)
 6025              		.loc 1 1885 0
 6026 3560 002050E2 		subs	r2, r0, #0
 6027 3564 F700001A 		bne	.L570
1893:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 6028              		.loc 1 1893 0
 6029 3568 1600A0E3 		mov	r0, #22
 6030              	.LVL482:
 6031 356c 0110A0E3 		mov	r1, #1
 6032 3570 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6033              	.LVL483:
1894:../uvc.c      ****     if (apiRetStatus != 0)
 6034              		.loc 1 1894 0
 6035 3574 002050E2 		subs	r2, r0, #0
 6036 3578 E900001A 		bne	.L571
1899:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 6037              		.loc 1 1899 0
 6038 357c 1400A0E3 		mov	r0, #20
 6039              	.LVL484:
 6040 3580 0110A0E3 		mov	r1, #1
 6041 3584 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6042              	.LVL485:
1900:../uvc.c      ****     if (apiRetStatus != 0)
 6043              		.loc 1 1900 0
 6044 3588 002050E2 		subs	r2, r0, #0
 6045 358c F600001A 		bne	.L572
1905:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 6046              		.loc 1 1905 0
 6047 3590 1800A0E3 		mov	r0, #24
 6048              	.LVL486:
 6049 3594 0110A0E3 		mov	r1, #1
 6050 3598 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6051              	.LVL487:
1906:../uvc.c      ****     if (apiRetStatus != 0)
 6052              		.loc 1 1906 0
 6053 359c 002050E2 		subs	r2, r0, #0
 6054 35a0 D201001A 		bne	.L573
1913:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6055              		.loc 1 1913 0
 6056 35a4 0140A0E3 		mov	r4, #1
 6057              	.LVL488:
1918:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6058              		.loc 1 1918 0
 6059 35a8 1600A0E3 		mov	r0, #22
 6060              	.LVL489:
 6061 35ac 68108DE2 		add	r1, sp, #104
1916:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6062              		.loc 1 1916 0
 6063 35b0 74208DE5 		str	r2, [sp, #116]
1917:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6064              		.loc 1 1917 0
 6065 35b4 7820CDE5 		strb	r2, [sp, #120]
1913:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6066              		.loc 1 1913 0
 6067 35b8 68408DE5 		str	r4, [sp, #104]
1914:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6068              		.loc 1 1914 0
 6069 35bc 6C408DE5 		str	r4, [sp, #108]
1915:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6070              		.loc 1 1915 0
 6071 35c0 70408DE5 		str	r4, [sp, #112]
1918:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6072              		.loc 1 1918 0
 6073 35c4 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6074              	.LVL490:
1919:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6075              		.loc 1 1919 0
 6076 35c8 002050E2 		subs	r2, r0, #0
 6077 35cc BE01001A 		bne	.L574
1932:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6078              		.loc 1 1932 0
 6079 35d0 1400A0E3 		mov	r0, #20
 6080              	.LVL491:
 6081 35d4 68108DE2 		add	r1, sp, #104
1930:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6082              		.loc 1 1930 0
 6083 35d8 74208DE5 		str	r2, [sp, #116]
1931:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6084              		.loc 1 1931 0
 6085 35dc 7820CDE5 		strb	r2, [sp, #120]
1927:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6086              		.loc 1 1927 0
 6087 35e0 68408DE5 		str	r4, [sp, #104]
1928:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6088              		.loc 1 1928 0
 6089 35e4 6C408DE5 		str	r4, [sp, #108]
1929:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6090              		.loc 1 1929 0
 6091 35e8 70408DE5 		str	r4, [sp, #112]
1932:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6092              		.loc 1 1932 0
 6093 35ec FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6094              	.LVL492:
1933:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6095              		.loc 1 1933 0
 6096 35f0 002050E2 		subs	r2, r0, #0
 6097 35f4 C601001A 		bne	.L575
1946:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6098              		.loc 1 1946 0
 6099 35f8 1800A0E3 		mov	r0, #24
 6100              	.LVL493:
 6101 35fc 68108DE2 		add	r1, sp, #104
1941:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 6102              		.loc 1 1941 0
 6103 3600 68208DE5 		str	r2, [sp, #104]
1942:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6104              		.loc 1 1942 0
 6105 3604 6C208DE5 		str	r2, [sp, #108]
1943:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 6106              		.loc 1 1943 0
 6107 3608 70208DE5 		str	r2, [sp, #112]
1945:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6108              		.loc 1 1945 0
 6109 360c 7820CDE5 		strb	r2, [sp, #120]
1944:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 6110              		.loc 1 1944 0
 6111 3610 74408DE5 		str	r4, [sp, #116]
1946:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6112              		.loc 1 1946 0
 6113 3614 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6114              	.LVL494:
1947:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6115              		.loc 1 1947 0
 6116 3618 002050E2 		subs	r2, r0, #0
 6117 361c A101001A 		bne	.L576
1959:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 6118              		.loc 1 1959 0
 6119 3620 0400A0E1 		mov	r0, r4
 6120              	.LVL495:
 6121 3624 7C108DE2 		add	r1, sp, #124
1956:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6122              		.loc 1 1956 0
 6123 3628 84208DE5 		str	r2, [sp, #132]
1957:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 6124              		.loc 1 1957 0
 6125 362c 80208DE5 		str	r2, [sp, #128]
1954:../uvc.c      ****     pibclock.clkDiv      = 2;
 6126              		.loc 1 1954 0
 6127 3630 BC57CDE1 		strh	r5, [sp, #124]	@ movhi
1955:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6128              		.loc 1 1955 0
 6129 3634 8870CDE5 		strb	r7, [sp, #136]
1959:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 6130              		.loc 1 1959 0
 6131 3638 FEFFFFEB 		bl	CyU3PPibInit
 6132              	.LVL496:
1960:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6133              		.loc 1 1960 0
 6134 363c 002050E2 		subs	r2, r0, #0
 6135 3640 8F01001A 		bne	.L577
1967:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 6136              		.loc 1 1967 0
 6137 3644 F8079FE5 		ldr	r0, .L592+24
 6138              	.LVL497:
 6139 3648 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 6140              	.LVL498:
1975:../uvc.c      ****     SensorReset ();
 6141              		.loc 1 1975 0
 6142 364c FEFFFFEB 		bl	SensorReset
1976:../uvc.c      ****     CyU3PThreadSleep(5000);
 6143              		.loc 1 1976 0
 6144 3650 F0079FE5 		ldr	r0, .L592+28
 6145 3654 FEFFFFEB 		bl	_tx_thread_sleep
1980:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 6146              		.loc 1 1980 0
 6147 3658 FEFFFFEB 		bl	CyU3PUsbStart
 6148              	.LVL499:
1981:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6149              		.loc 1 1981 0
 6150 365c 002050E2 		subs	r2, r0, #0
 6151 3660 7E01001A 		bne	.L578
1987:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 6152              		.loc 1 1987 0
 6153 3664 0010A0E3 		mov	r1, #0
 6154 3668 DC079FE5 		ldr	r0, .L592+32
 6155              	.LVL500:
 6156 366c FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 6157              	.LVL501:
1990:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 6158              		.loc 1 1990 0
 6159 3670 D8079FE5 		ldr	r0, .L592+36
 6160 3674 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
1996:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 6161              		.loc 1 1996 0
 6162 3678 0010A0E3 		mov	r1, #0
 6163 367c D0279FE5 		ldr	r2, .L592+40
 6164 3680 0100A0E3 		mov	r0, #1
 6165 3684 FEFFFFEB 		bl	CyU3PUsbSetDesc
1997:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 6166              		.loc 1 1997 0
 6167 3688 0000A0E3 		mov	r0, #0
 6168 368c 0010A0E1 		mov	r1, r0
 6169 3690 C0279FE5 		ldr	r2, .L592+44
 6170 3694 FEFFFFEB 		bl	CyU3PUsbSetDesc
2000:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 6171              		.loc 1 2000 0
 6172 3698 0010A0E3 		mov	r1, #0
 6173 369c B8279FE5 		ldr	r2, .L592+48
 6174 36a0 0200A0E3 		mov	r0, #2
 6175 36a4 FEFFFFEB 		bl	CyU3PUsbSetDesc
2001:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 6176              		.loc 1 2001 0
 6177 36a8 0010A0E3 		mov	r1, #0
 6178 36ac AC279FE5 		ldr	r2, .L592+52
 6179 36b0 0700A0E3 		mov	r0, #7
 6180 36b4 FEFFFFEB 		bl	CyU3PUsbSetDesc
2004:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 6181              		.loc 1 2004 0
 6182 36b8 0010A0E3 		mov	r1, #0
 6183 36bc A0279FE5 		ldr	r2, .L592+56
 6184 36c0 0400A0E3 		mov	r0, #4
 6185 36c4 FEFFFFEB 		bl	CyU3PUsbSetDesc
2005:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 6186              		.loc 1 2005 0
 6187 36c8 0010A0E3 		mov	r1, #0
 6188 36cc 94279FE5 		ldr	r2, .L592+60
 6189 36d0 0300A0E3 		mov	r0, #3
 6190 36d4 FEFFFFEB 		bl	CyU3PUsbSetDesc
2006:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 6191              		.loc 1 2006 0
 6192 36d8 0010A0E3 		mov	r1, #0
 6193 36dc 88279FE5 		ldr	r2, .L592+64
 6194 36e0 0600A0E3 		mov	r0, #6
 6195 36e4 FEFFFFEB 		bl	CyU3PUsbSetDesc
2009:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 6196              		.loc 1 2009 0
 6197 36e8 0010A0E3 		mov	r1, #0
 6198 36ec 7C279FE5 		ldr	r2, .L592+68
 6199 36f0 0500A0E3 		mov	r0, #5
 6200 36f4 FEFFFFEB 		bl	CyU3PUsbSetDesc
2010:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 6201              		.loc 1 2010 0
 6202 36f8 0110A0E3 		mov	r1, #1
 6203 36fc 70279FE5 		ldr	r2, .L592+72
 6204 3700 0500A0E3 		mov	r0, #5
 6205 3704 FEFFFFEB 		bl	CyU3PUsbSetDesc
2011:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 6206              		.loc 1 2011 0
 6207 3708 0210A0E3 		mov	r1, #2
 6208 370c 64279FE5 		ldr	r2, .L592+76
 6209 3710 0500A0E3 		mov	r0, #5
 6210 3714 FEFFFFEB 		bl	CyU3PUsbSetDesc
2021:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6211              		.loc 1 2021 0
 6212 3718 0070A0E3 		mov	r7, #0
2018:../uvc.c      ****     endPointConfig.enable   = 1;
 6213              		.loc 1 2018 0
 6214 371c 0140A0E3 		mov	r4, #1
2019:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6215              		.loc 1 2019 0
 6216 3720 03A0A0E3 		mov	sl, #3
2024:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6217              		.loc 1 2024 0
 6218 3724 8200A0E3 		mov	r0, #130
 6219 3728 A8108DE2 		add	r1, sp, #168
2020:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6220              		.loc 1 2020 0
 6221 372c 4080A0E3 		mov	r8, #64	@ movhi
2019:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6222              		.loc 1 2019 0
 6223 3730 ACA0CDE5 		strb	sl, [sp, #172]
2018:../uvc.c      ****     endPointConfig.enable   = 1;
 6224              		.loc 1 2018 0
 6225 3734 A8408DE5 		str	r4, [sp, #168]
2020:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6226              		.loc 1 2020 0
 6227 3738 B08BCDE1 		strh	r8, [sp, #176]	@ movhi
2021:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6228              		.loc 1 2021 0
 6229 373c B370CDE5 		strb	r7, [sp, #179]
2022:../uvc.c      ****     endPointConfig.streams  = 0;
 6230              		.loc 1 2022 0
 6231 3740 BE7ACDE1 		strh	r7, [sp, #174]	@ movhi
2023:../uvc.c      ****     endPointConfig.burstLen = 1;
 6232              		.loc 1 2023 0
 6233 3744 B240CDE5 		strb	r4, [sp, #178]
2024:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6234              		.loc 1 2024 0
 6235 3748 FEFFFFEB 		bl	CyU3PSetEpConfig
 6236              	.LVL502:
2022:../uvc.c      ****     endPointConfig.streams  = 0;
 6237              		.loc 1 2022 0
 6238 374c 07A0A0E1 		mov	sl, r7	@ movhi
2025:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6239              		.loc 1 2025 0
 6240 3750 003050E2 		subs	r3, r0, #0
 6241 3754 3701001A 		bne	.L579
2035:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6242              		.loc 1 2035 0
 6243 3758 1CC79FE5 		ldr	ip, .L592+80
2036:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6244              		.loc 1 2036 0
 6245 375c 1CE79FE5 		ldr	lr, .L592+84
2033:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6246              		.loc 1 2033 0
 6247 3760 015BA0E3 		mov	r5, #1024	@ movhi
2042:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6248              		.loc 1 2042 0
 6249 3764 1070A0E3 		mov	r7, #16
2044:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6250              		.loc 1 2044 0
 6251 3768 14079FE5 		ldr	r0, .L592+88
 6252              	.LVL503:
 6253 376c 0410A0E3 		mov	r1, #4
 6254 3770 34208DE2 		add	r2, sp, #52
2033:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6255              		.loc 1 2033 0
 6256 3774 B453CDE1 		strh	r5, [sp, #52]	@ movhi
2034:../uvc.c      ****     dmaInterConfig.count          = 1;
 6257              		.loc 1 2034 0
 6258 3778 B643CDE1 		strh	r4, [sp, #54]	@ movhi
2035:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6259              		.loc 1 2035 0
 6260 377c B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
2036:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6261              		.loc 1 2036 0
 6262 3780 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
2037:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 6263              		.loc 1 2037 0
 6264 3784 BC33CDE1 		strh	r3, [sp, #60]	@ movhi
2038:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 6265              		.loc 1 2038 0
 6266 3788 BE33CDE1 		strh	r3, [sp, #62]	@ movhi
2039:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 6267              		.loc 1 2039 0
 6268 378c B034CDE1 		strh	r3, [sp, #64]	@ movhi
2040:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 6269              		.loc 1 2040 0
 6270 3790 B234CDE1 		strh	r3, [sp, #66]	@ movhi
2041:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6271              		.loc 1 2041 0
 6272 3794 44A0CDE5 		strb	sl, [sp, #68]
2042:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6273              		.loc 1 2042 0
 6274 3798 48708DE5 		str	r7, [sp, #72]
2043:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6275              		.loc 1 2043 0
 6276 379c 4C308DE5 		str	r3, [sp, #76]
2044:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6277              		.loc 1 2044 0
 6278 37a0 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6279              	.LVL504:
2046:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6280              		.loc 1 2046 0
 6281 37a4 005050E2 		subs	r5, r0, #0
 6282 37a8 DB00001A 		bne	.L580
2053:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6283              		.loc 1 2053 0
 6284 37ac 010BA0E3 		mov	r0, #1024
 6285              	.LVL505:
 6286 37b0 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6287 37b4 CC169FE5 		ldr	r1, .L592+92
2054:../uvc.c      ****     if (glInterStaBuffer == 0)
 6288              		.loc 1 2054 0
 6289 37b8 000050E3 		cmp	r0, #0
2053:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6290              		.loc 1 2053 0
 6291 37bc 000081E5 		str	r0, [r1, #0]
2054:../uvc.c      ****     if (glInterStaBuffer == 0)
 6292              		.loc 1 2054 0
 6293 37c0 CC00000A 		beq	.L581
2062:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6294              		.loc 1 2062 0
 6295 37c4 0430A0E3 		mov	r3, #4	@ movhi
 6296 37c8 BE30CDE1 		strh	r3, [sp, #14]	@ movhi
2066:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6297              		.loc 1 2066 0
 6298 37cc B8369FE5 		ldr	r3, .L592+96
2061:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6299              		.loc 1 2061 0
 6300 37d0 01E9A0E3 		mov	lr, #16384	@ movhi
 6301 37d4 BCE0CDE1 		strh	lr, [sp, #12]	@ movhi
2065:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6302              		.loc 1 2065 0
 6303 37d8 B0E69FE5 		ldr	lr, .L592+100
2066:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6304              		.loc 1 2066 0
 6305 37dc BA31CDE1 		strh	r3, [sp, #26]	@ movhi
2073:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6306              		.loc 1 2073 0
 6307 37e0 AC369FE5 		ldr	r3, .L592+104
2064:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6308              		.loc 1 2064 0
 6309 37e4 01CCA0E3 		mov	ip, #256	@ movhi
2074:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6310              		.loc 1 2074 0
 6311 37e8 0C208DE2 		add	r2, sp, #12
2064:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6312              		.loc 1 2064 0
 6313 37ec B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
2065:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6314              		.loc 1 2065 0
 6315 37f0 B4E1CDE1 		strh	lr, [sp, #20]	@ movhi
2068:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6316              		.loc 1 2068 0
 6317 37f4 0CC0A0E3 		mov	ip, #12	@ movhi
2069:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6318              		.loc 1 2069 0
 6319 37f8 04E0A0E3 		mov	lr, #4	@ movhi
2071:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6320              		.loc 1 2071 0
 6321 37fc 2AA0CDE5 		strb	sl, [sp, #42]
2063:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6322              		.loc 1 2063 0
 6323 3800 0280A0E3 		mov	r8, #2	@ movhi
2074:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6324              		.loc 1 2074 0
 6325 3804 8C069FE5 		ldr	r0, .L592+108
 6326 3808 0710A0E3 		mov	r1, #7
2072:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6327              		.loc 1 2072 0
 6328 380c 18A0A0E3 		mov	sl, #24
2063:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6329              		.loc 1 2063 0
 6330 3810 B081CDE1 		strh	r8, [sp, #16]	@ movhi
2067:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6331              		.loc 1 2067 0
 6332 3814 B252CDE1 		strh	r5, [sp, #34]	@ movhi
2068:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6333              		.loc 1 2068 0
 6334 3818 B4C2CDE1 		strh	ip, [sp, #36]	@ movhi
2069:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6335              		.loc 1 2069 0
 6336 381c B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
2070:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6337              		.loc 1 2070 0
 6338 3820 B852CDE1 		strh	r5, [sp, #40]	@ movhi
2072:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6339              		.loc 1 2072 0
 6340 3824 2CA08DE5 		str	sl, [sp, #44]
2073:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6341              		.loc 1 2073 0
 6342 3828 30308DE5 		str	r3, [sp, #48]
2074:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6343              		.loc 1 2074 0
 6344 382c FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6345              	.LVL506:
2076:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6346              		.loc 1 2076 0
 6347 3830 002050E2 		subs	r2, r0, #0
 6348 3834 A600001A 		bne	.L582
2167:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 6349              		.loc 1 2167 0
 6350 3838 0400A0E1 		mov	r0, r4
 6351              	.LVL507:
 6352 383c 0410A0E1 		mov	r1, r4
 6353 3840 FEFFFFEB 		bl	CyU3PConnectState
 6354              	.LVL508:
2168:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6355              		.loc 1 2168 0
 6356 3844 002050E2 		subs	r2, r0, #0
 6357 3848 9800001A 		bne	.L583
2174:../uvc.c      ****     CyU3PBusyWait(100);
 6358              		.loc 1 2174 0
 6359 384c 6400A0E3 		mov	r0, #100
 6360              	.LVL509:
 6361 3850 FEFFFFEB 		bl	CyU3PBusyWait
 6362              	.LVL510:
2176:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6363              		.loc 1 2176 0
 6364 3854 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2190:../uvc.c      ****     endPointConfig.streams  = 0;
 6365              		.loc 1 2190 0
 6366 3858 0020A0E3 		mov	r2, #0	@ movhi
2179:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6367              		.loc 1 2179 0
 6368 385c AC80CDE5 		strb	r8, [sp, #172]
2191:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6369              		.loc 1 2191 0
 6370 3860 A8108DE2 		add	r1, sp, #168
2190:../uvc.c      ****     endPointConfig.streams  = 0;
 6371              		.loc 1 2190 0
 6372 3864 BE2ACDE1 		strh	r2, [sp, #174]	@ movhi
2178:../uvc.c      ****     endPointConfig.enable   = 1;
 6373              		.loc 1 2178 0
 6374 3868 A8408DE5 		str	r4, [sp, #168]
2180:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6375              		.loc 1 2180 0
 6376 386c 030050E3 		cmp	r0, #3
2176:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6377              		.loc 1 2176 0
 6378 3870 4800C6E5 		strb	r0, [r6, #72]
2187:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6379              		.loc 1 2187 0
 6380 3874 020CA013 		movne	r0, #512	@ movhi
2182:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6381              		.loc 1 2182 0
 6382 3878 018BA003 		moveq	r8, #1024	@ movhi
2187:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6383              		.loc 1 2187 0
 6384 387c B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2191:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6385              		.loc 1 2191 0
 6386 3880 8300A0E3 		mov	r0, #131
2182:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6387              		.loc 1 2182 0
 6388 3884 B08BCD01 		streqh	r8, [sp, #176]	@ movhi
2183:../uvc.c      ****     	endPointConfig.burstLen = 16;
 6389              		.loc 1 2183 0
 6390 3888 B270CD05 		streqb	r7, [sp, #178]
2188:../uvc.c      ****     	endPointConfig.burstLen = 1;
 6391              		.loc 1 2188 0
 6392 388c B240CD15 		strneb	r4, [sp, #178]
2191:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6393              		.loc 1 2191 0
 6394 3890 FEFFFFEB 		bl	CyU3PSetEpConfig
 6395              	.LVL511:
2192:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6396              		.loc 1 2192 0
 6397 3894 002050E2 		subs	r2, r0, #0
 6398 3898 4F00001A 		bne	.L566
 6399 389c F8859FE5 		ldr	r8, .L592+112
 6400              	.LBE215:
 6401              	.LBE212:
2315:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6402              		.loc 1 2315 0
 6403 38a0 98559FE5 		ldr	r5, .L592+20
 6404 38a4 0240A0E1 		mov	r4, r2
2386:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6405              		.loc 1 2386 0
 6406 38a8 0870A0E1 		mov	r7, r8
 6407              	.LVL512:
 6408              	.L540:
2315:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6409              		.loc 1 2315 0
 6410 38ac 8C059FE5 		ldr	r0, .L592+20
 6411 38b0 0110A0E3 		mov	r1, #1
 6412 38b4 0220A0E3 		mov	r2, #2
 6413 38b8 B4308DE2 		add	r3, sp, #180
 6414 38bc 00408DE5 		str	r4, [sp, #0]
 6415 38c0 FEFFFFEB 		bl	_txe_event_flags_get
 6416 38c4 000050E3 		cmp	r0, #0
 6417 38c8 3000001A 		bne	.L542
2361:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6418              		.loc 1 2361 0
 6419 38cc 301095E5 		ldr	r1, [r5, #48]
 6420 38d0 000051E3 		cmp	r1, #0
 6421 38d4 0300000A 		beq	.L543
2361:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6422              		.loc 1 2361 0 is_stmt 0 discriminator 1
 6423 38d8 B4A3D5E1 		ldrh	sl, [r5, #52]
 6424 38dc B6C3D5E1 		ldrh	ip, [r5, #54]
 6425 38e0 0C005AE1 		cmp	sl, ip
 6426 38e4 1301000A 		beq	.L584
 6427              	.L543:
2513:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 6428              		.loc 1 2513 0 is_stmt 1
 6429 38e8 4010A0E3 		mov	r1, #64
 6430 38ec 0020A0E3 		mov	r2, #0
 6431 38f0 48059FE5 		ldr	r0, .L592+20
 6432 38f4 FEFFFFEB 		bl	_txe_event_flags_set
2516:../uvc.c      ****         CyU3PThreadRelinquish ();
 6433              		.loc 1 2516 0
 6434 38f8 FEFFFFEB 		bl	_txe_thread_relinquish
2517:../uvc.c      ****     }
 6435              		.loc 1 2517 0
 6436 38fc EAFFFFEA 		b	.L540
 6437              	.LVL513:
 6438              	.L569:
 6439              	.LBB250:
 6440              	.LBB214:
1865:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 6441              		.loc 1 1865 0
 6442 3900 0400A0E3 		mov	r0, #4
 6443              	.LVL514:
 6444 3904 94159FE5 		ldr	r1, .L592+116
 6445 3908 FEFFFFEB 		bl	CyU3PDebugPrint
 6446              	.LVL515:
 6447              	.L509:
 6448              	.LBB230:
 6449              	.LBB231:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6450              		.loc 1 1314 0
 6451 390c 90159FE5 		ldr	r1, .L592+120
 6452 3910 0400A0E3 		mov	r0, #4
 6453 3914 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 6454              		.loc 1 1315 0
 6455 3918 FA0FA0E3 		mov	r0, #1000
 6456 391c FEFFFFEB 		bl	_tx_thread_sleep
 6457 3920 F9FFFFEA 		b	.L509
 6458              	.LVL516:
 6459              	.L571:
 6460              	.LBE231:
 6461              	.LBE230:
1896:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 6462              		.loc 1 1896 0
 6463 3924 0400A0E3 		mov	r0, #4
 6464              	.LVL517:
 6465 3928 78159FE5 		ldr	r1, .L592+124
 6466 392c FEFFFFEB 		bl	CyU3PDebugPrint
 6467              	.LVL518:
 6468              	.L513:
 6469              	.LBB228:
 6470              	.LBB229:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6471              		.loc 1 1314 0
 6472 3930 6C159FE5 		ldr	r1, .L592+120
 6473 3934 0400A0E3 		mov	r0, #4
 6474 3938 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 6475              		.loc 1 1315 0
 6476 393c FA0FA0E3 		mov	r0, #1000
 6477 3940 FEFFFFEB 		bl	_tx_thread_sleep
 6478 3944 F9FFFFEA 		b	.L513
 6479              	.LVL519:
 6480              	.L570:
 6481              	.LBE229:
 6482              	.LBE228:
1887:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 6483              		.loc 1 1887 0
 6484 3948 0400A0E3 		mov	r0, #4
 6485              	.LVL520:
 6486 394c 58159FE5 		ldr	r1, .L592+128
 6487 3950 FEFFFFEB 		bl	CyU3PDebugPrint
 6488              	.LVL521:
 6489              	.L511:
 6490              	.LBB226:
 6491              	.LBB227:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6492              		.loc 1 1314 0
 6493 3954 48159FE5 		ldr	r1, .L592+120
 6494 3958 0400A0E3 		mov	r0, #4
 6495 395c FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 6496              		.loc 1 1315 0
 6497 3960 FA0FA0E3 		mov	r0, #1000
 6498 3964 FEFFFFEB 		bl	_tx_thread_sleep
 6499 3968 F9FFFFEA 		b	.L511
 6500              	.LVL522:
 6501              	.L572:
 6502              	.LBE227:
 6503              	.LBE226:
1902:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 6504              		.loc 1 1902 0
 6505 396c 0400A0E3 		mov	r0, #4
 6506              	.LVL523:
 6507 3970 38159FE5 		ldr	r1, .L592+132
 6508 3974 FEFFFFEB 		bl	CyU3PDebugPrint
 6509              	.LVL524:
 6510              	.L515:
 6511              	.LBB224:
 6512              	.LBB225:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6513              		.loc 1 1314 0
 6514 3978 24159FE5 		ldr	r1, .L592+120
 6515 397c 0400A0E3 		mov	r0, #4
 6516 3980 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 6517              		.loc 1 1315 0
 6518 3984 FA0FA0E3 		mov	r0, #1000
 6519 3988 FEFFFFEB 		bl	_tx_thread_sleep
 6520 398c F9FFFFEA 		b	.L515
 6521              	.LVL525:
 6522              	.L542:
 6523              	.LBE225:
 6524              	.LBE224:
 6525              	.LBE214:
 6526              	.LBE250:
2420:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 6527              		.loc 1 2420 0
 6528 3990 A8049FE5 		ldr	r0, .L592+20
 6529 3994 0210A0E3 		mov	r1, #2
 6530 3998 0320A0E3 		mov	r2, #3
 6531 399c B4308DE2 		add	r3, sp, #180
 6532 39a0 00408DE5 		str	r4, [sp, #0]
 6533 39a4 FEFFFFEB 		bl	_txe_event_flags_get
 6534 39a8 000050E3 		cmp	r0, #0
 6535 39ac 2500001A 		bne	.L550
2435:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6536              		.loc 1 2435 0
 6537 39b0 441095E5 		ldr	r1, [r5, #68]
2423:../uvc.c      ****                 hitFV     = CyFalse;
 6538              		.loc 1 2423 0
 6539 39b4 304085E5 		str	r4, [r5, #48]
2435:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6540              		.loc 1 2435 0
 6541 39b8 000051E3 		cmp	r1, #0
2424:../uvc.c      ****                 prodCount = 0;
 6542              		.loc 1 2424 0
 6543 39bc B443C5E1 		strh	r4, [r5, #52]	@ movhi
2431:../uvc.c      ****                 fb=0;
 6544              		.loc 1 2431 0
 6545 39c0 B842C5E1 		strh	r4, [r5, #40]	@ movhi
2425:../uvc.c      ****                 consCount = 0;
 6546              		.loc 1 2425 0
 6547 39c4 B643C5E1 		strh	r4, [r5, #54]	@ movhi
2432:../uvc.c      ****                 pb=0;
 6548              		.loc 1 2432 0
 6549 39c8 BA42C5E1 		strh	r4, [r5, #42]	@ movhi
2433:../uvc.c      ****                 pbc=0;
 6550              		.loc 1 2433 0
 6551 39cc BC42C5E1 		strh	r4, [r5, #44]	@ movhi
2435:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6552              		.loc 1 2435 0
 6553 39d0 0A00000A 		beq	.L585
 6554              	.L551:
2447:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 6555              		.loc 1 2447 0
 6556 39d4 444086E5 		str	r4, [r6, #68]
 6557 39d8 C2FFFFEA 		b	.L543
 6558              	.LVL526:
 6559              	.L566:
 6560              	.LBB251:
 6561              	.LBB248:
2195:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6562              		.loc 1 2195 0
 6563 39dc 0400A0E3 		mov	r0, #4
 6564              	.LVL527:
 6565 39e0 CC149FE5 		ldr	r1, .L592+136
 6566 39e4 FEFFFFEB 		bl	CyU3PDebugPrint
 6567              	.LVL528:
 6568              	.L541:
 6569              	.LBB232:
 6570              	.LBB233:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6571              		.loc 1 1314 0
 6572 39e8 B4149FE5 		ldr	r1, .L592+120
 6573 39ec 0400A0E3 		mov	r0, #4
 6574 39f0 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 6575              		.loc 1 1315 0
 6576 39f4 FA0FA0E3 		mov	r0, #1000
 6577 39f8 FEFFFFEB 		bl	_tx_thread_sleep
 6578 39fc F9FFFFEA 		b	.L541
 6579              	.LVL529:
 6580              	.L585:
 6581              	.LBE233:
 6582              	.LBE232:
 6583              	.LBE248:
 6584              	.LBE251:
2437:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6585              		.loc 1 2437 0
 6586 3a00 90049FE5 		ldr	r0, .L592+108
 6587 3a04 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6588              	.LVL530:
2438:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6589              		.loc 1 2438 0
 6590 3a08 000050E3 		cmp	r0, #0
 6591 3a0c 0200001A 		bne	.L567
2444:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 6592              		.loc 1 2444 0
 6593 3a10 8300A0E3 		mov	r0, #131
 6594              	.LVL531:
 6595 3a14 FEFFFFEB 		bl	CyU3PUsbFlushEp
 6596 3a18 EDFFFFEA 		b	.L551
 6597              	.L567:
 6598              	.LBB252:
 6599              	.LBB253:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6600              		.loc 1 1314 0
 6601 3a1c 80149FE5 		ldr	r1, .L592+120
 6602 3a20 0400A0E3 		mov	r0, #4
 6603 3a24 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 6604              		.loc 1 1315 0
 6605 3a28 FA0FA0E3 		mov	r0, #1000
 6606 3a2c FEFFFFEB 		bl	_tx_thread_sleep
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6607              		.loc 1 1314 0
 6608 3a30 6C149FE5 		ldr	r1, .L592+120
 6609 3a34 0400A0E3 		mov	r0, #4
 6610 3a38 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 6611              		.loc 1 1315 0
 6612 3a3c FA0FA0E3 		mov	r0, #1000
 6613 3a40 FEFFFFEB 		bl	_tx_thread_sleep
 6614 3a44 F4FFFFEA 		b	.L567
 6615              	.L550:
 6616              	.LBE253:
 6617              	.LBE252:
2452:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 6618              		.loc 1 2452 0
 6619 3a48 00C0E0E3 		mvn	ip, #0
 6620 3a4c 0110A0E3 		mov	r1, #1
 6621 3a50 0220A0E3 		mov	r2, #2
 6622 3a54 B4308DE2 		add	r3, sp, #180
 6623 3a58 E0039FE5 		ldr	r0, .L592+20
 6624 3a5c 00C08DE5 		str	ip, [sp, #0]
 6625 3a60 FEFFFFEB 		bl	_txe_event_flags_get
2456:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6626              		.loc 1 2456 0
 6627 3a64 0420A0E1 		mov	r2, r4
 6628 3a68 28049FE5 		ldr	r0, .L592+108
 6629 3a6c 0410A0E1 		mov	r1, r4
 6630 3a70 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6631              	.LVL532:
2457:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6632              		.loc 1 2457 0
 6633 3a74 002050E2 		subs	r2, r0, #0
 6634 3a78 6500001A 		bne	.L586
2465:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 6635              		.loc 1 2465 0
 6636 3a7c 3C3095E5 		ldr	r3, [r5, #60]
 6637 3a80 000053E3 		cmp	r3, #0
 6638 3a84 5A00001A 		bne	.L556
 6639              	.LVL533:
 6640              	.LBB254:
 6641              	.LBB255:
2220:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6642              		.loc 1 2220 0
 6643 3a88 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 6644 3a8c 030053E3 		cmp	r3, #3
 6645 3a90 4700000A 		beq	.L587
2225:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 6646              		.loc 1 2225 0
 6647 3a94 020053E3 		cmp	r3, #2
 6648 3a98 2900000A 		beq	.L588
 6649              	.LVL534:
 6650              	.L559:
 6651              	.LBE255:
 6652              	.LBE254:
2501:../uvc.c      ****                     gpif_initialized = CyTrue;
 6653              		.loc 1 2501 0
 6654 3a9c 01E0A0E3 		mov	lr, #1
 6655 3aa0 3CE086E5 		str	lr, [r6, #60]
2502:../uvc.c      ****                     CyU3PThreadSleep(200);
 6656              		.loc 1 2502 0
 6657 3aa4 C800A0E3 		mov	r0, #200
 6658 3aa8 FEFFFFEB 		bl	_tx_thread_sleep
 6659 3aac 8DFFFFEA 		b	.L543
 6660              	.LVL535:
 6661              	.L583:
 6662              	.LBB261:
 6663              	.LBB213:
2170:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 6664              		.loc 1 2170 0
 6665 3ab0 0400A0E3 		mov	r0, #4
 6666              	.LVL536:
 6667 3ab4 FC139FE5 		ldr	r1, .L592+140
 6668 3ab8 FEFFFFEB 		bl	CyU3PDebugPrint
 6669              	.LVL537:
 6670              	.L537:
 6671              	.LBB222:
 6672              	.LBB223:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6673              		.loc 1 1314 0
 6674 3abc E0139FE5 		ldr	r1, .L592+120
 6675 3ac0 0400A0E3 		mov	r0, #4
 6676 3ac4 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 6677              		.loc 1 1315 0
 6678 3ac8 FA0FA0E3 		mov	r0, #1000
 6679 3acc FEFFFFEB 		bl	_tx_thread_sleep
 6680 3ad0 F9FFFFEA 		b	.L537
 6681              	.LVL538:
 6682              	.L582:
 6683              	.LBE223:
 6684              	.LBE222:
2079:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 6685              		.loc 1 2079 0
 6686 3ad4 0400A0E3 		mov	r0, #4
 6687              	.LVL539:
 6688 3ad8 DC139FE5 		ldr	r1, .L592+144
 6689 3adc FEFFFFEB 		bl	CyU3PDebugPrint
 6690              	.LVL540:
 6691              	.L535:
 6692              	.LBB220:
 6693              	.LBB221:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6694              		.loc 1 1314 0
 6695 3ae0 BC139FE5 		ldr	r1, .L592+120
 6696 3ae4 0400A0E3 		mov	r0, #4
 6697 3ae8 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 6698              		.loc 1 1315 0
 6699 3aec FA0FA0E3 		mov	r0, #1000
 6700 3af0 FEFFFFEB 		bl	_tx_thread_sleep
 6701 3af4 F9FFFFEA 		b	.L535
 6702              	.LVL541:
 6703              	.L581:
 6704              	.LBE221:
 6705              	.LBE220:
2056:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 6706              		.loc 1 2056 0
 6707 3af8 040080E2 		add	r0, r0, #4
 6708 3afc BC139FE5 		ldr	r1, .L592+148
 6709 3b00 FEFFFFEB 		bl	CyU3PDebugPrint
 6710              	.LVL542:
 6711              	.L533:
 6712              	.LBB218:
 6713              	.LBB219:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6714              		.loc 1 1314 0
 6715 3b04 98139FE5 		ldr	r1, .L592+120
 6716 3b08 0400A0E3 		mov	r0, #4
 6717 3b0c FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 6718              		.loc 1 1315 0
 6719 3b10 FA0FA0E3 		mov	r0, #1000
 6720 3b14 FEFFFFEB 		bl	_tx_thread_sleep
 6721 3b18 F9FFFFEA 		b	.L533
 6722              	.LVL543:
 6723              	.L580:
 6724              	.LBE219:
 6725              	.LBE218:
2049:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 6726              		.loc 1 2049 0
 6727 3b1c 0400A0E3 		mov	r0, #4
 6728 3b20 9C139FE5 		ldr	r1, .L592+152
 6729 3b24 0520A0E1 		mov	r2, r5
 6730 3b28 FEFFFFEB 		bl	CyU3PDebugPrint
 6731              	.L531:
 6732              	.LBB216:
 6733              	.LBB217:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6734              		.loc 1 1314 0
 6735 3b2c 70139FE5 		ldr	r1, .L592+120
 6736 3b30 0400A0E3 		mov	r0, #4
 6737 3b34 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 6738              		.loc 1 1315 0
 6739 3b38 FA0FA0E3 		mov	r0, #1000
 6740 3b3c FEFFFFEB 		bl	_tx_thread_sleep
 6741 3b40 F9FFFFEA 		b	.L531
 6742              	.LVL544:
 6743              	.L588:
 6744              	.LBE217:
 6745              	.LBE216:
 6746              	.LBE213:
 6747              	.LBE261:
 6748              	.LBB262:
 6749              	.LBB260:
2227:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 6750              		.loc 1 2227 0
 6751 3b44 7C139FE5 		ldr	r1, .L592+156
 6752 3b48 0100A0E3 		mov	r0, #1
 6753              	.LVL545:
 6754 3b4c FEFFFFEB 		bl	CyU3PDebugPrint
 6755              	.LVL546:
2228:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 6756              		.loc 1 2228 0
 6757 3b50 74039FE5 		ldr	r0, .L592+160
 6758 3b54 FEFFFFEB 		bl	CyU3PGpifLoad
 6759 3b58 0020A0E1 		mov	r2, r0
 6760              	.LVL547:
 6761              	.L558:
2230:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6762              		.loc 1 2230 0
 6763 3b5c 000052E3 		cmp	r2, #0
 6764 3b60 1A00001A 		bne	.L589
2238:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6765              		.loc 1 2238 0
 6766 3b64 4830D6E5 		ldrb	r3, [r6, #72]	@ zero_extendqisi2
 6767 3b68 030053E3 		cmp	r3, #3
 6768 3b6c 0100000A 		beq	.L568
2242:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 6769              		.loc 1 2242 0
 6770 3b70 020053E3 		cmp	r3, #2
 6771 3b74 C8FFFF1A 		bne	.L559
 6772              	.L568:
2244:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6773              		.loc 1 2244 0
 6774 3b78 0200A0E1 		mov	r0, r2
 6775              	.LVL548:
 6776 3b7c 0210A0E1 		mov	r1, r2
 6777 3b80 FEFFFFEB 		bl	CyU3PGpifSMStart
 6778              	.LVL549:
2246:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6779              		.loc 1 2246 0
 6780 3b84 000050E3 		cmp	r0, #0
2244:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6781              		.loc 1 2244 0
 6782 3b88 0020A0E1 		mov	r2, r0
 6783              	.LVL550:
2246:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6784              		.loc 1 2246 0
 6785 3b8c C2FFFF0A 		beq	.L559
2249:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 6786              		.loc 1 2249 0
 6787 3b90 0400A0E3 		mov	r0, #4
 6788              	.LVL551:
 6789 3b94 34139FE5 		ldr	r1, .L592+164
 6790 3b98 FEFFFFEB 		bl	CyU3PDebugPrint
 6791              	.LVL552:
 6792              	.L564:
 6793              	.LBB256:
 6794              	.LBB257:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6795              		.loc 1 1314 0
 6796 3b9c 00139FE5 		ldr	r1, .L592+120
 6797 3ba0 0400A0E3 		mov	r0, #4
 6798 3ba4 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 6799              		.loc 1 1315 0
 6800 3ba8 FA0FA0E3 		mov	r0, #1000
 6801 3bac FEFFFFEB 		bl	_tx_thread_sleep
 6802 3bb0 F9FFFFEA 		b	.L564
 6803              	.LVL553:
 6804              	.L587:
 6805              	.LBE257:
 6806              	.LBE256:
2222:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 6807              		.loc 1 2222 0
 6808 3bb4 18139FE5 		ldr	r1, .L592+168
 6809 3bb8 0100A0E3 		mov	r0, #1
 6810              	.LVL554:
 6811 3bbc FEFFFFEB 		bl	CyU3PDebugPrint
 6812              	.LVL555:
2223:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 6813              		.loc 1 2223 0
 6814 3bc0 10039FE5 		ldr	r0, .L592+172
 6815 3bc4 FEFFFFEB 		bl	CyU3PGpifLoad
 6816 3bc8 0020A0E1 		mov	r2, r0
 6817              	.LVL556:
 6818 3bcc E2FFFFEA 		b	.L558
 6819              	.L589:
2233:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 6820              		.loc 1 2233 0
 6821 3bd0 0400A0E3 		mov	r0, #4
 6822              	.LVL557:
 6823 3bd4 00139FE5 		ldr	r1, .L592+176
 6824 3bd8 FEFFFFEB 		bl	CyU3PDebugPrint
 6825              	.LVL558:
 6826              	.L561:
 6827              	.LBB258:
 6828              	.LBB259:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6829              		.loc 1 1314 0
 6830 3bdc C0129FE5 		ldr	r1, .L592+120
 6831 3be0 0400A0E3 		mov	r0, #4
 6832 3be4 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 6833              		.loc 1 1315 0
 6834 3be8 FA0FA0E3 		mov	r0, #1000
 6835 3bec FEFFFFEB 		bl	_tx_thread_sleep
 6836 3bf0 F9FFFFEA 		b	.L561
 6837              	.LVL559:
 6838              	.L556:
 6839              	.LBE259:
 6840              	.LBE258:
 6841              	.LBE260:
 6842              	.LBE262:
2509:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6843              		.loc 1 2509 0
 6844 3bf4 94029FE5 		ldr	r0, .L592+100
 6845              	.LVL560:
 6846 3bf8 02A0A0E3 		mov	sl, #2
 6847 3bfc 0410A0E1 		mov	r1, r4
 6848 3c00 0020A0E1 		mov	r2, r0
 6849              	.LVL561:
 6850 3c04 0430A0E1 		mov	r3, r4
 6851 3c08 00A08DE5 		str	sl, [sp, #0]
 6852 3c0c FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6853 3c10 34FFFFEA 		b	.L543
 6854              	.LVL562:
 6855              	.L586:
2460:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 6856              		.loc 1 2460 0
 6857 3c14 0400A0E3 		mov	r0, #4
 6858              	.LVL563:
 6859 3c18 C0129FE5 		ldr	r1, .L592+180
 6860 3c1c FEFFFFEB 		bl	CyU3PDebugPrint
 6861              	.LVL564:
 6862              	.L555:
 6863              	.LBB263:
 6864              	.LBB264:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6865              		.loc 1 1314 0
 6866 3c20 7C129FE5 		ldr	r1, .L592+120
 6867 3c24 0400A0E3 		mov	r0, #4
 6868 3c28 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 6869              		.loc 1 1315 0
 6870 3c2c FA0FA0E3 		mov	r0, #1000
 6871 3c30 FEFFFFEB 		bl	_tx_thread_sleep
 6872 3c34 F9FFFFEA 		b	.L555
 6873              	.LVL565:
 6874              	.L579:
 6875              	.LBE264:
 6876              	.LBE263:
 6877              	.LBB265:
 6878              	.LBB249:
2028:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6879              		.loc 1 2028 0
 6880 3c38 0400A0E3 		mov	r0, #4
 6881              	.LVL566:
 6882 3c3c 70129FE5 		ldr	r1, .L592+136
 6883 3c40 0320A0E1 		mov	r2, r3
 6884 3c44 FEFFFFEB 		bl	CyU3PDebugPrint
 6885              	.LVL567:
 6886              	.L529:
 6887              	.LBB234:
 6888              	.LBB235:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6889              		.loc 1 1314 0
 6890 3c48 54129FE5 		ldr	r1, .L592+120
 6891 3c4c 0400A0E3 		mov	r0, #4
 6892 3c50 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 6893              		.loc 1 1315 0
 6894 3c54 FA0FA0E3 		mov	r0, #1000
 6895 3c58 FEFFFFEB 		bl	_tx_thread_sleep
 6896 3c5c F9FFFFEA 		b	.L529
 6897              	.LVL568:
 6898              	.L578:
 6899              	.LBE235:
 6900              	.LBE234:
1983:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6901              		.loc 1 1983 0
 6902 3c60 0400A0E3 		mov	r0, #4
 6903              	.LVL569:
 6904 3c64 78129FE5 		ldr	r1, .L592+184
 6905 3c68 FEFFFFEB 		bl	CyU3PDebugPrint
 6906              	.LVL570:
 6907              	.L527:
 6908              	.LBB236:
 6909              	.LBB237:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6910              		.loc 1 1314 0
 6911 3c6c 30129FE5 		ldr	r1, .L592+120
 6912 3c70 0400A0E3 		mov	r0, #4
 6913 3c74 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 6914              		.loc 1 1315 0
 6915 3c78 FA0FA0E3 		mov	r0, #1000
 6916 3c7c FEFFFFEB 		bl	_tx_thread_sleep
 6917 3c80 F9FFFFEA 		b	.L527
 6918              	.LVL571:
 6919              	.L577:
 6920              	.LBE237:
 6921              	.LBE236:
1962:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6922              		.loc 1 1962 0
 6923 3c84 0400A0E3 		mov	r0, #4
 6924              	.LVL572:
 6925 3c88 58129FE5 		ldr	r1, .L592+188
 6926 3c8c FEFFFFEB 		bl	CyU3PDebugPrint
 6927              	.LVL573:
 6928              	.L525:
 6929              	.LBB238:
 6930              	.LBB239:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6931              		.loc 1 1314 0
 6932 3c90 0C129FE5 		ldr	r1, .L592+120
 6933 3c94 0400A0E3 		mov	r0, #4
 6934 3c98 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 6935              		.loc 1 1315 0
 6936 3c9c FA0FA0E3 		mov	r0, #1000
 6937 3ca0 FEFFFFEB 		bl	_tx_thread_sleep
 6938 3ca4 F9FFFFEA 		b	.L525
 6939              	.LVL574:
 6940              	.L576:
 6941              	.LBE239:
 6942              	.LBE238:
1949:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 6943              		.loc 1 1949 0
 6944 3ca8 0400A0E3 		mov	r0, #4
 6945              	.LVL575:
 6946 3cac 38129FE5 		ldr	r1, .L592+192
 6947 3cb0 FEFFFFEB 		bl	CyU3PDebugPrint
 6948              	.LVL576:
 6949              	.L523:
 6950              	.LBB240:
 6951              	.LBB241:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6952              		.loc 1 1314 0
 6953 3cb4 E8119FE5 		ldr	r1, .L592+120
 6954 3cb8 0400A0E3 		mov	r0, #4
 6955 3cbc FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 6956              		.loc 1 1315 0
 6957 3cc0 FA0FA0E3 		mov	r0, #1000
 6958 3cc4 FEFFFFEB 		bl	_tx_thread_sleep
 6959 3cc8 F9FFFFEA 		b	.L523
 6960              	.LVL577:
 6961              	.L574:
 6962              	.LBE241:
 6963              	.LBE240:
1921:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 6964              		.loc 1 1921 0
 6965 3ccc 0400A0E3 		mov	r0, #4
 6966              	.LVL578:
 6967 3cd0 18129FE5 		ldr	r1, .L592+196
 6968 3cd4 FEFFFFEB 		bl	CyU3PDebugPrint
 6969              	.LVL579:
 6970              	.L519:
 6971              	.LBB242:
 6972              	.LBB243:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6973              		.loc 1 1314 0
 6974 3cd8 C4119FE5 		ldr	r1, .L592+120
 6975 3cdc 0400A0E3 		mov	r0, #4
 6976 3ce0 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 6977              		.loc 1 1315 0
 6978 3ce4 FA0FA0E3 		mov	r0, #1000
 6979 3ce8 FEFFFFEB 		bl	_tx_thread_sleep
 6980 3cec F9FFFFEA 		b	.L519
 6981              	.LVL580:
 6982              	.L573:
 6983              	.LBE243:
 6984              	.LBE242:
1908:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 6985              		.loc 1 1908 0
 6986 3cf0 0400A0E3 		mov	r0, #4
 6987              	.LVL581:
 6988 3cf4 F8119FE5 		ldr	r1, .L592+200
 6989 3cf8 FEFFFFEB 		bl	CyU3PDebugPrint
 6990              	.LVL582:
 6991              	.L517:
 6992              	.LBB244:
 6993              	.LBB245:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6994              		.loc 1 1314 0
 6995 3cfc A0119FE5 		ldr	r1, .L592+120
 6996 3d00 0400A0E3 		mov	r0, #4
 6997 3d04 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 6998              		.loc 1 1315 0
 6999 3d08 FA0FA0E3 		mov	r0, #1000
 7000 3d0c FEFFFFEB 		bl	_tx_thread_sleep
 7001 3d10 F9FFFFEA 		b	.L517
 7002              	.LVL583:
 7003              	.L575:
 7004              	.LBE245:
 7005              	.LBE244:
1935:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 7006              		.loc 1 1935 0
 7007 3d14 0400A0E3 		mov	r0, #4
 7008              	.LVL584:
 7009 3d18 D8119FE5 		ldr	r1, .L592+204
 7010 3d1c FEFFFFEB 		bl	CyU3PDebugPrint
 7011              	.LVL585:
 7012              	.L521:
 7013              	.LBB246:
 7014              	.LBB247:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7015              		.loc 1 1314 0
 7016 3d20 7C119FE5 		ldr	r1, .L592+120
 7017 3d24 0400A0E3 		mov	r0, #4
 7018 3d28 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 7019              		.loc 1 1315 0
 7020 3d2c FA0FA0E3 		mov	r0, #1000
 7021 3d30 FEFFFFEB 		bl	_tx_thread_sleep
 7022 3d34 F9FFFFEA 		b	.L521
 7023              	.LVL586:
 7024              	.L584:
 7025              	.LBE247:
 7026              	.LBE246:
 7027              	.LBE249:
 7028              	.LBE265:
2371:../uvc.c      ****                 prodCount = 0;
 7029              		.loc 1 2371 0
 7030 3d38 B443C5E1 		strh	r4, [r5, #52]	@ movhi
2372:../uvc.c      ****                 consCount = 0;
 7031              		.loc 1 2372 0
 7032 3d3c B643C5E1 		strh	r4, [r5, #54]	@ movhi
2373:../uvc.c      ****                 hitFV     = CyFalse;
 7033              		.loc 1 2373 0
 7034 3d40 304085E5 		str	r4, [r5, #48]
2386:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 7035              		.loc 1 2386 0
 7036 3d44 8124D8E5 		ldrb	r2, [r8, #1153]	@ zero_extendqisi2
2368:../uvc.c      ****             	fb=0;
 7037              		.loc 1 2368 0
 7038 3d48 B842C5E1 		strh	r4, [r5, #40]	@ movhi
2386:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 7039              		.loc 1 2386 0
 7040 3d4c 01E022E2 		eor	lr, r2, #1
 7041 3d50 81E4C8E5 		strb	lr, [r8, #1153]
2387:../uvc.c      ****                 if(stiflag){
 7042              		.loc 1 2387 0
 7043 3d54 A03095E5 		ldr	r3, [r5, #160]
2369:../uvc.c      ****             	pb=0;
 7044              		.loc 1 2369 0
 7045 3d58 BA42C5E1 		strh	r4, [r5, #42]	@ movhi
2387:../uvc.c      ****                 if(stiflag){
 7046              		.loc 1 2387 0
 7047 3d5c 000053E3 		cmp	r3, #0
2394:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 7048              		.loc 1 2394 0
 7049 3d60 8134D705 		ldreqb	r3, [r7, #1153]	@ zero_extendqisi2
2370:../uvc.c      ****             	pbc=0;
 7050              		.loc 1 2370 0
 7051 3d64 BC42C5E1 		strh	r4, [r5, #44]	@ movhi
2394:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 7052              		.loc 1 2394 0
 7053 3d68 DF300302 		andeq	r3, r3, #223
 7054 3d6c 8134C705 		streqb	r3, [r7, #1153]
2387:../uvc.c      ****                 if(stiflag){
 7055              		.loc 1 2387 0
 7056 3d70 0A00000A 		beq	.L545
2388:../uvc.c      ****                 	if (CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3P_EVENT_AND_CLEAR, &fl
 7057              		.loc 1 2388 0
 7058 3d74 C4009FE5 		ldr	r0, .L592+20
 7059 3d78 8010A0E3 		mov	r1, #128
 7060 3d7c 0320A0E3 		mov	r2, #3
 7061 3d80 B4308DE2 		add	r3, sp, #180
 7062 3d84 00408DE5 		str	r4, [sp, #0]
 7063 3d88 FEFFFFEB 		bl	_txe_event_flags_get
 7064 3d8c 000050E3 		cmp	r0, #0
2390:../uvc.c      ****                 		glUVCHeader[1] |= (1<<5);    //set still image flag
 7065              		.loc 1 2390 0
 7066 3d90 8104D705 		ldreqb	r0, [r7, #1153]	@ zero_extendqisi2
 7067 3d94 20008003 		orreq	r0, r0, #32
 7068 3d98 8104C705 		streqb	r0, [r7, #1153]
2391:../uvc.c      ****                 		stiflag = CyFalse;
 7069              		.loc 1 2391 0
 7070 3d9c A0408505 		streq	r4, [r5, #160]
 7071              	.L545:
2397:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 7072              		.loc 1 2397 0
 7073 3da0 F0009FE5 		ldr	r0, .L592+108
 7074 3da4 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 7075              	.LVL587:
2398:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7076              		.loc 1 2398 0
 7077 3da8 002050E2 		subs	r2, r0, #0
 7078 3dac 0C00001A 		bne	.L590
2405:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 7079              		.loc 1 2405 0
 7080 3db0 0210A0E1 		mov	r1, r2
 7081 3db4 DC009FE5 		ldr	r0, .L592+108
 7082              	.LVL588:
 7083 3db8 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 7084              	.LVL589:
2406:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7085              		.loc 1 2406 0
 7086 3dbc 002050E2 		subs	r2, r0, #0
 7087 3dc0 1000001A 		bne	.L591
2414:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 7088              		.loc 1 2414 0
 7089 3dc4 C4009FE5 		ldr	r0, .L592+100
 7090              	.LVL590:
 7091 3dc8 0210A0E1 		mov	r1, r2
 7092 3dcc 02A0A0E3 		mov	sl, #2
 7093 3dd0 0020A0E1 		mov	r2, r0
 7094              	.LVL591:
 7095 3dd4 0130A0E1 		mov	r3, r1
 7096 3dd8 00A08DE5 		str	sl, [sp, #0]
 7097 3ddc FEFFFFEB 		bl	CyU3PGpifSMSwitch
 7098              	.LVL592:
 7099 3de0 C0FEFFEA 		b	.L543
 7100              	.LVL593:
 7101              	.L590:
2400:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 7102              		.loc 1 2400 0
 7103 3de4 0400A0E3 		mov	r0, #4
 7104              	.LVL594:
 7105 3de8 0C119FE5 		ldr	r1, .L592+208
 7106 3dec FEFFFFEB 		bl	CyU3PDebugPrint
 7107              	.LVL595:
 7108              	.L547:
 7109              	.LBB266:
 7110              	.LBB267:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7111              		.loc 1 1314 0
 7112 3df0 AC109FE5 		ldr	r1, .L592+120
 7113 3df4 0400A0E3 		mov	r0, #4
 7114 3df8 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 7115              		.loc 1 1315 0
 7116 3dfc FA0FA0E3 		mov	r0, #1000
 7117 3e00 FEFFFFEB 		bl	_tx_thread_sleep
 7118 3e04 F9FFFFEA 		b	.L547
 7119              	.LVL596:
 7120              	.L591:
 7121              	.LBE267:
 7122              	.LBE266:
2408:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 7123              		.loc 1 2408 0
 7124 3e08 0400A0E3 		mov	r0, #4
 7125              	.LVL597:
 7126 3e0c EC109FE5 		ldr	r1, .L592+212
 7127 3e10 FEFFFFEB 		bl	CyU3PDebugPrint
 7128              	.LVL598:
 7129              	.L549:
 7130              	.LBB268:
 7131              	.LBB269:
1314:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7132              		.loc 1 1314 0
 7133 3e14 88109FE5 		ldr	r1, .L592+120
 7134 3e18 0400A0E3 		mov	r0, #4
 7135 3e1c FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****         CyU3PThreadSleep (1000);
 7136              		.loc 1 1315 0
 7137 3e20 FA0FA0E3 		mov	r0, #1000
 7138 3e24 FEFFFFEB 		bl	_tx_thread_sleep
 7139 3e28 F9FFFFEA 		b	.L549
 7140              	.L593:
 7141              		.align	2
 7142              	.L592:
 7143 3e2c D0060000 		.word	.LC38
 7144 3e30 00C20100 		.word	115200
 7145 3e34 F0060000 		.word	.LC39
 7146 3e38 A0860100 		.word	100000
 7147 3e3c 0C070000 		.word	.LC40
 7148 3e40 00000000 		.word	.LANCHOR0
 7149 3e44 00000000 		.word	CyFxGpifCB
 7150 3e48 88130000 		.word	5000
 7151 3e4c 00000000 		.word	CyFxUVCApplnUSBSetupCB
 7152 3e50 00000000 		.word	CyFxUVCApplnUSBEventCB
 7153 3e54 00000000 		.word	CyFxUSBDeviceDscr
 7154 3e58 00000000 		.word	CyFxUSBDeviceDscrSS
 7155 3e5c 00000000 		.word	CyFxUSBDeviceQualDscr
 7156 3e60 00000000 		.word	CyFxUSBBOSDscr
 7157 3e64 00000000 		.word	CyFxUSBHSConfigDscr
 7158 3e68 00000000 		.word	CyFxUSBFSConfigDscr
 7159 3e6c 00000000 		.word	CyFxUSBSSConfigDscr
 7160 3e70 00000000 		.word	CyFxUSBStringLangIDDscr
 7161 3e74 00000000 		.word	CyFxUSBManufactureDscr
 7162 3e78 00000000 		.word	CyFxUSBProductDscr
 7163 3e7c 013F0000 		.word	16129
 7164 3e80 02030000 		.word	770
 7165 3e84 00000000 		.word	glChHandleInterStat
 7166 3e88 00000000 		.word	glInterStaBuffer
 7167 3e8c 03030000 		.word	771
 7168 3e90 01010000 		.word	257
 7169 3e94 00000000 		.word	CyFxUvcApplnDmaCallback
 7170 3e98 00000000 		.word	glChHandleUVCStream
 7171 3e9c 00000000 		.word	.LANCHOR1
 7172 3ea0 28070000 		.word	.LC41
 7173 3ea4 D8010000 		.word	.LC12
 7174 3ea8 78070000 		.word	.LC43
 7175 3eac 54070000 		.word	.LC42
 7176 3eb0 A0070000 		.word	.LC44
 7177 3eb4 F8080000 		.word	.LC51
 7178 3eb8 D4090000 		.word	.LC55
 7179 3ebc A4090000 		.word	.LC54
 7180 3ec0 6C090000 		.word	.LC53
 7181 3ec4 2C090000 		.word	.LC52
 7182 3ec8 A00A0000 		.word	.LC60
 7183 3ecc 2C000000 		.word	.LANCHOR2+44
 7184 3ed0 E80A0000 		.word	.LC62
 7185 3ed4 900A0000 		.word	.LC59
 7186 3ed8 10000000 		.word	.LANCHOR2+16
 7187 3edc B00A0000 		.word	.LC61
 7188 3ee0 5C0A0000 		.word	.LC58
 7189 3ee4 C8080000 		.word	.LC50
 7190 3ee8 98080000 		.word	.LC49
 7191 3eec 60080000 		.word	.LC48
 7192 3ef0 F8070000 		.word	.LC46
 7193 3ef4 CC070000 		.word	.LC45
 7194 3ef8 2C080000 		.word	.LC47
 7195 3efc FC090000 		.word	.LC56
 7196 3f00 280A0000 		.word	.LC57
 7197              	.LBE269:
 7198              	.LBE268:
 7199              		.cfi_endproc
 7200              	.LFE18:
 7202              		.align	2
 7203              		.global	CyFxApplicationDefine
 7205              	CyFxApplicationDefine:
 7206              	.LFB26:
3775:../uvc.c      **** }
3776:../uvc.c      **** 
3777:../uvc.c      **** 
3778:../uvc.c      **** /*
3779:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
3780:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
3781:../uvc.c      ****  */
3782:../uvc.c      **** void
3783:../uvc.c      **** CyFxApplicationDefine (
3784:../uvc.c      ****         void)
3785:../uvc.c      **** {
 7207              		.loc 1 3785 0
 7208              		.cfi_startproc
 7209              		@ args = 0, pretend = 0, frame = 40
 7210              		@ frame_needed = 0, uses_anonymous_args = 0
 7211              	.LVL599:
 7212 3f04 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7213              	.LCFI25:
 7214              		.cfi_def_cfa_offset 36
3786:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
3787:../uvc.c      ****     uint32_t retThrdCreate;
3788:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3789:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3790:../uvc.c      **** 
3791:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
3792:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7215              		.loc 1 3792 0
 7216 3f08 010AA0E3 		mov	r0, #4096
3785:../uvc.c      **** {
 7217              		.loc 1 3785 0
 7218 3f0c 4CD04DE2 		sub	sp, sp, #76
 7219              	.LCFI26:
 7220              		.cfi_def_cfa_offset 112
 7221              		.loc 1 3792 0
 7222              		.cfi_offset 14, -4
 7223              		.cfi_offset 11, -8
 7224              		.cfi_offset 10, -12
 7225              		.cfi_offset 9, -16
 7226              		.cfi_offset 8, -20
 7227              		.cfi_offset 7, -24
 7228              		.cfi_offset 6, -28
 7229              		.cfi_offset 5, -32
 7230              		.cfi_offset 4, -36
 7231 3f10 FEFFFFEB 		bl	CyU3PMemAlloc
 7232 3f14 00A0A0E1 		mov	sl, r0
 7233              	.LVL600:
3793:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7234              		.loc 1 3793 0
 7235 3f18 010AA0E3 		mov	r0, #4096
 7236              	.LVL601:
 7237 3f1c FEFFFFEB 		bl	CyU3PMemAlloc
 7238 3f20 00B0A0E1 		mov	fp, r0
 7239              	.LVL602:
3794:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7240              		.loc 1 3794 0
 7241 3f24 010AA0E3 		mov	r0, #4096
 7242              	.LVL603:
 7243 3f28 FEFFFFEB 		bl	CyU3PMemAlloc
3795:../uvc.c      **** 
3796:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 7244              		.loc 1 3796 0
 7245 3f2c 00005AE3 		cmp	sl, #0
 7246 3f30 00005B13 		cmpne	fp, #0
 7247 3f34 0090A013 		movne	r9, #0
 7248 3f38 0190A003 		moveq	r9, #1
3794:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7249              		.loc 1 3794 0
 7250 3f3c 24008DE5 		str	r0, [sp, #36]
 7251              	.LVL604:
 7252              		.loc 1 3796 0
 7253 3f40 0000001A 		bne	.L598
 7254              	.LVL605:
 7255              	.L595:
 7256              	.L597:
 7257 3f44 FEFFFFEA 		b	.L597
 7258              	.L598:
 7259              		.loc 1 3796 0 is_stmt 0 discriminator 1
 7260 3f48 000050E3 		cmp	r0, #0
 7261 3f4c FCFFFF0A 		beq	.L595
3797:../uvc.c      ****         goto fatalErrorHandler;
3798:../uvc.c      **** 
3799:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
3800:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7262              		.loc 1 3800 0 is_stmt 1
 7263 3f50 28408DE2 		add	r4, sp, #40
 7264 3f54 0400A0E1 		mov	r0, r4
 7265 3f58 4010A0E3 		mov	r1, #64
 7266 3f5c 18219FE5 		ldr	r2, .L599
 7267 3f60 FEFFFFEB 		bl	cmdbufCreate
 7268 3f64 0450A0E1 		mov	r5, r4
 7269 3f68 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 7270 3f6c 0C719FE5 		ldr	r7, .L599+4
3801:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7271              		.loc 1 3801 0
 7272 3f70 0C819FE5 		ldr	r8, .L599+8
3800:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7273              		.loc 1 3800 0
 7274 3f74 07C0A0E1 		mov	ip, r7
 7275 3f78 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7276 3f7c 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
3802:../uvc.c      **** 
3803:../uvc.c      **** 	/****** initialize command descriptor ***********/
3804:../uvc.c      **** 	cmdquInit(cmdQuptr);
3805:../uvc.c      **** 	cmdquInit(statQuptr);
3806:../uvc.c      **** 
3807:../uvc.c      ****     /* Create the UVC application thread. */
3808:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 7277              		.loc 1 3808 0
 7278 3f80 0860A0E3 		mov	r6, #8
3800:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7279              		.loc 1 3800 0
 7280 3f84 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3801:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7281              		.loc 1 3801 0
 7282 3f88 F8209FE5 		ldr	r2, .L599+12
 7283 3f8c 0400A0E1 		mov	r0, r4
 7284 3f90 2010A0E3 		mov	r1, #32
 7285 3f94 FEFFFFEB 		bl	cmdbufCreate
 7286 3f98 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 7287 3f9c 08C0A0E1 		mov	ip, r8
 7288 3fa0 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7289 3fa4 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 7290              		.loc 1 3808 0
 7291 3fa8 0140A0E3 		mov	r4, #1
3801:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7292              		.loc 1 3801 0
 7293 3fac 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3804:../uvc.c      **** 	cmdquInit(cmdQuptr);
 7294              		.loc 1 3804 0
 7295 3fb0 0700A0E1 		mov	r0, r7
 7296 3fb4 FEFFFFEB 		bl	cmdquInit
3805:../uvc.c      **** 	cmdquInit(statQuptr);
 7297              		.loc 1 3805 0
 7298 3fb8 0800A0E1 		mov	r0, r8
 7299 3fbc FEFFFFEB 		bl	cmdquInit
 7300              		.loc 1 3808 0
 7301 3fc0 A850A0E3 		mov	r5, #168
 7302 3fc4 01CAA0E3 		mov	ip, #4096
 7303 3fc8 BC009FE5 		ldr	r0, .L599+16
 7304 3fcc BC109FE5 		ldr	r1, .L599+20
 7305 3fd0 BC209FE5 		ldr	r2, .L599+24
 7306 3fd4 0930A0E1 		mov	r3, r9
 7307 3fd8 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 7308 3fdc 08608DE5 		str	r6, [sp, #8]
 7309 3fe0 0C608DE5 		str	r6, [sp, #12]
 7310 3fe4 10908DE5 		str	r9, [sp, #16]
 7311 3fe8 14408DE5 		str	r4, [sp, #20]
 7312 3fec 18508DE5 		str	r5, [sp, #24]
 7313 3ff0 FEFFFFEB 		bl	_txe_thread_create
 7314              	.LVL606:
3809:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
3810:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
3811:../uvc.c      ****             0,                                          /* No input parameter to thread */
3812:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
3813:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
3814:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3815:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
3816:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3817:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3818:../uvc.c      ****             );
3819:../uvc.c      ****     if (retThrdCreate != 0)
 7315              		.loc 1 3819 0
 7316 3ff4 00C050E2 		subs	ip, r0, #0
 7317 3ff8 D1FFFF1A 		bne	.L595
3820:../uvc.c      ****     {
3821:../uvc.c      ****         goto fatalErrorHandler;
3822:../uvc.c      ****     }
3823:../uvc.c      **** 
3824:../uvc.c      ****     /* Create the control request handling thread. */
3825:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 7318              		.loc 1 3825 0
 7319 3ffc 0C30A0E1 		mov	r3, ip
 7320 4000 027BA0E3 		mov	r7, #2048
 7321 4004 8C009FE5 		ldr	r0, .L599+28
 7322              	.LVL607:
 7323 4008 8C109FE5 		ldr	r1, .L599+32
 7324 400c 8C209FE5 		ldr	r2, .L599+36
 7325 4010 10C08DE5 		str	ip, [sp, #16]
 7326 4014 00B08DE5 		str	fp, [sp, #0]
 7327 4018 04708DE5 		str	r7, [sp, #4]
 7328 401c 08608DE5 		str	r6, [sp, #8]
 7329 4020 0C608DE5 		str	r6, [sp, #12]
 7330 4024 14408DE5 		str	r4, [sp, #20]
 7331 4028 18508DE5 		str	r5, [sp, #24]
 7332 402c FEFFFFEB 		bl	_txe_thread_create
 7333              	.LVL608:
3826:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
3827:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
3828:../uvc.c      ****             0,                                                  /* No input parameter to thread */
3829:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
3830:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
3831:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
3832:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
3833:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
3834:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
3835:../uvc.c      ****             );
3836:../uvc.c      ****     if (retThrdCreate != 0)
 7334              		.loc 1 3836 0
 7335 4030 00C050E2 		subs	ip, r0, #0
 7336 4034 C2FFFF1A 		bne	.L595
3837:../uvc.c      ****     {
3838:../uvc.c      ****         goto fatalErrorHandler;
3839:../uvc.c      ****     }
3840:../uvc.c      **** #if 1
3841:../uvc.c      ****     /* Create the I2C control command handling thread. */
3842:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 7337              		.loc 1 3842 0
 7338 4038 24E09DE5 		ldr	lr, [sp, #36]
 7339 403c 60009FE5 		ldr	r0, .L599+40
 7340              	.LVL609:
 7341 4040 60109FE5 		ldr	r1, .L599+44
 7342 4044 60209FE5 		ldr	r2, .L599+48
 7343 4048 0C30A0E1 		mov	r3, ip
 7344 404c 00E08DE5 		str	lr, [sp, #0]
 7345 4050 04708DE5 		str	r7, [sp, #4]
 7346 4054 08608DE5 		str	r6, [sp, #8]
 7347 4058 0C608DE5 		str	r6, [sp, #12]
 7348 405c 10C08DE5 		str	ip, [sp, #16]
 7349 4060 14408DE5 		str	r4, [sp, #20]
 7350 4064 18508DE5 		str	r5, [sp, #24]
 7351 4068 FEFFFFEB 		bl	_txe_thread_create
 7352              	.LVL610:
3843:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
3844:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
3845:../uvc.c      ****             0,                                          /* No input parameter to thread */
3846:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
3847:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
3848:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3849:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
3850:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3851:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3852:../uvc.c      ****             );
3853:../uvc.c      ****     if (retThrdCreate != 0)
 7353              		.loc 1 3853 0
 7354 406c 000050E3 		cmp	r0, #0
 7355 4070 B3FFFF1A 		bne	.L595
3854:../uvc.c      ****     {
3855:../uvc.c      ****         goto fatalErrorHandler;
3856:../uvc.c      ****     }
3857:../uvc.c      **** #endif
3858:../uvc.c      **** 
3859:../uvc.c      ****     return;
3860:../uvc.c      **** 
3861:../uvc.c      **** fatalErrorHandler:
3862:../uvc.c      ****     /* Add custom recovery or debug actions here */
3863:../uvc.c      ****     /* Loop indefinitely */
3864:../uvc.c      ****     while (1);
3865:../uvc.c      **** }
 7356              		.loc 1 3865 0
 7357 4074 4CD08DE2 		add	sp, sp, #76
 7358 4078 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 7359              	.L600:
 7360              		.align	2
 7361              	.L599:
 7362 407c 00000000 		.word	cmdQuMux
 7363 4080 00000000 		.word	cmdQu
 7364 4084 00000000 		.word	statQu
 7365 4088 00000000 		.word	staQuMux
 7366 408c A4000000 		.word	.LANCHOR0+164
 7367 4090 200B0000 		.word	.LC63
 7368 4094 00000000 		.word	UVCAppThread_Entry
 7369 4098 4C010000 		.word	.LANCHOR0+332
 7370 409c 340B0000 		.word	.LC64
 7371 40a0 00000000 		.word	UVCAppEP0Thread_Entry
 7372 40a4 F4010000 		.word	.LANCHOR0+500
 7373 40a8 4C0B0000 		.word	.LC65
 7374 40ac 00000000 		.word	I2cAppThread_Entry
 7375              		.cfi_endproc
 7376              	.LFE26:
 7378              		.align	2
 7379              		.global	main
 7381              	main:
 7382              	.LFB27:
3866:../uvc.c      **** 
3867:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
3868:../uvc.c      ****  * the ThreadX RTOS here.
3869:../uvc.c      ****  */
3870:../uvc.c      **** int
3871:../uvc.c      **** main (
3872:../uvc.c      ****         void)
3873:../uvc.c      **** {
 7383              		.loc 1 3873 0
 7384              		.cfi_startproc
 7385              		@ args = 0, pretend = 0, frame = 56
 7386              		@ frame_needed = 0, uses_anonymous_args = 0
 7387 40b0 30402DE9 		stmfd	sp!, {r4, r5, lr}
 7388              	.LCFI27:
 7389              		.cfi_def_cfa_offset 12
3874:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3875:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
3876:../uvc.c      **** 
3877:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
3878:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
3879:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
3880:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
3881:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
3882:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7390              		.loc 1 3882 0
 7391 40b4 0010A0E3 		mov	r1, #0
3873:../uvc.c      **** {
 7392              		.loc 1 3873 0
 7393 40b8 3CD04DE2 		sub	sp, sp, #60
 7394              	.LCFI28:
 7395              		.cfi_def_cfa_offset 72
3879:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7396              		.loc 1 3879 0
 7397 40bc 0220A0E3 		mov	r2, #2
3883:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7398              		.loc 1 3883 0
 7399 40c0 033081E2 		add	r3, r1, #3
3878:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7400              		.loc 1 3878 0
 7401 40c4 0150A0E3 		mov	r5, #1
 7402              		.cfi_offset 14, -4
 7403              		.cfi_offset 5, -8
 7404              		.cfi_offset 4, -12
3884:../uvc.c      **** 
3885:../uvc.c      ****     /* Initialize the device */
3886:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 7405              		.loc 1 3886 0
 7406 40c8 28008DE2 		add	r0, sp, #40
3878:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7407              		.loc 1 3878 0
 7408 40cc 28508DE5 		str	r5, [sp, #40]
3879:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7409              		.loc 1 3879 0
 7410 40d0 2C20CDE5 		strb	r2, [sp, #44]
3880:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 7411              		.loc 1 3880 0
 7412 40d4 2D20CDE5 		strb	r2, [sp, #45]
3881:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 7413              		.loc 1 3881 0
 7414 40d8 2E20CDE5 		strb	r2, [sp, #46]
3882:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7415              		.loc 1 3882 0
 7416 40dc 30108DE5 		str	r1, [sp, #48]
3883:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7417              		.loc 1 3883 0
 7418 40e0 3430CDE5 		strb	r3, [sp, #52]
 7419              		.loc 1 3886 0
 7420 40e4 FEFFFFEB 		bl	CyU3PDeviceInit
 7421              	.LVL611:
3887:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7422              		.loc 1 3887 0
 7423 40e8 004050E2 		subs	r4, r0, #0
 7424 40ec 0000000A 		beq	.L604
 7425              	.L602:
 7426              	.L603:
 7427 40f0 FEFFFFEA 		b	.L603
 7428              	.L604:
3888:../uvc.c      ****     {
3889:../uvc.c      ****         goto handle_fatal_error;
3890:../uvc.c      ****     }
3891:../uvc.c      **** 
3892:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
3893:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 7429              		.loc 1 3893 0
 7430 40f4 0410A0E1 		mov	r1, r4
 7431 40f8 0420A0E1 		mov	r2, r4
 7432 40fc 0500A0E1 		mov	r0, r5
 7433              	.LVL612:
 7434 4100 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 7435              	.LVL613:
3894:../uvc.c      **** 
3895:../uvc.c      ****     /* Configure the IO matrix for the device. */
3896:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
3897:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
3898:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
3899:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
3900:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
3901:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
3902:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
3903:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
3904:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
3905:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
3906:../uvc.c      **** 
3907:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 7436              		.loc 1 3907 0
 7437 4104 0D00A0E1 		mov	r0, sp
3897:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 7438              		.loc 1 3897 0
 7439 4108 1640CDE5 		strb	r4, [sp, #22]
3898:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 7440              		.loc 1 3898 0
 7441 410c 18408DE5 		str	r4, [sp, #24]
3899:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 7442              		.loc 1 3899 0
 7443 4110 1C408DE5 		str	r4, [sp, #28]
3900:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 7444              		.loc 1 3900 0
 7445 4114 20408DE5 		str	r4, [sp, #32]
3901:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 7446              		.loc 1 3901 0
 7447 4118 24408DE5 		str	r4, [sp, #36]
3904:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 7448              		.loc 1 3904 0
 7449 411c 0C408DE5 		str	r4, [sp, #12]
3905:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 7450              		.loc 1 3905 0
 7451 4120 10408DE5 		str	r4, [sp, #16]
3896:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 7452              		.loc 1 3896 0
 7453 4124 00508DE5 		str	r5, [sp, #0]
3902:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 7454              		.loc 1 3902 0
 7455 4128 04508DE5 		str	r5, [sp, #4]
3903:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 7456              		.loc 1 3903 0
 7457 412c 08508DE5 		str	r5, [sp, #8]
 7458              		.loc 1 3907 0
 7459 4130 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 7460              	.LVL614:
3908:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7461              		.loc 1 3908 0
 7462 4134 004050E2 		subs	r4, r0, #0
 7463 4138 ECFFFF1A 		bne	.L602
3909:../uvc.c      ****     {
3910:../uvc.c      ****         goto handle_fatal_error;
3911:../uvc.c      ****     }
3912:../uvc.c      **** 
3913:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
3914:../uvc.c      ****     CyU3PKernelEntry ();
 7464              		.loc 1 3914 0
 7465 413c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 7466              	.LVL615:
3915:../uvc.c      **** 
3916:../uvc.c      ****     /* Dummy return to make the compiler happy */
3917:../uvc.c      ****     return 0;
3918:../uvc.c      **** 
3919:../uvc.c      **** handle_fatal_error:
3920:../uvc.c      ****     /* Cannot recover from this error. */
3921:../uvc.c      ****     while (1);
3922:../uvc.c      **** }
 7467              		.loc 1 3922 0
 7468 4140 0400A0E1 		mov	r0, r4
 7469 4144 3CD08DE2 		add	sp, sp, #60
 7470 4148 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 7471              		.cfi_endproc
 7472              	.LFE27:
 7474              		.global	CyFxGpifTransition
 7475              		.global	CyFxGpifWavedata
 7476              		.global	CyFxGpifWavedataPosition
 7477              		.global	CyFxGpifRegValue
 7478              		.global	CyFxGpifConfig
 7479              		.global	CyFxGpifTransition_usb2
 7480              		.global	CyFxGpifWavedata_usb2
 7481              		.global	CyFxGpifWavedataPosition_usb2
 7482              		.global	CyFxGpifRegValue_usb2
 7483              		.global	CyFxGpifConfig_usb2
 7484              		.global	snapButFlag
 7485              		.global	testSnap
 7486              		.global	fb
 7487              		.global	pb
 7488              		.global	pbc
 7489              		.global	fbbak
 7490              		.global	pbbak
 7491              		.global	pbcbak
 7492              		.global	pbcpbak
 7493              		.global	isUsbConnected
 7494              		.global	usbSpeed
 7495              		.global	clearFeatureRqtReceived
 7496              		.global	streamingStarted
 7497              		.global	glProbeCtrl
 7498              		.global	glProbeCtrlFull
 7499              		.global	glProbeStilCtrl
 7500              		.global	glProbeCtrl20
 7501              		.global	glProbeStilCtrl20
 7502              		.global	glUVCHeader
 7503              		.comm	glChHandleUVCStream,220,4
 7504              		.comm	glChHandleStillStream,220,4
 7505              		.comm	glChHandleInterStat,160,4
 7506              		.comm	glInterStaBuffer,4,4
 7507              		.comm	cmdQu,32,4
 7508              		.comm	statQu,32,4
 7509              		.comm	cmdQuMux,56,4
 7510              		.comm	staQuMux,56,4
 7511              		.comm	timMux,56,4
 7512              		.comm	bmReqType,1,1
 7513              		.comm	bRequest,1,1
 7514              		.comm	wValue,2,2
 7515              		.comm	wIndex,2,2
 7516              		.comm	wLength,2,2
 7517              		.comm	posTick,4,4
 7518              		.comm	I2CCmdTimer,44,4
 7519              		.section	.rodata
 7520              		.align	2
 7521              		.set	.LANCHOR2,. + 0
 7524              	ExTime:
 7525 0000 9C       		.byte	-100
 7526 0001 00       		.byte	0
 7527 0002 4E       		.byte	78
 7528 0003 00       		.byte	0
 7529 0004 27       		.byte	39
 7530 0005 00       		.byte	0
 7531 0006 14       		.byte	20
 7532 0007 00       		.byte	0
 7533 0008 0A       		.byte	10
 7534 0009 00       		.byte	0
 7535 000a 05       		.byte	5
 7536 000b 00       		.byte	0
 7537 000c 02       		.byte	2
 7538 000d 00       		.byte	0
 7539 000e 01       		.byte	1
 7540 000f 00       		.byte	0
 7543              	CyFxGpifConfig:
 7544 0010 0F00     		.short	15
 7545 0012 0000     		.space	2
 7546 0014 00000000 		.word	CyFxGpifWavedata
 7547 0018 00000000 		.word	CyFxGpifWavedataPosition
 7548 001c 0500     		.short	5
 7549 001e 0000     		.space	2
 7550 0020 00000000 		.word	CyFxGpifTransition
 7551 0024 4C00     		.short	76
 7552 0026 0000     		.space	2
 7553 0028 00000000 		.word	CyFxGpifRegValue
 7556              	CyFxGpifConfig_usb2:
 7557 002c 9300     		.short	147
 7558 002e 0000     		.space	2
 7559 0030 00000000 		.word	CyFxGpifWavedata_usb2
 7560 0034 00000000 		.word	CyFxGpifWavedataPosition_usb2
 7561 0038 0800     		.short	8
 7562 003a 0000     		.space	2
 7563 003c 00000000 		.word	CyFxGpifTransition_usb2
 7564 0040 4C00     		.short	76
 7565 0042 0000     		.space	2
 7566 0044 00000000 		.word	CyFxGpifRegValue_usb2
 7567              		.data
 7568              		.align	2
 7569              		.set	.LANCHOR1,. + 0
 7572              	ExUCtrlParArry:
 7573 0000 13       		.byte	19
 7574 0001 14       		.byte	20
 7575 0002 02       		.byte	2
 7576 0003 01       		.byte	1
 7577 0004 00       		.byte	0
 7578 0005 03       		.byte	3
 7579 0006 00       		.byte	0
 7580 0007 01       		.byte	1
 7581 0008 00       		.byte	0
 7582 0009 03       		.byte	3
 7583 000a 00       		.byte	0
 7584 000b 23       		.byte	35
 7585 000c 37       		.byte	55
 7586 000d 23       		.byte	35
 7587 000e 37       		.byte	55
 7588 000f 30       		.byte	48
 7589 0010 01       		.byte	1
 7590 0011 00       		.byte	0
 7591 0012 00       		.byte	0
 7592 0013 00000000 		.space	5
 7592      00
 7593 0018 11       		.byte	17
 7594 0019 00       		.byte	0
 7595 001a 02       		.byte	2
 7596 001b 01       		.byte	1
 7597 001c 00       		.byte	0
 7598 001d 03       		.byte	3
 7599 001e 00       		.byte	0
 7600 001f 01       		.byte	1
 7601 0020 00       		.byte	0
 7602 0021 03       		.byte	3
 7603 0022 00       		.byte	0
 7604 0023 01       		.byte	1
 7605 0024 00       		.byte	0
 7606 0025 01       		.byte	1
 7607 0026 00       		.byte	0
 7608 0027 30       		.byte	48
 7609 0028 01       		.byte	1
 7610 0029 01       		.byte	1
 7611 002a 00       		.byte	0
 7612 002b 00000000 		.space	5
 7612      00
 7613 0030 17       		.byte	23
 7614 0031 00       		.byte	0
 7615 0032 01       		.byte	1
 7616 0033 01       		.byte	1
 7617 0034 00       		.byte	0
 7618 0035 02       		.byte	2
 7619 0036 00       		.byte	0
 7620 0037 01       		.byte	1
 7621 0038 00       		.byte	0
 7622 0039 03       		.byte	3
 7623 003a 00       		.byte	0
 7624 003b 00       		.byte	0
 7625 003c 00       		.byte	0
 7626 003d 00       		.byte	0
 7627 003e 00       		.byte	0
 7628 003f 30       		.byte	48
 7629 0040 01       		.byte	1
 7630 0041 01       		.byte	1
 7631 0042 00       		.byte	0
 7632 0043 00000000 		.space	5
 7632      00
 7633 0048 00       		.byte	0
 7634 0049 00       		.byte	0
 7635 004a 04       		.byte	4
 7636 004b 01       		.byte	1
 7637 004c 00       		.byte	0
 7638 004d 38       		.byte	56
 7639 004e 01       		.byte	1
 7640 004f 01       		.byte	1
 7641 0050 00       		.byte	0
 7642 0051 03       		.byte	3
 7643 0052 00       		.byte	0
 7644 0053 4E       		.byte	78
 7645 0054 00       		.byte	0
 7646 0055 4E       		.byte	78
 7647 0056 00       		.byte	0
 7648 0057 30       		.byte	48
 7649 0058 01       		.byte	1
 7650 0059 00       		.byte	0
 7651 005a 00       		.byte	0
 7652 005b 00000000 		.space	5
 7652      00
 7653 0060 00       		.byte	0
 7654 0061 00       		.byte	0
 7655 0062 01       		.byte	1
 7656 0063 00       		.byte	0
 7657 0064 00       		.byte	0
 7658 0065 00       		.byte	0
 7659 0066 00       		.byte	0
 7660 0067 01       		.byte	1
 7661 0068 00       		.byte	0
 7662 0069 03       		.byte	3
 7663 006a 00       		.byte	0
 7664 006b 00       		.byte	0
 7665 006c 00       		.byte	0
 7666 006d 00       		.byte	0
 7667 006e 00       		.byte	0
 7668 006f 30       		.byte	48
 7669 0070 01       		.byte	1
 7670 0071 00       		.byte	0
 7671 0072 00       		.byte	0
 7672 0073 00000000 		.space	5
 7672      00
 7673 0078 00       		.byte	0
 7674 0079 00       		.byte	0
 7675 007a 02       		.byte	2
 7676 007b 00       		.byte	0
 7677 007c 00       		.byte	0
 7678 007d FF       		.byte	-1
 7679 007e 00       		.byte	0
 7680 007f 01       		.byte	1
 7681 0080 00       		.byte	0
 7682 0081 03       		.byte	3
 7683 0082 00       		.byte	0
 7684 0083 01       		.byte	1
 7685 0084 00       		.byte	0
 7686 0085 00       		.byte	0
 7687 0086 00       		.byte	0
 7688 0087 30       		.byte	48
 7689 0088 01       		.byte	1
 7690 0089 01       		.byte	1
 7691 008a 00       		.byte	0
 7692 008b 00000000 		.space	5
 7692      00
 7693 0090 00       		.byte	0
 7694 0091 00       		.byte	0
 7695 0092 02       		.byte	2
 7696 0093 00       		.byte	0
 7697 0094 00       		.byte	0
 7698 0095 00       		.byte	0
 7699 0096 00       		.byte	0
 7700 0097 00       		.byte	0
 7701 0098 00       		.byte	0
 7702 0099 03       		.byte	3
 7703 009a 00       		.byte	0
 7704 009b 00       		.byte	0
 7705 009c 00       		.byte	0
 7706 009d 00       		.byte	0
 7707 009e 00       		.byte	0
 7708 009f 30       		.byte	48
 7709 00a0 01       		.byte	1
 7710 00a1 01       		.byte	1
 7711 00a2 00       		.byte	0
 7712 00a3 00000000 		.space	5
 7712      00
 7713 00a8 00       		.byte	0
 7714 00a9 00       		.byte	0
 7715 00aa 02       		.byte	2
 7716 00ab 00       		.byte	0
 7717 00ac 00       		.byte	0
 7718 00ad 30       		.byte	48
 7719 00ae 00       		.byte	0
 7720 00af 01       		.byte	1
 7721 00b0 00       		.byte	0
 7722 00b1 03       		.byte	3
 7723 00b2 0A       		.byte	10
 7724 00b3 00       		.byte	0
 7725 00b4 00       		.byte	0
 7726 00b5 0A       		.byte	10
 7727 00b6 00       		.byte	0
 7728 00b7 30       		.byte	48
 7729 00b8 01       		.byte	1
 7730 00b9 01       		.byte	1
 7731 00ba 00       		.byte	0
 7732 00bb 00000000 		.space	5
 7732      00
 7733 00c0 00       		.byte	0
 7734 00c1 00       		.byte	0
 7735 00c2 01       		.byte	1
 7736 00c3 00       		.byte	0
 7737 00c4 00       		.byte	0
 7738 00c5 7F       		.byte	127
 7739 00c6 00       		.byte	0
 7740 00c7 01       		.byte	1
 7741 00c8 00       		.byte	0
 7742 00c9 03       		.byte	3
 7743 00ca 00       		.byte	0
 7744 00cb 00       		.byte	0
 7745 00cc 00       		.byte	0
 7746 00cd 00       		.byte	0
 7747 00ce 00       		.byte	0
 7748 00cf 30       		.byte	48
 7749 00d0 01       		.byte	1
 7750 00d1 00       		.byte	0
 7751 00d2 00       		.byte	0
 7752 00d3 00000000 		.space	5
 7752      00
 7753 00d8 00       		.byte	0
 7754 00d9 00       		.byte	0
 7755 00da 02       		.byte	2
 7756 00db 00       		.byte	0
 7757 00dc 00       		.byte	0
 7758 00dd 05       		.byte	5
 7759 00de 00       		.byte	0
 7760 00df 01       		.byte	1
 7761 00e0 00       		.byte	0
 7762 00e1 03       		.byte	3
 7763 00e2 00       		.byte	0
 7764 00e3 00       		.byte	0
 7765 00e4 00       		.byte	0
 7766 00e5 00       		.byte	0
 7767 00e6 00       		.byte	0
 7768 00e7 30       		.byte	48
 7769 00e8 01       		.byte	1
 7770 00e9 00       		.byte	0
 7771 00ea 00       		.byte	0
 7772 00eb 00000000 		.space	5
 7772      00
 7773 00f0 00       		.byte	0
 7774 00f1 00       		.byte	0
 7775 00f2 03       		.byte	3
 7776 00f3 00       		.byte	0
 7777 00f4 00       		.byte	0
 7778 00f5 0A       		.byte	10
 7779 00f6 00       		.byte	0
 7780 00f7 01       		.byte	1
 7781 00f8 00       		.byte	0
 7782 00f9 03       		.byte	3
 7783 00fa 00       		.byte	0
 7784 00fb 00       		.byte	0
 7785 00fc 00       		.byte	0
 7786 00fd 00       		.byte	0
 7787 00fe 00       		.byte	0
 7788 00ff 30       		.byte	48
 7789 0100 01       		.byte	1
 7790 0101 00       		.byte	0
 7791 0102 00       		.byte	0
 7792 0103 00000000 		.space	5
 7792      00
 7793 0108 00       		.byte	0
 7794 0109 00       		.byte	0
 7795 010a 02       		.byte	2
 7796 010b 00       		.byte	0
 7797 010c 00       		.byte	0
 7798 010d 40       		.byte	64
 7799 010e 00       		.byte	0
 7800 010f 01       		.byte	1
 7801 0110 00       		.byte	0
 7802 0111 03       		.byte	3
 7803 0112 00       		.byte	0
 7804 0113 0F       		.byte	15
 7805 0114 11       		.byte	17
 7806 0115 00       		.byte	0
 7807 0116 00       		.byte	0
 7808 0117 30       		.byte	48
 7809 0118 01       		.byte	1
 7810 0119 00       		.byte	0
 7811 011a 00       		.byte	0
 7812 011b 00000000 		.space	5
 7812      00
 7813 0120 00       		.byte	0
 7814 0121 00       		.byte	0
 7815 0122 02       		.byte	2
 7816 0123 00       		.byte	0
 7817 0124 00       		.byte	0
 7818 0125 64       		.byte	100
 7819 0126 00       		.byte	0
 7820 0127 01       		.byte	1
 7821 0128 00       		.byte	0
 7822 0129 03       		.byte	3
 7823 012a 00       		.byte	0
 7824 012b 00       		.byte	0
 7825 012c 00       		.byte	0
 7826 012d 00       		.byte	0
 7827 012e 00       		.byte	0
 7828 012f 30       		.byte	48
 7829 0130 01       		.byte	1
 7830 0131 00       		.byte	0
 7831 0132 00       		.byte	0
 7832 0133 00000000 		.space	5
 7832      00
 7833 0138 00       		.byte	0
 7834 0139 00       		.byte	0
 7835 013a 02       		.byte	2
 7836 013b 00       		.byte	0
 7837 013c 00       		.byte	0
 7838 013d 64       		.byte	100
 7839 013e 00       		.byte	0
 7840 013f 01       		.byte	1
 7841 0140 00       		.byte	0
 7842 0141 03       		.byte	3
 7843 0142 00       		.byte	0
 7844 0143 00       		.byte	0
 7845 0144 00       		.byte	0
 7846 0145 00       		.byte	0
 7847 0146 00       		.byte	0
 7848 0147 30       		.byte	48
 7849 0148 01       		.byte	1
 7850 0149 00       		.byte	0
 7851 014a 00       		.byte	0
 7852 014b 00000000 		.space	5
 7852      00
 7853 0150 00       		.byte	0
 7854 0151 00       		.byte	0
 7855 0152 02       		.byte	2
 7856 0153 00       		.byte	0
 7857 0154 00       		.byte	0
 7858 0155 64       		.byte	100
 7859 0156 00       		.byte	0
 7860 0157 01       		.byte	1
 7861 0158 00       		.byte	0
 7862 0159 03       		.byte	3
 7863 015a 00       		.byte	0
 7864 015b 00       		.byte	0
 7865 015c 00       		.byte	0
 7866 015d 00       		.byte	0
 7867 015e 00       		.byte	0
 7868 015f 30       		.byte	48
 7869 0160 01       		.byte	1
 7870 0161 00       		.byte	0
 7871 0162 00       		.byte	0
 7872 0163 00000000 		.space	5
 7872      00
 7873 0168 00       		.byte	0
 7874 0169 00       		.byte	0
 7875 016a 02       		.byte	2
 7876 016b 00       		.byte	0
 7877 016c 00       		.byte	0
 7878 016d 64       		.byte	100
 7879 016e 00       		.byte	0
 7880 016f 01       		.byte	1
 7881 0170 00       		.byte	0
 7882 0171 03       		.byte	3
 7883 0172 00       		.byte	0
 7884 0173 00       		.byte	0
 7885 0174 00       		.byte	0
 7886 0175 00       		.byte	0
 7887 0176 00       		.byte	0
 7888 0177 30       		.byte	48
 7889 0178 01       		.byte	1
 7890 0179 00       		.byte	0
 7891 017a 00       		.byte	0
 7892 017b 00000000 		.space	5
 7892      00
 7895              	CtrlParArry:
 7896 0180 10       		.byte	16
 7897 0181 10       		.byte	16
 7898 0182 02       		.byte	2
 7899 0183 00       		.byte	0
 7900 0184 00       		.byte	0
 7901 0185 03       		.byte	3
 7902 0186 00       		.byte	0
 7903 0187 01       		.byte	1
 7904 0188 00       		.byte	0
 7905 0189 03       		.byte	3
 7906 018a 00       		.byte	0
 7907 018b 03       		.byte	3
 7908 018c 00       		.byte	0
 7909 018d 03       		.byte	3
 7910 018e 00       		.byte	0
 7911 018f 30       		.byte	48
 7912 0190 01       		.byte	1
 7913 0191 00       		.byte	0
 7914 0192 00       		.byte	0
 7915 0193 00000000 		.space	5
 7915      00
 7916 0198 15       		.byte	21
 7917 0199 15       		.byte	21
 7918 019a 02       		.byte	2
 7919 019b 00       		.byte	0
 7920 019c 00       		.byte	0
 7921 019d FF       		.byte	-1
 7922 019e 00       		.byte	0
 7923 019f 01       		.byte	1
 7924 01a0 00       		.byte	0
 7925 01a1 03       		.byte	3
 7926 01a2 00       		.byte	0
 7927 01a3 76       		.byte	118
 7928 01a4 00       		.byte	0
 7929 01a5 76       		.byte	118
 7930 01a6 C7       		.byte	-57
 7931 01a7 30       		.byte	48
 7932 01a8 01       		.byte	1
 7933 01a9 01       		.byte	1
 7934 01aa 00       		.byte	0
 7935 01ab 00000000 		.space	5
 7935      00
 7936 01b0 02       		.byte	2
 7937 01b1 02       		.byte	2
 7938 01b2 02       		.byte	2
 7939 01b3 00       		.byte	0
 7940 01b4 00       		.byte	0
 7941 01b5 FF       		.byte	-1
 7942 01b6 00       		.byte	0
 7943 01b7 01       		.byte	1
 7944 01b8 00       		.byte	0
 7945 01b9 03       		.byte	3
 7946 01ba 00       		.byte	0
 7947 01bb 70       		.byte	112
 7948 01bc 00       		.byte	0
 7949 01bd 70       		.byte	112
 7950 01be 00       		.byte	0
 7951 01bf C6       		.byte	-58
 7952 01c0 01       		.byte	1
 7953 01c1 01       		.byte	1
 7954 01c2 00       		.byte	0
 7955 01c3 00000000 		.space	5
 7955      00
 7956 01c8 00       		.byte	0
 7957 01c9 00       		.byte	0
 7958 01ca 02       		.byte	2
 7959 01cb 00       		.byte	0
 7960 01cc 00       		.byte	0
 7961 01cd 64       		.byte	100
 7962 01ce 00       		.byte	0
 7963 01cf 01       		.byte	1
 7964 01d0 00       		.byte	0
 7965 01d1 03       		.byte	3
 7966 01d2 00       		.byte	0
 7967 01d3 00       		.byte	0
 7968 01d4 00       		.byte	0
 7969 01d5 00       		.byte	0
 7970 01d6 00       		.byte	0
 7971 01d7 30       		.byte	48
 7972 01d8 01       		.byte	1
 7973 01d9 00       		.byte	0
 7974 01da 00       		.byte	0
 7975 01db 00000000 		.space	5
 7975      00
 7976 01e0 07       		.byte	7
 7977 01e1 07       		.byte	7
 7978 01e2 02       		.byte	2
 7979 01e3 00       		.byte	0
 7980 01e4 00       		.byte	0
 7981 01e5 01       		.byte	1
 7982 01e6 00       		.byte	0
 7983 01e7 01       		.byte	1
 7984 01e8 00       		.byte	0
 7985 01e9 03       		.byte	3
 7986 01ea 00       		.byte	0
 7987 01eb 01       		.byte	1
 7988 01ec 00       		.byte	0
 7989 01ed 01       		.byte	1
 7990 01ee 00       		.byte	0
 7991 01ef 30       		.byte	48
 7992 01f0 01       		.byte	1
 7993 01f1 00       		.byte	0
 7994 01f2 00       		.byte	0
 7995 01f3 00000000 		.space	5
 7995      00
 7996 01f8 DF       		.byte	-33
 7997 01f9 E1       		.byte	-31
 7998 01fa 02       		.byte	2
 7999 01fb 00       		.byte	0
 8000 01fc 00       		.byte	0
 8001 01fd FF       		.byte	-1
 8002 01fe 00       		.byte	0
 8003 01ff 01       		.byte	1
 8004 0200 00       		.byte	0
 8005 0201 03       		.byte	3
 8006 0202 00       		.byte	0
 8007 0203 80       		.byte	-128
 8008 0204 00       		.byte	0
 8009 0205 00       		.byte	0
 8010 0206 00       		.byte	0
 8011 0207 C6       		.byte	-58
 8012 0208 01       		.byte	1
 8013 0209 01       		.byte	1
 8014 020a 00       		.byte	0
 8015 020b 00000000 		.space	5
 8015      00
 8016 0210 85       		.byte	-123
 8017 0211 86       		.byte	-122
 8018 0212 02       		.byte	2
 8019 0213 00       		.byte	0
 8020 0214 00       		.byte	0
 8021 0215 64       		.byte	100
 8022 0216 00       		.byte	0
 8023 0217 01       		.byte	1
 8024 0218 00       		.byte	0
 8025 0219 03       		.byte	3
 8026 021a 00       		.byte	0
 8027 021b 32       		.byte	50
 8028 021c 00       		.byte	0
 8029 021d 32       		.byte	50
 8030 021e 00       		.byte	0
 8031 021f F2       		.byte	-14
 8032 0220 01       		.byte	1
 8033 0221 01       		.byte	1
 8034 0222 00       		.byte	0
 8035 0223 00000000 		.space	5
 8035      00
 8036 0228 06       		.byte	6
 8037 0229 06       		.byte	6
 8038 022a 02       		.byte	2
 8039 022b 00       		.byte	0
 8040 022c 00       		.byte	0
 8041 022d 40       		.byte	64
 8042 022e 00       		.byte	0
 8043 022f 01       		.byte	1
 8044 0230 00       		.byte	0
 8045 0231 03       		.byte	3
 8046 0232 00       		.byte	0
 8047 0233 20       		.byte	32
 8048 0234 00       		.byte	0
 8049 0235 20       		.byte	32
 8050 0236 00       		.byte	0
 8051 0237 30       		.byte	48
 8052 0238 01       		.byte	1
 8053 0239 01       		.byte	1
 8054 023a 00       		.byte	0
 8055 023b 00000000 		.space	5
 8055      00
 8056 0240 00       		.byte	0
 8057 0241 00       		.byte	0
 8058 0242 02       		.byte	2
 8059 0243 00       		.byte	0
 8060 0244 00       		.byte	0
 8061 0245 64       		.byte	100
 8062 0246 00       		.byte	0
 8063 0247 01       		.byte	1
 8064 0248 00       		.byte	0
 8065 0249 03       		.byte	3
 8066 024a 00       		.byte	0
 8067 024b 00       		.byte	0
 8068 024c 00       		.byte	0
 8069 024d 00       		.byte	0
 8070 024e 00       		.byte	0
 8071 024f 30       		.byte	48
 8072 0250 01       		.byte	1
 8073 0251 00       		.byte	0
 8074 0252 00       		.byte	0
 8075 0253 00000000 		.space	5
 8075      00
 8076 0258 08       		.byte	8
 8077 0259 08       		.byte	8
 8078 025a 02       		.byte	2
 8079 025b 00       		.byte	0
 8080 025c 00       		.byte	0
 8081 025d 05       		.byte	5
 8082 025e 00       		.byte	0
 8083 025f 01       		.byte	1
 8084 0260 00       		.byte	0
 8085 0261 03       		.byte	3
 8086 0262 00       		.byte	0
 8087 0263 00       		.byte	0
 8088 0264 00       		.byte	0
 8089 0265 00       		.byte	0
 8090 0266 00       		.byte	0
 8091 0267 30       		.byte	48
 8092 0268 01       		.byte	1
 8093 0269 00       		.byte	0
 8094 026a 00       		.byte	0
 8095 026b 00000000 		.space	5
 8095      00
 8096 0270 00       		.byte	0
 8097 0271 00       		.byte	0
 8098 0272 02       		.byte	2
 8099 0273 00       		.byte	0
 8100 0274 00       		.byte	0
 8101 0275 40       		.byte	64
 8102 0276 00       		.byte	0
 8103 0277 01       		.byte	1
 8104 0278 00       		.byte	0
 8105 0279 03       		.byte	3
 8106 027a 00       		.byte	0
 8107 027b 00       		.byte	0
 8108 027c 00       		.byte	0
 8109 027d 00       		.byte	0
 8110 027e 00       		.byte	0
 8111 027f 30       		.byte	48
 8112 0280 01       		.byte	1
 8113 0281 00       		.byte	0
 8114 0282 00       		.byte	0
 8115 0283 00000000 		.space	5
 8115      00
 8116 0288 09       		.byte	9
 8117 0289 0A       		.byte	10
 8118 028a 04       		.byte	4
 8119 028b 00       		.byte	0
 8120 028c 00       		.byte	0
 8121 028d 40       		.byte	64
 8122 028e 00       		.byte	0
 8123 028f 01       		.byte	1
 8124 0290 00       		.byte	0
 8125 0291 03       		.byte	3
 8126 0292 00       		.byte	0
 8127 0293 20       		.byte	32
 8128 0294 38       		.byte	56
 8129 0295 20       		.byte	32
 8130 0296 38       		.byte	56
 8131 0297 30       		.byte	48
 8132 0298 01       		.byte	1
 8133 0299 00       		.byte	0
 8134 029a 00       		.byte	0
 8135 029b 00000000 		.space	5
 8135      00
 8136 02a0 00       		.byte	0
 8137 02a1 00       		.byte	0
 8138 02a2 02       		.byte	2
 8139 02a3 00       		.byte	0
 8140 02a4 00       		.byte	0
 8141 02a5 64       		.byte	100
 8142 02a6 00       		.byte	0
 8143 02a7 01       		.byte	1
 8144 02a8 00       		.byte	0
 8145 02a9 03       		.byte	3
 8146 02aa 00       		.byte	0
 8147 02ab 00       		.byte	0
 8148 02ac 00       		.byte	0
 8149 02ad 00       		.byte	0
 8150 02ae 00       		.byte	0
 8151 02af 30       		.byte	48
 8152 02b0 01       		.byte	1
 8153 02b1 00       		.byte	0
 8154 02b2 00       		.byte	0
 8155 02b3 00000000 		.space	5
 8155      00
 8156 02b8 00       		.byte	0
 8157 02b9 00       		.byte	0
 8158 02ba 02       		.byte	2
 8159 02bb 00       		.byte	0
 8160 02bc 00       		.byte	0
 8161 02bd 64       		.byte	100
 8162 02be 00       		.byte	0
 8163 02bf 01       		.byte	1
 8164 02c0 00       		.byte	0
 8165 02c1 03       		.byte	3
 8166 02c2 00       		.byte	0
 8167 02c3 00       		.byte	0
 8168 02c4 00       		.byte	0
 8169 02c5 00       		.byte	0
 8170 02c6 00       		.byte	0
 8171 02c7 30       		.byte	48
 8172 02c8 01       		.byte	1
 8173 02c9 00       		.byte	0
 8174 02ca 00       		.byte	0
 8175 02cb 00000000 		.space	5
 8175      00
 8176 02d0 2A       		.byte	42
 8177 02d1 2A       		.byte	42
 8178 02d2 02       		.byte	2
 8179 02d3 00       		.byte	0
 8180 02d4 00       		.byte	0
 8181 02d5 1B       		.byte	27
 8182 02d6 00       		.byte	0
 8183 02d7 01       		.byte	1
 8184 02d8 00       		.byte	0
 8185 02d9 03       		.byte	3
 8186 02da 00       		.byte	0
 8187 02db 00       		.byte	0
 8188 02dc 00       		.byte	0
 8189 02dd 00       		.byte	0
 8190 02de 00       		.byte	0
 8191 02df 30       		.byte	48
 8192 02e0 01       		.byte	1
 8193 02e1 00       		.byte	0
 8194 02e2 00       		.byte	0
 8195 02e3 00000000 		.space	5
 8195      00
 8196 02e8 00       		.byte	0
 8197 02e9 00       		.byte	0
 8198 02ea 02       		.byte	2
 8199 02eb 00       		.byte	0
 8200 02ec 00       		.byte	0
 8201 02ed 64       		.byte	100
 8202 02ee 00       		.byte	0
 8203 02ef 01       		.byte	1
 8204 02f0 00       		.byte	0
 8205 02f1 03       		.byte	3
 8206 02f2 00       		.byte	0
 8207 02f3 00       		.byte	0
 8208 02f4 00       		.byte	0
 8209 02f5 00       		.byte	0
 8210 02f6 00       		.byte	0
 8211 02f7 30       		.byte	48
 8212 02f8 01       		.byte	1
 8213 02f9 00       		.byte	0
 8214 02fa 00       		.byte	0
 8215 02fb 00000000 		.space	5
 8215      00
 8216 0300 00       		.byte	0
 8217 0301 00       		.byte	0
 8218 0302 02       		.byte	2
 8219 0303 00       		.byte	0
 8220 0304 00       		.byte	0
 8221 0305 12       		.byte	18
 8222 0306 00       		.byte	0
 8223 0307 01       		.byte	1
 8224 0308 00       		.byte	0
 8225 0309 03       		.byte	3
 8226 030a 00       		.byte	0
 8227 030b 00       		.byte	0
 8228 030c 00       		.byte	0
 8229 030d 00       		.byte	0
 8230 030e 00       		.byte	0
 8231 030f 30       		.byte	48
 8232 0310 01       		.byte	1
 8233 0311 00       		.byte	0
 8234 0312 00       		.byte	0
 8235 0313 00000000 		.space	5
 8235      00
 8236 0318 01       		.byte	1
 8237 0319 01       		.byte	1
 8238 031a 02       		.byte	2
 8239 031b 00       		.byte	0
 8240 031c 00       		.byte	0
 8241 031d 09       		.byte	9
 8242 031e 00       		.byte	0
 8243 031f 01       		.byte	1
 8244 0320 00       		.byte	0
 8245 0321 03       		.byte	3
 8246 0322 00       		.byte	0
 8247 0323 00       		.byte	0
 8248 0324 00       		.byte	0
 8249 0325 01       		.byte	1
 8250 0326 00       		.byte	0
 8251 0327 30       		.byte	48
 8252 0328 01       		.byte	1
 8253 0329 00       		.byte	0
 8254 032a 00       		.byte	0
 8255 032b 00000000 		.space	5
 8255      00
 8256 0330 05       		.byte	5
 8257 0331 05       		.byte	5
 8258 0332 02       		.byte	2
 8259 0333 00       		.byte	0
 8260 0334 00       		.byte	0
 8261 0335 03       		.byte	3
 8262 0336 00       		.byte	0
 8263 0337 01       		.byte	1
 8264 0338 00       		.byte	0
 8265 0339 03       		.byte	3
 8266 033a 00       		.byte	0
 8267 033b 00       		.byte	0
 8268 033c 00       		.byte	0
 8269 033d 02       		.byte	2
 8270 033e 00       		.byte	0
 8271 033f 30       		.byte	48
 8272 0340 01       		.byte	1
 8273 0341 00       		.byte	0
 8274 0342 00       		.byte	0
 8275 0343 00000000 		.space	5
 8275      00
 8276 0348 18       		.byte	24
 8277 0349 18       		.byte	24
 8278 034a 02       		.byte	2
 8279 034b 00       		.byte	0
 8280 034c 00       		.byte	0
 8281 034d 01       		.byte	1
 8282 034e 00       		.byte	0
 8283 034f 01       		.byte	1
 8284 0350 00       		.byte	0
 8285 0351 03       		.byte	3
 8286 0352 00       		.byte	0
 8287 0353 00       		.byte	0
 8288 0354 00       		.byte	0
 8289 0355 00       		.byte	0
 8290 0356 00       		.byte	0
 8291 0357 30       		.byte	48
 8292 0358 01       		.byte	1
 8293 0359 00       		.byte	0
 8294 035a 00       		.byte	0
 8295 035b 00000000 		.space	5
 8295      00
 8296 0360 19       		.byte	25
 8297 0361 19       		.byte	25
 8298 0362 01       		.byte	1
 8299 0363 00       		.byte	0
 8300 0364 00       		.byte	0
 8301 0365 40       		.byte	64
 8302 0366 00       		.byte	0
 8303 0367 01       		.byte	1
 8304 0368 00       		.byte	0
 8305 0369 03       		.byte	3
 8306 036a 00       		.byte	0
 8307 036b 20       		.byte	32
 8308 036c 00       		.byte	0
 8309 036d 20       		.byte	32
 8310 036e 00       		.byte	0
 8311 036f 30       		.byte	48
 8312 0370 01       		.byte	1
 8313 0371 00       		.byte	0
 8314 0372 00       		.byte	0
 8315 0373 00000000 		.space	5
 8315      00
 8316 0378 20       		.byte	32
 8317 0379 20       		.byte	32
 8318 037a 02       		.byte	2
 8319 037b 00       		.byte	0
 8320 037c 00       		.byte	0
 8321 037d 02       		.byte	2
 8322 037e 00       		.byte	0
 8323 037f 01       		.byte	1
 8324 0380 00       		.byte	0
 8325 0381 03       		.byte	3
 8326 0382 00       		.byte	0
 8327 0383 00       		.byte	0
 8328 0384 00       		.byte	0
 8329 0385 00       		.byte	0
 8330 0386 00       		.byte	0
 8331 0387 30       		.byte	48
 8332 0388 01       		.byte	1
 8333 0389 00       		.byte	0
 8334 038a 00       		.byte	0
 8335 038b 00000000 		.space	5
 8335      00
 8336 0390 22       		.byte	34
 8337 0391 22       		.byte	34
 8338 0392 02       		.byte	2
 8339 0393 00       		.byte	0
 8340 0394 00       		.byte	0
 8341 0395 3F       		.byte	63
 8342 0396 00       		.byte	0
 8343 0397 01       		.byte	1
 8344 0398 00       		.byte	0
 8345 0399 03       		.byte	3
 8346 039a 00       		.byte	0
 8347 039b 00       		.byte	0
 8348 039c 00       		.byte	0
 8349 039d 00       		.byte	0
 8350 039e 00       		.byte	0
 8351 039f 30       		.byte	48
 8352 03a0 01       		.byte	1
 8353 03a1 00       		.byte	0
 8354 03a2 00       		.byte	0
 8355 03a3 00000000 		.space	5
 8355      00
 8356 03a8 23       		.byte	35
 8357 03a9 23       		.byte	35
 8358 03aa 02       		.byte	2
 8359 03ab 00       		.byte	0
 8360 03ac 00       		.byte	0
 8361 03ad 64       		.byte	100
 8362 03ae 00       		.byte	0
 8363 03af 01       		.byte	1
 8364 03b0 00       		.byte	0
 8365 03b1 03       		.byte	3
 8366 03b2 00       		.byte	0
 8367 03b3 10       		.byte	16
 8368 03b4 00       		.byte	0
 8369 03b5 10       		.byte	16
 8370 03b6 00       		.byte	0
 8371 03b7 30       		.byte	48
 8372 03b8 01       		.byte	1
 8373 03b9 00       		.byte	0
 8374 03ba 00       		.byte	0
 8375 03bb 00000000 		.space	5
 8375      00
 8376 03c0 24       		.byte	36
 8377 03c1 24       		.byte	36
 8378 03c2 02       		.byte	2
 8379 03c3 00       		.byte	0
 8380 03c4 00       		.byte	0
 8381 03c5 64       		.byte	100
 8382 03c6 00       		.byte	0
 8383 03c7 01       		.byte	1
 8384 03c8 00       		.byte	0
 8385 03c9 03       		.byte	3
 8386 03ca 00       		.byte	0
 8387 03cb 10       		.byte	16
 8388 03cc 00       		.byte	0
 8389 03cd 10       		.byte	16
 8390 03ce 00       		.byte	0
 8391 03cf 30       		.byte	48
 8392 03d0 01       		.byte	1
 8393 03d1 00       		.byte	0
 8394 03d2 00       		.byte	0
 8395 03d3 00000000 		.space	5
 8395      00
 8396 03d8 02       		.byte	2
 8397 03d9 03       		.byte	3
 8398 03da 04       		.byte	4
 8399 03db 00       		.byte	0
 8400 03dc 00       		.byte	0
 8401 03dd 7F       		.byte	127
 8402 03de 00       		.byte	0
 8403 03df 01       		.byte	1
 8404 03e0 00       		.byte	0
 8405 03e1 03       		.byte	3
 8406 03e2 00       		.byte	0
 8407 03e3 00       		.byte	0
 8408 03e4 20       		.byte	32
 8409 03e5 00       		.byte	0
 8410 03e6 20       		.byte	32
 8411 03e7 30       		.byte	48
 8412 03e8 01       		.byte	1
 8413 03e9 00       		.byte	0
 8414 03ea 00       		.byte	0
 8415 03eb 00000000 		.space	5
 8415      00
 8416 03f0 04       		.byte	4
 8417 03f1 04       		.byte	4
 8418 03f2 02       		.byte	2
 8419 03f3 00       		.byte	0
 8420 03f4 00       		.byte	0
 8421 03f5 40       		.byte	64
 8422 03f6 00       		.byte	0
 8423 03f7 01       		.byte	1
 8424 03f8 00       		.byte	0
 8425 03f9 03       		.byte	3
 8426 03fa 00       		.byte	0
 8427 03fb 20       		.byte	32
 8428 03fc 00       		.byte	0
 8429 03fd 20       		.byte	32
 8430 03fe 00       		.byte	0
 8431 03ff 30       		.byte	48
 8432 0400 01       		.byte	1
 8433 0401 00       		.byte	0
 8434 0402 00       		.byte	0
 8435 0403 00000000 		.space	5
 8435      00
 8436 0408 00       		.byte	0
 8437 0409 00       		.byte	0
 8438 040a 02       		.byte	2
 8439 040b 00       		.byte	0
 8440 040c 00       		.byte	0
 8441 040d 19       		.byte	25
 8442 040e 00       		.byte	0
 8443 040f 01       		.byte	1
 8444 0410 00       		.byte	0
 8445 0411 03       		.byte	3
 8446 0412 00       		.byte	0
 8447 0413 00       		.byte	0
 8448 0414 00       		.byte	0
 8449 0415 00       		.byte	0
 8450 0416 00       		.byte	0
 8451 0417 30       		.byte	48
 8452 0418 01       		.byte	1
 8453 0419 00       		.byte	0
 8454 041a 00       		.byte	0
 8455 041b 00000000 		.space	5
 8455      00
 8456 0420 10       		.byte	16
 8457 0421 10       		.byte	16
 8458 0422 02       		.byte	2
 8459 0423 00       		.byte	0
 8460 0424 00       		.byte	0
 8461 0425 06       		.byte	6
 8462 0426 00       		.byte	0
 8463 0427 01       		.byte	1
 8464 0428 00       		.byte	0
 8465 0429 03       		.byte	3
 8466 042a 00       		.byte	0
 8467 042b 03       		.byte	3
 8468 042c 00       		.byte	0
 8469 042d 03       		.byte	3
 8470 042e 00       		.byte	0
 8471 042f 30       		.byte	48
 8472 0430 01       		.byte	1
 8473 0431 00       		.byte	0
 8474 0432 00       		.byte	0
 8475 0433 00000000 		.space	5
 8475      00
 8476 0438 00       		.byte	0
 8477 0439 00       		.byte	0
 8478 043a 02       		.byte	2
 8479 043b 00       		.byte	0
 8480 043c 00       		.byte	0
 8481 043d 03       		.byte	3
 8482 043e 00       		.byte	0
 8483 043f 01       		.byte	1
 8484 0440 00       		.byte	0
 8485 0441 03       		.byte	3
 8486 0442 00       		.byte	0
 8487 0443 00       		.byte	0
 8488 0444 00       		.byte	0
 8489 0445 00       		.byte	0
 8490 0446 00       		.byte	0
 8491 0447 30       		.byte	48
 8492 0448 01       		.byte	1
 8493 0449 00       		.byte	0
 8494 044a 00       		.byte	0
 8495 044b 00000000 		.space	5
 8495      00
 8496 0450 50       		.byte	80
 8497 0451 50       		.byte	80
 8498 0452 01       		.byte	1
 8499 0453 00       		.byte	0
 8500 0454 00       		.byte	0
 8501 0455 03       		.byte	3
 8502 0456 00       		.byte	0
 8503 0457 01       		.byte	1
 8504 0458 00       		.byte	0
 8505 0459 03       		.byte	3
 8506 045a 00       		.byte	0
 8507 045b 00       		.byte	0
 8508 045c 00       		.byte	0
 8509 045d 00       		.byte	0
 8510 045e 00       		.byte	0
 8511 045f 30       		.byte	48
 8512 0460 01       		.byte	1
 8513 0461 00       		.byte	0
 8514 0462 00       		.byte	0
 8515 0463 00000000 		.space	5
 8515      00
 8516 0468 00       		.byte	0
 8517 0469 00       		.byte	0
 8518 046a 0B       		.byte	11
 8519 046b 00       		.byte	0
 8520 046c 00       		.byte	0
 8521 046d FF       		.byte	-1
 8522 046e FF       		.byte	-1
 8523 046f 01       		.byte	1
 8524 0470 00       		.byte	0
 8525 0471 03       		.byte	3
 8526 0472 00       		.byte	0
 8527 0473 00       		.byte	0
 8528 0474 00       		.byte	0
 8529 0475 00       		.byte	0
 8530 0476 00       		.byte	0
 8531 0477 00       		.byte	0
 8532 0478 01       		.byte	1
 8533 0479 00       		.byte	0
 8534 047a 00       		.byte	0
 8535 047b 00000000 		.space	5
 8535      00
 8538              	glUVCHeader:
 8539 0480 0C       		.byte	12
 8540 0481 8C       		.byte	-116
 8541 0482 00       		.byte	0
 8542 0483 00       		.byte	0
 8543 0484 00       		.byte	0
 8544 0485 00       		.byte	0
 8545 0486 00       		.byte	0
 8546 0487 00       		.byte	0
 8547 0488 00       		.byte	0
 8548 0489 00       		.byte	0
 8549 048a 00       		.byte	0
 8550 048b 00       		.byte	0
 8553              	ROIMode:
 8554 048c 01       		.byte	1
 8555 048d 000000   		.space	3
 8558              	WBMenuCmpArry:
 8559 0490 20       		.byte	32
 8560 0491 0F       		.byte	15
 8561 0492 38       		.byte	56
 8562 0493 F0       		.byte	-16
 8565              	CTCtrlParArry:
 8566 0494 00       		.byte	0
 8567 0495 00       		.byte	0
 8568 0496 01       		.byte	1
 8569 0497 00       		.byte	0
 8570 0498 00       		.byte	0
 8571 0499 03       		.byte	3
 8572 049a 00       		.byte	0
 8573 049b 01       		.byte	1
 8574 049c 00       		.byte	0
 8575 049d 03       		.byte	3
 8576 049e 00       		.byte	0
 8577 049f 03       		.byte	3
 8578 04a0 00       		.byte	0
 8579 04a1 03       		.byte	3
 8580 04a2 00       		.byte	0
 8581 04a3 30       		.byte	48
 8582 04a4 01       		.byte	1
 8583 04a5 00       		.byte	0
 8584 04a6 00       		.byte	0
 8585 04a7 00000000 		.space	5
 8585      00
 8586 04ac 00       		.byte	0
 8587 04ad 00       		.byte	0
 8588 04ae 01       		.byte	1
 8589 04af 01       		.byte	1
 8590 04b0 00       		.byte	0
 8591 04b1 0F       		.byte	15
 8592 04b2 00       		.byte	0
 8593 04b3 0F       		.byte	15
 8594 04b4 00       		.byte	0
 8595 04b5 03       		.byte	3
 8596 04b6 00       		.byte	0
 8597 04b7 02       		.byte	2
 8598 04b8 00       		.byte	0
 8599 04b9 02       		.byte	2
 8600 04ba 00       		.byte	0
 8601 04bb 30       		.byte	48
 8602 04bc 01       		.byte	1
 8603 04bd 01       		.byte	1
 8604 04be 00       		.byte	0
 8605 04bf 00000000 		.space	5
 8605      00
 8606 04c4 02       		.byte	2
 8607 04c5 00       		.byte	0
 8608 04c6 01       		.byte	1
 8609 04c7 00       		.byte	0
 8610 04c8 00       		.byte	0
 8611 04c9 01       		.byte	1
 8612 04ca 00       		.byte	0
 8613 04cb 01       		.byte	1
 8614 04cc 00       		.byte	0
 8615 04cd 03       		.byte	3
 8616 04ce 00       		.byte	0
 8617 04cf 00       		.byte	0
 8618 04d0 00       		.byte	0
 8619 04d1 00       		.byte	0
 8620 04d2 00       		.byte	0
 8621 04d3 30       		.byte	48
 8622 04d4 01       		.byte	1
 8623 04d5 01       		.byte	1
 8624 04d6 00       		.byte	0
 8625 04d7 00000000 		.space	5
 8625      00
 8626 04dc 00       		.byte	0
 8627 04dd 00       		.byte	0
 8628 04de 04       		.byte	4
 8629 04df 01       		.byte	1
 8630 04e0 00       		.byte	0
 8631 04e1 38       		.byte	56
 8632 04e2 01       		.byte	1
 8633 04e3 01       		.byte	1
 8634 04e4 00       		.byte	0
 8635 04e5 03       		.byte	3
 8636 04e6 00       		.byte	0
 8637 04e7 4E       		.byte	78
 8638 04e8 00       		.byte	0
 8639 04e9 4E       		.byte	78
 8640 04ea 00       		.byte	0
 8641 04eb 30       		.byte	48
 8642 04ec 01       		.byte	1
 8643 04ed 00       		.byte	0
 8644 04ee 00       		.byte	0
 8645 04ef 00000000 		.space	5
 8645      00
 8646 04f4 04       		.byte	4
 8647 04f5 00       		.byte	0
 8648 04f6 01       		.byte	1
 8649 04f7 00       		.byte	0
 8650 04f8 00       		.byte	0
 8651 04f9 00       		.byte	0
 8652 04fa 00       		.byte	0
 8653 04fb 01       		.byte	1
 8654 04fc 00       		.byte	0
 8655 04fd 03       		.byte	3
 8656 04fe 00       		.byte	0
 8657 04ff 00       		.byte	0
 8658 0500 00       		.byte	0
 8659 0501 00       		.byte	0
 8660 0502 00       		.byte	0
 8661 0503 30       		.byte	48
 8662 0504 01       		.byte	1
 8663 0505 00       		.byte	0
 8664 0506 00       		.byte	0
 8665 0507 00000000 		.space	5
 8665      00
 8666 050c 05       		.byte	5
 8667 050d 00       		.byte	0
 8668 050e 02       		.byte	2
 8669 050f 00       		.byte	0
 8670 0510 00       		.byte	0
 8671 0511 FF       		.byte	-1
 8672 0512 00       		.byte	0
 8673 0513 01       		.byte	1
 8674 0514 00       		.byte	0
 8675 0515 03       		.byte	3
 8676 0516 00       		.byte	0
 8677 0517 01       		.byte	1
 8678 0518 00       		.byte	0
 8679 0519 00       		.byte	0
 8680 051a 00       		.byte	0
 8681 051b 30       		.byte	48
 8682 051c 01       		.byte	1
 8683 051d 01       		.byte	1
 8684 051e 00       		.byte	0
 8685 051f 00000000 		.space	5
 8685      00
 8686 0524 06       		.byte	6
 8687 0525 00       		.byte	0
 8688 0526 02       		.byte	2
 8689 0527 00       		.byte	0
 8690 0528 00       		.byte	0
 8691 0529 00       		.byte	0
 8692 052a 00       		.byte	0
 8693 052b 00       		.byte	0
 8694 052c 00       		.byte	0
 8695 052d 03       		.byte	3
 8696 052e 00       		.byte	0
 8697 052f 00       		.byte	0
 8698 0530 00       		.byte	0
 8699 0531 00       		.byte	0
 8700 0532 00       		.byte	0
 8701 0533 30       		.byte	48
 8702 0534 01       		.byte	1
 8703 0535 01       		.byte	1
 8704 0536 00       		.byte	0
 8705 0537 00000000 		.space	5
 8705      00
 8706 053c 23       		.byte	35
 8707 053d 00       		.byte	0
 8708 053e 02       		.byte	2
 8709 053f 00       		.byte	0
 8710 0540 00       		.byte	0
 8711 0541 30       		.byte	48
 8712 0542 00       		.byte	0
 8713 0543 01       		.byte	1
 8714 0544 00       		.byte	0
 8715 0545 03       		.byte	3
 8716 0546 0A       		.byte	10
 8717 0547 00       		.byte	0
 8718 0548 00       		.byte	0
 8719 0549 0A       		.byte	10
 8720 054a 00       		.byte	0
 8721 054b 30       		.byte	48
 8722 054c 01       		.byte	1
 8723 054d 01       		.byte	1
 8724 054e 00       		.byte	0
 8725 054f 00000000 		.space	5
 8725      00
 8726 0554 08       		.byte	8
 8727 0555 00       		.byte	0
 8728 0556 01       		.byte	1
 8729 0557 00       		.byte	0
 8730 0558 00       		.byte	0
 8731 0559 7F       		.byte	127
 8732 055a 00       		.byte	0
 8733 055b 01       		.byte	1
 8734 055c 00       		.byte	0
 8735 055d 03       		.byte	3
 8736 055e 00       		.byte	0
 8737 055f 00       		.byte	0
 8738 0560 00       		.byte	0
 8739 0561 00       		.byte	0
 8740 0562 00       		.byte	0
 8741 0563 30       		.byte	48
 8742 0564 01       		.byte	1
 8743 0565 00       		.byte	0
 8744 0566 00       		.byte	0
 8745 0567 00000000 		.space	5
 8745      00
 8746 056c 09       		.byte	9
 8747 056d 00       		.byte	0
 8748 056e 02       		.byte	2
 8749 056f 00       		.byte	0
 8750 0570 00       		.byte	0
 8751 0571 05       		.byte	5
 8752 0572 00       		.byte	0
 8753 0573 01       		.byte	1
 8754 0574 00       		.byte	0
 8755 0575 03       		.byte	3
 8756 0576 00       		.byte	0
 8757 0577 00       		.byte	0
 8758 0578 00       		.byte	0
 8759 0579 00       		.byte	0
 8760 057a 00       		.byte	0
 8761 057b 30       		.byte	48
 8762 057c 01       		.byte	1
 8763 057d 00       		.byte	0
 8764 057e 00       		.byte	0
 8765 057f 00000000 		.space	5
 8765      00
 8766 0584 10       		.byte	16
 8767 0585 00       		.byte	0
 8768 0586 03       		.byte	3
 8769 0587 00       		.byte	0
 8770 0588 00       		.byte	0
 8771 0589 00       		.byte	0
 8772 058a 00       		.byte	0
 8773 058b 00       		.byte	0
 8774 058c 00       		.byte	0
 8775 058d 03       		.byte	3
 8776 058e 00       		.byte	0
 8777 058f 00       		.byte	0
 8778 0590 00       		.byte	0
 8779 0591 00       		.byte	0
 8780 0592 00       		.byte	0
 8781 0593 30       		.byte	48
 8782 0594 01       		.byte	1
 8783 0595 00       		.byte	0
 8784 0596 00       		.byte	0
 8785 0597 00000000 		.space	5
 8785      00
 8786 059c 00       		.byte	0
 8787 059d 00       		.byte	0
 8788 059e 02       		.byte	2
 8789 059f 00       		.byte	0
 8790 05a0 00       		.byte	0
 8791 05a1 40       		.byte	64
 8792 05a2 00       		.byte	0
 8793 05a3 01       		.byte	1
 8794 05a4 00       		.byte	0
 8795 05a5 03       		.byte	3
 8796 05a6 00       		.byte	0
 8797 05a7 0F       		.byte	15
 8798 05a8 11       		.byte	17
 8799 05a9 00       		.byte	0
 8800 05aa 00       		.byte	0
 8801 05ab 30       		.byte	48
 8802 05ac 01       		.byte	1
 8803 05ad 00       		.byte	0
 8804 05ae 00       		.byte	0
 8805 05af 00000000 		.space	5
 8805      00
 8806 05b4 00       		.byte	0
 8807 05b5 00       		.byte	0
 8808 05b6 02       		.byte	2
 8809 05b7 00       		.byte	0
 8810 05b8 00       		.byte	0
 8811 05b9 64       		.byte	100
 8812 05ba 00       		.byte	0
 8813 05bb 01       		.byte	1
 8814 05bc 00       		.byte	0
 8815 05bd 03       		.byte	3
 8816 05be 00       		.byte	0
 8817 05bf 00       		.byte	0
 8818 05c0 00       		.byte	0
 8819 05c1 00       		.byte	0
 8820 05c2 00       		.byte	0
 8821 05c3 30       		.byte	48
 8822 05c4 01       		.byte	1
 8823 05c5 00       		.byte	0
 8824 05c6 00       		.byte	0
 8825 05c7 00000000 		.space	5
 8825      00
 8826 05cc 00       		.byte	0
 8827 05cd 00       		.byte	0
 8828 05ce 02       		.byte	2
 8829 05cf 00       		.byte	0
 8830 05d0 00       		.byte	0
 8831 05d1 64       		.byte	100
 8832 05d2 00       		.byte	0
 8833 05d3 01       		.byte	1
 8834 05d4 00       		.byte	0
 8835 05d5 03       		.byte	3
 8836 05d6 00       		.byte	0
 8837 05d7 00       		.byte	0
 8838 05d8 00       		.byte	0
 8839 05d9 00       		.byte	0
 8840 05da 00       		.byte	0
 8841 05db 30       		.byte	48
 8842 05dc 01       		.byte	1
 8843 05dd 00       		.byte	0
 8844 05de 00       		.byte	0
 8845 05df 00000000 		.space	5
 8845      00
 8846 05e4 00       		.byte	0
 8847 05e5 00       		.byte	0
 8848 05e6 02       		.byte	2
 8849 05e7 00       		.byte	0
 8850 05e8 00       		.byte	0
 8851 05e9 64       		.byte	100
 8852 05ea 00       		.byte	0
 8853 05eb 01       		.byte	1
 8854 05ec 00       		.byte	0
 8855 05ed 03       		.byte	3
 8856 05ee 00       		.byte	0
 8857 05ef 00       		.byte	0
 8858 05f0 00       		.byte	0
 8859 05f1 00       		.byte	0
 8860 05f2 00       		.byte	0
 8861 05f3 30       		.byte	48
 8862 05f4 01       		.byte	1
 8863 05f5 00       		.byte	0
 8864 05f6 00       		.byte	0
 8865 05f7 00000000 		.space	5
 8865      00
 8866 05fc 00       		.byte	0
 8867 05fd 00       		.byte	0
 8868 05fe 02       		.byte	2
 8869 05ff 00       		.byte	0
 8870 0600 00       		.byte	0
 8871 0601 64       		.byte	100
 8872 0602 00       		.byte	0
 8873 0603 01       		.byte	1
 8874 0604 00       		.byte	0
 8875 0605 03       		.byte	3
 8876 0606 00       		.byte	0
 8877 0607 00       		.byte	0
 8878 0608 00       		.byte	0
 8879 0609 00       		.byte	0
 8880 060a 00       		.byte	0
 8881 060b 30       		.byte	48
 8882 060c 01       		.byte	1
 8883 060d 00       		.byte	0
 8884 060e 00       		.byte	0
 8885 060f 00000000 		.space	5
 8885      00
 8888              	glProbeCtrlFull:
 8889 0614 00       		.byte	0
 8890 0615 00       		.byte	0
 8891 0616 01       		.byte	1
 8892 0617 01       		.byte	1
 8893 0618 15       		.byte	21
 8894 0619 16       		.byte	22
 8895 061a 05       		.byte	5
 8896 061b 00       		.byte	0
 8897 061c 00       		.byte	0
 8898 061d 00       		.byte	0
 8899 061e 00       		.byte	0
 8900 061f 00       		.byte	0
 8901 0620 00       		.byte	0
 8902 0621 00       		.byte	0
 8903 0622 00       		.byte	0
 8904 0623 00       		.byte	0
 8905 0624 00       		.byte	0
 8906 0625 00       		.byte	0
 8907 0626 00       		.byte	0
 8908 0627 C6       		.byte	-58
 8909 0628 99       		.byte	-103
 8910 0629 00       		.byte	0
 8911 062a 00       		.byte	0
 8912 062b 40       		.byte	64
 8913 062c 00       		.byte	0
 8914 062d 00       		.byte	0
 8915 062e 0000     		.space	2
 8918              	glProbeCtrl20:
 8919 0630 00       		.byte	0
 8920 0631 00       		.byte	0
 8921 0632 01       		.byte	1
 8922 0633 01       		.byte	1
 8923 0634 80       		.byte	-128
 8924 0635 1A       		.byte	26
 8925 0636 06       		.byte	6
 8926 0637 00       		.byte	0
 8927 0638 00       		.byte	0
 8928 0639 00       		.byte	0
 8929 063a 00       		.byte	0
 8930 063b 00       		.byte	0
 8931 063c 00       		.byte	0
 8932 063d 00       		.byte	0
 8933 063e 00       		.byte	0
 8934 063f 00       		.byte	0
 8935 0640 00       		.byte	0
 8936 0641 00       		.byte	0
 8937 0642 00       		.byte	0
 8938 0643 D2       		.byte	-46
 8939 0644 0F       		.byte	15
 8940 0645 00       		.byte	0
 8941 0646 00       		.byte	0
 8942 0647 40       		.byte	64
 8943 0648 00       		.byte	0
 8944 0649 00       		.byte	0
 8945 064a 0000     		.space	2
 8948              	glProbeCtrl:
 8949 064c 00       		.byte	0
 8950 064d 00       		.byte	0
 8951 064e 01       		.byte	1
 8952 064f 01       		.byte	1
 8953 0650 15       		.byte	21
 8954 0651 16       		.byte	22
 8955 0652 05       		.byte	5
 8956 0653 00       		.byte	0
 8957 0654 00       		.byte	0
 8958 0655 00       		.byte	0
 8959 0656 00       		.byte	0
 8960 0657 00       		.byte	0
 8961 0658 00       		.byte	0
 8962 0659 00       		.byte	0
 8963 065a 00       		.byte	0
 8964 065b 00       		.byte	0
 8965 065c 00       		.byte	0
 8966 065d 00       		.byte	0
 8967 065e 00       		.byte	0
 8968 065f 48       		.byte	72
 8969 0660 3F       		.byte	63
 8970 0661 00       		.byte	0
 8971 0662 00       		.byte	0
 8972 0663 40       		.byte	64
 8973 0664 00       		.byte	0
 8974 0665 00       		.byte	0
 8975 0666 0000     		.space	2
 8978              	glProbeStilCtrl:
 8979 0668 01       		.byte	1
 8980 0669 02       		.byte	2
 8981 066a 00       		.byte	0
 8982 066b 00       		.byte	0
 8983 066c C6       		.byte	-58
 8984 066d 99       		.byte	-103
 8985 066e 00       		.byte	0
 8986 066f 00       		.byte	0
 8987 0670 40       		.byte	64
 8988 0671 00       		.byte	0
 8989 0672 00       		.byte	0
 8990 0673 00       		.space	1
 8993              	glProbeStilCtrl20:
 8994 0674 01       		.byte	1
 8995 0675 01       		.byte	1
 8996 0676 00       		.byte	0
 8997 0677 00       		.byte	0
 8998 0678 D2       		.byte	-46
 8999 0679 0F       		.byte	15
 9000 067a 00       		.byte	0
 9001 067b 00       		.byte	0
 9002 067c 40       		.byte	64
 9003 067d 00       		.byte	0
 9004 067e 00       		.byte	0
 9007              	snapButFlag:
 9008 067f 01       		.byte	1
 9011              	CyFxGpifTransition:
 9012 0680 0000     		.short	0
 9013 0682 5555     		.short	21845
 9014 0684 8888     		.short	-30584
 9015 0686 AAAA     		.short	-21846
 9016 0688 3333     		.short	13107
 9017 068a 0000     		.space	2
 9020              	CyFxGpifWavedata:
 9021 068c 0181731E 		.word	510886145
 9022 0690 00000000 		.word	0
 9023 0694 00000080 		.word	-2147483648
 9024 0698 00000000 		.word	0
 9025 069c 00000000 		.word	0
 9026 06a0 00000000 		.word	0
 9027 06a4 0201702E 		.word	779092226
 9028 06a8 00010000 		.word	256
 9029 06ac A0000080 		.word	-2147483488
 9030 06b0 00000000 		.word	0
 9031 06b4 00000000 		.word	0
 9032 06b8 00000000 		.word	0
 9033 06bc 0380722E 		.word	779255811
 9034 06c0 02010020 		.word	536871170
 9035 06c4 60000080 		.word	-2147483552
 9036 06c8 00000000 		.word	0
 9037 06cc 00000000 		.word	0
 9038 06d0 00000000 		.word	0
 9039 06d4 0460722E 		.word	779247620
 9040 06d8 02010024 		.word	603980034
 9041 06dc 90000080 		.word	-2147483504
 9042 06e0 0594731E 		.word	510891013
 9043 06e4 06000000 		.word	6
 9044 06e8 00000080 		.word	-2147483648
 9045 06ec 0380722E 		.word	779255811
 9046 06f0 02010020 		.word	536871170
 9047 06f4 60000080 		.word	-2147483552
 9048 06f8 0693731E 		.word	510890758
 9049 06fc 06000000 		.word	6
 9050 0700 00000080 		.word	-2147483648
 9051 0704 0720703E 		.word	1047535623
 9052 0708 08010000 		.word	264
 9053 070c 00000080 		.word	-2147483648
 9054 0710 0820703E 		.word	1047535624
 9055 0714 08010000 		.word	264
 9056 0718 00000080 		.word	-2147483648
 9057 071c 0920703E 		.word	1047535625
 9058 0720 08010000 		.word	264
 9059 0724 00000080 		.word	-2147483648
 9060 0728 0A20703E 		.word	1047535626
 9061 072c 08010000 		.word	264
 9062 0730 00000080 		.word	-2147483648
 9063 0734 0380722E 		.word	779255811
 9064 0738 02010020 		.word	536871170
 9065 073c 60000080 		.word	-2147483552
 9066 0740 0B000000 		.word	11
 9067 0744 00000000 		.word	0
 9068 0748 00010080 		.word	-2147483392
 9069 074c 0460722E 		.word	779247620
 9070 0750 02010024 		.word	603980034
 9071 0754 90000080 		.word	-2147483504
 9072 0758 0D000000 		.word	13
 9073 075c 00000000 		.word	0
 9074 0760 00010080 		.word	-2147483392
 9075 0764 0460722E 		.word	779247620
 9076 0768 02010024 		.word	603980034
 9077 076c 90000080 		.word	-2147483504
 9078 0770 0C000000 		.word	12
 9079 0774 00000000 		.word	0
 9080 0778 00010080 		.word	-2147483392
 9081 077c 0380722E 		.word	779255811
 9082 0780 02010020 		.word	536871170
 9083 0784 60000080 		.word	-2147483552
 9084 0788 0E000000 		.word	14
 9085 078c 00000000 		.word	0
 9086 0790 00010080 		.word	-2147483392
 9087 0794 00000000 		.word	0
 9088 0798 00000000 		.word	0
 9089 079c 00000000 		.word	0
 9090 07a0 00000000 		.word	0
 9091 07a4 00000000 		.word	0
 9092 07a8 00000000 		.word	0
 9095              	CyFxGpifWavedataPosition:
 9096 07ac 00       		.byte	0
 9097 07ad 01       		.byte	1
 9098 07ae 02       		.byte	2
 9099 07af 03       		.byte	3
 9100 07b0 04       		.byte	4
 9101 07b1 05       		.byte	5
 9102 07b2 06       		.byte	6
 9103 07b3 07       		.byte	7
 9104 07b4 08       		.byte	8
 9105 07b5 09       		.byte	9
 9106 07b6 0A       		.byte	10
 9107 07b7 0B       		.byte	11
 9108 07b8 0B       		.byte	11
 9109 07b9 0B       		.byte	11
 9110 07ba 0B       		.byte	11
 9111 07bb 00       		.space	1
 9114              	CyFxGpifRegValue:
 9115 07bc 08830080 		.word	-2147450104
 9116 07c0 67000000 		.word	103
 9117 07c4 00000000 		.word	0
 9118 07c8 46000000 		.word	70
 9119 07cc 00000000 		.word	0
 9120 07d0 00000000 		.word	0
 9121 07d4 02000000 		.word	2
 9122 07d8 82000000 		.word	130
 9123 07dc 82070000 		.word	1922
 9124 07e0 40040000 		.word	1088
 9125 07e4 FCFF0000 		.word	65532
 9126 07e8 28000000 		.word	40
 9127 07ec 00000000 		.word	0
 9128 07f0 00000000 		.word	0
 9129 07f4 00000000 		.word	0
 9130 07f8 00000000 		.word	0
 9131 07fc 01000000 		.word	1
 9132 0800 00000000 		.word	0
 9133 0804 00000000 		.word	0
 9134 0808 00000000 		.word	0
 9135 080c 00000000 		.word	0
 9136 0810 00000000 		.word	0
 9137 0814 00000000 		.word	0
 9138 0818 00000000 		.word	0
 9139 081c 00000000 		.word	0
 9140 0820 00000000 		.word	0
 9141 0824 00000000 		.word	0
 9142 0828 00000000 		.word	0
 9143 082c 00000000 		.word	0
 9144 0830 06000000 		.word	6
 9145 0834 00000000 		.word	0
 9146 0838 FFFF0000 		.word	65535
 9147 083c 09010000 		.word	265
 9148 0840 00000000 		.word	0
 9149 0844 F71F0000 		.word	8183
 9150 0848 00000000 		.word	0
 9151 084c FFFF0000 		.word	65535
 9152 0850 09010000 		.word	265
 9153 0854 00000000 		.word	0
 9154 0858 F71F0000 		.word	8183
 9155 085c 00000000 		.word	0
 9156 0860 00000000 		.word	0
 9157 0864 00000000 		.word	0
 9158 0868 00000000 		.word	0
 9159 086c 00000000 		.word	0
 9160 0870 00000000 		.word	0
 9161 0874 00000000 		.word	0
 9162 0878 00000000 		.word	0
 9163 087c 00000000 		.word	0
 9164 0880 00000000 		.word	0
 9165 0884 00000000 		.word	0
 9166 0888 00000000 		.word	0
 9167 088c 00000000 		.word	0
 9168 0890 00000000 		.word	0
 9169 0894 00000000 		.word	0
 9170 0898 00000000 		.word	0
 9171 089c 00000000 		.word	0
 9172 08a0 00000000 		.word	0
 9173 08a4 00000000 		.word	0
 9174 08a8 00000000 		.word	0
 9175 08ac 00000000 		.word	0
 9176 08b0 00000000 		.word	0
 9177 08b4 00000000 		.word	0
 9178 08b8 00040180 		.word	-2147417088
 9179 08bc 01040180 		.word	-2147417087
 9180 08c0 02040180 		.word	-2147417086
 9181 08c4 03040180 		.word	-2147417085
 9182 08c8 00000000 		.word	0
 9183 08cc 00000000 		.word	0
 9184 08d0 00000000 		.word	0
 9185 08d4 00000000 		.word	0
 9186 08d8 00000000 		.word	0
 9187 08dc 00000000 		.word	0
 9188 08e0 00000000 		.word	0
 9189 08e4 00000000 		.word	0
 9190 08e8 C1FFFFFF 		.word	-63
 9193              	CyFxGpifTransition_usb2:
 9194 08ec 0000     		.short	0
 9195 08ee 5555     		.short	21845
 9196 08f0 AAAA     		.short	-21846
 9197 08f2 8888     		.short	-30584
 9198 08f4 1111     		.short	4369
 9199 08f6 4444     		.short	17476
 9200 08f8 3333     		.short	13107
 9201 08fa CCCC     		.short	-13108
 9204              	CyFxGpifWavedata_usb2:
 9205 08fc 0181731E 		.word	510886145
 9206 0900 00000000 		.word	0
 9207 0904 00000080 		.word	-2147483648
 9208 0908 00000000 		.word	0
 9209 090c 00000000 		.word	0
 9210 0910 00000000 		.word	0
 9211 0914 0201703E 		.word	1047527682
 9212 0918 00010000 		.word	256
 9213 091c A00000C0 		.word	-1073741664
 9214 0920 00000000 		.word	0
 9215 0924 00000000 		.word	0
 9216 0928 00000000 		.word	0
 9217 092c 0394731E 		.word	510891011
 9218 0930 04000020 		.word	536870916
 9219 0934 60004080 		.word	-2143289248
 9220 0938 00000000 		.word	0
 9221 093c 00000000 		.word	0
 9222 0940 00000000 		.word	0
 9223 0944 0620702E 		.word	779100166
 9224 0948 0C000000 		.word	12
 9225 094c 00000080 		.word	-2147483648
 9226 0950 0620702E 		.word	779100166
 9227 0954 0C000000 		.word	12
 9228 0958 00000080 		.word	-2147483648
 9229 095c 0394731E 		.word	510891011
 9230 0960 04000020 		.word	536870916
 9231 0964 60004080 		.word	-2143289248
 9232 0968 0620702E 		.word	779100166
 9233 096c 0C000000 		.word	12
 9234 0970 00000080 		.word	-2147483648
 9235 0974 0C93731E 		.word	510890764
 9236 0978 04000024 		.word	603979780
 9237 097c 90004080 		.word	-2143289200
 9238 0980 0D20702E 		.word	779100173
 9239 0984 0C000000 		.word	12
 9240 0988 00000080 		.word	-2147483648
 9241 098c 0780724E 		.word	1316126727
 9242 0990 0A000000 		.word	10
 9243 0994 00000080 		.word	-2147483648
 9244 0998 08000000 		.word	8
 9245 099c 00000000 		.word	0
 9246 09a0 00010080 		.word	-2147483392
 9247 09a4 0920702E 		.word	779100169
 9248 09a8 0C010000 		.word	268
 9249 09ac 00000080 		.word	-2147483648
 9250 09b0 0A01701E 		.word	510656778
 9251 09b4 0E000100 		.word	65550
 9252 09b8 00000080 		.word	-2147483648
 9253 09bc 00000000 		.word	0
 9254 09c0 00000000 		.word	0
 9255 09c4 00000000 		.word	0
 9256 09c8 00000000 		.word	0
 9257 09cc 00000000 		.word	0
 9258 09d0 00000000 		.word	0
 9259 09d4 0394731E 		.word	510891011
 9260 09d8 04000020 		.word	536870916
 9261 09dc 60004080 		.word	-2143289248
 9262 09e0 08000000 		.word	8
 9263 09e4 00000000 		.word	0
 9264 09e8 00010080 		.word	-2147483392
 9265 09ec 0B000000 		.word	11
 9266 09f0 00000000 		.word	0
 9267 09f4 00010080 		.word	-2147483392
 9268 09f8 0C93731E 		.word	510890764
 9269 09fc 04000024 		.word	603979780
 9270 0a00 90004080 		.word	-2143289200
 9271 0a04 0D20702E 		.word	779100173
 9272 0a08 0C000000 		.word	12
 9273 0a0c 00000080 		.word	-2147483648
 9274 0a10 0D20702E 		.word	779100173
 9275 0a14 0C000000 		.word	12
 9276 0a18 00000080 		.word	-2147483648
 9277 0a1c 0E60724E 		.word	1316118542
 9278 0a20 0A000000 		.word	10
 9279 0a24 00000080 		.word	-2147483648
 9280 0a28 0F000000 		.word	15
 9281 0a2c 00000000 		.word	0
 9282 0a30 00010080 		.word	-2147483392
 9283 0a34 1020702E 		.word	779100176
 9284 0a38 0C010000 		.word	268
 9285 0a3c 00000080 		.word	-2147483648
 9286 0a40 1101701E 		.word	510656785
 9287 0a44 0E000100 		.word	65550
 9288 0a48 00000080 		.word	-2147483648
 9289 0a4c 0C93731E 		.word	510890764
 9290 0a50 04000024 		.word	603979780
 9291 0a54 90004080 		.word	-2143289200
 9292 0a58 0F000000 		.word	15
 9293 0a5c 00000000 		.word	0
 9294 0a60 00010080 		.word	-2147483392
 9295 0a64 12000000 		.word	18
 9296 0a68 00000000 		.word	0
 9297 0a6c 00010080 		.word	-2147483392
 9298 0a70 0394731E 		.word	510891011
 9299 0a74 04000020 		.word	536870916
 9300 0a78 60004080 		.word	-2143289248
 9301 0a7c 0480732E 		.word	779321348
 9302 0a80 02010000 		.word	258
 9303 0a84 0000C0C0 		.word	-1061158912
 9304 0a88 0580732E 		.word	779321349
 9305 0a8c 02010000 		.word	258
 9306 0a90 0000C0C0 		.word	-1061158912
 9307 0a94 0580732E 		.word	779321349
 9308 0a98 02010000 		.word	258
 9309 0a9c 0000C0C0 		.word	-1061158912
 9310 0aa0 0480732E 		.word	779321348
 9311 0aa4 02010000 		.word	258
 9312 0aa8 0000C0C0 		.word	-1061158912
 9315              	CyFxGpifWavedataPosition_usb2:
 9316 0aac 00       		.byte	0
 9317 0aad 01       		.byte	1
 9318 0aae 02       		.byte	2
 9319 0aaf 03       		.byte	3
 9320 0ab0 04       		.byte	4
 9321 0ab1 05       		.byte	5
 9322 0ab2 06       		.byte	6
 9323 0ab3 07       		.byte	7
 9324 0ab4 08       		.byte	8
 9325 0ab5 09       		.byte	9
 9326 0ab6 0A       		.byte	10
 9327 0ab7 08       		.byte	8
 9328 0ab8 0B       		.byte	11
 9329 0ab9 0C       		.byte	12
 9330 0aba 0D       		.byte	13
 9331 0abb 08       		.byte	8
 9332 0abc 0E       		.byte	14
 9333 0abd 0F       		.byte	15
 9334 0abe 08       		.byte	8
 9335 0abf 08       		.byte	8
 9336 0ac0 08       		.byte	8
 9337 0ac1 08       		.byte	8
 9338 0ac2 08       		.byte	8
 9339 0ac3 08       		.byte	8
 9340 0ac4 08       		.byte	8
 9341 0ac5 08       		.byte	8
 9342 0ac6 08       		.byte	8
 9343 0ac7 08       		.byte	8
 9344 0ac8 08       		.byte	8
 9345 0ac9 08       		.byte	8
 9346 0aca 08       		.byte	8
 9347 0acb 08       		.byte	8
 9348 0acc 08       		.byte	8
 9349 0acd 08       		.byte	8
 9350 0ace 08       		.byte	8
 9351 0acf 08       		.byte	8
 9352 0ad0 08       		.byte	8
 9353 0ad1 08       		.byte	8
 9354 0ad2 08       		.byte	8
 9355 0ad3 08       		.byte	8
 9356 0ad4 08       		.byte	8
 9357 0ad5 08       		.byte	8
 9358 0ad6 08       		.byte	8
 9359 0ad7 08       		.byte	8
 9360 0ad8 08       		.byte	8
 9361 0ad9 08       		.byte	8
 9362 0ada 08       		.byte	8
 9363 0adb 08       		.byte	8
 9364 0adc 08       		.byte	8
 9365 0add 08       		.byte	8
 9366 0ade 08       		.byte	8
 9367 0adf 08       		.byte	8
 9368 0ae0 08       		.byte	8
 9369 0ae1 08       		.byte	8
 9370 0ae2 08       		.byte	8
 9371 0ae3 08       		.byte	8
 9372 0ae4 08       		.byte	8
 9373 0ae5 08       		.byte	8
 9374 0ae6 08       		.byte	8
 9375 0ae7 08       		.byte	8
 9376 0ae8 08       		.byte	8
 9377 0ae9 08       		.byte	8
 9378 0aea 08       		.byte	8
 9379 0aeb 08       		.byte	8
 9380 0aec 08       		.byte	8
 9381 0aed 08       		.byte	8
 9382 0aee 08       		.byte	8
 9383 0aef 08       		.byte	8
 9384 0af0 08       		.byte	8
 9385 0af1 08       		.byte	8
 9386 0af2 08       		.byte	8
 9387 0af3 08       		.byte	8
 9388 0af4 08       		.byte	8
 9389 0af5 08       		.byte	8
 9390 0af6 08       		.byte	8
 9391 0af7 08       		.byte	8
 9392 0af8 08       		.byte	8
 9393 0af9 08       		.byte	8
 9394 0afa 08       		.byte	8
 9395 0afb 08       		.byte	8
 9396 0afc 08       		.byte	8
 9397 0afd 08       		.byte	8
 9398 0afe 08       		.byte	8
 9399 0aff 08       		.byte	8
 9400 0b00 08       		.byte	8
 9401 0b01 08       		.byte	8
 9402 0b02 08       		.byte	8
 9403 0b03 08       		.byte	8
 9404 0b04 08       		.byte	8
 9405 0b05 08       		.byte	8
 9406 0b06 08       		.byte	8
 9407 0b07 08       		.byte	8
 9408 0b08 08       		.byte	8
 9409 0b09 08       		.byte	8
 9410 0b0a 08       		.byte	8
 9411 0b0b 08       		.byte	8
 9412 0b0c 08       		.byte	8
 9413 0b0d 08       		.byte	8
 9414 0b0e 08       		.byte	8
 9415 0b0f 08       		.byte	8
 9416 0b10 08       		.byte	8
 9417 0b11 08       		.byte	8
 9418 0b12 08       		.byte	8
 9419 0b13 08       		.byte	8
 9420 0b14 08       		.byte	8
 9421 0b15 08       		.byte	8
 9422 0b16 08       		.byte	8
 9423 0b17 08       		.byte	8
 9424 0b18 08       		.byte	8
 9425 0b19 08       		.byte	8
 9426 0b1a 08       		.byte	8
 9427 0b1b 08       		.byte	8
 9428 0b1c 08       		.byte	8
 9429 0b1d 08       		.byte	8
 9430 0b1e 08       		.byte	8
 9431 0b1f 08       		.byte	8
 9432 0b20 08       		.byte	8
 9433 0b21 08       		.byte	8
 9434 0b22 08       		.byte	8
 9435 0b23 08       		.byte	8
 9436 0b24 08       		.byte	8
 9437 0b25 08       		.byte	8
 9438 0b26 08       		.byte	8
 9439 0b27 08       		.byte	8
 9440 0b28 08       		.byte	8
 9441 0b29 08       		.byte	8
 9442 0b2a 08       		.byte	8
 9443 0b2b 08       		.byte	8
 9444 0b2c 00       		.byte	0
 9445 0b2d 01       		.byte	1
 9446 0b2e 02       		.byte	2
 9447 0b2f 10       		.byte	16
 9448 0b30 04       		.byte	4
 9449 0b31 05       		.byte	5
 9450 0b32 06       		.byte	6
 9451 0b33 07       		.byte	7
 9452 0b34 08       		.byte	8
 9453 0b35 09       		.byte	9
 9454 0b36 0A       		.byte	10
 9455 0b37 08       		.byte	8
 9456 0b38 11       		.byte	17
 9457 0b39 0C       		.byte	12
 9458 0b3a 0D       		.byte	13
 9459 0b3b 08       		.byte	8
 9460 0b3c 0E       		.byte	14
 9461 0b3d 0F       		.byte	15
 9462 0b3e 08       		.byte	8
 9463 0b3f 00       		.space	1
 9466              	CyFxGpifRegValue_usb2:
 9467 0b40 08830080 		.word	-2147450104
 9468 0b44 67000000 		.word	103
 9469 0b48 01000000 		.word	1
 9470 0b4c 46000000 		.word	70
 9471 0b50 00000000 		.word	0
 9472 0b54 00000000 		.word	0
 9473 0b58 02000000 		.word	2
 9474 0b5c 82000000 		.word	130
 9475 0b60 82070000 		.word	1922
 9476 0b64 40040000 		.word	1088
 9477 0b68 FCFF0000 		.word	65532
 9478 0b6c 28000000 		.word	40
 9479 0b70 00000000 		.word	0
 9480 0b74 00000000 		.word	0
 9481 0b78 00000000 		.word	0
 9482 0b7c 00000000 		.word	0
 9483 0b80 01000000 		.word	1
 9484 0b84 00000000 		.word	0
 9485 0b88 00000000 		.word	0
 9486 0b8c 00000000 		.word	0
 9487 0b90 00000000 		.word	0
 9488 0b94 00000000 		.word	0
 9489 0b98 00000000 		.word	0
 9490 0b9c 00000000 		.word	0
 9491 0ba0 00000000 		.word	0
 9492 0ba4 00000000 		.word	0
 9493 0ba8 00000000 		.word	0
 9494 0bac 00000000 		.word	0
 9495 0bb0 00000000 		.word	0
 9496 0bb4 06000000 		.word	6
 9497 0bb8 00000000 		.word	0
 9498 0bbc FFFF0000 		.word	65535
 9499 0bc0 09010000 		.word	265
 9500 0bc4 00000000 		.word	0
 9501 0bc8 F71F0000 		.word	8183
 9502 0bcc 00000000 		.word	0
 9503 0bd0 FFFF0000 		.word	65535
 9504 0bd4 09010000 		.word	265
 9505 0bd8 00000000 		.word	0
 9506 0bdc F71F0000 		.word	8183
 9507 0be0 00000000 		.word	0
 9508 0be4 00000000 		.word	0
 9509 0be8 00000000 		.word	0
 9510 0bec 00000000 		.word	0
 9511 0bf0 00000000 		.word	0
 9512 0bf4 00000000 		.word	0
 9513 0bf8 00000000 		.word	0
 9514 0bfc 00000000 		.word	0
 9515 0c00 00000000 		.word	0
 9516 0c04 00000000 		.word	0
 9517 0c08 00000000 		.word	0
 9518 0c0c 00000000 		.word	0
 9519 0c10 00000000 		.word	0
 9520 0c14 00000000 		.word	0
 9521 0c18 00000000 		.word	0
 9522 0c1c 00000000 		.word	0
 9523 0c20 00000000 		.word	0
 9524 0c24 00000000 		.word	0
 9525 0c28 00000000 		.word	0
 9526 0c2c 00000000 		.word	0
 9527 0c30 00000000 		.word	0
 9528 0c34 00000000 		.word	0
 9529 0c38 00000000 		.word	0
 9530 0c3c 00040180 		.word	-2147417088
 9531 0c40 01040180 		.word	-2147417087
 9532 0c44 02040180 		.word	-2147417086
 9533 0c48 03040180 		.word	-2147417085
 9534 0c4c 00000000 		.word	0
 9535 0c50 00000000 		.word	0
 9536 0c54 00000000 		.word	0
 9537 0c58 00000000 		.word	0
 9538 0c5c 00000000 		.word	0
 9539 0c60 00000000 		.word	0
 9540 0c64 00000000 		.word	0
 9541 0c68 00000000 		.word	0
 9542 0c6c C1FFFFFF 		.word	-63
 9543              		.section	.rodata.str1.4,"aMS",%progbits,1
 9544              		.align	2
 9545              	.LC0:
 9546 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 9546      7065722D 
 9546      74696D65 
 9546      72202564 
 9546      0D0A00
 9547 0013 00       		.space	1
 9548              	.LC1:
 9549 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 9549      636F6D6D 
 9549      616E6420 
 9549      71756575 
 9549      65206973 
 9550 0037 00       		.space	1
 9551              	.LC2:
 9552 0038 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 9552      7220696E 
 9552      206D756C 
 9552      74696368 
 9552      616E6E65 
 9553 006b 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 9553      2025782C 
 9553      20646D61 
 9553      446F6E65 
 9553      20256420 
 9554              	.LC3:
 9555 0084 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 9555      5420656E 
 9555      636F756E 
 9555      74657265 
 9555      642E2E2E 
 9556              	.LC4:
 9557 00a4 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 9557      454E4420 
 9557      656E636F 
 9557      756E7465 
 9557      7265642E 
 9558 00c6 0000     		.space	2
 9559              	.LC5:
 9560 00c8 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 9560      64697363 
 9560      6F6E6E65 
 9560      63746564 
 9560      2E2E2E30 
 9561 00e7 00       		.space	1
 9562              	.LC6:
 9563 00e8 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 9563      43595F46 
 9563      585F5556 
 9563      435F5649 
 9563      44454F5F 
 9564 011b 0A00     		.ascii	"\012\000"
 9565 011d 000000   		.space	3
 9566              	.LC7:
 9567 0120 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 9567      43595F46 
 9567      585F5556 
 9567      435F5649 
 9567      44454F5F 
 9568 0153 00       		.ascii	"\000"
 9569              	.LC8:
 9570 0154 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 9570      726E6174 
 9570      65207365 
 9570      7474696E 
 9570      6720302E 
 9571              	.LC9:
 9572 016c 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 9572      72206665 
 9572      61747572 
 9572      65207265 
 9572      71756573 
 9573 018f 00       		.space	1
 9574              	.LC10:
 9575 0190 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 9575      6F6D6D69 
 9575      74656F66 
 9575      20737461 
 9575      7465203D 
 9576              	.LC11:
 9577 01a8 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 9577      6E656C20 
 9577      53657420 
 9577      57726170 
 9577      55702066 
 9578 01d5 000000   		.space	3
 9579              	.LC12:
 9580 01d8 4572726F 		.ascii	"Error handler...\015\012\000"
 9580      72206861 
 9580      6E646C65 
 9580      722E2E2E 
 9580      0D0A00
 9581 01eb 00       		.space	1
 9582              	.LC13:
 9583 01ec 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 9583      69742045 
 9583      4F462066 
 9583      61696C65 
 9583      64210D0A 
 9584 0201 000000   		.space	3
 9585              	.LC14:
 9586 0204 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 9586      49324320 
 9586      636F6D6D 
 9586      616E6420 
 9586      69732030 
 9587 0237 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 9587      78257820 
 9587      30782578 
 9587      20307825 
 9587      78203078 
 9588              	.LC15:
 9589 0250 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 9589      49324320 
 9589      636F6D6D 
 9589      616E6420 
 9589      73657474 
 9590 0276 0000     		.space	2
 9591              	.LC16:
 9592 0278 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 9592      206C6967 
 9592      68742063 
 9592      6F6D7065 
 9592      6E736174 
 9593 02ab 25640D0A 		.ascii	"%d\015\012\000"
 9593      00
 9594              	.LC17:
 9595 02b0 54686520 		.ascii	"The I2C current data is not available. try again. %"
 9595      49324320 
 9595      63757272 
 9595      656E7420 
 9595      64617461 
 9596 02e3 64202564 		.ascii	"d %d\015\012\000"
 9596      0D0A00
 9597 02ea 0000     		.space	2
 9598              	.LC18:
 9599 02ec 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 9599      26414743 
 9599      2073656E 
 9599      7420746F 
 9599      20686F73 
 9600 0312 0000     		.space	2
 9601              	.LC19:
 9602 0314 4578704D 		.ascii	"ExpM&AGC gotten from host. %d %d; %d %d\015\012\000"
 9602      26414743 
 9602      20676F74 
 9602      74656E20 
 9602      66726F6D 
 9603 033e 0000     		.space	2
 9604              	.LC20:
 9605 0340 46726571 		.ascii	"Frequency setting is  %d %d\015\012\000"
 9605      75656E63 
 9605      79207365 
 9605      7474696E 
 9605      67206973 
 9606 035e 0000     		.space	2
 9607              	.LC21:
 9608 0360 46536574 		.ascii	"FSet the video mode format %x %d\012\000"
 9608      20746865 
 9608      20766964 
 9608      656F206D 
 9608      6F646520 
 9609 0382 0000     		.space	2
 9610              	.LC22:
 9611 0384 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 9611      67657420 
 9611      64617461 
 9611      2066726F 
 9611      6D20686F 
 9612 03b1 000000   		.space	3
 9613              	.LC23:
 9614 03b4 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 9614      52657175 
 9614      65737420 
 9614      30782578 
 9614      20706172 
 9615 03e7 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 9615      6E642074 
 9615      6F20686F 
 9615      73742030 
 9615      78257820 
 9616 0402 0000     		.space	2
 9617              	.LC24:
 9618 0404 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 9618      204F7020 
 9618      72656365 
 9618      69766573 
 9618      20284354 
 9619 042b 00       		.space	1
 9620              	.LC25:
 9621 042c 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 9621      756C7420 
 9621      73656C65 
 9621      63746F72 
 9621      20284354 
 9622 044e 0000     		.space	2
 9623              	.LC26:
 9624 0450 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 9624      756C7420 
 9624      72657175 
 9624      65737420 
 9624      28435429 
 9625 0471 000000   		.space	3
 9626              	.LC27:
 9627 0474 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 9627      52657175 
 9627      65737420 
 9627      30782578 
 9627      20706172 
 9628 04a7 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 9628      20307825 
 9628      78202F20 
 9628      73656E64 
 9628      20746F20 
 9629 04d4 00       		.ascii	"\000"
 9630 04d5 000000   		.space	3
 9631              	.LC28:
 9632 04d8 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 9632      73706565 
 9632      64203D20 
 9632      25642065 
 9632      76656E66 
 9633 0508 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 9633      71756573 
 9633      74203D20 
 9633      30782578 
 9633      20775661 
 9634 0538 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 9634      203D2030 
 9634      78257820 
 9634      6973666C 
 9634      61672030 
 9635 0552 0000     		.space	2
 9636              	.LC29:
 9637 0554 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 9637      64656661 
 9637      756C7420 
 9637      73657475 
 9637      70207265 
 9638              	.LC30:
 9639 0580 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 9639      6F207374 
 9639      7265616D 
 9639      20474554 
 9639      20726571 
 9640 05a5 000000   		.space	3
 9641              	.LC31:
 9642 05a8 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 9642      74686520 
 9642      76696465 
 9642      6F206D6F 
 9642      64652066 
 9643 05c9 000000   		.space	3
 9644              	.LC32:
 9645 05cc 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 9645      43595F46 
 9645      585F5556 
 9645      435F5354 
 9645      5245414D 
 9646 05f2 0000     		.space	2
 9647              	.LC33:
 9648 05f4 47657420 		.ascii	"Get UVC still trigger control %d %d\015\012\000"
 9648      55564320 
 9648      7374696C 
 9648      6C207472 
 9648      69676765 
 9649 061a 0000     		.space	2
 9650              	.LC34:
 9651 061c 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 9651      7374696C 
 9651      6C207472 
 9651      69676765 
 9651      7220636F 
 9652 0643 00       		.space	1
 9653              	.LC35:
 9654 0644 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 9654      65642074 
 9654      6F207365 
 9654      6E642069 
 9654      6E746572 
 9655 0675 0A00     		.ascii	"\012\000"
 9656 0677 00       		.space	1
 9657              	.LC36:
 9658 0678 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 9658      73657420 
 9658      64656620 
 9658      64617461 
 9658      20307825 
 9659 0697 00       		.space	1
 9660              	.LC37:
 9661 0698 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 9661      73657420 
 9661      64656620 
 9661      64617461 
 9661      20307825 
 9662 06cb 2E0D0A00 		.ascii	".\015\012\000"
 9663 06cf 00       		.space	1
 9664              	.LC38:
 9665 06d0 55415254 		.ascii	"UART initialization failed!\012\000"
 9665      20696E69 
 9665      7469616C 
 9665      697A6174 
 9665      696F6E20 
 9666 06ed 000000   		.space	3
 9667              	.LC39:
 9668 06f0 49324320 		.ascii	"I2C initialization failed!\012\000"
 9668      696E6974 
 9668      69616C69 
 9668      7A617469 
 9668      6F6E2066 
 9669              	.LC40:
 9670 070c 49324320 		.ascii	"I2C configuration failed!\012\000"
 9670      636F6E66 
 9670      69677572 
 9670      6174696F 
 9670      6E206661 
 9671 0727 00       		.space	1
 9672              	.LC41:
 9673 0728 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 9673      43726561 
 9673      74652045 
 9673      76656E74 
 9673      20666169 
 9674 0752 0000     		.space	2
 9675              	.LC42:
 9676 0754 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 9676      20496E69 
 9676      74206661 
 9676      696C6564 
 9676      2C204572 
 9677 0777 00       		.space	1
 9678              	.LC43:
 9679 0778 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 9679      204F7665 
 9679      72726964 
 9679      65206661 
 9679      696C6564 
 9680 079f 00       		.space	1
 9681              	.LC44:
 9682 07a0 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 9682      28323029 
 9682      204F7665 
 9682      72726964 
 9682      65206661 
 9683 07cb 00       		.space	1
 9684              	.LC45:
 9685 07cc 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 9685      28323429 
 9685      204F7665 
 9685      72726964 
 9685      65206661 
 9686 07f7 00       		.space	1
 9687              	.LC46:
 9688 07f8 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 9688      20536574 
 9688      20287265 
 9688      73657420 
 9688      32322920 
 9689 082a 00       		.ascii	"\000"
 9690 082b 00       		.space	1
 9691              	.LC47:
 9692 082c 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 9692      20536574 
 9692      2028706F 
 9692      77657220 
 9692      32302920 
 9693 085e 00       		.ascii	"\000"
 9694 085f 00       		.space	1
 9695              	.LC48:
 9696 0860 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 9696      20536574 
 9696      2028736E 
 9696      61702073 
 9696      686F7420 
 9697 0893 25640A00 		.ascii	"%d\012\000"
 9698 0897 00       		.space	1
 9699              	.LC49:
 9700 0898 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 9700      46756E63 
 9700      74696F6E 
 9700      20466169 
 9700      6C656420 
 9701 08c7 00       		.space	1
 9702              	.LC50:
 9703 08c8 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 9703      46756E63 
 9703      74696F6E 
 9703      20466169 
 9703      6C656420 
 9704 08f7 00       		.space	1
 9705              	.LC51:
 9706 08f8 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 9706      53657420 
 9706      456E6470 
 9706      6F696E74 
 9706      20636F6E 
 9707 0928 00       		.ascii	"\000"
 9708 0929 000000   		.space	3
 9709              	.LC52:
 9710 092c 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 9710      496E7465 
 9710      72727570 
 9710      74205374 
 9710      61747573 
 9711 095f 20436F64 		.ascii	" Code = %d\012\000"
 9711      65203D20 
 9711      25640A00 
 9712 096b 00       		.space	1
 9713              	.LC53:
 9714 096c 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 9714      65642074 
 9714      6F20616C 
 9714      6C6F6361 
 9714      7465206D 
 9715 099f 65720D0A 		.ascii	"er\015\012\000"
 9715      00
 9716              	.LC54:
 9717 09a4 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 9717      4368616E 
 9717      6E656C20 
 9717      43726561 
 9717      74696F6E 
 9718 09d2 0000     		.space	2
 9719              	.LC55:
 9720 09d4 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 9720      436F6E6E 
 9720      65637420 
 9720      6661696C 
 9720      65642C20 
 9721 09f9 000000   		.space	3
 9722              	.LC56:
 9723 09fc 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 9723      4368616E 
 9723      6E656C20 
 9723      52657365 
 9723      74204661 
 9724 0a27 00       		.space	1
 9725              	.LC57:
 9726 0a28 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 9726      4368616E 
 9726      6E656C20 
 9726      53657420 
 9726      5472616E 
 9727 0a59 00       		.ascii	"\000"
 9728 0a5a 0000     		.space	2
 9729              	.LC58:
 9730 0a5c 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 9730      4368616E 
 9730      6E656C20 
 9730      53657420 
 9730      5472616E 
 9731 0a8d 0A00     		.ascii	"\012\000"
 9732 0a8f 00       		.space	1
 9733              	.LC59:
 9734 0a90 0D0A2073 		.ascii	"\015\012 super gpif\000"
 9734      75706572 
 9734      20677069 
 9734      6600
 9735 0a9e 0000     		.space	2
 9736              	.LC60:
 9737 0aa0 0D0A2068 		.ascii	"\015\012 high gpif\000"
 9737      69676820 
 9737      67706966 
 9737      00
 9738 0aad 000000   		.space	3
 9739              	.LC61:
 9740 0ab0 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 9740      696E6720 
 9740      47504946 
 9740      20436F6E 
 9740      66696775 
 9741 0ae3 0A00     		.ascii	"\012\000"
 9742 0ae5 000000   		.space	3
 9743              	.LC62:
 9744 0ae8 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 9744      74696E67 
 9744      20475049 
 9744      46207374 
 9744      61746520 
 9745 0b1b 0D0A00   		.ascii	"\015\012\000"
 9746 0b1e 0000     		.space	2
 9747              	.LC63:
 9748 0b20 33303A55 		.ascii	"30:UVC App Thread\000"
 9748      56432041 
 9748      70702054 
 9748      68726561 
 9748      6400
 9749 0b32 0000     		.space	2
 9750              	.LC64:
 9751 0b34 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 9751      56432041 
 9751      70702045 
 9751      50302054 
 9751      68726561 
 9752 0b4a 0000     		.space	2
 9753              	.LC65:
 9754 0b4c 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 9754      32432041 
 9754      70702043 
 9754      54524C20 
 9754      54687265 
 9755 0b63 00       		.bss
 9756              		.align	2
 9757              		.set	.LANCHOR0,. + 0
 9760              	glFxUVCEvent:
 9761 0000 00000000 		.space	40
 9761      00000000 
 9761      00000000 
 9761      00000000 
 9761      00000000 
 9764              	fb:
 9765 0028 0000     		.space	2
 9768              	pb:
 9769 002a 0000     		.space	2
 9772              	pbc:
 9773 002c 0000     		.space	2
 9774 002e 0000     		.space	2
 9777              	hitFV:
 9778 0030 00000000 		.space	4
 9781              	prodCount:
 9782 0034 0000     		.space	2
 9785              	consCount:
 9786 0036 0000     		.space	2
 9789              	streamingStarted:
 9790 0038 00000000 		.space	4
 9793              	gpif_initialized:
 9794 003c 00000000 		.space	4
 9797              	isUsbConnected:
 9798 0040 00000000 		.space	4
 9801              	clearFeatureRqtReceived:
 9802 0044 00000000 		.space	4
 9805              	usbSpeed:
 9806 0048 00       		.space	1
 9807 0049 000000   		.space	3
 9810              	I2CCMDArry:
 9811 004c 00000000 		.space	12
 9811      00000000 
 9811      00000000 
 9814              	is60Hz:
 9815 0058 00000000 		.space	4
 9818              	glEp0Buffer:
 9819 005c 00000000 		.space	32
 9819      00000000 
 9819      00000000 
 9819      00000000 
 9819      00000000 
 9822              	CamMode:
 9823 007c 00       		.space	1
 9826              	setRes:
 9827 007d 00       		.space	1
 9828 007e 0000     		.space	2
 9831              	glCommitCtrl:
 9832 0080 00000000 		.space	32
 9832      00000000 
 9832      00000000 
 9832      00000000 
 9832      00000000 
 9835              	stiflag:
 9836 00a0 00000000 		.space	4
 9839              	uvcAppThread:
 9840 00a4 00000000 		.space	168
 9840      00000000 
 9840      00000000 
 9840      00000000 
 9840      00000000 
 9843              	uvcAppEP0Thread:
 9844 014c 00000000 		.space	168
 9844      00000000 
 9844      00000000 
 9844      00000000 
 9844      00000000 
 9847              	i2cAppThread:
 9848 01f4 00000000 		.space	168
 9848      00000000 
 9848      00000000 
 9848      00000000 
 9848      00000000 
 9851              	testSnap:
 9852 029c 00       		.space	1
 9853 029d 00       		.space	1
 9856              	fbbak:
 9857 029e 0000     		.space	2
 9860              	pbbak:
 9861 02a0 0000     		.space	2
 9864              	pbcbak:
 9865 02a2 0000     		.space	2
 9868              	pbcpbak:
 9869 02a4 0000     		.space	2
 9870 02a6 0000     		.text
 9871              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:184    .text:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:191    .text:00000158 $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:292    .text:0000021c $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:306    .text:0000023c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:303    .text:0000023c $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:325    .text:0000024c $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:329    .text:00000250 $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:332    .text:00000250 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:495    .text:00000380 $d
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:503    .text:00000394 $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:505    .text:00000394 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:684    .text:000004f4 $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:693    .text:00000504 $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:695    .text:00000504 CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:1020   .text:000007cc $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:1036   .text:000007f8 $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:1039   .text:000007f8 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:1076   .text:00000830 $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:1089   .text:0000085c $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:1136   .text:000008b0 $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:1143   .text:000008c0 $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:1161   .text:000008dc $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:1170   .text:000008f4 $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:1173   .text:000008f4 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:1377   .text:00000afc $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:1385   .text:00000b10 $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:1388   .text:00000b10 setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:1451   .text:00000b90 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:1658   .text:00000d2c $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:1696   .text:00000db8 $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:1760   .text:00000e3c $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:1796   .text:00000ec4 $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:3071   .text:00001ad4 $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:3090   .text:00001b18 $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:3129   .text:00001b7c CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:3297   .text:00001cd8 $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:3310   .text:00001d00 $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:3805   .text:00002210 $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:3816   .text:00002230 $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:4071   .text:000024e8 $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:4084   .text:00002510 $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:4087   .text:00002510 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:4149   .text:0000258c $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:4157   .text:0000259c $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:5413   .text:00003068 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:5443   .text:000030cc $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:5446   .text:000030cc CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:5737   .text:00003384 $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:5744   .text:00003394 $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:5747   .text:00003394 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:5783   .text:000033c0 $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:5787   .text:000033c4 $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:5790   .text:000033c4 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:5815   .text:000033e0 $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:5819   .text:000033e4 $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:5822   .text:000033e4 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:7143   .text:00003e2c $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:7202   .text:00003f04 $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:7205   .text:00003f04 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:7362   .text:0000407c $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:7378   .text:000040b0 $a
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:7381   .text:000040b0 main
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9011   .data:00000680 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9020   .data:0000068c CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9095   .data:000007ac CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9114   .data:000007bc CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:7543   .rodata:00000010 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9193   .data:000008ec CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9204   .data:000008fc CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9315   .data:00000aac CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9466   .data:00000b40 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:7556   .rodata:0000002c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9007   .data:0000067f snapButFlag
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9851   .bss:0000029c testSnap
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9764   .bss:00000028 fb
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9768   .bss:0000002a pb
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9772   .bss:0000002c pbc
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9856   .bss:0000029e fbbak
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9860   .bss:000002a0 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9864   .bss:000002a2 pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9868   .bss:000002a4 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9797   .bss:00000040 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9805   .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9801   .bss:00000044 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9789   .bss:00000038 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:8948   .data:0000064c glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:8888   .data:00000614 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:8978   .data:00000668 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:8918   .data:00000630 glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:8993   .data:00000674 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:8538   .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:7520   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:7524   .rodata:00000000 ExTime
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:7568   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:7572   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:7895   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:8553   .data:0000048c ROIMode
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:8558   .data:00000490 WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:8565   .data:00000494 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9544   .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9756   .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9760   .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9777   .bss:00000030 hitFV
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9781   .bss:00000034 prodCount
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9785   .bss:00000036 consCount
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9793   .bss:0000003c gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9810   .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9814   .bss:00000058 is60Hz
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9818   .bss:0000005c glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9822   .bss:0000007c CamMode
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9826   .bss:0000007d setRes
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9831   .bss:00000080 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9835   .bss:000000a0 stiflag
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9839   .bss:000000a4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9843   .bss:0000014c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccgcTT7P.s:9847   .bss:000001f4 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorWrite2B
SensorWrite2B2
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifLoad
CyU3PGpifSMStart
CyU3PGpifSMSwitch
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
