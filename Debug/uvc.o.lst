   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"uvc.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	I2CCmdCb
  19              	I2CCmdCb:
  20              	.LFB18:
  21              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      ****                                                            received. */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 214:../uvc.c      ****                                                            the current video frame. */
 215:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 216:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 217:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 218:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 219:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 220:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 221:../uvc.c      **** 
 222:../uvc.c      **** /************ control parameters array ***********
 223:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 224:../uvc.c      ****  *    e.g.
 225:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 226:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 227:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 228:../uvc.c      ****  **************************************************/
 229:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 230:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 231:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 232:../uvc.c      **** 		{/*0*/BLCModeRegAct       , BLCModeRegAct        , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,
 233:../uvc.c      **** 		{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 234:../uvc.c      **** 		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1, 
 235:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 236:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 237:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 238:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 239:../uvc.c      **** 		{/*7*/SharpnessEnReg       , SharpnessGaiReg        , 2,    0,    0,  255,    0, 1, 0, 3, 0,  32,
 240:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 241:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 242:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 243:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 244:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 245:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 246:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 247:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 248:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 253:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 254:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 255:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 256:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 257:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 258:../uvc.c      **** 		{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 259:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 260:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 261:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 262:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 263:../uvc.c      **** 		/**********************************
 264:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 265:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 266:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 267:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 268:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 269:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 270:../uvc.c      **** 		 *
 271:../uvc.c      **** 		 *********************************/
 272:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 273:../uvc.c      **** };
 274:../uvc.c      **** #if 1 // the new control structure
 275:../uvc.c      **** /* the processing unit control request */
 276:../uvc.c      **** //		{ 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,   0, I2C_EAGLESDP_ADDR,  CyTrue, CyFalse,
 277:../uvc.c      **** 
 278:../uvc.c      **** volatile static SensorCtrl PUCBLC =
 279:../uvc.c      **** 		{BLCModeRegAct,		//Reg1: the command register address1
 280:../uvc.c      **** 		 BLCModeRegGain,	//Reg2: the command register address2
 281:../uvc.c      **** 		 2,					//UVCLn: the command length
 282:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 283:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 284:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 285:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 286:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 287:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 288:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 289:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 290:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 291:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 292:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 293:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 294:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 295:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 296:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 297:../uvc.c      **** 		}; //
 298:../uvc.c      **** //{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 299:../uvc.c      **** //volatile static SensorCtrl PUCBright;
 300:../uvc.c      **** volatile static SensorCtrl PUCBright =
 301:../uvc.c      **** 		{0x15/*BrightnessReg1*/,		//Reg1: the command register address1
 302:../uvc.c      **** 		 0x15/*BrightnessReg0*/,		//Reg2: the command register address2
 303:../uvc.c      **** 		 2,					//UVCLn: the command length
 304:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 305:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 306:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 307:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 308:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 309:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 310:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 311:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 312:../uvc.c      **** 		 118,				//UVCDefVLo: the command default data value low byte
 313:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 314:../uvc.c      **** 		 118,				//UVCCurVLo: the command current data value low byte
 315:../uvc.c      **** 		 119,				//UVCCurVHi: the command current data value high byte
 316:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 317:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 318:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 319:../uvc.c      **** 		}; //brightness, Reg1: ; Reg2: .
 320:../uvc.c      **** //		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1
 321:../uvc.c      **** //volatile static SensorCtrl PUCContrast;
 322:../uvc.c      **** volatile static SensorCtrl PUCContrast =
 323:../uvc.c      **** 		{ContrastReg,		//Reg1: the command register address1
 324:../uvc.c      **** 		 ContrastReg,		//Reg2: the command register address2
 325:../uvc.c      **** 		 2,					//UVCLn: the command length
 326:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 327:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 328:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 329:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 330:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 331:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 332:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 333:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 334:../uvc.c      **** 		 112,				//UVCDefVLo: the command default data value low byte
 335:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 336:../uvc.c      **** 		 112,				//UVCCurVLo: the command current data value low byte
 337:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 338:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 339:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 340:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 341:../uvc.c      **** 		}; //contrast, Reg1: ; Reg2: .
 342:../uvc.c      **** //volatile static SensorCtrl PUCGain;
 343:../uvc.c      **** //		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 
 344:../uvc.c      **** volatile static SensorCtrl PUCPLFreq =  //in 5MP b/w it is not used.
 345:../uvc.c      **** 		{MainsFreqReg,		//Reg1: the command register address1
 346:../uvc.c      **** 		 MainsFreqReg,		//Reg2: the command register address2
 347:../uvc.c      **** 		 2,					//UVCLn: the command length
 348:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 349:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 350:../uvc.c      **** 		 1,					//UVCMaxLo: the command maximum value low byte
 351:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 352:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 353:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 354:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 355:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 356:../uvc.c      **** 		 1,					//UVCDefVLo: the command default data value low byte
 357:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 358:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 359:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 360:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 361:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 362:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 363:../uvc.c      **** 		}; //main frequency, Reg1: ; Reg2: .
 364:../uvc.c      **** //volatile static SensorCtrl PUCHueC;
 365:../uvc.c      **** //{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 366:../uvc.c      **** volatile static SensorCtrl PUCHueC =
 367:../uvc.c      **** 		{HuectrlRegGr,		//Reg1: the command register address1
 368:../uvc.c      **** 		 HuectrlRegBlu,		//Reg2: the command register address2
 369:../uvc.c      **** 		 2,					//UVCLn: the command length
 370:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 371:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 372:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 373:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 374:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 375:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 376:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 377:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 378:../uvc.c      **** 		 128,				//UVCDefVLo: the command default data value low byte
 379:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 380:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 381:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 382:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 383:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 384:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 385:../uvc.c      **** 		}; //hue control, Reg1: ; Reg2: .
 386:../uvc.c      **** //		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 
 387:../uvc.c      **** //volatile static SensorCtrl PUCSaturation;
 388:../uvc.c      **** volatile static SensorCtrl PUCSaturation =
 389:../uvc.c      **** 		{SaturationRegR,		//Reg1: the command register address1
 390:../uvc.c      **** 		 SaturationRegB,		//Reg2: the command register address2
 391:../uvc.c      **** 		 2,					//UVCLn: the command length
 392:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 393:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 394:../uvc.c      **** 		 100,				//UVCMaxLo: the command maximum value low byte
 395:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 396:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 397:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 398:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 399:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 400:../uvc.c      **** 		 50,				//UVCDefVLo: the command default data value low byte
 401:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 402:../uvc.c      **** 		 50,				//UVCCurVLo: the command current data value low byte
 403:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 404:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 405:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 406:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 407:../uvc.c      **** 		}; //saturation, Reg1: ; Reg2: .
 408:../uvc.c      **** volatile static SensorCtrl PUCSharp =
 409:../uvc.c      **** 		{SharpnessEnReg,		//Reg1: the command register address1
 410:../uvc.c      **** 		 SharpnessGaiReg,		//Reg2: the command register address2
 411:../uvc.c      **** 		 2,					//UVCLn: the command length
 412:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 413:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 414:../uvc.c      **** 		 0xFF,				//UVCMaxLo: the command maximum value low byte
 415:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 416:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 417:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 418:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 419:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 420:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 421:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 422:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 423:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 424:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 425:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 426:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 427:../uvc.c      **** 		}; //sharpness, Reg1: 0-disable & 1-enable; Reg2: 0x00~0xFF.
 428:../uvc.c      **** //		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 
 429:../uvc.c      **** //volatile static SensorCtrl PUCWBMd;
 430:../uvc.c      **** volatile static SensorCtrl PUCWBMd = //not be used in 5MP B/W
 431:../uvc.c      **** 		{WBModeReg,		//Reg1: the command register address1
 432:../uvc.c      **** 		 WBModeReg,		//Reg2: the command register address2
 433:../uvc.c      **** 		 2,					//UVCLn: the command length
 434:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 435:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 436:../uvc.c      **** 		 5,					//UVCMaxLo: the command maximum value low byte
 437:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 438:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 439:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 440:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 441:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 442:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 443:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 444:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 445:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 446:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 447:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 448:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 449:../uvc.c      **** 		}; //write balance mode, Reg1: ; Reg2: .
 450:../uvc.c      **** //		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,5
 451:../uvc.c      **** //volatile static SensorCtrl PUCWBLC; //?
 452:../uvc.c      **** volatile static SensorCtrl PUCWBLC =  //not be used in 5MP B/W
 453:../uvc.c      **** 		{ManuBWBReg,		//Reg1: the command register address1
 454:../uvc.c      **** 		 ManuRWBReg,		//Reg2: the command register address2
 455:../uvc.c      **** 		 4,					//UVCLn: the command length
 456:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 457:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 458:../uvc.c      **** 		 64,				//UVCMaxLo: the command maximum value low byte
 459:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 460:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 461:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 462:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 463:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 464:../uvc.c      **** 		 32,				//UVCDefVLo: the command default data value low byte
 465:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 466:../uvc.c      **** 		 56,				//UVCCurVLo: the command current data value low byte
 467:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 468:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 469:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 470:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 471:../uvc.c      **** 		}; //write balance components, Reg1: ; Reg2: .
 472:../uvc.c      **** //		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 
 473:../uvc.c      **** //volatile static SensorCtrl PUCDZoom;
 474:../uvc.c      **** volatile static SensorCtrl PUCDZoom =
 475:../uvc.c      **** 		{DigZoomReg,		//Reg1: the command register address1
 476:../uvc.c      **** 		 DigZoomReg,		//Reg2: the command register address2
 477:../uvc.c      **** 		 2,					//UVCLn: the command length
 478:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 479:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 480:../uvc.c      **** 		 27,				//UVCMaxLo: the command maximum value low byte
 481:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 482:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 483:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 484:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 485:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 486:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 487:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 488:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 489:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 490:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 491:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 492:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 493:../uvc.c      **** 		}; //digital zoom, Reg1: ; Reg2: .
 494:../uvc.c      **** 
 495:../uvc.c      **** volatile static SensorCtrl *pPUCSenCtrl[0x10] = {
 496:../uvc.c      **** 	&PUCBLC,
 497:../uvc.c      **** 	&PUCBright,
 498:../uvc.c      **** 	&PUCContrast,
 499:../uvc.c      **** 	0, //&PUCGain (AGC?)
 500:../uvc.c      **** 	&PUCPLFreq,
 501:../uvc.c      **** 	&PUCHueC,
 502:../uvc.c      **** 	&PUCSaturation,
 503:../uvc.c      **** 	&PUCSharp,
 504:../uvc.c      **** 	0, //&PUCGamGain,
 505:../uvc.c      **** 	&PUCWBMd,
 506:../uvc.c      **** 	0, //UVCCtlID10,
 507:../uvc.c      **** 	&PUCWBLC,
 508:../uvc.c      **** 	0, //UVCCtlID12,
 509:../uvc.c      **** 	0, //UVCCtlID13,
 510:../uvc.c      **** 	&PUCDZoom,
 511:../uvc.c      **** 	0 //UVCCtlID15
 512:../uvc.c      **** };
 513:../uvc.c      **** 
 514:../uvc.c      **** /* the Camera terminal control request */
 515:../uvc.c      **** //volatile static SensorCtrl CTCAutoExMode;
 516:../uvc.c      **** //volatile static SensorCtrl CTCExposureTAbs;
 517:../uvc.c      **** //volatile static SensorCtrl CTCFocusRel;
 518:../uvc.c      **** //volatile static SensorCtrl CTCIrisAbs;
 519:../uvc.c      **** //volatile static SensorCtrl CTCOPZoomAbs;
 520:../uvc.c      **** 
 521:../uvc.c      **** /* the Extentsion control request */
 522:../uvc.c      **** volatile static SensorCtrl EXTShutter =
 523:../uvc.c      **** 		{ShutterReg,		//Reg1: the command register address1
 524:../uvc.c      **** 		 ExFinShutReg,		//Reg2: the command register address2
 525:../uvc.c      **** 		 2,					//UVCLn: the command length
 526:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 527:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 528:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 529:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 530:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 531:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 532:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 533:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 534:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 535:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 536:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 537:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 538:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 539:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 540:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 541:../uvc.c      **** 		}; //shutter control 0 ~ 0x12
 542:../uvc.c      **** volatile static SensorCtrl EXTSensUp =  //not be used in 5MP B/W
 543:../uvc.c      **** 		{SenseUpReg,		//Reg1: the command register address1
 544:../uvc.c      **** 		 SenseUpReg,		//Reg2: the command register address2
 545:../uvc.c      **** 		 2,					//UVCLn: the command length
 546:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 547:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 548:../uvc.c      **** 		 9,					//UVCMaxLo: the command maximum value low byte
 549:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 550:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 551:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 552:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 553:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 554:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 555:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 556:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 557:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 558:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 559:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 560:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 561:../uvc.c      **** 		};	// sense up control 0 ~ 0x09
 562:../uvc.c      **** 
 563:../uvc.c      **** // 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0
 564:../uvc.c      **** volatile static SensorCtrl EXTMirror =
 565:../uvc.c      **** 		{MirrModeReg,		//Reg1: the command register address1
 566:../uvc.c      **** 		 MirrModeReg,		//Reg2: the command register address2
 567:../uvc.c      **** 		 2,					//UVCLn: the command length
 568:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 569:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 570:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 571:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 572:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 573:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 574:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 575:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 576:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 577:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 578:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 579:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 580:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 581:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 582:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 583:../uvc.c      **** 		};	// mirror mode control 0 ~ 0x03
 584:../uvc.c      **** //		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0,
 585:../uvc.c      **** //volatile static SensorCtrl EXT3DnoiseReduceMode;
 586:../uvc.c      **** volatile static SensorCtrl EXT3DnoiseReduceMode = //2DNR mode
 587:../uvc.c      **** 		{NoiRedu3DModReg,		//Reg1: the command register address1
 588:../uvc.c      **** 		 NoiRedu3DModReg,		//Reg2: the command register address2
 589:../uvc.c      **** 		 2,					//UVCLn: the command length
 590:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 591:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 592:../uvc.c      **** 		 1,					//UVCMaxLo: the command maximum value low byte
 593:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 594:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 595:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 596:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 597:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 598:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 599:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 600:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 601:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 602:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 603:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 604:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 605:../uvc.c      **** 		};	// 3D noise reduce mode control
 606:../uvc.c      **** //		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32,
 607:../uvc.c      **** //volatile static SensorCtrl EXT3DNoiseLev;
 608:../uvc.c      **** volatile static SensorCtrl EXT3DNoiseLev =  //2DNR gain
 609:../uvc.c      **** 		{NoiRedu3DLevReg,		//Reg1: the command register address1
 610:../uvc.c      **** 		 NoiRedu3DLevReg,		//Reg2: the command register address2
 611:../uvc.c      **** 		 2,					//UVCLn: the command length
 612:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 613:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 614:../uvc.c      **** 		 64,				//UVCMaxLo: the command maximum value low byte
 615:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 616:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 617:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 618:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 619:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 620:../uvc.c      **** 		 32,				//UVCDefVLo: the command default data value low byte
 621:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 622:../uvc.c      **** 		 32,				//UVCCurVLo: the command current data value low byte
 623:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 624:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 625:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 626:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 627:../uvc.c      **** 		};	// 3D noise reduce level control
 628:../uvc.c      **** 
 629:../uvc.c      **** //		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0,
 630:../uvc.c      **** //volatile static SensorCtrl EXTDayNightMode;
 631:../uvc.c      **** volatile static SensorCtrl EXTDayNightMode =
 632:../uvc.c      **** 		{DayNightModReg,		//Reg1: the command register address1
 633:../uvc.c      **** 		 DayNightModReg,		//Reg2: the command register address2
 634:../uvc.c      **** 		 2,					//UVCLn: the command length
 635:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 636:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 637:../uvc.c      **** 		 2,					//UVCMaxLo: the command maximum value low byte
 638:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 639:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 640:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 641:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 642:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 643:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 644:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 645:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 646:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 647:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 648:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 649:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 650:../uvc.c      **** 		};	// day night mode control
 651:../uvc.c      **** //{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 652:../uvc.c      **** //volatile static SensorCtrl EXTDayNightdely;
 653:../uvc.c      **** volatile static SensorCtrl EXTDayNightdely =
 654:../uvc.c      **** 		{DayNightDlyReg,		//Reg1: the command register address1
 655:../uvc.c      **** 		 DayNightDlyReg,		//Reg2: the command register address2
 656:../uvc.c      **** 		 2,					//UVCLn: the command length
 657:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 658:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 659:../uvc.c      **** 		 63,				//UVCMaxLo: the command maximum value low byte
 660:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 661:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 662:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 663:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 664:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 665:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 666:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 667:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 668:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 669:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 670:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 671:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 672:../uvc.c      **** 		};	// day night delay control
 673:../uvc.c      **** //{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 674:../uvc.c      **** //volatile static SensorCtrl EXTDayNightlev;
 675:../uvc.c      **** volatile static SensorCtrl EXTDayNightlev =
 676:../uvc.c      **** 		{DayNightLevReg,		//Reg1: the command register address1
 677:../uvc.c      **** 		 DayNightLevReg,		//Reg2: the command register address2
 678:../uvc.c      **** 		 2,					//UVCLn: the command length
 679:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 680:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 681:../uvc.c      **** 		 100,				//UVCMaxLo: the command maximum value low byte
 682:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 683:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 684:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 685:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 686:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 687:../uvc.c      **** 		 16,				//UVCDefVLo: the command default data value low byte
 688:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 689:../uvc.c      **** 		 16,				//UVCCurVLo: the command current data value low byte
 690:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 691:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 692:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 693:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 694:../uvc.c      **** 		};	// day night level control
 695:../uvc.c      **** //{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 696:../uvc.c      **** //volatile static SensorCtrl EXTNightDaylev;
 697:../uvc.c      **** volatile static SensorCtrl EXTNightDaylev =
 698:../uvc.c      **** 		{NightDayLevReg,		//Reg1: the command register address1
 699:../uvc.c      **** 		 NightDayLevReg,		//Reg2: the command register address2
 700:../uvc.c      **** 		 2,					//UVCLn: the command length
 701:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 702:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 703:../uvc.c      **** 		 100,				//UVCMaxLo: the command maximum value low byte
 704:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 705:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 706:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 707:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 708:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 709:../uvc.c      **** 		 16,				//UVCDefVLo: the command default data value low byte
 710:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 711:../uvc.c      **** 		 16,				//UVCCurVLo: the command current data value low byte
 712:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 713:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 714:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 715:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 716:../uvc.c      **** 		};	// night day level control
 717:../uvc.c      **** //{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 718:../uvc.c      **** volatile static SensorCtrl EXTAexModGainlev =
 719:../uvc.c      **** 		{AExModeReg,		//Reg1: the command register address1
 720:../uvc.c      **** 		 AExAGCReg,			//Reg2: the command register address2
 721:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 722:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 723:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 724:../uvc.c      **** 		 127,				//UVCMaxLo: the command maximum value low byte
 725:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 726:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 727:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 728:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 729:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 730:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 731:../uvc.c      **** 		 63, 				//UVCDefVHi: the command default data value high byte
 732:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 733:../uvc.c      **** 		 63,				//UVCCurVHi: the command current data value high byte
 734:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 735:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 736:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 737:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 738:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 739:../uvc.c      **** //{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 740:../uvc.c      **** //volatile static SensorCtrl EXTExpReflev;
 741:../uvc.c      **** volatile static SensorCtrl EXTExpReflev =
 742:../uvc.c      **** 		{AExReferleveReg,		//Reg1: the command register address1
 743:../uvc.c      **** 		 AExReferleveReg,		//Reg2: the command register address2
 744:../uvc.c      **** 		 2,					//UVCLn: the command length
 745:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 746:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 747:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 748:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 749:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 750:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 751:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 752:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 753:../uvc.c      **** 		 60,				//UVCDefVLo: the command default data value low byte
 754:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 755:../uvc.c      **** 		 60,				//UVCCurVLo: the command current data value low byte
 756:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 757:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 758:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 759:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 760:../uvc.c      **** 		};	// AEX reference level control
 761:../uvc.c      **** //{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 762:../uvc.c      **** //volatile static SensorCtrl EXTCamMode;
 763:../uvc.c      **** volatile static SensorCtrl EXTCamMode =  //not be used
 764:../uvc.c      **** 		{SensorModeReg,		//Reg1: the command register address1
 765:../uvc.c      **** 		 SensorModeReg,		//Reg2: the command register address2
 766:../uvc.c      **** 		 2,					//UVCLn: the command length
 767:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 768:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 769:../uvc.c      **** 		 6,					//UVCMaxLo: the command maximum value low byte
 770:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 771:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 772:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 773:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 774:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 775:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 776:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 777:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 778:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 779:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 780:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 781:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 782:../uvc.c      **** 		};	// sensor mode control ???
 783:../uvc.c      **** //volatile static SensorCtrl EXTSnapshot; ???
 784:../uvc.c      **** //{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 785:../uvc.c      **** //volatile static SensorCtrl EXTSensorPare;
 786:../uvc.c      **** volatile static SensorCtrl EXTSensorPare = //not be used
 787:../uvc.c      **** 		{SeveParsReg,		//Reg1: the command register address1
 788:../uvc.c      **** 		 SeveParsReg,		//Reg2: the command register address2
 789:../uvc.c      **** 		 2,					//UVCLn: the command length
 790:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 791:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 792:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 793:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 794:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 795:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 796:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 797:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 798:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 799:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 800:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 801:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 802:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 803:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 804:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 805:../uvc.c      **** 		};	// sensor mode control ???
 806:../uvc.c      **** //{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 807:../uvc.c      **** //volatile static SensorCtrl EXTI2Ccmd;???
 808:../uvc.c      **** volatile static SensorCtrl EXTI2Ccmd = //not be used
 809:../uvc.c      **** 		{0,/*no-fix register*/		//Reg1: the command register address1
 810:../uvc.c      **** 		 0,/*no-fix register*/		//Reg2: the command register address2
 811:../uvc.c      **** 		 11,				//UVCLn: the command length
 812:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 813:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 814:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 815:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 816:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 817:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 818:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 819:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 820:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 821:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 822:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 823:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 824:../uvc.c      **** 		 0,/*no-fix address*/ 		//DeviceAdd: the device address
 825:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 826:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 827:../uvc.c      **** 		};	// sensor mode control ???
 828:../uvc.c      **** volatile static SensorCtrl EXTBLCWinPos =
 829:../uvc.c      **** 		{BLCPosReg,			//Reg1: the command register address1
 830:../uvc.c      **** 		 BLCSizeReg,		//Reg2: the command register address2
 831:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 832:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 833:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 834:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 835:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 836:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 837:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 838:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 839:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 840:../uvc.c      **** 		 0x66,				//UVCDefVLo: the command default data value low byte
 841:../uvc.c      **** 		 0x66, 				//UVCDefVHi: the command default data value high byte
 842:../uvc.c      **** 		 0x66,				//UVCCurVLo: the command current data value low byte
 843:../uvc.c      **** 		 0x66,				//UVCCurVHi: the command current data value high byte
 844:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 845:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 846:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 847:../uvc.c      **** 		}; //BLC position: [7:4]:Top/bottom [3:0]:left/right; BLC size: [7:4]:height [3:0]:width.
 848:../uvc.c      **** //{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 849:../uvc.c      **** volatile static SensorCtrl EXTBLCWeight =
 850:../uvc.c      **** 		{BLCModeRegGain,			//Reg1: the command register address1
 851:../uvc.c      **** 		 BLCModeRegGain,			//Reg2: the command register address2
 852:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 853:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 854:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 855:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 856:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 857:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 858:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 859:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 860:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 861:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 862:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 863:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 864:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 865:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 866:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 867:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 868:../uvc.c      **** 		}; //
 869:../uvc.c      **** //{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 870:../uvc.c      **** //volatile static SensorCtrl EXTBLCGrid;
 871:../uvc.c      **** volatile static SensorCtrl EXTBLCGrid =
 872:../uvc.c      **** 		{BLCModeRegAct,			//Reg1: the command register address1
 873:../uvc.c      **** 		 BLCModeRegAct,			//Reg2: the command register address2
 874:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 875:../uvc.c      **** 		 1,					//UVCMinLo: the command minimum value low byte
 876:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 877:../uvc.c      **** 		 2,		  			//UVCMaxLo: the command maximum value low byte
 878:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 879:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 880:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 881:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 882:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 883:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 884:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 885:../uvc.c      **** 		 0, 				//UVCCurVLo: the command current data value low byte
 886:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 887:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 888:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 889:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 890:../uvc.c      **** 		}; //
 891:../uvc.c      **** 
 892:../uvc.c      **** volatile static SensorCtrl EXTShutlev =
 893:../uvc.c      **** 		{0x12/*ShutterFineReg*/,		//Reg1: the command register address1
 894:../uvc.c      **** 		 0x12/*ShutterFineReg*/,			//Reg2: the command register address2
 895:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 896:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 897:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 898:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 899:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 900:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 901:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 902:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 903:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 904:../uvc.c      **** 		 63,				//UVCDefVLo: the command default data value low byte
 905:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 906:../uvc.c      **** 		 63,					//UVCCurVLo: the command current data value low byte
 907:../uvc.c      **** 		 0,				//UVCCurVHi: the command current data value high byte
 908:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 909:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 910:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 911:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 912:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 913:../uvc.c      **** 
 914:../uvc.c      **** volatile static SensorCtrl EXTExHyster =
 915:../uvc.c      **** 		{ExHysterReg,			//Reg1: the command register address1
 916:../uvc.c      **** 		 ExHysterReg,			//Reg2: the command register address2
 917:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 918:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 919:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 920:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 921:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 922:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 923:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 924:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 925:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 926:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 927:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 928:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 929:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 930:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 931:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 932:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 933:../uvc.c      **** 		}; //
 934:../uvc.c      **** 
 935:../uvc.c      **** volatile static SensorCtrl EXTExCtrlSped =
 936:../uvc.c      **** 		{ExCtrlSpdReg,			//Reg1: the command register address1
 937:../uvc.c      **** 		 ExCtrlSpdReg,			//Reg2: the command register address2
 938:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 939:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 940:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 941:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 942:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 943:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 944:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 945:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 946:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 947:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 948:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 949:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 950:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 951:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 952:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 953:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 954:../uvc.c      **** 		}; //
 955:../uvc.c      **** 
 956:../uvc.c      **** volatile static SensorCtrl EXTEnhanceMode =
 957:../uvc.c      **** 		{ExEnhanceModeReg,			//Reg1: the command register address1
 958:../uvc.c      **** 		 ExEnhanceModeReg,			//Reg2: the command register address2
 959:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 960:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 961:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 962:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 963:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 964:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 965:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 966:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 967:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 968:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 969:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 970:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 971:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 972:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 973:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 974:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 975:../uvc.c      **** 		}; //
 976:../uvc.c      **** 
 977:../uvc.c      **** volatile static SensorCtrl EXTEnhanceGain =
 978:../uvc.c      **** 		{ExEnhanceGainReg,			//Reg1: the command register address1
 979:../uvc.c      **** 		 ExEnhanceGainReg,			//Reg2: the command register address2
 980:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 981:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 982:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 983:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 984:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 985:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 986:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 987:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 988:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 989:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 990:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 991:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 992:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 993:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 994:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 995:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 996:../uvc.c      **** 		}; //
 997:../uvc.c      **** 
 998:../uvc.c      **** volatile static SensorCtrl EXTEnhanceSTED =
 999:../uvc.c      **** 		{ExEnhanceStartReg,			//Reg1: the command register address1
1000:../uvc.c      **** 		 ExEnhanceEndReg,			//Reg2: the command register address2
1001:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1002:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1003:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1004:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
1005:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1006:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1007:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1008:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1009:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1010:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
1011:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1012:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
1013:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1014:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1015:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1016:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1017:../uvc.c      **** 		}; //
1018:../uvc.c      **** 
1019:../uvc.c      **** volatile static SensorCtrl EXT2DNRGain =
1020:../uvc.c      **** 		{Ex2DNREnableReg,		//Reg1: the command register address1
1021:../uvc.c      **** 		 Ex2DNRGainReg,			//Reg2: the command register address2
1022:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1023:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1024:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1025:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
1026:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1027:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1028:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1029:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1030:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1031:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
1032:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1033:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
1034:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1035:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1036:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1037:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1038:../uvc.c      **** 		}; //
1039:../uvc.c      **** 
1040:../uvc.c      **** volatile static SensorCtrl EXT2DNRSTED =
1041:../uvc.c      **** 		{Ex2DNRStartReg,			//Reg1: the command register address1
1042:../uvc.c      **** 		 Ex2DNREndReg,			//Reg2: the command register address2
1043:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1044:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1045:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1046:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
1047:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1048:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1049:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1050:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1051:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1052:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
1053:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1054:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
1055:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1056:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1057:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1058:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1059:../uvc.c      **** 		}; //
1060:../uvc.c      **** 
1061:../uvc.c      **** volatile static SensorCtrl EXTGammaCor =
1062:../uvc.c      **** 		{ExGammaReg,			//Reg1: the command register address1
1063:../uvc.c      **** 		 ExGammaReg,			//Reg2: the command register address2
1064:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1065:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1066:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1067:../uvc.c      **** 		 0x10,				//UVCMaxLo: the command maximum value low byte
1068:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1069:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1070:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1071:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1072:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1073:../uvc.c      **** 		 0x00,				//UVCDefVLo: the command default data value low byte
1074:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1075:../uvc.c      **** 		 0x00,				//UVCCurVLo: the command current data value low byte
1076:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1077:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1078:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1079:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1080:../uvc.c      **** 		}; //
1081:../uvc.c      **** 
1082:../uvc.c      **** volatile static SensorCtrl EXTAGCMaxLimit =
1083:../uvc.c      **** 		{AGCMaxLimtReg,			//Reg1: the command register address1
1084:../uvc.c      **** 		 AGCMaxLimtReg,			//Reg2: the command register address2
1085:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1086:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1087:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1088:../uvc.c      **** 		 0x10,				//UVCMaxLo: the command maximum value low byte
1089:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1090:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1091:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1092:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1093:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1094:../uvc.c      **** 		 0x00,				//UVCDefVLo: the command default data value low byte
1095:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1096:../uvc.c      **** 		 0x00,				//UVCCurVLo: the command current data value low byte
1097:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1098:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1099:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1100:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1101:../uvc.c      **** 		}; //
1102:../uvc.c      **** 
1103:../uvc.c      **** volatile static SensorCtrl *pEXTSenCtrl[0x40] = {//Extension control
1104:../uvc.c      **** 		&EXTShutter,
1105:../uvc.c      **** 		&EXTSensUp,
1106:../uvc.c      **** 		&EXTMirror,
1107:../uvc.c      **** 		&EXT3DnoiseReduceMode,
1108:../uvc.c      **** 		&EXT3DNoiseLev,
1109:../uvc.c      **** 		&EXTDayNightMode,
1110:../uvc.c      **** 		&EXTDayNightdely,
1111:../uvc.c      **** 		&EXTDayNightlev,
1112:../uvc.c      **** 		&EXTNightDaylev,
1113:../uvc.c      **** 		&EXTAexModGainlev,
1114:../uvc.c      **** 		&EXTExpReflev,
1115:../uvc.c      **** 		&EXTShutlev,
1116:../uvc.c      **** 		&EXTCamMode,
1117:../uvc.c      **** 		0, //&EXTSnapshot,
1118:../uvc.c      **** 		&EXTSensorPare,
1119:../uvc.c      **** 		&EXTI2Ccmd,
1120:../uvc.c      **** 		0, //&Ext1CtlID0 = 0x20,
1121:../uvc.c      **** 		0, //&Ext1CtlID1,
1122:../uvc.c      **** 		0, //&Ext1CtlID2,
1123:../uvc.c      **** 		0, //&Ext1CtlID3,
1124:../uvc.c      **** 		&EXTBLCWinPos,   		// back light compensation range
1125:../uvc.c      **** 		&EXTBLCWeight,  	    // back light compensation weight (gain) factor
1126:../uvc.c      **** 		&EXTBLCGrid,    	// back light compensation grid state
1127:../uvc.c      **** 		&EXTExHyster,       // exposure hystereses level
1128:../uvc.c      **** 		&EXTExCtrlSped,     // exposure control speed level
1129:../uvc.c      **** 		&EXTEnhanceMode,    // edge enhancement mode
1130:../uvc.c      **** 		&EXTEnhanceGain,    // edge enhancement gain level
1131:../uvc.c      **** 		&EXTEnhanceSTED,    // edge enhancement start/end level
1132:../uvc.c      **** 		&EXT2DNRGain,       // 2D noise reduction Gain level
1133:../uvc.c      **** 		&EXT2DNRSTED,       // 2D noise reduction start/end level
1134:../uvc.c      **** 		&EXTGammaCor,		// Gamma correction
1135:../uvc.c      **** 		&EXTAGCMaxLimit, 	// AGC Maximum Gain limitation &Ext1AGCMaxLimetCtlID15,
1136:../uvc.c      **** 		0
1137:../uvc.c      **** };
1138:../uvc.c      **** 
1139:../uvc.c      **** #endif //end of the new control structure
1140:../uvc.c      **** 
1141:../uvc.c      **** #ifndef CAM720
1142:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
1143:../uvc.c      **** #else
1144:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
1145:../uvc.c      **** #endif
1146:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
1147:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
1148:../uvc.c      **** 
1149:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
1150:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
1151:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
1152:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
1153:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
1154:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    0,    0,    0xff, 0xff, 1, 0, 3
1155:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   0x80,
1156:../uvc.c      **** 		{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
1157:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
1158:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
1159:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
1160:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
1161:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
1162:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1163:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1164:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1165:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1166:../uvc.c      **** };
1167:../uvc.c      **** 
1168:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
1169:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
1170:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
1171:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
1172:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
1173:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
1174:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
1175:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
1176:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
1177:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
1178:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
1179:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
1180:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
1181:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
1182:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
1183:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1184:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1185:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1186:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1187:../uvc.c      **** };
1188:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
1189:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
1190:../uvc.c      **** static uint16_t ShutSp[16]={33333, 16667, 8333, 4000, 2000, 1000, 500, 200, 100, 10, 0}; // in micr
1191:../uvc.c      **** static uint8_t curFlag[64]={0}; //the curFlag for each controls current records available. 0: unabl
1192:../uvc.c      **** /*
1193:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
1194:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
1195:../uvc.c      ****  */
1196:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
1197:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
1198:../uvc.c      **** };
1199:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
1200:../uvc.c      **** 		0
1201:../uvc.c      **** };
1202:../uvc.c      **** 
1203:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
1204:../uvc.c      **** 
1205:../uvc.c      **** void I2CCmdHandler(){
1206:../uvc.c      **** 	uint8_t buf[2];
1207:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
1208:../uvc.c      **** 	CmdType = I2CCMDArry[0];
1209:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
1210:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
1211:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
1212:../uvc.c      **** 	uint8_t i;
1213:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
1214:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
1215:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
1216:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
1217:../uvc.c      **** 	{
1218:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
1219:../uvc.c      **** 		if(is60Hz==CyFalse)
1220:../uvc.c      **** 			{
1221:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
1222:../uvc.c      **** 			}
1223:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
1224:../uvc.c      **** 
1225:../uvc.c      **** 	}
1226:../uvc.c      **** 	if(CmdType == 0)//I2C read
1227:../uvc.c      **** 	{
1228:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
1229:../uvc.c      **** #if 0 //for debugging
1230:../uvc.c      **** 		/* test still image operation */
1231:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
1232:../uvc.c      **** 			snapButFlag = 0; //press
1233:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
1234:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
1235:../uvc.c      **** 			snapButFlag = 0xf; //release
1236:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
1237:../uvc.c      **** 		}
1238:../uvc.c      **** 
1239:../uvc.c      **** 		/* end of the test */
1240:../uvc.c      **** #endif
1241:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
1242:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
1243:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
1244:../uvc.c      **** 				if(CmdDataLen == 2){
1245:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
1246:../uvc.c      **** 				}
1247:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
1248:../uvc.c      **** 		}else{//not support currently
1249:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
1250:../uvc.c      **** 		}
1251:../uvc.c      **** 	}else if(CmdType == 1){
1252:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
1253:../uvc.c      **** 			if(CmdRegLen == 2){
1254:../uvc.c      **** 				for(i = 0; i<4; i++)
1255:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
1256:../uvc.c      **** 			}
1257:../uvc.c      **** 			else{
1258:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
1259:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
1260:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
1261:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
1262:../uvc.c      **** 				}
1263:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
1264:../uvc.c      **** 			}
1265:../uvc.c      **** 		}else{//not support currently
1266:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
1267:../uvc.c      **** 		}
1268:../uvc.c      **** 
1269:../uvc.c      **** 	}
1270:../uvc.c      **** }
1271:../uvc.c      **** 
1272:../uvc.c      **** /************************************
1273:../uvc.c      ****  * set Iris mode
1274:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
1275:../uvc.c      ****  */
1276:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
1277:../uvc.c      **** 	uint8_t dataIdx = 0;
1278:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
1280:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
1281:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1282:../uvc.c      **** }
1283:../uvc.c      **** 
1284:../uvc.c      **** 
1285:../uvc.c      **** 
1286:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
1287:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
1288:../uvc.c      **** 	uint16_t NumLn;
1289:../uvc.c      **** 	uint16_t fRate, shutTm;
1290:../uvc.c      **** 	uint8_t LnVal;
1291:../uvc.c      **** 	switch (Data){
1292:../uvc.c      **** 	case 1:
1293:../uvc.c      **** 	case 2:
1294:../uvc.c      **** 	case 3:
1295:../uvc.c      **** 	case 4:
1296:../uvc.c      **** 	case 5:
1297:../uvc.c      **** 		shutTm = ShutSp[Data-1];
1298:../uvc.c      **** 		fRate = 30;
1299:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
1300:../uvc.c      **** 		if(NumLn > 1944)
1301:../uvc.c      **** 			NumLn =1944;
1302:../uvc.c      **** 		else if(NumLn < 8)
1303:../uvc.c      **** 			NumLn = 8;
1304:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
1305:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
1306:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
1307:../uvc.c      **** 		break;
1308:../uvc.c      **** 	case 6:
1309:../uvc.c      **** 	case 7:
1310:../uvc.c      **** 	case 8:
1311:../uvc.c      **** 	case 9:
1312:../uvc.c      **** 	case 10:
1313:../uvc.c      **** 		shutTm = ShutSp[Data-1];
1314:../uvc.c      **** 		fRate = 30;
1315:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
1316:../uvc.c      **** 		if(NumLn > 1944)
1317:../uvc.c      **** 			NumLn =1944;
1318:../uvc.c      **** 		else if(NumLn < 8)
1319:../uvc.c      **** 			NumLn = 8;
1320:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
1321:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
1322:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
1323:../uvc.c      **** 		break;
1324:../uvc.c      **** 	case 0: //auto
1325:../uvc.c      **** 	default:
1326:../uvc.c      **** 		*pAxMode = 0x00;	// auto
1327:../uvc.c      **** 		LnVal = 1;
1328:../uvc.c      **** 		break;
1329:../uvc.c      **** 	}
1330:../uvc.c      **** 	return LnVal;
1331:../uvc.c      **** }
1332:../uvc.c      **** 
1333:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
1334:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
1335:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1336:../uvc.c      ****     uint16_t readCount;
1337:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID, AxMode;
1338:../uvc.c      ****     uint8_t devAdd;
1339:../uvc.c      ****     //locCtrlID = CtrlID-EXUAOFFSET+4;
1340:../uvc.c      ****     if(CtrlID >= 0x10){//the extension command over 32.
1341:../uvc.c      ****     	RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1;//ExUCtrlParArry[locCtrlID][0];
1342:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
1343:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
1344:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
1345:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
1346:../uvc.c      ****     	//		CtrlID, RegAdd0, RegAdd1, devAdd, Len);
1347:../uvc.c      ****     }else{
1348:../uvc.c      **** 		RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1;//CtrlParArry[CtrlID][0];
1349:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
1350:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
1351:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
1352:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
1353:../uvc.c      ****     	//		CtrlID, RegAdd0, RegAdd1, devAdd, Len);
1354:../uvc.c      ****     }
1355:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
1356:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1357:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
1358:../uvc.c      **** #endif
1359:../uvc.c      ****     reqData = bRequest;
1360:../uvc.c      ****     /*
1361:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
1362:../uvc.c      ****      */
1363:../uvc.c      ****     //if (0 && (CtrlID == ExtAexModCtlID9)){
1364:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
1365:../uvc.c      ****     	//goto EndofSet;
1366:../uvc.c      ****     //}
1367:../uvc.c      ****     switch (bRequest)
1368:../uvc.c      **** 		 {
1369:../uvc.c      **** 
1370:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
1371:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1372:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1373:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1374:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1375:../uvc.c      **** 			  break;
1376:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1377:../uvc.c      **** 
1378:../uvc.c      **** 		 	 if(CtrlID >= 0x10/*EXUAOFFSET*/){
1379:../uvc.c      **** 				 switch(CtrlID)
1380:../uvc.c      **** 				 {
1381:../uvc.c      **** 					 case Ext1BLCGridCtlID6:
1382:../uvc.c      **** 						 if(curFlag[CtrlID]){
1383:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo; //ExUCtrlParArry[CtrlID-0x20][13];/
1384:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi; //ExUCtrlParArry[CtrlID-0x20][14];
1385:../uvc.c      **** 						 }else{
1386:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1387:../uvc.c      **** 							if(Data0&0x80)
1388:../uvc.c      **** 								glEp0Buffer[0] = 1;
1389:../uvc.c      **** 							else
1390:../uvc.c      **** 								glEp0Buffer[0] = 0;
1391:../uvc.c      **** 							pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1392:../uvc.c      **** 							glEp0Buffer[1] = 0; //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;ExUCtrlParArry[CtrlID-0x20][14];
1393:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
1394:../uvc.c      **** 						 }
1395:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1396:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1397:../uvc.c      **** 						 break;
1398:../uvc.c      **** 			 	 	 case ExtAexModCtlID9:
1399:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1400:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1401:../uvc.c      **** 							 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1402:../uvc.c      **** 			 	 		 }else{
1403:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1404:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0]; // keep the original data.
1405:../uvc.c      **** 			 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // 1:0 for Aex Mode
1406:../uvc.c      **** 			 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
1407:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
1408:../uvc.c      **** 			 	 			//curFlag[CtrlID] = CyTrue;
1409:../uvc.c      **** 			 	 		 }
1410:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1411:../uvc.c      **** 						 glEp0Buffer[3] = 0;
1412:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1413:../uvc.c      **** 						 sendData1 = glEp0Buffer[2];
1414:../uvc.c      **** 						 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], pEXTSenCtrl[C
1415:../uvc.c      **** 						 break;
1416:../uvc.c      **** 				 	 case ExtCamMCtlID12: //EXTCamMode
1417:../uvc.c      **** #if 0 //not be used
1418:../uvc.c      **** 						 sendData = CtrlParArry[CtrlID][13];
1419:../uvc.c      **** 
1420:../uvc.c      **** 						 if(CamMode == 1){//720p
1421:../uvc.c      **** 							if(sendData >= 3){
1422:../uvc.c      **** 								CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, s
1423:../uvc.c      **** 								sendData = 0; //set back to default
1424:../uvc.c      **** 								CtrlParArry[CtrlID][13] = 0;
1425:../uvc.c      **** 							}
1426:../uvc.c      **** 							sendData += 4;
1427:../uvc.c      **** 						 }
1428:../uvc.c      **** 						//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, s
1429:../uvc.c      **** 						 glEp0Buffer[0] = sendData;
1430:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1431:../uvc.c      **** #endif
1432:../uvc.c      **** 						 break;
1433:../uvc.c      **** 				 	 case ExtI2CCtlID15:
1434:../uvc.c      **** 				 		 for(idx=0; idx<Len; idx++){
1435:../uvc.c      **** 				 			glEp0Buffer[idx] = I2CCMDArry[idx];
1436:../uvc.c      **** 				 		 }
1437:../uvc.c      **** 				 		 sendData = glEp0Buffer[9];
1438:../uvc.c      **** 				 		 sendData1 = glEp0Buffer[10];
1439:../uvc.c      **** 	#ifdef USB_DEBUG_PRINT
1440:../uvc.c      **** 				 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x
1441:../uvc.c      **** 				 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
1442:../uvc.c      **** 				 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
1443:../uvc.c      **** 	#endif
1444:../uvc.c      **** 				 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
1445:../uvc.c      **** 				 		 {
1446:../uvc.c      **** 				 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDAr
1447:../uvc.c      **** 				 		 }
1448:../uvc.c      **** 				 		 break;
1449:../uvc.c      **** 			 	 	 case Ext1ExCtrlSpeedCtlID8:
1450:../uvc.c      **** 			 	 		 sendData = SensorGetControl(RegAdd1, devAdd);
1451:../uvc.c      **** 			 	 		// sendData &= 0x70;
1452:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];// keep original data.
1453:../uvc.c      **** 	 	 				 glEp0Buffer[0] = (sendData >> 4)&0xF; // bit6:4 are significant bits. bit7 is fine shutter
1454:../uvc.c      **** 	 	 				 glEp0Buffer[1] = 0;
1455:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
1456:../uvc.c      **** 	 	 				 sendData = glEp0Buffer[0];
1457:../uvc.c      **** 	 	 				 sendData1 = glEp0Buffer[1];
1458:../uvc.c      **** 	 	 				 break;
1459:../uvc.c      **** 				 	 case Ext1BLCRangeCtlID4:
1460:../uvc.c      **** 	 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1461:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1462:../uvc.c      **** 	 	 				 glEp0Buffer[1] = SensorGetControl(RegAdd1, devAdd);
1463:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
1464:../uvc.c      **** 	 	 				 sendData = glEp0Buffer[0];
1465:../uvc.c      **** 	 	 				 sendData1 = glEp0Buffer[1];
1466:../uvc.c      **** 	 	 				 break;
1467:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
1468:../uvc.c      **** 				 	 case ExtShutCtlID0:
1469:../uvc.c      **** 				 	 case ExtCtlShutlevCtlID11:
1470:../uvc.c      **** 				 		 /* the exposure hysteresis to gamma correction */
1471:../uvc.c      **** 			 	 	 case Ext1ExHysterCtlID7:
1472:../uvc.c      **** 			 	 	 case Ext1EnhanceModeCtlID9:
1473:../uvc.c      **** 			 	 	 case Ext1EnhanceGainCtlID10:
1474:../uvc.c      **** 			 	 	 case Ext1EnhanceStarEndCtlID11:
1475:../uvc.c      **** 			 	 	 case Ext12DNRGainEnblCtlID12:
1476:../uvc.c      **** 			 	 	 case Ext12DNRGainStarEndCtlID13://4bytes
1477:../uvc.c      **** 			 	 	 case Ext1GammaCorCtlID14:
1478:../uvc.c      **** 			 	 	 case Ext1AGCMaxLimetCtlID15:
1479:../uvc.c      **** 					 case ExtExRefCtlID10:
1480:../uvc.c      **** 			 	 	 default:
1481:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1482:../uvc.c      **** 			 	 			 if(Len == 2)
1483:../uvc.c      **** 			 	 			 {
1484:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1485:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1486:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1487:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1488:../uvc.c      **** 			 	 			 }else if(Len == 4){
1489:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1490:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1491:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1492:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1493:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1494:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1495:../uvc.c      **** 			 	 			 }
1496:../uvc.c      **** 			 	 		 }else{
1497:../uvc.c      **** 			 	 			 if(Len == 2)
1498:../uvc.c      **** 			 	 			 {
1499:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1500:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1501:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1502:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
1503:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1504:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1505:../uvc.c      **** 			 	 			 }else if(Len == 4){
1506:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1507:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1508:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
1509:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
1510:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1511:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1512:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1513:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1514:../uvc.c      **** 			 	 			 }
1515:../uvc.c      **** 			 	 			 //curFlag[CtrlID] = CyTrue;
1516:../uvc.c      **** 			 	 		 }
1517:../uvc.c      **** 			 	 		 break;
1518:../uvc.c      **** 			 	 }
1519:../uvc.c      **** 		 	 }
1520:../uvc.c      **** 		 	 else{
1521:../uvc.c      **** 				 switch(CtrlID)
1522:../uvc.c      **** 				 {
1523:../uvc.c      **** 					 case BrgtCtlID1:
1524:../uvc.c      **** 						 /* cancel for 5MP w/b camera
1525:../uvc.c      **** 						 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
1526:../uvc.c      **** 						 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
1527:../uvc.c      **** 						 if (Data1&0x2){ //check the sign bit (bit1)
1528:../uvc.c      **** 							 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
1529:../uvc.c      **** 						 }else{
1530:../uvc.c      **** 							 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
1531:../uvc.c      **** 						 }
1532:../uvc.c      **** 						 glEp0Buffer[0] = Data1;
1533:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1534:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1535:../uvc.c      **** 						 */
1536:../uvc.c      **** 						 if(curFlag[CtrlID]){
1537:../uvc.c      **** 							Data0 = pPUCSenCtrl[CtrlID]->UVCCurVLo; // CtrlParArry[CtrlID][13];
1538:../uvc.c      **** 						 }else{
1539:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1540:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1541:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
1542:../uvc.c      **** 						 }
1543:../uvc.c      **** 						 //Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode(
1544:../uvc.c      **** 						 /*//new implementation 8/23/2016
1545:../uvc.c      **** 						 if(Data0&0x80){
1546:../uvc.c      **** 							  Data0 = ~Data0;
1547:../uvc.c      **** 						  }else{
1548:../uvc.c      **** 							  Data0 = Data0 + 0x80;
1549:../uvc.c      **** 						  }
1550:../uvc.c      **** 						  */
1551:../uvc.c      **** 						 glEp0Buffer[0] = Data0;
1552:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1553:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1554:../uvc.c      **** 						 break;
1555:../uvc.c      **** 					 case HueCtlID5:
1556:../uvc.c      **** 						 if(curFlag[CtrlID]){
1557:../uvc.c      **** 							Data0 = pPUCSenCtrl[CtrlID]->UVCCurVLo; //CtrlParArry[CtrlID][13];
1558:../uvc.c      **** 						 }else{
1559:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1560:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1561:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
1562:../uvc.c      **** 						 }
1563:../uvc.c      **** 
1564:../uvc.c      **** 						 glEp0Buffer[0] = Data0 + GREEN_BASE;
1565:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1566:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1567:../uvc.c      **** 						 break;
1568:../uvc.c      **** 					 case MFreqCtlID4:
1569:../uvc.c      **** 
1570:../uvc.c      **** 						 if(curFlag[CtrlID]){
1571:../uvc.c      **** 
1572:../uvc.c      **** 							 if(is60Hz)
1573:../uvc.c      **** 								 glEp0Buffer[0] = 0;//CtrlParArry[CtrlID][13];//ext_control array;
1574:../uvc.c      **** 							 else
1575:../uvc.c      **** 								 glEp0Buffer[0] = 1;
1576:../uvc.c      **** 
1577:../uvc.c      **** 							 glEp0Buffer[1] = 0; //CtrlParArry[CtrlID][14];
1578:../uvc.c      **** 						 }else{
1579:../uvc.c      **** 							Data0 = SensorGetControl(0x1, devAdd); //get resolution bit7 for main frequency information
1580:../uvc.c      **** 							glEp0Buffer[0] = (Data0&0x80)>>7;
1581:../uvc.c      **** 							//glEp0Buffer[0]++;
1582:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1583:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
1584:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
1585:../uvc.c      **** 						 }
1586:../uvc.c      **** 
1587:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1588:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1589:../uvc.c      **** 						 break;
1590:../uvc.c      **** 					 case WBTLevCtlID11:
1591:../uvc.c      **** 						 if(curFlag[CtrlID]){
1592:../uvc.c      **** 							 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
1593:../uvc.c      **** 							 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
1594:../uvc.c      **** 						 }else{
1595:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1596:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
1597:../uvc.c      **** 							glEp0Buffer[0] = Data0;
1598:../uvc.c      **** 							WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
1599:../uvc.c      **** 							glEp0Buffer[2] = Data1;
1600:../uvc.c      **** 							WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
1601:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
1602:../uvc.c      **** 						 }
1603:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1604:../uvc.c      **** 						 glEp0Buffer[3] = 0;
1605:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1606:../uvc.c      **** 						 sendData1 = glEp0Buffer[2];
1607:../uvc.c      **** 						 break;
1608:../uvc.c      **** 					 case ShapCtlID7:
1609:../uvc.c      **** 						 if(curFlag[CtrlID]){
1610:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1611:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1612:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1613:../uvc.c      **** 			 	 		 }else{
1614:../uvc.c      **** 			 	 			 if(Len == 2)
1615:../uvc.c      **** 			 	 			 {
1616:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1617:../uvc.c      **** 			 	 				 if(glEp0Buffer[0]&0x1){// the enhancement on
1618:../uvc.c      **** 			 	 					 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);// get the enhancement level
1619:../uvc.c      **** 			 	 				 }else{
1620:../uvc.c      **** 			 	 					glEp0Buffer[0] = 0; // the enhancement off
1621:../uvc.c      **** 			 	 				 }
1622:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1623:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1624:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
1625:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1626:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1627:../uvc.c      **** 			 	 			 }
1628:../uvc.c      **** 			 	 			 //curFlag[CtrlID] = CyTrue;
1629:../uvc.c      **** 			 	 		 }
1630:../uvc.c      **** 						 break;
1631:../uvc.c      **** 					 case BLCCtlID0:
1632:../uvc.c      **** 					 case ConsCtlID2:
1633:../uvc.c      **** 					 case WBTMdCtlID9:
1634:../uvc.c      **** 					 case SaturCtlID6:
1635:../uvc.c      **** 					 default:
1636:../uvc.c      **** 						 if(curFlag[CtrlID]){
1637:../uvc.c      **** 			 	 			 if(Len == 2)
1638:../uvc.c      **** 			 	 			 {
1639:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1640:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1641:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1642:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1643:../uvc.c      **** 			 	 			 }else if(Len == 4){
1644:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1645:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1646:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1647:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1648:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1649:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1650:../uvc.c      **** 			 	 			 }
1651:../uvc.c      **** 			 	 		 }else{
1652:../uvc.c      **** 			 	 			 if(Len == 2)
1653:../uvc.c      **** 			 	 			 {
1654:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1655:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1656:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1657:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
1658:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1659:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1660:../uvc.c      **** 			 	 			 }else if(Len == 4){
1661:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1662:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1663:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
1664:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
1665:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1666:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1667:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1668:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1669:../uvc.c      **** 			 	 			 }
1670:../uvc.c      **** 			 	 			 //curFlag[CtrlID] = CyTrue;
1671:../uvc.c      **** 			 	 		 }
1672:../uvc.c      **** 						 break;
1673:../uvc.c      **** 				 }
1674:../uvc.c      **** 		 	 }
1675:../uvc.c      **** 
1676:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1677:../uvc.c      **** 
1678:../uvc.c      **** //#ifdef USB_DEBUG_PRINT
1679:../uvc.c      **** 			  CyU3PDebugPrint (4, "The current value 0x%x 0x%x 0x%x, 0x%x, %d\r\n", glEp0Buffer[0], glEp0Buf
1680:../uvc.c      **** //#endif
1681:../uvc.c      **** 			  break;
1682:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
1683:../uvc.c      **** 		 	 if(CtrlID >= 0x10){//the camera terminal/extension uint command over 0x10.
1684:../uvc.c      **** 		 		 if(Len == 2){
1685:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1686:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1687:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1688:../uvc.c      **** 		 		 }else //if(Len == 4)
1689:../uvc.c      **** 		 		 {
1690:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1691:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1692:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1693:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1694:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1695:../uvc.c      **** 				 }
1696:../uvc.c      **** 			 }else{
1697:../uvc.c      **** 			 	 if(Len ==2){
1698:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1699:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1700:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1701:../uvc.c      **** 				 }else{
1702:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1703:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1704:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1705:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1706:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1707:../uvc.c      **** 				 }
1708:../uvc.c      **** 			 }
1709:../uvc.c      **** 		 	 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1710:../uvc.c      **** 		 	 if(Len == 2){
1711:../uvc.c      **** 		 		 sendData = glEp0Buffer[0];
1712:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[1];
1713:../uvc.c      **** 		 	 }else{
1714:../uvc.c      **** 				  sendData = glEp0Buffer[0];
1715:../uvc.c      **** 				  sendData1 = glEp0Buffer[2];
1716:../uvc.c      **** 			  }
1717:../uvc.c      **** 			  break;
1718:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1719:../uvc.c      **** 		 	 if(CtrlID >= 0x10){//the camera terminal/extension uint command over 0x10.
1720:../uvc.c      **** 		 		 if(Len == 2){
1721:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1722:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1723:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1724:../uvc.c      **** 		 		 }else //if(Len == 4)
1725:../uvc.c      **** 		 		 {
1726:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1727:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1728:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1729:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1730:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1731:../uvc.c      **** 				 }
1732:../uvc.c      **** 			 }else{
1733:../uvc.c      **** 			 	 if(Len ==2){
1734:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1735:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1736:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1737:../uvc.c      **** 				 }else{
1738:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1739:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1740:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1741:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1742:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1743:../uvc.c      **** 				 }
1744:../uvc.c      **** 			 }
1745:../uvc.c      **** 				  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1746:../uvc.c      **** 				  if(Len == 2){
1747:../uvc.c      **** 					  sendData = glEp0Buffer[0];
1748:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
1749:../uvc.c      **** 				  }else{
1750:../uvc.c      **** 					  sendData = glEp0Buffer[0];
1751:../uvc.c      **** 					  sendData1 = glEp0Buffer[2];
1752:../uvc.c      **** 				  }
1753:../uvc.c      **** 				  break;
1754:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1755:../uvc.c      **** 		 	 if(CtrlID >= 0x10){
1756:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCResLo;//ExUCtrlParArry[locCtrlID][7];//ext_con
1757:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
1758:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1759:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1760:../uvc.c      **** 		 	 }
1761:../uvc.c      **** 		 	 else{
1762:../uvc.c      **** 		 		 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCResLo;//ExUCtrlParArry[locCtrlID][7];//ext_control a
1763:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
1764:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
1765:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
1766:../uvc.c      **** 		 	 }
1767:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1768:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1769:../uvc.c      **** 			  sendData1 = glEp0Buffer[1];
1770:../uvc.c      **** 			  //CyU3PDebugPrint (4, "The control ResLo: 0x%x, ResHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0], g
1771:../uvc.c      **** 			  break;
1772:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1773:../uvc.c      **** 		 	 if(CtrlID >= 0x10){
1774:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCInfoLo;//ExUCtrlParArry[locCtrlID][9];//ext_co
1775:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
1776:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1777:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1778:../uvc.c      **** 		 	 }
1779:../uvc.c      **** 		 	 else{
1780:../uvc.c      **** 		 		 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCInfoLo;//ExUCtrlParArry[locCtrlID][9];//ext_control 
1781:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
1782:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
1783:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
1784:../uvc.c      **** 		 	 }
1785:../uvc.c      **** 		 	 Len = 1;
1786:../uvc.c      **** 		 	 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1787:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
1788:../uvc.c      **** 		 	 sendData1 = glEp0Buffer[1];
1789:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
1790:../uvc.c      **** 		 	 break;
1791:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1792:../uvc.c      **** 		 	 if(CtrlID >= 0x10){//the camera terminal/extension uint command over 0x10.
1793:../uvc.c      **** 		 		 if(Len == 2){
1794:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1795:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1796:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
1797:../uvc.c      **** 		 		 }else //if(Len == 4)
1798:../uvc.c      **** 		 		 {
1799:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1800:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1801:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1802:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1803:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
1804:../uvc.c      **** 				 }
1805:../uvc.c      **** 			 }else{
1806:../uvc.c      **** 			 	 if(Len ==2){
1807:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1808:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1809:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
1810:../uvc.c      **** 				 }else{
1811:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1812:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1813:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1814:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1815:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
1816:../uvc.c      **** 				 }
1817:../uvc.c      **** 			 }
1818:../uvc.c      **** 		 	 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1819:../uvc.c      **** 		 	 if(Len == 2){
1820:../uvc.c      **** 		 		 sendData = glEp0Buffer[0];
1821:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[1];
1822:../uvc.c      **** 		 	 }else{
1823:../uvc.c      **** 		 		 sendData = glEp0Buffer[0];
1824:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
1825:../uvc.c      **** 		 	 }
1826:../uvc.c      **** 		 	 break;
1827:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1828:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1829:../uvc.c      **** 				  glEp0Buffer, &readCount);
1830:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
1831:../uvc.c      **** 			   {
1832:../uvc.c      **** 				 if(Len == 2){
1833:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
1834:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
1835:../uvc.c      **** 				 }else{
1836:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
1837:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
1838:../uvc.c      **** 				 }
1839:../uvc.c      **** 				 dataIdx = 0;
1840:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x 
1841:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
1842:../uvc.c      **** 			 	 if(CtrlID >= 0x10){
1843:../uvc.c      **** 					 switch(CtrlID)
1844:../uvc.c      **** 					 {
1845:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
1846:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
1847:../uvc.c      **** 							 if(Data0 == 1){
1848:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
1849:../uvc.c      **** 							 }else{
1850:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
1851:../uvc.c      **** 							 }
1852:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1853:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
1854:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1855:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
1856:../uvc.c      **** 							 break;
1857:../uvc.c      **** 					 	 case ExtCamMCtlID12://EXTCamMode
1858:../uvc.c      **** 	#if 0 // not be used
1859:../uvc.c      **** 							 sendData = CtrlParArry[CtrlID][13];
1860:../uvc.c      **** 
1861:../uvc.c      **** 							 if(CamMode == 1){//720p
1862:../uvc.c      **** 								if(sendData >= 3){
1863:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1864:../uvc.c      **** 									sendData = 0; //set back to default
1865:../uvc.c      **** 									CtrlParArry[CtrlID][13] = 0;
1866:../uvc.c      **** 								}
1867:../uvc.c      **** 								sendData += 4;
1868:../uvc.c      **** 							 }
1869:../uvc.c      **** 							//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1870:../uvc.c      **** 							 glEp0Buffer[0] = sendData;
1871:../uvc.c      **** 							 glEp0Buffer[1] = 0;
1872:../uvc.c      **** 	#endif
1873:../uvc.c      **** 							 break;
1874:../uvc.c      **** 					 	 case ExtSensorParCtlID14:
1875:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1876:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
1877:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1878:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
1879:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
1880:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
1881:../uvc.c      **** 							 break;
1882:../uvc.c      **** 					 	 case ExtI2CCtlID15:
1883:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
1884:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
1885:../uvc.c      **** 					 		 }
1886:../uvc.c      **** 					 		 I2CCmdHandler();
1887:../uvc.c      **** 							 break;
1888:../uvc.c      **** 				 	 	 case ExtAexModCtlID9://4byte
1889:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1890:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi != Data1){//if it's GC settings, the Ex Mode doesn
1891:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
1892:../uvc.c      **** 								 if(1 || Data0 == 2 || Data0 == 3){
1893:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //AGC
1894:../uvc.c      **** 								 }
1895:../uvc.c      **** 							 }else{//if it's not GC settings, the Ex Mode does need to set.
1896:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = SensorGetControl(RegAdd0, devAdd);
1897:../uvc.c      **** 								 if((pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo&0x03) != Data0)
1898:../uvc.c      **** 								 {
1899:../uvc.c      **** 									 Data0 = Data0 | (pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo & 0xFC);//exposure mode bit0:1 (ke
1900:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0; //keep the valus is the same as the Reg. h
1901:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
1902:../uvc.c      **** 									 dataIdx++;
1903:../uvc.c      **** 								 }
1904:../uvc.c      **** 							 }
1905:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
1906:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1907:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1908:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi,
1909:../uvc.c      **** 									 EXTShutter.UVCCurVLo, Data0, Data1);
1910:../uvc.c      **** 							 break;
1911:../uvc.c      **** 					 	 case ExtShutCtlID0: //special!!
1912:../uvc.c      **** 	#if 1	// register setting directly
1913:../uvc.c      **** 						     if(1||(EXTAexModGainlev.UVCCurVLo&0x3) != 0)//based on the Aex Mode 2 has been masked in
1914:../uvc.c      **** 						     {
1915:../uvc.c      **** 						    	 Data1 = SensorGetControl(RegAdd0, devAdd);
1916:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (Data1 & 0x8F);
1917:../uvc.c      **** 						    	 if (pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
1918:../uvc.c      **** 						    	 dataIdx = 0;
1919:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1920:../uvc.c      **** 								 //cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
1921:../uvc.c      **** 								 //dataIdx++;
1922:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1923:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1924:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0; //CtrlParArry[CtrlID][13] save new setting 
1925:../uvc.c      **** 						     }
1926:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
1927:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
1928:../uvc.c      **** 						     break;
1929:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://Fine shutter level 2bytes standard operation!!!
1930:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1931:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){
1932:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
1933:../uvc.c      **** 								 if(1 || EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
1934:../uvc.c      **** 									 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
1935:../uvc.c      **** 									 //dataIdx++;
1936:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //shutter level
1937:../uvc.c      **** 								 }
1938:../uvc.c      **** 							 }
1939:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1940:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1941:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1942:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
1943:../uvc.c      **** 							 break;
1944:../uvc.c      **** 
1945:../uvc.c      **** 	#else	// old fashion
1946:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
1947:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
1948:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
1949:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
1950:../uvc.c      **** 									 }else{
1951:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
1952:../uvc.c      **** 									 }
1953:../uvc.c      **** 								 }
1954:../uvc.c      **** 							 }else{
1955:../uvc.c      **** 								 Data1 = Data0 - 1;
1956:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
1957:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
1958:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
1959:../uvc.c      **** 									 }else{
1960:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
1961:../uvc.c      **** 									 }
1962:../uvc.c      **** 								 }
1963:../uvc.c      **** 								 if(Data1 < 8){
1964:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
1965:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
1966:../uvc.c      **** 								 }else{
1967:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
1968:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
1969:../uvc.c      **** 								 }
1970:../uvc.c      **** 							 }
1971:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
1972:../uvc.c      **** 							 dataIdx = 0;
1973:../uvc.c      **** 							 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
1974:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1975:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
1976:../uvc.c      **** 							 if(AxMode){
1977:../uvc.c      **** 								 dataIdx++;
1978:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
1979:../uvc.c      **** 								 dataIdx++;
1980:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustme
1981:../uvc.c      **** 							 }
1982:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1983:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
1984:../uvc.c      **** 							 break;
1985:../uvc.c      **** 	#endif
1986:../uvc.c      **** 						 case Ext1BLCRangeCtlID4:
1987:../uvc.c      **** 	#if 0 //seperate version
1988:../uvc.c      **** 							 //registers value BLD window enable (0x17); position (0x13); size (0x14).getData = Data0&0x
1989:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
1990:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1991:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
1992:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
1993:../uvc.c      **** 							 }else{ //disable BLD window
1994:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
1995:../uvc.c      **** 							 }
1996:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
1997:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
1998:../uvc.c      **** 							 dataIdx++;
1999:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
2000:../uvc.c      **** 							 dataIdx++;
2001:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
2002:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
2003:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
2004:../uvc.c      **** 							 dataIdx++;
2005:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
2006:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2007:../uvc.c      **** 	#else //combination version
2008:../uvc.c      **** 							 //Data0 = Data0&0x7F; //mask window show flag bit.
2009:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2010:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
2011:../uvc.c      **** 							 dataIdx++;
2012:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
2013:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2014:../uvc.c      **** 							 getData1 = Data1;
2015:../uvc.c      **** 	#endif
2016:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
2017:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
2018:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
2019:../uvc.c      **** 							 break;
2020:../uvc.c      **** 				 	 	 case Ext1ExCtrlSpeedCtlID8:
2021:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){  //2Bytes
2022:../uvc.c      **** 								 Data1 = SensorGetControl(RegAdd0, devAdd); //get the origin data as the fine shutter enabl
2023:../uvc.c      **** 								 Data1 &= 0x0F; Data0 = (Data0&0x0F) << 4;
2024:../uvc.c      **** 								 Data0 |= Data1;
2025:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]. Saving the v
2026:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2027:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
2028:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2029:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
2030:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2031:../uvc.c      **** 							 }
2032:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
2033:../uvc.c      **** 
2034:../uvc.c      **** 				 	 	 case Ext1BLCWeightCtlID5:
2035:../uvc.c      **** 				 	 	 case Ext1ExHysterCtlID7:
2036:../uvc.c      **** 				 	 	 case Ext1EnhanceModeCtlID9:
2037:../uvc.c      **** 				 	 	 case Ext1EnhanceGainCtlID10:
2038:../uvc.c      **** 				 	 	 case Ext12DNRGainEnblCtlID12:
2039:../uvc.c      **** 				 	 	 case Ext1GammaCorCtlID14:
2040:../uvc.c      **** 				 	 	 case Ext1AGCMaxLimetCtlID15:
2041:../uvc.c      **** 				 	 	 case Ext1EnhanceStarEndCtlID11://4bytes
2042:../uvc.c      **** 				 	 	 case Ext12DNRGainStarEndCtlID13://4bytes
2043:../uvc.c      **** 						 case ExtExRefCtlID10:
2044:../uvc.c      **** 				 	 	 default:
2045:../uvc.c      **** 				 	 			 if(Len == 2)
2046:../uvc.c      **** 				 	 			 {
2047:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){  //2Bytes
2048:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2049:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
2050:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2051:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
2052:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
2053:../uvc.c      **** 									 }
2054:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
2055:../uvc.c      **** 				 	 			 }else if(Len == 4){
2056:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
2057:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
2058:../uvc.c      **** 									 {
2059:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//exposure mode (assume b3:2=00, no BLC wi
2060:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
2061:../uvc.c      **** 										 dataIdx++;
2062:../uvc.c      **** 									 }
2063:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi != Data1){
2064:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
2065:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
2066:../uvc.c      **** 									 }
2067:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
2068:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2069:../uvc.c      **** 
2070:../uvc.c      **** 				 	 			 }
2071:../uvc.c      **** 				 	 			 CyU3PDebugPrint (4, "The data gets from host. [0]: 0x%x [1]: 0x%x curLo: 0x%x curHi: 0x%
2072:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
2073:../uvc.c      **** 				 	 			 break;
2074:../uvc.c      **** 					 }
2075:../uvc.c      **** 			 	 }
2076:../uvc.c      **** 			 	 else{
2077:../uvc.c      **** 					 switch(CtrlID)
2078:../uvc.c      **** 					 {
2079:../uvc.c      **** 						 case BrgtCtlID1:
2080:../uvc.c      **** 	#if 0 //cancel for 5MP w/b camera
2081:../uvc.c      **** 								 dataIdx = 0;
2082:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2083:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
2084:../uvc.c      **** 								  if(Data0&0x80){
2085:../uvc.c      **** 									  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
2086:../uvc.c      **** 								  }else{
2087:../uvc.c      **** 									  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
2088:../uvc.c      **** 								  }
2089:../uvc.c      **** 								 Data1 |= ~0x03;
2090:../uvc.c      **** 								 Data1 &= 0xC7;
2091:../uvc.c      **** 							  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
2092:../uvc.c      **** 							  	 dataIdx++;
2093:../uvc.c      **** 
2094:../uvc.c      **** 								 Data0 = (Data0 << 2);
2095:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
2096:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2097:../uvc.c      **** 
2098:../uvc.c      **** 								 CtrlParArry[CtrlID][13] = Data0;
2099:../uvc.c      **** 								 CtrlParArry[CtrlID][14] = Data1;
2100:../uvc.c      **** 								 CtrlParArry[CtrlID][16] = CyTrue;
2101:../uvc.c      **** 	#endif
2102:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2103:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
2104:../uvc.c      **** 								 /*// new I2C command. direct using Data0 coming from host. 8/23/2016
2105:../uvc.c      **** 								 if(Data0&0x80){
2106:../uvc.c      **** 									  Data0 = Data0 - 0x80;
2107:../uvc.c      **** 								  }else{
2108:../uvc.c      **** 									  Data0 = ~Data0;
2109:../uvc.c      **** 								  }
2110:../uvc.c      **** 								  */
2111:../uvc.c      **** 							  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
2112:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2113:../uvc.c      **** 
2114:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2115:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2116:../uvc.c      **** 							 break;
2117:../uvc.c      **** 						 case HueCtlID5://not being used
2118:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2119:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
2120:../uvc.c      **** 							 dataIdx++;
2121:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
2122:../uvc.c      **** 							 dataIdx++;
2123:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
2124:../uvc.c      **** 							 dataIdx++;
2125:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
2126:../uvc.c      **** 							 dataIdx++;
2127:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
2128:../uvc.c      **** 							 dataIdx++;
2129:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
2130:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2131:../uvc.c      **** 
2132:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0] - GREEN_BASE;
2133:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2134:../uvc.c      **** 							 break;
2135:../uvc.c      **** 						 case MFreqCtlID4:
2136:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2137:../uvc.c      **** 							 //Data0 = Data0 - 1;
2138:../uvc.c      **** 							 //is60Hz = Data0;
2139:../uvc.c      **** 							 if(Data0 <= 0)  //for specific check. if it's minor value, set to 0.
2140:../uvc.c      **** 							 {
2141:../uvc.c      **** 								 Data0 = 0;  // 60Hz (PAL)
2142:../uvc.c      **** 								 is60Hz = CyTrue;
2143:../uvc.c      **** 							 }
2144:../uvc.c      **** 							 else if(Data0 >= 1)
2145:../uvc.c      **** 							 {
2146:../uvc.c      **** 								 Data0 = 1;  // 50Hz (NTSC)
2147:../uvc.c      **** 								 is60Hz = CyFalse;
2148:../uvc.c      **** 							 }
2149:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
2150:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
2151:../uvc.c      **** 							 {
2152:../uvc.c      **** 			                       switch (setRes)
2153:../uvc.c      **** 			                         {
2154:../uvc.c      **** 			                         	case 1: //1944
2155:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR_
2156:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2157:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
2158:../uvc.c      **** 			                         		break;
2159:../uvc.c      **** 			                         	case 2: //1080
2160:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR_
2161:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2162:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
2163:../uvc.c      **** 			                         		break;
2164:../uvc.c      **** 			                         	case 3: //720
2165:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, I
2166:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2167:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
2168:../uvc.c      **** 			                         		break;
2169:../uvc.c      **** 			                         	case 4: //VGA
2170:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x32:0xB2)&0xFC)|ROIMode, I
2171:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2172:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
2173:../uvc.c      **** 			                         	default:
2174:../uvc.c      **** 			                         		break;
2175:../uvc.c      **** 			                         }
2176:../uvc.c      **** 							 }
2177:../uvc.c      **** 
2178:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2179:../uvc.c      **** 							 break;
2180:../uvc.c      **** 						 case WBTLevCtlID11: //4bytes
2181:../uvc.c      **** 							 //Data0 = glEp0Buffer[0]; //blue
2182:../uvc.c      **** 							 //Data1 = glEp0Buffer[2]; //red
2183:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2184:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2185:../uvc.c      **** 							 dataIdx++;
2186:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
2187:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2188:../uvc.c      **** 
2189:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
2190:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
2191:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2192:../uvc.c      **** 							 break;
2193:../uvc.c      **** 						 case BLCCtlID0:
2194:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2195:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
2196:../uvc.c      **** 							 {
2197:../uvc.c      **** 								 if(Data0 < 3){
2198:../uvc.c      **** 					 				 Data0 += 4;
2199:../uvc.c      **** 					 			 }else{
2200:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
2201:../uvc.c      **** 									Data0 = 4; //set to default.
2202:../uvc.c      **** 					 			 }
2203:../uvc.c      **** 					 		 }else{
2204:../uvc.c      **** 					 			 Data0 |= EXTBLCGrid.UVCCurVLo << 7;
2205:../uvc.c      **** 					 		 }
2206:../uvc.c      **** 
2207:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2208:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2209:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2210:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2211:../uvc.c      **** 					 		 break;
2212:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
2213:../uvc.c      **** 
2214:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2215:../uvc.c      **** 							 if(Data0 != 0){
2216:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2217:../uvc.c      **** 	#ifdef COLOR
2218:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Second: set enhancement valu
2219:../uvc.c      **** 	#else
2220:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
2221:../uvc.c      **** 								 dataIdx++;
2222:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
2223:../uvc.c      **** 	#endif
2224:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2225:../uvc.c      **** 							 }else{
2226:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2227:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
2228:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2229:../uvc.c      **** 							 }
2230:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2231:../uvc.c      **** 							 break;
2232:../uvc.c      **** 						 case ConsCtlID2:
2233:../uvc.c      **** 						 case WBTMdCtlID9:
2234:../uvc.c      **** 						 case SaturCtlID6:
2235:../uvc.c      **** 						 default:
2236:../uvc.c      **** 			 	 			 if(Len == 2)
2237:../uvc.c      **** 			 	 			 {
2238:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0){  //2Bytes
2239:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2240:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
2241:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2242:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
2243:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
2244:../uvc.c      **** 								 }
2245:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2246:../uvc.c      **** 			 	 			 }else if(Len == 4){
2247:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
2248:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
2249:../uvc.c      **** 								 {
2250:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//exposure mode (assume b3:2=00, no BLC window). C
2251:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
2252:../uvc.c      **** 									 dataIdx++;
2253:../uvc.c      **** 								 }
2254:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVHi != Data1){
2255:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
2256:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
2257:../uvc.c      **** 								 }
2258:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2259:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2260:../uvc.c      **** 
2261:../uvc.c      **** 			 	 			 }
2262:../uvc.c      **** 			 	 			 CyU3PDebugPrint (4, "The data gets from host. [0]: 0x%x [1]: 0x%x curLo: 0x%x curHi: 0x%x
2263:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
2264:../uvc.c      **** 			 	 			 break;
2265:../uvc.c      **** 					 }
2266:../uvc.c      **** 			 	 }
2267:../uvc.c      **** 			   }else{
2268:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
2269:../uvc.c      **** 			   }
2270:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2271:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
2272:../uvc.c      **** #endif
2273:../uvc.c      **** 
2274:../uvc.c      **** 			  break;
2275:../uvc.c      **** 		  default:
2276:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
2277:../uvc.c      **** 			  break;
2278:../uvc.c      **** 		 }
2279:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
2280:../uvc.c      **** }
2281:../uvc.c      **** /************** CT control requests handler *************************/
2282:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
2283:../uvc.c      **** 
2284:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
2285:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
2286:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
2287:../uvc.c      ****     uint16_t readCount;
2288:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
2289:../uvc.c      ****     uint16_t diff, value, diffRd;
2290:../uvc.c      ****     uint8_t i, shutter, index;
2291:../uvc.c      ****     diff = 0xffff;
2292:../uvc.c      ****     shutter = 1;
2293:../uvc.c      ****     index = 1;
2294:../uvc.c      **** 
2295:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
2296:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
2297:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
2298:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
2299:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
2300:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2301:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
2302:../uvc.c      **** #endif
2303:../uvc.c      ****     reqData = bRequest;
2304:../uvc.c      **** 
2305:../uvc.c      ****     switch (bRequest)
2306:../uvc.c      **** 		 {
2307:../uvc.c      **** 
2308:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
2309:../uvc.c      **** 			  glEp0Buffer[0] = Len;
2310:../uvc.c      **** 			  glEp0Buffer[1] = 0;
2311:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2312:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2313:../uvc.c      **** 			  break;
2314:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
2315:../uvc.c      **** 
2316:../uvc.c      **** 			 switch(CtrlID)
2317:../uvc.c      **** 			 {
2318:../uvc.c      **** 				 default:
2319:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
2320:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
2321:../uvc.c      **** 					 glEp0Buffer[2] = 0;
2322:../uvc.c      **** 					 glEp0Buffer[3] = 0;
2323:../uvc.c      **** 					 sendData = glEp0Buffer[0];
2324:../uvc.c      **** 					 break;
2325:../uvc.c      **** 			 }
2326:../uvc.c      **** 
2327:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2328:../uvc.c      **** 
2329:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2330:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
2331:../uvc.c      **** #endif
2332:../uvc.c      **** 			  break;
2333:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
2334:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
2335:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
2336:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
2337:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2338:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2339:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2340:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2341:../uvc.c      **** 			  break;
2342:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
2343:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
2344:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
2345:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
2346:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2347:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2348:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2349:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2350:../uvc.c      **** 			  break;
2351:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
2352:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
2353:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
2354:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
2355:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2356:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2357:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2358:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2359:../uvc.c      **** 			  break;
2360:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
2361:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
2362:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2363:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2364:../uvc.c      **** 			  Len = 1;
2365:../uvc.c      **** 			  break;
2366:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
2367:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
2368:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
2369:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
2370:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2371:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2374:../uvc.c      **** 			  break;
2375:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
2376:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2377:../uvc.c      **** 			  glEp0Buffer, &readCount);
2378:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
2379:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
2380:../uvc.c      **** 			  value = Data1;
2381:../uvc.c      **** 
2382:../uvc.c      **** 			  switch(CtrlID)
2383:../uvc.c      **** 			  {
2384:../uvc.c      **** 		  	      case AutoExMCtlID1:
2385:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
2386:../uvc.c      **** 
2387:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
2388:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
2389:../uvc.c      **** 				    getData = glEp0Buffer[0];
2390:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
2391:../uvc.c      **** 		  		    switch (getData){
2392:../uvc.c      **** 						case 1:
2393:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
2394:../uvc.c      **** 							break;
2395:../uvc.c      **** 						case 2:
2396:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
2397:../uvc.c      **** 							dataIdx = 0;
2398:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2399:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
2400:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2401:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
2402:../uvc.c      **** 
2403:../uvc.c      **** 							break;
2404:../uvc.c      **** 						case 4:
2405:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
2406:../uvc.c      **** 							break;
2407:../uvc.c      **** 						case 8:
2408:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
2409:../uvc.c      **** 			  		    	dataIdx = 0;
2410:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2411:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
2412:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2413:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
2414:../uvc.c      **** 							break;
2415:../uvc.c      **** 		  		    }
2416:../uvc.c      **** #if 0
2417:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
2418:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
2419:../uvc.c      **** 						  dataIdx = 0;
2420:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2421:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
2422:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2423:../uvc.c      **** 		  		    }
2424:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
2425:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
2426:../uvc.c      **** 		  		    }
2427:../uvc.c      **** #endif
2428:../uvc.c      **** 				    break;
2429:../uvc.c      **** 
2430:../uvc.c      **** 			  	  case ExTmACtlID3:
2431:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
2432:../uvc.c      **** 
2433:../uvc.c      **** 					  value = (value << 8)|Data0;
2434:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
2435:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
2436:../uvc.c      **** 					  {
2437:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
2438:../uvc.c      **** 						  {
2439:../uvc.c      **** 							if(value > ShutValueArry[i]){
2440:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
2441:../uvc.c      **** 							}else{
2442:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
2443:../uvc.c      **** 							}
2444:../uvc.c      **** 							  if(diff > diffRd){
2445:../uvc.c      **** 								  diff = diffRd;
2446:../uvc.c      **** 								  index = i;
2447:../uvc.c      **** 							  }
2448:../uvc.c      **** 						  }
2449:../uvc.c      **** 						  shutter = shutter+index;
2450:../uvc.c      **** 
2451:../uvc.c      **** 						  dataIdx = 0;
2452:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2453:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
2454:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2455:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
2456:../uvc.c      **** 
2457:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
2458:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
2459:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
2460:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
2461:../uvc.c      **** 					  }else{
2462:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
2463:../uvc.c      **** 					  }
2464:../uvc.c      **** 					  getData = glEp0Buffer[0];
2465:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
2466:../uvc.c      **** 					  break;
2467:../uvc.c      **** 			  	  case IriACtlID7:
2468:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
2469:../uvc.c      **** 					  {
2470:../uvc.c      **** 							 dataIdx = 0;
2471:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2472:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
2473:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2474:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
2475:../uvc.c      **** 
2476:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
2477:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
2478:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
2479:../uvc.c      **** 					  }else{
2480:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
2481:../uvc.c      **** 					  }
2482:../uvc.c      **** 					  getData = glEp0Buffer[0];
2483:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
2484:../uvc.c      **** 
2485:../uvc.c      **** 					  break;
2486:../uvc.c      **** 			  	  case ZmOpRCtlID10:
2487:../uvc.c      **** 					  getData = glEp0Buffer[0];
2488:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
2489:../uvc.c      **** #if 1
2490:../uvc.c      **** 					  dataIdx = 0;
2491:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2492:../uvc.c      **** 					  if(getData == 1)
2493:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
2494:../uvc.c      **** 					  else if(getData == 0xff)
2495:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
2496:../uvc.c      **** 					  else
2497:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
2498:../uvc.c      **** 					  //dataIdx++;
2499:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
2500:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2501:../uvc.c      **** #endif
2502:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
2503:../uvc.c      **** 					  break;
2504:../uvc.c      **** 
2505:../uvc.c      **** 			  	  default:
2506:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
2507:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
2508:../uvc.c      **** 			  		 break;
2509:../uvc.c      **** 			  }
2510:../uvc.c      **** 			  break;
2511:../uvc.c      **** 		  default:
2512:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
2513:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
2514:../uvc.c      **** 			  break;
2515:../uvc.c      **** 		 }
2516:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
2517:../uvc.c      **** 
2518:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
2519:../uvc.c      **** }
2520:../uvc.c      **** 
2521:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
2522:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
2523:../uvc.c      **** {
2524:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
2525:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
2526:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
2527:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
2528:../uvc.c      **** 
2529:../uvc.c      ****     CtrlID = BrgtCtlID1;
2530:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
2531:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2532:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
2533:../uvc.c      ****     Data1 = Data0;
2534:../uvc.c      **** 
2535:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2536:../uvc.c      ****     if(Data1&0x80){
2537:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
2538:../uvc.c      ****     }else{
2539:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
2540:../uvc.c      ****     }
2541:../uvc.c      ****     Data0 = (Data0 << 2);
2542:../uvc.c      **** 
2543:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
2544:../uvc.c      **** 
2545:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
2546:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
2547:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2548:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
2549:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
2550:../uvc.c      **** 
2551:../uvc.c      ****     CtrlID = ConsCtlID2;
2552:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2553:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2554:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2555:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
2556:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2557:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
2558:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2559:../uvc.c      **** 
2560:../uvc.c      ****     CtrlID = HueCtlID5;
2561:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2562:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2563:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2564:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
2565:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
2566:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
2567:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
2568:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
2569:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
2570:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
2571:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
2572:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
2573:../uvc.c      **** 
2574:../uvc.c      ****     CtrlID = SaturCtlID6;
2575:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2576:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2577:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
2578:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
2579:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
2580:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2581:../uvc.c      **** 
2582:../uvc.c      ****     CtrlID = ShapCtlID7;
2583:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2584:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2585:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2586:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
2587:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2588:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2589:../uvc.c      **** 
2590:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
2591:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
2592:../uvc.c      **** 	return;
2593:../uvc.c      **** }
2594:../uvc.c      **** 
2595:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
2596:../uvc.c      **** void
2597:../uvc.c      **** CyFxUVCAddHeader (
2598:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
2599:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
2600:../uvc.c      ****         )
2601:../uvc.c      **** {
2602:../uvc.c      ****     /* Copy header to buffer */
2603:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2604:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
2605:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
2606:../uvc.c      **** 
2607:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
2608:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
2609:../uvc.c      ****     {
2610:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
2611:../uvc.c      ****     }
2612:../uvc.c      **** }
2613:../uvc.c      **** 
2614:../uvc.c      **** 
2615:../uvc.c      **** /* Application Error Handler */
2616:../uvc.c      **** void
2617:../uvc.c      **** CyFxAppErrorHandler (
2618:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
2619:../uvc.c      ****         )
2620:../uvc.c      **** {
2621:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
2622:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
2623:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
2624:../uvc.c      **** 
2625:../uvc.c      ****        This function can be modified to take additional error handling actions such
2626:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
2627:../uvc.c      ****      */
2628:../uvc.c      ****     for (;;)
2629:../uvc.c      ****     {
2630:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
2631:../uvc.c      ****         CyU3PThreadSleep (1000);
2632:../uvc.c      ****     }
2633:../uvc.c      **** }
2634:../uvc.c      **** 
2635:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
2636:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
2637:../uvc.c      ****  */
2638:../uvc.c      **** static void
2639:../uvc.c      **** CyFxUVCApplnAbortHandler (
2640:../uvc.c      ****         void)
2641:../uvc.c      **** {
2642:../uvc.c      **** 	uint32_t flag;
2643:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
2644:../uvc.c      **** 	{
2645:../uvc.c      ****         /* Clear the Video Stream Request Event */
2646:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
2647:../uvc.c      **** 
2648:../uvc.c      ****         /* Set Video Stream Abort Event */
2649:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
2650:../uvc.c      **** 	}
2651:../uvc.c      **** }
2652:../uvc.c      **** 
2653:../uvc.c      **** /* This is the Callback function to handle the USB Events */
2654:../uvc.c      **** static void
2655:../uvc.c      **** CyFxUVCApplnUSBEventCB (
2656:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
2657:../uvc.c      ****         uint16_t             evdata  /* Event data */
2658:../uvc.c      ****         )
2659:../uvc.c      **** {
2660:../uvc.c      ****     switch (evtype)
2661:../uvc.c      ****     {
2662:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
2663:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
2664:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2665:../uvc.c      ****             gpif_initialized = 0;
2666:../uvc.c      ****             streamingStarted = CyFalse;
2667:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2668:../uvc.c      ****             break;
2669:../uvc.c      **** 
2670:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
2671:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
2672:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2673:../uvc.c      ****             gpif_initialized = 0;
2674:../uvc.c      ****             streamingStarted = CyFalse;
2675:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2676:../uvc.c      ****             break;
2677:../uvc.c      **** 
2678:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
2679:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
2680:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2681:../uvc.c      ****             gpif_initialized = 0;
2682:../uvc.c      ****             isUsbConnected = CyFalse;
2683:../uvc.c      ****             streamingStarted = CyFalse;
2684:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2685:../uvc.c      ****             break;
2686:../uvc.c      **** 
2687:../uvc.c      **** #ifdef BACKFLOW_DETECT
2688:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
2689:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
2690:../uvc.c      ****             break;
2691:../uvc.c      **** #endif
2692:../uvc.c      **** 
2693:../uvc.c      ****         default:
2694:../uvc.c      ****             break;
2695:../uvc.c      ****     }
2696:../uvc.c      **** }
2697:../uvc.c      **** 
2698:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
2699:../uvc.c      **** static CyBool_t
2700:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
2701:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
2702:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
2703:../uvc.c      ****         )
2704:../uvc.c      **** {
2705:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
2706:../uvc.c      ****     uint32_t status;
2707:../uvc.c      **** 
2708:../uvc.c      ****     /* Obtain Request Type and Request */
2709:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
2710:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
2711:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
2712:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
2713:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
2714:../uvc.c      **** 
2715:../uvc.c      ****     /* Check for UVC Class Requests */
2716:../uvc.c      ****     switch (bmReqType)
2717:../uvc.c      ****     {
2718:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
2719:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
2720:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
2721:../uvc.c      ****             switch (wIndex & 0xFF)
2722:../uvc.c      ****             {
2723:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
2724:../uvc.c      ****                     {
2725:../uvc.c      ****                         uvcHandleReq = CyTrue;
2726:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
2727:../uvc.c      ****                                 CYU3P_EVENT_OR);
2728:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2729:../uvc.c      ****                         {
2730:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
2731:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2732:../uvc.c      ****                         }
2733:../uvc.c      ****                     }
2734:../uvc.c      ****                     break;
2735:../uvc.c      **** 
2736:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
2737:../uvc.c      ****                     {
2738:../uvc.c      ****                         uvcHandleReq = CyTrue;
2739:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
2740:../uvc.c      ****                                 CYU3P_EVENT_OR);
2741:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2742:../uvc.c      ****                         {
2743:../uvc.c      ****                             /* Error handling */
2744:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
2745:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2746:../uvc.c      ****                         }
2747:../uvc.c      ****                     }
2748:../uvc.c      ****                     break;
2749:../uvc.c      **** 
2750:../uvc.c      ****                 default:
2751:../uvc.c      ****                     break;
2752:../uvc.c      ****             }
2753:../uvc.c      ****             break;
2754:../uvc.c      **** 
2755:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
2756:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
2757:../uvc.c      ****             {
2758:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
2759:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
2760:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
2761:../uvc.c      ****                 {
2762:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
2763:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
2764:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
2765:../uvc.c      ****                     gpif_initialized = 0;
2766:../uvc.c      ****                     streamingStarted = CyFalse;
2767:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
2768:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2769:../uvc.c      ****                     CyU3PBusyWait (100);
2770:../uvc.c      **** 
2771:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
2772:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2773:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2774:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2775:../uvc.c      ****                     CyU3PBusyWait (100);
2776:../uvc.c      **** 
2777:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
2778:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2779:../uvc.c      ****                     uvcHandleReq = CyTrue;
2780:../uvc.c      ****                     /* Complete Control request handshake */
2781:../uvc.c      ****                     CyU3PUsbAckSetup ();
2782:../uvc.c      ****                     /* Indicate stop streaming to main thread */
2783:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
2784:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
2785:../uvc.c      **** 
2786:../uvc.c      ****                 }
2787:../uvc.c      ****             }
2788:../uvc.c      ****             break;
2789:../uvc.c      **** 
2790:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
2791:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
2792:../uvc.c      ****             {
2793:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
2794:../uvc.c      ****                 {
2795:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
2796:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
2797:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
2798:../uvc.c      ****                 	 * has started. */
2799:../uvc.c      ****                     if (streamingStarted == CyTrue)
2800:../uvc.c      ****                     {
2801:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
2802:../uvc.c      **** 
2803:../uvc.c      ****                         /* Disable the GPIF state machine. */
2804:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
2805:../uvc.c      ****                         gpif_initialized = 0;
2806:../uvc.c      ****                         streamingStarted = CyFalse;
2807:../uvc.c      **** 
2808:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
2809:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2810:../uvc.c      ****                         CyU3PBusyWait (100);
2811:../uvc.c      **** 
2812:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
2813:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2814:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2815:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2816:../uvc.c      ****                         CyU3PBusyWait (100);
2817:../uvc.c      **** 
2818:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
2819:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2820:../uvc.c      **** 
2821:../uvc.c      ****                         uvcHandleReq = CyTrue;
2822:../uvc.c      ****                         /* Complete Control request handshake */
2823:../uvc.c      ****                         CyU3PUsbAckSetup ();
2824:../uvc.c      ****                         /* Indicate stop streaming to main thread */
2825:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
2826:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
2827:../uvc.c      ****                     }
2828:../uvc.c      ****                     else
2829:../uvc.c      ****                     {
2830:../uvc.c      ****                         uvcHandleReq = CyTrue;
2831:../uvc.c      ****                         CyU3PUsbAckSetup ();
2832:../uvc.c      ****                     }
2833:../uvc.c      ****                 }
2834:../uvc.c      ****             }
2835:../uvc.c      ****             break;
2836:../uvc.c      **** 
2837:../uvc.c      ****         default:
2838:../uvc.c      ****             break;
2839:../uvc.c      ****     }
2840:../uvc.c      **** 
2841:../uvc.c      ****     /* Return status of request handling to the USB driver */
2842:../uvc.c      ****     return uvcHandleReq;
2843:../uvc.c      **** }
2844:../uvc.c      **** 
2845:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
2846:../uvc.c      **** 
2847:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
2848:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
2849:../uvc.c      ****  */
2850:../uvc.c      **** void
2851:../uvc.c      **** CyFxUvcApplnDmaCallback (
2852:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
2853:../uvc.c      ****         CyU3PDmaCbType_t      type,
2854:../uvc.c      ****         CyU3PDmaCBInput_t    *input
2855:../uvc.c      ****         )
2856:../uvc.c      **** {
2857:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
2858:../uvc.c      **** #if 1
2859:../uvc.c      ****     CyU3PReturnStatus_t status;
2860:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
2861:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
2862:../uvc.c      **** 
2863:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2864:../uvc.c      ****     {
2865:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
2866:../uvc.c      ****             {
2867:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
2868:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
2869:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2870:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
2871:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2872:../uvc.c      ****                 	stiflag = 0x03;
2873:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
2874:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2875:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2876:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2877:../uvc.c      ****                 }
2878:../uvc.c      **** #endif
2879:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
2880:../uvc.c      ****                 fb++;
2881:../uvc.c      ****             }
2882:../uvc.c      ****             else
2883:../uvc.c      ****             {
2884:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
2885:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
2886:../uvc.c      ****                 pb++;
2887:../uvc.c      ****                 pbc = input->buffer_p.count;
2888:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
2889:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
2890:../uvc.c      ****                 //lineCount = 0; //res test
2891:../uvc.c      **** #if 1   //remove the still flag clearing here
2892:../uvc.c      ****                 if(stiflag == 0x0F){
2893:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2894:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2895:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2896:../uvc.c      ****                 	stiflag = 0xAA;
2897:../uvc.c      ****                 }
2898:../uvc.c      **** #endif
2899:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
2900:../uvc.c      ****             }
2901:../uvc.c      **** 
2902:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
2903:../uvc.c      ****             prodCount++;
2904:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2905:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
2906:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
2907:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
2908:../uvc.c      ****             {
2909:../uvc.c      ****                 prodCount--;
2910:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
2911:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
2912:../uvc.c      ****             }
2913:../uvc.c      ****     }
2914:../uvc.c      **** #endif
2915:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
2916:../uvc.c      ****     {
2917:../uvc.c      ****         consCount++;
2918:../uvc.c      ****         streamingStarted = CyTrue;
2919:../uvc.c      ****     }
2920:../uvc.c      **** }
2921:../uvc.c      **** 
2922:../uvc.c      **** /*
2923:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
2924:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
2925:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
2926:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
2927:../uvc.c      ****  * to commit the buffer.
2928:../uvc.c      ****  */
2929:../uvc.c      **** static uint8_t
2930:../uvc.c      **** CyFxUvcAppCommitEOF (
2931:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
2932:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
2933:../uvc.c      ****         )
2934:../uvc.c      **** {
2935:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2936:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
2937:../uvc.c      **** 
2938:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
2939:../uvc.c      **** 
2940:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2941:../uvc.c      ****     {
2942:../uvc.c      ****         switch (stateId)
2943:../uvc.c      ****         {
2944:../uvc.c      **** 
2945:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
2946:../uvc.c      ****             case FULL_BUF_IN_SCK1:
2947:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2948:../uvc.c      ****                 break;
2949:../uvc.c      **** 
2950:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
2951:../uvc.c      ****                 socket = 0;
2952:../uvc.c      ****                 break;
2953:../uvc.c      **** 
2954:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
2955:../uvc.c      ****                 socket = 1;
2956:../uvc.c      ****                 break;
2957:../uvc.c      **** 
2958:../uvc.c      ****             default:
2959:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2960:../uvc.c      ****                 /* Unexpected current state. Return error. */
2961:../uvc.c      ****             	//lineCount++;
2962:../uvc.c      ****             	return 1;
2963:../uvc.c      ****         }
2964:../uvc.c      ****     }
2965:../uvc.c      **** 
2966:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2967:../uvc.c      ****     {
2968:../uvc.c      ****         switch (stateId)
2969:../uvc.c      ****         {
2970:../uvc.c      **** #ifndef CAM720
2971:../uvc.c      **** #ifdef GPIFIIM
2972:../uvc.c      ****             case 13:
2973:../uvc.c      ****             case 24:
2974:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2975:../uvc.c      ****                 break;
2976:../uvc.c      **** 
2977:../uvc.c      ****             case 8:
2978:../uvc.c      ****                 socket = 0;
2979:../uvc.c      ****                 break;
2980:../uvc.c      **** 
2981:../uvc.c      ****             case 20:
2982:../uvc.c      ****                 socket = 1;
2983:../uvc.c      ****                 break;
2984:../uvc.c      **** #else
2985:../uvc.c      ****             case 11:
2986:../uvc.c      ****             case 18:
2987:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2988:../uvc.c      ****                 break;
2989:../uvc.c      **** 
2990:../uvc.c      ****             case 8:
2991:../uvc.c      ****                 socket = 0;
2992:../uvc.c      ****                 break;
2993:../uvc.c      **** 
2994:../uvc.c      ****             case 15:
2995:../uvc.c      ****                 socket = 1;
2996:../uvc.c      ****                 break;
2997:../uvc.c      **** #endif
2998:../uvc.c      **** #else
2999:../uvc.c      ****             case 11:
3000:../uvc.c      ****             case 18:
3001:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
3002:../uvc.c      ****                 break;
3003:../uvc.c      **** 
3004:../uvc.c      ****             case 8:
3005:../uvc.c      ****                 socket = 0;
3006:../uvc.c      ****                 break;
3007:../uvc.c      **** 
3008:../uvc.c      ****             case 15:
3009:../uvc.c      ****                 socket = 1;
3010:../uvc.c      ****                 break;
3011:../uvc.c      **** 
3012:../uvc.c      **** #endif
3013:../uvc.c      ****              default:
3014:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
3015:../uvc.c      ****                 /* Unexpected current state. Return error. */
3016:../uvc.c      ****                return 1;
3017:../uvc.c      ****         }
3018:../uvc.c      ****     }
3019:../uvc.c      **** 
3020:../uvc.c      ****     if (socket != 0xFF)
3021:../uvc.c      ****     {
3022:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
3023:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
3024:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
3025:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
3026:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
3027:../uvc.c      ****         {
3028:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
3029:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
3030:../uvc.c      ****         }
3031:../uvc.c      ****     }
3032:../uvc.c      **** 
3033:../uvc.c      ****     return 0;
3034:../uvc.c      **** }
3035:../uvc.c      **** 
3036:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
3037:../uvc.c      **** void
3038:../uvc.c      **** CyFxGpifCB (
3039:../uvc.c      ****         CyU3PGpifEventType event,
3040:../uvc.c      ****         uint8_t currentState
3041:../uvc.c      ****         )
3042:../uvc.c      **** {
3043:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
3044:../uvc.c      ****     {
3045:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
3046:../uvc.c      ****     	           in the UVC implementation. */
3047:../uvc.c      ****     	//hitFV = CyTrue;
3048:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
3049:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
3050:../uvc.c      ****     }
3051:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
3052:../uvc.c      **** }
3053:../uvc.c      **** 
3054:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
3055:../uvc.c      **** static void
3056:../uvc.c      **** CyFxUVCApplnDebugInit (
3057:../uvc.c      ****         void)
3058:../uvc.c      **** {
3059:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
3060:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3061:../uvc.c      **** 
3062:../uvc.c      ****     /* Initialize the UART for printing debug messages */
3063:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
3064:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3065:../uvc.c      ****     {
3066:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
3067:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3068:../uvc.c      ****     }
3069:../uvc.c      **** 
3070:../uvc.c      ****     /* Set UART Configuration */
3071:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
3072:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
3073:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
3074:../uvc.c      ****     uartConfig.txEnable = CyTrue;
3075:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
3076:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
3077:../uvc.c      ****     uartConfig.isDma    = CyTrue;
3078:../uvc.c      **** 
3079:../uvc.c      ****     /* Set the UART configuration */
3080:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
3081:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3082:../uvc.c      ****     {
3083:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3084:../uvc.c      ****     }
3085:../uvc.c      **** 
3086:../uvc.c      ****     /* Set the UART transfer */
3087:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
3088:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3089:../uvc.c      ****     {
3090:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3091:../uvc.c      ****     }
3092:../uvc.c      **** 
3093:../uvc.c      ****     /* Initialize the Debug logger module. */
3094:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
3095:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3096:../uvc.c      ****     {
3097:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3098:../uvc.c      ****     }
3099:../uvc.c      **** 
3100:../uvc.c      ****     /* Disable log message headers. */
3101:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
3102:../uvc.c      **** }
3103:../uvc.c      **** 
3104:../uvc.c      **** /* I2C initialization. */
3105:../uvc.c      **** static void
3106:../uvc.c      **** CyFxUVCApplnI2CInit (void)
3107:../uvc.c      **** {
3108:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
3109:../uvc.c      ****     CyU3PReturnStatus_t status;
3110:../uvc.c      **** 
3111:../uvc.c      ****     status = CyU3PI2cInit ();
3112:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
3113:../uvc.c      ****     {
3114:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
3115:../uvc.c      ****         CyFxAppErrorHandler (status);
3116:../uvc.c      ****     }
3117:../uvc.c      **** 
3118:../uvc.c      ****     /*  Set I2C Configuration */
3119:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
3120:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
3121:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
3122:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
3123:../uvc.c      **** 
3124:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
3125:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
3126:../uvc.c      ****     {
3127:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
3128:../uvc.c      ****         CyFxAppErrorHandler (status);
3129:../uvc.c      ****     }
3130:../uvc.c      **** }
3131:../uvc.c      **** 
3132:../uvc.c      **** #ifdef BACKFLOW_DETECT
3133:../uvc.c      **** static void CyFxUvcAppPibCallback (
3134:../uvc.c      ****         CyU3PPibIntrType cbType,
3135:../uvc.c      ****         uint16_t cbArg)
3136:../uvc.c      **** {
3137:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
3138:../uvc.c      ****     {
3139:../uvc.c      ****         if (!back_flow_detected)
3140:../uvc.c      ****         {
3141:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
3142:../uvc.c      ****             back_flow_detected = 1;
3143:../uvc.c      ****         }
3144:../uvc.c      ****     }
3145:../uvc.c      **** }
3146:../uvc.c      **** #endif
3147:../uvc.c      **** 
3148:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3149:../uvc.c      **** static void
3150:../uvc.c      **** CyFxUvcAppDebugCallback (
3151:../uvc.c      ****         CyU3PDmaChannel   *handle,
3152:../uvc.c      ****         CyU3PDmaCbType_t   type,
3153:../uvc.c      ****         CyU3PDmaCBInput_t *input)
3154:../uvc.c      **** {
3155:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
3156:../uvc.c      ****     {
3157:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
3158:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
3159:../uvc.c      ****     }
3160:../uvc.c      **** }
3161:../uvc.c      **** #endif
3162:../uvc.c      **** 
3163:../uvc.c      **** #if 0
3164:../uvc.c      **** static void CyFxAppIntEpCb(
3165:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
3166:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
3167:../uvc.c      **** 		uint8_t  ebNum)
3168:../uvc.c      **** 		{
3169:../uvc.c      **** 			//CyBool_t value;
3170:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
3171:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
3172:../uvc.c      **** 
3173:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
3174:../uvc.c      **** 		}
3175:../uvc.c      **** #endif
3176:../uvc.c      **** 
3177:../uvc.c      **** /* This function initializes the USB Module, creates event group,
3178:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
3179:../uvc.c      ****    configures the DMA module for the UVC Application */
3180:../uvc.c      **** static void
3181:../uvc.c      **** CyFxUVCApplnInit (void)
3182:../uvc.c      **** {
3183:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
3184:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
3185:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
3186:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
3187:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
3188:../uvc.c      ****     CyU3PPibClock_t              pibclock;
3189:../uvc.c      **** 
3190:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
3191:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
3192:../uvc.c      **** 
3193:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3194:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
3195:../uvc.c      **** #endif
3196:../uvc.c      **** 
3197:../uvc.c      ****     /* Create UVC event group */
3198:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
3199:../uvc.c      ****     if (apiRetStatus != 0)
3200:../uvc.c      ****     {
3201:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
3202:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3203:../uvc.c      ****     }
3204:../uvc.c      **** 
3205:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3206:../uvc.c      ****     CyFxUvcAppPTZInit ();
3207:../uvc.c      **** #endif
3208:../uvc.c      **** 
3209:../uvc.c      ****     isUsbConnected = CyFalse;
3210:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
3211:../uvc.c      **** 
3212:../uvc.c      ****     /* Init the GPIO module */
3213:../uvc.c      ****     gpioClock.fastClkDiv = 2;
3214:../uvc.c      ****     gpioClock.slowClkDiv = 2;
3215:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
3216:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
3217:../uvc.c      ****     gpioClock.halfDiv    = 0;
3218:../uvc.c      **** 
3219:../uvc.c      ****     /* Initialize Gpio interface */
3220:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
3221:../uvc.c      ****     if (apiRetStatus != 0)
3222:../uvc.c      ****     {
3223:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
3224:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3225:../uvc.c      ****     }
3226:../uvc.c      **** 
3227:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
3228:../uvc.c      ****      * must use GpioOverride to configure it */
3229:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
3230:../uvc.c      ****     if (apiRetStatus != 0)
3231:../uvc.c      ****     {
3232:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
3233:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3234:../uvc.c      ****     }
3235:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
3236:../uvc.c      ****     if (apiRetStatus != 0)
3237:../uvc.c      ****     {
3238:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
3239:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3240:../uvc.c      ****     }
3241:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
3242:../uvc.c      ****     if (apiRetStatus != 0)
3243:../uvc.c      ****     {
3244:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
3245:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3246:../uvc.c      ****     }
3247:../uvc.c      **** 
3248:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
3249:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
3250:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
3251:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
3252:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
3253:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3254:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
3255:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3256:../uvc.c      ****     {
3257:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
3258:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3259:../uvc.c      ****     }
3260:../uvc.c      **** 
3261:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
3262:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
3263:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
3264:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
3265:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
3266:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
3267:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3268:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
3269:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3270:../uvc.c      ****     {
3271:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
3272:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3273:../uvc.c      ****     }
3274:../uvc.c      **** 
3275:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
3276:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
3277:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
3278:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
3279:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
3280:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
3281:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3282:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
3283:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3284:../uvc.c      ****     {
3285:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
3286:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3287:../uvc.c      ****     }
3288:../uvc.c      **** 
3289:../uvc.c      ****     /* Initialize the P-port. */
3290:../uvc.c      ****     pibclock.clkDiv      = 2;
3291:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
3292:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
3293:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
3294:../uvc.c      **** 
3295:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
3296:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3297:../uvc.c      ****     {
3298:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
3299:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3300:../uvc.c      ****     }
3301:../uvc.c      **** 
3302:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
3303:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
3304:../uvc.c      **** 
3305:../uvc.c      **** #ifdef BACKFLOW_DETECT
3306:../uvc.c      ****     back_flow_detected = 0;
3307:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
3308:../uvc.c      **** #endif
3309:../uvc.c      **** 
3310:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
3311:../uvc.c      ****     SensorReset ();
3312:../uvc.c      ****     CyU3PThreadSleep(5000);
3313:../uvc.c      ****     //SensorInit ();
3314:../uvc.c      **** 
3315:../uvc.c      ****     /* USB initialization. */
3316:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
3317:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3318:../uvc.c      ****     {
3319:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
3320:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3321:../uvc.c      ****     }
3322:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
3323:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
3324:../uvc.c      **** 
3325:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
3326:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
3327:../uvc.c      **** 
3328:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
3329:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
3330:../uvc.c      **** 
3331:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
3332:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
3333:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
3334:../uvc.c      **** 
3335:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
3336:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
3337:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
3338:../uvc.c      **** 
3339:../uvc.c      ****     /* Configuration descriptors. */
3340:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
3341:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
3342:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
3343:../uvc.c      **** 
3344:../uvc.c      ****     /* String Descriptors */
3345:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
3346:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
3347:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
3348:../uvc.c      **** 
3349:../uvc.c      ****     /* Configure the status interrupt endpoint.
3350:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
3351:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
3352:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
3353:../uvc.c      ****      */
3354:../uvc.c      ****     endPointConfig.enable   = 1;
3355:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
3356:../uvc.c      ****     endPointConfig.pcktSize = 64;
3357:../uvc.c      ****     endPointConfig.isoPkts  = 0;
3358:../uvc.c      ****     endPointConfig.streams  = 0;
3359:../uvc.c      ****     endPointConfig.burstLen = 1;
3360:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
3361:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3362:../uvc.c      ****     {
3363:../uvc.c      ****         /* Error Handling */
3364:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
3365:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3366:../uvc.c      ****     }
3367:../uvc.c      **** 
3368:../uvc.c      ****     /* create a DMA for interrupt endpoint */
3369:../uvc.c      ****     dmaInterConfig.size           = 1024;
3370:../uvc.c      ****     dmaInterConfig.count          = 1;
3371:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
3372:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
3373:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
3374:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
3375:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
3376:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
3377:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3378:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
3379:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
3380:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
3381:../uvc.c      ****             &dmaInterConfig);
3382:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3383:../uvc.c      ****     {
3384:../uvc.c      ****         /* Error handling */
3385:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
3386:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3387:../uvc.c      ****     }
3388:../uvc.c      **** 
3389:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
3390:../uvc.c      ****     if (glInterStaBuffer == 0)
3391:../uvc.c      ****     {
3392:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
3393:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
3394:../uvc.c      ****     }
3395:../uvc.c      **** 
3396:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
3397:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
3398:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
3399:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
3400:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
3401:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
3402:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
3403:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
3404:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
3405:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
3406:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
3407:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
3408:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3409:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
3410:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
3411:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
3412:../uvc.c      ****             &dmaMultiConfig);
3413:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3414:../uvc.c      ****     {
3415:../uvc.c      ****         /* Error handling */
3416:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
3417:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3418:../uvc.c      ****     }
3419:../uvc.c      **** 
3420:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3421:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
3422:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
3423:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
3424:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
3425:../uvc.c      ****      */
3426:../uvc.c      **** 
3427:../uvc.c      ****     endPointConfig.enable   = 1;
3428:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
3429:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
3430:../uvc.c      ****     endPointConfig.isoPkts  = 0;
3431:../uvc.c      ****     endPointConfig.streams  = 0;
3432:../uvc.c      ****     endPointConfig.burstLen = 1;
3433:../uvc.c      **** 
3434:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
3435:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3436:../uvc.c      ****     {
3437:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
3438:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3439:../uvc.c      ****     }
3440:../uvc.c      **** 
3441:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
3442:../uvc.c      **** 
3443:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
3444:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3445:../uvc.c      ****     {
3446:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
3447:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3448:../uvc.c      ****     }
3449:../uvc.c      **** 
3450:../uvc.c      ****     channelConfig.size           = 1024;
3451:../uvc.c      ****     channelConfig.count          = 1;
3452:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
3453:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
3454:../uvc.c      ****     channelConfig.prodAvailCount = 0;
3455:../uvc.c      ****     channelConfig.prodHeader     = 0;
3456:../uvc.c      ****     channelConfig.prodFooter     = 0;
3457:../uvc.c      ****     channelConfig.consHeader     = 0;
3458:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3459:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
3460:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
3461:../uvc.c      **** 
3462:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
3463:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3464:../uvc.c      ****     {
3465:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
3466:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3467:../uvc.c      ****     }
3468:../uvc.c      **** 
3469:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
3470:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3471:../uvc.c      ****     {
3472:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
3473:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3474:../uvc.c      ****     }
3475:../uvc.c      **** 
3476:../uvc.c      ****     channelConfig.size           = 1024;
3477:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
3478:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
3479:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
3480:../uvc.c      ****     channelConfig.prodAvailCount = 0;
3481:../uvc.c      ****     channelConfig.prodHeader     = 0;
3482:../uvc.c      ****     channelConfig.prodFooter     = 0;
3483:../uvc.c      ****     channelConfig.consHeader     = 0;
3484:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3485:../uvc.c      ****     channelConfig.notification   = 0;
3486:../uvc.c      ****     channelConfig.cb             = 0;
3487:../uvc.c      **** 
3488:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
3489:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3490:../uvc.c      ****     {
3491:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
3492:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3493:../uvc.c      ****     }
3494:../uvc.c      **** 
3495:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
3496:../uvc.c      ****     if (glDebugRspBuffer == 0)
3497:../uvc.c      ****     {
3498:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
3499:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
3500:../uvc.c      ****     }
3501:../uvc.c      **** #endif
3502:../uvc.c      **** 
3503:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
3504:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
3505:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3506:../uvc.c      ****     {
3507:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
3508:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3509:../uvc.c      ****     }
3510:../uvc.c      **** 
3511:../uvc.c      ****     CyU3PBusyWait(100);
3512:../uvc.c      **** 
3513:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
3514:../uvc.c      **** 
3515:../uvc.c      ****     endPointConfig.enable   = 1;
3516:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
3517:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
3518:../uvc.c      ****     {
3519:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
3520:../uvc.c      ****     	endPointConfig.burstLen = 16;
3521:../uvc.c      ****     }
3522:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
3523:../uvc.c      ****     {
3524:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
3525:../uvc.c      ****     	endPointConfig.burstLen = 1;
3526:../uvc.c      ****     }
3527:../uvc.c      ****     endPointConfig.streams  = 0;
3528:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
3529:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3530:../uvc.c      ****     {
3531:../uvc.c      ****         /* Error Handling */
3532:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
3533:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3534:../uvc.c      ****     }
3535:../uvc.c      **** #if 0    //for still image method 3 using
3536:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
3537:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3538:../uvc.c      ****     {
3539:../uvc.c      ****         /* Error Handling */
3540:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
3541:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3542:../uvc.c      ****     }
3543:../uvc.c      **** #endif
3544:../uvc.c      **** 
3545:../uvc.c      **** }
3546:../uvc.c      **** 
3547:../uvc.c      **** /*
3548:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
3549:../uvc.c      ****  * streaming session is started.
3550:../uvc.c      ****  */
3551:../uvc.c      **** static void
3552:../uvc.c      **** CyFxUvcAppGpifInit (
3553:../uvc.c      ****         void)
3554:../uvc.c      **** {
3555:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
3556:../uvc.c      **** 
3557:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3558:../uvc.c      ****     {
3559:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
3560:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
3561:../uvc.c      ****     }
3562:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
3563:../uvc.c      ****     {
3564:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
3565:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
3566:../uvc.c      ****     }
3567:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3568:../uvc.c      ****     {
3569:../uvc.c      ****         /* Error Handling */
3570:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
3571:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3572:../uvc.c      ****     }
3573:../uvc.c      **** 
3574:../uvc.c      ****     /* Start the state machine from the designated start state. */
3575:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3576:../uvc.c      ****     {
3577:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
3578:../uvc.c      ****     }
3579:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
3580:../uvc.c      ****     {
3581:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
3582:../uvc.c      ****     }
3583:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3584:../uvc.c      ****     {
3585:../uvc.c      ****         /* Error Handling */
3586:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
3587:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3588:../uvc.c      ****     }
3589:../uvc.c      **** }
3590:../uvc.c      **** 
3591:../uvc.c      **** /*
3592:../uvc.c      ****  * Entry function for the UVC Application Thread
3593:../uvc.c      ****  */
3594:../uvc.c      **** 
3595:../uvc.c      **** uint32_t posTick;
3596:../uvc.c      **** CyU3PTimer I2CCmdTimer;
3597:../uvc.c      **** 
3598:../uvc.c      **** void  I2CCmdCb(uint32_t input){
  22              		.loc 1 3598 0
  23              		.cfi_startproc
  24              		@ args = 0, pretend = 0, frame = 0
  25              		@ frame_needed = 0, uses_anonymous_args = 0
  26              	.LVL0:
3599:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  27              		.loc 1 3599 0
  28 0000 28209FE5 		ldr	r2, .L2
3598:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  29              		.loc 1 3598 0
  30 0004 08402DE9 		stmfd	sp!, {r3, lr}
  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 3, -8
  34              		.cfi_offset 14, -4
  35              		.loc 1 3599 0
  36 0008 002092E5 		ldr	r2, [r2]
3598:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  37              		.loc 1 3598 0
  38 000c 0030A0E1 		mov	r3, r0
  39              		.loc 1 3599 0
  40 0010 1C109FE5 		ldr	r1, .L2+4
  41 0014 0400A0E3 		mov	r0, #4
  42              	.LVL1:
  43 0018 FEFFFFEB 		bl	CyU3PDebugPrint
  44              	.LVL2:
3600:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  45              		.loc 1 3600 0
  46 001c 14009FE5 		ldr	r0, .L2+8
  47 0020 2010A0E3 		mov	r1, #32
  48 0024 0020A0E3 		mov	r2, #0
3601:../uvc.c      **** }
  49              		.loc 1 3601 0
  50 0028 0840BDE8 		ldmfd	sp!, {r3, lr}
3600:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  51              		.loc 1 3600 0
  52 002c FEFFFFEA 		b	_txe_event_flags_set
  53              	.LVL3:
  54              	.L3:
  55              		.align	2
  56              	.L2:
  57 0030 00000000 		.word	posTick
  58 0034 00000000 		.word	.LC0
  59 0038 00000000 		.word	.LANCHOR0
  60              		.cfi_endproc
  61              	.LFE18:
  63              		.align	2
  65              	UVCHandleVideoStreamingRqts:
  66              	.LFB24:
3602:../uvc.c      **** 
3603:../uvc.c      **** 
3604:../uvc.c      **** void
3605:../uvc.c      **** UVCAppThread_Entry (
3606:../uvc.c      ****         uint32_t input)
3607:../uvc.c      **** {
3608:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
3609:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
3610:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
3611:../uvc.c      ****     uint8_t i = 0;
3612:../uvc.c      ****     uint32_t flag;
3613:../uvc.c      ****     uint32_t prinflag = 0;
3614:../uvc.c      **** static uint8_t IMcount = 0;
3615:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
3616:../uvc.c      ****     uint32_t frameCnt = 0;
3617:../uvc.c      **** #endif
3618:../uvc.c      ****     /* Initialize the Uart Debug Module */
3619:../uvc.c      ****     CyFxUVCApplnDebugInit ();
3620:../uvc.c      **** 
3621:../uvc.c      ****     /* Initialize the I2C interface */
3622:../uvc.c      **** 	while (i++ < 6){
3623:../uvc.c      **** 		CyU3PThreadSleep(500);
3624:../uvc.c      **** 	}
3625:../uvc.c      **** 
3626:../uvc.c      ****     CyFxUVCApplnI2CInit ();
3627:../uvc.c      **** 
3628:../uvc.c      ****     /* Initialize the UVC Application */
3629:../uvc.c      ****     CyFxUVCApplnInit ();
3630:../uvc.c      ****     /*
3631:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
3632:../uvc.c      **** 
3633:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
3634:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
3635:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
3636:../uvc.c      **** 
3637:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
3638:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
3639:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
3640:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
3641:../uvc.c      **** 
3642:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
3643:../uvc.c      ****        of handling the abort request.
3644:../uvc.c      ****      */
3645:../uvc.c      **** 
3646:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
3647:../uvc.c      ****     //CyU3PThreadSleep(1000);
3648:../uvc.c      **** 
3649:../uvc.c      ****     for (;;)
3650:../uvc.c      ****     {
3651:../uvc.c      ****         /* Waiting for the Video Stream Event */
3652:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
3653:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3654:../uvc.c      ****         {
3655:../uvc.c      **** #if 0 //test for new firmware no video bring up
3656:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
3657:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
3658:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
3659:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
3660:../uvc.c      ****             {
3661:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
3662:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
3663:../uvc.c      ****                 {
3664:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3665:../uvc.c      **** #ifdef  USB_LOWRES_IMG
3666:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
3667:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
3668:../uvc.c      **** #endif
3669:../uvc.c      **** #endif
3670:../uvc.c      ****                     }
3671:../uvc.c      ****                 else
3672:../uvc.c      ****                 {
3673:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
3674:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3675:../uvc.c      **** #ifdef USB_LOWRES_IMG
3676:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
3677:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3678:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
3679:../uvc.c      **** #endif
3680:../uvc.c      **** #endif
3681:../uvc.c      ****                 }
3682:../uvc.c      **** 
3683:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
3684:../uvc.c      ****                 prodCount++;
3685:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
3686:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
3687:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
3688:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3689:../uvc.c      ****                 {
3690:../uvc.c      ****                     prodCount--;
3691:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
3692:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
3693:../uvc.c      ****                 }
3694:../uvc.c      ****             }
3695:../uvc.c      **** #endif
3696:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
3697:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
3698:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
3699:../uvc.c      ****             {
3700:../uvc.c      ****             	if(0&&(prinflag == 0)){
3701:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
3702:../uvc.c      ****             		prinflag = 1;
3703:../uvc.c      ****             	}
3704:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
3705:../uvc.c      ****             	fb=0;
3706:../uvc.c      ****             	pb=0;
3707:../uvc.c      ****             	pbc=0;
3708:../uvc.c      ****                 prodCount = 0;
3709:../uvc.c      ****                 consCount = 0;
3710:../uvc.c      ****                 hitFV     = CyFalse;
3711:../uvc.c      **** 
3712:../uvc.c      **** #ifdef BACKFLOW_DETECT
3713:../uvc.c      ****                 back_flow_detected = 0;
3714:../uvc.c      **** #endif
3715:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
3716:../uvc.c      ****                 frameCnt++;
3717:../uvc.c      **** #endif
3718:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
3719:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
3720:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
3721:../uvc.c      ****                 //}
3722:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
3723:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3724:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
3725:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
3726:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3727:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
3728:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
3729:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
3730:../uvc.c      ****                      	//CyU3PThreadSleep(100);
3731:../uvc.c      ****                 		stiflag = 0xFF;
3732:../uvc.c      ****                 		IMcount = 0;
3733:../uvc.c      ****                 	}
3734:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
3735:../uvc.c      **** 
3736:../uvc.c      ****                  		if(IMcount++ >= 0x3){
3737:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
3738:../uvc.c      ****                 		stiflag = 0x0F;
3739:../uvc.c      ****                 		IMcount = 0;
3740:../uvc.c      ****                 		}
3741:../uvc.c      ****                  		/*if(IMcount > 0x4){
3742:../uvc.c      ****                 			stiflag = 0x0F;
3743:../uvc.c      ****                 			IMcount = 0;
3744:../uvc.c      ****                 		}*/
3745:../uvc.c      **** 
3746:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
3747:../uvc.c      ****                     //CyU3PThreadSleep(400);
3748:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3749:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3750:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
3751:../uvc.c      **** 
3752:../uvc.c      ****                 	if(IMcount++ >= 0x3)
3753:../uvc.c      ****                 	{
3754:../uvc.c      ****                     switch (setRes)
3755:../uvc.c      ****                      {
3756:../uvc.c      ****                  	case 1: //1944
3757:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR_WR/*boardID
3758:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3759:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x22:0xA2
3760:../uvc.c      ****                  		break;
3761:../uvc.c      ****                  	case 2: //1080
3762:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR_WR/*boardID
3763:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3764:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x12:0x92
3765:../uvc.c      ****                  		break;
3766:../uvc.c      ****                  	case 3: //720
3767:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, I2C_DSPBOARD
3768:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3769:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x02:0x
3770:../uvc.c      ****                  		break;
3771:../uvc.c      ****                  	case 4: //VGA
3772:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x32:0xB2)&0xFC)|ROIMode, I2C_DSPBOARD
3773:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3774:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x32:0x
3775:../uvc.c      ****                  		break;
3776:../uvc.c      ****                  	default:
3777:../uvc.c      ****                  		break;
3778:../uvc.c      ****                      }
3779:../uvc.c      ****                     IMcount = 0;
3780:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3781:../uvc.c      ****                 	stiflag = 0x0;
3782:../uvc.c      ****                 	}
3783:../uvc.c      ****                 }
3784:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
3785:../uvc.c      ****                 /* Reset the DMA channel. */
3786:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3787:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3788:../uvc.c      ****                 {
3789:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
3790:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3791:../uvc.c      ****                 }
3792:../uvc.c      **** 
3793:../uvc.c      ****                 /* Start Channel Immediately */
3794:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3795:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3796:../uvc.c      ****                 {
3797:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
3798:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3799:../uvc.c      ****                 }
3800:../uvc.c      **** 
3801:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
3802:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
3803:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3804:../uvc.c      ****                 }
3805:../uvc.c      ****         }
3806:../uvc.c      ****         else
3807:../uvc.c      ****         {
3808:../uvc.c      ****             /* If we have a stream abort request pending. */
3809:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
3810:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3811:../uvc.c      ****             {
3812:../uvc.c      ****                 hitFV     = CyFalse;
3813:../uvc.c      ****                 prodCount = 0;
3814:../uvc.c      ****                 consCount = 0;
3815:../uvc.c      ****                 if(0&&(prinflag == 0)){
3816:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
3817:../uvc.c      ****                 	prinflag = 1;
3818:../uvc.c      ****                 }
3819:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
3820:../uvc.c      ****                 fb=0;
3821:../uvc.c      ****                 pb=0;
3822:../uvc.c      ****                 pbc=0;
3823:../uvc.c      **** 
3824:../uvc.c      ****                 if (!clearFeatureRqtReceived)
3825:../uvc.c      ****                 {
3826:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3827:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
3828:../uvc.c      ****                     {
3829:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
3830:../uvc.c      ****                     }
3831:../uvc.c      **** 
3832:../uvc.c      ****                     /* Flush the Endpoint memory */
3833:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
3834:../uvc.c      ****                 }
3835:../uvc.c      **** 
3836:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
3837:../uvc.c      ****             }
3838:../uvc.c      ****             else
3839:../uvc.c      ****             {
3840:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
3841:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
3842:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
3843:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
3844:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
3845:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3846:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3847:../uvc.c      ****                 {
3848:../uvc.c      ****                     /* Error handling */
3849:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
3850:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3851:../uvc.c      ****                 }
3852:../uvc.c      **** 
3853:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
3854:../uvc.c      ****                 if (gpif_initialized == CyFalse)
3855:../uvc.c      ****                 {
3856:../uvc.c      **** #if 0
3857:../uvc.c      ****                 	//for start up of the AF Lens
3858:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3859:../uvc.c      ****                     CyU3PThreadSleep(500);
3860:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3861:../uvc.c      ****                     CyU3PThreadSleep(500);
3862:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
3863:../uvc.c      ****                    	CyU3PThreadSleep(300);
3864:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3865:../uvc.c      ****                     CyU3PThreadSleep(500);
3866:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3867:../uvc.c      ****                     CyU3PThreadSleep(500);
3868:../uvc.c      **** #endif
3869:../uvc.c      **** #if 0
3870:../uvc.c      ****                     switch (setRes)
3871:../uvc.c      ****                     {
3872:../uvc.c      ****                     	case 1: //1944
3873:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x64, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3874:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3875:../uvc.c      ****                     		break;
3876:../uvc.c      ****                     	case 2: //1080
3877:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x54, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3878:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3879:../uvc.c      ****                     		break;
3880:../uvc.c      ****                     	case 3: //720
3881:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x45, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3882:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3883:../uvc.c      ****                     		break;
3884:../uvc.c      ****                     	default:
3885:../uvc.c      ****                     		break;
3886:../uvc.c      ****                     }
3887:../uvc.c      **** #endif
3888:../uvc.c      ****                     CyFxUvcAppGpifInit ();
3889:../uvc.c      **** 
3890:../uvc.c      ****                     gpif_initialized = CyTrue;
3891:../uvc.c      ****                     CyU3PThreadSleep(200);
3892:../uvc.c      ****                     
3893:../uvc.c      ****                 }
3894:../uvc.c      ****                 else
3895:../uvc.c      ****                 {
3896:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
3897:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
3898:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3899:../uvc.c      ****                 }
3900:../uvc.c      ****             }
3901:../uvc.c      ****         }
3902:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
3903:../uvc.c      **** 
3904:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
3905:../uvc.c      ****         CyU3PThreadRelinquish ();
3906:../uvc.c      ****     }
3907:../uvc.c      **** }
3908:../uvc.c      **** 
3909:../uvc.c      **** /*
3910:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
3911:../uvc.c      ****  */
3912:../uvc.c      **** 
3913:../uvc.c      **** static void
3914:../uvc.c      **** UVCHandleProcessingUnitRqts (
3915:../uvc.c      ****         void)
3916:../uvc.c      **** {
3917:../uvc.c      ****     uint8_t CtrlAdd;
3918:../uvc.c      **** #ifdef DbgInfo
3919:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3920:../uvc.c      **** #endif
3921:../uvc.c      ****     switch (wValue)
3922:../uvc.c      ****     {
3923:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
3924:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
3925:../uvc.c      ****     		ControlHandle(BLCCtlID0);
3926:../uvc.c      ****     		break;
3927:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
3928:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
3929:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
3930:../uvc.c      ****     		break;
3931:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
3932:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
3933:../uvc.c      **** 			ControlHandle(ConsCtlID2);
3934:../uvc.c      **** 			break;
3935:../uvc.c      **** 
3936:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
3937:../uvc.c      **** 
3938:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
3939:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
3940:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
3941:../uvc.c      ****       		break;
3942:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
3943:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
3944:../uvc.c      ****      		ControlHandle(HueCtlID5);
3945:../uvc.c      ****      		break;
3946:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
3947:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
3948:../uvc.c      ****           		ControlHandle(SaturCtlID6);
3949:../uvc.c      ****           		break;
3950:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
3951:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
3952:../uvc.c      ****           		ControlHandle(ShapCtlID7);
3953:../uvc.c      ****           		break;
3954:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
3955:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
3956:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
3957:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
3958:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
3959:../uvc.c      ****     		break;
3960:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
3961:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
3962:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
3963:../uvc.c      ****     		break;
3964:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
3965:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
3966:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
3967:../uvc.c      ****     		break;
3968:../uvc.c      **** 
3969:../uvc.c      ****         default:
3970:../uvc.c      ****             /*
3971:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3972:../uvc.c      ****              * other controls.
3973:../uvc.c      ****              */
3974:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3975:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3976:../uvc.c      ****             break;
3977:../uvc.c      ****     }
3978:../uvc.c      **** }
3979:../uvc.c      **** 
3980:../uvc.c      **** /*
3981:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
3982:../uvc.c      ****  */
3983:../uvc.c      **** static void
3984:../uvc.c      **** UVCHandleCameraTerminalRqts (
3985:../uvc.c      ****         void)
3986:../uvc.c      **** {
3987:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3988:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3989:../uvc.c      ****     uint16_t readCount;
3990:../uvc.c      ****     uint16_t zoomVal;
3991:../uvc.c      ****     int32_t  panVal, tiltVal;
3992:../uvc.c      ****     CyBool_t sendData = CyFalse;
3993:../uvc.c      **** #endif
3994:../uvc.c      ****     uint8_t CtrlAdd;
3995:../uvc.c      **** 
3996:../uvc.c      ****     switch (wValue)
3997:../uvc.c      ****     {
3998:../uvc.c      **** #if 0 // cancel the CT controls
3999:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
4000:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
4001:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
4002:../uvc.c      ****     		break;
4003:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
4004:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
4005:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
4006:../uvc.c      ****     		break;
4007:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
4008:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
4009:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
4010:../uvc.c      **** 			break;
4011:../uvc.c      **** 
4012:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
4013:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
4014:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
4015:../uvc.c      **** 			break;
4016:../uvc.c      **** 
4017:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
4018:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
4019:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
4020:../uvc.c      ****       		break;
4021:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
4022:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
4023:../uvc.c      ****      		CTControlHandle(FocACtlID5);
4024:../uvc.c      ****      		break;
4025:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
4026:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
4027:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
4028:../uvc.c      ****           		break;
4029:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
4030:../uvc.c      ****           		break;
4031:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
4032:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
4033:../uvc.c      ****      		CTControlHandle(IriACtlID7);
4034:../uvc.c      ****      		break;
4035:../uvc.c      **** 
4036:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
4037:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
4038:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
4039:../uvc.c      ****     		break;
4040:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
4041:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
4042:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
4043:../uvc.c      ****     		break;
4044:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
4045:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
4046:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
4047:../uvc.c      ****     		break;
4048:../uvc.c      **** #endif
4049:../uvc.c      ****         default:
4050:../uvc.c      ****             /*
4051:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
4052:../uvc.c      ****              * other controls.
4053:../uvc.c      ****              */
4054:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
4055:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4056:../uvc.c      ****             break;
4057:../uvc.c      ****     }
4058:../uvc.c      **** 
4059:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
4060:../uvc.c      ****     switch (wValue)
4061:../uvc.c      ****     {
4062:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
4063:../uvc.c      ****             switch (bRequest)
4064:../uvc.c      ****             {
4065:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4066:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
4067:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4068:../uvc.c      ****                     break;
4069:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
4070:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
4071:../uvc.c      ****                     sendData = CyTrue;
4072:../uvc.c      ****                     break;
4073:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
4074:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
4075:../uvc.c      ****                     sendData = CyTrue;
4076:../uvc.c      ****                     break;
4077:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
4078:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
4079:../uvc.c      ****                     sendData = CyTrue;
4080:../uvc.c      ****                     break;
4081:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
4082:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
4083:../uvc.c      ****                     sendData = CyTrue;
4084:../uvc.c      ****                     break;
4085:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
4086:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
4087:../uvc.c      ****                     sendData = CyTrue;
4088:../uvc.c      ****                     break;
4089:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4090:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4091:../uvc.c      ****                             glEp0Buffer, &readCount);
4092:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4093:../uvc.c      ****                     {
4094:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
4095:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
4096:../uvc.c      ****                     }
4097:../uvc.c      ****                     break;
4098:../uvc.c      ****                 default:
4099:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4100:../uvc.c      ****                     break;
4101:../uvc.c      ****             }
4102:../uvc.c      **** 
4103:../uvc.c      ****             if (sendData)
4104:../uvc.c      ****             {
4105:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
4106:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
4107:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
4108:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
4109:../uvc.c      ****             }
4110:../uvc.c      ****             break;
4111:../uvc.c      **** 
4112:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
4113:../uvc.c      ****             switch (bRequest)
4114:../uvc.c      ****             {
4115:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4116:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
4117:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4118:../uvc.c      ****                     break;
4119:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
4120:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
4121:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
4122:../uvc.c      ****                     sendData = CyTrue;
4123:../uvc.c      ****                     break;
4124:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
4125:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
4126:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
4127:../uvc.c      ****                     sendData = CyTrue;
4128:../uvc.c      ****                     break;
4129:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
4130:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
4131:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
4132:../uvc.c      ****                     sendData = CyTrue;
4133:../uvc.c      ****                     break;
4134:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
4135:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
4136:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
4137:../uvc.c      ****                     sendData = CyTrue;
4138:../uvc.c      ****                     break;
4139:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
4140:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
4141:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
4142:../uvc.c      ****                     sendData = CyTrue;
4143:../uvc.c      ****                     break;
4144:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4145:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4146:../uvc.c      ****                             glEp0Buffer, &readCount);
4147:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4148:../uvc.c      ****                     {
4149:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
4150:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
4151:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
4152:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
4153:../uvc.c      **** 
4154:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
4155:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
4156:../uvc.c      ****                     }
4157:../uvc.c      ****                     break;
4158:../uvc.c      ****                 default:
4159:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4160:../uvc.c      ****                     break;
4161:../uvc.c      ****             }
4162:../uvc.c      **** 
4163:../uvc.c      ****             if (sendData)
4164:../uvc.c      ****             {
4165:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
4166:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
4167:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
4168:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
4169:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
4170:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
4171:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
4172:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
4173:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
4174:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
4175:../uvc.c      ****             }
4176:../uvc.c      ****             break;
4177:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
4178:../uvc.c      ****         default:
4179:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
4180:../uvc.c      ****             break;
4181:../uvc.c      ****     }
4182:../uvc.c      **** #endif
4183:../uvc.c      **** }
4184:../uvc.c      **** 
4185:../uvc.c      **** /*
4186:../uvc.c      ****  * Handler for UVC Interface control requests.
4187:../uvc.c      ****  */
4188:../uvc.c      **** static void
4189:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
4190:../uvc.c      ****         void)
4191:../uvc.c      **** {
4192:../uvc.c      **** 
4193:../uvc.c      ****     switch (wValue)
4194:../uvc.c      ****     {
4195:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
4196:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
4197:../uvc.c      ****     		break;
4198:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
4199:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
4200:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
4201:../uvc.c      ****     		break;
4202:../uvc.c      ****     	default:
4203:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
4204:../uvc.c      ****      		break;
4205:../uvc.c      ****     }
4206:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
4207:../uvc.c      **** 
4208:../uvc.c      **** }
4209:../uvc.c      **** 
4210:../uvc.c      **** /*
4211:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
4212:../uvc.c      ****  */
4213:../uvc.c      **** static void
4214:../uvc.c      **** UVCHandleExtensionUnitRqts (
4215:../uvc.c      ****         void)
4216:../uvc.c      **** {
4217:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
4218:../uvc.c      **** 
4219:../uvc.c      **** #ifdef DbgInfo
4220:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
4221:../uvc.c      **** #endif
4222:../uvc.c      ****     switch (wValue)
4223:../uvc.c      ****     {
4224:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
4225:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
4226:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
4227:../uvc.c      ****     		break;
4228:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
4229:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
4230:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
4231:../uvc.c      ****     		break;
4232:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
4233:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
4234:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
4235:../uvc.c      ****      		break;
4236:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
4237:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
4238:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
4239:../uvc.c      ****     		break;
4240:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
4241:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
4242:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
4243:../uvc.c      ****     		break;
4244:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
4245:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
4246:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
4247:../uvc.c      ****      		break;
4248:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
4249:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
4250:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
4251:../uvc.c      ****     		break;
4252:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
4253:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
4254:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
4255:../uvc.c      ****     		break;
4256:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
4257:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
4258:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
4259:../uvc.c      ****      		break;
4260:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
4261:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
4262:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
4263:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
4264:../uvc.c      ****     		}else/* no support for 1080p camera */
4265:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
4266:../uvc.c      ****     		break;
4267:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
4268:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
4269:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
4270:../uvc.c      ****     		break;
4271:../uvc.c      **** 		case CY_FX_EXT_CONTROL_12: //AEx shutter level CONTROL12
4272:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCtlShutlevCtlID11][0];
4273:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
4274:../uvc.c      ****     		break;
4275:../uvc.c      **** 
4276:../uvc.c      ****     		//ExtCtlShutlevCtlID11
4277:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
4278:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
4279:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
4280:../uvc.c      ****     		break;
4281:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
4282:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
4283:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
4284:../uvc.c      ****     		//break;
4285:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
4286:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
4287:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
4288:../uvc.c      ****     		break;
4289:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
4290:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
4291:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
4292:../uvc.c      ****     		break;
4293:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
4294:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET][0];
4295:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
4296:../uvc.c      ****     		break;
4297:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
4298:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET][0];
4299:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
4300:../uvc.c      ****     		break;
4301:../uvc.c      **** 		case CY_FX_EXT_CONTROL_19BLC_GRID:   //BLD gain CONTROL19
4302:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET][0];
4303:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
4304:../uvc.c      ****     		break;
4305:../uvc.c      **** 		case CY_FX_EXT_CONTROL_20EXP_HYSTER: //exposure hysteresis CONTROL20
4306:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1ExHysterCtlID7-EXUAOFFSET][0];
4307:../uvc.c      ****       		ControlHandle(Ext1ExHysterCtlID7);
4308:../uvc.c      **** 			CyU3PDebugPrint (4, "The hyster command 0x%x 0x%x\r\n", wValue, bRequest);
4309:../uvc.c      ****     		break;
4310:../uvc.c      **** 		case CY_FX_EXT_CONTROL_21EXP_CTRLSPD: //exposure control speed CONTROL21
4311:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1ExCtrlSpeedCtlID8-EXUAOFFSET][0];
4312:../uvc.c      ****       		ControlHandle(Ext1ExCtrlSpeedCtlID8);
4313:../uvc.c      **** 			CyU3PDebugPrint (4, "The ctrlspd command 0x%x 0x%x\r\n", wValue, bRequest);
4314:../uvc.c      ****     		break;
4315:../uvc.c      **** 		case CY_FX_EXT_CONTROL_22ENHANCE_MODE: //edge enhancement mode CONTROL22
4316:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceModeCtlID9-EXUAOFFSET][0];
4317:../uvc.c      ****       		ControlHandle(Ext1EnhanceModeCtlID9);
4318:../uvc.c      **** 			CyU3PDebugPrint (4, "The edgeMode command 0x%x 0x%x\r\n", wValue, bRequest);
4319:../uvc.c      ****     		break;
4320:../uvc.c      **** 		case CY_FX_EXT_CONTROL_23ENHANCE_GAIN: //edge enhancement gain CONTROL23
4321:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceGainCtlID10-EXUAOFFSET][0];
4322:../uvc.c      ****       		ControlHandle(Ext1EnhanceGainCtlID10);
4323:../uvc.c      **** 			CyU3PDebugPrint (4, "The edgegain command 0x%x 0x%x\r\n", wValue, bRequest);
4324:../uvc.c      ****    		break;
4325:../uvc.c      **** 		case CY_FX_EXT_CONTROL_24ENHANCE_STED: //edge enhancement start/end CONTROL24
4326:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceStarEndCtlID11-EXUAOFFSET][0];
4327:../uvc.c      ****       		ControlHandle(Ext1EnhanceStarEndCtlID11);
4328:../uvc.c      **** 			CyU3PDebugPrint (4, "The edge start/end command 0x%x 0x%x\r\n", wValue, bRequest);
4329:../uvc.c      ****     		break;
4330:../uvc.c      **** 		case CY_FX_EXT_CONTROL_262DNR_STED: //2D noise reduction start/end CONTROL26
4331:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext12DNRGainStarEndCtlID13-EXUAOFFSET][0];
4332:../uvc.c      ****       		ControlHandle(Ext12DNRGainStarEndCtlID13);
4333:../uvc.c      **** 			CyU3PDebugPrint (4, "The 2DNR start/end command 0x%x 0x%x\r\n", wValue, bRequest);
4334:../uvc.c      ****     		break;
4335:../uvc.c      **** 		case CY_FX_EXT_CONTROL_27GAMMA_MODE: //gamma correction CONTROL27
4336:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1GammaCorCtlID14-EXUAOFFSET][0];
4337:../uvc.c      ****       		ControlHandle(Ext1GammaCorCtlID14);
4338:../uvc.c      **** 			CyU3PDebugPrint (4, "The gamma command 0x%x 0x%x\r\n", wValue, bRequest);
4339:../uvc.c      ****     		break;
4340:../uvc.c      **** 		case CY_FX_EXT_CONTROL_28AGC_MAX: //AGC Maximum limitation CONTROL28
4341:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1GammaCorCtlID14-EXUAOFFSET][0];
4342:../uvc.c      ****       		ControlHandle(Ext1AGCMaxLimetCtlID15);
4343:../uvc.c      **** 			CyU3PDebugPrint (4, "The AGC Max command 0x%x 0x%x\r\n", wValue, bRequest);
4344:../uvc.c      ****     		break;
4345:../uvc.c      **** 
4346:../uvc.c      ****    	default:
4347:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
4348:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
4349:../uvc.c      ****     		break;
4350:../uvc.c      ****     }
4351:../uvc.c      **** 
4352:../uvc.c      **** }
4353:../uvc.c      **** 
4354:../uvc.c      **** /*
4355:../uvc.c      ****  * Handler for the video streaming control requests.
4356:../uvc.c      ****  */
4357:../uvc.c      **** static void
4358:../uvc.c      **** UVCHandleVideoStreamingRqts (
4359:../uvc.c      ****         void)
4360:../uvc.c      **** {
  67              		.loc 1 4360 0
  68              		.cfi_startproc
  69              		@ args = 0, pretend = 0, frame = 8
  70              		@ frame_needed = 0, uses_anonymous_args = 0
  71              	.LVL4:
4361:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
4362:../uvc.c      ****     uint16_t readCount;
4363:../uvc.c      **** 
4364:../uvc.c      ****     switch (wValue)
  72              		.loc 1 4364 0
  73 003c A8369FE5 		ldr	r3, .L133
4360:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
  74              		.loc 1 4360 0
  75 0040 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
  76              	.LCFI1:
  77              		.cfi_def_cfa_offset 16
  78              		.cfi_offset 4, -16
  79              		.cfi_offset 5, -12
  80              		.cfi_offset 6, -8
  81              		.cfi_offset 14, -4
  82              		.loc 1 4364 0
  83 0044 B030D3E1 		ldrh	r3, [r3]
4360:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
  84              		.loc 1 4360 0
  85 0048 10D04DE2 		sub	sp, sp, #16
  86              	.LCFI2:
  87              		.cfi_def_cfa_offset 32
  88              		.loc 1 4364 0
  89 004c 030C53E3 		cmp	r3, #768
  90 0050 5200000A 		beq	.L6
  91 0054 1300008A 		bhi	.L7
  92 0058 010C53E3 		cmp	r3, #256
  93 005c 2400000A 		beq	.L8
  94 0060 020C53E3 		cmp	r3, #512
  95 0064 1C00001A 		bne	.L5
4365:../uvc.c      ****     {
4366:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
4367:../uvc.c      ****             switch (bRequest)
4368:../uvc.c      ****             {
4369:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4370:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
4371:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4372:../uvc.c      ****                     break;
4373:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
4374:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4375:../uvc.c      ****                     glEp0Buffer[1] = 0;
4376:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4377:../uvc.c      ****                     break;
4378:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
4379:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
4380:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
4381:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
4382:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
4383:../uvc.c      ****                     {
4384:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
4385:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
4386:../uvc.c      **** 
4387:../uvc.c      ****                     }
4388:../uvc.c      ****                     else
4389:../uvc.c      ****                     {
4390:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
4391:../uvc.c      ****                     }
4392:../uvc.c      ****                     break;
4393:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4394:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4395:../uvc.c      ****                             glCommitCtrl, &readCount);
4396:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4397:../uvc.c      ****                     {
4398:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4399:../uvc.c      ****                         {
4400:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
4401:../uvc.c      ****                                active data structure. */
4402:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
4403:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
4404:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
4405:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
4406:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
4407:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
4408:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
4409:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
4410:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
4411:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
4412:../uvc.c      **** #if 0
4413:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
4414:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
4415:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
4416:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
4417:../uvc.c      **** #endif
4418:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
4419:../uvc.c      ****                        }
4420:../uvc.c      ****                     }
4421:../uvc.c      ****                     break;
4422:../uvc.c      ****                 default:
4423:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4424:../uvc.c      ****                     break;
4425:../uvc.c      ****             }
4426:../uvc.c      ****             break;
4427:../uvc.c      **** 
4428:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
4429:../uvc.c      ****             switch (bRequest)
  96              		.loc 1 4429 0
  97 0068 80369FE5 		ldr	r3, .L133+4
  98 006c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
  99 0070 810053E3 		cmp	r3, #129
 100 0074 9000000A 		beq	.L23
 101 0078 AF00009A 		bls	.L127
 102              	.L53:
4430:../uvc.c      ****             {
4431:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4432:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
4433:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4434:../uvc.c      ****                     break;
4435:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
4436:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4437:../uvc.c      ****                     glEp0Buffer[1] = 0;
4438:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4439:../uvc.c      ****                     break;
4440:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
4441:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
4442:../uvc.c      ****                     {
4443:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
4444:../uvc.c      ****                     }
4445:../uvc.c      ****                     else
4446:../uvc.c      ****                     {
4447:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
4448:../uvc.c      ****                     }
4449:../uvc.c      ****                     break;
4450:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4451:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
4452:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
4453:../uvc.c      ****                        */
4454:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4455:../uvc.c      ****                             glCommitCtrl, &readCount);
4456:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4457:../uvc.c      ****                     {
4458:../uvc.c      ****                         switch (glCommitCtrl[3])
4459:../uvc.c      ****                          {
4460:../uvc.c      ****                          	case 1: //1944
4461:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR_WR/
4462:../uvc.c      ****                          		CyU3PThreadSleep(500);
4463:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
4464:../uvc.c      ****                          		break;
4465:../uvc.c      ****                          	case 2: //1080
4466:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR_WR/
4467:../uvc.c      ****                          		CyU3PThreadSleep(500);
4468:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
4469:../uvc.c      ****                          		break;
4470:../uvc.c      ****                          	case 3: //720
4471:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, I2C_
4472:../uvc.c      ****                          		CyU3PThreadSleep(500);
4473:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
4474:../uvc.c      ****                          		break;
4475:../uvc.c      ****                          	case 4: //VGA
4476:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x32:0xB2)&0xFC)|ROIMode, I2C_
4477:../uvc.c      ****                          		CyU3PThreadSleep(500);
4478:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
4479:../uvc.c      ****                          		break;
4480:../uvc.c      ****                          	default:
4481:../uvc.c      ****                          		break;
4482:../uvc.c      ****                          }
4483:../uvc.c      ****                         setRes = glCommitCtrl[3];
4484:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
4485:../uvc.c      **** 
4486:../uvc.c      **** #if 0
4487:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
4488:../uvc.c      ****                         {
4489:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
4490:../uvc.c      ****                         }
4491:../uvc.c      ****                         else
4492:../uvc.c      ****                         {
4493:../uvc.c      ****                             SensorScaling_VGA ();
4494:../uvc.c      ****                         }
4495:../uvc.c      **** #endif
4496:../uvc.c      ****                         /* We can start streaming video now. */
4497:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
4498:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
4499:../uvc.c      ****                         {
4500:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
4501:../uvc.c      ****                         }
4502:../uvc.c      ****                     }
4503:../uvc.c      ****                     break;
4504:../uvc.c      **** 
4505:../uvc.c      ****                 default:
4506:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4507:../uvc.c      ****                     break;
4508:../uvc.c      ****             }
4509:../uvc.c      ****             break;
4510:../uvc.c      **** 
4511:../uvc.c      **** /* still image streaming handler */
4512:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
4513:../uvc.c      ****                 switch (bRequest)
4514:../uvc.c      ****                 {
4515:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4516:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
4517:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4518:../uvc.c      ****                         break;
4519:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4520:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4521:../uvc.c      ****                         glEp0Buffer[1] = 0;
4522:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4523:../uvc.c      ****                         break;
4524:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
4525:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
4526:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
4527:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
4528:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4529:../uvc.c      ****                         {
4530:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4531:../uvc.c      ****                         }
4532:../uvc.c      ****                         else
4533:../uvc.c      ****                         {
4534:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4535:../uvc.c      ****                         }
4536:../uvc.c      ****                         break;
4537:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4538:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4539:../uvc.c      ****                                 glCommitCtrl, &readCount);
4540:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4541:../uvc.c      ****                         {
4542:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
4543:../uvc.c      ****                             {
4544:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
4545:../uvc.c      ****                                    active data structure. */
4546:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
4547:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
4548:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
4549:../uvc.c      ****                             	//glProbeStilCtrl[4] = glCommitCtrl[4];
4550:../uvc.c      ****                             	//glProbeStilCtrl[5] = glCommitCtrl[5];
4551:../uvc.c      ****                             	//glProbeStilCtrl[6] = glCommitCtrl[6];
4552:../uvc.c      ****                             }
4553:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
4554:../uvc.c      ****                         }
4555:../uvc.c      ****                         break;
4556:../uvc.c      ****                     default:
4557:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4558:../uvc.c      ****                         break;
4559:../uvc.c      ****                 }
4560:../uvc.c      ****                 break;
4561:../uvc.c      **** 
4562:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
4563:../uvc.c      ****                 switch (bRequest)
 103              		.loc 1 4563 0
 104 007c 850053E3 		cmp	r3, #133
 105 0080 2500000A 		beq	.L55
 106 0084 860053E3 		cmp	r3, #134
 107 0088 1300001A 		bne	.L5
 108              	.L120:
4564:../uvc.c      ****                 {
4565:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4566:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
4567:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4568:../uvc.c      ****                         break;
4569:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4570:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4571:../uvc.c      ****                         glEp0Buffer[1] = 0;
4572:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4573:../uvc.c      ****                         break;
4574:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
4575:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4576:../uvc.c      ****                         {
4577:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4578:../uvc.c      ****                         }
4579:../uvc.c      ****                         else
4580:../uvc.c      ****                         {
4581:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4582:../uvc.c      ****                         }
4583:../uvc.c      ****                         break;
4584:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4585:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4586:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4587:../uvc.c      ****                            */
4588:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4589:../uvc.c      ****                                 glCommitCtrl, &readCount);
4590:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4591:../uvc.c      ****                         {
4592:../uvc.c      ****     #if 0
4593:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
4594:../uvc.c      ****                             {
4595:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
4596:../uvc.c      ****                             }
4597:../uvc.c      ****                             else
4598:../uvc.c      ****                             {
4599:../uvc.c      ****                                 SensorScaling_VGA ();
4600:../uvc.c      ****                             }
4601:../uvc.c      ****                             /* We can start streaming video now. */
4602:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
4603:../uvc.c      **** 
4604:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4605:../uvc.c      ****                             {
4606:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
4607:../uvc.c      ****                             }
4608:../uvc.c      **** 	#endif
4609:../uvc.c      ****                            switch (glCommitCtrl[1])
4610:../uvc.c      ****                              {
4611:../uvc.c      ****                              	case 4: //1944
4612:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR
4613:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4614:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4615:../uvc.c      ****                              		break;
4616:../uvc.c      ****                              	case 3: //1080
4617:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR
4618:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4619:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4620:../uvc.c      ****                              		break;
4621:../uvc.c      ****                              	case 2: //720
4622:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, 
4623:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4624:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4625:../uvc.c      ****                              		break;
4626:../uvc.c      ****                             	case 1: //VGA
4627:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
4628:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4629:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4630:../uvc.c      ****                              		break;
4631:../uvc.c      ****                               	default:
4632:../uvc.c      ****                              		break;
4633:../uvc.c      ****                              }
4634:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
4635:../uvc.c      **** 
4636:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
4637:../uvc.c      **** 
4638:../uvc.c      ****                         }
4639:../uvc.c      ****                         break;
4640:../uvc.c      **** 
4641:../uvc.c      ****                     default:
4642:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4643:../uvc.c      ****                         break;
4644:../uvc.c      ****                 }
4645:../uvc.c      ****                 break;
4646:../uvc.c      **** 
4647:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
4648:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
4649:../uvc.c      ****             	switch (bRequest)
4650:../uvc.c      ****                 {
4651:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4652:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
 109              		.loc 1 4652 0
 110 008c 60169FE5 		ldr	r1, .L133+8
 111 0090 0330A0E3 		mov	r3, #3
 112 0094 2830E1E5 		strb	r3, [r1, #40]!
4653:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 113              		.loc 1 4653 0
 114 0098 0100A0E3 		mov	r0, #1
 115 009c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 116              	.LVL5:
4654:../uvc.c      ****                         break;
4655:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4656:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
4657:../uvc.c      ****                         glEp0Buffer[1] = 0;
4658:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4659:../uvc.c      ****                         break;
4660:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
4661:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4662:../uvc.c      ****                         {
4663:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4664:../uvc.c      ****                         }
4665:../uvc.c      ****                         else
4666:../uvc.c      ****                         {
4667:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4668:../uvc.c      ****                         }
4669:../uvc.c      ****                         break;
4670:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4671:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4672:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4673:../uvc.c      ****                            */
4674:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4675:../uvc.c      ****                                 glCommitCtrl, &readCount);
4676:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4677:../uvc.c      ****                         {
4678:../uvc.c      ****     #if 1
4679:../uvc.c      ****                             /* We can start still streaming video now. */
4680:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
4681:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4682:../uvc.c      ****                             {
4683:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
4684:../uvc.c      ****                             }
4685:../uvc.c      ****     #endif
4686:../uvc.c      ****                             else{
4687:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
4688:../uvc.c      ****                             //stillcont = 0;
4689:../uvc.c      ****                             }
4690:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
4691:../uvc.c      ****                         }else{
4692:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
4693:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
4694:../uvc.c      ****                         }
4695:../uvc.c      ****                         break;
4696:../uvc.c      **** 
4697:../uvc.c      ****                     default:
4698:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4699:../uvc.c      ****                         break;
4700:../uvc.c      ****                 }
4701:../uvc.c      ****                 break;
4702:../uvc.c      **** 
4703:../uvc.c      ****         default:
4704:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4705:../uvc.c      ****             break;
4706:../uvc.c      ****     }
4707:../uvc.c      **** }
 117              		.loc 1 4707 0
 118 00a0 10D08DE2 		add	sp, sp, #16
 119              		@ sp needed
 120 00a4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 121              	.L7:
4364:../uvc.c      ****     {
 122              		.loc 1 4364 0
 123 00a8 010B53E3 		cmp	r3, #1024
 124 00ac 2400000A 		beq	.L10
 125 00b0 050C53E3 		cmp	r3, #1280
 126 00b4 0800001A 		bne	.L5
4649:../uvc.c      ****                 {
 127              		.loc 1 4649 0
 128 00b8 30369FE5 		ldr	r3, .L133+4
 129 00bc 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
 130 00c0 810055E3 		cmp	r5, #129
 131 00c4 7C00000A 		beq	.L23
 132 00c8 8300009A 		bls	.L128
 133 00cc 850055E3 		cmp	r5, #133
 134 00d0 6601000A 		beq	.L76
 135 00d4 860055E3 		cmp	r5, #134
 136 00d8 EBFFFF0A 		beq	.L120
 137              	.L5:
4704:../uvc.c      ****             break;
 138              		.loc 1 4704 0
 139 00dc 0000A0E3 		mov	r0, #0
 140 00e0 0020A0E1 		mov	r2, r0
 141 00e4 0110A0E3 		mov	r1, #1
 142 00e8 FEFFFFEB 		bl	CyU3PUsbStall
 143              	.LVL6:
 144              	.L4:
 145              		.loc 1 4707 0
 146 00ec 10D08DE2 		add	sp, sp, #16
 147              		@ sp needed
 148 00f0 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 149              	.LVL7:
 150              	.L8:
4367:../uvc.c      ****             {
 151              		.loc 1 4367 0
 152 00f4 F4459FE5 		ldr	r4, .L133+4
 153 00f8 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 154 00fc 830053E3 		cmp	r3, #131
 155 0100 5100009A 		bls	.L129
 156 0104 860053E3 		cmp	r3, #134
 157 0108 DFFFFF0A 		beq	.L120
 158 010c 870053E3 		cmp	r3, #135
 159 0110 5901000A 		beq	.L14
 160              	.L125:
4513:../uvc.c      ****                 {
 161              		.loc 1 4513 0
 162 0114 850053E3 		cmp	r3, #133
 163 0118 EFFFFF1A 		bne	.L5
 164              	.L55:
4570:../uvc.c      ****                         glEp0Buffer[1] = 0;
 165              		.loc 1 4570 0
 166 011c D0359FE5 		ldr	r3, .L133+8
 167 0120 1AC0A0E3 		mov	ip, #26
 168              	.L121:
4657:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 169              		.loc 1 4657 0
 170 0124 0020A0E3 		mov	r2, #0
4658:../uvc.c      ****                         break;
 171              		.loc 1 4658 0
 172 0128 281083E2 		add	r1, r3, #40
 173 012c 0200A0E3 		mov	r0, #2
4656:../uvc.c      ****                         glEp0Buffer[1] = 0;
 174              		.loc 1 4656 0
 175 0130 28C0C3E5 		strb	ip, [r3, #40]
4657:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 176              		.loc 1 4657 0
 177 0134 2920C3E5 		strb	r2, [r3, #41]
4658:../uvc.c      ****                         break;
 178              		.loc 1 4658 0
 179 0138 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 180              	.LVL8:
 181              		.loc 1 4707 0
 182 013c 10D08DE2 		add	sp, sp, #16
 183              		@ sp needed
 184 0140 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 185              	.L10:
4563:../uvc.c      ****                 {
 186              		.loc 1 4563 0
 187 0144 A4359FE5 		ldr	r3, .L133+4
 188 0148 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 189 014c 810053E3 		cmp	r3, #129
 190 0150 1A00000A 		beq	.L44
 191 0154 C8FFFF8A 		bhi	.L53
 192 0158 010053E3 		cmp	r3, #1
 193 015c DEFFFF1A 		bne	.L5
4588:../uvc.c      ****                                 glCommitCtrl, &readCount);
 194              		.loc 1 4588 0
 195 0160 8C459FE5 		ldr	r4, .L133+8
 196 0164 2000A0E3 		mov	r0, #32
 197 0168 4C1084E2 		add	r1, r4, #76
 198 016c 08208DE2 		add	r2, sp, #8
 199 0170 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 200              	.LVL9:
4590:../uvc.c      ****                         {
 201              		.loc 1 4590 0
 202 0174 000050E3 		cmp	r0, #0
 203 0178 DBFFFF1A 		bne	.L4
4609:../uvc.c      ****                              {
 204              		.loc 1 4609 0
 205 017c 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
 206 0180 01304CE2 		sub	r3, ip, #1
 207 0184 030053E3 		cmp	r3, #3
 208 0188 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 209 018c B80000EA 		b	.L58
 210              	.L60:
 211 0190 F0040000 		.word	.L59
 212 0194 94040000 		.word	.L61
 213 0198 30040000 		.word	.L62
 214 019c 28060000 		.word	.L63
 215              	.LVL10:
 216              	.L6:
4513:../uvc.c      ****                 {
 217              		.loc 1 4513 0
 218 01a0 48359FE5 		ldr	r3, .L133+4
 219 01a4 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 220 01a8 830053E3 		cmp	r3, #131
 221 01ac 0B00009A 		bls	.L130
 222 01b0 860053E3 		cmp	r3, #134
 223 01b4 B4FFFF0A 		beq	.L120
 224 01b8 870053E3 		cmp	r3, #135
 225 01bc D4FFFF1A 		bne	.L125
 226              	.L44:
4528:../uvc.c      ****                         {
 227              		.loc 1 4528 0
 228 01c0 2C359FE5 		ldr	r3, .L133+8
4530:../uvc.c      ****                         }
 229              		.loc 1 4530 0
 230 01c4 0B00A0E3 		mov	r0, #11
4528:../uvc.c      ****                         {
 231              		.loc 1 4528 0
 232 01c8 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 233 01cc 030053E3 		cmp	r3, #3
4530:../uvc.c      ****                         }
 234              		.loc 1 4530 0
 235 01d0 20159F05 		ldreq	r1, .L133+12
4534:../uvc.c      ****                         }
 236              		.loc 1 4534 0
 237 01d4 20159F15 		ldrne	r1, .L133+16
 238 01d8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 239              	.LVL11:
 240 01dc C2FFFFEA 		b	.L4
 241              	.L130:
4513:../uvc.c      ****                 {
 242              		.loc 1 4513 0
 243 01e0 810053E3 		cmp	r3, #129
 244 01e4 F5FFFF2A 		bcs	.L44
 245 01e8 010053E3 		cmp	r3, #1
 246 01ec BAFFFF1A 		bne	.L5
4538:../uvc.c      ****                                 glCommitCtrl, &readCount);
 247              		.loc 1 4538 0
 248 01f0 FC449FE5 		ldr	r4, .L133+8
 249 01f4 2000A0E3 		mov	r0, #32
 250 01f8 4C1084E2 		add	r1, r4, #76
 251 01fc 08208DE2 		add	r2, sp, #8
 252 0200 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 253              	.LVL12:
4540:../uvc.c      ****                         {
 254              		.loc 1 4540 0
 255 0204 000050E3 		cmp	r0, #0
 256 0208 B7FFFF1A 		bne	.L4
4542:../uvc.c      ****                             {
 257              		.loc 1 4542 0
 258 020c 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 259 0210 030053E3 		cmp	r3, #3
4546:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 260              		.loc 1 4546 0
 261 0214 4D20D405 		ldreqb	r2, [r4, #77]	@ zero_extendqisi2
 262 0218 E0349F05 		ldreq	r3, .L133+20
4547:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
 263              		.loc 1 4547 0
 264 021c 4E00D405 		ldreqb	r0, [r4, #78]	@ zero_extendqisi2
 265              	.LVL13:
 266 0220 4D10D415 		ldrneb	r1, [r4, #77]	@ zero_extendqisi2
 267 0224 0210A001 		moveq	r1, r2
4546:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 268              		.loc 1 4546 0
 269 0228 5520C305 		streqb	r2, [r3, #85]
4547:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
 270              		.loc 1 4547 0
 271 022c 5600C305 		streqb	r0, [r3, #86]
4553:../uvc.c      ****                         }
 272              		.loc 1 4553 0
 273 0230 B820DDE1 		ldrh	r2, [sp, #8]
 274 0234 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 275 0238 0400A0E3 		mov	r0, #4
 276 023c 00108DE5 		str	r1, [sp]
 277 0240 BC149FE5 		ldr	r1, .L133+24
 278 0244 FEFFFFEB 		bl	CyU3PDebugPrint
 279              	.LVL14:
 280 0248 A7FFFFEA 		b	.L4
 281              	.LVL15:
 282              	.L129:
4367:../uvc.c      ****             {
 283              		.loc 1 4367 0
 284 024c 810053E3 		cmp	r3, #129
 285 0250 0901002A 		bcs	.L14
 286 0254 010053E3 		cmp	r3, #1
 287 0258 9FFFFF1A 		bne	.L5
4394:../uvc.c      ****                             glCommitCtrl, &readCount);
 288              		.loc 1 4394 0
 289 025c 90449FE5 		ldr	r4, .L133+8
 290 0260 2000A0E3 		mov	r0, #32
 291 0264 4C1084E2 		add	r1, r4, #76
 292 0268 08208DE2 		add	r2, sp, #8
 293 026c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 294              	.LVL16:
4396:../uvc.c      ****                     {
 295              		.loc 1 4396 0
 296 0270 000050E3 		cmp	r0, #0
 297 0274 9CFFFF1A 		bne	.L4
4398:../uvc.c      ****                         {
 298              		.loc 1 4398 0
 299 0278 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 300 027c 030053E3 		cmp	r3, #3
 301 0280 99FFFF1A 		bne	.L4
4402:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 302              		.loc 1 4402 0
 303 0284 74349FE5 		ldr	r3, .L133+20
 304 0288 4E60D4E5 		ldrb	r6, [r4, #78]	@ zero_extendqisi2
4403:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 305              		.loc 1 4403 0
 306 028c 4F50D4E5 		ldrb	r5, [r4, #79]	@ zero_extendqisi2
4404:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 307              		.loc 1 4404 0
 308 0290 50C0D4E5 		ldrb	ip, [r4, #80]	@ zero_extendqisi2
4405:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 309              		.loc 1 4405 0
 310 0294 5100D4E5 		ldrb	r0, [r4, #81]	@ zero_extendqisi2
 311              	.LVL17:
4406:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 312              		.loc 1 4406 0
 313 0298 5210D4E5 		ldrb	r1, [r4, #82]	@ zero_extendqisi2
4407:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
 314              		.loc 1 4407 0
 315 029c 5320D4E5 		ldrb	r2, [r4, #83]	@ zero_extendqisi2
4402:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 316              		.loc 1 4402 0
 317 02a0 0260C3E5 		strb	r6, [r3, #2]
4403:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 318              		.loc 1 4403 0
 319 02a4 0350C3E5 		strb	r5, [r3, #3]
4404:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 320              		.loc 1 4404 0
 321 02a8 04C0C3E5 		strb	ip, [r3, #4]
4405:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 322              		.loc 1 4405 0
 323 02ac 0500C3E5 		strb	r0, [r3, #5]
4406:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 324              		.loc 1 4406 0
 325 02b0 0610C3E5 		strb	r1, [r3, #6]
4407:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
 326              		.loc 1 4407 0
 327 02b4 0720C3E5 		strb	r2, [r3, #7]
 328 02b8 8BFFFFEA 		b	.L4
 329              	.LVL18:
 330              	.L23:
4441:../uvc.c      ****                     {
 331              		.loc 1 4441 0
 332 02bc 30349FE5 		ldr	r3, .L133+8
 333 02c0 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 334 02c4 030053E3 		cmp	r3, #3
 335 02c8 2D00000A 		beq	.L131
 336              	.L19:
4390:../uvc.c      ****                     }
 337              		.loc 1 4390 0
 338 02cc 34149FE5 		ldr	r1, .L133+28
 339 02d0 1A00A0E3 		mov	r0, #26
 340 02d4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 341              	.LVL19:
 342 02d8 83FFFFEA 		b	.L4
 343              	.L128:
4649:../uvc.c      ****                 {
 344              		.loc 1 4649 0
 345 02dc 010055E3 		cmp	r5, #1
 346 02e0 7DFFFF1A 		bne	.L5
4674:../uvc.c      ****                                 glCommitCtrl, &readCount);
 347              		.loc 1 4674 0
 348 02e4 08449FE5 		ldr	r4, .L133+8
 349 02e8 08208DE2 		add	r2, sp, #8
 350 02ec 2000A0E3 		mov	r0, #32
 351 02f0 4C1084E2 		add	r1, r4, #76
 352 02f4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 353              	.LVL20:
4676:../uvc.c      ****                         {
 354              		.loc 1 4676 0
 355 02f8 002050E2 		subs	r2, r0, #0
 356 02fc EA00001A 		bne	.L79
4680:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 357              		.loc 1 4680 0
 358 0300 0400A0E1 		mov	r0, r4
 359              	.LVL21:
 360 0304 8010A0E3 		mov	r1, #128
 361 0308 FEFFFFEB 		bl	_txe_event_flags_set
 362              	.LVL22:
4681:../uvc.c      ****                             {
 363              		.loc 1 4681 0
 364 030c 002050E2 		subs	r2, r0, #0
4687:../uvc.c      ****                             //stillcont = 0;
 365              		.loc 1 4687 0
 366 0310 0F30E003 		mvneq	r3, #15
 367 0314 7230C405 		streqb	r3, [r4, #114]
4681:../uvc.c      ****                             {
 368              		.loc 1 4681 0
 369 0318 ED00001A 		bne	.L132
 370              	.LVL23:
 371              	.L81:
4690:../uvc.c      ****                         }else{
 372              		.loc 1 4690 0 discriminator 1
 373 031c 4D10D4E5 		ldrb	r1, [r4, #77]	@ zero_extendqisi2
 374 0320 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 375 0324 B820DDE1 		ldrh	r2, [sp, #8]
 376 0328 00108DE5 		str	r1, [sp]
 377 032c 0400A0E3 		mov	r0, #4
 378 0330 D4139FE5 		ldr	r1, .L133+32
 379 0334 FEFFFFEB 		bl	CyU3PDebugPrint
 380              	.LVL24:
 381 0338 6BFFFFEA 		b	.L4
 382              	.LVL25:
 383              	.L127:
4429:../uvc.c      ****             {
 384              		.loc 1 4429 0
 385 033c 010053E3 		cmp	r3, #1
 386 0340 65FFFF1A 		bne	.L5
4454:../uvc.c      ****                             glCommitCtrl, &readCount);
 387              		.loc 1 4454 0
 388 0344 A8439FE5 		ldr	r4, .L133+8
 389 0348 2000A0E3 		mov	r0, #32
 390 034c 4C1084E2 		add	r1, r4, #76
 391 0350 08208DE2 		add	r2, sp, #8
 392 0354 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 393              	.LVL26:
4456:../uvc.c      ****                     {
 394              		.loc 1 4456 0
 395 0358 000050E3 		cmp	r0, #0
 396 035c 62FFFF1A 		bne	.L4
4458:../uvc.c      ****                          {
 397              		.loc 1 4458 0
 398 0360 4F20D4E5 		ldrb	r2, [r4, #79]	@ zero_extendqisi2
 399 0364 013042E2 		sub	r3, r2, #1
 400 0368 030053E3 		cmp	r3, #3
 401 036c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 402 0370 DB0000EA 		b	.L82
 403              	.L30:
 404 0374 D8050000 		.word	.L29
 405 0378 88050000 		.word	.L31
 406 037c 38050000 		.word	.L32
 407 0380 94030000 		.word	.L33
 408              	.LVL27:
 409              	.L131:
4443:../uvc.c      ****                     }
 410              		.loc 1 4443 0
 411 0384 84139FE5 		ldr	r1, .L133+36
 412 0388 1A00A0E3 		mov	r0, #26
 413 038c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 414              	.LVL28:
 415 0390 55FFFFEA 		b	.L4
 416              	.LVL29:
 417              	.L33:
4476:../uvc.c      ****                          		CyU3PThreadSleep(500);
 418              		.loc 1 4476 0
 419 0394 64539FE5 		ldr	r5, .L133+20
 420 0398 6C2094E5 		ldr	r2, [r4, #108]
 421 039c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 422 03a0 000052E3 		cmp	r2, #0
 423 03a4 B020A003 		moveq	r2, #176
 424 03a8 3020A013 		movne	r2, #48
 425 03ac 032082E1 		orr	r2, r2, r3
 426 03b0 3010A0E3 		mov	r1, #48
 427 03b4 5230A0E3 		mov	r3, #82
 428 03b8 0100A0E3 		mov	r0, #1
 429              	.LVL30:
 430 03bc FEFFFFEB 		bl	SensorSetIrisControl
 431              	.LVL31:
4477:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 432              		.loc 1 4477 0
 433 03c0 7D0FA0E3 		mov	r0, #500
 434 03c4 FEFFFFEB 		bl	_tx_thread_sleep
 435              	.LVL32:
4478:../uvc.c      ****                          		break;
 436              		.loc 1 4478 0
 437 03c8 6C1094E5 		ldr	r1, [r4, #108]
 438 03cc 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 439 03d0 6C3094E5 		ldr	r3, [r4, #108]
 440 03d4 000051E3 		cmp	r1, #0
 441 03d8 B010A003 		moveq	r1, #176
 442 03dc 3010A013 		movne	r1, #48
 443              	.L116:
 444 03e0 022081E1 		orr	r2, r1, r2
 445 03e4 0400A0E3 		mov	r0, #4
 446 03e8 24139FE5 		ldr	r1, .L133+40
 447 03ec FEFFFFEB 		bl	CyU3PDebugPrint
 448              	.LVL33:
 449 03f0 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 450              	.L28:
4484:../uvc.c      **** 
 451              		.loc 1 4484 0
 452 03f4 0320A0E1 		mov	r2, r3
 453 03f8 18139FE5 		ldr	r1, .L133+44
 454 03fc 0400A0E3 		mov	r0, #4
4483:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 455              		.loc 1 4483 0
 456 0400 7030C4E5 		strb	r3, [r4, #112]
4484:../uvc.c      **** 
 457              		.loc 1 4484 0
 458 0404 FEFFFFEB 		bl	CyU3PDebugPrint
 459              	.LVL34:
4497:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 460              		.loc 1 4497 0
 461 0408 0020A0E3 		mov	r2, #0
 462 040c E0029FE5 		ldr	r0, .L133+8
 463 0410 0110A0E3 		mov	r1, #1
 464 0414 FEFFFFEB 		bl	_txe_event_flags_set
 465              	.LVL35:
4498:../uvc.c      ****                         {
 466              		.loc 1 4498 0
 467 0418 002050E2 		subs	r2, r0, #0
 468 041c 32FFFF0A 		beq	.L4
4500:../uvc.c      ****                         }
 469              		.loc 1 4500 0
 470 0420 F4129FE5 		ldr	r1, .L133+48
 471 0424 0400A0E3 		mov	r0, #4
 472              	.LVL36:
 473 0428 FEFFFFEB 		bl	CyU3PDebugPrint
 474              	.LVL37:
 475 042c 2EFFFFEA 		b	.L4
 476              	.LVL38:
 477              	.L62:
4617:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 478              		.loc 1 4617 0
 479 0430 6C2094E5 		ldr	r2, [r4, #108]
 480 0434 3010A0E3 		mov	r1, #48
 481 0438 000052E3 		cmp	r2, #0
 482 043c 9220A003 		moveq	r2, #146
 483 0440 1220A013 		movne	r2, #18
 484 0444 5230A0E3 		mov	r3, #82
 485 0448 0100A0E3 		mov	r0, #1
 486              	.LVL39:
 487 044c FEFFFFEB 		bl	SensorSetIrisControl
 488              	.LVL40:
4619:../uvc.c      ****                              		break;
 489              		.loc 1 4619 0
 490 0450 6C2094E5 		ldr	r2, [r4, #108]
 491 0454 0400A0E3 		mov	r0, #4
 492 0458 000052E3 		cmp	r2, #0
 493 045c 6C3094E5 		ldr	r3, [r4, #108]
 494 0460 9220A003 		moveq	r2, #146
 495 0464 1220A013 		movne	r2, #18
 496 0468 B0129FE5 		ldr	r1, .L133+52
 497 046c FEFFFFEB 		bl	CyU3PDebugPrint
 498              	.LVL41:
 499 0470 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
 500              	.L58:
4636:../uvc.c      **** 
 501              		.loc 1 4636 0
 502 0474 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 503 0478 B820DDE1 		ldrh	r2, [sp, #8]
 504 047c 00C08DE5 		str	ip, [sp]
 505 0480 9C129FE5 		ldr	r1, .L133+56
4634:../uvc.c      **** 
 506              		.loc 1 4634 0
 507 0484 71C0C4E5 		strb	ip, [r4, #113]
4636:../uvc.c      **** 
 508              		.loc 1 4636 0
 509 0488 0400A0E3 		mov	r0, #4
 510 048c FEFFFFEB 		bl	CyU3PDebugPrint
 511              	.LVL42:
 512 0490 15FFFFEA 		b	.L4
 513              	.LVL43:
 514              	.L61:
4622:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 515              		.loc 1 4622 0
 516 0494 64529FE5 		ldr	r5, .L133+20
 517 0498 6C2094E5 		ldr	r2, [r4, #108]
 518 049c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 519 04a0 000052E3 		cmp	r2, #0
 520 04a4 8020A003 		moveq	r2, #128
 521 04a8 0020A013 		movne	r2, #0
 522 04ac 032082E1 		orr	r2, r2, r3
 523 04b0 3010A0E3 		mov	r1, #48
 524 04b4 5230A0E3 		mov	r3, #82
 525 04b8 0100A0E3 		mov	r0, #1
 526              	.LVL44:
 527 04bc FEFFFFEB 		bl	SensorSetIrisControl
 528              	.LVL45:
4624:../uvc.c      ****                              		break;
 529              		.loc 1 4624 0
 530 04c0 6C1094E5 		ldr	r1, [r4, #108]
 531 04c4 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 532 04c8 6C3094E5 		ldr	r3, [r4, #108]
 533 04cc 000051E3 		cmp	r1, #0
 534 04d0 8010A003 		moveq	r1, #128
 535 04d4 0010A013 		movne	r1, #0
 536              	.L118:
4629:../uvc.c      ****                              		break;
 537              		.loc 1 4629 0
 538 04d8 022081E1 		orr	r2, r1, r2
 539 04dc 0400A0E3 		mov	r0, #4
 540 04e0 38129FE5 		ldr	r1, .L133+52
 541 04e4 FEFFFFEB 		bl	CyU3PDebugPrint
 542              	.LVL46:
 543 04e8 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
4630:../uvc.c      ****                               	default:
 544              		.loc 1 4630 0
 545 04ec E0FFFFEA 		b	.L58
 546              	.LVL47:
 547              	.L59:
4627:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 548              		.loc 1 4627 0
 549 04f0 08529FE5 		ldr	r5, .L133+20
 550 04f4 6C2094E5 		ldr	r2, [r4, #108]
 551 04f8 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 552 04fc 000052E3 		cmp	r2, #0
 553 0500 F420A003 		moveq	r2, #244
 554 0504 7420A013 		movne	r2, #116
 555 0508 032082E1 		orr	r2, r2, r3
 556 050c 3010A0E3 		mov	r1, #48
 557 0510 5230A0E3 		mov	r3, #82
 558 0514 0100A0E3 		mov	r0, #1
 559              	.LVL48:
 560 0518 FEFFFFEB 		bl	SensorSetIrisControl
 561              	.LVL49:
4629:../uvc.c      ****                              		break;
 562              		.loc 1 4629 0
 563 051c 6C1094E5 		ldr	r1, [r4, #108]
 564 0520 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 565 0524 000051E3 		cmp	r1, #0
 566 0528 6C3094E5 		ldr	r3, [r4, #108]
 567 052c F410A003 		moveq	r1, #244
 568 0530 7410A013 		movne	r1, #116
 569 0534 E7FFFFEA 		b	.L118
 570              	.LVL50:
 571              	.L32:
4471:../uvc.c      ****                          		CyU3PThreadSleep(500);
 572              		.loc 1 4471 0
 573 0538 C0519FE5 		ldr	r5, .L133+20
 574 053c 6C2094E5 		ldr	r2, [r4, #108]
 575 0540 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 576 0544 000052E3 		cmp	r2, #0
 577 0548 8020A003 		moveq	r2, #128
 578 054c 0020A013 		movne	r2, #0
 579 0550 032082E1 		orr	r2, r2, r3
 580 0554 3010A0E3 		mov	r1, #48
 581 0558 5230A0E3 		mov	r3, #82
 582 055c 0100A0E3 		mov	r0, #1
 583              	.LVL51:
 584 0560 FEFFFFEB 		bl	SensorSetIrisControl
 585              	.LVL52:
4472:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 586              		.loc 1 4472 0
 587 0564 7D0FA0E3 		mov	r0, #500
 588 0568 FEFFFFEB 		bl	_tx_thread_sleep
 589              	.LVL53:
4473:../uvc.c      ****                          		break;
 590              		.loc 1 4473 0
 591 056c 6C1094E5 		ldr	r1, [r4, #108]
 592 0570 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 593 0574 000051E3 		cmp	r1, #0
 594 0578 6C3094E5 		ldr	r3, [r4, #108]
 595 057c 8010A003 		moveq	r1, #128
 596 0580 0010A013 		movne	r1, #0
 597 0584 95FFFFEA 		b	.L116
 598              	.LVL54:
 599              	.L31:
4466:../uvc.c      ****                          		CyU3PThreadSleep(500);
 600              		.loc 1 4466 0
 601 0588 6C2094E5 		ldr	r2, [r4, #108]
 602 058c 3010A0E3 		mov	r1, #48
 603 0590 000052E3 		cmp	r2, #0
 604 0594 9220A003 		moveq	r2, #146
 605 0598 1220A013 		movne	r2, #18
 606 059c 5230A0E3 		mov	r3, #82
 607 05a0 0100A0E3 		mov	r0, #1
 608              	.LVL55:
 609 05a4 FEFFFFEB 		bl	SensorSetIrisControl
 610              	.LVL56:
4467:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 611              		.loc 1 4467 0
 612 05a8 7D0FA0E3 		mov	r0, #500
 613 05ac FEFFFFEB 		bl	_tx_thread_sleep
 614              	.LVL57:
4468:../uvc.c      ****                          		break;
 615              		.loc 1 4468 0
 616 05b0 6C2094E5 		ldr	r2, [r4, #108]
 617 05b4 0400A0E3 		mov	r0, #4
 618 05b8 000052E3 		cmp	r2, #0
 619 05bc 6C3094E5 		ldr	r3, [r4, #108]
 620 05c0 9220A003 		moveq	r2, #146
 621 05c4 1220A013 		movne	r2, #18
 622 05c8 44119FE5 		ldr	r1, .L133+40
 623 05cc FEFFFFEB 		bl	CyU3PDebugPrint
 624              	.LVL58:
 625 05d0 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
4469:../uvc.c      ****                          	case 3: //720
 626              		.loc 1 4469 0
 627 05d4 86FFFFEA 		b	.L28
 628              	.LVL59:
 629              	.L29:
4461:../uvc.c      ****                          		CyU3PThreadSleep(500);
 630              		.loc 1 4461 0
 631 05d8 6C2094E5 		ldr	r2, [r4, #108]
 632 05dc 3010A0E3 		mov	r1, #48
 633 05e0 000052E3 		cmp	r2, #0
 634 05e4 A220A003 		moveq	r2, #162
 635 05e8 2220A013 		movne	r2, #34
 636 05ec 5230A0E3 		mov	r3, #82
 637 05f0 0100A0E3 		mov	r0, #1
 638              	.LVL60:
 639 05f4 FEFFFFEB 		bl	SensorSetIrisControl
 640              	.LVL61:
4462:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 641              		.loc 1 4462 0
 642 05f8 7D0FA0E3 		mov	r0, #500
 643 05fc FEFFFFEB 		bl	_tx_thread_sleep
 644              	.LVL62:
4463:../uvc.c      ****                          		break;
 645              		.loc 1 4463 0
 646 0600 6C2094E5 		ldr	r2, [r4, #108]
 647 0604 0400A0E3 		mov	r0, #4
 648 0608 000052E3 		cmp	r2, #0
 649 060c 6C3094E5 		ldr	r3, [r4, #108]
 650 0610 A220A003 		moveq	r2, #162
 651 0614 2220A013 		movne	r2, #34
 652 0618 F4109FE5 		ldr	r1, .L133+40
 653 061c FEFFFFEB 		bl	CyU3PDebugPrint
 654              	.LVL63:
 655 0620 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
4464:../uvc.c      ****                          	case 2: //1080
 656              		.loc 1 4464 0
 657 0624 72FFFFEA 		b	.L28
 658              	.LVL64:
 659              	.L63:
4612:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 660              		.loc 1 4612 0
 661 0628 6C2094E5 		ldr	r2, [r4, #108]
 662 062c 3010A0E3 		mov	r1, #48
 663 0630 000052E3 		cmp	r2, #0
 664 0634 A220A003 		moveq	r2, #162
 665 0638 2220A013 		movne	r2, #34
 666 063c 5230A0E3 		mov	r3, #82
 667 0640 0100A0E3 		mov	r0, #1
 668              	.LVL65:
 669 0644 FEFFFFEB 		bl	SensorSetIrisControl
 670              	.LVL66:
4614:../uvc.c      ****                              		break;
 671              		.loc 1 4614 0
 672 0648 6C2094E5 		ldr	r2, [r4, #108]
 673 064c 0400A0E3 		mov	r0, #4
 674 0650 000052E3 		cmp	r2, #0
 675 0654 6C3094E5 		ldr	r3, [r4, #108]
 676 0658 A220A003 		moveq	r2, #162
 677 065c 2220A013 		movne	r2, #34
 678 0660 B8109FE5 		ldr	r1, .L133+52
 679 0664 FEFFFFEB 		bl	CyU3PDebugPrint
 680              	.LVL67:
 681 0668 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
4615:../uvc.c      ****                              	case 3: //1080
 682              		.loc 1 4615 0
 683 066c 80FFFFEA 		b	.L58
 684              	.LVL68:
 685              	.L76:
4656:../uvc.c      ****                         glEp0Buffer[1] = 0;
 686              		.loc 1 4656 0
 687 0670 7C309FE5 		ldr	r3, .L133+8
 688 0674 01C0A0E3 		mov	ip, #1
 689 0678 A9FEFFEA 		b	.L121
 690              	.L14:
4382:../uvc.c      ****                     {
 691              		.loc 1 4382 0
 692 067c 70309FE5 		ldr	r3, .L133+8
 693 0680 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 694 0684 030053E3 		cmp	r3, #3
 695 0688 0FFFFF1A 		bne	.L19
4384:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 696              		.loc 1 4384 0
 697 068c 6C109FE5 		ldr	r1, .L133+20
 698 0690 1A00A0E3 		mov	r0, #26
 699 0694 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 700              	.LVL69:
4385:../uvc.c      **** 
 701              		.loc 1 4385 0
 702 0698 0020D4E5 		ldrb	r2, [r4]	@ zero_extendqisi2
 703 069c 84109FE5 		ldr	r1, .L133+60
 704 06a0 0400A0E3 		mov	r0, #4
 705 06a4 FEFFFFEB 		bl	CyU3PDebugPrint
 706              	.LVL70:
 707 06a8 8FFEFFEA 		b	.L4
 708              	.LVL71:
 709              	.L79:
4692:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
 710              		.loc 1 4692 0
 711 06ac B820DDE1 		ldrh	r2, [sp, #8]
 712 06b0 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 713 06b4 70109FE5 		ldr	r1, .L133+64
 714 06b8 0400A0E3 		mov	r0, #4
 715              	.LVL72:
 716 06bc FEFFFFEB 		bl	CyU3PDebugPrint
 717              	.LVL73:
4693:../uvc.c      ****                         }
 718              		.loc 1 4693 0
 719 06c0 0000A0E3 		mov	r0, #0
 720 06c4 0510A0E1 		mov	r1, r5
 721 06c8 0020A0E1 		mov	r2, r0
 722 06cc FEFFFFEB 		bl	CyU3PUsbStall
 723              	.LVL74:
 724 06d0 85FEFFEA 		b	.L4
 725              	.LVL75:
 726              	.L132:
4683:../uvc.c      ****                             }
 727              		.loc 1 4683 0
 728 06d4 54109FE5 		ldr	r1, .L133+68
 729 06d8 0400A0E3 		mov	r0, #4
 730              	.LVL76:
 731 06dc FEFFFFEB 		bl	CyU3PDebugPrint
 732              	.LVL77:
 733 06e0 0DFFFFEA 		b	.L81
 734              	.LVL78:
 735              	.L82:
4458:../uvc.c      ****                          {
 736              		.loc 1 4458 0
 737 06e4 0230A0E1 		mov	r3, r2
 738 06e8 41FFFFEA 		b	.L28
 739              	.L134:
 740              		.align	2
 741              	.L133:
 742 06ec 00000000 		.word	wValue
 743 06f0 00000000 		.word	bRequest
 744 06f4 00000000 		.word	.LANCHOR0
 745 06f8 54000000 		.word	.LANCHOR1+84
 746 06fc 60000000 		.word	.LANCHOR1+96
 747 0700 00000000 		.word	.LANCHOR1
 748 0704 B4000000 		.word	.LC5
 749 0708 1C000000 		.word	.LANCHOR1+28
 750 070c 50010000 		.word	.LC9
 751 0710 38000000 		.word	.LANCHOR1+56
 752 0714 40000000 		.word	.LC2
 753 0718 64000000 		.word	.LC3
 754 071c 8C000000 		.word	.LC4
 755 0720 E0000000 		.word	.LC6
 756 0724 04010000 		.word	.LC7
 757 0728 18000000 		.word	.LC1
 758 072c 7C010000 		.word	.LC10
 759 0730 2C010000 		.word	.LC8
 760              		.cfi_endproc
 761              	.LFE24:
 763              		.align	2
 764              		.global	I2cAppThread_Entry
 766              	I2cAppThread_Entry:
 767              	.LFB26:
4708:../uvc.c      **** 
4709:../uvc.c      **** /*
4710:../uvc.c      ****  * Entry function for the UVC control request processing thread.
4711:../uvc.c      ****  */
4712:../uvc.c      **** void
4713:../uvc.c      **** UVCAppEP0Thread_Entry (
4714:../uvc.c      ****         uint32_t input)
4715:../uvc.c      **** {
4716:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
4717:../uvc.c      ****     uint32_t eventFlag;
4718:../uvc.c      **** 	CyBool_t value;
4719:../uvc.c      **** 	CyBool_t *valueptr = &value;
4720:../uvc.c      **** 
4721:../uvc.c      **** 
4722:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4723:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4724:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
4725:../uvc.c      **** 
4726:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
4727:../uvc.c      **** #endif
4728:../uvc.c      **** 
4729:../uvc.c      ****     /* for interrupt status test */
4730:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4731:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
4732:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
4733:../uvc.c      **** 
4734:../uvc.c      ****     for (;;)
4735:../uvc.c      ****     {
4736:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
4737:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
4738:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
4739:../uvc.c      ****         {
4740:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
4741:../uvc.c      ****             if (!isUsbConnected)
4742:../uvc.c      ****             {
4743:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
4744:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
4745:../uvc.c      ****                 {
4746:../uvc.c      ****                     isUsbConnected = CyTrue;
4747:../uvc.c      ****                 }
4748:../uvc.c      ****             }
4749:../uvc.c      **** //#ifdef DbgInfo
4750:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
4751:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
4752:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
4753:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
4754:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
4755:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
4756:../uvc.c      **** //#endif
4757:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
4758:../uvc.c      ****             {
4759:../uvc.c      ****             	switch ((wIndex >> 8))
4760:../uvc.c      ****                 {
4761:../uvc.c      **** 
4762:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
4763:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
4764:../uvc.c      ****                         break;
4765:../uvc.c      **** 
4766:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
4767:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
4768:../uvc.c      ****                         break;
4769:../uvc.c      **** 
4770:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
4771:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
4772:../uvc.c      ****                         break;
4773:../uvc.c      **** 
4774:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
4775:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
4776:../uvc.c      ****                         break;
4777:../uvc.c      **** 
4778:../uvc.c      ****                     default:
4779:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
4780:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4781:../uvc.c      ****                         break;
4782:../uvc.c      ****                 }
4783:../uvc.c      ****             }
4784:../uvc.c      **** 
4785:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
4786:../uvc.c      ****             {
4787:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
4788:../uvc.c      **** 
4789:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
4790:../uvc.c      ****                 {
4791:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4792:../uvc.c      ****                 }
4793:../uvc.c      ****                 else
4794:../uvc.c      ****                 {
4795:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
4796:../uvc.c      ****                 }
4797:../uvc.c      ****             }
4798:../uvc.c      **** 
4799:../uvc.c      ****             /* handle interrupt status event */
4800:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
4801:../uvc.c      ****             {
4802:../uvc.c      **** 
4803:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
4804:../uvc.c      ****             	/** preparing interrupt status data **/
4805:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
4806:../uvc.c      **** 
4807:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4808:../uvc.c      **** 
4809:../uvc.c      **** #if 0 //for real button
4810:../uvc.c      **** 				if(value&&(!snapButFlag)){
4811:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4812:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4813:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4814:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4815:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4816:../uvc.c      **** 
4817:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4818:../uvc.c      **** 					interStabuf.size   = 1024;
4819:../uvc.c      **** 					interStabuf.status = 0;
4820:../uvc.c      **** 
4821:../uvc.c      **** 					interStabuf.count = 4;
4822:../uvc.c      **** 
4823:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4824:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4825:../uvc.c      **** 
4826:../uvc.c      **** 					/** send a interrupt status data **/
4827:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4828:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4829:../uvc.c      **** 					{
4830:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4831:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4832:../uvc.c      **** 					}
4833:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
4834:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
4835:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4836:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4837:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4838:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4839:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4840:../uvc.c      **** 
4841:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4842:../uvc.c      **** 					interStabuf.size   = 1024;
4843:../uvc.c      **** 					interStabuf.status = 0;
4844:../uvc.c      **** 
4845:../uvc.c      **** 					interStabuf.count = 4;
4846:../uvc.c      **** 
4847:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4848:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4849:../uvc.c      **** 
4850:../uvc.c      **** 					/** send a interrupt status data **/
4851:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4852:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4853:../uvc.c      **** 					{
4854:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4855:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4856:../uvc.c      **** 					}
4857:../uvc.c      **** 
4858:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
4859:../uvc.c      **** 					stiflag = 0xFF;
4860:../uvc.c      **** 				}
4861:../uvc.c      **** #else			//for botton simulation
4862:../uvc.c      **** 				if(snapButFlag == 0x0f){
4863:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4864:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4865:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4866:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4867:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4868:../uvc.c      **** 
4869:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4870:../uvc.c      **** 					interStabuf.size   = 1024;
4871:../uvc.c      **** 					interStabuf.status = 0;
4872:../uvc.c      **** 
4873:../uvc.c      **** 					interStabuf.count = 4;
4874:../uvc.c      **** 
4875:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4876:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4877:../uvc.c      **** 
4878:../uvc.c      **** 					/** send a interrupt status data **/
4879:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4880:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4881:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4882:../uvc.c      **** 					{
4883:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4884:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4885:../uvc.c      **** 					}
4886:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
4887:../uvc.c      **** 
4888:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
4889:../uvc.c      **** 				}else if(!snapButFlag){
4890:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4891:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4892:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4893:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4894:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4895:../uvc.c      **** 
4896:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4897:../uvc.c      **** 					interStabuf.size   = 1024;
4898:../uvc.c      **** 					interStabuf.status = 0;
4899:../uvc.c      **** 
4900:../uvc.c      **** 					interStabuf.count = 4;
4901:../uvc.c      **** 
4902:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4903:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4904:../uvc.c      **** 
4905:../uvc.c      **** 					/** send a interrupt status data **/
4906:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4907:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4908:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4909:../uvc.c      **** 					{
4910:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4911:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4912:../uvc.c      **** 					}
4913:../uvc.c      **** 
4914:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
4915:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
4916:../uvc.c      **** 				}
4917:../uvc.c      **** #endif
4918:../uvc.c      **** 
4919:../uvc.c      ****             }
4920:../uvc.c      **** 
4921:../uvc.c      **** 
4922:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4923:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
4924:../uvc.c      ****             {
4925:../uvc.c      ****                 /* Get the command buffer */
4926:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
4927:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4928:../uvc.c      ****                 {
4929:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
4930:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4931:../uvc.c      ****                 }
4932:../uvc.c      **** 
4933:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
4934:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
4935:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
4936:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
4937:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
4938:../uvc.c      ****                  * register value high byte and register value low byte.
4939:../uvc.c      ****                  */
4940:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
4941:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
4942:../uvc.c      ****                 {
4943:../uvc.c      ****                     if (dmaInfo.count == 3)
4944:../uvc.c      ****                     {
4945:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
4946:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
4947:../uvc.c      ****                         dmaInfo.count = 3;
4948:../uvc.c      ****                     }
4949:../uvc.c      ****                     else if (dmaInfo.count == 4)
4950:../uvc.c      ****                     {
4951:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
4952:../uvc.c      ****                         {
4953:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
4954:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
4955:../uvc.c      ****                         }
4956:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
4957:../uvc.c      ****                     }
4958:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
4959:../uvc.c      ****                 }
4960:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
4961:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
4962:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
4963:../uvc.c      ****                  */
4964:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
4965:../uvc.c      ****                 {
4966:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4967:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
4968:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4969:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
4970:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
4971:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4972:../uvc.c      ****                         	break;
4973:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
4974:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
4975:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4976:../uvc.c      ****                         	break;*/
4977:../uvc.c      ****                     dmaInfo.count -= 2;
4978:../uvc.c      ****                 }
4979:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
4980:../uvc.c      ****                 else
4981:../uvc.c      ****                 {
4982:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
4983:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
4984:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
4985:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
4986:../uvc.c      ****                 }
4987:../uvc.c      **** 
4988:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
4989:../uvc.c      ****                 dmaInfo.size   = 1024;
4990:../uvc.c      ****                 dmaInfo.status = 0;
4991:../uvc.c      **** 
4992:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
4993:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
4994:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4995:../uvc.c      ****                 {
4996:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
4997:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4998:../uvc.c      ****                 }
4999:../uvc.c      **** 
5000:../uvc.c      ****                 /* Wait until the response has gone out. */
5001:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
5002:../uvc.c      **** 
5003:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
5004:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
5005:../uvc.c      ****                 {
5006:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
5007:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
5008:../uvc.c      ****                 }
5009:../uvc.c      ****             }
5010:../uvc.c      **** #endif
5011:../uvc.c      ****         }
5012:../uvc.c      ****         /* Allow other ready threads to run. */
5013:../uvc.c      ****         CyU3PThreadRelinquish ();
5014:../uvc.c      ****     }
5015:../uvc.c      **** }
5016:../uvc.c      **** 
5017:../uvc.c      **** /*
5018:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
5019:../uvc.c      ****  * added 10/2013
5020:../uvc.c      ****  */
5021:../uvc.c      **** /*
5022:../uvc.c      **** static uint8_t timeDelay[64] = {
5023:../uvc.c      **** 
5024:../uvc.c      **** };
5025:../uvc.c      **** */
5026:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
 768              		.loc 1 5026 0
 769              		.cfi_startproc
 770              		@ args = 0, pretend = 0, frame = 8
 771              		@ frame_needed = 0, uses_anonymous_args = 0
 772              	.LVL79:
 773 0734 F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
 774              	.LCFI3:
 775              		.cfi_def_cfa_offset 28
 776              		.cfi_offset 4, -28
 777              		.cfi_offset 5, -24
 778              		.cfi_offset 6, -20
 779              		.cfi_offset 7, -16
 780              		.cfi_offset 8, -12
 781              		.cfi_offset 9, -8
 782              		.cfi_offset 14, -4
5027:../uvc.c      **** 
5028:../uvc.c      **** 	uint16_t count = 0, cmdCopyIdx = 0, count1 = 0, cmdQuIdx = 0; //
5029:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
5030:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
5031:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
5032:../uvc.c      **** 	VdcmdDes  *lcStaDes;
5033:../uvc.c      **** 	uint32_t flag = 0;
5034:../uvc.c      **** 	uint8_t  cmdFlag = 0;
5035:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
5036:../uvc.c      **** 	uint8_t i;
5037:../uvc.c      **** 	uint16_t delaytime;
5038:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
5039:../uvc.c      **** 
5040:../uvc.c      **** #if 0 //for test the command queue
5041:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
5042:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
5043:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
5044:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
5045:../uvc.c      **** 		lcCmdDes += 1;
5046:../uvc.c      **** 	}
5047:../uvc.c      **** 	lcCmdDes = statQuptr->startAdd;
5048:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
5049:../uvc.c      **** 		CyU3PDebugPrint (4, "State Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n",
5050:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
5051:../uvc.c      **** 		lcCmdDes += 1;
5052:../uvc.c      **** 	}
5053:../uvc.c      **** 
5054:../uvc.c      **** #endif
5055:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
5056:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
 783              		.loc 1 5056 0
 784 0738 34029FE5 		ldr	r0, .L161
 785              	.LVL80:
5026:../uvc.c      **** 
 786              		.loc 1 5026 0
 787 073c 1CD04DE2 		sub	sp, sp, #28
 788              	.LCFI4:
 789              		.cfi_def_cfa_offset 56
5033:../uvc.c      **** 	uint8_t  cmdFlag = 0;
 790              		.loc 1 5033 0
 791 0740 00C0A0E3 		mov	ip, #0
 792              		.loc 1 5056 0
 793 0744 FA2FA0E3 		mov	r2, #1000
 794 0748 2C30A0E3 		mov	r3, #44
 795 074c 0C10A0E1 		mov	r1, ip
 796 0750 04C08DE5 		str	ip, [sp, #4]
 797 0754 08C08DE5 		str	ip, [sp, #8]
 798 0758 00208DE5 		str	r2, [sp]
 799 075c 0C308DE5 		str	r3, [sp, #12]
 800 0760 10229FE5 		ldr	r2, .L161+4
 801 0764 0B30A0E3 		mov	r3, #11
5033:../uvc.c      **** 	uint8_t  cmdFlag = 0;
 802              		.loc 1 5033 0
 803 0768 14C08DE5 		str	ip, [sp, #20]
 804              	.LVL81:
 805              		.loc 1 5056 0
 806 076c FEFFFFEB 		bl	_txe_timer_create
 807              	.LVL82:
5057:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
 808              		.loc 1 5057 0
 809 0770 FEFFFFEB 		bl	_tx_time_get
 810              	.LVL83:
5058:../uvc.c      **** 	CyU3PThreadSleep(50);
5059:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
5060:../uvc.c      **** 
5061:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
 811              		.loc 1 5061 0
 812 0774 00529FE5 		ldr	r5, .L161+8
5057:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
 813              		.loc 1 5057 0
 814 0778 00129FE5 		ldr	r1, .L161+12
 815 077c 0020A0E1 		mov	r2, r0
 816 0780 0400A0E3 		mov	r0, #4
 817 0784 FEFFFFEB 		bl	CyU3PDebugPrint
 818              	.LVL84:
5058:../uvc.c      **** 	CyU3PThreadSleep(50);
 819              		.loc 1 5058 0
 820 0788 3200A0E3 		mov	r0, #50
 821 078c FEFFFFEB 		bl	_tx_thread_sleep
 822              	.LVL85:
5059:../uvc.c      **** 
 823              		.loc 1 5059 0
 824 0790 DC019FE5 		ldr	r0, .L161
 825 0794 FEFFFFEB 		bl	_txe_timer_activate
 826              	.LVL86:
 827              		.loc 1 5061 0
 828 0798 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 829 079c 000052E3 		cmp	r2, #0
 830 07a0 0300001A 		bne	.L136
 831              	.L137:
5062:../uvc.c      ****         /* Allow other ready threads to run. */
5063:../uvc.c      **** 
5064:../uvc.c      ****         CyU3PThreadRelinquish ();
 832              		.loc 1 5064 0
 833 07a4 FEFFFFEB 		bl	_txe_thread_relinquish
 834              	.LVL87:
5061:../uvc.c      ****         /* Allow other ready threads to run. */
 835              		.loc 1 5061 0
 836 07a8 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 837 07ac 000052E3 		cmp	r2, #0
 838 07b0 FBFFFF0A 		beq	.L137
 839              	.L136:
5065:../uvc.c      **** 	}
5066:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
 840              		.loc 1 5066 0
 841 07b4 103095E5 		ldr	r3, [r5, #16]
 842 07b8 0400A0E3 		mov	r0, #4
 843 07bc 3C3093E5 		ldr	r3, [r3, #60]
 844 07c0 BC119FE5 		ldr	r1, .L161+16
 845 07c4 FEFFFFEB 		bl	CyU3PDebugPrint
 846              	.LVL88:
 847 07c8 B8619FE5 		ldr	r6, .L161+20
 848 07cc B8819FE5 		ldr	r8, .L161+24
5067:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
5068:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
5069:../uvc.c      **** 	//CyU3PThreadSleep(100);
5070:../uvc.c      **** 	//SetCurCmd();
5071:../uvc.c      **** 	/*********** the loop of the thread ***********/
5072:../uvc.c      **** 	for(;;){
5073:../uvc.c      **** 
5074:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 849              		.loc 1 5074 0
 850 07d0 0070E0E3 		mvn	r7, #0
 851              	.L154:
 852 07d4 14308DE2 		add	r3, sp, #20
 853 07d8 2010A0E3 		mov	r1, #32
 854 07dc 0320A0E3 		mov	r2, #3
 855 07e0 00708DE5 		str	r7, [sp]
 856 07e4 A4019FE5 		ldr	r0, .L161+28
 857 07e8 FEFFFFEB 		bl	_txe_event_flags_get
 858              	.LVL89:
5075:../uvc.c      **** /*  // for test GPIO output
5076:../uvc.c      **** 		if(trigger)
5077:../uvc.c      **** 		{
5078:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
5079:../uvc.c      **** 			{
5080:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
5081:../uvc.c      **** 			}
5082:../uvc.c      **** 
5083:../uvc.c      **** 		}else{
5084:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
5085:../uvc.c      **** 			{
5086:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
5087:../uvc.c      **** 			}
5088:../uvc.c      **** 
5089:../uvc.c      **** 		}
5090:../uvc.c      **** */
5091:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 859              		.loc 1 5091 0
 860 07ec 1C0096E5 		ldr	r0, [r6, #28]
 861 07f0 0010E0E3 		mvn	r1, #0
 862 07f4 FEFFFFEB 		bl	_txe_mutex_get
 863              	.LVL90:
5092:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
5093:../uvc.c      **** 			/* find an available reading I2C command in the state queue */
5094:../uvc.c      **** 			lcStaDes = (VdcmdDes*)statQuptr->readPtr;
5095:../uvc.c      **** 			//if(0 && (lcStaDes->cmdFlag == CyTrue)){ /* for state queue it's not used right now. */
5096:../uvc.c      **** 				i = 0;
5097:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 864              		.loc 1 5097 0
 865 07f8 103096E5 		ldr	r3, [r6, #16]
 866 07fc 3C3093E5 		ldr	r3, [r3, #60]
 867 0800 000053E3 		cmp	r3, #0
 868 0804 0300001A 		bne	.L138
 869 0808 4030A0E3 		mov	r3, #64
 870              	.LVL91:
 871              	.L139:
 872 080c 013043E2 		sub	r3, r3, #1
 873 0810 FF3013E2 		ands	r3, r3, #255
 874 0814 FCFFFF1A 		bne	.L139
 875              	.LVL92:
 876              	.L138:
5098:../uvc.c      **** 					i++;
5099:../uvc.c      **** 					lcCmdDes = lcStaDes->cmdDesNext;
5100:../uvc.c      **** 					statQuptr->readPtr = lcStaDes;
5101:../uvc.c      **** 				}
5102:../uvc.c      **** #if 0
5103:../uvc.c      **** 				if(lcStaDes->cmdFlag != deswait){
5104:../uvc.c      **** 				i = lcStaDes->curNum;
5105:../uvc.c      **** 				regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
5106:../uvc.c      **** 				devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
5107:../uvc.c      **** 				data = ((lcStaDes->CmdPar)+i)->Data;
5108:../uvc.c      **** 				//delaytime = ((lcStaDes->CmdPar)+i)->DelayT;
5109:../uvc.c      **** 
5110:../uvc.c      **** 				//for(i = 0; i < lcStaDes->NumPara; i++){
5111:../uvc.c      **** 					//regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
5112:../uvc.c      **** 					//devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
5113:../uvc.c      **** 					((lcStaDes->CmdPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
5114:../uvc.c      **** #ifdef USB_DEBUG_PRINT
5115:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
5116:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
5117:../uvc.c      **** #endif
5118:../uvc.c      **** 				//}
5119:../uvc.c      **** 				lcStaDes->cmdFlag = CyFalse;
5120:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->cmdDesNext; //update command queue read pointer
5121:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
5122:../uvc.c      **** 				/* setting delay */
5123:../uvc.c      **** 				delaytime = 300;
5124:../uvc.c      **** 				CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
5125:../uvc.c      **** 				CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
5126:../uvc.c      **** 			} //end of the if condition statment
5127:../uvc.c      **** #endif
5128:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 877              		.loc 1 5128 0
 878 0818 1C0096E5 		ldr	r0, [r6, #28]
 879 081c FEFFFFEB 		bl	_txe_mutex_put
 880              	.LVL93:
5129:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
5130:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 881              		.loc 1 5130 0
 882 0820 1C0095E5 		ldr	r0, [r5, #28]
 883 0824 0010E0E3 		mvn	r1, #0
 884 0828 FEFFFFEB 		bl	_txe_mutex_get
 885              	.LVL94:
5131:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 886              		.loc 1 5131 0
 887 082c 104095E5 		ldr	r4, [r5, #16]
 888              	.LVL95:
5132:../uvc.c      **** 
5133:../uvc.c      **** 				/*
5134:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
5135:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
5136:../uvc.c      **** 				*/
5137:../uvc.c      **** 
5138:../uvc.c      **** 				/* find a available command */
5139:../uvc.c      **** 				i = 0;
5140:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 889              		.loc 1 5140 0
 890 0830 3C3094E5 		ldr	r3, [r4, #60]
 891 0834 000053E3 		cmp	r3, #0
 892 0838 0900001A 		bne	.L140
 893 083c 4020A0E3 		mov	r2, #64
 894 0840 010000EA 		b	.L143
 895              	.LVL96:
 896              	.L141:
 897              		.loc 1 5140 0 is_stmt 0 discriminator 2
 898 0844 FF2012E2 		ands	r2, r2, #255
 899 0848 3100000A 		beq	.L159
 900              	.L143:
5141:../uvc.c      **** 					i++;
5142:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 901              		.loc 1 5142 0 is_stmt 1
 902 084c 344094E5 		ldr	r4, [r4, #52]
 903              	.LVL97:
 904 0850 012042E2 		sub	r2, r2, #1
5140:../uvc.c      **** 					i++;
 905              		.loc 1 5140 0
 906 0854 3C3094E5 		ldr	r3, [r4, #60]
 907 0858 000053E3 		cmp	r3, #0
 908 085c F8FFFF0A 		beq	.L141
 909 0860 104085E5 		str	r4, [r5, #16]
 910              	.L140:
 911              	.LVL98:
 912 0864 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
5143:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
5144:../uvc.c      **** 				}
5145:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
5146:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
5147:../uvc.c      **** 					i = lcCmdDes->curNum;
5148:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
5149:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
5150:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
5151:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
5152:../uvc.c      **** #if 1
5153:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 913              		.loc 1 5153 0
 914 0868 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
 915 086c 833083E0 		add	r3, r3, r3, asl #1
 916 0870 833084E0 		add	r3, r4, r3, asl #1
 917 0874 20C04CE2 		sub	ip, ip, #32
5148:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 918              		.loc 1 5148 0
 919 0878 0400D3E5 		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 920              	.LVL99:
5149:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 921              		.loc 1 5149 0
 922 087c 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 923              	.LVL100:
5150:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 924              		.loc 1 5150 0
 925 0880 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 926              	.LVL101:
5151:../uvc.c      **** #if 1
 927              		.loc 1 5151 0
 928 0884 B890D3E1 		ldrh	r9, [r3, #8]
 929              	.LVL102:
 930              		.loc 1 5153 0
 931 0888 03005CE3 		cmp	ip, #3
 932 088c 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 933 0890 340000EA 		b	.L149
 934              	.L155:
 935 0894 04090000 		.word	.L144
 936 0898 F4080000 		.word	.L146
 937 089c A4080000 		.word	.L148
 938 08a0 A4080000 		.word	.L148
 939              	.L148:
5154:../uvc.c      **** 						case 0x20:
5155:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
5156:../uvc.c      **** 							delaytime = 500;
5157:../uvc.c      **** 							break;
5158:../uvc.c      **** 						case 0x21:
5159:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
5160:../uvc.c      **** 							delaytime = 500;
5161:../uvc.c      **** 							break;
5162:../uvc.c      **** 						case 0x22:
5163:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
5164:../uvc.c      **** 							delaytime = 300;
5165:../uvc.c      **** 							break;
5166:../uvc.c      **** 						case 0x23:
5167:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 940              		.loc 1 5167 0
 941 08a4 8230A0E3 		mov	r3, #130
 942              	.LVL103:
 943 08a8 FEFFFFEB 		bl	SensorSetIrisControl
 944              	.LVL104:
5168:../uvc.c      **** 							delaytime = 300;
5169:../uvc.c      **** 							break;
 945              		.loc 1 5169 0
 946 08ac 4B1FA0E3 		mov	r1, #300
 947              	.LVL105:
 948              	.L145:
5170:../uvc.c      **** 						default:
5171:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
5172:../uvc.c      **** 							break;
5173:../uvc.c      **** 					}
5174:../uvc.c      **** #endif
5175:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
5176:../uvc.c      **** 					/** timer's ticket modify **/
5177:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
5178:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 949              		.loc 1 5178 0
 950 08b0 0020A0E3 		mov	r2, #0
 951 08b4 B8009FE5 		ldr	r0, .L161
 952 08b8 FEFFFFEB 		bl	_txe_timer_change
 953              	.LVL106:
5179:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 954              		.loc 1 5179 0
 955 08bc B0009FE5 		ldr	r0, .L161
 956 08c0 FEFFFFEB 		bl	_txe_timer_activate
 957              	.LVL107:
5180:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
5181:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
5182:../uvc.c      **** #ifdef USB_DEBUG_PRINT
5183:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
5184:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
5185:../uvc.c      **** #endif
5186:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 958              		.loc 1 5186 0
 959 08c4 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 960 08c8 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 961 08cc 030052E1 		cmp	r2, r3
 962 08d0 1600000A 		beq	.L160
5187:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
5188:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
5189:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
5190:../uvc.c      **** 						}else{
5191:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
5192:../uvc.c      **** 						}
5193:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
5194:../uvc.c      **** 					}else{
5195:../uvc.c      **** 						lcCmdDes->curNum ++;
 963              		.loc 1 5195 0
 964 08d4 013083E2 		add	r3, r3, #1
5196:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 965              		.loc 1 5196 0
 966 08d8 0F20A0E3 		mov	r2, #15
5195:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 967              		.loc 1 5195 0
 968 08dc 0130C4E5 		strb	r3, [r4, #1]
 969              		.loc 1 5196 0
 970 08e0 3C2084E5 		str	r2, [r4, #60]
 971              	.LVL108:
 972              	.L153:
5197:../uvc.c      **** 					}
5198:../uvc.c      **** 				}else{
5199:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
5200:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
5201:../uvc.c      **** //					CyU3PDebugPrint (4, "I2C thread beat pace 0x%x\r\n",
5202:../uvc.c      **** //							1000);
5203:../uvc.c      **** 				}
5204:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 973              		.loc 1 5204 0
 974 08e4 1C0095E5 		ldr	r0, [r5, #28]
 975 08e8 FEFFFFEB 		bl	_txe_mutex_put
 976              	.LVL109:
5205:../uvc.c      **** 			}
5206:../uvc.c      **** /*
5207:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
5208:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
5209:../uvc.c      **** */
5210:../uvc.c      **** #ifdef USB_DEBUG_PRINT
5211:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
5212:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
5213:../uvc.c      **** #endif
5214:../uvc.c      **** 
5215:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
5216:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
5217:../uvc.c      **** #if 0
5218:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
5219:../uvc.c      **** 
5220:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
5221:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
5222:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
5223:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
5224:../uvc.c      **** 			    i = 0;
5225:../uvc.c      **** 				 switch(cmdCopyIdx)
5226:../uvc.c      **** 				 {
5227:../uvc.c      **** 					 case BrgtCtlID1:
5228:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
5229:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5230:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
5231:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5232:../uvc.c      **** 							 i++;
5233:../uvc.c      **** 						 }
5234:../uvc.c      **** 						 else{
5235:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5236:../uvc.c      **** 						 }
5237:../uvc.c      **** 
5238:../uvc.c      **** 						 CyU3PBusyWait(500);
5239:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
5240:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
5241:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5242:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
5243:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5244:../uvc.c      **** 						 }
5245:../uvc.c      **** 						 else{
5246:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5247:../uvc.c      **** 						 }
5248:../uvc.c      **** 						 break;
5249:../uvc.c      **** 					 case HueCtlID5:
5250:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
5251:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5252:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
5253:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5254:../uvc.c      **** 						 }
5255:../uvc.c      **** 						 else{
5256:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5257:../uvc.c      **** 						 }
5258:../uvc.c      **** 						 break;
5259:../uvc.c      **** 					 case SaturCtlID6:
5260:../uvc.c      **** 					 case WBTLevCtlID10:
5261:../uvc.c      **** 					 default:
5262:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
5263:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5264:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
5265:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5266:../uvc.c      **** 						 }
5267:../uvc.c      **** 						 else{
5268:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5269:../uvc.c      **** 						 }
5270:../uvc.c      **** 						 break;
5271:../uvc.c      **** 				 }
5272:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
5273:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
5274:../uvc.c      **** 			}
5275:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
5276:../uvc.c      **** #endif
5277:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
5278:../uvc.c      **** 		/* Allow other ready threads to run. */
5279:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
5280:../uvc.c      **** 			CyU3PThreadRelinquish ();
 977              		.loc 1 5280 0
 978 08ec FEFFFFEB 		bl	_txe_thread_relinquish
 979              	.LVL110:
5281:../uvc.c      **** 		}
 980              		.loc 1 5281 0
 981 08f0 B7FFFFEA 		b	.L154
 982              	.LVL111:
 983              	.L146:
5159:../uvc.c      **** 							delaytime = 500;
 984              		.loc 1 5159 0
 985 08f4 5230A0E3 		mov	r3, #82
 986              	.LVL112:
 987 08f8 FEFFFFEB 		bl	SensorSetIrisControl
 988              	.LVL113:
5161:../uvc.c      **** 						case 0x22:
 989              		.loc 1 5161 0
 990 08fc 7D1FA0E3 		mov	r1, #500
 991 0900 EAFFFFEA 		b	.L145
 992              	.LVL114:
 993              	.L144:
5155:../uvc.c      **** 							delaytime = 500;
 994              		.loc 1 5155 0
 995 0904 8230A0E3 		mov	r3, #130
 996              	.LVL115:
 997 0908 FEFFFFEB 		bl	SensorSetIrisControl
 998              	.LVL116:
5157:../uvc.c      **** 						case 0x21:
 999              		.loc 1 5157 0
 1000 090c 7D1FA0E3 		mov	r1, #500
 1001 0910 E6FFFFEA 		b	.L145
 1002              	.LVL117:
 1003              	.L159:
5199:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 1004              		.loc 1 5199 0
 1005 0914 FA1FA0E3 		mov	r1, #1000
 1006 0918 54009FE5 		ldr	r0, .L161
 1007 091c 104085E5 		str	r4, [r5, #16]
 1008 0920 FEFFFFEB 		bl	_txe_timer_change
 1009              	.LVL118:
5200:../uvc.c      **** //					CyU3PDebugPrint (4, "I2C thread beat pace 0x%x\r\n",
 1010              		.loc 1 5200 0
 1011 0924 48009FE5 		ldr	r0, .L161
 1012 0928 FEFFFFEB 		bl	_txe_timer_activate
 1013              	.LVL119:
 1014 092c ECFFFFEA 		b	.L153
 1015              	.LVL120:
 1016              	.L160:
5188:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 1017              		.loc 1 5188 0
 1018 0930 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
5187:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 1019              		.loc 1 5187 0
 1020 0934 0020A0E3 		mov	r2, #0
5188:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 1021              		.loc 1 5188 0
 1022 0938 230053E3 		cmp	r3, #35
5189:../uvc.c      **** 						}else{
 1023              		.loc 1 5189 0
 1024 093c 24304382 		subhi	r3, r3, #36
 1025 0940 83308380 		addhi	r3, r3, r3, asl #1
5191:../uvc.c      **** 						}
 1026              		.loc 1 5191 0
 1027 0944 83308390 		addls	r3, r3, r3, asl #1
5189:../uvc.c      **** 						}else{
 1028              		.loc 1 5189 0
 1029 0948 83318880 		addhi	r3, r8, r3, asl #3
5191:../uvc.c      **** 						}
 1030              		.loc 1 5191 0
 1031 094c 83318890 		addls	r3, r8, r3, asl #3
5189:../uvc.c      **** 						}else{
 1032              		.loc 1 5189 0
 1033 0950 7C20C385 		strhib	r2, [r3, #124]
5191:../uvc.c      **** 						}
 1034              		.loc 1 5191 0
 1035 0954 FC21C395 		strlsb	r2, [r3, #508]
5193:../uvc.c      **** 					}else{
 1036              		.loc 1 5193 0
 1037 0958 343094E5 		ldr	r3, [r4, #52]
5187:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 1038              		.loc 1 5187 0
 1039 095c 3C2084E5 		str	r2, [r4, #60]
5193:../uvc.c      **** 					}else{
 1040              		.loc 1 5193 0
 1041 0960 103085E5 		str	r3, [r5, #16]
 1042 0964 DEFFFFEA 		b	.L153
 1043              	.LVL121:
 1044              	.L149:
5171:../uvc.c      **** 							break;
 1045              		.loc 1 5171 0
 1046 0968 FEFFFFEB 		bl	SensorSetControl
 1047              	.LVL122:
 1048 096c 0910A0E1 		mov	r1, r9
5172:../uvc.c      **** 					}
 1049              		.loc 1 5172 0
 1050 0970 CEFFFFEA 		b	.L145
 1051              	.L162:
 1052              		.align	2
 1053              	.L161:
 1054 0974 00000000 		.word	I2CCmdTimer
 1055 0978 00000000 		.word	I2CCmdCb
 1056 097c 00000000 		.word	cmdQu
 1057 0980 A4010000 		.word	.LC11
 1058 0984 B8010000 		.word	.LC12
 1059 0988 00000000 		.word	statQu
 1060 098c 00000000 		.word	.LANCHOR1
 1061 0990 00000000 		.word	.LANCHOR0
 1062              		.cfi_endproc
 1063              	.LFE26:
 1065              		.align	2
 1066              		.global	CyFxUvcApplnDmaCallback
 1068              	CyFxUvcApplnDmaCallback:
 1069              	.LFB11:
2856:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 1070              		.loc 1 2856 0
 1071              		.cfi_startproc
 1072              		@ args = 0, pretend = 0, frame = 0
 1073              		@ frame_needed = 0, uses_anonymous_args = 0
 1074              	.LVL123:
2863:../uvc.c      ****     {
 1075              		.loc 1 2863 0
 1076 0994 080051E3 		cmp	r1, #8
2856:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 1077              		.loc 1 2856 0
 1078 0998 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1079              	.LCFI5:
 1080              		.cfi_def_cfa_offset 16
 1081              		.cfi_offset 4, -16
 1082              		.cfi_offset 5, -12
 1083              		.cfi_offset 6, -8
 1084              		.cfi_offset 14, -4
 1085 099c 0250A0E1 		mov	r5, r2
 1086 09a0 08D04DE2 		sub	sp, sp, #8
 1087              	.LCFI6:
 1088              		.cfi_def_cfa_offset 24
2863:../uvc.c      ****     {
 1089              		.loc 1 2863 0
 1090 09a4 0B00000A 		beq	.L174
2915:../uvc.c      ****     {
 1091              		.loc 1 2915 0
 1092 09a8 100051E3 		cmp	r1, #16
 1093 09ac 0700001A 		bne	.L163
2917:../uvc.c      ****         streamingStarted = CyTrue;
 1094              		.loc 1 2917 0
 1095 09b0 6C319FE5 		ldr	r3, .L177
2918:../uvc.c      ****     }
 1096              		.loc 1 2918 0
 1097 09b4 0110A0E3 		mov	r1, #1
 1098              	.LVL124:
2917:../uvc.c      ****         streamingStarted = CyTrue;
 1099              		.loc 1 2917 0
 1100 09b8 B228D3E1 		ldrh	r2, [r3, #130]
 1101              	.LVL125:
2918:../uvc.c      ****     }
 1102              		.loc 1 2918 0
 1103 09bc 841083E5 		str	r1, [r3, #132]
2917:../uvc.c      ****         streamingStarted = CyTrue;
 1104              		.loc 1 2917 0
 1105 09c0 012082E0 		add	r2, r2, r1
 1106 09c4 0228A0E1 		mov	r2, r2, asl #16
 1107 09c8 2228A0E1 		mov	r2, r2, lsr #16
 1108 09cc B228C3E1 		strh	r2, [r3, #130]	@ movhi
 1109              	.LVL126:
 1110              	.L163:
2920:../uvc.c      **** 
 1111              		.loc 1 2920 0
 1112 09d0 08D08DE2 		add	sp, sp, #8
 1113              		@ sp needed
 1114 09d4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1115              	.LVL127:
 1116              	.L174:
2865:../uvc.c      ****             {
 1117              		.loc 1 2865 0
 1118 09d8 48319FE5 		ldr	r3, .L177+4
 1119 09dc B420D2E1 		ldrh	r2, [r2, #4]
 1120              	.LVL128:
2879:../uvc.c      ****                 fb++;
 1121              		.loc 1 2879 0
 1122 09e0 006095E5 		ldr	r6, [r5]
2865:../uvc.c      ****             {
 1123              		.loc 1 2865 0
 1124 09e4 030052E1 		cmp	r2, r3
 1125              	.LBB6:
 1126              	.LBB7:
2603:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1127              		.loc 1 2603 0
 1128 09e8 3C019FE5 		ldr	r0, .L177+8
 1129              	.LVL129:
 1130              	.LBE7:
 1131              	.LBE6:
2865:../uvc.c      ****             {
 1132              		.loc 1 2865 0
 1133 09ec 3100000A 		beq	.L175
 1134              	.LBB11:
 1135              	.LBB12:
2603:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1136              		.loc 1 2603 0
 1137 09f0 0010E0E3 		mvn	r1, #0
 1138              	.LVL130:
 1139 09f4 FEFFFFEB 		bl	_txe_mutex_get
 1140              	.LVL131:
2604:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1141              		.loc 1 2604 0
 1142 09f8 0C0046E2 		sub	r0, r6, #12
 1143 09fc 2C119FE5 		ldr	r1, .L177+12
 1144 0a00 0C20A0E3 		mov	r2, #12
 1145 0a04 FEFFFFEB 		bl	CyU3PMemCopy
 1146              	.LVL132:
2605:../uvc.c      **** 
 1147              		.loc 1 2605 0
 1148 0a08 1C019FE5 		ldr	r0, .L177+8
 1149 0a0c FEFFFFEB 		bl	_txe_mutex_put
 1150              	.LVL133:
2610:../uvc.c      ****     }
 1151              		.loc 1 2610 0
 1152 0a10 0B3056E5 		ldrb	r3, [r6, #-11]	@ zero_extendqisi2
 1153              	.LBE12:
 1154              	.LBE11:
2886:../uvc.c      ****                 pbc = input->buffer_p.count;
 1155              		.loc 1 2886 0
 1156 0a14 08419FE5 		ldr	r4, .L177
 1157              	.LBB15:
 1158              	.LBB13:
2610:../uvc.c      ****     }
 1159              		.loc 1 2610 0
 1160 0a18 023083E3 		orr	r3, r3, #2
 1161 0a1c 0B3046E5 		strb	r3, [r6, #-11]
 1162              	.LBE13:
 1163              	.LBE15:
2892:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1164              		.loc 1 2892 0
 1165 0a20 7210D4E5 		ldrb	r1, [r4, #114]	@ zero_extendqisi2
2886:../uvc.c      ****                 pbc = input->buffer_p.count;
 1166              		.loc 1 2886 0
 1167 0a24 B627D4E1 		ldrh	r2, [r4, #118]
2887:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
 1168              		.loc 1 2887 0
 1169 0a28 B430D5E1 		ldrh	r3, [r5, #4]
2886:../uvc.c      ****                 pbc = input->buffer_p.count;
 1170              		.loc 1 2886 0
 1171 0a2c 012082E2 		add	r2, r2, #1
2892:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1172              		.loc 1 2892 0
 1173 0a30 0F0051E3 		cmp	r1, #15
2886:../uvc.c      ****                 pbc = input->buffer_p.count;
 1174              		.loc 1 2886 0
 1175 0a34 B627C4E1 		strh	r2, [r4, #118]	@ movhi
2887:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
 1176              		.loc 1 2887 0
 1177 0a38 B837C4E1 		strh	r3, [r4, #120]	@ movhi
 1178              	.LBB16:
 1179              	.LBB14:
2604:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1180              		.loc 1 2604 0
 1181 0a3c F0609FE5 		ldr	r6, .L177+16
 1182              	.LBE14:
 1183              	.LBE16:
2892:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1184              		.loc 1 2892 0
 1185 0a40 2B00000A 		beq	.L176
 1186              	.L167:
2899:../uvc.c      ****             }
 1187              		.loc 1 2899 0
 1188 0a44 0120A0E3 		mov	r2, #1
 1189 0a48 7C2084E5 		str	r2, [r4, #124]
 1190              	.L166:
2903:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1191              		.loc 1 2903 0
 1192 0a4c B028D4E1 		ldrh	r2, [r4, #128]
2904:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1193              		.loc 1 2904 0
 1194 0a50 0C1083E2 		add	r1, r3, #12
2903:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1195              		.loc 1 2903 0
 1196 0a54 013082E2 		add	r3, r2, #1
2904:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1197              		.loc 1 2904 0
 1198 0a58 0118A0E1 		mov	r1, r1, asl #16
2903:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1199              		.loc 1 2903 0
 1200 0a5c 0338A0E1 		mov	r3, r3, asl #16
2904:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1201              		.loc 1 2904 0
 1202 0a60 2118A0E1 		mov	r1, r1, lsr #16
2903:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1203              		.loc 1 2903 0
 1204 0a64 2338A0E1 		mov	r3, r3, lsr #16
2904:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1205              		.loc 1 2904 0
 1206 0a68 0020A0E3 		mov	r2, #0
 1207 0a6c C4009FE5 		ldr	r0, .L177+20
2903:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1208              		.loc 1 2903 0
 1209 0a70 B038C4E1 		strh	r3, [r4, #128]	@ movhi
2904:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1210              		.loc 1 2904 0
 1211 0a74 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 1212              	.LVL134:
2903:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1213              		.loc 1 2903 0
 1214 0a78 A4109FE5 		ldr	r1, .L177
2907:../uvc.c      ****             {
 1215              		.loc 1 2907 0
 1216 0a7c 002050E2 		subs	r2, r0, #0
 1217 0a80 D2FFFF0A 		beq	.L163
2909:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 1218              		.loc 1 2909 0
 1219 0a84 B008D1E1 		ldrh	r0, [r1, #128]
 1220              	.LVL135:
2910:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
 1221              		.loc 1 2910 0
 1222 0a88 B430D5E1 		ldrh	r3, [r5, #4]
2909:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 1223              		.loc 1 2909 0
 1224 0a8c 010040E2 		sub	r0, r0, #1
 1225 0a90 0008A0E1 		mov	r0, r0, asl #16
 1226 0a94 2008A0E1 		mov	r0, r0, lsr #16
 1227 0a98 B008C1E1 		strh	r0, [r1, #128]	@ movhi
2910:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
 1228              		.loc 1 2910 0
 1229 0a9c B008D1E1 		ldrh	r0, [r1, #128]
 1230 0aa0 B218D1E1 		ldrh	r1, [r1, #130]
 1231 0aa4 03008DE8 		stmia	sp, {r0, r1}
 1232 0aa8 8C109FE5 		ldr	r1, .L177+24
 1233 0aac 0400A0E3 		mov	r0, #4
 1234 0ab0 FEFFFFEB 		bl	CyU3PDebugPrint
 1235              	.LVL136:
 1236 0ab4 C5FFFFEA 		b	.L163
 1237              	.LVL137:
 1238              	.L175:
 1239              	.LBB17:
 1240              	.LBB8:
2603:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1241              		.loc 1 2603 0
 1242 0ab8 0010E0E3 		mvn	r1, #0
 1243              	.LVL138:
 1244              	.LBE8:
 1245              	.LBE17:
2880:../uvc.c      ****             }
 1246              		.loc 1 2880 0
 1247 0abc 60409FE5 		ldr	r4, .L177
 1248              	.LBB18:
 1249              	.LBB9:
2603:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1250              		.loc 1 2603 0
 1251 0ac0 FEFFFFEB 		bl	_txe_mutex_get
 1252              	.LVL139:
 1253              	.LBE9:
 1254              	.LBE18:
2879:../uvc.c      ****                 fb++;
 1255              		.loc 1 2879 0
 1256 0ac4 0C6046E2 		sub	r6, r6, #12
 1257              	.LVL140:
 1258              	.LBB19:
 1259              	.LBB10:
2604:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1260              		.loc 1 2604 0
 1261 0ac8 0C20A0E3 		mov	r2, #12
 1262 0acc 0600A0E1 		mov	r0, r6
 1263 0ad0 58109FE5 		ldr	r1, .L177+12
 1264 0ad4 FEFFFFEB 		bl	CyU3PMemCopy
 1265              	.LVL141:
2605:../uvc.c      **** 
 1266              		.loc 1 2605 0
 1267 0ad8 4C009FE5 		ldr	r0, .L177+8
 1268 0adc FEFFFFEB 		bl	_txe_mutex_put
 1269              	.LVL142:
 1270              	.LBE10:
 1271              	.LBE19:
2880:../uvc.c      ****             }
 1272              		.loc 1 2880 0
 1273 0ae0 B427D4E1 		ldrh	r2, [r4, #116]
 1274 0ae4 B430D5E1 		ldrh	r3, [r5, #4]
 1275 0ae8 012082E2 		add	r2, r2, #1
 1276 0aec B427C4E1 		strh	r2, [r4, #116]	@ movhi
 1277 0af0 D5FFFFEA 		b	.L166
 1278              	.LVL143:
 1279              	.L176:
2893:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 1280              		.loc 1 2893 0
 1281 0af4 0010E0E3 		mvn	r1, #0
 1282 0af8 2C009FE5 		ldr	r0, .L177+8
 1283 0afc FEFFFFEB 		bl	_txe_mutex_get
 1284              	.LVL144:
2894:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 1285              		.loc 1 2894 0
 1286 0b00 ED34D6E5 		ldrb	r3, [r6, #1261]	@ zero_extendqisi2
2895:../uvc.c      ****                 	stiflag = 0xAA;
 1287              		.loc 1 2895 0
 1288 0b04 20009FE5 		ldr	r0, .L177+8
2894:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 1289              		.loc 1 2894 0
 1290 0b08 DF3003E2 		and	r3, r3, #223
 1291 0b0c ED34C6E5 		strb	r3, [r6, #1261]
2895:../uvc.c      ****                 	stiflag = 0xAA;
 1292              		.loc 1 2895 0
 1293 0b10 FEFFFFEB 		bl	_txe_mutex_put
 1294              	.LVL145:
2896:../uvc.c      ****                 }
 1295              		.loc 1 2896 0
 1296 0b14 5530E0E3 		mvn	r3, #85
 1297 0b18 7230C4E5 		strb	r3, [r4, #114]
 1298 0b1c B430D5E1 		ldrh	r3, [r5, #4]
 1299 0b20 C7FFFFEA 		b	.L167
 1300              	.L178:
 1301              		.align	2
 1302              	.L177:
 1303 0b24 00000000 		.word	.LANCHOR0
 1304 0b28 F03F0000 		.word	16368
 1305 0b2c 00000000 		.word	imgHdMux
 1306 0b30 EC040000 		.word	.LANCHOR1+1260
 1307 0b34 00000000 		.word	.LANCHOR1
 1308 0b38 00000000 		.word	glChHandleUVCStream
 1309 0b3c DC010000 		.word	.LC13
 1310              		.cfi_endproc
 1311              	.LFE11:
 1313              		.align	2
 1315              	CyFxUVCApplnUSBEventCB:
 1316              	.LFB9:
2659:../uvc.c      ****     switch (evtype)
 1317              		.loc 1 2659 0
 1318              		.cfi_startproc
 1319              		@ args = 0, pretend = 0, frame = 8
 1320              		@ frame_needed = 0, uses_anonymous_args = 0
 1321              	.LVL146:
2660:../uvc.c      ****     {
 1322              		.loc 1 2660 0
 1323 0b40 020050E3 		cmp	r0, #2
2659:../uvc.c      ****     switch (evtype)
 1324              		.loc 1 2659 0
 1325 0b44 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1326              	.LCFI7:
 1327              		.cfi_def_cfa_offset 16
 1328              		.cfi_offset 4, -16
 1329              		.cfi_offset 5, -12
 1330              		.cfi_offset 6, -8
 1331              		.cfi_offset 14, -4
 1332 0b48 0040A0E1 		mov	r4, r0
 1333 0b4c 10D04DE2 		sub	sp, sp, #16
 1334              	.LCFI8:
 1335              		.cfi_def_cfa_offset 32
2660:../uvc.c      ****     {
 1336              		.loc 1 2660 0
 1337 0b50 3D00000A 		beq	.L181
 1338 0b54 040050E3 		cmp	r0, #4
 1339 0b58 2000000A 		beq	.L182
 1340 0b5c 010050E3 		cmp	r0, #1
 1341 0b60 0100000A 		beq	.L187
 1342              	.LVL147:
 1343              	.L179:
2696:../uvc.c      **** 
 1344              		.loc 1 2696 0
 1345 0b64 10D08DE2 		add	sp, sp, #16
 1346              		@ sp needed
 1347 0b68 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1348              	.LVL148:
 1349              	.L187:
 1350              	.LBB34:
 1351              	.LBB35:
2679:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1352              		.loc 1 2679 0
 1353 0b6c 0130A0E1 		mov	r3, r1
 1354 0b70 0420A0E1 		mov	r2, r4
2681:../uvc.c      ****             isUsbConnected = CyFalse;
 1355              		.loc 1 2681 0
 1356 0b74 40519FE5 		ldr	r5, .L188
2679:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1357              		.loc 1 2679 0
 1358 0b78 40119FE5 		ldr	r1, .L188+4
 1359              	.LVL149:
 1360 0b7c 0400A0E3 		mov	r0, #4
 1361              	.LVL150:
 1362 0b80 FEFFFFEB 		bl	CyU3PDebugPrint
 1363              	.LVL151:
2680:../uvc.c      ****             gpif_initialized = 0;
 1364              		.loc 1 2680 0
 1365 0b84 0400A0E1 		mov	r0, r4
 1366 0b88 FEFFFFEB 		bl	CyU3PGpifDisable
 1367              	.LVL152:
2681:../uvc.c      ****             isUsbConnected = CyFalse;
 1368              		.loc 1 2681 0
 1369 0b8c 00C0A0E3 		mov	ip, #0
 1370              	.LBB36:
 1371              	.LBB37:
2643:../uvc.c      **** 	{
 1372              		.loc 1 2643 0
 1373 0b90 00C08DE5 		str	ip, [sp]
 1374 0b94 0410A0E1 		mov	r1, r4
 1375 0b98 0500A0E1 		mov	r0, r5
 1376 0b9c 0220A0E3 		mov	r2, #2
 1377 0ba0 0C308DE2 		add	r3, sp, #12
 1378              	.LBE37:
 1379              	.LBE36:
2681:../uvc.c      ****             isUsbConnected = CyFalse;
 1380              		.loc 1 2681 0
 1381 0ba4 88C085E5 		str	ip, [r5, #136]
2682:../uvc.c      ****             streamingStarted = CyFalse;
 1382              		.loc 1 2682 0
 1383 0ba8 8CC085E5 		str	ip, [r5, #140]
2683:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1384              		.loc 1 2683 0
 1385 0bac 84C085E5 		str	ip, [r5, #132]
 1386              	.LBB41:
 1387              	.LBB40:
2643:../uvc.c      **** 	{
 1388              		.loc 1 2643 0
 1389 0bb0 FEFFFFEB 		bl	_txe_event_flags_get
 1390              	.LVL153:
 1391 0bb4 004050E2 		subs	r4, r0, #0
 1392 0bb8 E9FFFF1A 		bne	.L179
 1393              	.LBB38:
 1394              	.LBB39:
2646:../uvc.c      **** 
 1395              		.loc 1 2646 0
 1396 0bbc 0500A0E1 		mov	r0, r5
 1397 0bc0 0110E0E3 		mvn	r1, #1
 1398 0bc4 0220A0E3 		mov	r2, #2
 1399 0bc8 FEFFFFEB 		bl	_txe_event_flags_set
 1400              	.LVL154:
2649:../uvc.c      **** 	}
 1401              		.loc 1 2649 0
 1402 0bcc 0500A0E1 		mov	r0, r5
 1403 0bd0 0420A0E1 		mov	r2, r4
 1404 0bd4 0210A0E3 		mov	r1, #2
 1405 0bd8 FEFFFFEB 		bl	_txe_event_flags_set
 1406              	.LVL155:
 1407 0bdc E0FFFFEA 		b	.L179
 1408              	.LVL156:
 1409              	.L182:
 1410              	.LBE39:
 1411              	.LBE38:
 1412              	.LBE40:
 1413              	.LBE41:
 1414              	.LBE35:
 1415              	.LBE34:
2663:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1416              		.loc 1 2663 0
 1417 0be0 0130A0E1 		mov	r3, r1
 1418 0be4 0020A0E1 		mov	r2, r0
 1419 0be8 D4109FE5 		ldr	r1, .L188+8
 1420              	.LVL157:
 1421 0bec FEFFFFEB 		bl	CyU3PDebugPrint
 1422              	.LVL158:
2665:../uvc.c      ****             streamingStarted = CyFalse;
 1423              		.loc 1 2665 0
 1424 0bf0 C4409FE5 		ldr	r4, .L188
2664:../uvc.c      ****             gpif_initialized = 0;
 1425              		.loc 1 2664 0
 1426 0bf4 0100A0E3 		mov	r0, #1
 1427 0bf8 FEFFFFEB 		bl	CyU3PGpifDisable
 1428              	.LVL159:
2665:../uvc.c      ****             streamingStarted = CyFalse;
 1429              		.loc 1 2665 0
 1430 0bfc 00C0A0E3 		mov	ip, #0
 1431              	.LBB42:
 1432              	.LBB43:
2643:../uvc.c      **** 	{
 1433              		.loc 1 2643 0
 1434 0c00 00C08DE5 		str	ip, [sp]
 1435 0c04 0400A0E1 		mov	r0, r4
 1436 0c08 0110A0E3 		mov	r1, #1
 1437 0c0c 0220A0E3 		mov	r2, #2
 1438 0c10 0C308DE2 		add	r3, sp, #12
 1439              	.LBE43:
 1440              	.LBE42:
2665:../uvc.c      ****             streamingStarted = CyFalse;
 1441              		.loc 1 2665 0
 1442 0c14 88C084E5 		str	ip, [r4, #136]
2666:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1443              		.loc 1 2666 0
 1444 0c18 84C084E5 		str	ip, [r4, #132]
 1445              	.LBB47:
 1446              	.LBB46:
2643:../uvc.c      **** 	{
 1447              		.loc 1 2643 0
 1448 0c1c FEFFFFEB 		bl	_txe_event_flags_get
 1449              	.LVL160:
 1450 0c20 005050E2 		subs	r5, r0, #0
 1451 0c24 CEFFFF1A 		bne	.L179
 1452              	.LBB44:
 1453              	.LBB45:
2646:../uvc.c      **** 
 1454              		.loc 1 2646 0
 1455 0c28 0400A0E1 		mov	r0, r4
 1456 0c2c 0110E0E3 		mvn	r1, #1
 1457 0c30 0220A0E3 		mov	r2, #2
 1458 0c34 FEFFFFEB 		bl	_txe_event_flags_set
 1459              	.LVL161:
2649:../uvc.c      **** 	}
 1460              		.loc 1 2649 0
 1461 0c38 0400A0E1 		mov	r0, r4
 1462 0c3c 0520A0E1 		mov	r2, r5
 1463 0c40 0210A0E3 		mov	r1, #2
 1464 0c44 FEFFFFEB 		bl	_txe_event_flags_set
 1465              	.LVL162:
 1466 0c48 C5FFFFEA 		b	.L179
 1467              	.LVL163:
 1468              	.L181:
 1469              	.LBE45:
 1470              	.LBE44:
 1471              	.LBE46:
 1472              	.LBE47:
2671:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1473              		.loc 1 2671 0
 1474 0c4c 0130A0E1 		mov	r3, r1
 1475 0c50 0420A0E1 		mov	r2, r4
 1476 0c54 6C109FE5 		ldr	r1, .L188+12
 1477              	.LVL164:
2673:../uvc.c      ****             streamingStarted = CyFalse;
 1478              		.loc 1 2673 0
 1479 0c58 5C509FE5 		ldr	r5, .L188
2671:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1480              		.loc 1 2671 0
 1481 0c5c 0400A0E3 		mov	r0, #4
 1482              	.LVL165:
 1483 0c60 FEFFFFEB 		bl	CyU3PDebugPrint
 1484              	.LVL166:
2672:../uvc.c      ****             gpif_initialized = 0;
 1485              		.loc 1 2672 0
 1486 0c64 0100A0E3 		mov	r0, #1
 1487 0c68 FEFFFFEB 		bl	CyU3PGpifDisable
 1488              	.LVL167:
2673:../uvc.c      ****             streamingStarted = CyFalse;
 1489              		.loc 1 2673 0
 1490 0c6c 00C0A0E3 		mov	ip, #0
 1491              	.LBB48:
 1492              	.LBB49:
2643:../uvc.c      **** 	{
 1493              		.loc 1 2643 0
 1494 0c70 00C08DE5 		str	ip, [sp]
 1495 0c74 0500A0E1 		mov	r0, r5
 1496 0c78 0110A0E3 		mov	r1, #1
 1497 0c7c 0420A0E1 		mov	r2, r4
 1498 0c80 0C308DE2 		add	r3, sp, #12
 1499              	.LBE49:
 1500              	.LBE48:
2673:../uvc.c      ****             streamingStarted = CyFalse;
 1501              		.loc 1 2673 0
 1502 0c84 88C085E5 		str	ip, [r5, #136]
2674:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1503              		.loc 1 2674 0
 1504 0c88 84C085E5 		str	ip, [r5, #132]
 1505              	.LBB53:
 1506              	.LBB52:
2643:../uvc.c      **** 	{
 1507              		.loc 1 2643 0
 1508 0c8c FEFFFFEB 		bl	_txe_event_flags_get
 1509              	.LVL168:
 1510 0c90 006050E2 		subs	r6, r0, #0
 1511 0c94 B2FFFF1A 		bne	.L179
 1512              	.LBB50:
 1513              	.LBB51:
2646:../uvc.c      **** 
 1514              		.loc 1 2646 0
 1515 0c98 0420A0E1 		mov	r2, r4
 1516 0c9c 0500A0E1 		mov	r0, r5
 1517 0ca0 0110E0E3 		mvn	r1, #1
 1518 0ca4 FEFFFFEB 		bl	_txe_event_flags_set
 1519              	.LVL169:
2649:../uvc.c      **** 	}
 1520              		.loc 1 2649 0
 1521 0ca8 0500A0E1 		mov	r0, r5
 1522 0cac 0410A0E1 		mov	r1, r4
 1523 0cb0 0620A0E1 		mov	r2, r6
 1524 0cb4 FEFFFFEB 		bl	_txe_event_flags_set
 1525              	.LVL170:
 1526 0cb8 A9FFFFEA 		b	.L179
 1527              	.L189:
 1528              		.align	2
 1529              	.L188:
 1530 0cbc 00000000 		.word	.LANCHOR0
 1531 0cc0 6C020000 		.word	.LC16
 1532 0cc4 28020000 		.word	.LC14
 1533 0cc8 48020000 		.word	.LC15
 1534              	.LBE51:
 1535              	.LBE50:
 1536              	.LBE52:
 1537              	.LBE53:
 1538              		.cfi_endproc
 1539              	.LFE9:
 1541              		.align	2
 1543              	CyFxUVCApplnUSBSetupCB:
 1544              	.LFB10:
2704:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1545              		.loc 1 2704 0
 1546              		.cfi_startproc
 1547              		@ args = 0, pretend = 0, frame = 8
 1548              		@ frame_needed = 0, uses_anonymous_args = 0
 1549              	.LVL171:
 1550 0ccc F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
 1551              	.LCFI9:
 1552              		.cfi_def_cfa_offset 28
 1553              		.cfi_offset 4, -28
 1554              		.cfi_offset 5, -24
 1555              		.cfi_offset 6, -20
 1556              		.cfi_offset 7, -16
 1557              		.cfi_offset 8, -12
 1558              		.cfi_offset 9, -8
 1559              		.cfi_offset 14, -4
2713:../uvc.c      **** 
 1560              		.loc 1 2713 0
 1561 0cd0 B0C29FE5 		ldr	ip, .L224
2710:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1562              		.loc 1 2710 0
 1563 0cd4 B0929FE5 		ldr	r9, .L224+4
2712:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1564              		.loc 1 2712 0
 1565 0cd8 B0829FE5 		ldr	r8, .L224+8
2709:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1566              		.loc 1 2709 0
 1567 0cdc B0229FE5 		ldr	r2, .L224+12
2711:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1568              		.loc 1 2711 0
 1569 0ce0 B0329FE5 		ldr	r3, .L224+16
2712:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1570              		.loc 1 2712 0
 1571 0ce4 0168A0E1 		mov	r6, r1, asl #16
2709:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1572              		.loc 1 2709 0
 1573 0ce8 FF4000E2 		and	r4, r0, #255
2710:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1574              		.loc 1 2710 0
 1575 0cec FF5C00E2 		and	r5, r0, #65280
 1576 0cf0 2554A0E1 		mov	r5, r5, lsr #8
2712:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1577              		.loc 1 2712 0
 1578 0cf4 2668A0E1 		mov	r6, r6, lsr #16
2713:../uvc.c      **** 
 1579              		.loc 1 2713 0
 1580 0cf8 2118A0E1 		mov	r1, r1, lsr #16
 1581              	.LVL172:
2711:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1582              		.loc 1 2711 0
 1583 0cfc 2078A0E1 		mov	r7, r0, lsr #16
2716:../uvc.c      ****     {
 1584              		.loc 1 2716 0
 1585 0d00 020054E3 		cmp	r4, #2
2704:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1586              		.loc 1 2704 0
 1587 0d04 14D04DE2 		sub	sp, sp, #20
 1588              	.LCFI10:
 1589              		.cfi_def_cfa_offset 48
2710:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1590              		.loc 1 2710 0
 1591 0d08 0050C9E5 		strb	r5, [r9]
2712:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1592              		.loc 1 2712 0
 1593 0d0c B060C8E1 		strh	r6, [r8]	@ movhi
2713:../uvc.c      **** 
 1594              		.loc 1 2713 0
 1595 0d10 B010CCE1 		strh	r1, [ip]	@ movhi
2709:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1596              		.loc 1 2709 0
 1597 0d14 0040C2E5 		strb	r4, [r2]
2711:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1598              		.loc 1 2711 0
 1599 0d18 B070C3E1 		strh	r7, [r3]	@ movhi
2716:../uvc.c      ****     {
 1600              		.loc 1 2716 0
 1601 0d1c 4A00000A 		beq	.L192
 1602 0d20 0600009A 		bls	.L221
 1603 0d24 210054E3 		cmp	r4, #33
 1604 0d28 3900000A 		beq	.L195
 1605 0d2c A10054E3 		cmp	r4, #161
 1606 0d30 3700000A 		beq	.L195
 1607              	.L209:
2705:../uvc.c      ****     uint32_t status;
 1608              		.loc 1 2705 0
 1609 0d34 0000A0E3 		mov	r0, #0
 1610              	.LVL173:
 1611              	.L191:
2843:../uvc.c      **** 
 1612              		.loc 1 2843 0
 1613 0d38 14D08DE2 		add	sp, sp, #20
 1614              		@ sp needed
 1615 0d3c F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1616              	.LVL174:
 1617              	.L221:
2716:../uvc.c      ****     {
 1618              		.loc 1 2716 0
 1619 0d40 010054E3 		cmp	r4, #1
 1620 0d44 FAFFFF1A 		bne	.L209
2756:../uvc.c      ****             {
 1621              		.loc 1 2756 0
 1622 0d48 0B0055E3 		cmp	r5, #11
 1623 0d4c F8FFFF1A 		bne	.L209
2760:../uvc.c      ****                 {
 1624              		.loc 1 2760 0
 1625 0d50 010056E3 		cmp	r6, #1
 1626 0d54 F6FFFF1A 		bne	.L209
2760:../uvc.c      ****                 {
 1627              		.loc 1 2760 0 is_stmt 0 discriminator 1
 1628 0d58 000057E3 		cmp	r7, #0
 1629 0d5c F4FFFF1A 		bne	.L209
2765:../uvc.c      ****                     streamingStarted = CyFalse;
 1630              		.loc 1 2765 0 is_stmt 1
 1631 0d60 34429FE5 		ldr	r4, .L224+20
2763:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 1632              		.loc 1 2763 0
 1633 0d64 34129FE5 		ldr	r1, .L224+24
 1634 0d68 0400A0E3 		mov	r0, #4
 1635              	.LVL175:
 1636 0d6c FEFFFFEB 		bl	CyU3PDebugPrint
 1637              	.LVL176:
2764:../uvc.c      ****                     gpif_initialized = 0;
 1638              		.loc 1 2764 0
 1639 0d70 0600A0E1 		mov	r0, r6
 1640 0d74 FEFFFFEB 		bl	CyU3PGpifDisable
 1641              	.LVL177:
2768:../uvc.c      ****                     CyU3PBusyWait (100);
 1642              		.loc 1 2768 0
 1643 0d78 0610A0E1 		mov	r1, r6
 1644 0d7c 8300A0E3 		mov	r0, #131
2765:../uvc.c      ****                     streamingStarted = CyFalse;
 1645              		.loc 1 2765 0
 1646 0d80 887084E5 		str	r7, [r4, #136]
2766:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
 1647              		.loc 1 2766 0
 1648 0d84 847084E5 		str	r7, [r4, #132]
2768:../uvc.c      ****                     CyU3PBusyWait (100);
 1649              		.loc 1 2768 0
 1650 0d88 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1651              	.LVL178:
2769:../uvc.c      **** 
 1652              		.loc 1 2769 0
 1653 0d8c 6400A0E3 		mov	r0, #100
 1654 0d90 FEFFFFEB 		bl	CyFx3BusyWait
 1655              	.LVL179:
2772:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1656              		.loc 1 2772 0
 1657 0d94 08029FE5 		ldr	r0, .L224+28
 1658 0d98 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1659              	.LVL180:
2773:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1660              		.loc 1 2773 0
 1661 0d9c 8300A0E3 		mov	r0, #131
 1662 0da0 FEFFFFEB 		bl	CyU3PUsbFlushEp
 1663              	.LVL181:
2774:../uvc.c      ****                     CyU3PBusyWait (100);
 1664              		.loc 1 2774 0
 1665 0da4 0710A0E1 		mov	r1, r7
 1666 0da8 8300A0E3 		mov	r0, #131
 1667 0dac FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1668              	.LVL182:
2775:../uvc.c      **** 
 1669              		.loc 1 2775 0
 1670 0db0 6400A0E3 		mov	r0, #100
 1671 0db4 FEFFFFEB 		bl	CyFx3BusyWait
 1672              	.LVL183:
2778:../uvc.c      ****                     uvcHandleReq = CyTrue;
 1673              		.loc 1 2778 0
 1674 0db8 0710A0E1 		mov	r1, r7
 1675 0dbc 0620A0E1 		mov	r2, r6
 1676 0dc0 8300A0E3 		mov	r0, #131
 1677 0dc4 FEFFFFEB 		bl	CyU3PUsbStall
 1678              	.LVL184:
2781:../uvc.c      ****                     /* Indicate stop streaming to main thread */
 1679              		.loc 1 2781 0
 1680 0dc8 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1681              	.LVL185:
 1682              	.LBB62:
 1683              	.LBB63:
2643:../uvc.c      **** 	{
 1684              		.loc 1 2643 0
 1685 0dcc 00708DE5 		str	r7, [sp]
 1686 0dd0 0610A0E1 		mov	r1, r6
 1687 0dd4 0400A0E1 		mov	r0, r4
 1688 0dd8 0220A0E3 		mov	r2, #2
 1689 0ddc 0C308DE2 		add	r3, sp, #12
 1690              	.LBE63:
 1691              	.LBE62:
2783:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
 1692              		.loc 1 2783 0
 1693 0de0 906084E5 		str	r6, [r4, #144]
 1694              	.LBB67:
 1695              	.LBB66:
2643:../uvc.c      **** 	{
 1696              		.loc 1 2643 0
 1697 0de4 FEFFFFEB 		bl	_txe_event_flags_get
 1698              	.LVL186:
 1699 0de8 005050E2 		subs	r5, r0, #0
 1700 0dec 1300001A 		bne	.L220
 1701              	.LBB64:
 1702              	.LBB65:
2646:../uvc.c      **** 
 1703              		.loc 1 2646 0
 1704 0df0 0400A0E1 		mov	r0, r4
 1705 0df4 0110E0E3 		mvn	r1, #1
 1706 0df8 0220A0E3 		mov	r2, #2
 1707 0dfc FEFFFFEB 		bl	_txe_event_flags_set
 1708              	.LVL187:
2649:../uvc.c      **** 	}
 1709              		.loc 1 2649 0
 1710 0e00 0400A0E1 		mov	r0, r4
 1711 0e04 0520A0E1 		mov	r2, r5
 1712 0e08 0210A0E3 		mov	r1, #2
 1713 0e0c FEFFFFEB 		bl	_txe_event_flags_set
 1714              	.LVL188:
 1715 0e10 0A0000EA 		b	.L220
 1716              	.LVL189:
 1717              	.L195:
 1718              	.LBE65:
 1719              	.LBE64:
 1720              	.LBE66:
 1721              	.LBE67:
2721:../uvc.c      ****             {
 1722              		.loc 1 2721 0
 1723 0e14 FF6006E2 		and	r6, r6, #255
 1724 0e18 000056E3 		cmp	r6, #0
 1725 0e1c 1500000A 		beq	.L196
 1726 0e20 010056E3 		cmp	r6, #1
 1727 0e24 C2FFFF1A 		bne	.L209
 1728              	.LVL190:
2739:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1729              		.loc 1 2739 0
 1730 0e28 0020A0E3 		mov	r2, #0
 1731 0e2c 68019FE5 		ldr	r0, .L224+20
 1732              	.LVL191:
 1733 0e30 0810A0E3 		mov	r1, #8
 1734 0e34 FEFFFFEB 		bl	_txe_event_flags_set
 1735              	.LVL192:
2741:../uvc.c      ****                         {
 1736              		.loc 1 2741 0
 1737 0e38 002050E2 		subs	r2, r0, #0
 1738 0e3c 1B00001A 		bne	.L222
 1739              	.LVL193:
 1740              	.L220:
2725:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 1741              		.loc 1 2725 0
 1742 0e40 0100A0E3 		mov	r0, #1
 1743              	.LVL194:
2843:../uvc.c      **** 
 1744              		.loc 1 2843 0
 1745 0e44 14D08DE2 		add	sp, sp, #20
 1746              		@ sp needed
 1747 0e48 F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1748              	.LVL195:
 1749              	.L192:
2791:../uvc.c      ****             {
 1750              		.loc 1 2791 0
 1751 0e4c 010055E3 		cmp	r5, #1
 1752 0e50 B7FFFF1A 		bne	.L209
2793:../uvc.c      ****                 {
 1753              		.loc 1 2793 0
 1754 0e54 830056E3 		cmp	r6, #131
 1755 0e58 B5FFFF1A 		bne	.L209
2799:../uvc.c      ****                     {
 1756              		.loc 1 2799 0
 1757 0e5c 38819FE5 		ldr	r8, .L224+20
 1758 0e60 847098E5 		ldr	r7, [r8, #132]
 1759 0e64 010057E3 		cmp	r7, #1
 1760 0e68 1900000A 		beq	.L223
 1761              	.LVL196:
2831:../uvc.c      ****                     }
 1762              		.loc 1 2831 0
 1763 0e6c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1764              	.LVL197:
2830:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1765              		.loc 1 2830 0
 1766 0e70 0500A0E1 		mov	r0, r5
 1767 0e74 AFFFFFEA 		b	.L191
 1768              	.LVL198:
 1769              	.L196:
2726:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1770              		.loc 1 2726 0
 1771 0e78 0620A0E1 		mov	r2, r6
 1772 0e7c 18019FE5 		ldr	r0, .L224+20
 1773              	.LVL199:
 1774 0e80 0410A0E3 		mov	r1, #4
 1775 0e84 FEFFFFEB 		bl	_txe_event_flags_set
 1776              	.LVL200:
2728:../uvc.c      ****                         {
 1777              		.loc 1 2728 0
 1778 0e88 002050E2 		subs	r2, r0, #0
 1779 0e8c EBFFFF0A 		beq	.L220
2730:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1780              		.loc 1 2730 0
 1781 0e90 10119FE5 		ldr	r1, .L224+32
 1782 0e94 0400A0E3 		mov	r0, #4
 1783              	.LVL201:
 1784 0e98 FEFFFFEB 		bl	CyU3PDebugPrint
 1785              	.LVL202:
2731:../uvc.c      ****                         }
 1786              		.loc 1 2731 0
 1787 0e9c 0600A0E1 		mov	r0, r6
 1788 0ea0 0620A0E1 		mov	r2, r6
 1789 0ea4 0110A0E3 		mov	r1, #1
 1790 0ea8 FEFFFFEB 		bl	CyU3PUsbStall
 1791              	.LVL203:
 1792 0eac E3FFFFEA 		b	.L220
 1793              	.LVL204:
 1794              	.L222:
2744:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1795              		.loc 1 2744 0
 1796 0eb0 F4109FE5 		ldr	r1, .L224+36
 1797 0eb4 0400A0E3 		mov	r0, #4
 1798              	.LVL205:
 1799 0eb8 FEFFFFEB 		bl	CyU3PDebugPrint
 1800              	.LVL206:
2745:../uvc.c      ****                         }
 1801              		.loc 1 2745 0
 1802 0ebc 0000A0E3 		mov	r0, #0
 1803 0ec0 0020A0E1 		mov	r2, r0
 1804 0ec4 0610A0E1 		mov	r1, r6
 1805 0ec8 FEFFFFEB 		bl	CyU3PUsbStall
 1806              	.LVL207:
2738:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 1807              		.loc 1 2738 0
 1808 0ecc 0600A0E1 		mov	r0, r6
 1809 0ed0 98FFFFEA 		b	.L191
 1810              	.LVL208:
 1811              	.L223:
2801:../uvc.c      **** 
 1812              		.loc 1 2801 0
 1813 0ed4 D4109FE5 		ldr	r1, .L224+40
 1814 0ed8 0400A0E3 		mov	r0, #4
 1815              	.LVL209:
 1816 0edc FEFFFFEB 		bl	CyU3PDebugPrint
 1817              	.LVL210:
2804:../uvc.c      ****                         gpif_initialized = 0;
 1818              		.loc 1 2804 0
 1819 0ee0 0700A0E1 		mov	r0, r7
 1820 0ee4 FEFFFFEB 		bl	CyU3PGpifDisable
 1821              	.LVL211:
2805:../uvc.c      ****                         streamingStarted = CyFalse;
 1822              		.loc 1 2805 0
 1823 0ee8 0050A0E3 		mov	r5, #0
2809:../uvc.c      ****                         CyU3PBusyWait (100);
 1824              		.loc 1 2809 0
 1825 0eec 0710A0E1 		mov	r1, r7
 1826 0ef0 0600A0E1 		mov	r0, r6
2805:../uvc.c      ****                         streamingStarted = CyFalse;
 1827              		.loc 1 2805 0
 1828 0ef4 885088E5 		str	r5, [r8, #136]
2806:../uvc.c      **** 
 1829              		.loc 1 2806 0
 1830 0ef8 845088E5 		str	r5, [r8, #132]
2809:../uvc.c      ****                         CyU3PBusyWait (100);
 1831              		.loc 1 2809 0
 1832 0efc FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1833              	.LVL212:
2810:../uvc.c      **** 
 1834              		.loc 1 2810 0
 1835 0f00 6400A0E3 		mov	r0, #100
 1836 0f04 FEFFFFEB 		bl	CyFx3BusyWait
 1837              	.LVL213:
2813:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1838              		.loc 1 2813 0
 1839 0f08 94009FE5 		ldr	r0, .L224+28
 1840 0f0c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1841              	.LVL214:
2814:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1842              		.loc 1 2814 0
 1843 0f10 0600A0E1 		mov	r0, r6
 1844 0f14 FEFFFFEB 		bl	CyU3PUsbFlushEp
 1845              	.LVL215:
2815:../uvc.c      ****                         CyU3PBusyWait (100);
 1846              		.loc 1 2815 0
 1847 0f18 0510A0E1 		mov	r1, r5
 1848 0f1c 0600A0E1 		mov	r0, r6
 1849 0f20 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1850              	.LVL216:
2816:../uvc.c      **** 
 1851              		.loc 1 2816 0
 1852 0f24 6400A0E3 		mov	r0, #100
 1853 0f28 FEFFFFEB 		bl	CyFx3BusyWait
 1854              	.LVL217:
2819:../uvc.c      **** 
 1855              		.loc 1 2819 0
 1856 0f2c 0510A0E1 		mov	r1, r5
 1857 0f30 0720A0E1 		mov	r2, r7
 1858 0f34 0600A0E1 		mov	r0, r6
 1859 0f38 FEFFFFEB 		bl	CyU3PUsbStall
 1860              	.LVL218:
2823:../uvc.c      ****                         /* Indicate stop streaming to main thread */
 1861              		.loc 1 2823 0
 1862 0f3c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1863              	.LVL219:
 1864              	.LBB68:
 1865              	.LBB69:
2643:../uvc.c      **** 	{
 1866              		.loc 1 2643 0
 1867 0f40 00508DE5 		str	r5, [sp]
 1868 0f44 0710A0E1 		mov	r1, r7
 1869 0f48 0800A0E1 		mov	r0, r8
 1870 0f4c 0420A0E1 		mov	r2, r4
 1871 0f50 0C308DE2 		add	r3, sp, #12
 1872              	.LBE69:
 1873              	.LBE68:
2825:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
 1874              		.loc 1 2825 0
 1875 0f54 907088E5 		str	r7, [r8, #144]
 1876              	.LBB73:
 1877              	.LBB72:
2643:../uvc.c      **** 	{
 1878              		.loc 1 2643 0
 1879 0f58 FEFFFFEB 		bl	_txe_event_flags_get
 1880              	.LVL220:
 1881 0f5c 005050E2 		subs	r5, r0, #0
 1882 0f60 B6FFFF1A 		bne	.L220
 1883              	.LBB70:
 1884              	.LBB71:
2646:../uvc.c      **** 
 1885              		.loc 1 2646 0
 1886 0f64 0420A0E1 		mov	r2, r4
 1887 0f68 0800A0E1 		mov	r0, r8
 1888 0f6c 0110E0E3 		mvn	r1, #1
 1889 0f70 FEFFFFEB 		bl	_txe_event_flags_set
 1890              	.LVL221:
2649:../uvc.c      **** 	}
 1891              		.loc 1 2649 0
 1892 0f74 0800A0E1 		mov	r0, r8
 1893 0f78 0410A0E1 		mov	r1, r4
 1894 0f7c 0520A0E1 		mov	r2, r5
 1895 0f80 FEFFFFEB 		bl	_txe_event_flags_set
 1896              	.LVL222:
 1897 0f84 ADFFFFEA 		b	.L220
 1898              	.L225:
 1899              		.align	2
 1900              	.L224:
 1901 0f88 00000000 		.word	wLength
 1902 0f8c 00000000 		.word	bRequest
 1903 0f90 00000000 		.word	wIndex
 1904 0f94 00000000 		.word	bmReqType
 1905 0f98 00000000 		.word	wValue
 1906 0f9c 00000000 		.word	.LANCHOR0
 1907 0fa0 F8020000 		.word	.LC19
 1908 0fa4 00000000 		.word	glChHandleUVCStream
 1909 0fa8 8C020000 		.word	.LC17
 1910 0fac C4020000 		.word	.LC18
 1911 0fb0 10030000 		.word	.LC20
 1912              	.LBE71:
 1913              	.LBE70:
 1914              	.LBE72:
 1915              	.LBE73:
 1916              		.cfi_endproc
 1917              	.LFE10:
 1919              		.align	2
 1920              		.global	I2CCmdHandler
 1922              	I2CCmdHandler:
 1923              	.LFB0:
1205:../uvc.c      **** 	uint8_t buf[2];
 1924              		.loc 1 1205 0
 1925              		.cfi_startproc
 1926              		@ args = 0, pretend = 0, frame = 8
 1927              		@ frame_needed = 0, uses_anonymous_args = 0
 1928 0fb4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1929              	.LCFI11:
 1930              		.cfi_def_cfa_offset 36
 1931              		.cfi_offset 4, -36
 1932              		.cfi_offset 5, -32
 1933              		.cfi_offset 6, -28
 1934              		.cfi_offset 7, -24
 1935              		.cfi_offset 8, -20
 1936              		.cfi_offset 9, -16
 1937              		.cfi_offset 10, -12
 1938              		.cfi_offset 11, -8
 1939              		.cfi_offset 14, -4
1208:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1940              		.loc 1 1208 0
 1941 0fb8 F8419FE5 		ldr	r4, .L248
1205:../uvc.c      **** 	uint8_t buf[2];
 1942              		.loc 1 1205 0
 1943 0fbc 34D04DE2 		sub	sp, sp, #52
 1944              	.LCFI12:
 1945              		.cfi_def_cfa_offset 88
1213:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1946              		.loc 1 1213 0
 1947 0fc0 9A30D4E5 		ldrb	r3, [r4, #154]	@ zero_extendqisi2
1208:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1948              		.loc 1 1208 0
 1949 0fc4 9450D4E5 		ldrb	r5, [r4, #148]	@ zero_extendqisi2
 1950              	.LVL223:
1209:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1951              		.loc 1 1209 0
 1952 0fc8 9570D4E5 		ldrb	r7, [r4, #149]	@ zero_extendqisi2
 1953              	.LVL224:
1210:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 1954              		.loc 1 1210 0
 1955 0fcc 9C60D4E5 		ldrb	r6, [r4, #156]	@ zero_extendqisi2
 1956              	.LVL225:
1213:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1957              		.loc 1 1213 0
 1958 0fd0 96B0D4E5 		ldrb	fp, [r4, #150]	@ zero_extendqisi2
 1959 0fd4 97A0D4E5 		ldrb	r10, [r4, #151]	@ zero_extendqisi2
 1960 0fd8 9890D4E5 		ldrb	r9, [r4, #152]	@ zero_extendqisi2
 1961 0fdc 9980D4E5 		ldrb	r8, [r4, #153]	@ zero_extendqisi2
 1962 0fe0 10308DE5 		str	r3, [sp, #16]
 1963 0fe4 9E10D4E5 		ldrb	r1, [r4, #158]	@ zero_extendqisi2
 1964 0fe8 9BE0D4E5 		ldrb	lr, [r4, #155]	@ zero_extendqisi2
 1965 0fec 9DC0D4E5 		ldrb	ip, [r4, #157]	@ zero_extendqisi2
 1966 0ff0 0730A0E1 		mov	r3, r7
 1967 0ff4 20108DE5 		str	r1, [sp, #32]
 1968 0ff8 0400A0E3 		mov	r0, #4
 1969 0ffc 0520A0E1 		mov	r2, r5
 1970 1000 18608DE5 		str	r6, [sp, #24]
 1971 1004 00B08DE5 		str	fp, [sp]
 1972 1008 04A08DE5 		str	r10, [sp, #4]
 1973 100c 08908DE5 		str	r9, [sp, #8]
 1974 1010 0C808DE5 		str	r8, [sp, #12]
 1975 1014 14E08DE5 		str	lr, [sp, #20]
 1976 1018 1CC08DE5 		str	ip, [sp, #28]
 1977 101c 98119FE5 		ldr	r1, .L248+4
 1978 1020 FEFFFFEB 		bl	CyU3PDebugPrint
 1979              	.LVL226:
1216:../uvc.c      **** 	{
 1980              		.loc 1 1216 0
 1981 1024 9730D4E5 		ldrb	r3, [r4, #151]	@ zero_extendqisi2
 1982 1028 520053E3 		cmp	r3, #82
 1983 102c 2D00000A 		beq	.L243
 1984              	.L227:
1226:../uvc.c      **** 	{
 1985              		.loc 1 1226 0
 1986 1030 000055E3 		cmp	r5, #0
 1987 1034 1600000A 		beq	.L244
1251:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 1988              		.loc 1 1251 0
 1989 1038 010055E3 		cmp	r5, #1
 1990 103c 0100000A 		beq	.L245
 1991              	.LVL227:
 1992              	.L226:
1270:../uvc.c      **** 
 1993              		.loc 1 1270 0
 1994 1040 34D08DE2 		add	sp, sp, #52
 1995              		@ sp needed
 1996 1044 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1997              	.LVL228:
 1998              	.L245:
1253:../uvc.c      **** 				for(i = 0; i<4; i++)
 1999              		.loc 1 1253 0
 2000 1048 020057E3 		cmp	r7, #2
 2001 104c 3800000A 		beq	.L246
1258:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2002              		.loc 1 1258 0
 2003 1050 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2004 1054 5C019FE5 		ldr	r0, .L248
 2005 1058 FE1001E2 		and	r1, r1, #254
 2006 105c 820051E3 		cmp	r1, #130
 2007 1060 0200001A 		bne	.L236
1258:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2008              		.loc 1 1258 0 is_stmt 0 discriminator 1
 2009 1064 9850D0E5 		ldrb	r5, [r0, #152]	@ zero_extendqisi2
 2010              	.LVL229:
 2011 1068 300055E3 		cmp	r5, #48
 2012 106c 3D00000A 		beq	.L247
 2013              	.L236:
 2014 1070 9820D4E5 		ldrb	r2, [r4, #152]	@ zero_extendqisi2
 2015 1074 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2016              	.LVL230:
 2017              	.L237:
1263:../uvc.c      **** 			}
 2018              		.loc 1 1263 0 is_stmt 1
 2019 1078 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2020 107c 9DC0D4E5 		ldrb	ip, [r4, #157]	@ zero_extendqisi2
 2021 1080 FE0000E2 		and	r0, r0, #254
 2022 1084 00C08DE5 		str	ip, [sp]
 2023 1088 FEFFFFEB 		bl	SensorWrite2B
 2024              	.LVL231:
1270:../uvc.c      **** 
 2025              		.loc 1 1270 0
 2026 108c 34D08DE2 		add	sp, sp, #52
 2027              		@ sp needed
 2028 1090 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2029              	.LVL232:
 2030              	.L244:
1242:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2031              		.loc 1 1242 0
 2032 1094 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2033 1098 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2034 109c 28C08DE2 		add	ip, sp, #40
 2035 10a0 9820D4E5 		ldrb	r2, [r4, #152]	@ zero_extendqisi2
 2036 10a4 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2037 10a8 00C08DE5 		str	ip, [sp]
1228:../uvc.c      **** #if 0 //for debugging
 2038              		.loc 1 1228 0
 2039 10ac 0FC0A0E3 		mov	ip, #15
1242:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2040              		.loc 1 1242 0
 2041 10b0 011081E3 		orr	r1, r1, #1
1228:../uvc.c      **** #if 0 //for debugging
 2042              		.loc 1 1228 0
 2043 10b4 9FC0C4E5 		strb	ip, [r4, #159]
1242:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2044              		.loc 1 1242 0
 2045 10b8 010080E3 		orr	r0, r0, #1
 2046 10bc FEFFFFEB 		bl	SensorRead2B
 2047              	.LVL233:
1243:../uvc.c      **** 				if(CmdDataLen == 2){
 2048              		.loc 1 1243 0
 2049 10c0 2830DDE5 		ldrb	r3, [sp, #40]	@ zero_extendqisi2
1244:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 2050              		.loc 1 1244 0
 2051 10c4 020056E3 		cmp	r6, #2
1243:../uvc.c      **** 				if(CmdDataLen == 2){
 2052              		.loc 1 1243 0
 2053 10c8 9D30C4E5 		strb	r3, [r4, #157]
1245:../uvc.c      **** 				}
 2054              		.loc 1 1245 0
 2055 10cc 2920DD05 		ldreqb	r2, [sp, #41]	@ zero_extendqisi2
1228:../uvc.c      **** #if 0 //for debugging
 2056              		.loc 1 1228 0
 2057 10d0 E0309FE5 		ldr	r3, .L248
1245:../uvc.c      **** 				}
 2058              		.loc 1 1245 0
 2059 10d4 9E20C305 		streqb	r2, [r3, #158]
1247:../uvc.c      **** 		}else{//not support currently
 2060              		.loc 1 1247 0
 2061 10d8 0030E0E3 		mvn	r3, #0
 2062 10dc 9F30C4E5 		strb	r3, [r4, #159]
1270:../uvc.c      **** 
 2063              		.loc 1 1270 0
 2064 10e0 34D08DE2 		add	sp, sp, #52
 2065              		@ sp needed
 2066 10e4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2067              	.LVL234:
 2068              	.L243:
1216:../uvc.c      **** 	{
 2069              		.loc 1 1216 0 discriminator 1
 2070 10e8 9830D4E5 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 2071 10ec 300053E3 		cmp	r3, #48
 2072 10f0 CEFFFF1A 		bne	.L227
 2073 10f4 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2074 10f8 010053E3 		cmp	r3, #1
 2075 10fc CBFFFF1A 		bne	.L227
1218:../uvc.c      **** 		if(is60Hz==CyFalse)
 2076              		.loc 1 1218 0
 2077 1100 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 2078 1104 B4309FE5 		ldr	r3, .L248+8
 2079 1108 031002E2 		and	r1, r2, #3
 2080 110c 5210C3E5 		strb	r1, [r3, #82]
1219:../uvc.c      **** 			{
 2081              		.loc 1 1219 0
 2082 1110 6C1094E5 		ldr	r1, [r4, #108]
1223:../uvc.c      **** 
 2083              		.loc 1 1223 0
 2084 1114 0400A0E3 		mov	r0, #4
1219:../uvc.c      **** 			{
 2085              		.loc 1 1219 0
 2086 1118 000051E3 		cmp	r1, #0
1221:../uvc.c      **** 			}
 2087              		.loc 1 1221 0
 2088 111c 80208203 		orreq	r2, r2, #128
1223:../uvc.c      **** 
 2089              		.loc 1 1223 0
 2090 1120 5230D3E5 		ldrb	r3, [r3, #82]	@ zero_extendqisi2
 2091 1124 98109FE5 		ldr	r1, .L248+12
1221:../uvc.c      **** 			}
 2092              		.loc 1 1221 0
 2093 1128 9D20C405 		streqb	r2, [r4, #157]
1223:../uvc.c      **** 
 2094              		.loc 1 1223 0
 2095 112c FEFFFFEB 		bl	CyU3PDebugPrint
 2096              	.LVL235:
 2097 1130 BEFFFFEA 		b	.L227
 2098              	.L246:
1253:../uvc.c      **** 				for(i = 0; i<4; i++)
 2099              		.loc 1 1253 0
 2100 1134 0450A0E3 		mov	r5, #4
 2101              	.LVL236:
 2102              	.L235:
1255:../uvc.c      **** 			}
 2103              		.loc 1 1255 0 discriminator 2
 2104 1138 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2105 113c 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 2106 1140 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2107 1144 9830D4E5 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 2108 1148 FE0000E2 		and	r0, r0, #254
 2109 114c 00208DE5 		str	r2, [sp]
 2110 1150 015045E2 		sub	r5, r5, #1
 2111 1154 0020A0E3 		mov	r2, #0
 2112 1158 FEFFFFEB 		bl	SensorWrite2B2
 2113              	.LVL237:
1254:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 2114              		.loc 1 1254 0 discriminator 2
 2115 115c FF5015E2 		ands	r5, r5, #255
 2116 1160 F4FFFF1A 		bne	.L235
 2117 1164 B5FFFFEA 		b	.L226
 2118              	.L247:
1258:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2119              		.loc 1 1258 0 discriminator 1
 2120 1168 9960D0E5 		ldrb	r6, [r0, #153]	@ zero_extendqisi2
 2121              	.LVL238:
 2122 116c 100056E3 		cmp	r6, #16
 2123 1170 0630A011 		movne	r3, r6
 2124 1174 0520A011 		movne	r2, r5
 2125 1178 BEFFFF1A 		bne	.L237
1259:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 2126              		.loc 1 1259 0
 2127 117c 44409FE5 		ldr	r4, .L248+16
 2128 1180 0010E0E3 		mvn	r1, #0
 2129 1184 1C0094E5 		ldr	r0, [r4, #28]
 2130 1188 FEFFFFEB 		bl	_txe_mutex_get
 2131              	.LVL239:
1260:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 2132              		.loc 1 1260 0
 2133 118c 0010A0E3 		mov	r1, #0
 2134 1190 00108DE5 		str	r1, [sp]
 2135 1194 04108DE5 		str	r1, [sp, #4]
 2136 1198 0620A0E1 		mov	r2, r6
 2137 119c 0530A0E1 		mov	r3, r5
 2138 11a0 0400A0E1 		mov	r0, r4
 2139 11a4 1710A0E3 		mov	r1, #23
 2140 11a8 FEFFFFEB 		bl	cmdSet
 2141              	.LVL240:
1261:../uvc.c      **** 				}
 2142              		.loc 1 1261 0
 2143 11ac 1C0094E5 		ldr	r0, [r4, #28]
 2144 11b0 FEFFFFEB 		bl	_txe_mutex_put
 2145              	.LVL241:
 2146 11b4 A1FFFFEA 		b	.L226
 2147              	.L249:
 2148              		.align	2
 2149              	.L248:
 2150 11b8 00000000 		.word	.LANCHOR0
 2151 11bc 34030000 		.word	.LC21
 2152 11c0 00000000 		.word	.LANCHOR1
 2153 11c4 80030000 		.word	.LC22
 2154 11c8 00000000 		.word	cmdQu
 2155              		.cfi_endproc
 2156              	.LFE0:
 2158              		.align	2
 2159              		.global	setIrisauto
 2161              	setIrisauto:
 2162              	.LFB1:
1276:../uvc.c      **** 	uint8_t dataIdx = 0;
 2163              		.loc 1 1276 0
 2164              		.cfi_startproc
 2165              		@ args = 0, pretend = 0, frame = 0
 2166              		@ frame_needed = 0, uses_anonymous_args = 0
 2167              	.LVL242:
 2168 11cc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 2169              	.LCFI13:
 2170              		.cfi_def_cfa_offset 16
 2171              		.cfi_offset 4, -16
 2172              		.cfi_offset 5, -12
 2173              		.cfi_offset 6, -8
 2174              		.cfi_offset 14, -4
 2175 11d0 0150A0E1 		mov	r5, r1
 2176 11d4 08D04DE2 		sub	sp, sp, #8
 2177              	.LCFI14:
 2178              		.cfi_def_cfa_offset 24
1276:../uvc.c      **** 	uint8_t dataIdx = 0;
 2179              		.loc 1 1276 0
 2180 11d8 0040A0E1 		mov	r4, r0
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 2181              		.loc 1 1279 0
 2182 11dc 0060A0E3 		mov	r6, #0
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 2183              		.loc 1 1278 0
 2184 11e0 0010E0E3 		mvn	r1, #0
 2185              	.LVL243:
 2186 11e4 1C0090E5 		ldr	r0, [r0, #28]
 2187              	.LVL244:
 2188 11e8 FEFFFFEB 		bl	_txe_mutex_get
 2189              	.LVL245:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 2190              		.loc 1 1279 0
 2191 11ec 062055E0 		subs	r2, r5, r6
 2192 11f0 003072E2 		rsbs	r3, r2, #0
 2193 11f4 0230B3E0 		adcs	r3, r3, r2
 2194 11f8 00308DE5 		str	r3, [sp]
 2195 11fc 0400A0E1 		mov	r0, r4
 2196 1200 04608DE5 		str	r6, [sp, #4]
 2197 1204 2010A0E3 		mov	r1, #32
 2198 1208 2720A0E3 		mov	r2, #39
 2199 120c 3030A0E3 		mov	r3, #48
 2200 1210 FEFFFFEB 		bl	cmdSet
 2201              	.LVL246:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2202              		.loc 1 1280 0
 2203 1214 060055E1 		cmp	r5, r6
 2204 1218 0250A003 		moveq	r5, #2
 2205 121c 0150A013 		movne	r5, #1
 2206 1220 60008DE8 		stmia	sp, {r5, r6}
 2207 1224 0400A0E1 		mov	r0, r4
 2208 1228 2110A0E3 		mov	r1, #33
 2209 122c 2520A0E3 		mov	r2, #37
 2210 1230 3030A0E3 		mov	r3, #48
 2211 1234 FEFFFFEB 		bl	cmdSet
 2212              	.LVL247:
1281:../uvc.c      **** }
 2213              		.loc 1 1281 0
 2214 1238 1C0094E5 		ldr	r0, [r4, #28]
1282:../uvc.c      **** 
 2215              		.loc 1 1282 0
 2216 123c 08D08DE2 		add	sp, sp, #8
 2217              		@ sp needed
 2218 1240 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 2219              	.LVL248:
1281:../uvc.c      **** }
 2220              		.loc 1 1281 0
 2221 1244 FEFFFFEA 		b	_txe_mutex_put
 2222              	.LVL249:
 2223              		.cfi_endproc
 2224              	.LFE1:
 2226              		.align	2
 2227              		.global	getShutCtrl
 2229              	getShutCtrl:
 2230              	.LFB2:
1286:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 2231              		.loc 1 1286 0
 2232              		.cfi_startproc
 2233              		@ args = 0, pretend = 0, frame = 0
 2234              		@ frame_needed = 0, uses_anonymous_args = 0
 2235              	.LVL250:
1291:../uvc.c      **** 	case 1:
 2236              		.loc 1 1291 0
 2237 1248 013040E2 		sub	r3, r0, #1
1286:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 2238              		.loc 1 1286 0
 2239 124c 30402DE9 		stmfd	sp!, {r4, r5, lr}
 2240              	.LCFI15:
 2241              		.cfi_def_cfa_offset 12
 2242              		.cfi_offset 4, -12
 2243              		.cfi_offset 5, -8
 2244              		.cfi_offset 14, -4
 2245 1250 0020A0E1 		mov	r2, r0
 2246 1254 0CD04DE2 		sub	sp, sp, #12
 2247              	.LCFI16:
 2248              		.cfi_def_cfa_offset 24
1291:../uvc.c      **** 	case 1:
 2249              		.loc 1 1291 0
 2250 1258 090053E3 		cmp	r3, #9
 2251 125c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2252 1260 350000EA 		b	.L254
 2253              	.L256:
 2254 1264 00130000 		.word	.L255
 2255 1268 00130000 		.word	.L255
 2256 126c 00130000 		.word	.L255
 2257 1270 00130000 		.word	.L255
 2258 1274 00130000 		.word	.L255
 2259 1278 8C120000 		.word	.L257
 2260 127c 8C120000 		.word	.L257
 2261 1280 8C120000 		.word	.L257
 2262 1284 8C120000 		.word	.L257
 2263 1288 8C120000 		.word	.L257
 2264              	.L257:
 2265              	.LVL251:
1313:../uvc.c      **** 		fRate = 30;
 2266              		.loc 1 1313 0
 2267 128c D0009FE5 		ldr	r0, .L269
 2268              	.LVL252:
 2269 1290 8330A0E1 		mov	r3, r3, asl #1
1315:../uvc.c      **** 		if(NumLn > 1944)
 2270              		.loc 1 1315 0
 2271 1294 B33090E1 		ldrh	r3, [r0, r3]
 2272 1298 C8C09FE5 		ldr	ip, .L269+4
 2273 129c 030263E0 		rsb	r0, r3, r3, asl #4
 2274 12a0 8000A0E1 		mov	r0, r0, asl #1
 2275 12a4 90ECCCE0 		smull	lr, ip, r0, ip
 2276 12a8 C00FA0E1 		mov	r0, r0, asr #31
 2277 12ac 4C0460E0 		rsb	r0, r0, ip, asr #8
1316:../uvc.c      **** 			NumLn =1944;
 2278              		.loc 1 1316 0
 2279 12b0 B4E09FE5 		ldr	lr, .L269+8
1315:../uvc.c      **** 		if(NumLn > 1944)
 2280              		.loc 1 1315 0
 2281 12b4 0008A0E1 		mov	r0, r0, asl #16
 2282 12b8 20C8A0E1 		mov	ip, r0, lsr #16
 2283              	.LVL253:
1316:../uvc.c      **** 			NumLn =1944;
 2284              		.loc 1 1316 0
 2285 12bc 0E005CE1 		cmp	ip, lr
 2286 12c0 1A00008A 		bhi	.L263
 2287              	.LVL254:
 2288              	.L267:
1318:../uvc.c      **** 			NumLn = 8;
 2289              		.loc 1 1318 0
 2290 12c4 07005CE3 		cmp	ip, #7
 2291 12c8 2100008A 		bhi	.L268
 2292 12cc 0100A0E3 		mov	r0, #1
 2293 12d0 0040A0E1 		mov	r4, r0
 2294 12d4 08E0A0E3 		mov	lr, #8
 2295              	.L260:
 2296              	.LVL255:
1321:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 2297              		.loc 1 1321 0
 2298 12d8 0150A0E3 		mov	r5, #1
1322:../uvc.c      **** 		break;
 2299              		.loc 1 1322 0
 2300 12dc 04008DE5 		str	r0, [sp, #4]
 2301 12e0 00E08DE5 		str	lr, [sp]
 2302 12e4 0400A0E3 		mov	r0, #4
1321:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 2303              		.loc 1 1321 0
 2304 12e8 0050C1E5 		strb	r5, [r1]
1322:../uvc.c      **** 		break;
 2305              		.loc 1 1322 0
 2306 12ec 7C109FE5 		ldr	r1, .L269+12
 2307              	.LVL256:
 2308 12f0 FEFFFFEB 		bl	CyU3PDebugPrint
 2309              	.LVL257:
1331:../uvc.c      **** 
 2310              		.loc 1 1331 0
 2311 12f4 0400A0E1 		mov	r0, r4
 2312 12f8 0CD08DE2 		add	sp, sp, #12
 2313              		@ sp needed
 2314 12fc 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 2315              	.LVL258:
 2316              	.L255:
1297:../uvc.c      **** 		fRate = 30;
 2317              		.loc 1 1297 0
 2318 1300 5C009FE5 		ldr	r0, .L269
 2319              	.LVL259:
 2320 1304 8330A0E1 		mov	r3, r3, asl #1
 2321 1308 B33090E1 		ldrh	r3, [r0, r3]
 2322              	.LVL260:
1299:../uvc.c      **** 		if(NumLn > 1944)
 2323              		.loc 1 1299 0
 2324 130c 60009FE5 		ldr	r0, .L269+16
 2325              	.LVL261:
1300:../uvc.c      **** 			NumLn =1944;
 2326              		.loc 1 1300 0
 2327 1310 54E09FE5 		ldr	lr, .L269+8
1299:../uvc.c      **** 		if(NumLn > 1944)
 2328              		.loc 1 1299 0
 2329 1314 93C080E0 		umull	ip, r0, r3, r0
 2330 1318 A004A0E1 		mov	r0, r0, lsr #9
 2331 131c 000260E0 		rsb	r0, r0, r0, asl #4
 2332 1320 8008A0E1 		mov	r0, r0, asl #17
 2333 1324 20C8A0E1 		mov	ip, r0, lsr #16
 2334              	.LVL262:
1300:../uvc.c      **** 			NumLn =1944;
 2335              		.loc 1 1300 0
 2336 1328 0E005CE1 		cmp	ip, lr
 2337 132c E4FFFF9A 		bls	.L267
 2338              	.LVL263:
 2339              	.L263:
 2340 1330 F300A0E3 		mov	r0, #243
 2341 1334 0040A0E1 		mov	r4, r0
 2342 1338 E6FFFFEA 		b	.L260
 2343              	.LVL264:
 2344              	.L254:
1327:../uvc.c      **** 		break;
 2345              		.loc 1 1327 0
 2346 133c 0140A0E3 		mov	r4, #1
1326:../uvc.c      **** 		LnVal = 1;
 2347              		.loc 1 1326 0
 2348 1340 0030A0E3 		mov	r3, #0
1331:../uvc.c      **** 
 2349              		.loc 1 1331 0
 2350 1344 0400A0E1 		mov	r0, r4
 2351              	.LVL265:
1326:../uvc.c      **** 		LnVal = 1;
 2352              		.loc 1 1326 0
 2353 1348 0030C1E5 		strb	r3, [r1]
 2354              	.LVL266:
1331:../uvc.c      **** 
 2355              		.loc 1 1331 0
 2356 134c 0CD08DE2 		add	sp, sp, #12
 2357              		@ sp needed
 2358 1350 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 2359              	.LVL267:
 2360              	.L268:
 2361 1354 A009A0E1 		mov	r0, r0, lsr #19
 2362 1358 FF4000E2 		and	r4, r0, #255
 2363 135c 0CE0A0E1 		mov	lr, ip
 2364 1360 DCFFFFEA 		b	.L260
 2365              	.L270:
 2366              		.align	2
 2367              	.L269:
 2368 1364 00000000 		.word	.LANCHOR2
 2369 1368 817F807F 		.word	2139127681
 2370 136c 98070000 		.word	1944
 2371 1370 A8030000 		.word	.LC23
 2372 1374 01FF00FF 		.word	-16711935
 2373              		.cfi_endproc
 2374              	.LFE2:
 2376              		.align	2
 2377              		.global	ControlHandle
 2379              	ControlHandle:
 2380              	.LFB3:
1333:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2381              		.loc 1 1333 0
 2382              		.cfi_startproc
 2383              		@ args = 0, pretend = 0, frame = 32
 2384              		@ frame_needed = 0, uses_anonymous_args = 0
 2385              	.LVL268:
 2386 1378 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2387              	.LCFI17:
 2388              		.cfi_def_cfa_offset 36
 2389              		.cfi_offset 4, -36
 2390              		.cfi_offset 5, -32
 2391              		.cfi_offset 6, -28
 2392              		.cfi_offset 7, -24
 2393              		.cfi_offset 8, -20
 2394              		.cfi_offset 9, -16
 2395              		.cfi_offset 10, -12
 2396              		.cfi_offset 11, -8
 2397              		.cfi_offset 14, -4
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 2398              		.loc 1 1341 0
 2399 137c C07F9FE5 		ldr	r7, .L440
1340:../uvc.c      ****     	RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1;//ExUCtrlParArry[locCtrlID][0];
 2400              		.loc 1 1340 0
 2401 1380 0F0050E3 		cmp	r0, #15
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 2402              		.loc 1 1341 0
 2403 1384 003187E0 		add	r3, r7, r0, asl #2
 2404 1388 20301385 		ldrhi	r3, [r3, #-32]
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 2405              		.loc 1 1348 0
 2406 138c 20319395 		ldrls	r3, [r3, #288]
1333:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2407              		.loc 1 1333 0
 2408 1390 3CD04DE2 		sub	sp, sp, #60
 2409              	.LCFI18:
 2410              		.cfi_def_cfa_offset 96
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 2411              		.loc 1 1348 0
 2412 1394 00C0D3E5 		ldrb	ip, [r3]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 2413              		.loc 1 1349 0
 2414 1398 0120D3E5 		ldrb	r2, [r3, #1]	@ zero_extendqisi2
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 2415              		.loc 1 1350 0
 2416 139c 0FB0D3E5 		ldrb	fp, [r3, #15]	@ zero_extendqisi2
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 2417              		.loc 1 1351 0
 2418 13a0 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 2419              		.loc 1 1359 0
 2420 13a4 9C3F9FE5 		ldr	r3, .L440+4
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 2421              		.loc 1 1349 0
 2422 13a8 FF2002E2 		and	r2, r2, #255
1359:../uvc.c      ****     /*
 2423              		.loc 1 1359 0
 2424 13ac 0060D3E5 		ldrb	r6, [r3]	@ zero_extendqisi2
1333:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2425              		.loc 1 1333 0
 2426 13b0 0050A0E1 		mov	r5, r0
1367:../uvc.c      **** 		 {
 2427              		.loc 1 1367 0
 2428 13b4 830056E3 		cmp	r6, #131
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 2429              		.loc 1 1348 0
 2430 13b8 FFC00CE2 		and	ip, ip, #255
 2431              	.LVL269:
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 2432              		.loc 1 1349 0
 2433 13bc 20208DE5 		str	r2, [sp, #32]
 2434              	.LVL270:
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 2435              		.loc 1 1350 0
 2436 13c0 FFB00BE2 		and	fp, fp, #255
 2437              	.LVL271:
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 2438              		.loc 1 1351 0
 2439 13c4 FF8008E2 		and	r8, r8, #255
 2440              	.LVL272:
1367:../uvc.c      **** 		 {
 2441              		.loc 1 1367 0
 2442 13c8 B200000A 		beq	.L275
 2443 13cc 1500009A 		bls	.L425
 2444 13d0 850056E3 		cmp	r6, #133
 2445 13d4 A300000A 		beq	.L280
 2446 13d8 BD00003A 		bcc	.L281
 2447 13dc 860056E3 		cmp	r6, #134
 2448 13e0 6600000A 		beq	.L282
 2449 13e4 870056E3 		cmp	r6, #135
 2450 13e8 9500001A 		bne	.L274
1792:../uvc.c      **** 		 		 if(Len == 2){
 2451              		.loc 1 1792 0
 2452 13ec 0F0050E3 		cmp	r0, #15
1794:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2453              		.loc 1 1794 0
 2454 13f0 005187E0 		add	r5, r7, r0, asl #2
1792:../uvc.c      **** 		 		 if(Len == 2){
 2455              		.loc 1 1792 0
 2456 13f4 C400009A 		bls	.L330
1793:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 2457              		.loc 1 1793 0
 2458 13f8 020058E3 		cmp	r8, #2
 2459 13fc 0801000A 		beq	.L426
1799:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2460              		.loc 1 1799 0
 2461 1400 202015E5 		ldr	r2, [r5, #-32]
 2462 1404 844F9FE5 		ldr	r4, .L440+76
 2463 1408 0B10D2E5 		ldrb	r1, [r2, #11]	@ zero_extendqisi2
1800:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2464              		.loc 1 1800 0
 2465 140c 0030A0E3 		mov	r3, #0
1799:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2466              		.loc 1 1799 0
 2467 1410 2810C4E5 		strb	r1, [r4, #40]
1800:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2468              		.loc 1 1800 0
 2469 1414 2930C4E5 		strb	r3, [r4, #41]
1801:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2470              		.loc 1 1801 0
 2471 1418 0C20D2E5 		ldrb	r2, [r2, #12]	@ zero_extendqisi2
1802:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 2472              		.loc 1 1802 0
 2473 141c 2B30C4E5 		strb	r3, [r4, #43]
1801:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2474              		.loc 1 1801 0
 2475 1420 2A20C4E5 		strb	r2, [r4, #42]
 2476 1424 E70000EA 		b	.L333
 2477              	.L425:
1367:../uvc.c      **** 		 {
 2478              		.loc 1 1367 0
 2479 1428 810056E3 		cmp	r6, #129
 2480 142c 6E00000A 		beq	.L277
 2481 1430 4300008A 		bhi	.L278
 2482 1434 010056E3 		cmp	r6, #1
 2483 1438 8100001A 		bne	.L274
1828:../uvc.c      **** 				  glEp0Buffer, &readCount);
 2484              		.loc 1 1828 0
 2485 143c 4C4F9FE5 		ldr	r4, .L440+76
 2486 1440 36208DE2 		add	r2, sp, #54
 2487 1444 2000A0E3 		mov	r0, #32
 2488              	.LVL273:
 2489 1448 281084E2 		add	r1, r4, #40
 2490 144c 18C08DE5 		str	ip, [sp, #24]
 2491 1450 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2492              	.LVL274:
1830:../uvc.c      **** 			   {
 2493              		.loc 1 1830 0
 2494 1454 18C09DE5 		ldr	ip, [sp, #24]
 2495 1458 002050E2 		subs	r2, r0, #0
 2496 145c 6504001A 		bne	.L335
1832:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 2497              		.loc 1 1832 0
 2498 1460 020058E3 		cmp	r8, #2
1833:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 2499              		.loc 1 1833 0
 2500 1464 2800D405 		ldreqb	r0, [r4, #40]	@ zero_extendqisi2
 2501              	.LVL275:
1834:../uvc.c      **** 				 }else{
 2502              		.loc 1 1834 0
 2503 1468 2910D405 		ldreqb	r1, [r4, #41]	@ zero_extendqisi2
1836:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 2504              		.loc 1 1836 0
 2505 146c 2820D415 		ldrneb	r2, [r4, #40]	@ zero_extendqisi2
 2506              	.LVL276:
1837:../uvc.c      **** 				 }
 2507              		.loc 1 1837 0
 2508 1470 2A30D415 		ldrneb	r3, [r4, #42]	@ zero_extendqisi2
1834:../uvc.c      **** 				 }else{
 2509              		.loc 1 1834 0
 2510 1474 28108D05 		streq	r1, [sp, #40]
 2511 1478 0210A011 		movne	r1, r2
 2512 147c 0010A001 		moveq	r1, r0
1837:../uvc.c      **** 				 }
 2513              		.loc 1 1837 0
 2514 1480 28308D15 		strne	r3, [sp, #40]
1833:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 2515              		.loc 1 1833 0
 2516 1484 24008D05 		streq	r0, [sp, #36]
 2517              	.LVL277:
1836:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 2518              		.loc 1 1836 0
 2519 1488 24208D15 		strne	r2, [sp, #36]
 2520              	.LVL278:
1840:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 2521              		.loc 1 1840 0
 2522 148c 20009DE5 		ldr	r0, [sp, #32]
 2523 1490 28209DE5 		ldr	r2, [sp, #40]
 2524 1494 01088DE8 		stmia	sp, {r0, fp}
 2525 1498 0C108DE5 		str	r1, [sp, #12]
 2526 149c 10208DE5 		str	r2, [sp, #16]
 2527 14a0 0C30A0E1 		mov	r3, ip
 2528 14a4 08808DE5 		str	r8, [sp, #8]
 2529 14a8 0400A0E3 		mov	r0, #4
 2530 14ac 981E9FE5 		ldr	r1, .L440+8
 2531 14b0 0520A0E1 		mov	r2, r5
 2532 14b4 18C08DE5 		str	ip, [sp, #24]
 2533 14b8 FEFFFFEB 		bl	CyU3PDebugPrint
 2534              	.LVL279:
1842:../uvc.c      **** 					 switch(CtrlID)
 2535              		.loc 1 1842 0
 2536 14bc 0F0055E3 		cmp	r5, #15
1840:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 2537              		.loc 1 1840 0
 2538 14c0 24909DE5 		ldr	r9, [sp, #36]
 2539 14c4 28A09DE5 		ldr	r10, [sp, #40]
1842:../uvc.c      **** 					 switch(CtrlID)
 2540              		.loc 1 1842 0
 2541 14c8 18C09DE5 		ldr	ip, [sp, #24]
 2542 14cc C500009A 		bls	.L338
1843:../uvc.c      **** 					 {
 2543              		.loc 1 1843 0
 2544 14d0 104045E2 		sub	r4, r5, #16
 2545 14d4 180054E3 		cmp	r4, #24
 2546 14d8 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2547 14dc EC0300EA 		b	.L339
 2548              	.L341:
 2549 14e0 A4220000 		.word	.L340
 2550 14e4 94240000 		.word	.L339
 2551 14e8 94240000 		.word	.L339
 2552 14ec 94240000 		.word	.L339
 2553 14f0 94240000 		.word	.L339
 2554 14f4 94240000 		.word	.L339
 2555 14f8 94240000 		.word	.L339
 2556 14fc 94240000 		.word	.L339
 2557 1500 94240000 		.word	.L339
 2558 1504 FC210000 		.word	.L342
 2559 1508 94240000 		.word	.L339
 2560 150c 70210000 		.word	.L343
 2561 1510 B81F0000 		.word	.L395
 2562 1514 94240000 		.word	.L339
 2563 1518 C41F0000 		.word	.L344
 2564 151c 20240000 		.word	.L345
 2565 1520 94240000 		.word	.L339
 2566 1524 94240000 		.word	.L339
 2567 1528 94240000 		.word	.L339
 2568 152c 94240000 		.word	.L339
 2569 1530 94230000 		.word	.L346
 2570 1534 94240000 		.word	.L339
 2571 1538 14210000 		.word	.L347
 2572 153c 94240000 		.word	.L339
 2573 1540 30200000 		.word	.L348
 2574              	.LVL280:
 2575              	.L278:
1683:../uvc.c      **** 		 		 if(Len == 2){
 2576              		.loc 1 1683 0
 2577 1544 0F0050E3 		cmp	r0, #15
1685:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2578              		.loc 1 1685 0
 2579 1548 005187E0 		add	r5, r7, r0, asl #2
1683:../uvc.c      **** 		 		 if(Len == 2){
 2580              		.loc 1 1683 0
 2581 154c 8800009A 		bls	.L316
1684:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 2582              		.loc 1 1684 0
 2583 1550 020058E3 		cmp	r8, #2
 2584 1554 CB00000A 		beq	.L427
1690:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2585              		.loc 1 1690 0
 2586 1558 202015E5 		ldr	r2, [r5, #-32]
 2587 155c 2C4E9FE5 		ldr	r4, .L440+76
 2588 1560 0310D2E5 		ldrb	r1, [r2, #3]	@ zero_extendqisi2
1691:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2589              		.loc 1 1691 0
 2590 1564 0030A0E3 		mov	r3, #0
1690:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2591              		.loc 1 1690 0
 2592 1568 2810C4E5 		strb	r1, [r4, #40]
1691:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2593              		.loc 1 1691 0
 2594 156c 2930C4E5 		strb	r3, [r4, #41]
1692:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2595              		.loc 1 1692 0
 2596 1570 0420D2E5 		ldrb	r2, [r2, #4]	@ zero_extendqisi2
1693:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2597              		.loc 1 1693 0
 2598 1574 2B30C4E5 		strb	r3, [r4, #43]
1692:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2599              		.loc 1 1692 0
 2600 1578 2A20C4E5 		strb	r2, [r4, #42]
 2601 157c 910000EA 		b	.L333
 2602              	.L282:
 2603              	.LVL281:
1773:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCInfoLo;//ExUCtrlParArry[locCtrlID][9];//ext_co
 2604              		.loc 1 1773 0
 2605 1580 0F0050E3 		cmp	r0, #15
1774:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 2606              		.loc 1 1774 0
 2607 1584 005187E0 		add	r5, r7, r0, asl #2
 2608 1588 20301585 		ldrhi	r3, [r5, #-32]
1780:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 2609              		.loc 1 1780 0
 2610 158c 20319595 		ldrls	r3, [r5, #288]
 2611 1590 F84D9FE5 		ldr	r4, .L440+76
 2612 1594 0920D3E5 		ldrb	r2, [r3, #9]	@ zero_extendqisi2
1786:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 2613              		.loc 1 1786 0
 2614 1598 0100A0E3 		mov	r0, #1
 2615              	.LVL282:
1781:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2616              		.loc 1 1781 0
 2617 159c 0030A0E3 		mov	r3, #0
1780:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 2618              		.loc 1 1780 0
 2619 15a0 2820C4E5 		strb	r2, [r4, #40]
1781:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2620              		.loc 1 1781 0
 2621 15a4 2930C4E5 		strb	r3, [r4, #41]
1782:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 2622              		.loc 1 1782 0
 2623 15a8 2A30C4E5 		strb	r3, [r4, #42]
1783:../uvc.c      **** 		 	 }
 2624              		.loc 1 1783 0
 2625 15ac 2B30C4E5 		strb	r3, [r4, #43]
 2626              	.LVL283:
 2627              	.L417:
1818:../uvc.c      **** 		 	 if(Len == 2){
 2628              		.loc 1 1818 0
 2629 15b0 981D9FE5 		ldr	r1, .L440+12
 2630 15b4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2631              	.LVL284:
 2632 15b8 2850D4E5 		ldrb	r5, [r4, #40]	@ zero_extendqisi2
 2633 15bc 2970D4E5 		ldrb	r7, [r4, #41]	@ zero_extendqisi2
 2634 15c0 0090A0E3 		mov	r9, #0
 2635 15c4 09A0A0E1 		mov	r10, r9
 2636              	.LVL285:
 2637              	.L284:
2279:../uvc.c      **** }
 2638              		.loc 1 2279 0
 2639 15c8 00A08DE5 		str	r10, [sp]
 2640 15cc A0008DE9 		stmib	sp, {r5, r7}
 2641 15d0 7C1D9FE5 		ldr	r1, .L440+16
 2642 15d4 0620A0E1 		mov	r2, r6
 2643 15d8 0930A0E1 		mov	r3, r9
 2644 15dc 0400A0E3 		mov	r0, #4
 2645 15e0 FEFFFFEB 		bl	CyU3PDebugPrint
 2646              	.LVL286:
2280:../uvc.c      **** /************** CT control requests handler *************************/
 2647              		.loc 1 2280 0
 2648 15e4 3CD08DE2 		add	sp, sp, #60
 2649              		@ sp needed
 2650 15e8 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2651              	.LVL287:
 2652              	.L277:
1378:../uvc.c      **** 				 switch(CtrlID)
 2653              		.loc 1 1378 0
 2654 15ec 0F0050E3 		cmp	r0, #15
 2655 15f0 5000009A 		bls	.L285
1379:../uvc.c      **** 				 {
 2656              		.loc 1 1379 0
 2657 15f4 193040E2 		sub	r3, r0, #25
 2658 15f8 0F0053E3 		cmp	r3, #15
 2659 15fc 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2660 1600 900300EA 		b	.L286
 2661              	.L288:
 2662 1604 D01A0000 		.word	.L287
 2663 1608 48240000 		.word	.L286
 2664 160c 48240000 		.word	.L286
 2665 1610 48190000 		.word	.L303
 2666 1614 48240000 		.word	.L286
 2667 1618 48240000 		.word	.L286
 2668 161c 4C1B0000 		.word	.L290
 2669 1620 48240000 		.word	.L286
 2670 1624 48240000 		.word	.L286
 2671 1628 48240000 		.word	.L286
 2672 162c 48240000 		.word	.L286
 2673 1630 481A0000 		.word	.L291
 2674 1634 48240000 		.word	.L286
 2675 1638 101A0000 		.word	.L292
 2676 163c 48240000 		.word	.L286
 2677 1640 901A0000 		.word	.L293
 2678              	.L274:
2276:../uvc.c      **** 			  break;
 2679              		.loc 1 2276 0
 2680 1644 0000A0E3 		mov	r0, #0
 2681              	.LVL288:
 2682 1648 0020A0E1 		mov	r2, r0
 2683 164c 0110A0E3 		mov	r1, #1
2277:../uvc.c      **** 		 }
 2684              		.loc 1 2277 0
 2685 1650 FF70A0E3 		mov	r7, #255
 2686 1654 0090A0E3 		mov	r9, #0
2276:../uvc.c      **** 			  break;
 2687              		.loc 1 2276 0
 2688 1658 FEFFFFEB 		bl	CyU3PUsbStall
 2689              	.LVL289:
2277:../uvc.c      **** 		 }
 2690              		.loc 1 2277 0
 2691 165c 0750A0E1 		mov	r5, r7
 2692 1660 09A0A0E1 		mov	r10, r9
 2693 1664 D7FFFFEA 		b	.L284
 2694              	.LVL290:
 2695              	.L280:
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2696              		.loc 1 1371 0
 2697 1668 204D9FE5 		ldr	r4, .L440+76
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2698              		.loc 1 1372 0
 2699 166c 0030A0E3 		mov	r3, #0
 2700 1670 0390A0E1 		mov	r9, r3
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2701              		.loc 1 1373 0
 2702 1674 281084E2 		add	r1, r4, #40
 2703 1678 0200A0E3 		mov	r0, #2
 2704              	.LVL291:
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2705              		.loc 1 1371 0
 2706 167c 2880C4E5 		strb	r8, [r4, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2707              		.loc 1 1372 0
 2708 1680 2930C4E5 		strb	r3, [r4, #41]
 2709 1684 09A0A0E1 		mov	r10, r9
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2710              		.loc 1 1373 0
 2711 1688 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2712              	.LVL292:
1375:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 2713              		.loc 1 1375 0
 2714 168c FF70A0E3 		mov	r7, #255
 2715 1690 2850D4E5 		ldrb	r5, [r4, #40]	@ zero_extendqisi2
 2716 1694 CBFFFFEA 		b	.L284
 2717              	.LVL293:
 2718              	.L275:
1719:../uvc.c      **** 		 		 if(Len == 2){
 2719              		.loc 1 1719 0
 2720 1698 0F0050E3 		cmp	r0, #15
1721:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2721              		.loc 1 1721 0
 2722 169c 005187E0 		add	r5, r7, r0, asl #2
1719:../uvc.c      **** 		 		 if(Len == 2){
 2723              		.loc 1 1719 0
 2724 16a0 3E00009A 		bls	.L321
1720:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 2725              		.loc 1 1720 0
 2726 16a4 020058E3 		cmp	r8, #2
 2727 16a8 6500000A 		beq	.L428
1726:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2728              		.loc 1 1726 0
 2729 16ac 202015E5 		ldr	r2, [r5, #-32]
 2730 16b0 D84C9FE5 		ldr	r4, .L440+76
 2731 16b4 0510D2E5 		ldrb	r1, [r2, #5]	@ zero_extendqisi2
1727:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2732              		.loc 1 1727 0
 2733 16b8 0030A0E3 		mov	r3, #0
1726:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2734              		.loc 1 1726 0
 2735 16bc 2810C4E5 		strb	r1, [r4, #40]
1727:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2736              		.loc 1 1727 0
 2737 16c0 2930C4E5 		strb	r3, [r4, #41]
1728:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2738              		.loc 1 1728 0
 2739 16c4 0620D2E5 		ldrb	r2, [r2, #6]	@ zero_extendqisi2
1729:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2740              		.loc 1 1729 0
 2741 16c8 2B30C4E5 		strb	r3, [r4, #43]
1728:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2742              		.loc 1 1728 0
 2743 16cc 2A20C4E5 		strb	r2, [r4, #42]
 2744 16d0 3C0000EA 		b	.L333
 2745              	.L281:
1755:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCResLo;//ExUCtrlParArry[locCtrlID][7];//ext_con
 2746              		.loc 1 1755 0
 2747 16d4 0F0050E3 		cmp	r0, #15
1756:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 2748              		.loc 1 1756 0
 2749 16d8 005187E0 		add	r5, r7, r0, asl #2
 2750 16dc 20201585 		ldrhi	r2, [r5, #-32]
1762:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 2751              		.loc 1 1762 0
 2752 16e0 20219595 		ldrls	r2, [r5, #288]
 2753 16e4 A44C9FE5 		ldr	r4, .L440+76
 2754 16e8 0710D2E5 		ldrb	r1, [r2, #7]	@ zero_extendqisi2
1764:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 2755              		.loc 1 1764 0
 2756 16ec 0030A0E3 		mov	r3, #0
1762:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 2757              		.loc 1 1762 0
 2758 16f0 2810C4E5 		strb	r1, [r4, #40]
1763:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2759              		.loc 1 1763 0
 2760 16f4 0820D2E5 		ldrb	r2, [r2, #8]	@ zero_extendqisi2
1767:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2761              		.loc 1 1767 0
 2762 16f8 0800A0E1 		mov	r0, r8
 2763              	.LVL294:
1764:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 2764              		.loc 1 1764 0
 2765 16fc 2A30C4E5 		strb	r3, [r4, #42]
1763:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2766              		.loc 1 1763 0
 2767 1700 2920C4E5 		strb	r2, [r4, #41]
1765:../uvc.c      **** 		 	 }
 2768              		.loc 1 1765 0
 2769 1704 2B30C4E5 		strb	r3, [r4, #43]
 2770 1708 A8FFFFEA 		b	.L417
 2771              	.LVL295:
 2772              	.L330:
1806:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 2773              		.loc 1 1806 0
 2774 170c 020058E3 		cmp	r8, #2
1807:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2775              		.loc 1 1807 0
 2776 1710 203195E5 		ldr	r3, [r5, #288]
 2777 1714 744C9FE5 		ldr	r4, .L440+76
1806:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 2778              		.loc 1 1806 0
 2779 1718 5500000A 		beq	.L429
1811:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2780              		.loc 1 1811 0
 2781 171c 0B10D3E5 		ldrb	r1, [r3, #11]	@ zero_extendqisi2
1814:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 2782              		.loc 1 1814 0
 2783 1720 0020A0E3 		mov	r2, #0
1811:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2784              		.loc 1 1811 0
 2785 1724 2810C4E5 		strb	r1, [r4, #40]
1813:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2786              		.loc 1 1813 0
 2787 1728 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
1814:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 2788              		.loc 1 1814 0
 2789 172c 2B20C4E5 		strb	r2, [r4, #43]
1813:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2790              		.loc 1 1813 0
 2791 1730 2930C4E5 		strb	r3, [r4, #41]
 2792 1734 230000EA 		b	.L333
 2793              	.L285:
1521:../uvc.c      **** 				 {
 2794              		.loc 1 1521 0
 2795 1738 013040E2 		sub	r3, r0, #1
 2796 173c 0A0053E3 		cmp	r3, #10
 2797 1740 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2798 1744 030200EA 		b	.L304
 2799              	.L306:
 2800 1748 D8190000 		.word	.L305
 2801 174c 581F0000 		.word	.L304
 2802 1750 581F0000 		.word	.L304
 2803 1754 9C190000 		.word	.L307
 2804 1758 60190000 		.word	.L308
 2805 175c 581F0000 		.word	.L304
 2806 1760 40190000 		.word	.L309
 2807 1764 581F0000 		.word	.L304
 2808 1768 581F0000 		.word	.L304
 2809 176c 581F0000 		.word	.L304
 2810 1770 B8180000 		.word	.L310
 2811              	.L316:
1697:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 2812              		.loc 1 1697 0
 2813 1774 020058E3 		cmp	r8, #2
1698:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2814              		.loc 1 1698 0
 2815 1778 203195E5 		ldr	r3, [r5, #288]
 2816 177c 0C4C9FE5 		ldr	r4, .L440+76
1697:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 2817              		.loc 1 1697 0
 2818 1780 4700000A 		beq	.L430
1702:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2819              		.loc 1 1702 0
 2820 1784 0310D3E5 		ldrb	r1, [r3, #3]	@ zero_extendqisi2
1705:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2821              		.loc 1 1705 0
 2822 1788 0020A0E3 		mov	r2, #0
1702:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2823              		.loc 1 1702 0
 2824 178c 2810C4E5 		strb	r1, [r4, #40]
1704:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2825              		.loc 1 1704 0
 2826 1790 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
1705:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2827              		.loc 1 1705 0
 2828 1794 2B20C4E5 		strb	r2, [r4, #43]
1704:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2829              		.loc 1 1704 0
 2830 1798 2930C4E5 		strb	r3, [r4, #41]
 2831 179c 090000EA 		b	.L333
 2832              	.L321:
1733:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 2833              		.loc 1 1733 0
 2834 17a0 020058E3 		cmp	r8, #2
1734:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2835              		.loc 1 1734 0
 2836 17a4 203195E5 		ldr	r3, [r5, #288]
 2837 17a8 E04B9FE5 		ldr	r4, .L440+76
1733:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 2838              		.loc 1 1733 0
 2839 17ac 2B00000A 		beq	.L431
1738:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2840              		.loc 1 1738 0
 2841 17b0 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
1741:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2842              		.loc 1 1741 0
 2843 17b4 0020A0E3 		mov	r2, #0
1738:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2844              		.loc 1 1738 0
 2845 17b8 2810C4E5 		strb	r1, [r4, #40]
1740:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2846              		.loc 1 1740 0
 2847 17bc 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
1741:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2848              		.loc 1 1741 0
 2849 17c0 2B20C4E5 		strb	r2, [r4, #43]
1740:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2850              		.loc 1 1740 0
 2851 17c4 2930C4E5 		strb	r3, [r4, #41]
 2852              	.L333:
1818:../uvc.c      **** 		 	 if(Len == 2){
 2853              		.loc 1 1818 0
 2854 17c8 0800A0E1 		mov	r0, r8
 2855              	.LVL296:
 2856 17cc 7C1B9FE5 		ldr	r1, .L440+12
 2857 17d0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2858              	.LVL297:
 2859 17d4 0090A0E3 		mov	r9, #0
 2860 17d8 09A0A0E1 		mov	r10, r9
 2861 17dc 2850D4E5 		ldrb	r5, [r4, #40]	@ zero_extendqisi2
 2862 17e0 2A70D4E5 		ldrb	r7, [r4, #42]	@ zero_extendqisi2
 2863 17e4 77FFFFEA 		b	.L284
 2864              	.LVL298:
 2865              	.L338:
2077:../uvc.c      **** 					 {
 2866              		.loc 1 2077 0
 2867 17e8 0B0055E3 		cmp	r5, #11
 2868 17ec 05F19F97 		ldrls	pc, [pc, r5, asl #2]
 2869 17f0 200300EA 		b	.L363
 2870              	.L365:
 2871 17f4 E41E0000 		.word	.L364
 2872 17f8 841E0000 		.word	.L366
 2873 17fc 78240000 		.word	.L363
 2874 1800 78240000 		.word	.L363
 2875 1804 141E0000 		.word	.L367
 2876 1808 C01C0000 		.word	.L368
 2877 180c 78240000 		.word	.L363
 2878 1810 301C0000 		.word	.L369
 2879 1814 78240000 		.word	.L363
 2880 1818 78240000 		.word	.L363
 2881 181c 78240000 		.word	.L363
 2882 1820 9C1B0000 		.word	.L370
 2883              	.LVL299:
 2884              	.L426:
1794:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2885              		.loc 1 1794 0
 2886 1824 203015E5 		ldr	r3, [r5, #-32]
 2887 1828 604B9FE5 		ldr	r4, .L440+76
 2888 182c 0B20D3E5 		ldrb	r2, [r3, #11]	@ zero_extendqisi2
 2889 1830 2820C4E5 		strb	r2, [r4, #40]
1795:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 2890              		.loc 1 1795 0
 2891 1834 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 2892 1838 2930C4E5 		strb	r3, [r4, #41]
 2893              	.L332:
1818:../uvc.c      **** 		 	 if(Len == 2){
 2894              		.loc 1 1818 0
 2895 183c 0200A0E3 		mov	r0, #2
 2896              	.LVL300:
 2897 1840 5AFFFFEA 		b	.L417
 2898              	.LVL301:
 2899              	.L428:
1721:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2900              		.loc 1 1721 0
 2901 1844 203015E5 		ldr	r3, [r5, #-32]
 2902 1848 404B9FE5 		ldr	r4, .L440+76
 2903 184c 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 2904 1850 2820C4E5 		strb	r2, [r4, #40]
1722:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2905              		.loc 1 1722 0
 2906 1854 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 2907 1858 2930C4E5 		strb	r3, [r4, #41]
 2908 185c F6FFFFEA 		b	.L332
 2909              	.L431:
1734:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2910              		.loc 1 1734 0
 2911 1860 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 2912 1864 2820C4E5 		strb	r2, [r4, #40]
1735:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2913              		.loc 1 1735 0
 2914 1868 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 2915 186c 2930C4E5 		strb	r3, [r4, #41]
 2916 1870 F1FFFFEA 		b	.L332
 2917              	.L429:
1807:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2918              		.loc 1 1807 0
 2919 1874 0B20D3E5 		ldrb	r2, [r3, #11]	@ zero_extendqisi2
 2920 1878 2820C4E5 		strb	r2, [r4, #40]
1808:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 2921              		.loc 1 1808 0
 2922 187c 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 2923 1880 2930C4E5 		strb	r3, [r4, #41]
 2924 1884 ECFFFFEA 		b	.L332
 2925              	.L427:
1685:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2926              		.loc 1 1685 0
 2927 1888 203015E5 		ldr	r3, [r5, #-32]
 2928 188c FC4A9FE5 		ldr	r4, .L440+76
 2929 1890 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 2930 1894 2820C4E5 		strb	r2, [r4, #40]
1686:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2931              		.loc 1 1686 0
 2932 1898 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2933 189c 2930C4E5 		strb	r3, [r4, #41]
 2934 18a0 E5FFFFEA 		b	.L332
 2935              	.L430:
1698:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2936              		.loc 1 1698 0
 2937 18a4 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 2938 18a8 2820C4E5 		strb	r2, [r4, #40]
1699:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2939              		.loc 1 1699 0
 2940 18ac 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2941 18b0 2930C4E5 		strb	r3, [r4, #41]
 2942 18b4 E0FFFFEA 		b	.L332
 2943              	.L310:
1595:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
 2944              		.loc 1 1595 0
 2945 18b8 0C00A0E1 		mov	r0, ip
 2946              	.LVL302:
 2947 18bc 0B10A0E1 		mov	r1, fp
 2948 18c0 FEFFFFEB 		bl	SensorGetControl
 2949              	.LVL303:
1596:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 2950              		.loc 1 1596 0
 2951 18c4 0B10A0E1 		mov	r1, fp
1597:../uvc.c      **** 							WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 2952              		.loc 1 1597 0
 2953 18c8 C04A9FE5 		ldr	r4, .L440+76
1595:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
 2954              		.loc 1 1595 0
 2955 18cc 0030A0E1 		mov	r3, r0
 2956              	.LVL304:
1596:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 2957              		.loc 1 1596 0
 2958 18d0 20009DE5 		ldr	r0, [sp, #32]
 2959              	.LVL305:
 2960 18d4 1C308DE5 		str	r3, [sp, #28]
 2961 18d8 FEFFFFEB 		bl	SensorGetControl
 2962              	.LVL306:
 2963 18dc 1C309DE5 		ldr	r3, [sp, #28]
1598:../uvc.c      **** 							glEp0Buffer[2] = Data1;
 2964              		.loc 1 1598 0
 2965 18e0 A41A9FE5 		ldr	r1, .L440+72
1603:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 2966              		.loc 1 1603 0
 2967 18e4 0020A0E3 		mov	r2, #0
 2968 18e8 0350A0E1 		mov	r5, r3
1607:../uvc.c      **** 					 case ShapCtlID7:
 2969              		.loc 1 1607 0
 2970 18ec 0390A0E1 		mov	r9, r3
1597:../uvc.c      **** 							WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 2971              		.loc 1 1597 0
 2972 18f0 2830C4E5 		strb	r3, [r4, #40]
1598:../uvc.c      **** 							glEp0Buffer[2] = Data1;
 2973              		.loc 1 1598 0
 2974 18f4 8435C1E5 		strb	r3, [r1, #1412]
1603:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 2975              		.loc 1 1603 0
 2976 18f8 2920C4E5 		strb	r2, [r4, #41]
1604:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 2977              		.loc 1 1604 0
 2978 18fc 2B20C4E5 		strb	r2, [r4, #43]
 2979 1900 0070A0E1 		mov	r7, r0
1607:../uvc.c      **** 					 case ShapCtlID7:
 2980              		.loc 1 1607 0
 2981 1904 00A0A0E1 		mov	r10, r0
1599:../uvc.c      **** 							WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 2982              		.loc 1 1599 0
 2983 1908 2A00C4E5 		strb	r0, [r4, #42]
1600:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 2984              		.loc 1 1600 0
 2985 190c 8605C1E5 		strb	r0, [r1, #1414]
 2986              	.LVL307:
 2987              	.L294:
1676:../uvc.c      **** 
 2988              		.loc 1 1676 0
 2989 1910 0800A0E1 		mov	r0, r8
 2990 1914 341A9FE5 		ldr	r1, .L440+12
 2991 1918 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2992              	.LVL308:
1679:../uvc.c      **** //#endif
 2993              		.loc 1 1679 0
 2994 191c 2B00D4E5 		ldrb	r0, [r4, #43]	@ zero_extendqisi2
 2995 1920 2C10D4E5 		ldrb	r1, [r4, #44]	@ zero_extendqisi2
 2996 1924 2820D4E5 		ldrb	r2, [r4, #40]	@ zero_extendqisi2
 2997 1928 2930D4E5 		ldrb	r3, [r4, #41]	@ zero_extendqisi2
 2998 192c 03018DE8 		stmia	sp, {r0, r1, r8}
 2999 1930 201A9FE5 		ldr	r1, .L440+20
 3000 1934 0400A0E3 		mov	r0, #4
 3001 1938 FEFFFFEB 		bl	CyU3PDebugPrint
 3002              	.LVL309:
1681:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 3003              		.loc 1 1681 0
 3004 193c 21FFFFEA 		b	.L284
 3005              	.LVL310:
 3006              	.L309:
1614:../uvc.c      **** 			 	 			 {
 3007              		.loc 1 1614 0
 3008 1940 020058E3 		cmp	r8, #2
 3009 1944 F603000A 		beq	.L432
 3010              	.L303:
1397:../uvc.c      **** 			 	 	 case ExtAexModCtlID9:
 3011              		.loc 1 1397 0
 3012 1948 FF70A0E3 		mov	r7, #255
 3013 194c 0090A0E3 		mov	r9, #0
 3014 1950 0750A0E1 		mov	r5, r7
 3015 1954 09A0A0E1 		mov	r10, r9
 3016 1958 304A9FE5 		ldr	r4, .L440+76
 3017 195c EBFFFFEA 		b	.L294
 3018              	.L308:
1559:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3019              		.loc 1 1559 0
 3020 1960 0C00A0E1 		mov	r0, ip
 3021              	.LVL311:
 3022 1964 0B10A0E1 		mov	r1, fp
 3023 1968 FEFFFFEB 		bl	SensorGetControl
 3024              	.LVL312:
1564:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3025              		.loc 1 1564 0
 3026 196c 1C4A9FE5 		ldr	r4, .L440+76
1560:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3027              		.loc 1 1560 0
 3028 1970 142A9FE5 		ldr	r2, .L440+72
1565:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3029              		.loc 1 1565 0
 3030 1974 0030A0E3 		mov	r3, #0
 3031 1978 2930C4E5 		strb	r3, [r4, #41]
 3032 197c 03A0A0E1 		mov	r10, r3
1567:../uvc.c      **** 					 case MFreqCtlID4:
 3033              		.loc 1 1567 0
 3034 1980 FF70A0E3 		mov	r7, #255
1564:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3035              		.loc 1 1564 0
 3036 1984 805040E2 		sub	r5, r0, #128
 3037 1988 FF5005E2 		and	r5, r5, #255
1560:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3038              		.loc 1 1560 0
 3039 198c 6905C2E5 		strb	r0, [r2, #1385]
 3040 1990 0090A0E1 		mov	r9, r0
1564:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3041              		.loc 1 1564 0
 3042 1994 2850C4E5 		strb	r5, [r4, #40]
 3043              	.LVL313:
1567:../uvc.c      **** 					 case MFreqCtlID4:
 3044              		.loc 1 1567 0
 3045 1998 DCFFFFEA 		b	.L294
 3046              	.LVL314:
 3047              	.L307:
1579:../uvc.c      **** 							glEp0Buffer[0] = (Data0&0x80)>>7;
 3048              		.loc 1 1579 0
 3049 199c 0B10A0E1 		mov	r1, fp
 3050 19a0 0100A0E3 		mov	r0, #1
 3051              	.LVL315:
 3052 19a4 FEFFFFEB 		bl	SensorGetControl
 3053              	.LVL316:
1582:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
 3054              		.loc 1 1582 0
 3055 19a8 DC399FE5 		ldr	r3, .L440+72
1580:../uvc.c      **** 							//glEp0Buffer[0]++;
 3056              		.loc 1 1580 0
 3057 19ac DC499FE5 		ldr	r4, .L440+76
 3058 19b0 00A0A0E3 		mov	r10, #0
 3059 19b4 A053A0E1 		mov	r5, r0, lsr #7
 3060 19b8 FF5005E2 		and	r5, r5, #255
1582:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
 3061              		.loc 1 1582 0
 3062 19bc 7D55C3E5 		strb	r5, [r3, #1405]
1583:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3063              		.loc 1 1583 0
 3064 19c0 7E75D3E5 		ldrb	r7, [r3, #1406]	@ zero_extendqisi2
 3065 19c4 0090A0E1 		mov	r9, r0
 3066 19c8 FF7007E2 		and	r7, r7, #255
 3067 19cc 2970C4E5 		strb	r7, [r4, #41]
 3068              	.LVL317:
1580:../uvc.c      **** 							//glEp0Buffer[0]++;
 3069              		.loc 1 1580 0
 3070 19d0 2850C4E5 		strb	r5, [r4, #40]
1589:../uvc.c      **** 					 case WBTLevCtlID11:
 3071              		.loc 1 1589 0
 3072 19d4 CDFFFFEA 		b	.L294
 3073              	.LVL318:
 3074              	.L305:
1539:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3075              		.loc 1 1539 0
 3076 19d8 0C00A0E1 		mov	r0, ip
 3077              	.LVL319:
 3078 19dc 0B10A0E1 		mov	r1, fp
 3079 19e0 FEFFFFEB 		bl	SensorGetControl
 3080              	.LVL320:
1551:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3081              		.loc 1 1551 0
 3082 19e4 A4499FE5 		ldr	r4, .L440+76
1540:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3083              		.loc 1 1540 0
 3084 19e8 9C299FE5 		ldr	r2, .L440+72
1552:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3085              		.loc 1 1552 0
 3086 19ec 0030A0E3 		mov	r3, #0
 3087 19f0 2930C4E5 		strb	r3, [r4, #41]
 3088 19f4 03A0A0E1 		mov	r10, r3
1554:../uvc.c      **** 					 case HueCtlID5:
 3089              		.loc 1 1554 0
 3090 19f8 FF70A0E3 		mov	r7, #255
 3091 19fc 0050A0E1 		mov	r5, r0
1540:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3092              		.loc 1 1540 0
 3093 1a00 5505C2E5 		strb	r0, [r2, #1365]
 3094              	.LVL321:
1551:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3095              		.loc 1 1551 0
 3096 1a04 2800C4E5 		strb	r0, [r4, #40]
1554:../uvc.c      **** 					 case HueCtlID5:
 3097              		.loc 1 1554 0
 3098 1a08 0090A0E1 		mov	r9, r0
 3099 1a0c BFFFFFEA 		b	.L294
 3100              	.LVL322:
 3101              	.L292:
1386:../uvc.c      **** 							if(Data0&0x80)
 3102              		.loc 1 1386 0
 3103 1a10 0C00A0E1 		mov	r0, ip
 3104              	.LVL323:
 3105 1a14 0B10A0E1 		mov	r1, fp
 3106 1a18 FEFFFFEB 		bl	SensorGetControl
 3107              	.LVL324:
 3108 1a1c 6C499FE5 		ldr	r4, .L440+76
1391:../uvc.c      **** 							glEp0Buffer[1] = 0; //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;ExUCtrlParArry[CtrlID-0x20][14];
 3109              		.loc 1 1391 0
 3110 1a20 64399FE5 		ldr	r3, .L440+72
1392:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 3111              		.loc 1 1392 0
 3112 1a24 0070A0E3 		mov	r7, #0
 3113 1a28 2970C4E5 		strb	r7, [r4, #41]
 3114 1a2c 07A0A0E1 		mov	r10, r7
1387:../uvc.c      **** 								glEp0Buffer[0] = 1;
 3115              		.loc 1 1387 0
 3116 1a30 FF5000E2 		and	r5, r0, #255
 3117 1a34 A553A0E1 		mov	r5, r5, lsr #7
 3118              	.LVL325:
 3119 1a38 0090A0E1 		mov	r9, r0
1391:../uvc.c      **** 							glEp0Buffer[1] = 0; //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;ExUCtrlParArry[CtrlID-0x20][14];
 3120              		.loc 1 1391 0
 3121 1a3c 0555C3E5 		strb	r5, [r3, #1285]
 3122 1a40 2850C4E5 		strb	r5, [r4, #40]
1397:../uvc.c      **** 			 	 	 case ExtAexModCtlID9:
 3123              		.loc 1 1397 0
 3124 1a44 B1FFFFEA 		b	.L294
 3125              	.LVL326:
 3126              	.L291:
1460:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3127              		.loc 1 1460 0
 3128 1a48 0C00A0E1 		mov	r0, ip
 3129              	.LVL327:
 3130 1a4c 0B10A0E1 		mov	r1, fp
 3131 1a50 FEFFFFEB 		bl	SensorGetControl
 3132              	.LVL328:
 3133 1a54 34499FE5 		ldr	r4, .L440+76
1461:../uvc.c      **** 	 	 				 glEp0Buffer[1] = SensorGetControl(RegAdd1, devAdd);
 3134              		.loc 1 1461 0
 3135 1a58 2C599FE5 		ldr	r5, .L440+72
1462:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 3136              		.loc 1 1462 0
 3137 1a5c 0B10A0E1 		mov	r1, fp
1460:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3138              		.loc 1 1460 0
 3139 1a60 0030A0E1 		mov	r3, r0
1462:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 3140              		.loc 1 1462 0
 3141 1a64 20009DE5 		ldr	r0, [sp, #32]
1461:../uvc.c      **** 	 	 				 glEp0Buffer[1] = SensorGetControl(RegAdd1, devAdd);
 3142              		.loc 1 1461 0
 3143 1a68 4135C5E5 		strb	r3, [r5, #1345]
1460:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3144              		.loc 1 1460 0
 3145 1a6c 2830C4E5 		strb	r3, [r4, #40]
1462:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 3146              		.loc 1 1462 0
 3147 1a70 FEFFFFEB 		bl	SensorGetControl
 3148              	.LVL329:
1463:../uvc.c      **** 	 	 				 sendData = glEp0Buffer[0];
 3149              		.loc 1 1463 0
 3150 1a74 4205C5E5 		strb	r0, [r5, #1346]
 3151              	.LVL330:
 3152 1a78 2850D4E5 		ldrb	r5, [r4, #40]	@ zero_extendqisi2
 3153 1a7c 0070A0E1 		mov	r7, r0
1462:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 3154              		.loc 1 1462 0
 3155 1a80 2900C4E5 		strb	r0, [r4, #41]
 3156              	.LVL331:
 3157              	.L412:
 3158 1a84 0090A0E3 		mov	r9, #0
 3159 1a88 09A0A0E1 		mov	r10, r9
1466:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 3160              		.loc 1 1466 0
 3161 1a8c 9FFFFFEA 		b	.L294
 3162              	.LVL332:
 3163              	.L293:
1450:../uvc.c      **** 			 	 		// sendData &= 0x70;
 3164              		.loc 1 1450 0
 3165 1a90 20009DE5 		ldr	r0, [sp, #32]
 3166              	.LVL333:
 3167 1a94 0B10A0E1 		mov	r1, fp
 3168 1a98 FEFFFFEB 		bl	SensorGetControl
 3169              	.LVL334:
1452:../uvc.c      **** 	 	 				 glEp0Buffer[0] = (sendData >> 4)&0xF; // bit6:4 are significant bits. bit7 is fine shutter
 3170              		.loc 1 1452 0
 3171 1a9c EC489FE5 		ldr	r4, .L440+76
 3172 1aa0 E4389FE5 		ldr	r3, .L440+72
 3173 1aa4 2820D4E5 		ldrb	r2, [r4, #40]	@ zero_extendqisi2
1454:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 3174              		.loc 1 1454 0
 3175 1aa8 0070A0E3 		mov	r7, #0
1452:../uvc.c      **** 	 	 				 glEp0Buffer[0] = (sendData >> 4)&0xF; // bit6:4 are significant bits. bit7 is fine shutter
 3176              		.loc 1 1452 0
 3177 1aac 2D25C3E5 		strb	r2, [r3, #1325]
1454:../uvc.c      **** 	 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 3178              		.loc 1 1454 0
 3179 1ab0 2970C4E5 		strb	r7, [r4, #41]
1455:../uvc.c      **** 	 	 				 sendData = glEp0Buffer[0];
 3180              		.loc 1 1455 0
 3181 1ab4 2E75C3E5 		strb	r7, [r3, #1326]
 3182 1ab8 0790A0E1 		mov	r9, r7
 3183 1abc 07A0A0E1 		mov	r10, r7
1453:../uvc.c      **** 	 	 				 glEp0Buffer[1] = 0;
 3184              		.loc 1 1453 0
 3185 1ac0 2002A0E1 		mov	r0, r0, lsr #4
 3186              	.LVL335:
 3187 1ac4 FF5000E2 		and	r5, r0, #255
 3188              	.LVL336:
 3189 1ac8 2850C4E5 		strb	r5, [r4, #40]
1458:../uvc.c      **** 				 	 case Ext1BLCRangeCtlID4:
 3190              		.loc 1 1458 0
 3191 1acc 8FFFFFEA 		b	.L294
 3192              	.LVL337:
 3193              	.L287:
1403:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0]; // keep the original data.
 3194              		.loc 1 1403 0
 3195 1ad0 0C00A0E1 		mov	r0, ip
 3196              	.LVL338:
 3197 1ad4 0B10A0E1 		mov	r1, fp
 3198 1ad8 FEFFFFEB 		bl	SensorGetControl
 3199              	.LVL339:
1405:../uvc.c      **** 			 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 3200              		.loc 1 1405 0
 3201 1adc AC489FE5 		ldr	r4, .L440+76
1404:../uvc.c      **** 			 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // 1:0 for Aex Mode
 3202              		.loc 1 1404 0
 3203 1ae0 A4789FE5 		ldr	r7, .L440+72
1406:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 3204              		.loc 1 1406 0
 3205 1ae4 0B10A0E1 		mov	r1, fp
1403:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0]; // keep the original data.
 3206              		.loc 1 1403 0
 3207 1ae8 0030A0E1 		mov	r3, r0
1405:../uvc.c      **** 			 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 3208              		.loc 1 1405 0
 3209 1aec 032003E2 		and	r2, r3, #3
1406:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 3210              		.loc 1 1406 0
 3211 1af0 20009DE5 		ldr	r0, [sp, #32]
1404:../uvc.c      **** 			 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // 1:0 for Aex Mode
 3212              		.loc 1 1404 0
 3213 1af4 1935C7E5 		strb	r3, [r7, #1305]
1405:../uvc.c      **** 			 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 3214              		.loc 1 1405 0
 3215 1af8 2820C4E5 		strb	r2, [r4, #40]
1406:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 3216              		.loc 1 1406 0
 3217 1afc FEFFFFEB 		bl	SensorGetControl
 3218              	.LVL340:
1414:../uvc.c      **** 						 break;
 3219              		.loc 1 1414 0
 3220 1b00 2850D4E5 		ldrb	r5, [r4, #40]	@ zero_extendqisi2
1410:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 3221              		.loc 1 1410 0
 3222 1b04 00E0A0E3 		mov	lr, #0
1414:../uvc.c      **** 						 break;
 3223              		.loc 1 1414 0
 3224 1b08 1910A0E3 		mov	r1, #25
 3225 1b0c 0E90A0E1 		mov	r9, lr
 3226 1b10 0520A0E1 		mov	r2, r5
 3227 1b14 09A0A0E1 		mov	r10, r9
1406:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 3228              		.loc 1 1406 0
 3229 1b18 00C0A0E1 		mov	ip, r0
1407:../uvc.c      **** 			 	 			//curFlag[CtrlID] = CyTrue;
 3230              		.loc 1 1407 0
 3231 1b1c 1A05C7E5 		strb	r0, [r7, #1306]
1414:../uvc.c      **** 						 break;
 3232              		.loc 1 1414 0
 3233 1b20 1935D7E5 		ldrb	r3, [r7, #1305]	@ zero_extendqisi2
 3234 1b24 00008DE5 		str	r0, [sp]
 3235 1b28 04108DE5 		str	r1, [sp, #4]
 3236 1b2c 0070A0E1 		mov	r7, r0
 3237 1b30 24189FE5 		ldr	r1, .L440+24
 3238 1b34 0400A0E3 		mov	r0, #4
1406:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 3239              		.loc 1 1406 0
 3240 1b38 2AC0C4E5 		strb	ip, [r4, #42]
1410:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 3241              		.loc 1 1410 0
 3242 1b3c 29E0C4E5 		strb	lr, [r4, #41]
1411:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3243              		.loc 1 1411 0
 3244 1b40 2BE0C4E5 		strb	lr, [r4, #43]
 3245              	.LVL341:
1414:../uvc.c      **** 						 break;
 3246              		.loc 1 1414 0
 3247 1b44 FEFFFFEB 		bl	CyU3PDebugPrint
 3248              	.LVL342:
1415:../uvc.c      **** 				 	 case ExtCamMCtlID12: //EXTCamMode
 3249              		.loc 1 1415 0
 3250 1b48 70FFFFEA 		b	.L294
 3251              	.LVL343:
 3252              	.L290:
1434:../uvc.c      **** 				 			glEp0Buffer[idx] = I2CCMDArry[idx];
 3253              		.loc 1 1434 0 discriminator 1
 3254 1b4c 000058E3 		cmp	r8, #0
 3255 1b50 0300000A 		beq	.L298
 3256 1b54 F4079FE5 		ldr	r0, .L440+12
 3257              	.LVL344:
 3258 1b58 0820A0E1 		mov	r2, r8
 3259 1b5c 6C1080E2 		add	r1, r0, #108
 3260 1b60 FEFFFFEB 		bl	memcpy
 3261              	.LVL345:
 3262              	.L298:
1437:../uvc.c      **** 				 		 sendData1 = glEp0Buffer[10];
 3263              		.loc 1 1437 0
 3264 1b64 24489FE5 		ldr	r4, .L440+76
1444:../uvc.c      **** 				 		 {
 3265              		.loc 1 1444 0
 3266 1b68 9F30D4E5 		ldrb	r3, [r4, #159]	@ zero_extendqisi2
1437:../uvc.c      **** 				 		 sendData1 = glEp0Buffer[10];
 3267              		.loc 1 1437 0
 3268 1b6c 3150D4E5 		ldrb	r5, [r4, #49]	@ zero_extendqisi2
 3269              	.LVL346:
1444:../uvc.c      **** 				 		 {
 3270              		.loc 1 1444 0
 3271 1b70 FF0053E3 		cmp	r3, #255
1438:../uvc.c      **** 	#ifdef USB_DEBUG_PRINT
 3272              		.loc 1 1438 0
 3273 1b74 3270D4E5 		ldrb	r7, [r4, #50]	@ zero_extendqisi2
 3274              	.LVL347:
1444:../uvc.c      **** 				 		 {
 3275              		.loc 1 1444 0
 3276 1b78 C1FFFF0A 		beq	.L412
1446:../uvc.c      **** 				 		 }
 3277              		.loc 1 1446 0
 3278 1b7c 0400A0E3 		mov	r0, #4
 3279 1b80 D8179FE5 		ldr	r1, .L440+28
 3280 1b84 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 3281 1b88 9E30D4E5 		ldrb	r3, [r4, #158]	@ zero_extendqisi2
 3282 1b8c FEFFFFEB 		bl	CyU3PDebugPrint
 3283              	.LVL348:
 3284 1b90 0090A0E3 		mov	r9, #0
 3285 1b94 09A0A0E1 		mov	r10, r9
 3286 1b98 5CFFFFEA 		b	.L294
 3287              	.LVL349:
 3288              	.L370:
2183:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3289              		.loc 1 2183 0
 3290 1b9c E4479FE5 		ldr	r4, .L440+68
 3291 1ba0 0010E0E3 		mvn	r1, #0
 3292 1ba4 1C0094E5 		ldr	r0, [r4, #28]
 3293 1ba8 18C08DE5 		str	ip, [sp, #24]
 3294 1bac FEFFFFEB 		bl	_txe_mutex_get
 3295              	.LVL350:
2184:../uvc.c      **** 							 dataIdx++;
 3296              		.loc 1 2184 0
 3297 1bb0 24009DE5 		ldr	r0, [sp, #36]
 3298 1bb4 18C09DE5 		ldr	ip, [sp, #24]
 3299 1bb8 0030A0E3 		mov	r3, #0
 3300 1bbc 0C20A0E1 		mov	r2, ip
 3301 1bc0 00008DE5 		str	r0, [sp]
 3302 1bc4 04308DE5 		str	r3, [sp, #4]
 3303 1bc8 0B10A0E3 		mov	r1, #11
 3304 1bcc 0B30A0E1 		mov	r3, fp
 3305 1bd0 0400A0E1 		mov	r0, r4
 3306 1bd4 FEFFFFEB 		bl	cmdSet
 3307              	.LVL351:
2186:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3308              		.loc 1 2186 0
 3309 1bd8 28C09DE5 		ldr	ip, [sp, #40]
 3310 1bdc 0180A0E3 		mov	r8, #1
 3311              	.LVL352:
 3312 1be0 00C08DE5 		str	ip, [sp]
 3313 1be4 20209DE5 		ldr	r2, [sp, #32]
 3314 1be8 0B30A0E1 		mov	r3, fp
 3315 1bec 0B10A0E3 		mov	r1, #11
 3316 1bf0 0400A0E1 		mov	r0, r4
 3317 1bf4 04808DE5 		str	r8, [sp, #4]
 3318 1bf8 FEFFFFEB 		bl	cmdSet
 3319              	.LVL353:
2187:../uvc.c      **** 
 3320              		.loc 1 2187 0
 3321 1bfc 1C0094E5 		ldr	r0, [r4, #28]
 3322 1c00 FEFFFFEB 		bl	_txe_mutex_put
 3323              	.LVL354:
2189:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3324              		.loc 1 2189 0
 3325 1c04 80379FE5 		ldr	r3, .L440+72
 3326 1c08 24C09DE5 		ldr	ip, [sp, #36]
2191:../uvc.c      **** 							 break;
 3327              		.loc 1 2191 0
 3328 1c0c 055187E0 		add	r5, r7, r5, asl #2
 3329 1c10 202195E5 		ldr	r2, [r5, #288]
2189:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3330              		.loc 1 2189 0
 3331 1c14 84C5C3E5 		strb	ip, [r3, #1412]
2190:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3332              		.loc 1 2190 0
 3333 1c18 28C09DE5 		ldr	ip, [sp, #40]
2192:../uvc.c      **** 						 case BLCCtlID0:
 3334              		.loc 1 2192 0
 3335 1c1c FF70A0E3 		mov	r7, #255
2191:../uvc.c      **** 							 break;
 3336              		.loc 1 2191 0
 3337 1c20 1180C2E5 		strb	r8, [r2, #17]
2190:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3338              		.loc 1 2190 0
 3339 1c24 86C5C3E5 		strb	ip, [r3, #1414]
2192:../uvc.c      **** 						 case BLCCtlID0:
 3340              		.loc 1 2192 0
 3341 1c28 0750A0E1 		mov	r5, r7
 3342 1c2c 65FEFFEA 		b	.L284
 3343              	.LVL355:
 3344              	.L369:
2215:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3345              		.loc 1 2215 0
 3346 1c30 24209DE5 		ldr	r2, [sp, #36]
2214:../uvc.c      **** 							 if(Data0 != 0){
 3347              		.loc 1 2214 0
 3348 1c34 055187E0 		add	r5, r7, r5, asl #2
 3349 1c38 205195E5 		ldr	r5, [r5, #288]
2216:../uvc.c      **** 	#ifdef COLOR
 3350              		.loc 1 2216 0
 3351 1c3c 44479FE5 		ldr	r4, .L440+68
2215:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3352              		.loc 1 2215 0
 3353 1c40 000052E3 		cmp	r2, #0
2214:../uvc.c      **** 							 if(Data0 != 0){
 3354              		.loc 1 2214 0
 3355 1c44 0D20C5E5 		strb	r2, [r5, #13]
2216:../uvc.c      **** 	#ifdef COLOR
 3356              		.loc 1 2216 0
 3357 1c48 0010E0E3 		mvn	r1, #0
 3358 1c4c 1C0094E5 		ldr	r0, [r4, #28]
 3359 1c50 18C08DE5 		str	ip, [sp, #24]
2215:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3360              		.loc 1 2215 0
 3361 1c54 A902000A 		beq	.L387
2216:../uvc.c      **** 	#ifdef COLOR
 3362              		.loc 1 2216 0
 3363 1c58 FEFFFFEB 		bl	_txe_mutex_get
 3364              	.LVL356:
2220:../uvc.c      **** 								 dataIdx++;
 3365              		.loc 1 2220 0
 3366 1c5c 18C09DE5 		ldr	ip, [sp, #24]
 3367 1c60 0170A0E3 		mov	r7, #1
 3368 1c64 0030A0E3 		mov	r3, #0
 3369 1c68 0C20A0E1 		mov	r2, ip
 3370 1c6c 04308DE5 		str	r3, [sp, #4]
 3371 1c70 0400A0E1 		mov	r0, r4
 3372 1c74 00708DE5 		str	r7, [sp]
 3373 1c78 0710A0E3 		mov	r1, #7
 3374 1c7c 0B30A0E1 		mov	r3, fp
 3375 1c80 FEFFFFEB 		bl	cmdSet
 3376              	.LVL357:
2222:../uvc.c      **** 	#endif
 3377              		.loc 1 2222 0
 3378 1c84 24C09DE5 		ldr	ip, [sp, #36]
 3379 1c88 20209DE5 		ldr	r2, [sp, #32]
 3380 1c8c 04708DE5 		str	r7, [sp, #4]
 3381 1c90 00C08DE5 		str	ip, [sp]
 3382              	.LVL358:
 3383              	.L415:
2227:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3384              		.loc 1 2227 0
 3385 1c94 0B30A0E1 		mov	r3, fp
 3386 1c98 0400A0E1 		mov	r0, r4
 3387 1c9c 0710A0E3 		mov	r1, #7
 3388 1ca0 FEFFFFEB 		bl	cmdSet
 3389              	.LVL359:
2228:../uvc.c      **** 							 }
 3390              		.loc 1 2228 0
 3391 1ca4 1C0094E5 		ldr	r0, [r4, #28]
 3392 1ca8 FEFFFFEB 		bl	_txe_mutex_put
 3393              	.LVL360:
 3394              	.L418:
2230:../uvc.c      **** 							 break;
 3395              		.loc 1 2230 0
 3396 1cac 0130A0E3 		mov	r3, #1
2231:../uvc.c      **** 						 case ConsCtlID2:
 3397              		.loc 1 2231 0
 3398 1cb0 FF70A0E3 		mov	r7, #255
2230:../uvc.c      **** 							 break;
 3399              		.loc 1 2230 0
 3400 1cb4 1130C5E5 		strb	r3, [r5, #17]
 3401              	.LVL361:
2231:../uvc.c      **** 						 case ConsCtlID2:
 3402              		.loc 1 2231 0
 3403 1cb8 0750A0E1 		mov	r5, r7
 3404 1cbc 41FEFFEA 		b	.L284
 3405              	.LVL362:
 3406              	.L368:
2118:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 3407              		.loc 1 2118 0
 3408 1cc0 C0869FE5 		ldr	r8, .L440+68
 3409              	.LVL363:
 3410 1cc4 0010E0E3 		mvn	r1, #0
 3411 1cc8 1C0098E5 		ldr	r0, [r8, #28]
 3412 1ccc 18C08DE5 		str	ip, [sp, #24]
 3413 1cd0 FEFFFFEB 		bl	_txe_mutex_get
 3414              	.LVL364:
2119:../uvc.c      **** 							 dataIdx++;
 3415              		.loc 1 2119 0
 3416 1cd4 24009DE5 		ldr	r0, [sp, #36]
 3417 1cd8 18C09DE5 		ldr	ip, [sp, #24]
 3418 1cdc 801040E2 		sub	r1, r0, #128
 3419 1ce0 FF1001E2 		and	r1, r1, #255
 3420 1ce4 0030A0E3 		mov	r3, #0
 3421 1ce8 0C20A0E1 		mov	r2, ip
 3422 1cec 00108DE5 		str	r1, [sp]
 3423 1cf0 04308DE5 		str	r3, [sp, #4]
 3424 1cf4 0510A0E3 		mov	r1, #5
 3425 1cf8 0B30A0E1 		mov	r3, fp
 3426 1cfc 0800A0E1 		mov	r0, r8
 3427 1d00 FEFFFFEB 		bl	cmdSet
 3428              	.LVL365:
2121:../uvc.c      **** 							 dataIdx++;
 3429              		.loc 1 2121 0
 3430 1d04 24C09DE5 		ldr	ip, [sp, #36]
 3431 1d08 0510A0E3 		mov	r1, #5
 3432 1d0c 76304CE2 		sub	r3, ip, #118
 3433 1d10 FF3003E2 		and	r3, r3, #255
 3434 1d14 01C0A0E3 		mov	ip, #1
 3435 1d18 04C08DE5 		str	ip, [sp, #4]
 3436 1d1c 00308DE5 		str	r3, [sp]
 3437 1d20 DC20A0E3 		mov	r2, #220
 3438 1d24 0B30A0E1 		mov	r3, fp
 3439 1d28 0800A0E1 		mov	r0, r8
 3440 1d2c 18C08DE5 		str	ip, [sp, #24]
 3441 1d30 FEFFFFEB 		bl	cmdSet
 3442              	.LVL366:
2123:../uvc.c      **** 							 dataIdx++;
 3443              		.loc 1 2123 0
 3444 1d34 24009DE5 		ldr	r0, [sp, #36]
 3445 1d38 0230A0E3 		mov	r3, #2
 3446 1d3c 7E2080E2 		add	r2, r0, #126
 3447 1d40 FF2002E2 		and	r2, r2, #255
 3448 1d44 00208DE5 		str	r2, [sp]
 3449 1d48 04308DE5 		str	r3, [sp, #4]
 3450 1d4c 0510A0E3 		mov	r1, #5
 3451 1d50 DE20A0E3 		mov	r2, #222
 3452 1d54 0B30A0E1 		mov	r3, fp
 3453 1d58 0800A0E1 		mov	r0, r8
 3454 1d5c FEFFFFEB 		bl	cmdSet
 3455              	.LVL367:
2125:../uvc.c      **** 							 dataIdx++;
 3456              		.loc 1 2125 0
 3457 1d60 24109DE5 		ldr	r1, [sp, #36]
 3458 1d64 0330A0E3 		mov	r3, #3
 3459 1d68 722081E2 		add	r2, r1, #114
 3460 1d6c FF2002E2 		and	r2, r2, #255
 3461 1d70 00208DE5 		str	r2, [sp]
 3462 1d74 04308DE5 		str	r3, [sp, #4]
 3463 1d78 0510A0E3 		mov	r1, #5
 3464 1d7c E020A0E3 		mov	r2, #224
 3465 1d80 0B30A0E1 		mov	r3, fp
 3466 1d84 0800A0E1 		mov	r0, r8
 3467 1d88 FEFFFFEB 		bl	cmdSet
 3468              	.LVL368:
2127:../uvc.c      **** 							 dataIdx++;
 3469              		.loc 1 2127 0
 3470 1d8c 24309DE5 		ldr	r3, [sp, #36]
 3471 1d90 0510A0E3 		mov	r1, #5
 3472 1d94 6F2043E2 		sub	r2, r3, #111
 3473 1d98 FF2002E2 		and	r2, r2, #255
 3474 1d9c 0430A0E3 		mov	r3, #4
 3475 1da0 00208DE5 		str	r2, [sp]
 3476 1da4 04308DE5 		str	r3, [sp, #4]
 3477 1da8 DD20A0E3 		mov	r2, #221
 3478 1dac 0B30A0E1 		mov	r3, fp
 3479 1db0 0800A0E1 		mov	r0, r8
 3480 1db4 FEFFFFEB 		bl	cmdSet
 3481              	.LVL369:
2129:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3482              		.loc 1 2129 0
 3483 1db8 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
 3484 1dbc 0510A0E3 		mov	r1, #5
 3485 1dc0 7F0080E2 		add	r0, r0, #127
 3486 1dc4 FF0000E2 		and	r0, r0, #255
 3487 1dc8 20209DE5 		ldr	r2, [sp, #32]
 3488 1dcc 0B30A0E1 		mov	r3, fp
 3489 1dd0 00008DE5 		str	r0, [sp]
 3490 1dd4 04108DE5 		str	r1, [sp, #4]
 3491 1dd8 0800A0E1 		mov	r0, r8
 3492 1ddc FEFFFFEB 		bl	cmdSet
 3493              	.LVL370:
2130:../uvc.c      **** 
 3494              		.loc 1 2130 0
 3495 1de0 1C0098E5 		ldr	r0, [r8, #28]
 3496 1de4 FEFFFFEB 		bl	_txe_mutex_put
 3497              	.LVL371:
2132:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3498              		.loc 1 2132 0
 3499 1de8 2820D4E5 		ldrb	r2, [r4, #40]	@ zero_extendqisi2
 3500 1dec 055187E0 		add	r5, r7, r5, asl #2
 3501 1df0 203195E5 		ldr	r3, [r5, #288]
 3502 1df4 802042E2 		sub	r2, r2, #128
 3503 1df8 FF2002E2 		and	r2, r2, #255
 3504 1dfc 0D20C3E5 		strb	r2, [r3, #13]
2133:../uvc.c      **** 							 break;
 3505              		.loc 1 2133 0
 3506 1e00 18C09DE5 		ldr	ip, [sp, #24]
2134:../uvc.c      **** 						 case MFreqCtlID4:
 3507              		.loc 1 2134 0
 3508 1e04 FF70A0E3 		mov	r7, #255
 3509 1e08 0750A0E1 		mov	r5, r7
2133:../uvc.c      **** 							 break;
 3510              		.loc 1 2133 0
 3511 1e0c 11C0C3E5 		strb	ip, [r3, #17]
2134:../uvc.c      **** 						 case MFreqCtlID4:
 3512              		.loc 1 2134 0
 3513 1e10 ECFDFFEA 		b	.L284
 3514              	.LVL372:
 3515              	.L367:
2139:../uvc.c      **** 							 {
 3516              		.loc 1 2139 0
 3517 1e14 24C09DE5 		ldr	ip, [sp, #36]
2136:../uvc.c      **** 							 //Data0 = Data0 - 1;
 3518              		.loc 1 2136 0
 3519 1e18 055187E0 		add	r5, r7, r5, asl #2
 3520 1e1c 205195E5 		ldr	r5, [r5, #288]
2139:../uvc.c      **** 							 {
 3521              		.loc 1 2139 0
 3522 1e20 00005CE3 		cmp	ip, #0
2142:../uvc.c      **** 							 }
 3523              		.loc 1 2142 0
 3524 1e24 0130A003 		moveq	r3, #1
2147:../uvc.c      **** 							 }
 3525              		.loc 1 2147 0
 3526 1e28 0030A013 		movne	r3, #0
 3527 1e2c 0C90A001 		moveq	r9, ip
 3528 1e30 0190A013 		movne	r9, #1
2136:../uvc.c      **** 							 //Data0 = Data0 - 1;
 3529              		.loc 1 2136 0
 3530 1e34 0DC0C5E5 		strb	ip, [r5, #13]
 3531              	.LVL373:
2149:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3532              		.loc 1 2149 0
 3533 1e38 0920A0E1 		mov	r2, r9
2147:../uvc.c      **** 							 }
 3534              		.loc 1 2147 0
 3535 1e3c 6C3084E5 		str	r3, [r4, #108]
 3536              	.LVL374:
2149:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3537              		.loc 1 2149 0
 3538 1e40 0400A0E3 		mov	r0, #4
 3539 1e44 6C3094E5 		ldr	r3, [r4, #108]
 3540 1e48 14159FE5 		ldr	r1, .L440+32
 3541 1e4c FEFFFFEB 		bl	CyU3PDebugPrint
 3542              	.LVL375:
2150:../uvc.c      **** 							 {
 3543              		.loc 1 2150 0
 3544 1e50 883094E5 		ldr	r3, [r4, #136]
2149:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3545              		.loc 1 2149 0
 3546 1e54 34259FE5 		ldr	r2, .L440+76
2150:../uvc.c      **** 							 {
 3547              		.loc 1 2150 0
 3548 1e58 010053E3 		cmp	r3, #1
 3549 1e5c 92FFFF1A 		bne	.L418
2152:../uvc.c      **** 			                         {
 3550              		.loc 1 2152 0
 3551 1e60 7030D2E5 		ldrb	r3, [r2, #112]	@ zero_extendqisi2
 3552 1e64 013043E2 		sub	r3, r3, #1
 3553 1e68 030053E3 		cmp	r3, #3
 3554 1e6c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 3555 1e70 8DFFFFEA 		b	.L418
 3556              	.L375:
 3557 1e74 AC250000 		.word	.L374
 3558 1e78 60250000 		.word	.L376
 3559 1e7c 00250000 		.word	.L377
 3560 1e80 A0240000 		.word	.L378
 3561              	.LVL376:
 3562              	.L366:
2102:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
 3563              		.loc 1 2102 0
 3564 1e84 FC449FE5 		ldr	r4, .L440+68
 3565 1e88 0010E0E3 		mvn	r1, #0
 3566 1e8c 1C0094E5 		ldr	r0, [r4, #28]
 3567 1e90 FEFFFFEB 		bl	_txe_mutex_get
 3568              	.LVL377:
2111:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3569              		.loc 1 2111 0
 3570 1e94 24C09DE5 		ldr	ip, [sp, #36]
 3571 1e98 0010A0E3 		mov	r1, #0
 3572 1e9c 00C08DE5 		str	ip, [sp]
 3573 1ea0 20209DE5 		ldr	r2, [sp, #32]
 3574 1ea4 0B30A0E1 		mov	r3, fp
 3575 1ea8 04108DE5 		str	r1, [sp, #4]
 3576 1eac 0400A0E1 		mov	r0, r4
 3577 1eb0 0110A0E3 		mov	r1, #1
 3578 1eb4 FEFFFFEB 		bl	cmdSet
 3579              	.LVL378:
2114:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3580              		.loc 1 2114 0
 3581 1eb8 055187E0 		add	r5, r7, r5, asl #2
2112:../uvc.c      **** 
 3582              		.loc 1 2112 0
 3583 1ebc 1C0094E5 		ldr	r0, [r4, #28]
 3584 1ec0 FEFFFFEB 		bl	_txe_mutex_put
 3585              	.LVL379:
2114:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3586              		.loc 1 2114 0
 3587 1ec4 203195E5 		ldr	r3, [r5, #288]
 3588 1ec8 24C09DE5 		ldr	ip, [sp, #36]
2115:../uvc.c      **** 							 break;
 3589              		.loc 1 2115 0
 3590 1ecc 0120A0E3 		mov	r2, #1
2116:../uvc.c      **** 						 case HueCtlID5://not being used
 3591              		.loc 1 2116 0
 3592 1ed0 FF70A0E3 		mov	r7, #255
2114:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3593              		.loc 1 2114 0
 3594 1ed4 0DC0C3E5 		strb	ip, [r3, #13]
2116:../uvc.c      **** 						 case HueCtlID5://not being used
 3595              		.loc 1 2116 0
 3596 1ed8 0750A0E1 		mov	r5, r7
2115:../uvc.c      **** 							 break;
 3597              		.loc 1 2115 0
 3598 1edc 1120C3E5 		strb	r2, [r3, #17]
 3599              	.LVL380:
2116:../uvc.c      **** 						 case HueCtlID5://not being used
 3600              		.loc 1 2116 0
 3601 1ee0 B8FDFFEA 		b	.L284
 3602              	.LVL381:
 3603              	.L364:
2194:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3604              		.loc 1 2194 0
 3605 1ee4 055187E0 		add	r5, r7, r5, asl #2
2204:../uvc.c      **** 					 		 }
 3606              		.loc 1 2204 0
 3607 1ee8 9C349FE5 		ldr	r3, .L440+72
2194:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3608              		.loc 1 2194 0
 3609 1eec 24009DE5 		ldr	r0, [sp, #36]
 3610 1ef0 205195E5 		ldr	r5, [r5, #288]
2204:../uvc.c      **** 					 		 }
 3611              		.loc 1 2204 0
 3612 1ef4 24109DE5 		ldr	r1, [sp, #36]
2194:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3613              		.loc 1 2194 0
 3614 1ef8 0D00C5E5 		strb	r0, [r5, #13]
2207:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3615              		.loc 1 2207 0
 3616 1efc 84449FE5 		ldr	r4, .L440+68
2204:../uvc.c      **** 					 		 }
 3617              		.loc 1 2204 0
 3618 1f00 0595D3E5 		ldrb	r9, [r3, #1285]	@ zero_extendqisi2
2207:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3619              		.loc 1 2207 0
 3620 1f04 1C0094E5 		ldr	r0, [r4, #28]
2204:../uvc.c      **** 					 		 }
 3621              		.loc 1 2204 0
 3622 1f08 899381E1 		orr	r9, r1, r9, asl #7
2207:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3623              		.loc 1 2207 0
 3624 1f0c 0010E0E3 		mvn	r1, #0
 3625 1f10 18C08DE5 		str	ip, [sp, #24]
 3626 1f14 FEFFFFEB 		bl	_txe_mutex_get
 3627              	.LVL382:
2208:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3628              		.loc 1 2208 0
 3629 1f18 18C09DE5 		ldr	ip, [sp, #24]
2204:../uvc.c      **** 					 		 }
 3630              		.loc 1 2204 0
 3631 1f1c FF9009E2 		and	r9, r9, #255
 3632              	.LVL383:
2208:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3633              		.loc 1 2208 0
 3634 1f20 0010A0E3 		mov	r1, #0
 3635 1f24 0C20A0E1 		mov	r2, ip
 3636 1f28 0B30A0E1 		mov	r3, fp
 3637 1f2c 0400A0E1 		mov	r0, r4
 3638 1f30 00908DE5 		str	r9, [sp]
 3639 1f34 04108DE5 		str	r1, [sp, #4]
 3640              	.LVL384:
 3641              	.L416:
 3642 1f38 FEFFFFEB 		bl	cmdSet
 3643              	.LVL385:
2209:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3644              		.loc 1 2209 0
 3645 1f3c 1C0094E5 		ldr	r0, [r4, #28]
 3646 1f40 FEFFFFEB 		bl	_txe_mutex_put
 3647              	.LVL386:
2211:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
 3648              		.loc 1 2211 0
 3649 1f44 FF70A0E3 		mov	r7, #255
2210:../uvc.c      **** 					 		 break;
 3650              		.loc 1 2210 0
 3651 1f48 0130A0E3 		mov	r3, #1
 3652 1f4c 1130C5E5 		strb	r3, [r5, #17]
 3653              	.LVL387:
2211:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
 3654              		.loc 1 2211 0
 3655 1f50 0750A0E1 		mov	r5, r7
 3656 1f54 9BFDFFEA 		b	.L284
 3657              	.LVL388:
 3658              	.L304:
1636:../uvc.c      **** 			 	 			 if(Len == 2)
 3659              		.loc 1 1636 0
 3660 1f58 007087E0 		add	r7, r7, r0
 3661 1f5c 6031D7E5 		ldrb	r3, [r7, #352]	@ zero_extendqisi2
 3662 1f60 DC439FE5 		ldr	r4, .L440
 3663 1f64 000053E3 		cmp	r3, #0
 3664 1f68 AA01000A 		beq	.L313
1637:../uvc.c      **** 			 	 			 {
 3665              		.loc 1 1637 0
 3666 1f6c 020058E3 		cmp	r8, #2
 3667 1f70 3A02000A 		beq	.L433
1643:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 3668              		.loc 1 1643 0
 3669 1f74 040058E3 		cmp	r8, #4
 3670 1f78 72FEFF1A 		bne	.L303
1644:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 3671              		.loc 1 1644 0
 3672 1f7c 004184E0 		add	r4, r4, r0, asl #2
 3673 1f80 202194E5 		ldr	r2, [r4, #288]
 3674              	.L411:
 3675 1f84 0D50D2E5 		ldrb	r5, [r2, #13]	@ zero_extendqisi2
 3676 1f88 00449FE5 		ldr	r4, .L440+76
1645:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3677              		.loc 1 1645 0
 3678 1f8c 0030A0E3 		mov	r3, #0
1644:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 3679              		.loc 1 1644 0
 3680 1f90 FF5005E2 		and	r5, r5, #255
 3681 1f94 2850C4E5 		strb	r5, [r4, #40]
1645:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3682              		.loc 1 1645 0
 3683 1f98 2930C4E5 		strb	r3, [r4, #41]
1646:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 3684              		.loc 1 1646 0
 3685 1f9c 0E70D2E5 		ldrb	r7, [r2, #14]	@ zero_extendqisi2
 3686 1fa0 0390A0E1 		mov	r9, r3
 3687 1fa4 FF7007E2 		and	r7, r7, #255
 3688 1fa8 2A70C4E5 		strb	r7, [r4, #42]
1647:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 3689              		.loc 1 1647 0
 3690 1fac 2B30C4E5 		strb	r3, [r4, #43]
 3691              	.LVL389:
 3692 1fb0 03A0A0E1 		mov	r10, r3
 3693 1fb4 55FEFFEA 		b	.L294
 3694              	.LVL390:
 3695              	.L395:
1843:../uvc.c      **** 					 {
 3696              		.loc 1 1843 0
 3697 1fb8 FF70A0E3 		mov	r7, #255
 3698 1fbc 0750A0E1 		mov	r5, r7
 3699 1fc0 80FDFFEA 		b	.L284
 3700              	.L344:
1875:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 3701              		.loc 1 1875 0
 3702 1fc4 BC539FE5 		ldr	r5, .L440+68
 3703 1fc8 0010E0E3 		mvn	r1, #0
 3704 1fcc 1C0095E5 		ldr	r0, [r5, #28]
 3705 1fd0 18C08DE5 		str	ip, [sp, #24]
 3706 1fd4 FEFFFFEB 		bl	_txe_mutex_get
 3707              	.LVL391:
1876:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3708              		.loc 1 1876 0
 3709 1fd8 18C09DE5 		ldr	ip, [sp, #24]
 3710 1fdc 24009DE5 		ldr	r0, [sp, #36]
 3711 1fe0 0080A0E3 		mov	r8, #0
 3712              	.LVL392:
 3713 1fe4 0C20A0E1 		mov	r2, ip
 3714 1fe8 0B30A0E1 		mov	r3, fp
 3715 1fec 00008DE5 		str	r0, [sp]
 3716 1ff0 1E10A0E3 		mov	r1, #30
 3717 1ff4 0500A0E1 		mov	r0, r5
 3718 1ff8 04808DE5 		str	r8, [sp, #4]
 3719 1ffc FEFFFFEB 		bl	cmdSet
 3720              	.LVL393:
1878:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 3721              		.loc 1 1878 0
 3722 2000 044187E0 		add	r4, r7, r4, asl #2
1877:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 3723              		.loc 1 1877 0
 3724 2004 1C0095E5 		ldr	r0, [r5, #28]
 3725 2008 FEFFFFEB 		bl	_txe_mutex_put
 3726              	.LVL394:
1878:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 3727              		.loc 1 1878 0
 3728 200c 203094E5 		ldr	r3, [r4, #32]
 3729 2010 24C09DE5 		ldr	ip, [sp, #36]
1880:../uvc.c      **** 							 break;
 3730              		.loc 1 1880 0
 3731 2014 0120A0E3 		mov	r2, #1
1881:../uvc.c      **** 					 	 case ExtI2CCtlID15:
 3732              		.loc 1 1881 0
 3733 2018 FF70A0E3 		mov	r7, #255
1878:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 3734              		.loc 1 1878 0
 3735 201c 0DC0C3E5 		strb	ip, [r3, #13]
1881:../uvc.c      **** 					 	 case ExtI2CCtlID15:
 3736              		.loc 1 1881 0
 3737 2020 0750A0E1 		mov	r5, r7
1879:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
 3738              		.loc 1 1879 0
 3739 2024 0E80C3E5 		strb	r8, [r3, #14]
1880:../uvc.c      **** 							 break;
 3740              		.loc 1 1880 0
 3741 2028 1120C3E5 		strb	r2, [r3, #17]
 3742              	.LVL395:
1881:../uvc.c      **** 					 	 case ExtI2CCtlID15:
 3743              		.loc 1 1881 0
 3744 202c 65FDFFEA 		b	.L284
 3745              	.LVL396:
 3746              	.L348:
2021:../uvc.c      **** 								 Data1 = SensorGetControl(RegAdd0, devAdd); //get the origin data as the fine shutter enabl
 3747              		.loc 1 2021 0
 3748 2030 044187E0 		add	r4, r7, r4, asl #2
 3749 2034 207094E5 		ldr	r7, [r4, #32]
 3750 2038 24009DE5 		ldr	r0, [sp, #36]
 3751 203c 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 3752 2040 000053E1 		cmp	r3, r0
 3753 2044 2100000A 		beq	.L357
2022:../uvc.c      **** 								 Data1 &= 0x0F; Data0 = (Data0&0x0F) << 4;
 3754              		.loc 1 2022 0
 3755 2048 0C00A0E1 		mov	r0, ip
 3756 204c 0B10A0E1 		mov	r1, fp
 3757 2050 18C08DE5 		str	ip, [sp, #24]
 3758 2054 FEFFFFEB 		bl	SensorGetControl
 3759              	.LVL397:
2023:../uvc.c      **** 								 Data0 |= Data1;
 3760              		.loc 1 2023 0
 3761 2058 24109DE5 		ldr	r1, [sp, #36]
2026:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 3762              		.loc 1 2026 0
 3763 205c 24439FE5 		ldr	r4, .L440+68
2023:../uvc.c      **** 								 Data0 |= Data1;
 3764              		.loc 1 2023 0
 3765 2060 0132A0E1 		mov	r3, r1, asl #4
 3766 2064 FF3003E2 		and	r3, r3, #255
2026:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 3767              		.loc 1 2026 0
 3768 2068 0010E0E3 		mvn	r1, #0
2027:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3769              		.loc 1 2027 0
 3770 206c 0090A0E3 		mov	r9, #0
2023:../uvc.c      **** 								 Data0 |= Data1;
 3771              		.loc 1 2023 0
 3772 2070 0F0000E2 		and	r0, r0, #15
 3773              	.LVL398:
2024:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]. Saving the v
 3774              		.loc 1 2024 0
 3775 2074 033080E1 		orr	r3, r0, r3
2025:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3776              		.loc 1 2025 0
 3777 2078 0D30C7E5 		strb	r3, [r7, #13]
2023:../uvc.c      **** 								 Data0 |= Data1;
 3778              		.loc 1 2023 0
 3779 207c 28008DE5 		str	r0, [sp, #40]
 3780              	.LVL399:
2026:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 3781              		.loc 1 2026 0
 3782 2080 1C0094E5 		ldr	r0, [r4, #28]
2024:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]. Saving the v
 3783              		.loc 1 2024 0
 3784 2084 24308DE5 		str	r3, [sp, #36]
 3785              	.LVL400:
2026:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 3786              		.loc 1 2026 0
 3787 2088 FEFFFFEB 		bl	_txe_mutex_get
 3788              	.LVL401:
2027:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3789              		.loc 1 2027 0
 3790 208c 18C09DE5 		ldr	ip, [sp, #24]
 3791 2090 24209DE5 		ldr	r2, [sp, #36]
 3792 2094 2810A0E3 		mov	r1, #40
 3793 2098 0B30A0E1 		mov	r3, fp
 3794 209c 00208DE5 		str	r2, [sp]
 3795 20a0 04908DE5 		str	r9, [sp, #4]
 3796 20a4 0C20A0E1 		mov	r2, ip
 3797 20a8 0400A0E1 		mov	r0, r4
 3798 20ac FEFFFFEB 		bl	cmdSet
 3799              	.LVL402:
2028:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 3800              		.loc 1 2028 0
 3801 20b0 1C0094E5 		ldr	r0, [r4, #28]
 3802 20b4 FEFFFFEB 		bl	_txe_mutex_put
 3803              	.LVL403:
2029:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3804              		.loc 1 2029 0
 3805 20b8 0E90C7E5 		strb	r9, [r7, #14]
2030:../uvc.c      **** 							 }
 3806              		.loc 1 2030 0
 3807 20bc 1C0094E5 		ldr	r0, [r4, #28]
 3808 20c0 FEFFFFEB 		bl	_txe_mutex_put
 3809              	.LVL404:
 3810 20c4 24909DE5 		ldr	r9, [sp, #36]
 3811 20c8 28A09DE5 		ldr	r10, [sp, #40]
 3812 20cc 18C09DE5 		ldr	ip, [sp, #24]
 3813              	.L357:
2032:../uvc.c      **** 
 3814              		.loc 1 2032 0
 3815 20d0 0130A0E3 		mov	r3, #1
 3816 20d4 1130C7E5 		strb	r3, [r7, #17]
 3817              	.L349:
2045:../uvc.c      **** 				 	 			 {
 3818              		.loc 1 2045 0
 3819 20d8 020058E3 		cmp	r8, #2
 3820 20dc 8E01000A 		beq	.L434
2055:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 3821              		.loc 1 2055 0
 3822 20e0 040058E3 		cmp	r8, #4
 3823 20e4 B601000A 		beq	.L435
 3824              	.LVL405:
 3825              	.L391:
2263:../uvc.c      **** 			 	 			 break;
 3826              		.loc 1 2263 0
 3827 20e8 0E00D7E5 		ldrb	r0, [r7, #14]	@ zero_extendqisi2
 3828 20ec 0D10D7E5 		ldrb	r1, [r7, #13]	@ zero_extendqisi2
2262:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
 3829              		.loc 1 2262 0
 3830 20f0 24209DE5 		ldr	r2, [sp, #36]
 3831 20f4 03018DE8 		stmia	sp, {r0, r1, r8}
 3832 20f8 28309DE5 		ldr	r3, [sp, #40]
 3833 20fc 0400A0E3 		mov	r0, #4
 3834 2100 60129FE5 		ldr	r1, .L440+36
 3835 2104 FEFFFFEB 		bl	CyU3PDebugPrint
 3836              	.LVL406:
2264:../uvc.c      **** 					 }
 3837              		.loc 1 2264 0
 3838 2108 FF70A0E3 		mov	r7, #255
 3839 210c 0750A0E1 		mov	r5, r7
 3840 2110 2CFDFFEA 		b	.L284
 3841              	.LVL407:
 3842              	.L347:
1846:../uvc.c      **** 							 if(Data0 == 1){
 3843              		.loc 1 1846 0
 3844 2114 044187E0 		add	r4, r7, r4, asl #2
1847:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3845              		.loc 1 1847 0
 3846 2118 24309DE5 		ldr	r3, [sp, #36]
1846:../uvc.c      **** 							 if(Data0 == 1){
 3847              		.loc 1 1846 0
 3848 211c 205094E5 		ldr	r5, [r4, #32]
1847:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3849              		.loc 1 1847 0
 3850 2120 010053E3 		cmp	r3, #1
1846:../uvc.c      **** 							 if(Data0 == 1){
 3851              		.loc 1 1846 0
 3852 2124 0D30C5E5 		strb	r3, [r5, #13]
1848:../uvc.c      **** 							 }else{
 3853              		.loc 1 1848 0
 3854 2128 5C329FE5 		ldr	r3, .L440+72
1852:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3855              		.loc 1 1852 0
 3856 212c 54429FE5 		ldr	r4, .L440+68
1848:../uvc.c      **** 							 }else{
 3857              		.loc 1 1848 0
 3858 2130 A995D3E5 		ldrb	r9, [r3, #1449]	@ zero_extendqisi2
1852:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3859              		.loc 1 1852 0
 3860 2134 0010E0E3 		mvn	r1, #0
 3861 2138 1C0094E5 		ldr	r0, [r4, #28]
1848:../uvc.c      **** 							 }else{
 3862              		.loc 1 1848 0
 3863 213c 80908903 		orreq	r9, r9, #128
 3864              	.LVL408:
1850:../uvc.c      **** 							 }
 3865              		.loc 1 1850 0
 3866 2140 7F900912 		andne	r9, r9, #127
 3867              	.LVL409:
1852:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3868              		.loc 1 1852 0
 3869 2144 18C08DE5 		str	ip, [sp, #24]
 3870 2148 FEFFFFEB 		bl	_txe_mutex_get
 3871              	.LVL410:
1853:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3872              		.loc 1 1853 0
 3873 214c 18C09DE5 		ldr	ip, [sp, #24]
 3874 2150 0010A0E3 		mov	r1, #0
 3875 2154 04108DE5 		str	r1, [sp, #4]
 3876 2158 00908DE5 		str	r9, [sp]
 3877 215c 0C20A0E1 		mov	r2, ip
 3878 2160 0B30A0E1 		mov	r3, fp
 3879 2164 0400A0E1 		mov	r0, r4
 3880 2168 2610A0E3 		mov	r1, #38
 3881 216c 71FFFFEA 		b	.L416
 3882              	.LVL411:
 3883              	.L343:
1930:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){
 3884              		.loc 1 1930 0
 3885 2170 10C29FE5 		ldr	ip, .L440+68
 3886 2174 0010E0E3 		mvn	r1, #0
 3887 2178 1C009CE5 		ldr	r0, [ip, #28]
1931:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 3888              		.loc 1 1931 0
 3889 217c 044187E0 		add	r4, r7, r4, asl #2
1930:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){
 3890              		.loc 1 1930 0
 3891 2180 2CC08DE5 		str	ip, [sp, #44]
 3892 2184 FEFFFFEB 		bl	_txe_mutex_get
 3893              	.LVL412:
1931:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 3894              		.loc 1 1931 0
 3895 2188 203094E5 		ldr	r3, [r4, #32]
 3896 218c 24C09DE5 		ldr	ip, [sp, #36]
 3897 2190 0D20D3E5 		ldrb	r2, [r3, #13]	@ zero_extendqisi2
 3898 2194 0C0052E1 		cmp	r2, ip
 3899 2198 0800000A 		beq	.L356
1936:../uvc.c      **** 								 }
 3900              		.loc 1 1936 0
 3901 219c 0010A0E3 		mov	r1, #0
1932:../uvc.c      **** 								 if(1 || EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 3902              		.loc 1 1932 0
 3903 21a0 0DC0C3E5 		strb	ip, [r3, #13]
1936:../uvc.c      **** 								 }
 3904              		.loc 1 1936 0
 3905 21a4 20209DE5 		ldr	r2, [sp, #32]
 3906 21a8 04108DE5 		str	r1, [sp, #4]
 3907 21ac 00C08DE5 		str	ip, [sp]
 3908 21b0 0B30A0E1 		mov	r3, fp
 3909 21b4 2C009DE5 		ldr	r0, [sp, #44]
 3910 21b8 1B10A0E3 		mov	r1, #27
 3911 21bc FEFFFFEB 		bl	cmdSet
 3912              	.LVL413:
 3913              	.L356:
1940:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3914              		.loc 1 1940 0
 3915 21c0 2CC09DE5 		ldr	ip, [sp, #44]
1941:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3916              		.loc 1 1941 0
 3917 21c4 FF70A0E3 		mov	r7, #255
1940:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3918              		.loc 1 1940 0
 3919 21c8 1C009CE5 		ldr	r0, [ip, #28]
 3920 21cc FEFFFFEB 		bl	_txe_mutex_put
 3921              	.LVL414:
1942:../uvc.c      **** 							 break;
 3922              		.loc 1 1942 0
 3923 21d0 B4119FE5 		ldr	r1, .L440+72
1941:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3924              		.loc 1 1941 0
 3925 21d4 0400A0E3 		mov	r0, #4
1942:../uvc.c      **** 							 break;
 3926              		.loc 1 1942 0
 3927 21d8 1925D1E5 		ldrb	r2, [r1, #1305]	@ zero_extendqisi2
 3928 21dc 1A35D1E5 		ldrb	r3, [r1, #1306]	@ zero_extendqisi2
 3929 21e0 D115D1E5 		ldrb	r1, [r1, #1489]	@ zero_extendqisi2
1941:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3930              		.loc 1 1941 0
 3931 21e4 08708DE5 		str	r7, [sp, #8]
 3932 21e8 82008DE8 		stmia	sp, {r1, r7}
 3933 21ec 78119FE5 		ldr	r1, .L440+40
 3934 21f0 FEFFFFEB 		bl	CyU3PDebugPrint
 3935              	.LVL415:
1943:../uvc.c      **** 
 3936              		.loc 1 1943 0
 3937 21f4 0750A0E1 		mov	r5, r7
 3938 21f8 F2FCFFEA 		b	.L284
 3939              	.L342:
1889:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi != Data1){//if it's GC settings, the Ex Mode doesn
 3940              		.loc 1 1889 0
 3941 21fc 84019FE5 		ldr	r0, .L440+68
 3942 2200 0010E0E3 		mvn	r1, #0
 3943 2204 2C008DE5 		str	r0, [sp, #44]
1890:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 3944              		.loc 1 1890 0
 3945 2208 044187E0 		add	r4, r7, r4, asl #2
1889:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi != Data1){//if it's GC settings, the Ex Mode doesn
 3946              		.loc 1 1889 0
 3947 220c 1C0090E5 		ldr	r0, [r0, #28]
 3948 2210 18C08DE5 		str	ip, [sp, #24]
 3949 2214 FEFFFFEB 		bl	_txe_mutex_get
 3950              	.LVL416:
1890:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 3951              		.loc 1 1890 0
 3952 2218 204094E5 		ldr	r4, [r4, #32]
 3953 221c 28109DE5 		ldr	r1, [sp, #40]
 3954 2220 0E30D4E5 		ldrb	r3, [r4, #14]	@ zero_extendqisi2
 3955 2224 18C09DE5 		ldr	ip, [sp, #24]
 3956 2228 010053E1 		cmp	r3, r1
 3957 222c 9701000A 		beq	.L354
 3958 2230 01C0A0E1 		mov	ip, r1
1893:../uvc.c      **** 								 }
 3959              		.loc 1 1893 0
 3960 2234 0010A0E3 		mov	r1, #0
1891:../uvc.c      **** 								 if(1 || Data0 == 2 || Data0 == 3){
 3961              		.loc 1 1891 0
 3962 2238 0EC0C4E5 		strb	ip, [r4, #14]
1893:../uvc.c      **** 								 }
 3963              		.loc 1 1893 0
 3964 223c 20209DE5 		ldr	r2, [sp, #32]
 3965 2240 04108DE5 		str	r1, [sp, #4]
 3966 2244 00C08DE5 		str	ip, [sp]
 3967 2248 0B30A0E1 		mov	r3, fp
 3968 224c 2C009DE5 		ldr	r0, [sp, #44]
 3969 2250 1910A0E3 		mov	r1, #25
 3970 2254 FEFFFFEB 		bl	cmdSet
 3971              	.LVL417:
 3972              	.L355:
1906:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3973              		.loc 1 1906 0
 3974 2258 2CC09DE5 		ldr	ip, [sp, #44]
1905:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3975              		.loc 1 1905 0
 3976 225c 0130A0E3 		mov	r3, #1
 3977 2260 1130C4E5 		strb	r3, [r4, #17]
1906:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3978              		.loc 1 1906 0
 3979 2264 1C009CE5 		ldr	r0, [ip, #28]
 3980 2268 FEFFFFEB 		bl	_txe_mutex_put
 3981              	.LVL418:
1909:../uvc.c      **** 							 break;
 3982              		.loc 1 1909 0
 3983 226c 18119FE5 		ldr	r1, .L440+72
1908:../uvc.c      **** 									 EXTShutter.UVCCurVLo, Data0, Data1);
 3984              		.loc 1 1908 0
 3985 2270 0D20D4E5 		ldrb	r2, [r4, #13]	@ zero_extendqisi2
1907:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi,
 3986              		.loc 1 1907 0
 3987 2274 28C09DE5 		ldr	ip, [sp, #40]
1908:../uvc.c      **** 									 EXTShutter.UVCCurVLo, Data0, Data1);
 3988              		.loc 1 1908 0
 3989 2278 0E30D4E5 		ldrb	r3, [r4, #14]	@ zero_extendqisi2
1909:../uvc.c      **** 							 break;
 3990              		.loc 1 1909 0
 3991 227c BD15D1E5 		ldrb	r1, [r1, #1469]	@ zero_extendqisi2
1907:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi,
 3992              		.loc 1 1907 0
 3993 2280 0400A0E3 		mov	r0, #4
 3994 2284 00108DE5 		str	r1, [sp]
 3995 2288 04908DE5 		str	r9, [sp, #4]
 3996 228c 08C08DE5 		str	ip, [sp, #8]
 3997 2290 D8109FE5 		ldr	r1, .L440+44
 3998 2294 FEFFFFEB 		bl	CyU3PDebugPrint
 3999              	.LVL419:
1910:../uvc.c      **** 					 	 case ExtShutCtlID0: //special!!
 4000              		.loc 1 1910 0
 4001 2298 FF70A0E3 		mov	r7, #255
 4002 229c 0750A0E1 		mov	r5, r7
 4003 22a0 C8FCFFEA 		b	.L284
 4004              	.LVL420:
 4005              	.L340:
1915:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (Data1 & 0x8F);
 4006              		.loc 1 1915 0
 4007 22a4 0C00A0E1 		mov	r0, ip
 4008 22a8 0B10A0E1 		mov	r1, fp
 4009 22ac 18C08DE5 		str	ip, [sp, #24]
 4010 22b0 FEFFFFEB 		bl	SensorGetControl
 4011              	.LVL421:
1919:../uvc.c      **** 								 //cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 4012              		.loc 1 1919 0
 4013 22b4 CC509FE5 		ldr	r5, .L440+68
1917:../uvc.c      **** 						    	 dataIdx = 0;
 4014              		.loc 1 1917 0
 4015 22b8 044187E0 		add	r4, r7, r4, asl #2
 4016 22bc 204094E5 		ldr	r4, [r4, #32]
1919:../uvc.c      **** 								 //cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 4017              		.loc 1 1919 0
 4018 22c0 0010E0E3 		mvn	r1, #0
1917:../uvc.c      **** 						    	 dataIdx = 0;
 4019              		.loc 1 1917 0
 4020 22c4 0D30D4E5 		ldrb	r3, [r4, #13]	@ zero_extendqisi2
1928:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://Fine shutter level 2bytes standard operation!!!
 4021              		.loc 1 1928 0
 4022 22c8 FF70A0E3 		mov	r7, #255
1915:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (Data1 & 0x8F);
 4023              		.loc 1 1915 0
 4024 22cc 00A0A0E1 		mov	r10, r0
 4025              	.LVL422:
1916:../uvc.c      **** 						    	 if (pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 4026              		.loc 1 1916 0
 4027 22d0 7090C0E3 		bic	r9, r0, #112
 4028 22d4 24009DE5 		ldr	r0, [sp, #36]
 4029              	.LVL423:
 4030 22d8 009289E1 		orr	r9, r9, r0, asl #4
1919:../uvc.c      **** 								 //cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 4031              		.loc 1 1919 0
 4032 22dc 1C0095E5 		ldr	r0, [r5, #28]
 4033 22e0 FEFFFFEB 		bl	_txe_mutex_get
 4034              	.LVL424:
1922:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4035              		.loc 1 1922 0
 4036 22e4 18C09DE5 		ldr	ip, [sp, #24]
1916:../uvc.c      **** 						    	 if (pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 4037              		.loc 1 1916 0
 4038 22e8 FF9009E2 		and	r9, r9, #255
 4039              	.LVL425:
1922:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4040              		.loc 1 1922 0
 4041 22ec 0010A0E3 		mov	r1, #0
 4042 22f0 0C20A0E1 		mov	r2, ip
 4043 22f4 0B30A0E1 		mov	r3, fp
 4044 22f8 0500A0E1 		mov	r0, r5
 4045 22fc 04108DE5 		str	r1, [sp, #4]
 4046 2300 00908DE5 		str	r9, [sp]
 4047 2304 1010A0E3 		mov	r1, #16
 4048 2308 FEFFFFEB 		bl	cmdSet
 4049              	.LVL426:
1923:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0; //CtrlParArry[CtrlID][13] save new setting 
 4050              		.loc 1 1923 0
 4051 230c 1C0095E5 		ldr	r0, [r5, #28]
 4052 2310 FEFFFFEB 		bl	_txe_mutex_put
 4053              	.LVL427:
1927:../uvc.c      **** 						     break;
 4054              		.loc 1 1927 0
 4055 2314 70309FE5 		ldr	r3, .L440+72
1924:../uvc.c      **** 						     }
 4056              		.loc 1 1924 0
 4057 2318 0D90C4E5 		strb	r9, [r4, #13]
1927:../uvc.c      **** 						     break;
 4058              		.loc 1 1927 0
 4059 231c 1925D3E5 		ldrb	r2, [r3, #1305]	@ zero_extendqisi2
 4060 2320 BD35D3E5 		ldrb	r3, [r3, #1469]	@ zero_extendqisi2
1926:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 4061              		.loc 1 1926 0
 4062 2324 0400A0E3 		mov	r0, #4
 4063 2328 0C008DE8 		stmia	sp, {r2, r3}
 4064 232c 40109FE5 		ldr	r1, .L440+48
 4065 2330 0930A0E1 		mov	r3, r9
 4066 2334 0A20A0E1 		mov	r2, r10
 4067 2338 FEFFFFEB 		bl	CyU3PDebugPrint
 4068              	.LVL428:
1928:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://Fine shutter level 2bytes standard operation!!!
 4069              		.loc 1 1928 0
 4070 233c 0750A0E1 		mov	r5, r7
 4071 2340 A0FCFFEA 		b	.L284
 4072              	.L441:
 4073              		.align	2
 4074              	.L440:
 4075 2344 00000000 		.word	.LANCHOR2
 4076 2348 00000000 		.word	bRequest
 4077 234c 68040000 		.word	.LC27
 4078 2350 28000000 		.word	.LANCHOR0+40
 4079 2354 2C060000 		.word	.LC35
 4080 2358 38040000 		.word	.LC26
 4081 235c D4030000 		.word	.LC24
 4082 2360 FC030000 		.word	.LC25
 4083 2364 B8050000 		.word	.LC32
 4084 2368 64050000 		.word	.LC31
 4085 236c 2C050000 		.word	.LC30
 4086 2370 CC040000 		.word	.LC28
 4087 2374 00050000 		.word	.LC29
 4088 2378 94000000 		.word	.LANCHOR0+148
 4089 237c 00000000 		.word	.LANCHOR2
 4090 2380 D8050000 		.word	.LC33
 4091 2384 FC050000 		.word	.LC34
 4092 2388 00000000 		.word	cmdQu
 4093 238c 00000000 		.word	.LANCHOR1
 4094 2390 00000000 		.word	.LANCHOR0
 4095              	.LVL429:
 4096              	.L346:
2009:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 4097              		.loc 1 2009 0
 4098 2394 14401FE5 		ldr	r4, .L440+68
 4099 2398 0010E0E3 		mvn	r1, #0
 4100 239c 1C0094E5 		ldr	r0, [r4, #28]
 4101 23a0 18C08DE5 		str	ip, [sp, #24]
 4102 23a4 FEFFFFEB 		bl	_txe_mutex_get
 4103              	.LVL430:
2010:../uvc.c      **** 							 dataIdx++;
 4104              		.loc 1 2010 0
 4105 23a8 24009DE5 		ldr	r0, [sp, #36]
 4106 23ac 18C09DE5 		ldr	ip, [sp, #24]
 4107 23b0 0030A0E3 		mov	r3, #0
 4108 23b4 0C20A0E1 		mov	r2, ip
 4109 23b8 00008DE5 		str	r0, [sp]
 4110 23bc 04308DE5 		str	r3, [sp, #4]
 4111 23c0 2410A0E3 		mov	r1, #36
 4112 23c4 0B30A0E1 		mov	r3, fp
 4113 23c8 0400A0E1 		mov	r0, r4
 4114 23cc FEFFFFEB 		bl	cmdSet
 4115              	.LVL431:
2012:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4116              		.loc 1 2012 0
 4117 23d0 28C09DE5 		ldr	ip, [sp, #40]
 4118 23d4 0180A0E3 		mov	r8, #1
 4119              	.LVL432:
 4120 23d8 00C08DE5 		str	ip, [sp]
 4121 23dc 0B30A0E1 		mov	r3, fp
 4122 23e0 20209DE5 		ldr	r2, [sp, #32]
 4123 23e4 2410A0E3 		mov	r1, #36
 4124 23e8 0400A0E1 		mov	r0, r4
 4125 23ec 04808DE5 		str	r8, [sp, #4]
 4126 23f0 FEFFFFEB 		bl	cmdSet
 4127              	.LVL433:
2013:../uvc.c      **** 							 getData1 = Data1;
 4128              		.loc 1 2013 0
 4129 23f4 1C0094E5 		ldr	r0, [r4, #28]
 4130 23f8 FEFFFFEB 		bl	_txe_mutex_put
 4131              	.LVL434:
2016:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 4132              		.loc 1 2016 0
 4133 23fc 78301FE5 		ldr	r3, .L440+72
 4134 2400 24C09DE5 		ldr	ip, [sp, #36]
2019:../uvc.c      **** 				 	 	 case Ext1ExCtrlSpeedCtlID8:
 4135              		.loc 1 2019 0
 4136 2404 FF70A0E3 		mov	r7, #255
2016:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 4137              		.loc 1 2016 0
 4138 2408 41C5C3E5 		strb	ip, [r3, #1345]
2017:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 4139              		.loc 1 2017 0
 4140 240c 28C09DE5 		ldr	ip, [sp, #40]
2019:../uvc.c      **** 				 	 	 case Ext1ExCtrlSpeedCtlID8:
 4141              		.loc 1 2019 0
 4142 2410 0750A0E1 		mov	r5, r7
2017:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 4143              		.loc 1 2017 0
 4144 2414 42C5C3E5 		strb	ip, [r3, #1346]
2018:../uvc.c      **** 							 break;
 4145              		.loc 1 2018 0
 4146 2418 4585C3E5 		strb	r8, [r3, #1349]
2019:../uvc.c      **** 				 	 	 case Ext1ExCtrlSpeedCtlID8:
 4147              		.loc 1 2019 0
 4148 241c 69FCFFEA 		b	.L284
 4149              	.LVL435:
 4150              	.L345:
1883:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 4151              		.loc 1 1883 0 discriminator 1
 4152 2420 000058E3 		cmp	r8, #0
 4153 2424 0300000A 		beq	.L353
 4154 2428 B8001FE5 		ldr	r0, .L440+52
 4155 242c 0820A0E1 		mov	r2, r8
 4156 2430 6C1040E2 		sub	r1, r0, #108
 4157 2434 FEFFFFEB 		bl	memcpy
 4158              	.LVL436:
 4159              	.L353:
1887:../uvc.c      **** 				 	 	 case ExtAexModCtlID9://4byte
 4160              		.loc 1 1887 0
 4161 2438 FF70A0E3 		mov	r7, #255
1886:../uvc.c      **** 							 break;
 4162              		.loc 1 1886 0
 4163 243c FEFFFFEB 		bl	I2CCmdHandler
 4164              	.LVL437:
1887:../uvc.c      **** 				 	 	 case ExtAexModCtlID9://4byte
 4165              		.loc 1 1887 0
 4166 2440 0750A0E1 		mov	r5, r7
 4167 2444 5FFCFFEA 		b	.L284
 4168              	.LVL438:
 4169              	.L286:
1481:../uvc.c      **** 			 	 			 if(Len == 2)
 4170              		.loc 1 1481 0
 4171 2448 007087E0 		add	r7, r7, r0
 4172 244c 6031D7E5 		ldrb	r3, [r7, #352]	@ zero_extendqisi2
 4173 2450 DC401FE5 		ldr	r4, .L440+56
 4174 2454 000053E3 		cmp	r3, #0
 4175 2458 8B00000A 		beq	.L299
1482:../uvc.c      **** 			 	 			 {
 4176              		.loc 1 1482 0
 4177 245c 020058E3 		cmp	r8, #2
 4178 2460 2201000A 		beq	.L436
1488:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 4179              		.loc 1 1488 0
 4180 2464 040058E3 		cmp	r8, #4
 4181 2468 36FDFF1A 		bne	.L303
1489:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4182              		.loc 1 1489 0
 4183 246c 004184E0 		add	r4, r4, r0, asl #2
 4184 2470 202014E5 		ldr	r2, [r4, #-32]
 4185 2474 C2FEFFEA 		b	.L411
 4186              	.LVL439:
 4187              	.L363:
2236:../uvc.c      **** 			 	 			 {
 4188              		.loc 1 2236 0
 4189 2478 020058E3 		cmp	r8, #2
 4190 247c C200000A 		beq	.L437
2246:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 4191              		.loc 1 2246 0
 4192 2480 040058E3 		cmp	r8, #4
 4193 2484 1C01000A 		beq	.L392
 4194 2488 055187E0 		add	r5, r7, r5, asl #2
 4195 248c 207195E5 		ldr	r7, [r5, #288]
 4196 2490 14FFFFEA 		b	.L391
 4197              	.L339:
 4198 2494 044187E0 		add	r4, r7, r4, asl #2
 4199 2498 207094E5 		ldr	r7, [r4, #32]
 4200 249c 0DFFFFEA 		b	.L349
 4201              	.LVL440:
 4202              	.L378:
2170:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4203              		.loc 1 2170 0
 4204 24a0 1C711FE5 		ldr	r7, .L440+72
 4205 24a4 6C2094E5 		ldr	r2, [r4, #108]
 4206 24a8 5230D7E5 		ldrb	r3, [r7, #82]	@ zero_extendqisi2
 4207 24ac 000052E3 		cmp	r2, #0
 4208 24b0 B020A003 		moveq	r2, #176
 4209 24b4 3020A013 		movne	r2, #48
 4210 24b8 032082E1 		orr	r2, r2, r3
 4211 24bc 3010A0E3 		mov	r1, #48
 4212 24c0 5230A0E3 		mov	r3, #82
 4213 24c4 0100A0E3 		mov	r0, #1
 4214 24c8 FEFFFFEB 		bl	SensorSetIrisControl
 4215              	.LVL441:
2171:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4216              		.loc 1 2171 0
 4217 24cc 7D0FA0E3 		mov	r0, #500
 4218 24d0 FEFFFFEB 		bl	_tx_thread_sleep
 4219              	.LVL442:
2172:../uvc.c      **** 			                         	default:
 4220              		.loc 1 2172 0
 4221 24d4 6C1094E5 		ldr	r1, [r4, #108]
 4222 24d8 5220D7E5 		ldrb	r2, [r7, #82]	@ zero_extendqisi2
 4223 24dc 000051E3 		cmp	r1, #0
 4224 24e0 B010A003 		moveq	r1, #176
 4225 24e4 3010A013 		movne	r1, #48
 4226 24e8 022081E1 		orr	r2, r1, r2
 4227 24ec 6C3094E5 		ldr	r3, [r4, #108]
 4228 24f0 78111FE5 		ldr	r1, .L440+60
 4229 24f4 0400A0E3 		mov	r0, #4
 4230 24f8 FEFFFFEB 		bl	CyU3PDebugPrint
 4231              	.LVL443:
 4232 24fc EAFDFFEA 		b	.L418
 4233              	.L377:
2165:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4234              		.loc 1 2165 0
 4235 2500 7C711FE5 		ldr	r7, .L440+72
 4236 2504 6C2094E5 		ldr	r2, [r4, #108]
 4237 2508 5230D7E5 		ldrb	r3, [r7, #82]	@ zero_extendqisi2
 4238 250c 000052E3 		cmp	r2, #0
 4239 2510 8020A003 		moveq	r2, #128
 4240 2514 0020A013 		movne	r2, #0
 4241 2518 032082E1 		orr	r2, r2, r3
 4242 251c 3010A0E3 		mov	r1, #48
 4243 2520 5230A0E3 		mov	r3, #82
 4244 2524 0100A0E3 		mov	r0, #1
 4245 2528 FEFFFFEB 		bl	SensorSetIrisControl
 4246              	.LVL444:
2166:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4247              		.loc 1 2166 0
 4248 252c 7D0FA0E3 		mov	r0, #500
 4249 2530 FEFFFFEB 		bl	_tx_thread_sleep
 4250              	.LVL445:
2167:../uvc.c      **** 			                         		break;
 4251              		.loc 1 2167 0
 4252 2534 6C1094E5 		ldr	r1, [r4, #108]
 4253 2538 5220D7E5 		ldrb	r2, [r7, #82]	@ zero_extendqisi2
 4254 253c 000051E3 		cmp	r1, #0
 4255 2540 8010A003 		moveq	r1, #128
 4256 2544 0010A013 		movne	r1, #0
 4257 2548 022081E1 		orr	r2, r1, r2
 4258 254c 6C3094E5 		ldr	r3, [r4, #108]
 4259 2550 D8111FE5 		ldr	r1, .L440+60
 4260 2554 0400A0E3 		mov	r0, #4
 4261 2558 FEFFFFEB 		bl	CyU3PDebugPrint
 4262              	.LVL446:
2168:../uvc.c      **** 			                         	case 4: //VGA
 4263              		.loc 1 2168 0
 4264 255c D2FDFFEA 		b	.L418
 4265              	.L376:
2160:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4266              		.loc 1 2160 0
 4267 2560 6C2094E5 		ldr	r2, [r4, #108]
 4268 2564 3010A0E3 		mov	r1, #48
 4269 2568 000052E3 		cmp	r2, #0
 4270 256c 9220A003 		moveq	r2, #146
 4271 2570 1220A013 		movne	r2, #18
 4272 2574 5230A0E3 		mov	r3, #82
 4273 2578 0100A0E3 		mov	r0, #1
 4274 257c FEFFFFEB 		bl	SensorSetIrisControl
 4275              	.LVL447:
2161:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4276              		.loc 1 2161 0
 4277 2580 7D0FA0E3 		mov	r0, #500
 4278 2584 FEFFFFEB 		bl	_tx_thread_sleep
 4279              	.LVL448:
2162:../uvc.c      **** 			                         		break;
 4280              		.loc 1 2162 0
 4281 2588 6C2094E5 		ldr	r2, [r4, #108]
 4282 258c 14121FE5 		ldr	r1, .L440+60
 4283 2590 000052E3 		cmp	r2, #0
 4284 2594 6C3094E5 		ldr	r3, [r4, #108]
 4285 2598 9220A003 		moveq	r2, #146
 4286 259c 1220A013 		movne	r2, #18
 4287 25a0 0400A0E3 		mov	r0, #4
 4288 25a4 FEFFFFEB 		bl	CyU3PDebugPrint
 4289              	.LVL449:
2163:../uvc.c      **** 			                         	case 3: //720
 4290              		.loc 1 2163 0
 4291 25a8 BFFDFFEA 		b	.L418
 4292              	.L374:
2155:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4293              		.loc 1 2155 0
 4294 25ac 6C2094E5 		ldr	r2, [r4, #108]
 4295 25b0 3010A0E3 		mov	r1, #48
 4296 25b4 000052E3 		cmp	r2, #0
 4297 25b8 A220A003 		moveq	r2, #162
 4298 25bc 2220A013 		movne	r2, #34
 4299 25c0 5230A0E3 		mov	r3, #82
 4300 25c4 0100A0E3 		mov	r0, #1
 4301 25c8 FEFFFFEB 		bl	SensorSetIrisControl
 4302              	.LVL450:
2156:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4303              		.loc 1 2156 0
 4304 25cc 7D0FA0E3 		mov	r0, #500
 4305 25d0 FEFFFFEB 		bl	_tx_thread_sleep
 4306              	.LVL451:
2157:../uvc.c      **** 			                         		break;
 4307              		.loc 1 2157 0
 4308 25d4 6C2094E5 		ldr	r2, [r4, #108]
 4309 25d8 60121FE5 		ldr	r1, .L440+60
 4310 25dc 000052E3 		cmp	r2, #0
 4311 25e0 6C3094E5 		ldr	r3, [r4, #108]
 4312 25e4 A220A003 		moveq	r2, #162
 4313 25e8 2220A013 		movne	r2, #34
 4314 25ec 0400A0E3 		mov	r0, #4
 4315 25f0 FEFFFFEB 		bl	CyU3PDebugPrint
 4316              	.LVL452:
2158:../uvc.c      **** 			                         	case 2: //1080
 4317              		.loc 1 2158 0
 4318 25f4 ACFDFFEA 		b	.L418
 4319              	.LVL453:
 4320              	.L335:
2268:../uvc.c      **** 			   }
 4321              		.loc 1 2268 0
 4322 25f8 0400A0E3 		mov	r0, #4
 4323              	.LVL454:
 4324 25fc 80121FE5 		ldr	r1, .L440+64
 4325 2600 FEFFFFEB 		bl	CyU3PDebugPrint
 4326              	.LVL455:
 4327 2604 FF70A0E3 		mov	r7, #255
 4328 2608 0090A0E3 		mov	r9, #0
 4329 260c 0750A0E1 		mov	r5, r7
 4330 2610 09A0A0E1 		mov	r10, r9
 4331 2614 EBFBFFEA 		b	.L284
 4332              	.LVL456:
 4333              	.L313:
1652:../uvc.c      **** 			 	 			 {
 4334              		.loc 1 1652 0
 4335 2618 020058E3 		cmp	r8, #2
 4336 261c D500000A 		beq	.L438
1660:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4337              		.loc 1 1660 0
 4338 2620 040058E3 		cmp	r8, #4
 4339 2624 C7FCFF1A 		bne	.L303
1661:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4340              		.loc 1 1661 0
 4341 2628 0B10A0E1 		mov	r1, fp
 4342 262c 20009DE5 		ldr	r0, [sp, #32]
 4343              	.LVL457:
 4344 2630 1C308DE5 		str	r3, [sp, #28]
 4345 2634 18C08DE5 		str	ip, [sp, #24]
 4346 2638 FEFFFFEB 		bl	SensorGetControl
 4347              	.LVL458:
1662:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4348              		.loc 1 1662 0
 4349 263c 054184E0 		add	r4, r4, r5, asl #2
 4350 2640 205194E5 		ldr	r5, [r4, #288]
1663:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4351              		.loc 1 1663 0
 4352 2644 18C09DE5 		ldr	ip, [sp, #24]
1661:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4353              		.loc 1 1661 0
 4354 2648 C0421FE5 		ldr	r4, .L440+76
1663:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4355              		.loc 1 1663 0
 4356 264c 0B10A0E1 		mov	r1, fp
 4357 2650 0090A0E3 		mov	r9, #0
 4358 2654 09A0A0E1 		mov	r10, r9
1661:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4359              		.loc 1 1661 0
 4360 2658 0020A0E1 		mov	r2, r0
 4361 265c 2820C4E5 		strb	r2, [r4, #40]
1663:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4362              		.loc 1 1663 0
 4363 2660 0C00A0E1 		mov	r0, ip
1662:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4364              		.loc 1 1662 0
 4365 2664 0D20C5E5 		strb	r2, [r5, #13]
1663:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4366              		.loc 1 1663 0
 4367 2668 FEFFFFEB 		bl	SensorGetControl
 4368              	.LVL459:
 4369 266c 2A00C4E5 		strb	r0, [r4, #42]
1664:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4370              		.loc 1 1664 0
 4371 2670 0E00C5E5 		strb	r0, [r5, #14]
1665:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 4372              		.loc 1 1665 0
 4373 2674 1C309DE5 		ldr	r3, [sp, #28]
 4374 2678 2850D4E5 		ldrb	r5, [r4, #40]	@ zero_extendqisi2
 4375 267c 0070A0E1 		mov	r7, r0
 4376 2680 2930C4E5 		strb	r3, [r4, #41]
1666:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4377              		.loc 1 1666 0
 4378 2684 2B30C4E5 		strb	r3, [r4, #43]
 4379              	.LVL460:
 4380 2688 A0FCFFEA 		b	.L294
 4381              	.LVL461:
 4382              	.L299:
1497:../uvc.c      **** 			 	 			 {
 4383              		.loc 1 1497 0
 4384 268c 020058E3 		cmp	r8, #2
 4385 2690 C900000A 		beq	.L439
1505:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4386              		.loc 1 1505 0
 4387 2694 040058E3 		cmp	r8, #4
 4388 2698 AAFCFF1A 		bne	.L303
1506:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4389              		.loc 1 1506 0
 4390 269c 0B10A0E1 		mov	r1, fp
 4391 26a0 20009DE5 		ldr	r0, [sp, #32]
 4392              	.LVL462:
 4393 26a4 1C308DE5 		str	r3, [sp, #28]
 4394 26a8 18C08DE5 		str	ip, [sp, #24]
 4395 26ac FEFFFFEB 		bl	SensorGetControl
 4396              	.LVL463:
1507:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4397              		.loc 1 1507 0
 4398 26b0 054184E0 		add	r4, r4, r5, asl #2
 4399 26b4 205014E5 		ldr	r5, [r4, #-32]
1508:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4400              		.loc 1 1508 0
 4401 26b8 18C09DE5 		ldr	ip, [sp, #24]
1506:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4402              		.loc 1 1506 0
 4403 26bc 34431FE5 		ldr	r4, .L440+76
1508:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4404              		.loc 1 1508 0
 4405 26c0 0B10A0E1 		mov	r1, fp
 4406 26c4 0090A0E3 		mov	r9, #0
 4407 26c8 09A0A0E1 		mov	r10, r9
1506:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4408              		.loc 1 1506 0
 4409 26cc 0020A0E1 		mov	r2, r0
 4410 26d0 2820C4E5 		strb	r2, [r4, #40]
1508:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4411              		.loc 1 1508 0
 4412 26d4 0C00A0E1 		mov	r0, ip
1507:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4413              		.loc 1 1507 0
 4414 26d8 0D20C5E5 		strb	r2, [r5, #13]
1508:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4415              		.loc 1 1508 0
 4416 26dc FEFFFFEB 		bl	SensorGetControl
 4417              	.LVL464:
 4418 26e0 2A00C4E5 		strb	r0, [r4, #42]
1509:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4419              		.loc 1 1509 0
 4420 26e4 0E00C5E5 		strb	r0, [r5, #14]
1510:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 4421              		.loc 1 1510 0
 4422 26e8 1C309DE5 		ldr	r3, [sp, #28]
 4423 26ec 0070A0E1 		mov	r7, r0
 4424 26f0 2930C4E5 		strb	r3, [r4, #41]
1511:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4425              		.loc 1 1511 0
 4426 26f4 2B30C4E5 		strb	r3, [r4, #43]
 4427              	.LVL465:
 4428 26f8 2850D4E5 		ldrb	r5, [r4, #40]	@ zero_extendqisi2
 4429 26fc 83FCFFEA 		b	.L294
 4430              	.LVL466:
 4431              	.L387:
2226:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 4432              		.loc 1 2226 0
 4433 2700 FEFFFFEB 		bl	_txe_mutex_get
 4434              	.LVL467:
2227:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4435              		.loc 1 2227 0
 4436 2704 24009DE5 		ldr	r0, [sp, #36]
 4437 2708 18C09DE5 		ldr	ip, [sp, #24]
 4438 270c 00008DE5 		str	r0, [sp]
 4439 2710 04008DE5 		str	r0, [sp, #4]
 4440 2714 0C20A0E1 		mov	r2, ip
 4441 2718 5DFDFFEA 		b	.L415
 4442              	.L434:
2047:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4443              		.loc 1 2047 0
 4444 271c 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4445 2720 24009DE5 		ldr	r0, [sp, #36]
 4446 2724 000053E1 		cmp	r3, r0
 4447 2728 1400000A 		beq	.L390
2048:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 4448              		.loc 1 2048 0
 4449 272c AC431FE5 		ldr	r4, .L440+68
 4450 2730 0010E0E3 		mvn	r1, #0
 4451 2734 1C0094E5 		ldr	r0, [r4, #28]
 4452 2738 18C08DE5 		str	ip, [sp, #24]
 4453 273c FEFFFFEB 		bl	_txe_mutex_get
 4454              	.LVL468:
2049:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4455              		.loc 1 2049 0
 4456 2740 24109DE5 		ldr	r1, [sp, #36]
 4457 2744 00108DE5 		str	r1, [sp]
 4458              	.L419:
2240:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4459              		.loc 1 2240 0
 4460 2748 18C09DE5 		ldr	ip, [sp, #24]
 4461 274c 0510A0E1 		mov	r1, r5
 4462 2750 0C20A0E1 		mov	r2, ip
 4463 2754 00C0A0E3 		mov	ip, #0
 4464 2758 04C08DE5 		str	ip, [sp, #4]
 4465 275c 0B30A0E1 		mov	r3, fp
 4466 2760 0400A0E1 		mov	r0, r4
 4467 2764 FEFFFFEB 		bl	cmdSet
 4468              	.LVL469:
2241:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 4469              		.loc 1 2241 0
 4470 2768 1C0094E5 		ldr	r0, [r4, #28]
 4471 276c FEFFFFEB 		bl	_txe_mutex_put
 4472              	.LVL470:
2242:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
 4473              		.loc 1 2242 0
 4474 2770 24C09DE5 		ldr	ip, [sp, #36]
2243:../uvc.c      **** 								 }
 4475              		.loc 1 2243 0
 4476 2774 0000A0E3 		mov	r0, #0
2242:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
 4477              		.loc 1 2242 0
 4478 2778 0DC0C7E5 		strb	ip, [r7, #13]
 4479              	.LVL471:
2243:../uvc.c      **** 								 }
 4480              		.loc 1 2243 0
 4481 277c 0E00C7E5 		strb	r0, [r7, #14]
 4482              	.L390:
2245:../uvc.c      **** 			 	 			 }else if(Len == 4){
 4483              		.loc 1 2245 0
 4484 2780 0130A0E3 		mov	r3, #1
 4485 2784 1130C7E5 		strb	r3, [r7, #17]
 4486 2788 56FEFFEA 		b	.L391
 4487              	.LVL472:
 4488              	.L437:
2238:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4489              		.loc 1 2238 0
 4490 278c 057187E0 		add	r7, r7, r5, asl #2
 4491 2790 207197E5 		ldr	r7, [r7, #288]
 4492 2794 24109DE5 		ldr	r1, [sp, #36]
 4493 2798 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4494 279c 010053E1 		cmp	r3, r1
 4495 27a0 F6FFFF0A 		beq	.L390
2239:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 4496              		.loc 1 2239 0
 4497 27a4 24441FE5 		ldr	r4, .L440+68
 4498 27a8 0010E0E3 		mvn	r1, #0
 4499 27ac 1C0094E5 		ldr	r0, [r4, #28]
 4500 27b0 18C08DE5 		str	ip, [sp, #24]
 4501 27b4 FEFFFFEB 		bl	_txe_mutex_get
 4502              	.LVL473:
2240:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4503              		.loc 1 2240 0
 4504 27b8 24209DE5 		ldr	r2, [sp, #36]
 4505 27bc 00208DE5 		str	r2, [sp]
 4506 27c0 E0FFFFEA 		b	.L419
 4507              	.L435:
2056:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 4508              		.loc 1 2056 0
 4509 27c4 44141FE5 		ldr	r1, .L440+68
 4510 27c8 2C108DE5 		str	r1, [sp, #44]
 4511 27cc 2C209DE5 		ldr	r2, [sp, #44]
 4512 27d0 0010E0E3 		mvn	r1, #0
 4513 27d4 1C0092E5 		ldr	r0, [r2, #28]
 4514 27d8 18C08DE5 		str	ip, [sp, #24]
 4515 27dc FEFFFFEB 		bl	_txe_mutex_get
 4516              	.LVL474:
 4517              	.L424:
2248:../uvc.c      **** 								 {
 4518              		.loc 1 2248 0
 4519 27e0 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4520 27e4 24009DE5 		ldr	r0, [sp, #36]
 4521 27e8 18C09DE5 		ldr	ip, [sp, #24]
 4522 27ec 000053E1 		cmp	r3, r0
2251:../uvc.c      **** 									 dataIdx++;
 4523              		.loc 1 2251 0
 4524 27f0 0030A0E3 		mov	r3, #0
2248:../uvc.c      **** 								 {
 4525              		.loc 1 2248 0
 4526 27f4 0700000A 		beq	.L393
2250:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4527              		.loc 1 2250 0
 4528 27f8 0D00C7E5 		strb	r0, [r7, #13]
 4529              	.LVL475:
2251:../uvc.c      **** 									 dataIdx++;
 4530              		.loc 1 2251 0
 4531 27fc 0C20A0E1 		mov	r2, ip
 4532 2800 09008DE8 		stmia	sp, {r0, r3}
 4533 2804 2C009DE5 		ldr	r0, [sp, #44]
 4534 2808 0B30A0E1 		mov	r3, fp
 4535 280c 0510A0E1 		mov	r1, r5
 4536 2810 FEFFFFEB 		bl	cmdSet
 4537              	.LVL476:
2252:../uvc.c      **** 								 }
 4538              		.loc 1 2252 0
 4539 2814 0130A0E3 		mov	r3, #1
 4540              	.LVL477:
 4541              	.L393:
2254:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 4542              		.loc 1 2254 0
 4543 2818 0E20D7E5 		ldrb	r2, [r7, #14]	@ zero_extendqisi2
 4544 281c 28C09DE5 		ldr	ip, [sp, #40]
 4545 2820 0C0052E1 		cmp	r2, ip
 4546 2824 0700000A 		beq	.L394
2255:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 4547              		.loc 1 2255 0
 4548 2828 0EC0C7E5 		strb	ip, [r7, #14]
2256:../uvc.c      **** 								 }
 4549              		.loc 1 2256 0
 4550 282c 0510A0E1 		mov	r1, r5
 4551 2830 04308DE5 		str	r3, [sp, #4]
 4552 2834 00C08DE5 		str	ip, [sp]
 4553 2838 20209DE5 		ldr	r2, [sp, #32]
 4554 283c 0B30A0E1 		mov	r3, fp
 4555              	.LVL478:
 4556 2840 C0041FE5 		ldr	r0, .L440+68
 4557 2844 FEFFFFEB 		bl	cmdSet
 4558              	.LVL479:
 4559              	.L394:
2258:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4560              		.loc 1 2258 0
 4561 2848 0130A0E3 		mov	r3, #1
 4562 284c 1130C7E5 		strb	r3, [r7, #17]
2259:../uvc.c      **** 
 4563              		.loc 1 2259 0
 4564 2850 2CC09DE5 		ldr	ip, [sp, #44]
 4565 2854 1C009CE5 		ldr	r0, [ip, #28]
 4566 2858 FEFFFFEB 		bl	_txe_mutex_put
 4567              	.LVL480:
 4568 285c 21FEFFEA 		b	.L391
 4569              	.LVL481:
 4570              	.L433:
1639:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4571              		.loc 1 1639 0
 4572 2860 004184E0 		add	r4, r4, r0, asl #2
 4573 2864 203194E5 		ldr	r3, [r4, #288]
 4574              	.L410:
 4575 2868 0D50D3E5 		ldrb	r5, [r3, #13]	@ zero_extendqisi2
 4576 286c E4441FE5 		ldr	r4, .L440+76
 4577 2870 FF5005E2 		and	r5, r5, #255
 4578 2874 2850C4E5 		strb	r5, [r4, #40]
1640:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4579              		.loc 1 1640 0
 4580 2878 0E70D3E5 		ldrb	r7, [r3, #14]	@ zero_extendqisi2
 4581 287c 0090A0E3 		mov	r9, #0
 4582 2880 FF7007E2 		and	r7, r7, #255
 4583 2884 2970C4E5 		strb	r7, [r4, #41]
 4584              	.LVL482:
 4585 2888 09A0A0E1 		mov	r10, r9
 4586 288c 1FFCFFEA 		b	.L294
 4587              	.LVL483:
 4588              	.L354:
1896:../uvc.c      **** 								 if((pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo&0x03) != Data0)
 4589              		.loc 1 1896 0
 4590 2890 0C00A0E1 		mov	r0, ip
 4591 2894 0B10A0E1 		mov	r1, fp
 4592 2898 18C08DE5 		str	ip, [sp, #24]
 4593 289c FEFFFFEB 		bl	SensorGetControl
 4594              	.LVL484:
 4595 28a0 0D00C4E5 		strb	r0, [r4, #13]
1897:../uvc.c      **** 								 {
 4596              		.loc 1 1897 0
 4597 28a4 0D30D4E5 		ldrb	r3, [r4, #13]	@ zero_extendqisi2
 4598 28a8 24009DE5 		ldr	r0, [sp, #36]
 4599 28ac 033003E2 		and	r3, r3, #3
 4600 28b0 030050E1 		cmp	r0, r3
 4601 28b4 18C09DE5 		ldr	ip, [sp, #24]
 4602 28b8 66FEFF0A 		beq	.L355
1899:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0; //keep the valus is the same as the Reg. h
 4603              		.loc 1 1899 0
 4604 28bc 0D90D4E5 		ldrb	r9, [r4, #13]	@ zero_extendqisi2
1901:../uvc.c      **** 									 dataIdx++;
 4605              		.loc 1 1901 0
 4606 28c0 0010A0E3 		mov	r1, #0
1899:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0; //keep the valus is the same as the Reg. h
 4607              		.loc 1 1899 0
 4608 28c4 FC9009E2 		and	r9, r9, #252
 4609 28c8 099080E1 		orr	r9, r0, r9
 4610              	.LVL485:
1900:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4611              		.loc 1 1900 0
 4612 28cc 0D90C4E5 		strb	r9, [r4, #13]
1901:../uvc.c      **** 									 dataIdx++;
 4613              		.loc 1 1901 0
 4614 28d0 0C20A0E1 		mov	r2, ip
 4615 28d4 04108DE5 		str	r1, [sp, #4]
 4616 28d8 0B30A0E1 		mov	r3, fp
 4617 28dc 2C009DE5 		ldr	r0, [sp, #44]
 4618 28e0 00908DE5 		str	r9, [sp]
 4619 28e4 1910A0E3 		mov	r1, #25
 4620 28e8 FEFFFFEB 		bl	cmdSet
 4621              	.LVL486:
 4622 28ec 59FEFFEA 		b	.L355
 4623              	.LVL487:
 4624              	.L436:
1484:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4625              		.loc 1 1484 0
 4626 28f0 004184E0 		add	r4, r4, r0, asl #2
 4627 28f4 203014E5 		ldr	r3, [r4, #-32]
 4628 28f8 DAFFFFEA 		b	.L410
 4629              	.LVL488:
 4630              	.L392:
2247:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
 4631              		.loc 1 2247 0
 4632 28fc 7C151FE5 		ldr	r1, .L440+68
 4633 2900 80251FE5 		ldr	r2, .L440+68
 4634 2904 2C108DE5 		str	r1, [sp, #44]
 4635 2908 1C0092E5 		ldr	r0, [r2, #28]
 4636 290c 0010E0E3 		mvn	r1, #0
2248:../uvc.c      **** 								 {
 4637              		.loc 1 2248 0
 4638 2910 057187E0 		add	r7, r7, r5, asl #2
2247:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
 4639              		.loc 1 2247 0
 4640 2914 18C08DE5 		str	ip, [sp, #24]
 4641 2918 FEFFFFEB 		bl	_txe_mutex_get
 4642              	.LVL489:
2248:../uvc.c      **** 								 {
 4643              		.loc 1 2248 0
 4644 291c 207197E5 		ldr	r7, [r7, #288]
 4645 2920 AEFFFFEA 		b	.L424
 4646              	.LVL490:
 4647              	.L432:
1616:../uvc.c      **** 			 	 				 if(glEp0Buffer[0]&0x1){// the enhancement on
 4648              		.loc 1 1616 0
 4649 2924 0C00A0E1 		mov	r0, ip
 4650              	.LVL491:
 4651 2928 0B10A0E1 		mov	r1, fp
 4652 292c FEFFFFEB 		bl	SensorGetControl
 4653              	.LVL492:
 4654 2930 A8451FE5 		ldr	r4, .L440+76
1617:../uvc.c      **** 			 	 					 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);// get the enhancement level
 4655              		.loc 1 1617 0
 4656 2934 013010E2 		ands	r3, r0, #1
1616:../uvc.c      **** 			 	 				 if(glEp0Buffer[0]&0x1){// the enhancement on
 4657              		.loc 1 1616 0
 4658 2938 2800C4E5 		strb	r0, [r4, #40]
1620:../uvc.c      **** 			 	 				 }
 4659              		.loc 1 1620 0
 4660 293c 2830C405 		streqb	r3, [r4, #40]
1617:../uvc.c      **** 			 	 					 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);// get the enhancement level
 4661              		.loc 1 1617 0
 4662 2940 0300000A 		beq	.L312
1618:../uvc.c      **** 			 	 				 }else{
 4663              		.loc 1 1618 0
 4664 2944 20009DE5 		ldr	r0, [sp, #32]
 4665 2948 0B10A0E1 		mov	r1, fp
 4666 294c FEFFFFEB 		bl	SensorGetControl
 4667              	.LVL493:
 4668 2950 2800C4E5 		strb	r0, [r4, #40]
 4669              	.L312:
1622:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4670              		.loc 1 1622 0
 4671 2954 D0351FE5 		ldr	r3, .L440+72
 4672 2958 2850D4E5 		ldrb	r5, [r4, #40]	@ zero_extendqisi2
1623:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
 4673              		.loc 1 1623 0
 4674 295c 0070A0E3 		mov	r7, #0
1622:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4675              		.loc 1 1622 0
 4676 2960 9555C3E5 		strb	r5, [r3, #1429]
1623:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
 4677              		.loc 1 1623 0
 4678 2964 2970C4E5 		strb	r7, [r4, #41]
1624:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4679              		.loc 1 1624 0
 4680 2968 9675C3E5 		strb	r7, [r3, #1430]
 4681              	.LVL494:
 4682 296c 0790A0E1 		mov	r9, r7
 4683 2970 07A0A0E1 		mov	r10, r7
 4684 2974 E5FBFFEA 		b	.L294
 4685              	.LVL495:
 4686              	.L438:
1654:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4687              		.loc 1 1654 0
 4688 2978 0C00A0E1 		mov	r0, ip
 4689              	.LVL496:
 4690 297c 0B10A0E1 		mov	r1, fp
1655:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4691              		.loc 1 1655 0
 4692 2980 054184E0 		add	r4, r4, r5, asl #2
1654:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4693              		.loc 1 1654 0
 4694 2984 1C308DE5 		str	r3, [sp, #28]
 4695 2988 FEFFFFEB 		bl	SensorGetControl
 4696              	.LVL497:
1655:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4697              		.loc 1 1655 0
 4698 298c 202194E5 		ldr	r2, [r4, #288]
 4699              	.L409:
1654:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4700              		.loc 1 1654 0
 4701 2990 08461FE5 		ldr	r4, .L440+76
 4702 2994 0090A0E3 		mov	r9, #0
 4703 2998 2800C4E5 		strb	r0, [r4, #40]
 4704 299c 1C309DE5 		ldr	r3, [sp, #28]
 4705 29a0 0050A0E1 		mov	r5, r0
1655:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4706              		.loc 1 1655 0
 4707 29a4 0D00C2E5 		strb	r0, [r2, #13]
 4708              	.LVL498:
 4709 29a8 0370A0E1 		mov	r7, r3
1656:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
 4710              		.loc 1 1656 0
 4711 29ac 2930C4E5 		strb	r3, [r4, #41]
 4712 29b0 09A0A0E1 		mov	r10, r9
1657:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4713              		.loc 1 1657 0
 4714 29b4 0E30C2E5 		strb	r3, [r2, #14]
 4715              	.LVL499:
 4716 29b8 D4FBFFEA 		b	.L294
 4717              	.LVL500:
 4718              	.L439:
1499:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4719              		.loc 1 1499 0
 4720 29bc 0C00A0E1 		mov	r0, ip
 4721              	.LVL501:
 4722 29c0 0B10A0E1 		mov	r1, fp
1500:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4723              		.loc 1 1500 0
 4724 29c4 054184E0 		add	r4, r4, r5, asl #2
1499:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4725              		.loc 1 1499 0
 4726 29c8 1C308DE5 		str	r3, [sp, #28]
 4727 29cc FEFFFFEB 		bl	SensorGetControl
 4728              	.LVL502:
1500:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4729              		.loc 1 1500 0
 4730 29d0 202014E5 		ldr	r2, [r4, #-32]
 4731 29d4 EDFFFFEA 		b	.L409
 4732              		.cfi_endproc
 4733              	.LFE3:
 4735              		.align	2
 4736              		.global	CTControlHandle
 4738              	CTControlHandle:
 4739              	.LFB4:
2284:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 4740              		.loc 1 2284 0
 4741              		.cfi_startproc
 4742              		@ args = 0, pretend = 0, frame = 24
 4743              		@ frame_needed = 0, uses_anonymous_args = 0
 4744              	.LVL503:
 4745 29d8 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 4746              	.LCFI19:
 4747              		.cfi_def_cfa_offset 36
 4748              		.cfi_offset 4, -36
 4749              		.cfi_offset 5, -32
 4750              		.cfi_offset 6, -28
 4751              		.cfi_offset 7, -24
 4752              		.cfi_offset 8, -20
 4753              		.cfi_offset 9, -16
 4754              		.cfi_offset 10, -12
 4755              		.cfi_offset 11, -8
 4756              		.cfi_offset 14, -4
2303:../uvc.c      **** 
 4757              		.loc 1 2303 0
 4758 29dc 28B89FE5 		ldr	fp, .L480
2295:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4759              		.loc 1 2295 0
 4760 29e0 28389FE5 		ldr	r3, .L480+4
2303:../uvc.c      **** 
 4761              		.loc 1 2303 0
 4762 29e4 0050DBE5 		ldrb	r5, [fp]	@ zero_extendqisi2
2295:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4763              		.loc 1 2295 0
 4764 29e8 8080A0E1 		mov	r8, r0, asl #1
 4765 29ec 002088E0 		add	r2, r8, r0
 4766 29f0 822183E0 		add	r2, r3, r2, asl #3
2305:../uvc.c      **** 		 {
 4767              		.loc 1 2305 0
 4768 29f4 830055E3 		cmp	r5, #131
2284:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 4769              		.loc 1 2284 0
 4770 29f8 34D04DE2 		sub	sp, sp, #52
 4771              	.LCFI20:
 4772              		.cfi_def_cfa_offset 88
2284:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 4773              		.loc 1 2284 0
 4774 29fc 0060A0E1 		mov	r6, r0
2295:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4775              		.loc 1 2295 0
 4776 2a00 E795D2E5 		ldrb	r9, [r2, #1511]	@ zero_extendqisi2
 4777              	.LVL504:
2296:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 4778              		.loc 1 2296 0
 4779 2a04 D8A5D2E5 		ldrb	r10, [r2, #1496]	@ zero_extendqisi2
 4780              	.LVL505:
2298:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 4781              		.loc 1 2298 0
 4782 2a08 DA75D2E5 		ldrb	r7, [r2, #1498]	@ zero_extendqisi2
 4783              	.LVL506:
2305:../uvc.c      **** 		 {
 4784              		.loc 1 2305 0
 4785 2a0c 8000000A 		beq	.L444
 4786 2a10 2600009A 		bls	.L478
 4787 2a14 850055E3 		cmp	r5, #133
 4788 2a18 7200000A 		beq	.L449
 4789 2a1c 5000003A 		bcc	.L450
 4790 2a20 860055E3 		cmp	r5, #134
 4791 2a24 4300000A 		beq	.L451
 4792 2a28 870055E3 		cmp	r5, #135
 4793 2a2c 5F00001A 		bne	.L443
2367:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4794              		.loc 1 2367 0
 4795 2a30 E3C5D2E5 		ldrb	ip, [r2, #1507]	@ zero_extendqisi2
 4796 2a34 D8479FE5 		ldr	r4, .L480+8
2368:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4797              		.loc 1 2368 0
 4798 2a38 E425D2E5 		ldrb	r2, [r2, #1508]	@ zero_extendqisi2
 4799              	.LVL507:
 4800              	.L477:
2345:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 4801              		.loc 1 2345 0
 4802 2a3c 0A1056E2 		subs	r1, r6, #10
 4803 2a40 006071E2 		rsbs	r6, r1, #0
 4804 2a44 0160B6E0 		adcs	r6, r6, r1
2347:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4805              		.loc 1 2347 0
 4806 2a48 0030A0E3 		mov	r3, #0
 4807              	.LVL508:
2348:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4808              		.loc 1 2348 0
 4809 2a4c 281084E2 		add	r1, r4, #40
 4810 2a50 0700A0E1 		mov	r0, r7
 4811              	.LVL509:
2345:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 4812              		.loc 1 2345 0
 4813 2a54 2A60C4E5 		strb	r6, [r4, #42]
2343:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4814              		.loc 1 2343 0
 4815 2a58 28C0C4E5 		strb	ip, [r4, #40]
2344:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4816              		.loc 1 2344 0
 4817 2a5c 2920C4E5 		strb	r2, [r4, #41]
2347:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4818              		.loc 1 2347 0
 4819 2a60 2B30C4E5 		strb	r3, [r4, #43]
2348:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4820              		.loc 1 2348 0
 4821 2a64 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4822              	.LVL510:
 4823 2a68 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
2350:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 4824              		.loc 1 2350 0
 4825 2a6c FF80A0E3 		mov	r8, #255
 4826 2a70 0860A0E1 		mov	r6, r8
 4827              	.LVL511:
 4828              	.L453:
2518:../uvc.c      **** }
 4829              		.loc 1 2518 0
 4830 2a74 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 4831 2a78 FFC0A0E3 		mov	ip, #255
 4832 2a7c 04108DE5 		str	r1, [sp, #4]
 4833 2a80 10108DE5 		str	r1, [sp, #16]
 4834 2a84 08008DE5 		str	r0, [sp, #8]
 4835 2a88 00808DE5 		str	r8, [sp]
 4836 2a8c 14708DE5 		str	r7, [sp, #20]
 4837 2a90 0520A0E1 		mov	r2, r5
 4838 2a94 0630A0E1 		mov	r3, r6
 4839 2a98 0CC08DE5 		str	ip, [sp, #12]
 4840 2a9c 74179FE5 		ldr	r1, .L480+12
 4841 2aa0 0400A0E3 		mov	r0, #4
 4842 2aa4 FEFFFFEB 		bl	CyU3PDebugPrint
 4843              	.LVL512:
2519:../uvc.c      **** 
 4844              		.loc 1 2519 0
 4845 2aa8 34D08DE2 		add	sp, sp, #52
 4846              		@ sp needed
 4847 2aac F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 4848              	.LVL513:
 4849              	.L478:
2305:../uvc.c      **** 		 {
 4850              		.loc 1 2305 0
 4851 2ab0 810055E3 		cmp	r5, #129
 4852 2ab4 2E00000A 		beq	.L446
 4853 2ab8 1A00008A 		bhi	.L447
 4854 2abc 010055E3 		cmp	r5, #1
 4855 2ac0 3A00001A 		bne	.L443
2376:../uvc.c      **** 			  glEp0Buffer, &readCount);
 4856              		.loc 1 2376 0
 4857 2ac4 48479FE5 		ldr	r4, .L480+8
 4858 2ac8 2E208DE2 		add	r2, sp, #46
 4859              	.LVL514:
 4860 2acc 2000A0E3 		mov	r0, #32
 4861              	.LVL515:
 4862 2ad0 281084E2 		add	r1, r4, #40
 4863 2ad4 18308DE5 		str	r3, [sp, #24]
 4864 2ad8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4865              	.LVL516:
2378:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4866              		.loc 1 2378 0
 4867 2adc 28C0D4E5 		ldrb	ip, [r4, #40]	@ zero_extendqisi2
2382:../uvc.c      **** 			  {
 4868              		.loc 1 2382 0
 4869 2ae0 012046E2 		sub	r2, r6, #1
2378:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4870              		.loc 1 2378 0
 4871 2ae4 1CC08DE5 		str	ip, [sp, #28]
 4872              	.LVL517:
2379:../uvc.c      **** 			  value = Data1;
 4873              		.loc 1 2379 0
 4874 2ae8 29C0D4E5 		ldrb	ip, [r4, #41]	@ zero_extendqisi2
2382:../uvc.c      **** 			  {
 4875              		.loc 1 2382 0
 4876 2aec 18309DE5 		ldr	r3, [sp, #24]
2379:../uvc.c      **** 			  value = Data1;
 4877              		.loc 1 2379 0
 4878 2af0 20C08DE5 		str	ip, [sp, #32]
 4879              	.LVL518:
2382:../uvc.c      **** 			  {
 4880              		.loc 1 2382 0
 4881 2af4 090052E3 		cmp	r2, #9
 4882 2af8 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4883 2afc 1D0100EA 		b	.L454
 4884              	.L456:
 4885 2b00 302F0000 		.word	.L455
 4886 2b04 782F0000 		.word	.L454
 4887 2b08 302D0000 		.word	.L457
 4888 2b0c 782F0000 		.word	.L454
 4889 2b10 782F0000 		.word	.L454
 4890 2b14 782F0000 		.word	.L454
 4891 2b18 A02C0000 		.word	.L458
 4892 2b1c 782F0000 		.word	.L454
 4893 2b20 782F0000 		.word	.L454
 4894 2b24 242C0000 		.word	.L459
 4895              	.LVL519:
 4896              	.L447:
2334:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 4897              		.loc 1 2334 0
 4898 2b28 DBC5D2E5 		ldrb	ip, [r2, #1499]	@ zero_extendqisi2
 4899 2b2c E0469FE5 		ldr	r4, .L480+8
2335:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 4900              		.loc 1 2335 0
 4901 2b30 DC25D2E5 		ldrb	r2, [r2, #1500]	@ zero_extendqisi2
 4902              	.LVL520:
 4903 2b34 C0FFFFEA 		b	.L477
 4904              	.LVL521:
 4905              	.L451:
2361:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4906              		.loc 1 2361 0
 4907 2b38 D4469FE5 		ldr	r4, .L480+8
 4908 2b3c E135D2E5 		ldrb	r3, [r2, #1505]	@ zero_extendqisi2
 4909 2b40 0410A0E1 		mov	r1, r4
 4910 2b44 2830E1E5 		strb	r3, [r1, #40]!
2362:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4911              		.loc 1 2362 0
 4912 2b48 0100A0E3 		mov	r0, #1
 4913              	.LVL522:
2365:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 4914              		.loc 1 2365 0
 4915 2b4c FF80A0E3 		mov	r8, #255
2362:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4916              		.loc 1 2362 0
 4917 2b50 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4918              	.LVL523:
2365:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 4919              		.loc 1 2365 0
 4920 2b54 0860A0E1 		mov	r6, r8
 4921 2b58 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
 4922 2b5c 0170A0E3 		mov	r7, #1
 4923 2b60 C3FFFFEA 		b	.L453
 4924              	.LVL524:
 4925              	.L450:
2352:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4926              		.loc 1 2352 0
 4927 2b64 DFC5D2E5 		ldrb	ip, [r2, #1503]	@ zero_extendqisi2
 4928 2b68 A4469FE5 		ldr	r4, .L480+8
2353:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4929              		.loc 1 2353 0
 4930 2b6c E025D2E5 		ldrb	r2, [r2, #1504]	@ zero_extendqisi2
 4931              	.LVL525:
 4932 2b70 B1FFFFEA 		b	.L477
 4933              	.LVL526:
 4934              	.L446:
2319:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4935              		.loc 1 2319 0
 4936 2b74 98469FE5 		ldr	r4, .L480+8
 4937 2b78 E595D2E5 		ldrb	r9, [r2, #1509]	@ zero_extendqisi2
2320:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4938              		.loc 1 2320 0
 4939 2b7c E6C5D2E5 		ldrb	ip, [r2, #1510]	@ zero_extendqisi2
2321:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4940              		.loc 1 2321 0
 4941 2b80 0030A0E3 		mov	r3, #0
2327:../uvc.c      **** 
 4942              		.loc 1 2327 0
 4943 2b84 281084E2 		add	r1, r4, #40
 4944 2b88 0700A0E1 		mov	r0, r7
 4945              	.LVL527:
2332:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 4946              		.loc 1 2332 0
 4947 2b8c FF80A0E3 		mov	r8, #255
2320:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4948              		.loc 1 2320 0
 4949 2b90 29C0C4E5 		strb	ip, [r4, #41]
2319:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4950              		.loc 1 2319 0
 4951 2b94 2890C4E5 		strb	r9, [r4, #40]
2321:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4952              		.loc 1 2321 0
 4953 2b98 2A30C4E5 		strb	r3, [r4, #42]
2322:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 4954              		.loc 1 2322 0
 4955 2b9c 2B30C4E5 		strb	r3, [r4, #43]
 4956              	.LVL528:
2332:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 4957              		.loc 1 2332 0
 4958 2ba0 0860A0E1 		mov	r6, r8
 4959              	.LVL529:
2327:../uvc.c      **** 
 4960              		.loc 1 2327 0
 4961 2ba4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4962              	.LVL530:
 4963 2ba8 0900A0E1 		mov	r0, r9
2332:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 4964              		.loc 1 2332 0
 4965 2bac B0FFFFEA 		b	.L453
 4966              	.LVL531:
 4967              	.L443:
2512:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 4968              		.loc 1 2512 0
 4969 2bb0 0000A0E3 		mov	r0, #0
 4970              	.LVL532:
 4971 2bb4 0020A0E1 		mov	r2, r0
 4972              	.LVL533:
 4973 2bb8 0110A0E3 		mov	r1, #1
 4974 2bbc FEFFFFEB 		bl	CyU3PUsbStall
 4975              	.LVL534:
2513:../uvc.c      **** 			  break;
 4976              		.loc 1 2513 0
 4977 2bc0 0620A0E1 		mov	r2, r6
 4978 2bc4 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 4979 2bc8 0400A0E3 		mov	r0, #4
 4980 2bcc 48169FE5 		ldr	r1, .L480+16
 4981 2bd0 FEFFFFEB 		bl	CyU3PDebugPrint
 4982              	.LVL535:
2514:../uvc.c      **** 		 }
 4983              		.loc 1 2514 0
 4984 2bd4 FF00A0E3 		mov	r0, #255
 4985 2bd8 34469FE5 		ldr	r4, .L480+8
 4986 2bdc 0080A0E1 		mov	r8, r0
 4987 2be0 0060A0E1 		mov	r6, r0
 4988 2be4 A2FFFFEA 		b	.L453
 4989              	.LVL536:
 4990              	.L449:
2309:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 4991              		.loc 1 2309 0
 4992 2be8 24469FE5 		ldr	r4, .L480+8
2310:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4993              		.loc 1 2310 0
 4994 2bec 0030A0E3 		mov	r3, #0
2311:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4995              		.loc 1 2311 0
 4996 2bf0 281084E2 		add	r1, r4, #40
 4997 2bf4 0200A0E3 		mov	r0, #2
 4998              	.LVL537:
2313:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 4999              		.loc 1 2313 0
 5000 2bf8 FF80A0E3 		mov	r8, #255
2309:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 5001              		.loc 1 2309 0
 5002 2bfc 2870C4E5 		strb	r7, [r4, #40]
2310:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5003              		.loc 1 2310 0
 5004 2c00 2930C4E5 		strb	r3, [r4, #41]
2313:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5005              		.loc 1 2313 0
 5006 2c04 0860A0E1 		mov	r6, r8
 5007              	.LVL538:
2311:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5008              		.loc 1 2311 0
 5009 2c08 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5010              	.LVL539:
 5011 2c0c 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
2313:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5012              		.loc 1 2313 0
 5013 2c10 97FFFFEA 		b	.L453
 5014              	.LVL540:
 5015              	.L444:
2343:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5016              		.loc 1 2343 0
 5017 2c14 DDC5D2E5 		ldrb	ip, [r2, #1501]	@ zero_extendqisi2
 5018 2c18 F4459FE5 		ldr	r4, .L480+8
2344:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5019              		.loc 1 2344 0
 5020 2c1c DE25D2E5 		ldrb	r2, [r2, #1502]	@ zero_extendqisi2
 5021              	.LVL541:
 5022 2c20 85FFFFEA 		b	.L477
 5023              	.LVL542:
 5024              	.L459:
2491:../uvc.c      **** 					  if(getData == 1)
 5025              		.loc 1 2491 0
 5026 2c24 F4659FE5 		ldr	r6, .L480+20
 5027 2c28 0010E0E3 		mvn	r1, #0
 5028 2c2c 1C0096E5 		ldr	r0, [r6, #28]
 5029 2c30 FEFFFFEB 		bl	_txe_mutex_get
 5030              	.LVL543:
2492:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5031              		.loc 1 2492 0
 5032 2c34 1CC09DE5 		ldr	ip, [sp, #28]
 5033 2c38 01005CE3 		cmp	ip, #1
2493:../uvc.c      **** 					  else if(getData == 0xff)
 5034              		.loc 1 2493 0
 5035 2c3c 0400A003 		moveq	r0, #4
2492:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5036              		.loc 1 2492 0
 5037 2c40 6901000A 		beq	.L476
2494:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 5038              		.loc 1 2494 0
 5039 2c44 FF005CE3 		cmp	ip, #255
 5040 2c48 6601000A 		beq	.L479
2497:../uvc.c      **** 					  //dataIdx++;
 5041              		.loc 1 2497 0
 5042 2c4c 0010A0E3 		mov	r1, #0
 5043 2c50 00108DE5 		str	r1, [sp]
 5044 2c54 04108DE5 		str	r1, [sp, #4]
 5045 2c58 0A20A0E1 		mov	r2, r10
 5046 2c5c 0930A0E1 		mov	r3, r9
 5047 2c60 0600A0E1 		mov	r0, r6
 5048 2c64 2310A0E3 		mov	r1, #35
 5049 2c68 FEFFFFEB 		bl	cmdSet
 5050              	.LVL544:
 5051              	.L471:
2500:../uvc.c      **** #endif
 5052              		.loc 1 2500 0
 5053 2c6c 1C0096E5 		ldr	r0, [r6, #28]
 5054 2c70 FEFFFFEB 		bl	_txe_mutex_put
 5055              	.LVL545:
2502:../uvc.c      **** 					  break;
 5056              		.loc 1 2502 0
 5057 2c74 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 5058 2c78 1C609DE5 		ldr	r6, [sp, #28]
 5059 2c7c 20809DE5 		ldr	r8, [sp, #32]
 5060 2c80 00108DE5 		str	r1, [sp]
 5061 2c84 0620A0E1 		mov	r2, r6
 5062 2c88 0830A0E1 		mov	r3, r8
 5063 2c8c 0400A0E3 		mov	r0, #4
 5064 2c90 8C159FE5 		ldr	r1, .L480+24
 5065 2c94 FEFFFFEB 		bl	CyU3PDebugPrint
 5066              	.LVL546:
2503:../uvc.c      **** 
 5067              		.loc 1 2503 0
 5068 2c98 FF00A0E3 		mov	r0, #255
 5069 2c9c 74FFFFEA 		b	.L453
 5070              	.LVL547:
 5071              	.L458:
2468:../uvc.c      **** 					  {
 5072              		.loc 1 2468 0
 5073 2ca0 FD05D3E5 		ldrb	r0, [r3, #1533]	@ zero_extendqisi2
 5074 2ca4 64C59FE5 		ldr	ip, .L480+4
 5075 2ca8 010050E3 		cmp	r0, #1
 5076 2cac 08005013 		cmpne	r0, #8
 5077 2cb0 0000A013 		movne	r0, #0
 5078 2cb4 0100A003 		moveq	r0, #1
 5079 2cb8 4601001A 		bne	.L468
 5080              	.LVL548:
2471:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 5081              		.loc 1 2471 0
 5082 2cbc 5CB59FE5 		ldr	fp, .L480+20
 5083 2cc0 0010E0E3 		mvn	r1, #0
 5084 2cc4 1C009BE5 		ldr	r0, [fp, #28]
 5085 2cc8 18C08DE5 		str	ip, [sp, #24]
 5086 2ccc FEFFFFEB 		bl	_txe_mutex_get
 5087              	.LVL549:
2472:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5088              		.loc 1 2472 0
 5089 2cd0 1C009DE5 		ldr	r0, [sp, #28]
 5090 2cd4 0010A0E3 		mov	r1, #0
 5091 2cd8 0A20A0E1 		mov	r2, r10
 5092 2cdc 0930A0E1 		mov	r3, r9
 5093 2ce0 00008DE5 		str	r0, [sp]
 5094 2ce4 04108DE5 		str	r1, [sp, #4]
 5095 2ce8 0B00A0E1 		mov	r0, fp
 5096 2cec 2210A0E3 		mov	r1, #34
 5097 2cf0 FEFFFFEB 		bl	cmdSet
 5098              	.LVL550:
2473:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 5099              		.loc 1 2473 0
 5100 2cf4 1C009BE5 		ldr	r0, [fp, #28]
 5101 2cf8 FEFFFFEB 		bl	_txe_mutex_put
 5102              	.LVL551:
2476:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5103              		.loc 1 2476 0
 5104 2cfc 18C09DE5 		ldr	ip, [sp, #24]
 5105 2d00 1C109DE5 		ldr	r1, [sp, #28]
2477:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5106              		.loc 1 2477 0
 5107 2d04 20209DE5 		ldr	r2, [sp, #32]
2476:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5108              		.loc 1 2476 0
 5109 2d08 066088E0 		add	r6, r8, r6
 5110 2d0c 86C18CE0 		add	ip, ip, r6, asl #3
2478:../uvc.c      **** 					  }else{
 5111              		.loc 1 2478 0
 5112 2d10 0130A0E3 		mov	r3, #1
2476:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5113              		.loc 1 2476 0
 5114 2d14 E515CCE5 		strb	r1, [ip, #1509]
2477:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5115              		.loc 1 2477 0
 5116 2d18 E625CCE5 		strb	r2, [ip, #1510]
2478:../uvc.c      **** 					  }else{
 5117              		.loc 1 2478 0
 5118 2d1c E835CCE5 		strb	r3, [ip, #1512]
 5119              	.LVL552:
 5120              	.L469:
 5121 2d20 2860D4E5 		ldrb	r6, [r4, #40]	@ zero_extendqisi2
 5122 2d24 2980D4E5 		ldrb	r8, [r4, #41]	@ zero_extendqisi2
2485:../uvc.c      **** 			  	  case ZmOpRCtlID10:
 5123              		.loc 1 2485 0
 5124 2d28 FF00A0E3 		mov	r0, #255
 5125 2d2c 50FFFFEA 		b	.L453
 5126              	.LVL553:
 5127              	.L457:
2434:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 5128              		.loc 1 2434 0
 5129 2d30 FD35D3E5 		ldrb	r3, [r3, #1533]	@ zero_extendqisi2
 5130 2d34 010053E3 		cmp	r3, #1
 5131 2d38 04005313 		cmpne	r3, #4
 5132 2d3c 2001001A 		bne	.L466
2433:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 5133              		.loc 1 2433 0
 5134 2d40 1CC09DE5 		ldr	ip, [sp, #28]
 5135 2d44 20009DE5 		ldr	r0, [sp, #32]
 5136 2d48 00348CE1 		orr	r3, ip, r0, asl #8
2435:../uvc.c      **** 					  {
 5137              		.loc 1 2435 0
 5138 2d4c F90053E3 		cmp	r3, #249
 5139 2d50 1B01008A 		bhi	.L466
 5140              	.LVL554:
2440:../uvc.c      **** 							}else{
 5141              		.loc 1 2440 0
 5142 2d54 C80043E2 		sub	r0, r3, #200
 5143 2d58 C80053E3 		cmp	r3, #200
2442:../uvc.c      **** 							}
 5144              		.loc 1 2442 0
 5145 2d5c C82063E2 		rsb	r2, r3, #200
 5146 2d60 C0149FE5 		ldr	r1, .L480+28
 5147 2d64 0208A091 		movls	r0, r2, asl #16
 5148 2d68 0008A081 		movhi	r0, r0, asl #16
 5149 2d6c 642063E2 		rsb	r2, r3, #100
 5150 2d70 640053E3 		cmp	r3, #100
2440:../uvc.c      **** 							}else{
 5151              		.loc 1 2440 0
 5152 2d74 64C043E2 		sub	ip, r3, #100
 5153 2d78 2008A0E1 		mov	r0, r0, lsr #16
 5154 2d7c 0C28A081 		movhi	r2, ip, asl #16
 5155 2d80 0228A091 		movls	r2, r2, asl #16
 5156 2d84 010050E1 		cmp	r0, r1
 5157 2d88 00E0A031 		movcc	lr, r0
 5158 2d8c 01E0A021 		movcs	lr, r1
 5159 2d90 010050E1 		cmp	r0, r1
 5160 2d94 27C043E2 		sub	ip, r3, #39
2442:../uvc.c      **** 							}
 5161              		.loc 1 2442 0
 5162 2d98 271063E2 		rsb	r1, r3, #39
 5163 2d9c 00B0A033 		movcc	fp, #0
 5164 2da0 01B0A023 		movcs	fp, #1
 5165 2da4 270053E3 		cmp	r3, #39
2440:../uvc.c      **** 							}else{
 5166              		.loc 1 2440 0
 5167 2da8 140043E2 		sub	r0, r3, #20
 5168 2dac 01C8A091 		movls	ip, r1, asl #16
 5169 2db0 2228A0E1 		mov	r2, r2, lsr #16
2442:../uvc.c      **** 							}
 5170              		.loc 1 2442 0
 5171 2db4 141063E2 		rsb	r1, r3, #20
 5172 2db8 0CC8A081 		movhi	ip, ip, asl #16
 5173 2dbc 140053E3 		cmp	r3, #20
 5174 2dc0 0018A081 		movhi	r1, r0, asl #16
 5175 2dc4 0118A091 		movls	r1, r1, asl #16
 5176 2dc8 0E0052E1 		cmp	r2, lr
2440:../uvc.c      **** 							}else{
 5177              		.loc 1 2440 0
 5178 2dcc 0A0043E2 		sub	r0, r3, #10
 5179 2dd0 01B0A033 		movcc	fp, #1
 5180 2dd4 2CC8A0E1 		mov	ip, ip, lsr #16
 5181 2dd8 02005EE1 		cmp	lr, r2
 5182 2ddc 0E20A031 		movcc	r2, lr
 5183 2de0 0A0053E3 		cmp	r3, #10
 5184 2de4 21E8A0E1 		mov	lr, r1, lsr #16
2442:../uvc.c      **** 							}
 5185              		.loc 1 2442 0
 5186 2de8 0A1063E2 		rsb	r1, r3, #10
 5187 2dec 0118A091 		movls	r1, r1, asl #16
 5188 2df0 0018A081 		movhi	r1, r0, asl #16
 5189 2df4 0C0052E1 		cmp	r2, ip
 5190 2df8 02B0A083 		movhi	fp, #2
 5191 2dfc 24B08DE5 		str	fp, [sp, #36]
2440:../uvc.c      **** 							}else{
 5192              		.loc 1 2440 0
 5193 2e00 050043E2 		sub	r0, r3, #5
 5194 2e04 02005CE1 		cmp	ip, r2
 5195 2e08 0C20A031 		movcc	r2, ip
 5196 2e0c 21B8A0E1 		mov	fp, r1, lsr #16
2442:../uvc.c      **** 							}
 5197              		.loc 1 2442 0
 5198 2e10 05C063E2 		rsb	ip, r3, #5
 5199 2e14 050053E3 		cmp	r3, #5
 5200 2e18 24109DE5 		ldr	r1, [sp, #36]
 5201 2e1c 00C8A081 		movhi	ip, r0, asl #16
 5202 2e20 0CC8A091 		movls	ip, ip, asl #16
 5203 2e24 0E0052E1 		cmp	r2, lr
 5204 2e28 0310A083 		movhi	r1, #3
 5205 2e2c 24108DE5 		str	r1, [sp, #36]
 5206 2e30 02005EE1 		cmp	lr, r2
 5207 2e34 0E00A031 		movcc	r0, lr
 5208 2e38 0200A021 		movcs	r0, r2
 5209 2e3c 021063E2 		rsb	r1, r3, #2
2440:../uvc.c      **** 							}else{
 5210              		.loc 1 2440 0
 5211 2e40 022043E2 		sub	r2, r3, #2
 5212 2e44 020053E3 		cmp	r3, #2
 5213 2e48 0128A091 		movls	r2, r1, asl #16
 5214 2e4c 0228A081 		movhi	r2, r2, asl #16
 5215 2e50 0B0050E1 		cmp	r0, fp
 5216 2e54 24E09DE5 		ldr	lr, [sp, #36]
 5217 2e58 2CC8A0E1 		mov	ip, ip, lsr #16
 5218 2e5c 04E0A083 		movhi	lr, #4
 5219 2e60 00005BE1 		cmp	fp, r0
 5220 2e64 0B00A031 		movcc	r0, fp
 5221 2e68 00005CE1 		cmp	ip, r0
 5222 2e6c 0C10A031 		movcc	r1, ip
 5223 2e70 0010A021 		movcs	r1, r0
 5224 2e74 0C0050E1 		cmp	r0, ip
 5225 2e78 05E0A083 		movhi	lr, #5
 5226 2e7c 01C043E2 		sub	ip, r3, #1
 5227 2e80 010053E3 		cmp	r3, #1
2442:../uvc.c      **** 							}
 5228              		.loc 1 2442 0
 5229 2e84 010063E2 		rsb	r0, r3, #1
 5230 2e88 0C38A081 		movhi	r3, ip, asl #16
2452:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 5231              		.loc 1 2452 0
 5232 2e8c 8CC39FE5 		ldr	ip, .L480+20
 5233 2e90 2228A0E1 		mov	r2, r2, lsr #16
 5234 2e94 0038A091 		movls	r3, r0, asl #16
 5235 2e98 010052E1 		cmp	r2, r1
 5236 2e9c 0200A031 		movcc	r0, r2
 5237 2ea0 0100A021 		movcs	r0, r1
 5238 2ea4 020051E1 		cmp	r1, r2
 5239 2ea8 0E20A091 		movls	r2, lr
 5240 2eac 0620A083 		movhi	r2, #6
 5241              	.LVL555:
 5242 2eb0 0010E0E3 		mvn	r1, #0
 5243              	.LVL556:
 5244 2eb4 230850E1 		cmp	r0, r3, lsr #16
 5245 2eb8 1C009CE5 		ldr	r0, [ip, #28]
 5246 2ebc 02B0A091 		movls	fp, r2
 5247 2ec0 07B0A083 		movhi	fp, #7
 5248              	.LVL557:
 5249 2ec4 18C08DE5 		str	ip, [sp, #24]
 5250 2ec8 FEFFFFEB 		bl	_txe_mutex_get
 5251              	.LVL558:
2453:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5252              		.loc 1 2453 0
 5253 2ecc 18C09DE5 		ldr	ip, [sp, #24]
2449:../uvc.c      **** 
 5254              		.loc 1 2449 0
 5255 2ed0 01B08BE2 		add	fp, fp, #1
 5256              	.LVL559:
2453:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5257              		.loc 1 2453 0
 5258 2ed4 0010A0E3 		mov	r1, #0
 5259 2ed8 0A20A0E1 		mov	r2, r10
 5260 2edc 0930A0E1 		mov	r3, r9
 5261 2ee0 0C00A0E1 		mov	r0, ip
 5262 2ee4 04108DE5 		str	r1, [sp, #4]
 5263 2ee8 00B08DE5 		str	fp, [sp]
 5264 2eec 0310A0E3 		mov	r1, #3
 5265 2ef0 FEFFFFEB 		bl	cmdSet
 5266              	.LVL560:
2454:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 5267              		.loc 1 2454 0
 5268 2ef4 18C09DE5 		ldr	ip, [sp, #24]
 5269 2ef8 1C009CE5 		ldr	r0, [ip, #28]
 5270 2efc FEFFFFEB 		bl	_txe_mutex_put
 5271              	.LVL561:
2460:../uvc.c      **** 					  }else{
 5272              		.loc 1 2460 0
 5273 2f00 08C39FE5 		ldr	ip, .L480+4
2457:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5274              		.loc 1 2457 0
 5275 2f04 04239FE5 		ldr	r2, .L480+4
2460:../uvc.c      **** 					  }else{
 5276              		.loc 1 2460 0
 5277 2f08 79B3CCE5 		strb	fp, [ip, #889]
2457:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5278              		.loc 1 2457 0
 5279 2f0c 1CC09DE5 		ldr	ip, [sp, #28]
 5280 2f10 063088E0 		add	r3, r8, r6
 5281 2f14 833182E0 		add	r3, r2, r3, asl #3
 5282 2f18 E5C5C3E5 		strb	ip, [r3, #1509]
2458:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5283              		.loc 1 2458 0
 5284 2f1c 20C09DE5 		ldr	ip, [sp, #32]
2459:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5285              		.loc 1 2459 0
 5286 2f20 0120A0E3 		mov	r2, #1
2458:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5287              		.loc 1 2458 0
 5288 2f24 E6C5C3E5 		strb	ip, [r3, #1510]
2459:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5289              		.loc 1 2459 0
 5290 2f28 E825C3E5 		strb	r2, [r3, #1512]
2460:../uvc.c      **** 					  }else{
 5291              		.loc 1 2460 0
 5292 2f2c 7BFFFFEA 		b	.L469
 5293              	.LVL562:
 5294              	.L455:
2391:../uvc.c      **** 						case 1:
 5295              		.loc 1 2391 0
 5296 2f30 1CC09DE5 		ldr	ip, [sp, #28]
2387:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5297              		.loc 1 2387 0
 5298 2f34 066088E0 		add	r6, r8, r6
 5299 2f38 866183E0 		add	r6, r3, r6, asl #3
2388:../uvc.c      **** 				    getData = glEp0Buffer[0];
 5300              		.loc 1 2388 0
 5301 2f3c 0110A0E3 		mov	r1, #1
2391:../uvc.c      **** 						case 1:
 5302              		.loc 1 2391 0
 5303 2f40 01204CE2 		sub	r2, ip, #1
2387:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5304              		.loc 1 2387 0
 5305 2f44 E5C5C6E5 		strb	ip, [r6, #1509]
2388:../uvc.c      **** 				    getData = glEp0Buffer[0];
 5306              		.loc 1 2388 0
 5307 2f48 E815C6E5 		strb	r1, [r6, #1512]
 5308              	.LVL563:
2391:../uvc.c      **** 						case 1:
 5309              		.loc 1 2391 0
 5310 2f4c 070052E3 		cmp	r2, #7
 5311 2f50 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 5312 2f54 960000EA 		b	.L460
 5313              	.L462:
 5314 2f58 50310000 		.word	.L461
 5315 2f5c B4300000 		.word	.L463
 5316 2f60 B4310000 		.word	.L460
 5317 2f64 4C300000 		.word	.L464
 5318 2f68 B4310000 		.word	.L460
 5319 2f6c B4310000 		.word	.L460
 5320 2f70 B4310000 		.word	.L460
 5321 2f74 AC2F0000 		.word	.L465
 5322              	.LVL564:
 5323              	.L454:
2506:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5324              		.loc 1 2506 0
 5325 2f78 1CC09DE5 		ldr	ip, [sp, #28]
 5326 2f7c 068088E0 		add	r8, r8, r6
 5327 2f80 888183E0 		add	r8, r3, r8, asl #3
2507:../uvc.c      **** 			  		 break;
 5328              		.loc 1 2507 0
 5329 2f84 0620A0E1 		mov	r2, r6
 5330 2f88 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 5331 2f8c 0400A0E3 		mov	r0, #4
 5332 2f90 94129FE5 		ldr	r1, .L480+32
2506:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5333              		.loc 1 2506 0
 5334 2f94 E5C5C8E5 		strb	ip, [r8, #1509]
2507:../uvc.c      **** 			  		 break;
 5335              		.loc 1 2507 0
 5336 2f98 FEFFFFEB 		bl	CyU3PDebugPrint
 5337              	.LVL565:
2508:../uvc.c      **** 			  }
 5338              		.loc 1 2508 0
 5339 2f9c FF00A0E3 		mov	r0, #255
 5340 2fa0 0080A0E1 		mov	r8, r0
 5341 2fa4 0060A0E1 		mov	r6, r0
 5342 2fa8 B1FEFFEA 		b	.L453
 5343              	.LVL566:
 5344              	.L465:
2410:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5345              		.loc 1 2410 0
 5346 2fac 6C629FE5 		ldr	r6, .L480+20
2408:../uvc.c      **** 			  		    	dataIdx = 0;
 5347              		.loc 1 2408 0
 5348 2fb0 0080A0E3 		mov	r8, #0
2410:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5349              		.loc 1 2410 0
 5350 2fb4 1C0096E5 		ldr	r0, [r6, #28]
 5351 2fb8 0010E0E3 		mvn	r1, #0
2408:../uvc.c      **** 			  		    	dataIdx = 0;
 5352              		.loc 1 2408 0
 5353 2fbc 7983C3E5 		strb	r8, [r3, #889]
 5354              	.LVL567:
2410:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5355              		.loc 1 2410 0
 5356 2fc0 FEFFFFEB 		bl	_txe_mutex_get
 5357              	.LVL568:
2411:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5358              		.loc 1 2411 0
 5359 2fc4 0A20A0E1 		mov	r2, r10
 5360 2fc8 0930A0E1 		mov	r3, r9
 5361 2fcc 1010A0E3 		mov	r1, #16
 5362 2fd0 00808DE5 		str	r8, [sp]
 5363 2fd4 04808DE5 		str	r8, [sp, #4]
 5364 2fd8 0600A0E1 		mov	r0, r6
 5365 2fdc FEFFFFEB 		bl	cmdSet
 5366              	.LVL569:
2412:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
 5367              		.loc 1 2412 0
 5368 2fe0 1C0096E5 		ldr	r0, [r6, #28]
 5369 2fe4 FEFFFFEB 		bl	_txe_mutex_put
 5370              	.LVL570:
 5371              	.LBB82:
 5372              	.LBB83:
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5373              		.loc 1 1278 0
 5374 2fe8 1C0096E5 		ldr	r0, [r6, #28]
 5375 2fec 0010E0E3 		mvn	r1, #0
 5376 2ff0 FEFFFFEB 		bl	_txe_mutex_get
 5377              	.LVL571:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5378              		.loc 1 1279 0
 5379 2ff4 0130A0E3 		mov	r3, #1
 5380 2ff8 04808DE5 		str	r8, [sp, #4]
 5381 2ffc 0600A0E1 		mov	r0, r6
 5382 3000 00308DE5 		str	r3, [sp]
 5383 3004 2010A0E3 		mov	r1, #32
 5384 3008 2720A0E3 		mov	r2, #39
 5385 300c 3030A0E3 		mov	r3, #48
 5386 3010 FEFFFFEB 		bl	cmdSet
 5387              	.LVL572:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5388              		.loc 1 1280 0
 5389 3014 0230A0E3 		mov	r3, #2
 5390 3018 04808DE5 		str	r8, [sp, #4]
 5391 301c 0600A0E1 		mov	r0, r6
 5392 3020 00308DE5 		str	r3, [sp]
 5393 3024 2110A0E3 		mov	r1, #33
 5394 3028 2520A0E3 		mov	r2, #37
 5395 302c 3030A0E3 		mov	r3, #48
 5396 3030 FEFFFFEB 		bl	cmdSet
 5397              	.LVL573:
1281:../uvc.c      **** }
 5398              		.loc 1 1281 0
 5399 3034 1C0096E5 		ldr	r0, [r6, #28]
 5400 3038 FEFFFFEB 		bl	_txe_mutex_put
 5401              	.LVL574:
 5402 303c FF00A0E3 		mov	r0, #255
 5403 3040 0080A0E1 		mov	r8, r0
 5404 3044 0860A0E3 		mov	r6, #8
 5405 3048 89FEFFEA 		b	.L453
 5406              	.LVL575:
 5407              	.L464:
 5408              	.LBE83:
 5409              	.LBE82:
 5410              	.LBB84:
 5411              	.LBB85:
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5412              		.loc 1 1278 0
 5413 304c CC619FE5 		ldr	r6, .L480+20
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5414              		.loc 1 1279 0
 5415 3050 0080A0E3 		mov	r8, #0
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5416              		.loc 1 1278 0
 5417 3054 0010E0E3 		mvn	r1, #0
 5418 3058 1C0096E5 		ldr	r0, [r6, #28]
 5419 305c FEFFFFEB 		bl	_txe_mutex_get
 5420              	.LVL576:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5421              		.loc 1 1279 0
 5422 3060 0600A0E1 		mov	r0, r6
 5423 3064 00808DE5 		str	r8, [sp]
 5424 3068 04808DE5 		str	r8, [sp, #4]
 5425 306c 2010A0E3 		mov	r1, #32
 5426 3070 2720A0E3 		mov	r2, #39
 5427 3074 3030A0E3 		mov	r3, #48
 5428 3078 FEFFFFEB 		bl	cmdSet
 5429              	.LVL577:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5430              		.loc 1 1280 0
 5431 307c 0130A0E3 		mov	r3, #1
 5432 3080 04808DE5 		str	r8, [sp, #4]
 5433 3084 0600A0E1 		mov	r0, r6
 5434 3088 00308DE5 		str	r3, [sp]
 5435 308c 2110A0E3 		mov	r1, #33
 5436 3090 2520A0E3 		mov	r2, #37
 5437 3094 3030A0E3 		mov	r3, #48
 5438 3098 FEFFFFEB 		bl	cmdSet
 5439              	.LVL578:
1281:../uvc.c      **** }
 5440              		.loc 1 1281 0
 5441 309c 1C0096E5 		ldr	r0, [r6, #28]
 5442 30a0 FEFFFFEB 		bl	_txe_mutex_put
 5443              	.LVL579:
 5444 30a4 FF00A0E3 		mov	r0, #255
 5445 30a8 0080A0E1 		mov	r8, r0
 5446 30ac 0460A0E3 		mov	r6, #4
 5447 30b0 6FFEFFEA 		b	.L453
 5448              	.LVL580:
 5449              	.L463:
 5450              	.LBE85:
 5451              	.LBE84:
2398:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5452              		.loc 1 2398 0
 5453 30b4 64619FE5 		ldr	r6, .L480+20
2396:../uvc.c      **** 							dataIdx = 0;
 5454              		.loc 1 2396 0
 5455 30b8 0080A0E3 		mov	r8, #0
2398:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5456              		.loc 1 2398 0
 5457 30bc 1C0096E5 		ldr	r0, [r6, #28]
 5458 30c0 0010E0E3 		mvn	r1, #0
2396:../uvc.c      **** 							dataIdx = 0;
 5459              		.loc 1 2396 0
 5460 30c4 7983C3E5 		strb	r8, [r3, #889]
 5461              	.LVL581:
2398:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5462              		.loc 1 2398 0
 5463 30c8 FEFFFFEB 		bl	_txe_mutex_get
 5464              	.LVL582:
2399:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5465              		.loc 1 2399 0
 5466 30cc 0A20A0E1 		mov	r2, r10
 5467 30d0 0930A0E1 		mov	r3, r9
 5468 30d4 1010A0E3 		mov	r1, #16
 5469 30d8 00808DE5 		str	r8, [sp]
 5470 30dc 04808DE5 		str	r8, [sp, #4]
 5471 30e0 0600A0E1 		mov	r0, r6
 5472 30e4 FEFFFFEB 		bl	cmdSet
 5473              	.LVL583:
2400:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
 5474              		.loc 1 2400 0
 5475 30e8 1C0096E5 		ldr	r0, [r6, #28]
 5476 30ec FEFFFFEB 		bl	_txe_mutex_put
 5477              	.LVL584:
 5478              	.LBB86:
 5479              	.LBB87:
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5480              		.loc 1 1278 0
 5481 30f0 1C0096E5 		ldr	r0, [r6, #28]
 5482 30f4 0010E0E3 		mvn	r1, #0
 5483 30f8 FEFFFFEB 		bl	_txe_mutex_get
 5484              	.LVL585:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5485              		.loc 1 1279 0
 5486 30fc 00808DE5 		str	r8, [sp]
 5487 3100 04808DE5 		str	r8, [sp, #4]
 5488 3104 0600A0E1 		mov	r0, r6
 5489 3108 2010A0E3 		mov	r1, #32
 5490 310c 2720A0E3 		mov	r2, #39
 5491 3110 3030A0E3 		mov	r3, #48
 5492 3114 FEFFFFEB 		bl	cmdSet
 5493              	.LVL586:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5494              		.loc 1 1280 0
 5495 3118 0130A0E3 		mov	r3, #1
 5496 311c 04808DE5 		str	r8, [sp, #4]
 5497 3120 0600A0E1 		mov	r0, r6
 5498 3124 00308DE5 		str	r3, [sp]
 5499 3128 2110A0E3 		mov	r1, #33
 5500 312c 2520A0E3 		mov	r2, #37
 5501 3130 3030A0E3 		mov	r3, #48
 5502 3134 FEFFFFEB 		bl	cmdSet
 5503              	.LVL587:
1281:../uvc.c      **** }
 5504              		.loc 1 1281 0
 5505 3138 1C0096E5 		ldr	r0, [r6, #28]
 5506 313c FEFFFFEB 		bl	_txe_mutex_put
 5507              	.LVL588:
 5508 3140 FF00A0E3 		mov	r0, #255
 5509 3144 0080A0E1 		mov	r8, r0
 5510 3148 0260A0E3 		mov	r6, #2
 5511 314c 48FEFFEA 		b	.L453
 5512              	.LVL589:
 5513              	.L461:
 5514              	.LBE87:
 5515              	.LBE86:
 5516              	.LBB88:
 5517              	.LBB89:
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5518              		.loc 1 1278 0
 5519 3150 C8809FE5 		ldr	r8, .L480+20
 5520 3154 0010E0E3 		mvn	r1, #0
 5521 3158 1C0098E5 		ldr	r0, [r8, #28]
 5522 315c FEFFFFEB 		bl	_txe_mutex_get
 5523              	.LVL590:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5524              		.loc 1 1279 0
 5525 3160 0090A0E3 		mov	r9, #0
 5526              	.LVL591:
 5527 3164 0160A0E3 		mov	r6, #1
 5528 3168 0800A0E1 		mov	r0, r8
 5529 316c 2010A0E3 		mov	r1, #32
 5530 3170 2720A0E3 		mov	r2, #39
 5531 3174 3030A0E3 		mov	r3, #48
 5532 3178 40028DE8 		stmia	sp, {r6, r9}
 5533 317c FEFFFFEB 		bl	cmdSet
 5534              	.LVL592:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5535              		.loc 1 1280 0
 5536 3180 0230A0E3 		mov	r3, #2
 5537 3184 0800A0E1 		mov	r0, r8
 5538 3188 00308DE5 		str	r3, [sp]
 5539 318c 2110A0E3 		mov	r1, #33
 5540 3190 2520A0E3 		mov	r2, #37
 5541 3194 3030A0E3 		mov	r3, #48
 5542 3198 04908DE5 		str	r9, [sp, #4]
 5543 319c FEFFFFEB 		bl	cmdSet
 5544              	.LVL593:
1281:../uvc.c      **** }
 5545              		.loc 1 1281 0
 5546 31a0 1C0098E5 		ldr	r0, [r8, #28]
 5547 31a4 FEFFFFEB 		bl	_txe_mutex_put
 5548              	.LVL594:
 5549 31a8 FF00A0E3 		mov	r0, #255
 5550 31ac 0080A0E1 		mov	r8, r0
 5551 31b0 2FFEFFEA 		b	.L453
 5552              	.LVL595:
 5553              	.L460:
 5554              	.LBE89:
 5555              	.LBE88:
2391:../uvc.c      **** 						case 1:
 5556              		.loc 1 2391 0
 5557 31b4 FF00A0E3 		mov	r0, #255
 5558 31b8 0C60A0E1 		mov	r6, ip
 5559 31bc 0080A0E1 		mov	r8, r0
 5560 31c0 2BFEFFEA 		b	.L453
 5561              	.LVL596:
 5562              	.L466:
2462:../uvc.c      **** 					  }
 5563              		.loc 1 2462 0
 5564 31c4 0000A0E3 		mov	r0, #0
 5565 31c8 0020A0E1 		mov	r2, r0
 5566 31cc 0110A0E3 		mov	r1, #1
 5567 31d0 FEFFFFEB 		bl	CyU3PUsbStall
 5568              	.LVL597:
 5569 31d4 D1FEFFEA 		b	.L469
 5570              	.LVL598:
 5571              	.L468:
2480:../uvc.c      **** 					  }
 5572              		.loc 1 2480 0
 5573 31d8 0020A0E1 		mov	r2, r0
 5574 31dc 0110A0E3 		mov	r1, #1
 5575 31e0 FEFFFFEB 		bl	CyU3PUsbStall
 5576              	.LVL599:
 5577 31e4 CDFEFFEA 		b	.L469
 5578              	.LVL600:
 5579              	.L479:
2495:../uvc.c      **** 					  else
 5580              		.loc 1 2495 0
 5581 31e8 0800A0E3 		mov	r0, #8
 5582              	.L476:
 5583 31ec 0010A0E3 		mov	r1, #0
 5584 31f0 03008DE8 		stmia	sp, {r0, r1}
 5585 31f4 0A20A0E1 		mov	r2, r10
 5586 31f8 0930A0E1 		mov	r3, r9
 5587 31fc 0600A0E1 		mov	r0, r6
 5588 3200 2310A0E3 		mov	r1, #35
 5589 3204 FEFFFFEB 		bl	cmdSet
 5590              	.LVL601:
 5591 3208 97FEFFEA 		b	.L471
 5592              	.L481:
 5593              		.align	2
 5594              	.L480:
 5595 320c 00000000 		.word	bRequest
 5596 3210 00000000 		.word	.LANCHOR1
 5597 3214 00000000 		.word	.LANCHOR0
 5598 3218 EC060000 		.word	.LC39
 5599 321c C8060000 		.word	.LC38
 5600 3220 00000000 		.word	cmdQu
 5601 3224 7C060000 		.word	.LC36
 5602 3228 FFFF0000 		.word	65535
 5603 322c A4060000 		.word	.LC37
 5604              		.cfi_endproc
 5605              	.LFE4:
 5607              		.align	2
 5608              		.global	CamDefSet
 5610              	CamDefSet:
 5611              	.LFB5:
2523:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
 5612              		.loc 1 2523 0
 5613              		.cfi_startproc
 5614              		@ args = 0, pretend = 0, frame = 24
 5615              		@ frame_needed = 0, uses_anonymous_args = 0
 5616              	.LVL602:
 5617 3230 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5618              	.LCFI21:
 5619              		.cfi_def_cfa_offset 36
 5620              		.cfi_offset 4, -36
 5621              		.cfi_offset 5, -32
 5622              		.cfi_offset 6, -28
 5623              		.cfi_offset 7, -24
 5624              		.cfi_offset 8, -20
 5625              		.cfi_offset 9, -16
 5626              		.cfi_offset 10, -12
 5627              		.cfi_offset 11, -8
 5628              		.cfi_offset 14, -4
2530:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5629              		.loc 1 2530 0
 5630 3234 B0429FE5 		ldr	r4, .L485
2535:../uvc.c      ****     if(Data1&0x80){
 5631              		.loc 1 2535 0
 5632 3238 B0229FE5 		ldr	r2, .L485+4
2532:../uvc.c      ****     Data1 = Data0;
 5633              		.loc 1 2532 0
 5634 323c 0F52D4E5 		ldrb	r5, [r4, #527]	@ zero_extendqisi2
2523:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
 5635              		.loc 1 2523 0
 5636 3240 2CD04DE2 		sub	sp, sp, #44
 5637              	.LCFI22:
 5638              		.cfi_def_cfa_offset 80
2535:../uvc.c      ****     if(Data1&0x80){
 5639              		.loc 1 2535 0
 5640 3244 1C0092E5 		ldr	r0, [r2, #28]
 5641 3248 0010E0E3 		mvn	r1, #0
2537:../uvc.c      ****     }else{
 5642              		.loc 1 2537 0
 5643 324c 2563A0E1 		mov	r6, r5, lsr #6
2531:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5644              		.loc 1 2531 0
 5645 3250 1372D4E5 		ldrb	r7, [r4, #531]	@ zero_extendqisi2
2530:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5646              		.loc 1 2530 0
 5647 3254 0592D4E5 		ldrb	r9, [r4, #517]	@ zero_extendqisi2
 5648              	.LVL603:
2535:../uvc.c      ****     if(Data1&0x80){
 5649              		.loc 1 2535 0
 5650 3258 FEFFFFEB 		bl	_txe_mutex_get
 5651              	.LVL604:
2536:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5652              		.loc 1 2536 0
 5653 325c 800015E3 		tst	r5, #128
2537:../uvc.c      ****     }else{
 5654              		.loc 1 2537 0
 5655 3260 01600612 		andne	r6, r6, #1
 5656 3264 0660E011 		mvnne	r6, r6
 5657 3268 3B600612 		andne	r6, r6, #59
 5658 326c 0660E011 		mvnne	r6, r6
 5659 3270 FF600612 		andne	r6, r6, #255
 5660              	.LVL605:
2539:../uvc.c      ****     }
 5661              		.loc 1 2539 0
 5662 3274 C6608603 		orreq	r6, r6, #198
 5663              	.LVL606:
2543:../uvc.c      **** 
 5664              		.loc 1 2543 0
 5665 3278 0080A0E3 		mov	r8, #0
2541:../uvc.c      **** 
 5666              		.loc 1 2541 0
 5667 327c 0551A0E1 		mov	r5, r5, asl #2
 5668              	.LVL607:
 5669 3280 FF5005E2 		and	r5, r5, #255
 5670              	.LVL608:
2546:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5671              		.loc 1 2546 0
 5672 3284 01A0A0E3 		mov	r10, #1
2543:../uvc.c      **** 
 5673              		.loc 1 2543 0
 5674 3288 00608DE5 		str	r6, [sp]
 5675 328c 0920A0E1 		mov	r2, r9
 5676 3290 0730A0E1 		mov	r3, r7
 5677 3294 04808DE5 		str	r8, [sp, #4]
 5678 3298 0110A0E3 		mov	r1, #1
 5679 329c 4C029FE5 		ldr	r0, .L485+4
 5680 32a0 FEFFFFEB 		bl	cmdSet
 5681              	.LVL609:
2546:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5682              		.loc 1 2546 0
 5683 32a4 0422D4E5 		ldrb	r2, [r4, #516]	@ zero_extendqisi2
 5684 32a8 0730A0E1 		mov	r3, r7
 5685 32ac 0A10A0E1 		mov	r1, r10
 5686 32b0 00508DE5 		str	r5, [sp]
 5687 32b4 04A08DE5 		str	r10, [sp, #4]
 5688 32b8 30029FE5 		ldr	r0, .L485+4
 5689 32bc FEFFFFEB 		bl	cmdSet
 5690              	.LVL610:
2549:../uvc.c      **** 
 5691              		.loc 1 2549 0
 5692 32c0 0620A0E1 		mov	r2, r6
 5693 32c4 0530A0E1 		mov	r3, r5
 5694 32c8 24129FE5 		ldr	r1, .L485+8
 5695 32cc 0400A0E3 		mov	r0, #4
2548:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5696              		.loc 1 2548 0
 5697 32d0 1262C4E5 		strb	r6, [r4, #530]
2547:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5698              		.loc 1 2547 0
 5699 32d4 1152C4E5 		strb	r5, [r4, #529]
2549:../uvc.c      **** 
 5700              		.loc 1 2549 0
 5701 32d8 FEFFFFEB 		bl	CyU3PDebugPrint
 5702              	.LVL611:
2554:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5703              		.loc 1 2554 0
 5704 32dc 2762D4E5 		ldrb	r6, [r4, #551]	@ zero_extendqisi2
 5705              	.LVL612:
2555:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5706              		.loc 1 2555 0
 5707 32e0 1C22D4E5 		ldrb	r2, [r4, #540]	@ zero_extendqisi2
 5708 32e4 2B32D4E5 		ldrb	r3, [r4, #555]	@ zero_extendqisi2
 5709 32e8 40018DE8 		stmia	sp, {r6, r8}
 5710 32ec FC019FE5 		ldr	r0, .L485+4
 5711 32f0 0210A0E3 		mov	r1, #2
 5712 32f4 FEFFFFEB 		bl	cmdSet
 5713              	.LVL613:
2558:../uvc.c      **** 
 5714              		.loc 1 2558 0
 5715 32f8 0620A0E1 		mov	r2, r6
 5716 32fc 0530A0E1 		mov	r3, r5
 5717 3300 EC119FE5 		ldr	r1, .L485+8
 5718 3304 0400A0E3 		mov	r0, #4
2556:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
 5719              		.loc 1 2556 0
 5720 3308 2952C4E5 		strb	r5, [r4, #553]
2557:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5721              		.loc 1 2557 0
 5722 330c 6954C4E5 		strb	r5, [r4, #1129]
2558:../uvc.c      **** 
 5723              		.loc 1 2558 0
 5724 3310 FEFFFFEB 		bl	CyU3PDebugPrint
 5725              	.LVL614:
2563:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5726              		.loc 1 2563 0
 5727 3314 6F72D4E5 		ldrb	r7, [r4, #623]	@ zero_extendqisi2
2562:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5728              		.loc 1 2562 0
 5729 3318 7362D4E5 		ldrb	r6, [r4, #627]	@ zero_extendqisi2
 5730              	.LVL615:
2564:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5731              		.loc 1 2564 0
 5732 331c 80C047E2 		sub	ip, r7, #128
 5733 3320 FF300CE2 		and	r3, ip, #255
2565:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5734              		.loc 1 2565 0
 5735 3324 76E047E2 		sub	lr, r7, #118
2564:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5736              		.loc 1 2564 0
 5737 3328 18308DE5 		str	r3, [sp, #24]
 5738 332c 08018DE8 		stmia	sp, {r3, r8}
 5739 3330 B8019FE5 		ldr	r0, .L485+4
 5740 3334 0630A0E1 		mov	r3, r6
 5741 3338 0510A0E3 		mov	r1, #5
 5742 333c DF20A0E3 		mov	r2, #223
 5743 3340 14C08DE5 		str	ip, [sp, #20]
2565:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5744              		.loc 1 2565 0
 5745 3344 1CE08DE5 		str	lr, [sp, #28]
2564:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5746              		.loc 1 2564 0
 5747 3348 FEFFFFEB 		bl	cmdSet
 5748              	.LVL616:
2565:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5749              		.loc 1 2565 0
 5750 334c 1C209DE5 		ldr	r2, [sp, #28]
2566:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5751              		.loc 1 2566 0
 5752 3350 7EE087E2 		add	lr, r7, #126
2565:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5753              		.loc 1 2565 0
 5754 3354 FF3002E2 		and	r3, r2, #255
 5755 3358 08048DE8 		stmia	sp, {r3, r10}
 5756 335c 8C019FE5 		ldr	r0, .L485+4
 5757 3360 0630A0E1 		mov	r3, r6
 5758 3364 0510A0E3 		mov	r1, #5
 5759 3368 DC20A0E3 		mov	r2, #220
2566:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5760              		.loc 1 2566 0
 5761 336c 20E08DE5 		str	lr, [sp, #32]
2565:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5762              		.loc 1 2565 0
 5763 3370 FEFFFFEB 		bl	cmdSet
 5764              	.LVL617:
2566:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5765              		.loc 1 2566 0
 5766 3374 20209DE5 		ldr	r2, [sp, #32]
2567:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5767              		.loc 1 2567 0
 5768 3378 72E087E2 		add	lr, r7, #114
2566:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5769              		.loc 1 2566 0
 5770 337c FF3002E2 		and	r3, r2, #255
 5771 3380 0220A0E3 		mov	r2, #2
 5772 3384 00308DE5 		str	r3, [sp]
 5773 3388 04208DE5 		str	r2, [sp, #4]
 5774 338c 0630A0E1 		mov	r3, r6
 5775 3390 0510A0E3 		mov	r1, #5
 5776 3394 DE20A0E3 		mov	r2, #222
 5777 3398 50019FE5 		ldr	r0, .L485+4
2567:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5778              		.loc 1 2567 0
 5779 339c 24E08DE5 		str	lr, [sp, #36]
2566:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5780              		.loc 1 2566 0
 5781 33a0 FEFFFFEB 		bl	cmdSet
 5782              	.LVL618:
2567:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5783              		.loc 1 2567 0
 5784 33a4 24209DE5 		ldr	r2, [sp, #36]
2568:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5785              		.loc 1 2568 0
 5786 33a8 6FB047E2 		sub	fp, r7, #111
2567:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5787              		.loc 1 2567 0
 5788 33ac FF3002E2 		and	r3, r2, #255
 5789 33b0 0320A0E3 		mov	r2, #3
 5790 33b4 00308DE5 		str	r3, [sp]
 5791 33b8 04208DE5 		str	r2, [sp, #4]
 5792 33bc 0630A0E1 		mov	r3, r6
 5793 33c0 0510A0E3 		mov	r1, #5
 5794 33c4 E020A0E3 		mov	r2, #224
 5795 33c8 20019FE5 		ldr	r0, .L485+4
 5796 33cc FEFFFFEB 		bl	cmdSet
 5797              	.LVL619:
2568:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5798              		.loc 1 2568 0
 5799 33d0 0490A0E3 		mov	r9, #4
 5800 33d4 FF300BE2 		and	r3, fp, #255
2569:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5801              		.loc 1 2569 0
 5802 33d8 7F7087E2 		add	r7, r7, #127
 5803              	.LVL620:
2568:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5804              		.loc 1 2568 0
 5805 33dc 00308DE5 		str	r3, [sp]
 5806 33e0 04908DE5 		str	r9, [sp, #4]
 5807 33e4 0630A0E1 		mov	r3, r6
 5808 33e8 0510A0E3 		mov	r1, #5
 5809 33ec DD20A0E3 		mov	r2, #221
 5810 33f0 F8009FE5 		ldr	r0, .L485+4
 5811 33f4 FEFFFFEB 		bl	cmdSet
 5812              	.LVL621:
2569:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5813              		.loc 1 2569 0
 5814 33f8 FF2007E2 		and	r2, r7, #255
 5815 33fc 0510A0E3 		mov	r1, #5
 5816 3400 0630A0E1 		mov	r3, r6
 5817 3404 00208DE5 		str	r2, [sp]
 5818 3408 04108DE5 		str	r1, [sp, #4]
 5819 340c E120A0E3 		mov	r2, #225
 5820 3410 D8009FE5 		ldr	r0, .L485+4
 5821 3414 FEFFFFEB 		bl	cmdSet
 5822              	.LVL622:
2571:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 5823              		.loc 1 2571 0
 5824 3418 14C09DE5 		ldr	ip, [sp, #20]
 5825 341c 24E09DE5 		ldr	lr, [sp, #36]
 5826 3420 20309DE5 		ldr	r3, [sp, #32]
 5827 3424 0C20A0E1 		mov	r2, ip
2570:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5828              		.loc 1 2570 0
 5829 3428 18C09DE5 		ldr	ip, [sp, #24]
2571:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 5830              		.loc 1 2571 0
 5831 342c 04E08DE5 		str	lr, [sp, #4]
 5832 3430 00308DE5 		str	r3, [sp]
 5833 3434 0C708DE5 		str	r7, [sp, #12]
 5834 3438 1C309DE5 		ldr	r3, [sp, #28]
 5835 343c 08B08DE5 		str	fp, [sp, #8]
 5836 3440 0900A0E1 		mov	r0, r9
 5837 3444 AC109FE5 		ldr	r1, .L485+12
2570:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5838              		.loc 1 2570 0
 5839 3448 71C2C4E5 		strb	ip, [r4, #625]
2571:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 5840              		.loc 1 2571 0
 5841 344c FEFFFFEB 		bl	CyU3PDebugPrint
 5842              	.LVL623:
2576:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5843              		.loc 1 2576 0
 5844 3450 8762D4E5 		ldrb	r6, [r4, #647]	@ zero_extendqisi2
 5845              	.LVL624:
2575:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5846              		.loc 1 2575 0
 5847 3454 8B72D4E5 		ldrb	r7, [r4, #651]	@ zero_extendqisi2
 5848              	.LVL625:
2577:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5849              		.loc 1 2577 0
 5850 3458 00608DE5 		str	r6, [sp]
 5851 345c 0730A0E1 		mov	r3, r7
 5852 3460 04808DE5 		str	r8, [sp, #4]
 5853 3464 0610A0E3 		mov	r1, #6
 5854 3468 8520A0E3 		mov	r2, #133
 5855 346c 7C009FE5 		ldr	r0, .L485+4
 5856 3470 FEFFFFEB 		bl	cmdSet
 5857              	.LVL626:
2578:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5858              		.loc 1 2578 0
 5859 3474 40048DE8 		stmia	sp, {r6, r10}
 5860 3478 70009FE5 		ldr	r0, .L485+4
 5861 347c 0730A0E1 		mov	r3, r7
 5862 3480 0610A0E3 		mov	r1, #6
 5863 3484 8620A0E3 		mov	r2, #134
 5864 3488 FEFFFFEB 		bl	cmdSet
 5865              	.LVL627:
2580:../uvc.c      **** 
 5866              		.loc 1 2580 0
 5867 348c 0620A0E1 		mov	r2, r6
 5868 3490 0530A0E1 		mov	r3, r5
 5869 3494 0900A0E1 		mov	r0, r9
 5870 3498 54109FE5 		ldr	r1, .L485+8
2579:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5871              		.loc 1 2579 0
 5872 349c 8962C4E5 		strb	r6, [r4, #649]
2580:../uvc.c      **** 
 5873              		.loc 1 2580 0
 5874 34a0 FEFFFFEB 		bl	CyU3PDebugPrint
 5875              	.LVL628:
2585:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5876              		.loc 1 2585 0
 5877 34a4 9F62D4E5 		ldrb	r6, [r4, #671]	@ zero_extendqisi2
 5878              	.LVL629:
2586:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5879              		.loc 1 2586 0
 5880 34a8 9422D4E5 		ldrb	r2, [r4, #660]	@ zero_extendqisi2
 5881 34ac A332D4E5 		ldrb	r3, [r4, #675]	@ zero_extendqisi2
 5882 34b0 40018DE8 		stmia	sp, {r6, r8}
 5883 34b4 34009FE5 		ldr	r0, .L485+4
 5884 34b8 0710A0E3 		mov	r1, #7
 5885 34bc FEFFFFEB 		bl	cmdSet
 5886              	.LVL630:
2588:../uvc.c      **** 
 5887              		.loc 1 2588 0
 5888 34c0 0620A0E1 		mov	r2, r6
 5889 34c4 0530A0E1 		mov	r3, r5
 5890 34c8 0900A0E1 		mov	r0, r9
 5891 34cc 20109FE5 		ldr	r1, .L485+8
2587:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5892              		.loc 1 2587 0
 5893 34d0 A152C4E5 		strb	r5, [r4, #673]
2588:../uvc.c      **** 
 5894              		.loc 1 2588 0
 5895 34d4 FEFFFFEB 		bl	CyU3PDebugPrint
 5896              	.LVL631:
2590:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 5897              		.loc 1 2590 0
 5898 34d8 10209FE5 		ldr	r2, .L485+4
 5899 34dc 1C0092E5 		ldr	r0, [r2, #28]
2593:../uvc.c      **** 
 5900              		.loc 1 2593 0
 5901 34e0 2CD08DE2 		add	sp, sp, #44
 5902              		@ sp needed
 5903 34e4 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5904              	.LVL632:
2590:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 5905              		.loc 1 2590 0
 5906 34e8 FEFFFFEA 		b	_txe_mutex_put
 5907              	.LVL633:
 5908              	.L486:
 5909              		.align	2
 5910              	.L485:
 5911 34ec 00000000 		.word	.LANCHOR1
 5912 34f0 00000000 		.word	statQu
 5913 34f4 50070000 		.word	.LC40
 5914 34f8 70070000 		.word	.LC41
 5915              		.cfi_endproc
 5916              	.LFE5:
 5918              		.align	2
 5919              		.global	CyFxUVCAddHeader
 5921              	CyFxUVCAddHeader:
 5922              	.LFB6:
2601:../uvc.c      ****     /* Copy header to buffer */
 5923              		.loc 1 2601 0
 5924              		.cfi_startproc
 5925              		@ args = 0, pretend = 0, frame = 0
 5926              		@ frame_needed = 0, uses_anonymous_args = 0
 5927              	.LVL634:
 5928 34fc 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5929              	.LCFI23:
 5930              		.cfi_def_cfa_offset 16
 5931              		.cfi_offset 3, -16
 5932              		.cfi_offset 4, -12
 5933              		.cfi_offset 5, -8
 5934              		.cfi_offset 14, -4
2601:../uvc.c      ****     /* Copy header to buffer */
 5935              		.loc 1 2601 0
 5936 3500 0040A0E1 		mov	r4, r0
 5937 3504 0150A0E1 		mov	r5, r1
2603:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5938              		.loc 1 2603 0
 5939 3508 30009FE5 		ldr	r0, .L492
 5940              	.LVL635:
 5941 350c 0010E0E3 		mvn	r1, #0
 5942              	.LVL636:
 5943 3510 FEFFFFEB 		bl	_txe_mutex_get
 5944              	.LVL637:
2604:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 5945              		.loc 1 2604 0
 5946 3514 0400A0E1 		mov	r0, r4
 5947 3518 24109FE5 		ldr	r1, .L492+4
 5948 351c 0C20A0E3 		mov	r2, #12
 5949 3520 FEFFFFEB 		bl	CyU3PMemCopy
 5950              	.LVL638:
2605:../uvc.c      **** 
 5951              		.loc 1 2605 0
 5952 3524 14009FE5 		ldr	r0, .L492
 5953 3528 FEFFFFEB 		bl	_txe_mutex_put
 5954              	.LVL639:
2608:../uvc.c      ****     {
 5955              		.loc 1 2608 0
 5956 352c 020015E3 		tst	r5, #2
2610:../uvc.c      ****     }
 5957              		.loc 1 2610 0
 5958 3530 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5959 3534 02308313 		orrne	r3, r3, #2
 5960 3538 0130C415 		strneb	r3, [r4, #1]
 5961 353c 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 5962              	.L493:
 5963              		.align	2
 5964              	.L492:
 5965 3540 00000000 		.word	imgHdMux
 5966 3544 EC040000 		.word	.LANCHOR1+1260
 5967              		.cfi_endproc
 5968              	.LFE6:
 5970              		.align	2
 5971              		.global	CyFxAppErrorHandler
 5973              	CyFxAppErrorHandler:
 5974              	.LFB7:
2620:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
 5975              		.loc 1 2620 0
 5976              		.cfi_startproc
 5977              		@ Volatile: function does not return.
 5978              		@ args = 0, pretend = 0, frame = 0
 5979              		@ frame_needed = 0, uses_anonymous_args = 0
 5980              	.LVL640:
 5981 3548 08402DE9 		stmfd	sp!, {r3, lr}
 5982              	.LCFI24:
 5983              		.cfi_def_cfa_offset 8
 5984              		.cfi_offset 3, -8
 5985              		.cfi_offset 14, -4
 5986              	.LVL641:
 5987              	.L495:
2630:../uvc.c      ****         CyU3PThreadSleep (1000);
 5988              		.loc 1 2630 0 discriminator 1
 5989 354c 10109FE5 		ldr	r1, .L496
 5990 3550 0400A0E3 		mov	r0, #4
 5991 3554 FEFFFFEB 		bl	CyU3PDebugPrint
 5992              	.LVL642:
2631:../uvc.c      ****     }
 5993              		.loc 1 2631 0 discriminator 1
 5994 3558 FA0FA0E3 		mov	r0, #1000
 5995 355c FEFFFFEB 		bl	_tx_thread_sleep
 5996              	.LVL643:
 5997 3560 F9FFFFEA 		b	.L495
 5998              	.L497:
 5999              		.align	2
 6000              	.L496:
 6001 3564 A8070000 		.word	.LC42
 6002              		.cfi_endproc
 6003              	.LFE7:
 6005              		.align	2
 6006              		.global	UVCAppThread_Entry
 6008              	UVCAppThread_Entry:
 6009              	.LFB19:
3607:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
 6010              		.loc 1 3607 0
 6011              		.cfi_startproc
 6012              		@ args = 0, pretend = 0, frame = 128
 6013              		@ frame_needed = 0, uses_anonymous_args = 0
 6014              	.LVL644:
 6015 3568 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 6016              	.LCFI25:
 6017              		.cfi_def_cfa_offset 32
 6018              		.cfi_offset 4, -32
 6019              		.cfi_offset 5, -28
 6020              		.cfi_offset 6, -24
 6021              		.cfi_offset 7, -20
 6022              		.cfi_offset 8, -16
 6023              		.cfi_offset 9, -12
 6024              		.cfi_offset 10, -8
 6025              		.cfi_offset 14, -4
 6026 356c 88D04DE2 		sub	sp, sp, #136
 6027              	.LCFI26:
 6028              		.cfi_def_cfa_offset 168
 6029              	.LBB98:
 6030              	.LBB99:
3063:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6031              		.loc 1 3063 0
 6032 3570 FEFFFFEB 		bl	CyU3PUartInit
 6033              	.LVL645:
3064:../uvc.c      ****     {
 6034              		.loc 1 3064 0
 6035 3574 004050E2 		subs	r4, r0, #0
 6036 3578 2902001A 		bne	.L579
3071:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6037              		.loc 1 3071 0
 6038 357c 582A9FE5 		ldr	r2, .L610
3072:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6039              		.loc 1 3072 0
 6040 3580 0130A0E3 		mov	r3, #1
3080:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6041              		.loc 1 3080 0
 6042 3584 0410A0E1 		mov	r1, r4
 6043 3588 60008DE2 		add	r0, sp, #96
 6044              	.LVL646:
3073:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 6045              		.loc 1 3073 0
 6046 358c 7540CDE5 		strb	r4, [sp, #117]
3075:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 6047              		.loc 1 3075 0
 6048 3590 64408DE5 		str	r4, [sp, #100]
3076:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 6049              		.loc 1 3076 0
 6050 3594 68408DE5 		str	r4, [sp, #104]
3071:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6051              		.loc 1 3071 0
 6052 3598 70208DE5 		str	r2, [sp, #112]
3072:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6053              		.loc 1 3072 0
 6054 359c 7430CDE5 		strb	r3, [sp, #116]
3074:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 6055              		.loc 1 3074 0
 6056 35a0 60308DE5 		str	r3, [sp, #96]
3077:../uvc.c      **** 
 6057              		.loc 1 3077 0
 6058 35a4 6C308DE5 		str	r3, [sp, #108]
3080:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6059              		.loc 1 3080 0
 6060 35a8 FEFFFFEB 		bl	CyU3PUartSetConfig
 6061              	.LVL647:
3081:../uvc.c      ****     {
 6062              		.loc 1 3081 0
 6063 35ac 000050E3 		cmp	r0, #0
 6064 35b0 B201001A 		bne	.L578
3087:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6065              		.loc 1 3087 0
 6066 35b4 0000E0E3 		mvn	r0, #0
 6067              	.LVL648:
 6068 35b8 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 6069              	.LVL649:
3088:../uvc.c      ****     {
 6070              		.loc 1 3088 0
 6071 35bc 000050E3 		cmp	r0, #0
 6072 35c0 AE01001A 		bne	.L578
3094:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6073              		.loc 1 3094 0
 6074 35c4 0300A0E3 		mov	r0, #3
 6075              	.LVL650:
 6076 35c8 0410A0E3 		mov	r1, #4
 6077 35cc FEFFFFEB 		bl	CyU3PDebugInit
 6078              	.LVL651:
3095:../uvc.c      ****     {
 6079              		.loc 1 3095 0
 6080 35d0 000050E3 		cmp	r0, #0
 6081 35d4 A901001A 		bne	.L578
3101:../uvc.c      **** }
 6082              		.loc 1 3101 0
 6083 35d8 FEFFFFEB 		bl	CyU3PDebugPreamble
 6084              	.LVL652:
 6085 35dc 0640A0E3 		mov	r4, #6
 6086              	.LVL653:
 6087              	.L504:
 6088              	.LBE99:
 6089              	.LBE98:
3623:../uvc.c      **** 	}
 6090              		.loc 1 3623 0
 6091 35e0 7D0FA0E3 		mov	r0, #500
 6092 35e4 014044E2 		sub	r4, r4, #1
 6093 35e8 FEFFFFEB 		bl	_tx_thread_sleep
 6094              	.LVL654:
3622:../uvc.c      **** 		CyU3PThreadSleep(500);
 6095              		.loc 1 3622 0
 6096 35ec FF4014E2 		ands	r4, r4, #255
 6097 35f0 FAFFFF1A 		bne	.L504
 6098              	.LBB101:
 6099              	.LBB102:
3111:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 6100              		.loc 1 3111 0
 6101 35f4 FEFFFFEB 		bl	CyU3PI2cInit
 6102              	.LVL655:
3112:../uvc.c      ****     {
 6103              		.loc 1 3112 0
 6104 35f8 005050E2 		subs	r5, r0, #0
 6105 35fc 3002001A 		bne	.L580
3119:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6106              		.loc 1 3119 0
 6107 3600 D8299FE5 		ldr	r2, .L610+4
3121:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6108              		.loc 1 3121 0
 6109 3604 0030E0E3 		mvn	r3, #0
3124:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6110              		.loc 1 3124 0
 6111 3608 60008DE2 		add	r0, sp, #96
 6112              	.LVL656:
 6113 360c 0410A0E1 		mov	r1, r4
3120:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6114              		.loc 1 3120 0
 6115 3610 64408DE5 		str	r4, [sp, #100]
3119:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6116              		.loc 1 3119 0
 6117 3614 60208DE5 		str	r2, [sp, #96]
3121:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6118              		.loc 1 3121 0
 6119 3618 68308DE5 		str	r3, [sp, #104]
3122:../uvc.c      **** 
 6120              		.loc 1 3122 0
 6121 361c BC36CDE1 		strh	r3, [sp, #108]	@ movhi
3124:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6122              		.loc 1 3124 0
 6123 3620 FEFFFFEB 		bl	CyU3PI2cSetConfig
 6124              	.LVL657:
3125:../uvc.c      ****     {
 6125              		.loc 1 3125 0
 6126 3624 005050E2 		subs	r5, r0, #0
 6127 3628 2002001A 		bne	.L581
 6128              	.LBE102:
 6129              	.LBE101:
 6130              	.LBB104:
 6131              	.LBB105:
3198:../uvc.c      ****     if (apiRetStatus != 0)
 6132              		.loc 1 3198 0
 6133 362c B0799FE5 		ldr	r7, .L610+8
 6134 3630 0410A0E1 		mov	r1, r4
 6135 3634 0700A0E1 		mov	r0, r7
 6136              	.LVL658:
 6137 3638 2820A0E3 		mov	r2, #40
 6138 363c FEFFFFEB 		bl	_txe_event_flags_create
 6139              	.LVL659:
3199:../uvc.c      ****     {
 6140              		.loc 1 3199 0
 6141 3640 005050E2 		subs	r5, r0, #0
 6142              	.LVL660:
 6143 3644 1302001A 		bne	.L582
3213:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6144              		.loc 1 3213 0
 6145 3648 0230A0E3 		mov	r3, #2
3216:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6146              		.loc 1 3216 0
 6147 364c 0320A0E3 		mov	r2, #3
3220:../uvc.c      ****     if (apiRetStatus != 0)
 6148              		.loc 1 3220 0
 6149 3650 14008DE2 		add	r0, sp, #20
 6150              	.LVL661:
 6151 3654 0410A0E1 		mov	r1, r4
3209:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 6152              		.loc 1 3209 0
 6153 3658 8C4087E5 		str	r4, [r7, #140]
3210:../uvc.c      **** 
 6154              		.loc 1 3210 0
 6155 365c 904087E5 		str	r4, [r7, #144]
3215:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6156              		.loc 1 3215 0
 6157 3660 1C40CDE5 		strb	r4, [sp, #28]
3217:../uvc.c      **** 
 6158              		.loc 1 3217 0
 6159 3664 18408DE5 		str	r4, [sp, #24]
3213:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6160              		.loc 1 3213 0
 6161 3668 1430CDE5 		strb	r3, [sp, #20]
3214:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 6162              		.loc 1 3214 0
 6163 366c 1530CDE5 		strb	r3, [sp, #21]
3216:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6164              		.loc 1 3216 0
 6165 3670 1D20CDE5 		strb	r2, [sp, #29]
3220:../uvc.c      ****     if (apiRetStatus != 0)
 6166              		.loc 1 3220 0
 6167 3674 FEFFFFEB 		bl	CyU3PGpioInit
 6168              	.LVL662:
3221:../uvc.c      ****     {
 6169              		.loc 1 3221 0
 6170 3678 005050E2 		subs	r5, r0, #0
 6171 367c FF01001A 		bne	.L583
3229:../uvc.c      ****     if (apiRetStatus != 0)
 6172              		.loc 1 3229 0
 6173 3680 1600A0E3 		mov	r0, #22
 6174              	.LVL663:
 6175 3684 0110A0E3 		mov	r1, #1
 6176 3688 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6177              	.LVL664:
3230:../uvc.c      ****     {
 6178              		.loc 1 3230 0
 6179 368c 005050E2 		subs	r5, r0, #0
 6180 3690 3A02001A 		bne	.L584
3235:../uvc.c      ****     if (apiRetStatus != 0)
 6181              		.loc 1 3235 0
 6182 3694 1400A0E3 		mov	r0, #20
 6183              	.LVL665:
 6184 3698 0110A0E3 		mov	r1, #1
 6185 369c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6186              	.LVL666:
3236:../uvc.c      ****     {
 6187              		.loc 1 3236 0
 6188 36a0 005050E2 		subs	r5, r0, #0
 6189 36a4 2F02001A 		bne	.L585
3241:../uvc.c      ****     if (apiRetStatus != 0)
 6190              		.loc 1 3241 0
 6191 36a8 1800A0E3 		mov	r0, #24
 6192              	.LVL667:
 6193 36ac 0110A0E3 		mov	r1, #1
 6194 36b0 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6195              	.LVL668:
3242:../uvc.c      ****     {
 6196              		.loc 1 3242 0
 6197 36b4 005050E2 		subs	r5, r0, #0
 6198 36b8 2402001A 		bne	.L586
3249:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6199              		.loc 1 3249 0
 6200 36bc 0150A0E3 		mov	r5, #1
3254:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6201              		.loc 1 3254 0
 6202 36c0 30108DE2 		add	r1, sp, #48
 6203 36c4 1600A0E3 		mov	r0, #22
 6204              	.LVL669:
3252:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6205              		.loc 1 3252 0
 6206 36c8 3C408DE5 		str	r4, [sp, #60]
3253:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6207              		.loc 1 3253 0
 6208 36cc 4040CDE5 		strb	r4, [sp, #64]
3249:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6209              		.loc 1 3249 0
 6210 36d0 30508DE5 		str	r5, [sp, #48]
3250:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6211              		.loc 1 3250 0
 6212 36d4 34508DE5 		str	r5, [sp, #52]
3251:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6213              		.loc 1 3251 0
 6214 36d8 38508DE5 		str	r5, [sp, #56]
3254:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6215              		.loc 1 3254 0
 6216 36dc FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6217              	.LVL670:
3255:../uvc.c      ****     {
 6218              		.loc 1 3255 0
 6219 36e0 006050E2 		subs	r6, r0, #0
 6220 36e4 1302001A 		bne	.L587
3268:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6221              		.loc 1 3268 0
 6222 36e8 1400A0E3 		mov	r0, #20
 6223              	.LVL671:
 6224 36ec 30108DE2 		add	r1, sp, #48
3266:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6225              		.loc 1 3266 0
 6226 36f0 3C408DE5 		str	r4, [sp, #60]
3267:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6227              		.loc 1 3267 0
 6228 36f4 4040CDE5 		strb	r4, [sp, #64]
3263:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6229              		.loc 1 3263 0
 6230 36f8 30508DE5 		str	r5, [sp, #48]
3264:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6231              		.loc 1 3264 0
 6232 36fc 34508DE5 		str	r5, [sp, #52]
3265:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6233              		.loc 1 3265 0
 6234 3700 38508DE5 		str	r5, [sp, #56]
3268:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6235              		.loc 1 3268 0
 6236 3704 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6237              	.LVL672:
3269:../uvc.c      ****     {
 6238              		.loc 1 3269 0
 6239 3708 004050E2 		subs	r4, r0, #0
 6240 370c 0302001A 		bne	.L588
3277:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6241              		.loc 1 3277 0
 6242 3710 0030A0E3 		mov	r3, #0
3282:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6243              		.loc 1 3282 0
 6244 3714 30108DE2 		add	r1, sp, #48
3280:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6245              		.loc 1 3280 0
 6246 3718 0150A0E3 		mov	r5, #1
3282:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6247              		.loc 1 3282 0
 6248 371c 1800A0E3 		mov	r0, #24
 6249              	.LVL673:
3277:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6250              		.loc 1 3277 0
 6251 3720 30308DE5 		str	r3, [sp, #48]
3278:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 6252              		.loc 1 3278 0
 6253 3724 34308DE5 		str	r3, [sp, #52]
3279:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 6254              		.loc 1 3279 0
 6255 3728 38308DE5 		str	r3, [sp, #56]
3281:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6256              		.loc 1 3281 0
 6257 372c 4030CDE5 		strb	r3, [sp, #64]
3280:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6258              		.loc 1 3280 0
 6259 3730 3C508DE5 		str	r5, [sp, #60]
3282:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6260              		.loc 1 3282 0
 6261 3734 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6262              	.LVL674:
3283:../uvc.c      ****     {
 6263              		.loc 1 3283 0
 6264 3738 004050E2 		subs	r4, r0, #0
 6265 373c F101001A 		bne	.L589
3290:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6266              		.loc 1 3290 0
 6267 3740 0260A0E3 		mov	r6, #2
3291:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6268              		.loc 1 3291 0
 6269 3744 0380A0E3 		mov	r8, #3
3295:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6270              		.loc 1 3295 0
 6271 3748 0500A0E1 		mov	r0, r5
 6272              	.LVL675:
 6273 374c 20108DE2 		add	r1, sp, #32
3292:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 6274              		.loc 1 3292 0
 6275 3750 28408DE5 		str	r4, [sp, #40]
3293:../uvc.c      **** 
 6276              		.loc 1 3293 0
 6277 3754 24408DE5 		str	r4, [sp, #36]
3290:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6278              		.loc 1 3290 0
 6279 3758 B062CDE1 		strh	r6, [sp, #32]	@ movhi
3291:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6280              		.loc 1 3291 0
 6281 375c 2C80CDE5 		strb	r8, [sp, #44]
3295:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6282              		.loc 1 3295 0
 6283 3760 FEFFFFEB 		bl	CyU3PPibInit
 6284              	.LVL676:
3296:../uvc.c      ****     {
 6285              		.loc 1 3296 0
 6286 3764 004050E2 		subs	r4, r0, #0
 6287 3768 E001001A 		bne	.L590
3303:../uvc.c      **** 
 6288              		.loc 1 3303 0
 6289 376c 74089FE5 		ldr	r0, .L610+12
 6290              	.LVL677:
 6291 3770 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 6292              	.LVL678:
3311:../uvc.c      ****     CyU3PThreadSleep(5000);
 6293              		.loc 1 3311 0
 6294 3774 FEFFFFEB 		bl	SensorReset
 6295              	.LVL679:
3312:../uvc.c      ****     //SensorInit ();
 6296              		.loc 1 3312 0
 6297 3778 6C089FE5 		ldr	r0, .L610+16
 6298 377c FEFFFFEB 		bl	_tx_thread_sleep
 6299              	.LVL680:
3316:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6300              		.loc 1 3316 0
 6301 3780 FEFFFFEB 		bl	CyU3PUsbStart
 6302              	.LVL681:
3317:../uvc.c      ****     {
 6303              		.loc 1 3317 0
 6304 3784 004050E2 		subs	r4, r0, #0
 6305 3788 D201001A 		bne	.L591
3323:../uvc.c      **** 
 6306              		.loc 1 3323 0
 6307 378c 0410A0E1 		mov	r1, r4
 6308 3790 58089FE5 		ldr	r0, .L610+20
 6309              	.LVL682:
 6310 3794 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 6311              	.LVL683:
3326:../uvc.c      **** 
 6312              		.loc 1 3326 0
 6313 3798 54089FE5 		ldr	r0, .L610+24
 6314 379c FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
 6315              	.LVL684:
3332:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 6316              		.loc 1 3332 0
 6317 37a0 0410A0E1 		mov	r1, r4
 6318 37a4 4C289FE5 		ldr	r2, .L610+28
 6319 37a8 0500A0E1 		mov	r0, r5
 6320 37ac FEFFFFEB 		bl	CyU3PUsbSetDesc
 6321              	.LVL685:
3333:../uvc.c      **** 
 6322              		.loc 1 3333 0
 6323 37b0 0410A0E1 		mov	r1, r4
 6324 37b4 0400A0E1 		mov	r0, r4
 6325 37b8 3C289FE5 		ldr	r2, .L610+32
 6326 37bc FEFFFFEB 		bl	CyU3PUsbSetDesc
 6327              	.LVL686:
3336:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 6328              		.loc 1 3336 0
 6329 37c0 0410A0E1 		mov	r1, r4
 6330 37c4 34289FE5 		ldr	r2, .L610+36
 6331 37c8 0600A0E1 		mov	r0, r6
 6332 37cc FEFFFFEB 		bl	CyU3PUsbSetDesc
 6333              	.LVL687:
3337:../uvc.c      **** 
 6334              		.loc 1 3337 0
 6335 37d0 0410A0E1 		mov	r1, r4
 6336 37d4 28289FE5 		ldr	r2, .L610+40
 6337 37d8 0700A0E3 		mov	r0, #7
 6338 37dc FEFFFFEB 		bl	CyU3PUsbSetDesc
 6339              	.LVL688:
3340:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 6340              		.loc 1 3340 0
 6341 37e0 0410A0E1 		mov	r1, r4
 6342 37e4 1C289FE5 		ldr	r2, .L610+44
 6343 37e8 0400A0E3 		mov	r0, #4
 6344 37ec FEFFFFEB 		bl	CyU3PUsbSetDesc
 6345              	.LVL689:
3341:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 6346              		.loc 1 3341 0
 6347 37f0 0410A0E1 		mov	r1, r4
 6348 37f4 10289FE5 		ldr	r2, .L610+48
 6349 37f8 0800A0E1 		mov	r0, r8
 6350 37fc FEFFFFEB 		bl	CyU3PUsbSetDesc
 6351              	.LVL690:
3342:../uvc.c      **** 
 6352              		.loc 1 3342 0
 6353 3800 0410A0E1 		mov	r1, r4
 6354 3804 04289FE5 		ldr	r2, .L610+52
 6355 3808 0600A0E3 		mov	r0, #6
 6356 380c FEFFFFEB 		bl	CyU3PUsbSetDesc
 6357              	.LVL691:
3345:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 6358              		.loc 1 3345 0
 6359 3810 0410A0E1 		mov	r1, r4
 6360 3814 F8279FE5 		ldr	r2, .L610+56
 6361 3818 0500A0E3 		mov	r0, #5
 6362 381c FEFFFFEB 		bl	CyU3PUsbSetDesc
 6363              	.LVL692:
3346:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 6364              		.loc 1 3346 0
 6365 3820 0510A0E1 		mov	r1, r5
 6366 3824 EC279FE5 		ldr	r2, .L610+60
 6367 3828 0500A0E3 		mov	r0, #5
 6368 382c FEFFFFEB 		bl	CyU3PUsbSetDesc
 6369              	.LVL693:
3347:../uvc.c      **** 
 6370              		.loc 1 3347 0
 6371 3830 0610A0E1 		mov	r1, r6
 6372 3834 E0279FE5 		ldr	r2, .L610+64
 6373 3838 0500A0E3 		mov	r0, #5
 6374 383c FEFFFFEB 		bl	CyU3PUsbSetDesc
 6375              	.LVL694:
3356:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6376              		.loc 1 3356 0
 6377 3840 4030A0E3 		mov	r3, #64
3360:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6378              		.loc 1 3360 0
 6379 3844 08108DE2 		add	r1, sp, #8
 6380 3848 8200A0E3 		mov	r0, #130
3357:../uvc.c      ****     endPointConfig.streams  = 0;
 6381              		.loc 1 3357 0
 6382 384c 1340CDE5 		strb	r4, [sp, #19]
3358:../uvc.c      ****     endPointConfig.burstLen = 1;
 6383              		.loc 1 3358 0
 6384 3850 BE40CDE1 		strh	r4, [sp, #14]	@ movhi
3354:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6385              		.loc 1 3354 0
 6386 3854 08508DE5 		str	r5, [sp, #8]
3355:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6387              		.loc 1 3355 0
 6388 3858 0C80CDE5 		strb	r8, [sp, #12]
3359:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6389              		.loc 1 3359 0
 6390 385c 1250CDE5 		strb	r5, [sp, #18]
3356:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6391              		.loc 1 3356 0
 6392 3860 B031CDE1 		strh	r3, [sp, #16]	@ movhi
3360:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6393              		.loc 1 3360 0
 6394 3864 FEFFFFEB 		bl	CyU3PSetEpConfig
 6395              	.LVL695:
3361:../uvc.c      ****     {
 6396              		.loc 1 3361 0
 6397 3868 004050E2 		subs	r4, r0, #0
3364:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6398              		.loc 1 3364 0
 6399 386c 0400A013 		movne	r0, #4
 6400              	.LVL696:
3361:../uvc.c      ****     {
 6401              		.loc 1 3361 0
 6402 3870 7101001A 		bne	.L576
3369:../uvc.c      ****     dmaInterConfig.count          = 1;
 6403              		.loc 1 3369 0
 6404 3874 A4C79FE5 		ldr	ip, .L610+68
 6405 3878 413BA0E3 		mov	r3, #66560
3378:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6406              		.loc 1 3378 0
 6407 387c 1080A0E3 		mov	r8, #16
3380:../uvc.c      ****             &dmaInterConfig);
 6408              		.loc 1 3380 0
 6409 3880 9C079FE5 		ldr	r0, .L610+72
 6410 3884 0410A0E3 		mov	r1, #4
 6411 3888 44208DE2 		add	r2, sp, #68
3369:../uvc.c      ****     dmaInterConfig.count          = 1;
 6412              		.loc 1 3369 0
 6413 388c 4C408DE5 		str	r4, [sp, #76]
 6414 3890 50408DE5 		str	r4, [sp, #80]
3377:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6415              		.loc 1 3377 0
 6416 3894 5440CDE5 		strb	r4, [sp, #84]
3379:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6417              		.loc 1 3379 0
 6418 3898 5C408DE5 		str	r4, [sp, #92]
3369:../uvc.c      ****     dmaInterConfig.count          = 1;
 6419              		.loc 1 3369 0
 6420 389c 48C08DE5 		str	ip, [sp, #72]
 6421 38a0 44308DE5 		str	r3, [sp, #68]
3378:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6422              		.loc 1 3378 0
 6423 38a4 58808DE5 		str	r8, [sp, #88]
3380:../uvc.c      ****             &dmaInterConfig);
 6424              		.loc 1 3380 0
 6425 38a8 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6426              	.LVL697:
3382:../uvc.c      ****     {
 6427              		.loc 1 3382 0
 6428 38ac 004050E2 		subs	r4, r0, #0
 6429 38b0 BE01001A 		bne	.L592
3389:../uvc.c      ****     if (glInterStaBuffer == 0)
 6430              		.loc 1 3389 0
 6431 38b4 010BA0E3 		mov	r0, #1024
 6432              	.LVL698:
 6433 38b8 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6434              	.LVL699:
 6435 38bc 64379FE5 		ldr	r3, .L610+76
3390:../uvc.c      ****     {
 6436              		.loc 1 3390 0
 6437 38c0 000050E3 		cmp	r0, #0
3389:../uvc.c      ****     if (glInterStaBuffer == 0)
 6438              		.loc 1 3389 0
 6439 38c4 000083E5 		str	r0, [r3]
3390:../uvc.c      ****     {
 6440              		.loc 1 3390 0
 6441 38c8 BE01000A 		beq	.L593
3397:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6442              		.loc 1 3397 0
 6443 38cc 0410A0E1 		mov	r1, r4
 6444 38d0 0420A0E1 		mov	r2, r4
 6445 38d4 3830A0E3 		mov	r3, #56
 6446 38d8 4C079FE5 		ldr	r0, .L610+80
 6447 38dc FEFFFFEB 		bl	_txe_mutex_create
 6448              	.LVL700:
3402:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6449              		.loc 1 3402 0
 6450 38e0 48179FE5 		ldr	r1, .L610+84
3403:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6451              		.loc 1 3403 0
 6452 38e4 48279FE5 		ldr	r2, .L610+88
3410:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6453              		.loc 1 3410 0
 6454 38e8 48A79FE5 		ldr	r10, .L610+92
3399:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6455              		.loc 1 3399 0
 6456 38ec 0480A0E3 		mov	r8, #4
3401:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6457              		.loc 1 3401 0
 6458 38f0 01ECA0E3 		mov	lr, #256
3405:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6459              		.loc 1 3405 0
 6460 38f4 0CC0A0E3 		mov	ip, #12
3409:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6461              		.loc 1 3409 0
 6462 38f8 1830A0E3 		mov	r3, #24
3402:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6463              		.loc 1 3402 0
 6464 38fc B816CDE1 		strh	r1, [sp, #104]	@ movhi
3403:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6465              		.loc 1 3403 0
 6466 3900 BE26CDE1 		strh	r2, [sp, #110]	@ movhi
3398:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6467              		.loc 1 3398 0
 6468 3904 0199A0E3 		mov	r9, #16384
3411:../uvc.c      ****             &dmaMultiConfig);
 6469              		.loc 1 3411 0
 6470 3908 2C079FE5 		ldr	r0, .L610+96
 6471 390c 0710A0E3 		mov	r1, #7
 6472 3910 60208DE2 		add	r2, sp, #96
3404:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6473              		.loc 1 3404 0
 6474 3914 B647CDE1 		strh	r4, [sp, #118]	@ movhi
3407:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6475              		.loc 1 3407 0
 6476 3918 BC47CDE1 		strh	r4, [sp, #124]	@ movhi
3408:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6477              		.loc 1 3408 0
 6478 391c 7E40CDE5 		strb	r4, [sp, #126]
3400:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6479              		.loc 1 3400 0
 6480 3920 B466CDE1 		strh	r6, [sp, #100]	@ movhi
3410:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6481              		.loc 1 3410 0
 6482 3924 84A08DE5 		str	r10, [sp, #132]
3398:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6483              		.loc 1 3398 0
 6484 3928 B096CDE1 		strh	r9, [sp, #96]	@ movhi
3399:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6485              		.loc 1 3399 0
 6486 392c B286CDE1 		strh	r8, [sp, #98]	@ movhi
3406:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6487              		.loc 1 3406 0
 6488 3930 BA87CDE1 		strh	r8, [sp, #122]	@ movhi
3401:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6489              		.loc 1 3401 0
 6490 3934 B6E6CDE1 		strh	lr, [sp, #102]	@ movhi
3405:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6491              		.loc 1 3405 0
 6492 3938 B8C7CDE1 		strh	ip, [sp, #120]	@ movhi
3409:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6493              		.loc 1 3409 0
 6494 393c 80308DE5 		str	r3, [sp, #128]
3411:../uvc.c      ****             &dmaMultiConfig);
 6495              		.loc 1 3411 0
 6496 3940 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6497              	.LVL701:
3413:../uvc.c      ****     {
 6498              		.loc 1 3413 0
 6499 3944 004050E2 		subs	r4, r0, #0
 6500 3948 9201001A 		bne	.L594
3504:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6501              		.loc 1 3504 0
 6502 394c 0500A0E1 		mov	r0, r5
 6503              	.LVL702:
 6504 3950 0510A0E1 		mov	r1, r5
 6505 3954 FEFFFFEB 		bl	CyU3PConnectState
 6506              	.LVL703:
3505:../uvc.c      ****     {
 6507              		.loc 1 3505 0
 6508 3958 004050E2 		subs	r4, r0, #0
 6509 395c 3B01001A 		bne	.L595
3511:../uvc.c      **** 
 6510              		.loc 1 3511 0
 6511 3960 6400A0E3 		mov	r0, #100
 6512              	.LVL704:
 6513 3964 FEFFFFEB 		bl	CyFx3BusyWait
 6514              	.LVL705:
3513:../uvc.c      **** 
 6515              		.loc 1 3513 0
 6516 3968 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 6517              	.LVL706:
3528:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6518              		.loc 1 3528 0
 6519 396c 08108DE2 		add	r1, sp, #8
3527:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6520              		.loc 1 3527 0
 6521 3970 BE40CDE1 		strh	r4, [sp, #14]	@ movhi
3515:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6522              		.loc 1 3515 0
 6523 3974 08508DE5 		str	r5, [sp, #8]
3516:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6524              		.loc 1 3516 0
 6525 3978 0C60CDE5 		strb	r6, [sp, #12]
3520:../uvc.c      ****     }
 6526              		.loc 1 3520 0
 6527 397c 030050E3 		cmp	r0, #3
3513:../uvc.c      **** 
 6528              		.loc 1 3513 0
 6529 3980 0030A0E1 		mov	r3, r0
3520:../uvc.c      ****     }
 6530              		.loc 1 3520 0
 6531 3984 01C0A013 		movne	ip, #1
 6532 3988 10C0A003 		moveq	ip, #16
 6533 398c 022CA013 		movne	r2, #512
 6534 3990 012BA003 		moveq	r2, #1024
3528:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6535              		.loc 1 3528 0
 6536 3994 8300A0E3 		mov	r0, #131
3513:../uvc.c      **** 
 6537              		.loc 1 3513 0
 6538 3998 4830C7E5 		strb	r3, [r7, #72]
 6539 399c 12C0CDE5 		strb	ip, [sp, #18]
 6540 39a0 B021CDE1 		strh	r2, [sp, #16]	@ movhi
3528:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6541              		.loc 1 3528 0
 6542 39a4 FEFFFFEB 		bl	CyU3PSetEpConfig
 6543              	.LVL707:
3529:../uvc.c      ****     {
 6544              		.loc 1 3529 0
 6545 39a8 004050E2 		subs	r4, r0, #0
 6546              	.LBE105:
 6547              	.LBE104:
3652:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6548              		.loc 1 3652 0
 6549 39ac 30469F05 		ldreq	r4, .L610+8
 6550              	.LBB110:
 6551              	.LBB106:
3529:../uvc.c      ****     {
 6552              		.loc 1 3529 0
 6553 39b0 0C00000A 		beq	.L555
 6554 39b4 1F0100EA 		b	.L609
 6555              	.LVL708:
 6556              	.L598:
 6557              	.LBE106:
 6558              	.LBE110:
3698:../uvc.c      ****             {
 6559              		.loc 1 3698 0
 6560 39b8 7C3094E5 		ldr	r3, [r4, #124]
 6561 39bc 050053E1 		cmp	r3, r5
 6562 39c0 0300000A 		beq	.L525
3698:../uvc.c      ****             {
 6563              		.loc 1 3698 0 is_stmt 0 discriminator 1
 6564 39c4 B028D4E1 		ldrh	r2, [r4, #128]
 6565 39c8 B238D4E1 		ldrh	r3, [r4, #130]
 6566 39cc 030052E1 		cmp	r2, r3
 6567 39d0 3B00000A 		beq	.L597
 6568              	.L525:
3902:../uvc.c      **** 
 6569              		.loc 1 3902 0 is_stmt 1
 6570 39d4 4010A0E3 		mov	r1, #64
 6571 39d8 0020A0E3 		mov	r2, #0
 6572 39dc 00069FE5 		ldr	r0, .L610+8
 6573 39e0 FEFFFFEB 		bl	_txe_event_flags_set
 6574              	.LVL709:
3905:../uvc.c      ****     }
 6575              		.loc 1 3905 0
 6576 39e4 FEFFFFEB 		bl	_txe_thread_relinquish
 6577              	.LVL710:
 6578              	.L555:
3652:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6579              		.loc 1 3652 0
 6580 39e8 0050A0E3 		mov	r5, #0
 6581 39ec 00508DE5 		str	r5, [sp]
 6582 39f0 EC059FE5 		ldr	r0, .L610+8
 6583 39f4 0110A0E3 		mov	r1, #1
 6584 39f8 0220A0E3 		mov	r2, #2
 6585 39fc 60308DE2 		add	r3, sp, #96
 6586 3a00 FEFFFFEB 		bl	_txe_event_flags_get
 6587              	.LVL711:
 6588 3a04 006050E2 		subs	r6, r0, #0
 6589 3a08 EAFFFF0A 		beq	.L598
3809:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6590              		.loc 1 3809 0
 6591 3a0c 00508DE5 		str	r5, [sp]
 6592 3a10 CC059FE5 		ldr	r0, .L610+8
 6593 3a14 0210A0E3 		mov	r1, #2
 6594 3a18 0320A0E3 		mov	r2, #3
 6595 3a1c 60308DE2 		add	r3, sp, #96
 6596 3a20 FEFFFFEB 		bl	_txe_event_flags_get
 6597              	.LVL712:
 6598 3a24 000050E3 		cmp	r0, #0
 6599 3a28 0B00001A 		bne	.L547
3824:../uvc.c      ****                 {
 6600              		.loc 1 3824 0
 6601 3a2c 903094E5 		ldr	r3, [r4, #144]
3812:../uvc.c      ****                 prodCount = 0;
 6602              		.loc 1 3812 0
 6603 3a30 7C0084E5 		str	r0, [r4, #124]
3824:../uvc.c      ****                 {
 6604              		.loc 1 3824 0
 6605 3a34 000053E3 		cmp	r3, #0
3813:../uvc.c      ****                 consCount = 0;
 6606              		.loc 1 3813 0
 6607 3a38 B008C4E1 		strh	r0, [r4, #128]	@ movhi
3820:../uvc.c      ****                 pb=0;
 6608              		.loc 1 3820 0
 6609 3a3c B407C4E1 		strh	r0, [r4, #116]	@ movhi
3814:../uvc.c      ****                 if(0&&(prinflag == 0)){
 6610              		.loc 1 3814 0
 6611 3a40 B208C4E1 		strh	r0, [r4, #130]	@ movhi
3821:../uvc.c      ****                 pbc=0;
 6612              		.loc 1 3821 0
 6613 3a44 B607C4E1 		strh	r0, [r4, #118]	@ movhi
3822:../uvc.c      **** 
 6614              		.loc 1 3822 0
 6615 3a48 B807C4E1 		strh	r0, [r4, #120]	@ movhi
3824:../uvc.c      ****                 {
 6616              		.loc 1 3824 0
 6617 3a4c 4600000A 		beq	.L599
 6618              	.L548:
3836:../uvc.c      ****             }
 6619              		.loc 1 3836 0
 6620 3a50 0030A0E3 		mov	r3, #0
 6621 3a54 903087E5 		str	r3, [r7, #144]
 6622 3a58 DDFFFFEA 		b	.L525
 6623              	.L547:
3841:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
 6624              		.loc 1 3841 0
 6625 3a5c 0030E0E3 		mvn	r3, #0
 6626 3a60 00308DE5 		str	r3, [sp]
 6627 3a64 0110A0E3 		mov	r1, #1
 6628 3a68 0220A0E3 		mov	r2, #2
 6629 3a6c 60308DE2 		add	r3, sp, #96
 6630 3a70 6C059FE5 		ldr	r0, .L610+8
 6631 3a74 FEFFFFEB 		bl	_txe_event_flags_get
 6632              	.LVL713:
3845:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6633              		.loc 1 3845 0
 6634 3a78 0510A0E1 		mov	r1, r5
 6635 3a7c 0520A0E1 		mov	r2, r5
 6636 3a80 B4059FE5 		ldr	r0, .L610+96
 6637 3a84 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6638              	.LVL714:
3846:../uvc.c      ****                 {
 6639              		.loc 1 3846 0
 6640 3a88 005050E2 		subs	r5, r0, #0
 6641 3a8c 9D00001A 		bne	.L600
3854:../uvc.c      ****                 {
 6642              		.loc 1 3854 0
 6643 3a90 883094E5 		ldr	r3, [r4, #136]
 6644 3a94 000053E3 		cmp	r3, #0
 6645 3a98 2B00001A 		bne	.L546
 6646              	.LVL715:
 6647              	.LBB111:
 6648              	.LBB112:
3557:../uvc.c      ****     {
 6649              		.loc 1 3557 0
 6650 3a9c 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 6651 3aa0 030053E3 		cmp	r3, #3
 6652 3aa4 5E00000A 		beq	.L601
3562:../uvc.c      ****     {
 6653              		.loc 1 3562 0
 6654 3aa8 020053E3 		cmp	r3, #2
 6655 3aac 7400000A 		beq	.L602
 6656              	.LVL716:
 6657              	.L553:
 6658              	.LBE112:
 6659              	.LBE111:
3890:../uvc.c      ****                     CyU3PThreadSleep(200);
 6660              		.loc 1 3890 0
 6661 3ab0 0130A0E3 		mov	r3, #1
3891:../uvc.c      ****                     
 6662              		.loc 1 3891 0
 6663 3ab4 C800A0E3 		mov	r0, #200
3890:../uvc.c      ****                     CyU3PThreadSleep(200);
 6664              		.loc 1 3890 0
 6665 3ab8 883087E5 		str	r3, [r7, #136]
3891:../uvc.c      ****                     
 6666              		.loc 1 3891 0
 6667 3abc FEFFFFEB 		bl	_tx_thread_sleep
 6668              	.LVL717:
 6669 3ac0 C3FFFFEA 		b	.L525
 6670              	.L597:
3724:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 6671              		.loc 1 3724 0
 6672 3ac4 74559FE5 		ldr	r5, .L610+100
3723:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6673              		.loc 1 3723 0
 6674 3ac8 5C059FE5 		ldr	r0, .L610+80
 6675 3acc 0010E0E3 		mvn	r1, #0
3708:../uvc.c      ****                 consCount = 0;
 6676              		.loc 1 3708 0
 6677 3ad0 B068C4E1 		strh	r6, [r4, #128]	@ movhi
3705:../uvc.c      ****             	pb=0;
 6678              		.loc 1 3705 0
 6679 3ad4 B467C4E1 		strh	r6, [r4, #116]	@ movhi
3709:../uvc.c      ****                 hitFV     = CyFalse;
 6680              		.loc 1 3709 0
 6681 3ad8 B268C4E1 		strh	r6, [r4, #130]	@ movhi
3706:../uvc.c      ****             	pbc=0;
 6682              		.loc 1 3706 0
 6683 3adc B667C4E1 		strh	r6, [r4, #118]	@ movhi
3707:../uvc.c      ****                 prodCount = 0;
 6684              		.loc 1 3707 0
 6685 3ae0 B867C4E1 		strh	r6, [r4, #120]	@ movhi
3710:../uvc.c      **** 
 6686              		.loc 1 3710 0
 6687 3ae4 7C6084E5 		str	r6, [r4, #124]
3723:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6688              		.loc 1 3723 0
 6689 3ae8 FEFFFFEB 		bl	_txe_mutex_get
 6690              	.LVL718:
3724:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 6691              		.loc 1 3724 0
 6692 3aec ED34D5E5 		ldrb	r3, [r5, #1261]	@ zero_extendqisi2
 6693 3af0 013023E2 		eor	r3, r3, #1
 6694 3af4 ED34C5E5 		strb	r3, [r5, #1261]
3726:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 6695              		.loc 1 3726 0
 6696 3af8 7230D4E5 		ldrb	r3, [r4, #114]	@ zero_extendqisi2
 6697 3afc F00053E3 		cmp	r3, #240
 6698 3b00 3B00000A 		beq	.L603
 6699              	.L526:
3734:../uvc.c      **** 
 6700              		.loc 1 3734 0
 6701 3b04 7230D7E5 		ldrb	r3, [r7, #114]	@ zero_extendqisi2
 6702 3b08 FF0053E3 		cmp	r3, #255
 6703 3b0c 1D00000A 		beq	.L604
3746:../uvc.c      ****                     //CyU3PThreadSleep(400);
 6704              		.loc 1 3746 0
 6705 3b10 7230D4E5 		ldrb	r3, [r4, #114]	@ zero_extendqisi2
 6706 3b14 AA0053E3 		cmp	r3, #170
 6707 3b18 2700000A 		beq	.L605
 6708              	.L527:
3784:../uvc.c      ****                 /* Reset the DMA channel. */
 6709              		.loc 1 3784 0
 6710 3b1c 08059FE5 		ldr	r0, .L610+80
 6711 3b20 FEFFFFEB 		bl	_txe_mutex_put
 6712              	.LVL719:
3786:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6713              		.loc 1 3786 0
 6714 3b24 10059FE5 		ldr	r0, .L610+96
 6715 3b28 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6716              	.LVL720:
3787:../uvc.c      ****                 {
 6717              		.loc 1 3787 0
 6718 3b2c 005050E2 		subs	r5, r0, #0
 6719 3b30 7A00001A 		bne	.L606
3794:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6720              		.loc 1 3794 0
 6721 3b34 0510A0E1 		mov	r1, r5
 6722 3b38 0520A0E1 		mov	r2, r5
 6723 3b3c F8049FE5 		ldr	r0, .L610+96
 6724              	.LVL721:
 6725 3b40 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6726              	.LVL722:
3795:../uvc.c      ****                 {
 6727              		.loc 1 3795 0
 6728 3b44 005050E2 		subs	r5, r0, #0
 6729 3b48 6800001A 		bne	.L607
 6730              	.L546:
3803:../uvc.c      ****                 }
 6731              		.loc 1 3803 0
 6732 3b4c DC049FE5 		ldr	r0, .L610+84
 6733              	.LVL723:
 6734 3b50 0230A0E3 		mov	r3, #2
 6735 3b54 0010A0E3 		mov	r1, #0
 6736 3b58 00308DE5 		str	r3, [sp]
 6737 3b5c 0020A0E1 		mov	r2, r0
 6738 3b60 0130A0E1 		mov	r3, r1
 6739 3b64 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6740              	.LVL724:
 6741 3b68 99FFFFEA 		b	.L525
 6742              	.LVL725:
 6743              	.L599:
3826:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6744              		.loc 1 3826 0
 6745 3b6c C8049FE5 		ldr	r0, .L610+96
 6746 3b70 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6747              	.LVL726:
3827:../uvc.c      ****                     {
 6748              		.loc 1 3827 0
 6749 3b74 000050E3 		cmp	r0, #0
 6750 3b78 4000001A 		bne	.L578
3833:../uvc.c      ****                 }
 6751              		.loc 1 3833 0
 6752 3b7c 8300A0E3 		mov	r0, #131
 6753              	.LVL727:
 6754 3b80 FEFFFFEB 		bl	CyU3PUsbFlushEp
 6755              	.LVL728:
 6756 3b84 B1FFFFEA 		b	.L548
 6757              	.L604:
3736:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 6758              		.loc 1 3736 0
 6759 3b88 A030D4E5 		ldrb	r3, [r4, #160]	@ zero_extendqisi2
 6760 3b8c 020053E3 		cmp	r3, #2
 6761 3b90 013083E2 		add	r3, r3, #1
 6762 3b94 A030C4E5 		strb	r3, [r4, #160]
 6763 3b98 DFFFFF9A 		bls	.L527
3737:../uvc.c      ****                 		stiflag = 0x0F;
 6764              		.loc 1 3737 0
 6765 3b9c ED14D5E5 		ldrb	r1, [r5, #1261]	@ zero_extendqisi2
3738:../uvc.c      ****                 		IMcount = 0;
 6766              		.loc 1 3738 0
 6767 3ba0 0F30A0E3 		mov	r3, #15
3737:../uvc.c      ****                 		stiflag = 0x0F;
 6768              		.loc 1 3737 0
 6769 3ba4 201081E3 		orr	r1, r1, #32
3739:../uvc.c      ****                 		}
 6770              		.loc 1 3739 0
 6771 3ba8 0020A0E3 		mov	r2, #0
3737:../uvc.c      ****                 		stiflag = 0x0F;
 6772              		.loc 1 3737 0
 6773 3bac ED14C5E5 		strb	r1, [r5, #1261]
3739:../uvc.c      ****                 		}
 6774              		.loc 1 3739 0
 6775 3bb0 A020C4E5 		strb	r2, [r4, #160]
3738:../uvc.c      ****                 		IMcount = 0;
 6776              		.loc 1 3738 0
 6777 3bb4 7230C4E5 		strb	r3, [r4, #114]
 6778 3bb8 D7FFFFEA 		b	.L527
 6779              	.L605:
3752:../uvc.c      ****                 	{
 6780              		.loc 1 3752 0
 6781 3bbc A030D4E5 		ldrb	r3, [r4, #160]	@ zero_extendqisi2
 6782 3bc0 020053E3 		cmp	r3, #2
 6783 3bc4 013083E2 		add	r3, r3, #1
 6784 3bc8 A030C4E5 		strb	r3, [r4, #160]
 6785 3bcc D2FFFF9A 		bls	.L527
3754:../uvc.c      ****                      {
 6786              		.loc 1 3754 0
 6787 3bd0 7030D4E5 		ldrb	r3, [r4, #112]	@ zero_extendqisi2
 6788 3bd4 013043E2 		sub	r3, r3, #1
 6789 3bd8 030053E3 		cmp	r3, #3
 6790 3bdc 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 6791 3be0 3E0000EA 		b	.L531
 6792              	.L533:
 6793 3be4 A03C0000 		.word	.L532
 6794 3be8 8C3D0000 		.word	.L534
 6795 3bec D03D0000 		.word	.L535
 6796 3bf0 383D0000 		.word	.L536
 6797              	.L603:
3726:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 6798              		.loc 1 3726 0 discriminator 1
 6799 3bf4 00608DE5 		str	r6, [sp]
 6800 3bf8 E4039FE5 		ldr	r0, .L610+8
 6801 3bfc 8010A0E3 		mov	r1, #128
 6802 3c00 0320A0E3 		mov	r2, #3
 6803 3c04 60308DE2 		add	r3, sp, #96
 6804 3c08 FEFFFFEB 		bl	_txe_event_flags_get
 6805              	.LVL729:
 6806 3c0c 000050E3 		cmp	r0, #0
 6807 3c10 BBFFFF1A 		bne	.L526
3731:../uvc.c      ****                 		IMcount = 0;
 6808              		.loc 1 3731 0
 6809 3c14 0030E0E3 		mvn	r3, #0
3732:../uvc.c      ****                 	}
 6810              		.loc 1 3732 0
 6811 3c18 A000C4E5 		strb	r0, [r4, #160]
3731:../uvc.c      ****                 		IMcount = 0;
 6812              		.loc 1 3731 0
 6813 3c1c 7230C4E5 		strb	r3, [r4, #114]
3732:../uvc.c      ****                 	}
 6814              		.loc 1 3732 0
 6815 3c20 BDFFFFEA 		b	.L527
 6816              	.LVL730:
 6817              	.L601:
 6818              	.LBB115:
 6819              	.LBB113:
3559:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 6820              		.loc 1 3559 0
 6821 3c24 18149FE5 		ldr	r1, .L610+104
 6822 3c28 0100A0E3 		mov	r0, #1
 6823              	.LVL731:
 6824 3c2c FEFFFFEB 		bl	CyU3PDebugPrint
 6825              	.LVL732:
3560:../uvc.c      ****     }
 6826              		.loc 1 3560 0
 6827 3c30 10049FE5 		ldr	r0, .L610+108
 6828 3c34 FEFFFFEB 		bl	CyU3PGpifLoad
 6829              	.LVL733:
 6830 3c38 0050A0E1 		mov	r5, r0
 6831              	.LVL734:
 6832              	.L552:
3567:../uvc.c      ****     {
 6833              		.loc 1 3567 0
 6834 3c3c 000055E3 		cmp	r5, #0
 6835 3c40 8800001A 		bne	.L608
 6836              	.LVL735:
3579:../uvc.c      ****     {
 6837              		.loc 1 3579 0
 6838 3c44 4830D7E5 		ldrb	r3, [r7, #72]	@ zero_extendqisi2
 6839 3c48 023043E2 		sub	r3, r3, #2
 6840 3c4c FF3003E2 		and	r3, r3, #255
 6841 3c50 010053E3 		cmp	r3, #1
 6842 3c54 95FFFF8A 		bhi	.L553
3577:../uvc.c      ****     }
 6843              		.loc 1 3577 0
 6844 3c58 0500A0E1 		mov	r0, r5
 6845 3c5c 0510A0E1 		mov	r1, r5
 6846 3c60 FEFFFFEB 		bl	CyU3PGpifSMStart
 6847              	.LVL736:
3583:../uvc.c      ****     {
 6848              		.loc 1 3583 0
 6849 3c64 005050E2 		subs	r5, r0, #0
 6850 3c68 90FFFF0A 		beq	.L553
3586:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6851              		.loc 1 3586 0
 6852 3c6c 0400A0E3 		mov	r0, #4
 6853              	.LVL737:
 6854 3c70 D4139FE5 		ldr	r1, .L610+112
 6855 3c74 0520A0E1 		mov	r2, r5
 6856 3c78 FEFFFFEB 		bl	CyU3PDebugPrint
 6857              	.LVL738:
3587:../uvc.c      ****     }
 6858              		.loc 1 3587 0
 6859 3c7c 0500A0E1 		mov	r0, r5
 6860              	.LVL739:
 6861              	.L578:
3571:../uvc.c      ****     }
 6862              		.loc 1 3571 0
 6863 3c80 FEFFFFEB 		bl	CyFxAppErrorHandler
 6864              	.LVL740:
 6865              	.L602:
3564:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 6866              		.loc 1 3564 0
 6867 3c84 C4139FE5 		ldr	r1, .L610+116
 6868 3c88 0100A0E3 		mov	r0, #1
 6869              	.LVL741:
 6870 3c8c FEFFFFEB 		bl	CyU3PDebugPrint
 6871              	.LVL742:
3565:../uvc.c      ****     }
 6872              		.loc 1 3565 0
 6873 3c90 BC039FE5 		ldr	r0, .L610+120
 6874 3c94 FEFFFFEB 		bl	CyU3PGpifLoad
 6875              	.LVL743:
 6876 3c98 0050A0E1 		mov	r5, r0
 6877              	.LVL744:
 6878 3c9c E6FFFFEA 		b	.L552
 6879              	.LVL745:
 6880              	.L532:
 6881              	.LBE113:
 6882              	.LBE115:
3757:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 6883              		.loc 1 3757 0
 6884 3ca0 6C2097E5 		ldr	r2, [r7, #108]
 6885 3ca4 3010A0E3 		mov	r1, #48
 6886 3ca8 000052E3 		cmp	r2, #0
 6887 3cac A220A003 		moveq	r2, #162
 6888 3cb0 2220A013 		movne	r2, #34
 6889 3cb4 5230A0E3 		mov	r3, #82
 6890 3cb8 0100A0E3 		mov	r0, #1
 6891 3cbc FEFFFFEB 		bl	SensorSetIrisControl
 6892              	.LVL746:
3759:../uvc.c      ****                  		break;
 6893              		.loc 1 3759 0
 6894 3cc0 6C2097E5 		ldr	r2, [r7, #108]
 6895 3cc4 0400A0E3 		mov	r0, #4
 6896 3cc8 000052E3 		cmp	r2, #0
 6897 3ccc 6C3097E5 		ldr	r3, [r7, #108]
 6898 3cd0 A220A003 		moveq	r2, #162
 6899 3cd4 2220A013 		movne	r2, #34
 6900 3cd8 78139FE5 		ldr	r1, .L610+124
 6901 3cdc FEFFFFEB 		bl	CyU3PDebugPrint
 6902              	.LVL747:
 6903              	.L531:
3779:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6904              		.loc 1 3779 0
 6905 3ce0 0030A0E3 		mov	r3, #0
 6906 3ce4 A030C7E5 		strb	r3, [r7, #160]
3781:../uvc.c      ****                 	}
 6907              		.loc 1 3781 0
 6908 3ce8 7230C7E5 		strb	r3, [r7, #114]
 6909 3cec 8AFFFFEA 		b	.L527
 6910              	.LVL748:
 6911              	.L607:
3797:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 6912              		.loc 1 3797 0
 6913 3cf0 0400A0E3 		mov	r0, #4
 6914              	.LVL749:
 6915 3cf4 60139FE5 		ldr	r1, .L610+128
 6916 3cf8 0520A0E1 		mov	r2, r5
 6917 3cfc FEFFFFEB 		bl	CyU3PDebugPrint
 6918              	.LVL750:
3798:../uvc.c      ****                 }
 6919              		.loc 1 3798 0
 6920 3d00 0500A0E1 		mov	r0, r5
 6921 3d04 FEFFFFEB 		bl	CyFxAppErrorHandler
 6922              	.LVL751:
 6923              	.L600:
3849:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 6924              		.loc 1 3849 0
 6925 3d08 0400A0E3 		mov	r0, #4
 6926              	.LVL752:
 6927 3d0c 4C139FE5 		ldr	r1, .L610+132
 6928 3d10 0520A0E1 		mov	r2, r5
 6929 3d14 FEFFFFEB 		bl	CyU3PDebugPrint
 6930              	.LVL753:
3850:../uvc.c      ****                 }
 6931              		.loc 1 3850 0
 6932 3d18 0500A0E1 		mov	r0, r5
 6933 3d1c FEFFFFEB 		bl	CyFxAppErrorHandler
 6934              	.LVL754:
 6935              	.L606:
3789:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 6936              		.loc 1 3789 0
 6937 3d20 0400A0E3 		mov	r0, #4
 6938              	.LVL755:
 6939 3d24 38139FE5 		ldr	r1, .L610+136
 6940 3d28 0520A0E1 		mov	r2, r5
 6941 3d2c FEFFFFEB 		bl	CyU3PDebugPrint
 6942              	.LVL756:
3790:../uvc.c      ****                 }
 6943              		.loc 1 3790 0
 6944 3d30 0500A0E1 		mov	r0, r5
 6945 3d34 FEFFFFEB 		bl	CyFxAppErrorHandler
 6946              	.LVL757:
 6947              	.L536:
3772:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 6948              		.loc 1 3772 0
 6949 3d38 6C2097E5 		ldr	r2, [r7, #108]
 6950 3d3c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 6951 3d40 000052E3 		cmp	r2, #0
 6952 3d44 B020A003 		moveq	r2, #176
 6953 3d48 3020A013 		movne	r2, #48
 6954 3d4c 032082E1 		orr	r2, r2, r3
 6955 3d50 3010A0E3 		mov	r1, #48
 6956 3d54 5230A0E3 		mov	r3, #82
 6957 3d58 0100A0E3 		mov	r0, #1
 6958 3d5c FEFFFFEB 		bl	SensorSetIrisControl
 6959              	.LVL758:
3774:../uvc.c      ****                  		break;
 6960              		.loc 1 3774 0
 6961 3d60 6C1097E5 		ldr	r1, [r7, #108]
 6962 3d64 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 6963 3d68 000051E3 		cmp	r1, #0
 6964 3d6c B010A003 		moveq	r1, #176
 6965 3d70 3010A013 		movne	r1, #48
 6966 3d74 022081E1 		orr	r2, r1, r2
 6967 3d78 6C3097E5 		ldr	r3, [r7, #108]
 6968 3d7c D4129FE5 		ldr	r1, .L610+124
 6969 3d80 0400A0E3 		mov	r0, #4
 6970 3d84 FEFFFFEB 		bl	CyU3PDebugPrint
 6971              	.LVL759:
3775:../uvc.c      ****                  	default:
 6972              		.loc 1 3775 0
 6973 3d88 D4FFFFEA 		b	.L531
 6974              	.L534:
3762:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 6975              		.loc 1 3762 0
 6976 3d8c 6C2097E5 		ldr	r2, [r7, #108]
 6977 3d90 3010A0E3 		mov	r1, #48
 6978 3d94 000052E3 		cmp	r2, #0
 6979 3d98 9220A003 		moveq	r2, #146
 6980 3d9c 1220A013 		movne	r2, #18
 6981 3da0 5230A0E3 		mov	r3, #82
 6982 3da4 0100A0E3 		mov	r0, #1
 6983 3da8 FEFFFFEB 		bl	SensorSetIrisControl
 6984              	.LVL760:
3764:../uvc.c      ****                  		break;
 6985              		.loc 1 3764 0
 6986 3dac 6C2097E5 		ldr	r2, [r7, #108]
 6987 3db0 A0129FE5 		ldr	r1, .L610+124
 6988 3db4 000052E3 		cmp	r2, #0
 6989 3db8 6C3097E5 		ldr	r3, [r7, #108]
 6990 3dbc 9220A003 		moveq	r2, #146
 6991 3dc0 1220A013 		movne	r2, #18
 6992 3dc4 0400A0E3 		mov	r0, #4
 6993 3dc8 FEFFFFEB 		bl	CyU3PDebugPrint
 6994              	.LVL761:
3765:../uvc.c      ****                  	case 3: //720
 6995              		.loc 1 3765 0
 6996 3dcc C3FFFFEA 		b	.L531
 6997              	.L535:
3767:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 6998              		.loc 1 3767 0
 6999 3dd0 6C2097E5 		ldr	r2, [r7, #108]
 7000 3dd4 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 7001 3dd8 000052E3 		cmp	r2, #0
 7002 3ddc 8020A003 		moveq	r2, #128
 7003 3de0 0020A013 		movne	r2, #0
 7004 3de4 032082E1 		orr	r2, r2, r3
 7005 3de8 3010A0E3 		mov	r1, #48
 7006 3dec 5230A0E3 		mov	r3, #82
 7007 3df0 0100A0E3 		mov	r0, #1
 7008 3df4 FEFFFFEB 		bl	SensorSetIrisControl
 7009              	.LVL762:
3769:../uvc.c      ****                  		break;
 7010              		.loc 1 3769 0
 7011 3df8 6C1097E5 		ldr	r1, [r7, #108]
 7012 3dfc 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 7013 3e00 000051E3 		cmp	r1, #0
 7014 3e04 8010A003 		moveq	r1, #128
 7015 3e08 0010A013 		movne	r1, #0
 7016 3e0c 022081E1 		orr	r2, r1, r2
 7017 3e10 6C3097E5 		ldr	r3, [r7, #108]
 7018 3e14 3C129FE5 		ldr	r1, .L610+124
 7019 3e18 0400A0E3 		mov	r0, #4
 7020 3e1c FEFFFFEB 		bl	CyU3PDebugPrint
 7021              	.LVL763:
3770:../uvc.c      ****                  	case 4: //VGA
 7022              		.loc 1 3770 0
 7023 3e20 AEFFFFEA 		b	.L531
 7024              	.LVL764:
 7025              	.L579:
 7026              	.LBB116:
 7027              	.LBB100:
3066:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7028              		.loc 1 3066 0
 7029 3e24 0400A0E3 		mov	r0, #4
 7030              	.LVL765:
 7031 3e28 38129FE5 		ldr	r1, .L610+140
 7032 3e2c FEFFFFEB 		bl	CyU3PDebugPrint
 7033              	.LVL766:
3067:../uvc.c      ****     }
 7034              		.loc 1 3067 0
 7035 3e30 0400A0E1 		mov	r0, r4
 7036 3e34 FEFFFFEB 		bl	CyFxAppErrorHandler
 7037              	.LVL767:
 7038              	.L609:
 7039              	.LBE100:
 7040              	.LBE116:
 7041              	.LBB117:
 7042              	.LBB107:
3532:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7043              		.loc 1 3532 0
 7044 3e38 0800A0E1 		mov	r0, r8
 7045              	.LVL768:
 7046              	.L576:
 7047 3e3c 28129FE5 		ldr	r1, .L610+144
 7048 3e40 0420A0E1 		mov	r2, r4
 7049 3e44 FEFFFFEB 		bl	CyU3PDebugPrint
 7050              	.LVL769:
3533:../uvc.c      ****     }
 7051              		.loc 1 3533 0
 7052 3e48 0400A0E1 		mov	r0, r4
 7053 3e4c 8BFFFFEA 		b	.L578
 7054              	.LVL770:
 7055              	.L595:
3507:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7056              		.loc 1 3507 0
 7057 3e50 0800A0E1 		mov	r0, r8
 7058              	.LVL771:
 7059 3e54 14129FE5 		ldr	r1, .L610+148
 7060 3e58 0420A0E1 		mov	r2, r4
 7061 3e5c FEFFFFEB 		bl	CyU3PDebugPrint
 7062              	.LVL772:
3508:../uvc.c      ****     }
 7063              		.loc 1 3508 0
 7064 3e60 0400A0E1 		mov	r0, r4
 7065 3e64 FEFFFFEB 		bl	CyFxAppErrorHandler
 7066              	.LVL773:
 7067              	.L608:
 7068              	.LBE107:
 7069              	.LBE117:
 7070              	.LBB118:
 7071              	.LBB114:
3570:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7072              		.loc 1 3570 0
 7073 3e68 0400A0E3 		mov	r0, #4
 7074              	.LVL774:
 7075 3e6c 00129FE5 		ldr	r1, .L610+152
 7076 3e70 0520A0E1 		mov	r2, r5
 7077 3e74 FEFFFFEB 		bl	CyU3PDebugPrint
 7078              	.LVL775:
3571:../uvc.c      ****     }
 7079              		.loc 1 3571 0
 7080 3e78 0500A0E1 		mov	r0, r5
 7081 3e7c 7FFFFFEA 		b	.L578
 7082              	.LVL776:
 7083              	.L583:
 7084              	.LBE114:
 7085              	.LBE118:
 7086              	.LBB119:
 7087              	.LBB108:
3223:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7088              		.loc 1 3223 0
 7089 3e80 0400A0E3 		mov	r0, #4
 7090              	.LVL777:
 7091 3e84 EC119FE5 		ldr	r1, .L610+156
 7092 3e88 0520A0E1 		mov	r2, r5
 7093 3e8c FEFFFFEB 		bl	CyU3PDebugPrint
 7094              	.LVL778:
3224:../uvc.c      ****     }
 7095              		.loc 1 3224 0
 7096 3e90 0500A0E1 		mov	r0, r5
 7097 3e94 FEFFFFEB 		bl	CyFxAppErrorHandler
 7098              	.LVL779:
 7099              	.L582:
3201:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7100              		.loc 1 3201 0
 7101 3e98 0400A0E3 		mov	r0, #4
 7102              	.LVL780:
 7103 3e9c D8119FE5 		ldr	r1, .L610+160
 7104 3ea0 0520A0E1 		mov	r2, r5
 7105 3ea4 FEFFFFEB 		bl	CyU3PDebugPrint
 7106              	.LVL781:
3202:../uvc.c      ****     }
 7107              		.loc 1 3202 0
 7108 3ea8 0500A0E1 		mov	r0, r5
 7109 3eac FEFFFFEB 		bl	CyFxAppErrorHandler
 7110              	.LVL782:
 7111              	.L581:
 7112              	.LBE108:
 7113              	.LBE119:
 7114              	.LBB120:
 7115              	.LBB103:
3127:../uvc.c      ****         CyFxAppErrorHandler (status);
 7116              		.loc 1 3127 0
 7117 3eb0 0400A0E3 		mov	r0, #4
 7118              	.LVL783:
 7119 3eb4 C4119FE5 		ldr	r1, .L610+164
 7120 3eb8 FEFFFFEB 		bl	CyU3PDebugPrint
 7121              	.LVL784:
3128:../uvc.c      ****     }
 7122              		.loc 1 3128 0
 7123 3ebc 0500A0E1 		mov	r0, r5
 7124 3ec0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7125              	.LVL785:
 7126              	.L580:
3114:../uvc.c      ****         CyFxAppErrorHandler (status);
 7127              		.loc 1 3114 0
 7128 3ec4 0400A0E3 		mov	r0, #4
 7129              	.LVL786:
 7130 3ec8 B4119FE5 		ldr	r1, .L610+168
 7131 3ecc FEFFFFEB 		bl	CyU3PDebugPrint
 7132              	.LVL787:
3115:../uvc.c      ****     }
 7133              		.loc 1 3115 0
 7134 3ed0 0500A0E1 		mov	r0, r5
 7135 3ed4 FEFFFFEB 		bl	CyFxAppErrorHandler
 7136              	.LVL788:
 7137              	.L591:
 7138              	.LBE103:
 7139              	.LBE120:
 7140              	.LBB121:
 7141              	.LBB109:
3319:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7142              		.loc 1 3319 0
 7143 3ed8 0400A0E3 		mov	r0, #4
 7144              	.LVL789:
 7145 3edc A4119FE5 		ldr	r1, .L610+172
 7146 3ee0 0420A0E1 		mov	r2, r4
 7147 3ee4 FEFFFFEB 		bl	CyU3PDebugPrint
 7148              	.LVL790:
3320:../uvc.c      ****     }
 7149              		.loc 1 3320 0
 7150 3ee8 0400A0E1 		mov	r0, r4
 7151 3eec FEFFFFEB 		bl	CyFxAppErrorHandler
 7152              	.LVL791:
 7153              	.L590:
3298:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7154              		.loc 1 3298 0
 7155 3ef0 0400A0E3 		mov	r0, #4
 7156              	.LVL792:
 7157 3ef4 90119FE5 		ldr	r1, .L610+176
 7158 3ef8 0420A0E1 		mov	r2, r4
 7159 3efc FEFFFFEB 		bl	CyU3PDebugPrint
 7160              	.LVL793:
3299:../uvc.c      ****     }
 7161              		.loc 1 3299 0
 7162 3f00 0400A0E1 		mov	r0, r4
 7163 3f04 FEFFFFEB 		bl	CyFxAppErrorHandler
 7164              	.LVL794:
 7165              	.L589:
3285:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7166              		.loc 1 3285 0
 7167 3f08 0400A0E3 		mov	r0, #4
 7168              	.LVL795:
 7169 3f0c 7C119FE5 		ldr	r1, .L610+180
 7170 3f10 0420A0E1 		mov	r2, r4
 7171 3f14 FEFFFFEB 		bl	CyU3PDebugPrint
 7172              	.LVL796:
3286:../uvc.c      ****     }
 7173              		.loc 1 3286 0
 7174 3f18 0400A0E1 		mov	r0, r4
 7175 3f1c FEFFFFEB 		bl	CyFxAppErrorHandler
 7176              	.LVL797:
 7177              	.L588:
3271:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7178              		.loc 1 3271 0
 7179 3f20 0400A0E3 		mov	r0, #4
 7180              	.LVL798:
 7181 3f24 68119FE5 		ldr	r1, .L610+184
 7182 3f28 0420A0E1 		mov	r2, r4
 7183 3f2c FEFFFFEB 		bl	CyU3PDebugPrint
 7184              	.LVL799:
3272:../uvc.c      ****     }
 7185              		.loc 1 3272 0
 7186 3f30 0400A0E1 		mov	r0, r4
 7187 3f34 FEFFFFEB 		bl	CyFxAppErrorHandler
 7188              	.LVL800:
 7189              	.L587:
3257:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7190              		.loc 1 3257 0
 7191 3f38 0400A0E3 		mov	r0, #4
 7192              	.LVL801:
 7193 3f3c 54119FE5 		ldr	r1, .L610+188
 7194 3f40 0620A0E1 		mov	r2, r6
 7195 3f44 FEFFFFEB 		bl	CyU3PDebugPrint
 7196              	.LVL802:
3258:../uvc.c      ****     }
 7197              		.loc 1 3258 0
 7198 3f48 0600A0E1 		mov	r0, r6
 7199 3f4c FEFFFFEB 		bl	CyFxAppErrorHandler
 7200              	.LVL803:
 7201              	.L586:
3244:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7202              		.loc 1 3244 0
 7203 3f50 0400A0E3 		mov	r0, #4
 7204              	.LVL804:
 7205 3f54 40119FE5 		ldr	r1, .L610+192
 7206 3f58 0520A0E1 		mov	r2, r5
 7207 3f5c FEFFFFEB 		bl	CyU3PDebugPrint
 7208              	.LVL805:
3245:../uvc.c      ****     }
 7209              		.loc 1 3245 0
 7210 3f60 0500A0E1 		mov	r0, r5
 7211 3f64 FEFFFFEB 		bl	CyFxAppErrorHandler
 7212              	.LVL806:
 7213              	.L585:
3238:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7214              		.loc 1 3238 0
 7215 3f68 0400A0E3 		mov	r0, #4
 7216              	.LVL807:
 7217 3f6c 2C119FE5 		ldr	r1, .L610+196
 7218 3f70 0520A0E1 		mov	r2, r5
 7219 3f74 FEFFFFEB 		bl	CyU3PDebugPrint
 7220              	.LVL808:
3239:../uvc.c      ****     }
 7221              		.loc 1 3239 0
 7222 3f78 0500A0E1 		mov	r0, r5
 7223 3f7c FEFFFFEB 		bl	CyFxAppErrorHandler
 7224              	.LVL809:
 7225              	.L584:
3232:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7226              		.loc 1 3232 0
 7227 3f80 0400A0E3 		mov	r0, #4
 7228              	.LVL810:
 7229 3f84 18119FE5 		ldr	r1, .L610+200
 7230 3f88 0520A0E1 		mov	r2, r5
 7231 3f8c FEFFFFEB 		bl	CyU3PDebugPrint
 7232              	.LVL811:
3233:../uvc.c      ****     }
 7233              		.loc 1 3233 0
 7234 3f90 0500A0E1 		mov	r0, r5
 7235 3f94 FEFFFFEB 		bl	CyFxAppErrorHandler
 7236              	.LVL812:
 7237              	.L594:
3416:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7238              		.loc 1 3416 0
 7239 3f98 0800A0E1 		mov	r0, r8
 7240              	.LVL813:
 7241 3f9c 04119FE5 		ldr	r1, .L610+204
 7242 3fa0 0420A0E1 		mov	r2, r4
 7243 3fa4 FEFFFFEB 		bl	CyU3PDebugPrint
 7244              	.LVL814:
3417:../uvc.c      ****     }
 7245              		.loc 1 3417 0
 7246 3fa8 0400A0E1 		mov	r0, r4
 7247 3fac FEFFFFEB 		bl	CyFxAppErrorHandler
 7248              	.LVL815:
 7249              	.L592:
3385:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7250              		.loc 1 3385 0
 7251 3fb0 0400A0E3 		mov	r0, #4
 7252              	.LVL816:
 7253 3fb4 F0109FE5 		ldr	r1, .L610+208
 7254 3fb8 0420A0E1 		mov	r2, r4
 7255 3fbc FEFFFFEB 		bl	CyU3PDebugPrint
 7256              	.LVL817:
3386:../uvc.c      ****     }
 7257              		.loc 1 3386 0
 7258 3fc0 0400A0E1 		mov	r0, r4
 7259 3fc4 FEFFFFEB 		bl	CyFxAppErrorHandler
 7260              	.LVL818:
 7261              	.L593:
3392:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
 7262              		.loc 1 3392 0
 7263 3fc8 0400A0E3 		mov	r0, #4
 7264 3fcc DC109FE5 		ldr	r1, .L610+212
 7265 3fd0 FEFFFFEB 		bl	CyU3PDebugPrint
 7266              	.LVL819:
3393:../uvc.c      ****     }
 7267              		.loc 1 3393 0
 7268 3fd4 0800A0E1 		mov	r0, r8
 7269 3fd8 FEFFFFEB 		bl	CyFxAppErrorHandler
 7270              	.LVL820:
 7271              	.L611:
 7272              		.align	2
 7273              	.L610:
 7274 3fdc 00C20100 		.word	115200
 7275 3fe0 A0860100 		.word	100000
 7276 3fe4 00000000 		.word	.LANCHOR0
 7277 3fe8 00000000 		.word	CyFxGpifCB
 7278 3fec 88130000 		.word	5000
 7279 3ff0 00000000 		.word	CyFxUVCApplnUSBSetupCB
 7280 3ff4 00000000 		.word	CyFxUVCApplnUSBEventCB
 7281 3ff8 00000000 		.word	CyFxUSBDeviceDscr
 7282 3ffc 00000000 		.word	CyFxUSBDeviceDscrSS
 7283 4000 00000000 		.word	CyFxUSBDeviceQualDscr
 7284 4004 00000000 		.word	CyFxUSBBOSDscr
 7285 4008 00000000 		.word	CyFxUSBHSConfigDscr
 7286 400c 00000000 		.word	CyFxUSBFSConfigDscr
 7287 4010 00000000 		.word	CyFxUSBSSConfigDscr
 7288 4014 00000000 		.word	CyFxUSBStringLangIDDscr
 7289 4018 00000000 		.word	CyFxUSBManufactureDscr
 7290 401c 00000000 		.word	CyFxUSBProductDscr
 7291 4020 013F0203 		.word	50478849
 7292 4024 00000000 		.word	glChHandleInterStat
 7293 4028 00000000 		.word	glInterStaBuffer
 7294 402c 00000000 		.word	imgHdMux
 7295 4030 01010000 		.word	257
 7296 4034 03030000 		.word	771
 7297 4038 00000000 		.word	CyFxUvcApplnDmaCallback
 7298 403c 00000000 		.word	glChHandleUVCStream
 7299 4040 00000000 		.word	.LANCHOR1
 7300 4044 A00B0000 		.word	.LC65
 7301 4048 A0010000 		.word	.LANCHOR2+416
 7302 404c F80B0000 		.word	.LC68
 7303 4050 B00B0000 		.word	.LC66
 7304 4054 BC010000 		.word	.LANCHOR2+444
 7305 4058 E80A0000 		.word	.LC61
 7306 405c 380B0000 		.word	.LC63
 7307 4060 6C0B0000 		.word	.LC64
 7308 4064 0C0B0000 		.word	.LC62
 7309 4068 BC070000 		.word	.LC43
 7310 406c E4090000 		.word	.LC56
 7311 4070 C00A0000 		.word	.LC60
 7312 4074 C00B0000 		.word	.LC67
 7313 4078 40080000 		.word	.LC47
 7314 407c 14080000 		.word	.LC46
 7315 4080 F8070000 		.word	.LC45
 7316 4084 DC070000 		.word	.LC44
 7317 4088 B4090000 		.word	.LC55
 7318 408c 84090000 		.word	.LC54
 7319 4090 4C090000 		.word	.LC53
 7320 4094 18090000 		.word	.LC52
 7321 4098 E4080000 		.word	.LC51
 7322 409c B8080000 		.word	.LC50
 7323 40a0 8C080000 		.word	.LC49
 7324 40a4 64080000 		.word	.LC48
 7325 40a8 900A0000 		.word	.LC59
 7326 40ac 180A0000 		.word	.LC57
 7327 40b0 580A0000 		.word	.LC58
 7328              	.LBE109:
 7329              	.LBE121:
 7330              		.cfi_endproc
 7331              	.LFE19:
 7333              		.align	2
 7334              		.global	UVCAppEP0Thread_Entry
 7336              	UVCAppEP0Thread_Entry:
 7337              	.LFB25:
4715:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 7338              		.loc 1 4715 0
 7339              		.cfi_startproc
 7340              		@ args = 0, pretend = 0, frame = 64
 7341              		@ frame_needed = 0, uses_anonymous_args = 0
 7342              	.LVL821:
 7343 40b4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 7344              	.LCFI27:
 7345              		.cfi_def_cfa_offset 36
 7346              		.cfi_offset 4, -36
 7347              		.cfi_offset 5, -32
 7348              		.cfi_offset 6, -28
 7349              		.cfi_offset 7, -24
 7350              		.cfi_offset 8, -20
 7351              		.cfi_offset 9, -16
 7352              		.cfi_offset 10, -12
 7353              		.cfi_offset 11, -8
 7354              		.cfi_offset 14, -4
 7355 40b8 E08F9FE5 		ldr	r8, .L906
 7356 40bc E0BF9FE5 		ldr	fp, .L906+4
 7357 40c0 E06F9FE5 		ldr	r6, .L906+8
4789:../uvc.c      ****                 {
 7358              		.loc 1 4789 0
 7359 40c4 E0AF9FE5 		ldr	r10, .L906+12
 7360              	.LBB142:
 7361              	.LBB143:
4222:../uvc.c      ****     {
 7362              		.loc 1 4222 0
 7363 40c8 E07F9FE5 		ldr	r7, .L906+16
 7364              	.LBE143:
 7365              	.LBE142:
4715:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 7366              		.loc 1 4715 0
 7367 40cc 5CD04DE2 		sub	sp, sp, #92
 7368              	.LCFI28:
 7369              		.cfi_def_cfa_offset 128
 7370              	.LVL822:
4737:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
 7371              		.loc 1 4737 0
 7372 40d0 0890A0E1 		mov	r9, r8
 7373              	.LVL823:
 7374              	.L817:
 7375 40d4 0030E0E3 		mvn	r3, #0
 7376 40d8 00308DE5 		str	r3, [sp]
 7377 40dc BC0F9FE5 		ldr	r0, .L906
 7378 40e0 4C10A0E3 		mov	r1, #76
 7379 40e4 0120A0E3 		mov	r2, #1
 7380 40e8 44308DE2 		add	r3, sp, #68
 7381 40ec FEFFFFEB 		bl	_txe_event_flags_get
 7382              	.LVL824:
 7383 40f0 000050E3 		cmp	r0, #0
 7384 40f4 3700001A 		bne	.L614
4741:../uvc.c      ****             {
 7385              		.loc 1 4741 0
 7386 40f8 8C3099E5 		ldr	r3, [r9, #140]
 7387 40fc 000053E3 		cmp	r3, #0
 7388 4100 9900000A 		beq	.L875
 7389              	.L616:
4750:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 7390              		.loc 1 4750 0
 7391 4104 44309DE5 		ldr	r3, [sp, #68]
 7392 4108 0C0013E3 		tst	r3, #12
 7393 410c 8100001A 		bne	.L876
 7394              	.L618:
4757:../uvc.c      ****             {
 7395              		.loc 1 4757 0
 7396 4110 040013E3 		tst	r3, #4
 7397 4114 1B00000A 		beq	.L619
4759:../uvc.c      ****                 {
 7398              		.loc 1 4759 0
 7399 4118 B020DAE1 		ldrh	r2, [r10]
 7400 411c 2224A0E1 		mov	r2, r2, lsr #8
 7401 4120 030052E3 		cmp	r2, #3
 7402 4124 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 7403 4128 110000EA 		b	.L620
 7404              	.L622:
 7405 412c 74410000 		.word	.L620
 7406 4130 A8420000 		.word	.L623
 7407 4134 E0410000 		.word	.L624
 7408 4138 C4420000 		.word	.L625
 7409              	.L628:
 7410              	.LBB168:
 7411              	.LBB169:
3921:../uvc.c      ****     {
 7412              		.loc 1 3921 0
 7413 413c 0A0C52E3 		cmp	r2, #2560
 7414 4140 3F01000A 		beq	.L634
 7415 4144 2E01009A 		bls	.L877
 7416 4148 0D0C52E3 		cmp	r2, #3328
 7417 414c 3C01000A 		beq	.L634
 7418 4150 0E0C52E3 		cmp	r2, #3584
 7419 4154 3201000A 		beq	.L638
 7420 4158 030B52E3 		cmp	r2, #3072
 7421 415c 9101000A 		beq	.L878
 7422              	.L626:
3974:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 7423              		.loc 1 3974 0
 7424 4160 883F9FE5 		ldr	r3, .L906+80
 7425 4164 0400A0E3 		mov	r0, #4
 7426 4168 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 7427 416c 401F9FE5 		ldr	r1, .L906+20
 7428 4170 FEFFFFEB 		bl	CyU3PDebugPrint
 7429              	.LVL825:
 7430              	.L620:
 7431              	.LBE169:
 7432              	.LBE168:
4780:../uvc.c      ****                         break;
 7433              		.loc 1 4780 0
 7434 4174 0000A0E3 		mov	r0, #0
 7435 4178 0020A0E1 		mov	r2, r0
 7436 417c 0110A0E3 		mov	r1, #1
 7437 4180 FEFFFFEB 		bl	CyU3PUsbStall
 7438              	.LVL826:
 7439 4184 44309DE5 		ldr	r3, [sp, #68]
 7440              	.L619:
4785:../uvc.c      ****             {
 7441              		.loc 1 4785 0
 7442 4188 080013E3 		tst	r3, #8
 7443 418c 0700000A 		beq	.L811
4789:../uvc.c      ****                 {
 7444              		.loc 1 4789 0
 7445 4190 B030DAE1 		ldrh	r3, [r10]
 7446 4194 010053E3 		cmp	r3, #1
 7447 4198 7900000A 		beq	.L812
4791:../uvc.c      ****                 }
 7448              		.loc 1 4791 0
 7449 419c 0000A0E3 		mov	r0, #0
 7450 41a0 0020A0E1 		mov	r2, r0
 7451 41a4 0110A0E3 		mov	r1, #1
 7452 41a8 FEFFFFEB 		bl	CyU3PUsbStall
 7453              	.LVL827:
 7454 41ac 44309DE5 		ldr	r3, [sp, #68]
 7455              	.L811:
4800:../uvc.c      ****             {
 7456              		.loc 1 4800 0
 7457 41b0 400013E3 		tst	r3, #64
 7458 41b4 0700000A 		beq	.L614
4805:../uvc.c      **** 
 7459              		.loc 1 4805 0
 7460 41b8 1800A0E3 		mov	r0, #24
 7461 41bc 48108DE2 		add	r1, sp, #72
 7462              	.LVL828:
 7463 41c0 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
 7464              	.LVL829:
4862:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 7465              		.loc 1 4862 0
 7466 41c4 9237DBE5 		ldrb	r3, [fp, #1938]	@ zero_extendqisi2
 7467 41c8 0F0053E3 		cmp	r3, #15
 7468 41cc 8F00000A 		beq	.L879
4889:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 7469              		.loc 1 4889 0
 7470 41d0 000053E3 		cmp	r3, #0
 7471 41d4 6D00000A 		beq	.L880
 7472              	.L614:
5013:../uvc.c      ****     }
 7473              		.loc 1 5013 0
 7474 41d8 FEFFFFEB 		bl	_txe_thread_relinquish
 7475              	.LVL830:
5014:../uvc.c      **** }
 7476              		.loc 1 5014 0
 7477 41dc BCFFFFEA 		b	.L817
 7478              	.L624:
 7479              	.LBB281:
 7480              	.LBB272:
3921:../uvc.c      ****     {
 7481              		.loc 1 3921 0
 7482 41e0 B020D7E1 		ldrh	r2, [r7]
 7483 41e4 060C52E3 		cmp	r2, #1536
 7484 41e8 6A01000A 		beq	.L627
 7485 41ec D2FFFF8A 		bhi	.L628
 7486 41f0 030C52E3 		cmp	r2, #768
 7487 41f4 9201000A 		beq	.L629
 7488 41f8 D400008A 		bhi	.L630
 7489 41fc 010C52E3 		cmp	r2, #256
 7490 4200 3A01000A 		beq	.L631
 7491 4204 020C52E3 		cmp	r2, #512
 7492 4208 D4FFFF1A 		bne	.L626
 7493              	.LVL831:
 7494              	.LBB170:
 7495              	.LBB171:
1359:../uvc.c      ****     /*
 7496              		.loc 1 1359 0
 7497 420c DC3E9FE5 		ldr	r3, .L906+80
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7498              		.loc 1 1348 0
 7499 4210 4805DBE5 		ldrb	r0, [fp, #1352]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 7500              		.loc 1 1359 0
 7501 4214 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7502              		.loc 1 1349 0
 7503 4218 4915DBE5 		ldrb	r1, [fp, #1353]	@ zero_extendqisi2
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7504              		.loc 1 1350 0
 7505 421c 5725DBE5 		ldrb	r2, [fp, #1367]	@ zero_extendqisi2
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 7506              		.loc 1 1351 0
 7507 4220 4A35DBE5 		ldrb	r3, [fp, #1354]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7508              		.loc 1 1349 0
 7509 4224 FF1001E2 		and	r1, r1, #255
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7510              		.loc 1 1350 0
 7511 4228 FF2002E2 		and	r2, r2, #255
1367:../uvc.c      **** 		 {
 7512              		.loc 1 1367 0
 7513 422c 830055E3 		cmp	r5, #131
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7514              		.loc 1 1348 0
 7515 4230 FFC000E2 		and	ip, r0, #255
 7516              	.LVL832:
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7517              		.loc 1 1349 0
 7518 4234 2C108DE5 		str	r1, [sp, #44]
 7519              	.LVL833:
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7520              		.loc 1 1350 0
 7521 4238 28208DE5 		str	r2, [sp, #40]
 7522              	.LVL834:
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 7523              		.loc 1 1351 0
 7524 423c FF3003E2 		and	r3, r3, #255
 7525              	.LVL835:
1367:../uvc.c      **** 		 {
 7526              		.loc 1 1367 0
 7527 4240 C004000A 		beq	.L660
 7528 4244 FB02009A 		bls	.L881
 7529 4248 850055E3 		cmp	r5, #133
 7530 424c 9904000A 		beq	.L665
 7531 4250 8E04003A 		bcc	.L666
 7532 4254 860055E3 		cmp	r5, #134
 7533 4258 FE03000A 		beq	.L667
 7534 425c 870055E3 		cmp	r5, #135
 7535 4260 0F05001A 		bne	.L659
1806:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 7536              		.loc 1 1806 0
 7537 4264 020053E3 		cmp	r3, #2
1807:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 7538              		.loc 1 1807 0
 7539 4268 53C5DBE5 		ldrb	ip, [fp, #1363]	@ zero_extendqisi2
 7540              	.LVL836:
1818:../uvc.c      **** 		 	 if(Len == 2){
 7541              		.loc 1 1818 0
 7542 426c 0300A0E1 		mov	r0, r3
 7543              	.LVL837:
1808:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 7544              		.loc 1 1808 0
 7545 4270 5425DBE5 		ldrb	r2, [fp, #1364]	@ zero_extendqisi2
1806:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 7546              		.loc 1 1806 0
 7547 4274 7203000A 		beq	.L859
 7548              	.L672:
1814:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 7549              		.loc 1 1814 0
 7550 4278 0030A0E3 		mov	r3, #0
 7551              	.LVL838:
1818:../uvc.c      **** 		 	 if(Len == 2){
 7552              		.loc 1 1818 0
 7553 427c 7C1E9FE5 		ldr	r1, .L906+96
1811:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 7554              		.loc 1 1811 0
 7555 4280 28C0C8E5 		strb	ip, [r8, #40]
1813:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7556              		.loc 1 1813 0
 7557 4284 2920C8E5 		strb	r2, [r8, #41]
1814:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 7558              		.loc 1 1814 0
 7559 4288 2B30C8E5 		strb	r3, [r8, #43]
1824:../uvc.c      **** 		 	 }
 7560              		.loc 1 1824 0
 7561 428c 24308DE5 		str	r3, [sp, #36]
 7562 4290 0040A0E3 		mov	r4, #0
1818:../uvc.c      **** 		 	 if(Len == 2){
 7563              		.loc 1 1818 0
 7564 4294 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7565              	.LVL839:
1823:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 7566              		.loc 1 1823 0
 7567 4298 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 7568              	.LVL840:
1824:../uvc.c      **** 		 	 }
 7569              		.loc 1 1824 0
 7570 429c 2A30D8E5 		ldrb	r3, [r8, #42]	@ zero_extendqisi2
 7571              	.LVL841:
 7572 42a0 24C09DE5 		ldr	ip, [sp, #36]
 7573 42a4 180300EA 		b	.L669
 7574              	.LVL842:
 7575              	.L623:
 7576              	.LBE171:
 7577              	.LBE170:
 7578              	.LBE272:
 7579              	.LBE281:
 7580              	.LBB282:
 7581              	.LBB283:
4054:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 7582              		.loc 1 4054 0
 7583 42a8 403E9FE5 		ldr	r3, .L906+80
 7584 42ac 001E9FE5 		ldr	r1, .L906+20
 7585 42b0 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 7586 42b4 B020D7E1 		ldrh	r2, [r7]
 7587 42b8 0400A0E3 		mov	r0, #4
 7588 42bc FEFFFFEB 		bl	CyU3PDebugPrint
 7589              	.LVL843:
 7590 42c0 ABFFFFEA 		b	.L620
 7591              	.L625:
 7592              	.LBE283:
 7593              	.LBE282:
 7594              	.LBB284:
 7595              	.LBB158:
4222:../uvc.c      ****     {
 7596              		.loc 1 4222 0
 7597 42c4 B030D7E1 		ldrh	r3, [r7]
 7598 42c8 E04D9FE5 		ldr	r4, .L906+16
 7599 42cc 0D0C53E3 		cmp	r3, #3328
 7600 42d0 1603000A 		beq	.L754
 7601 42d4 6F00008A 		bhi	.L755
 7602 42d8 060C53E3 		cmp	r3, #1536
 7603 42dc 3103000A 		beq	.L756
 7604 42e0 8F00009A 		bls	.L882
 7605 42e4 090C53E3 		cmp	r3, #2304
 7606 42e8 2A03000A 		beq	.L764
 7607 42ec 6001009A 		bls	.L883
 7608 42f0 0B0C53E3 		cmp	r3, #2816
 7609 42f4 2303000A 		beq	.L768
 7610 42f8 030B53E3 		cmp	r3, #3072
 7611 42fc 9F01000A 		beq	.L769
 7612 4300 0A0C53E3 		cmp	r3, #2560
 7613 4304 9AFFFF1A 		bne	.L620
 7614              	.LVL844:
4263:../uvc.c      ****     		}else/* no support for 1080p camera */
 7615              		.loc 1 4263 0
 7616 4308 1900A0E3 		mov	r0, #25
 7617 430c FEFFFFEB 		bl	ControlHandle
 7618              	.LVL845:
 7619 4310 44309DE5 		ldr	r3, [sp, #68]
 7620 4314 9BFFFFEA 		b	.L619
 7621              	.L876:
 7622              	.LBE158:
 7623              	.LBE284:
4751:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
 7624              		.loc 1 4751 0
 7625 4318 980D9FE5 		ldr	r0, .L906+24
 7626 431c CC1D9FE5 		ldr	r1, .L906+80
 7627 4320 942D9FE5 		ldr	r2, .L906+28
 7628 4324 0000D0E5 		ldrb	r0, [r0]	@ zero_extendqisi2
 7629 4328 00E0D1E5 		ldrb	lr, [r1]	@ zero_extendqisi2
 7630 432c B010D2E1 		ldrh	r1, [r2]
 7631 4330 B0C0D7E1 		ldrh	ip, [r7]
 7632 4334 00008DE5 		str	r0, [sp]
 7633 4338 B000DAE1 		ldrh	r0, [r10]
 7634 433c 10108DE5 		str	r1, [sp, #16]
 7635 4340 0010A0E3 		mov	r1, #0
 7636 4344 0C008DE5 		str	r0, [sp, #12]
 7637 4348 14108DE5 		str	r1, [sp, #20]
 7638 434c 4820D8E5 		ldrb	r2, [r8, #72]	@ zero_extendqisi2
 7639 4350 04E08DE5 		str	lr, [sp, #4]
 7640 4354 08C08DE5 		str	ip, [sp, #8]
 7641 4358 0400A0E3 		mov	r0, #4
 7642 435c 5C1D9FE5 		ldr	r1, .L906+32
 7643 4360 FEFFFFEB 		bl	CyU3PDebugPrint
 7644              	.LVL846:
 7645 4364 44309DE5 		ldr	r3, [sp, #68]
 7646 4368 68FFFFEA 		b	.L618
 7647              	.L875:
4743:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 7648              		.loc 1 4743 0
 7649 436c FEFFFFEB 		bl	CyU3PUsbGetSpeed
 7650              	.LVL847:
4744:../uvc.c      ****                 {
 7651              		.loc 1 4744 0
 7652 4370 000050E3 		cmp	r0, #0
4746:../uvc.c      ****                 }
 7653              		.loc 1 4746 0
 7654 4374 0130A013 		movne	r3, #1
4743:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 7655              		.loc 1 4743 0
 7656 4378 4800C9E5 		strb	r0, [r9, #72]
4746:../uvc.c      ****                 }
 7657              		.loc 1 4746 0
 7658 437c 8C308915 		strne	r3, [r9, #140]
 7659 4380 5FFFFFEA 		b	.L616
 7660              	.L812:
4795:../uvc.c      ****                 }
 7661              		.loc 1 4795 0
 7662 4384 2CEFFFEB 		bl	UVCHandleVideoStreamingRqts
 7663              	.LVL848:
 7664 4388 44309DE5 		ldr	r3, [sp, #68]
 7665 438c 87FFFFEA 		b	.L811
 7666              	.L880:
4891:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 7667              		.loc 1 4891 0
 7668 4390 002096E5 		ldr	r2, [r6]
 7669 4394 0210A0E3 		mov	r1, #2
 7670 4398 0010C2E5 		strb	r1, [r2]
4892:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 7671              		.loc 1 4892 0
 7672 439c 002096E5 		ldr	r2, [r6]
 7673 43a0 0140A0E3 		mov	r4, #1
 7674 43a4 0140C2E5 		strb	r4, [r2, #1]
4893:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 7675              		.loc 1 4893 0
 7676 43a8 001096E5 		ldr	r1, [r6]
4897:../uvc.c      **** 					interStabuf.status = 0;
 7677              		.loc 1 4897 0
 7678 43ac 012BA0E3 		mov	r2, #1024
4893:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 7679              		.loc 1 4893 0
 7680 43b0 0230C1E5 		strb	r3, [r1, #2]
4894:../uvc.c      **** 
 7681              		.loc 1 4894 0
 7682 43b4 001096E5 		ldr	r1, [r6]
4900:../uvc.c      **** 
 7683              		.loc 1 4900 0
 7684 43b8 0450A0E3 		mov	r5, #4
4894:../uvc.c      **** 
 7685              		.loc 1 4894 0
 7686 43bc 0340C1E5 		strb	r4, [r1, #3]
4896:../uvc.c      **** 					interStabuf.size   = 1024;
 7687              		.loc 1 4896 0
 7688 43c0 001096E5 		ldr	r1, [r6]
4903:../uvc.c      **** 
 7689              		.loc 1 4903 0
 7690 43c4 F80C9FE5 		ldr	r0, .L906+36
4896:../uvc.c      **** 					interStabuf.size   = 1024;
 7691              		.loc 1 4896 0
 7692 43c8 4C108DE5 		str	r1, [sp, #76]
4903:../uvc.c      **** 
 7693              		.loc 1 4903 0
 7694 43cc 0010E0E3 		mvn	r1, #0
4898:../uvc.c      **** 
 7695              		.loc 1 4898 0
 7696 43d0 B435CDE1 		strh	r3, [sp, #84]	@ movhi
4897:../uvc.c      **** 					interStabuf.status = 0;
 7697              		.loc 1 4897 0
 7698 43d4 B225CDE1 		strh	r2, [sp, #82]	@ movhi
4900:../uvc.c      **** 
 7699              		.loc 1 4900 0
 7700 43d8 B055CDE1 		strh	r5, [sp, #80]	@ movhi
4903:../uvc.c      **** 
 7701              		.loc 1 4903 0
 7702 43dc FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 7703              	.LVL849:
4906:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
 7704              		.loc 1 4906 0
 7705 43e0 DC0C9FE5 		ldr	r0, .L906+36
 7706 43e4 4C108DE2 		add	r1, sp, #76
 7707 43e8 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 7708              	.LVL850:
4908:../uvc.c      **** 					{
 7709              		.loc 1 4908 0
 7710 43ec 000050E3 		cmp	r0, #0
 7711 43f0 3D01001A 		bne	.L884
4914:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 7712              		.loc 1 4914 0
 7713 43f4 0500A0E3 		mov	r0, #5
 7714              	.LVL851:
 7715 43f8 3010A0E3 		mov	r1, #48
 7716 43fc 0420A0E1 		mov	r2, r4
 7717 4400 FEFFFFEB 		bl	SensorSetControl
 7718              	.LVL852:
4915:../uvc.c      **** 				}
 7719              		.loc 1 4915 0
 7720 4404 98CC9FE5 		ldr	ip, .L906+4
 7721 4408 9247CCE5 		strb	r4, [ip, #1938]
 7722 440c 71FFFFEA 		b	.L614
 7723              	.L879:
4864:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 7724              		.loc 1 4864 0
 7725 4410 003096E5 		ldr	r3, [r6]
 7726 4414 0220A0E3 		mov	r2, #2
 7727 4418 0020C3E5 		strb	r2, [r3]
4865:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 7728              		.loc 1 4865 0
 7729 441c 003096E5 		ldr	r3, [r6]
 7730 4420 0140A0E3 		mov	r4, #1
 7731 4424 0140C3E5 		strb	r4, [r3, #1]
4866:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 7732              		.loc 1 4866 0
 7733 4428 002096E5 		ldr	r2, [r6]
 7734 442c 0030A0E3 		mov	r3, #0
 7735 4430 0230C2E5 		strb	r3, [r2, #2]
4867:../uvc.c      **** 
 7736              		.loc 1 4867 0
 7737 4434 001096E5 		ldr	r1, [r6]
4873:../uvc.c      **** 
 7738              		.loc 1 4873 0
 7739 4438 04C0A0E3 		mov	ip, #4
4867:../uvc.c      **** 
 7740              		.loc 1 4867 0
 7741 443c 0330C1E5 		strb	r3, [r1, #3]
4869:../uvc.c      **** 					interStabuf.size   = 1024;
 7742              		.loc 1 4869 0
 7743 4440 001096E5 		ldr	r1, [r6]
4870:../uvc.c      **** 					interStabuf.status = 0;
 7744              		.loc 1 4870 0
 7745 4444 012BA0E3 		mov	r2, #1024
4869:../uvc.c      **** 					interStabuf.size   = 1024;
 7746              		.loc 1 4869 0
 7747 4448 4C108DE5 		str	r1, [sp, #76]
4876:../uvc.c      **** 
 7748              		.loc 1 4876 0
 7749 444c 700C9FE5 		ldr	r0, .L906+36
 7750 4450 0010E0E3 		mvn	r1, #0
4870:../uvc.c      **** 					interStabuf.status = 0;
 7751              		.loc 1 4870 0
 7752 4454 B225CDE1 		strh	r2, [sp, #82]	@ movhi
4873:../uvc.c      **** 
 7753              		.loc 1 4873 0
 7754 4458 B0C5CDE1 		strh	ip, [sp, #80]	@ movhi
4876:../uvc.c      **** 
 7755              		.loc 1 4876 0
 7756 445c 1CC08DE5 		str	ip, [sp, #28]
4871:../uvc.c      **** 
 7757              		.loc 1 4871 0
 7758 4460 B435CDE1 		strh	r3, [sp, #84]	@ movhi
4876:../uvc.c      **** 
 7759              		.loc 1 4876 0
 7760 4464 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 7761              	.LVL853:
4879:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
 7762              		.loc 1 4879 0
 7763 4468 540C9FE5 		ldr	r0, .L906+36
 7764 446c 4C108DE2 		add	r1, sp, #76
 7765 4470 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 7766              	.LVL854:
4881:../uvc.c      **** 					{
 7767              		.loc 1 4881 0
 7768 4474 1CC09DE5 		ldr	ip, [sp, #28]
 7769 4478 002050E2 		subs	r2, r0, #0
 7770 447c E502001A 		bne	.L885
4886:../uvc.c      **** 
 7771              		.loc 1 4886 0
 7772 4480 0500A0E3 		mov	r0, #5
 7773              	.LVL855:
 7774 4484 3010A0E3 		mov	r1, #48
 7775 4488 FEFFFFEB 		bl	SensorSetControl
 7776              	.LVL856:
4888:../uvc.c      **** 				}else if(!snapButFlag){
 7777              		.loc 1 4888 0
 7778 448c 103C9FE5 		ldr	r3, .L906+4
 7779 4490 9247C3E5 		strb	r4, [r3, #1938]
 7780 4494 4FFFFFEA 		b	.L614
 7781              	.L755:
 7782              	.LBB285:
 7783              	.LBB159:
4222:../uvc.c      ****     {
 7784              		.loc 1 4222 0
 7785 4498 150C53E3 		cmp	r3, #5376
 7786 449c D302000A 		beq	.L771
 7787 44a0 0C00008A 		bhi	.L772
 7788 44a4 110C53E3 		cmp	r3, #4352
 7789 44a8 CC02000A 		beq	.L773
 7790 44ac 0601009A 		bls	.L886
 7791 44b0 130C53E3 		cmp	r3, #4864
 7792 44b4 A102000A 		beq	.L777
 7793 44b8 050B53E3 		cmp	r3, #5120
 7794 44bc 3301000A 		beq	.L778
 7795 44c0 120C53E3 		cmp	r3, #4608
 7796 44c4 2AFFFF1A 		bne	.L620
 7797              	.LVL857:
4299:../uvc.c      ****     		break;
 7798              		.loc 1 4299 0
 7799 44c8 2500A0E3 		mov	r0, #37
 7800 44cc FEFFFFEB 		bl	ControlHandle
 7801              	.LVL858:
 7802 44d0 44309DE5 		ldr	r3, [sp, #68]
 7803 44d4 2BFFFFEA 		b	.L619
 7804              	.L772:
4222:../uvc.c      ****     {
 7805              		.loc 1 4222 0
 7806 44d8 060B53E3 		cmp	r3, #6144
 7807 44dc B502000A 		beq	.L780
 7808 44e0 EB00009A 		bls	.L887
 7809 44e4 1B0C53E3 		cmp	r3, #6912
 7810 44e8 9C02000A 		beq	.L784
 7811 44ec 070B53E3 		cmp	r3, #7168
 7812 44f0 0A01000A 		beq	.L785
 7813 44f4 1A0C53E3 		cmp	r3, #6656
 7814 44f8 1DFFFF1A 		bne	.L620
4332:../uvc.c      **** 			CyU3PDebugPrint (4, "The 2DNR start/end command 0x%x 0x%x\r\n", wValue, bRequest);
 7815              		.loc 1 4332 0
 7816 44fc 2D00A0E3 		mov	r0, #45
 7817 4500 FEFFFFEB 		bl	ControlHandle
 7818              	.LVL859:
4333:../uvc.c      ****     		break;
 7819              		.loc 1 4333 0
 7820 4504 E43B9FE5 		ldr	r3, .L906+80
 7821 4508 B020D4E1 		ldrh	r2, [r4]
 7822 450c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 7823 4510 0400A0E3 		mov	r0, #4
 7824 4514 AC1B9FE5 		ldr	r1, .L906+40
 7825 4518 FEFFFFEB 		bl	CyU3PDebugPrint
 7826              	.LVL860:
 7827 451c 44309DE5 		ldr	r3, [sp, #68]
 7828 4520 18FFFFEA 		b	.L619
 7829              	.L882:
4222:../uvc.c      ****     {
 7830              		.loc 1 4222 0
 7831 4524 030C53E3 		cmp	r3, #768
 7832 4528 8802000A 		beq	.L758
 7833 452c C800008A 		bhi	.L759
 7834 4530 010C53E3 		cmp	r3, #256
 7835 4534 F500000A 		beq	.L760
 7836 4538 020C53E3 		cmp	r3, #512
 7837 453c 0CFFFF1A 		bne	.L620
 7838              	.LVL861:
4230:../uvc.c      ****     		break;
 7839              		.loc 1 4230 0
 7840 4540 1100A0E3 		mov	r0, #17
 7841 4544 FEFFFFEB 		bl	ControlHandle
 7842              	.LVL862:
 7843 4548 44309DE5 		ldr	r3, [sp, #68]
 7844 454c 0DFFFFEA 		b	.L619
 7845              	.L630:
 7846              	.LBE159:
 7847              	.LBE285:
 7848              	.LBB286:
 7849              	.LBB273:
3921:../uvc.c      ****     {
 7850              		.loc 1 3921 0
 7851 4550 010B52E3 		cmp	r2, #1024
 7852 4554 0BFFFF0A 		beq	.L619
 7853 4558 050C52E3 		cmp	r2, #1280
 7854 455c FFFEFF1A 		bne	.L626
 7855              	.LVL863:
 7856              	.LBB179:
 7857              	.LBB180:
1359:../uvc.c      ****     /*
 7858              		.loc 1 1359 0
 7859 4560 883B9FE5 		ldr	r3, .L906+80
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7860              		.loc 1 1348 0
 7861 4564 7025DBE5 		ldrb	r2, [fp, #1392]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 7862              		.loc 1 1359 0
 7863 4568 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7864              		.loc 1 1349 0
 7865 456c 71C5DBE5 		ldrb	ip, [fp, #1393]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 7866              		.loc 1 1359 0
 7867 4570 24308DE5 		str	r3, [sp, #36]
1367:../uvc.c      **** 		 {
 7868              		.loc 1 1367 0
 7869 4574 24E09DE5 		ldr	lr, [sp, #36]
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7870              		.loc 1 1350 0
 7871 4578 7F45DBE5 		ldrb	r4, [fp, #1407]	@ zero_extendqisi2
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 7872              		.loc 1 1351 0
 7873 457c 7235DBE5 		ldrb	r3, [fp, #1394]	@ zero_extendqisi2
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7874              		.loc 1 1348 0
 7875 4580 FF2002E2 		and	r2, r2, #255
1367:../uvc.c      **** 		 {
 7876              		.loc 1 1367 0
 7877 4584 83005EE3 		cmp	lr, #131
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7878              		.loc 1 1348 0
 7879 4588 2C208DE5 		str	r2, [sp, #44]
 7880              	.LVL864:
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7881              		.loc 1 1349 0
 7882 458c FFC00CE2 		and	ip, ip, #255
 7883              	.LVL865:
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7884              		.loc 1 1350 0
 7885 4590 FF4004E2 		and	r4, r4, #255
 7886              	.LVL866:
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 7887              		.loc 1 1351 0
 7888 4594 FF3003E2 		and	r3, r3, #255
 7889              	.LVL867:
1367:../uvc.c      **** 		 {
 7890              		.loc 1 1367 0
 7891 4598 D203000A 		beq	.L677
 7892 459c 5F01009A 		bls	.L888
 7893 45a0 24C09DE5 		ldr	ip, [sp, #36]
 7894              	.LVL868:
 7895 45a4 85005CE3 		cmp	ip, #133
 7896 45a8 8504000A 		beq	.L682
 7897 45ac AD03003A 		bcc	.L683
 7898 45b0 86005CE3 		cmp	ip, #134
 7899 45b4 1703000A 		beq	.L684
 7900 45b8 87005CE3 		cmp	ip, #135
 7901 45bc 7504001A 		bne	.L676
1806:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 7902              		.loc 1 1806 0
 7903 45c0 020053E3 		cmp	r3, #2
1807:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 7904              		.loc 1 1807 0
 7905 45c4 7BC5DBE5 		ldrb	ip, [fp, #1403]	@ zero_extendqisi2
1818:../uvc.c      **** 		 	 if(Len == 2){
 7906              		.loc 1 1818 0
 7907 45c8 0300A0E1 		mov	r0, r3
1808:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 7908              		.loc 1 1808 0
 7909 45cc 7C25DBE5 		ldrb	r2, [fp, #1404]	@ zero_extendqisi2
1806:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 7910              		.loc 1 1806 0
 7911 45d0 AE02000A 		beq	.L862
 7912              	.L689:
1814:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 7913              		.loc 1 1814 0
 7914 45d4 0030A0E3 		mov	r3, #0
 7915              	.LVL869:
1818:../uvc.c      **** 		 	 if(Len == 2){
 7916              		.loc 1 1818 0
 7917 45d8 201B9FE5 		ldr	r1, .L906+96
1811:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 7918              		.loc 1 1811 0
 7919 45dc 28C0C8E5 		strb	ip, [r8, #40]
1813:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7920              		.loc 1 1813 0
 7921 45e0 2920C8E5 		strb	r2, [r8, #41]
1814:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 7922              		.loc 1 1814 0
 7923 45e4 2B30C8E5 		strb	r3, [r8, #43]
1824:../uvc.c      **** 		 	 }
 7924              		.loc 1 1824 0
 7925 45e8 28308DE5 		str	r3, [sp, #40]
 7926 45ec 0050A0E3 		mov	r5, #0
1818:../uvc.c      **** 		 	 if(Len == 2){
 7927              		.loc 1 1818 0
 7928 45f0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7929              	.LVL870:
1823:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 7930              		.loc 1 1823 0
 7931 45f4 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 7932              	.LVL871:
1824:../uvc.c      **** 		 	 }
 7933              		.loc 1 1824 0
 7934 45f8 2A40D8E5 		ldrb	r4, [r8, #42]	@ zero_extendqisi2
 7935              	.LVL872:
 7936 45fc 28109DE5 		ldr	r1, [sp, #40]
 7937 4600 790100EA 		b	.L686
 7938              	.LVL873:
 7939              	.L877:
 7940              	.LBE180:
 7941              	.LBE179:
3921:../uvc.c      ****     {
 7942              		.loc 1 3921 0
 7943 4604 070C52E3 		cmp	r2, #1792
 7944 4608 0900000A 		beq	.L636
 7945 460c 020B52E3 		cmp	r2, #2048
 7946 4610 D2FEFF1A 		bne	.L626
 7947              	.LVL874:
3952:../uvc.c      ****           		break;
 7948              		.loc 1 3952 0
 7949 4614 0700A0E3 		mov	r0, #7
 7950 4618 FEFFFFEB 		bl	ControlHandle
 7951              	.LVL875:
 7952 461c 44309DE5 		ldr	r3, [sp, #68]
 7953 4620 D8FEFFEA 		b	.L619
 7954              	.L638:
 7955              	.LVL876:
3966:../uvc.c      ****     		break;
 7956              		.loc 1 3966 0
 7957 4624 0E00A0E3 		mov	r0, #14
 7958 4628 FEFFFFEB 		bl	ControlHandle
 7959              	.LVL877:
 7960 462c 44309DE5 		ldr	r3, [sp, #68]
 7961 4630 D4FEFFEA 		b	.L619
 7962              	.L636:
 7963              	.LVL878:
3948:../uvc.c      ****           		break;
 7964              		.loc 1 3948 0
 7965 4634 0600A0E3 		mov	r0, #6
 7966 4638 FEFFFFEB 		bl	ControlHandle
 7967              	.LVL879:
 7968 463c 44309DE5 		ldr	r3, [sp, #68]
 7969 4640 D0FEFFEA 		b	.L619
 7970              	.L634:
 7971              	.LVL880:
 7972              	.LBB190:
 7973              	.LBB191:
1359:../uvc.c      ****     /*
 7974              		.loc 1 1359 0
 7975 4644 A43A9FE5 		ldr	r3, .L906+80
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7976              		.loc 1 1348 0
 7977 4648 5817DBE5 		ldrb	r1, [fp, #1880]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 7978              		.loc 1 1359 0
 7979 464c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7980              		.loc 1 1349 0
 7981 4650 5957DBE5 		ldrb	r5, [fp, #1881]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 7982              		.loc 1 1359 0
 7983 4654 28308DE5 		str	r3, [sp, #40]
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7984              		.loc 1 1350 0
 7985 4658 6727DBE5 		ldrb	r2, [fp, #1895]	@ zero_extendqisi2
1367:../uvc.c      **** 		 {
 7986              		.loc 1 1367 0
 7987 465c 28C09DE5 		ldr	ip, [sp, #40]
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 7988              		.loc 1 1351 0
 7989 4660 5A37DBE5 		ldrb	r3, [fp, #1882]	@ zero_extendqisi2
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7990              		.loc 1 1348 0
 7991 4664 FF1001E2 		and	r1, r1, #255
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7992              		.loc 1 1350 0
 7993 4668 FF2002E2 		and	r2, r2, #255
1367:../uvc.c      **** 		 {
 7994              		.loc 1 1367 0
 7995 466c 83005CE3 		cmp	ip, #131
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7996              		.loc 1 1348 0
 7997 4670 30108DE5 		str	r1, [sp, #48]
 7998              	.LVL881:
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7999              		.loc 1 1349 0
 8000 4674 FF5005E2 		and	r5, r5, #255
 8001              	.LVL882:
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 8002              		.loc 1 1350 0
 8003 4678 2C208DE5 		str	r2, [sp, #44]
 8004              	.LVL883:
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 8005              		.loc 1 1351 0
 8006 467c FF3003E2 		and	r3, r3, #255
 8007              	.LVL884:
1367:../uvc.c      **** 		 {
 8008              		.loc 1 1367 0
 8009 4680 A603000A 		beq	.L710
 8010 4684 F200009A 		bls	.L889
 8011 4688 28C09DE5 		ldr	ip, [sp, #40]
 8012 468c 85005CE3 		cmp	ip, #133
 8013 4690 0D04000A 		beq	.L715
 8014 4694 1804003A 		bcc	.L716
 8015 4698 86005CE3 		cmp	ip, #134
 8016 469c B502000A 		beq	.L717
 8017 46a0 87005CE3 		cmp	ip, #135
 8018 46a4 5204001A 		bne	.L709
1807:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8019              		.loc 1 1807 0
 8020 46a8 F4E99FE5 		ldr	lr, .L906+4
1806:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8021              		.loc 1 1806 0
 8022 46ac 020053E3 		cmp	r3, #2
1807:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8023              		.loc 1 1807 0
 8024 46b0 63C7DEE5 		ldrb	ip, [lr, #1891]	@ zero_extendqisi2
1818:../uvc.c      **** 		 	 if(Len == 2){
 8025              		.loc 1 1818 0
 8026 46b4 0300A0E1 		mov	r0, r3
1808:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 8027              		.loc 1 1808 0
 8028 46b8 6427DEE5 		ldrb	r2, [lr, #1892]	@ zero_extendqisi2
1806:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8029              		.loc 1 1806 0
 8030 46bc 9D03000A 		beq	.L864
 8031              	.L724:
1814:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 8032              		.loc 1 1814 0
 8033 46c0 0030A0E3 		mov	r3, #0
 8034              	.LVL885:
1818:../uvc.c      **** 		 	 if(Len == 2){
 8035              		.loc 1 1818 0
 8036 46c4 341A9FE5 		ldr	r1, .L906+96
1811:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8037              		.loc 1 1811 0
 8038 46c8 28C0C8E5 		strb	ip, [r8, #40]
1813:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8039              		.loc 1 1813 0
 8040 46cc 2920C8E5 		strb	r2, [r8, #41]
1814:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 8041              		.loc 1 1814 0
 8042 46d0 2B30C8E5 		strb	r3, [r8, #43]
1824:../uvc.c      **** 		 	 }
 8043              		.loc 1 1824 0
 8044 46d4 24308DE5 		str	r3, [sp, #36]
 8045 46d8 0040A0E3 		mov	r4, #0
1818:../uvc.c      **** 		 	 if(Len == 2){
 8046              		.loc 1 1818 0
 8047 46dc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8048              	.LVL886:
1823:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 8049              		.loc 1 1823 0
 8050 46e0 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 8051              	.LVL887:
1824:../uvc.c      **** 		 	 }
 8052              		.loc 1 1824 0
 8053 46e4 2A50D8E5 		ldrb	r5, [r8, #42]	@ zero_extendqisi2
 8054              	.LVL888:
 8055 46e8 24109DE5 		ldr	r1, [sp, #36]
 8056 46ec 070100EA 		b	.L719
 8057              	.LVL889:
 8058              	.L631:
 8059              	.LBE191:
 8060              	.LBE190:
 8061              	.LBB203:
 8062              	.LBB204:
1359:../uvc.c      ****     /*
 8063              		.loc 1 1359 0
 8064 46f0 F8299FE5 		ldr	r2, .L906+80
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 8065              		.loc 1 1348 0
 8066 46f4 9C35DBE5 		ldrb	r3, [fp, #1436]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 8067              		.loc 1 1359 0
 8068 46f8 0020D2E5 		ldrb	r2, [r2]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 8069              		.loc 1 1349 0
 8070 46fc 9D45DBE5 		ldrb	r4, [fp, #1437]	@ zero_extendqisi2
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 8071              		.loc 1 1350 0
 8072 4700 AB55DBE5 		ldrb	r5, [fp, #1451]	@ zero_extendqisi2
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 8073              		.loc 1 1351 0
 8074 4704 9EC5DBE5 		ldrb	ip, [fp, #1438]	@ zero_extendqisi2
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 8075              		.loc 1 1348 0
 8076 4708 FF3003E2 		and	r3, r3, #255
1367:../uvc.c      **** 		 {
 8077              		.loc 1 1367 0
 8078 470c 830052E3 		cmp	r2, #131
1359:../uvc.c      ****     /*
 8079              		.loc 1 1359 0
 8080 4710 24208DE5 		str	r2, [sp, #36]
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 8081              		.loc 1 1348 0
 8082 4714 2C308DE5 		str	r3, [sp, #44]
 8083              	.LVL890:
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 8084              		.loc 1 1349 0
 8085 4718 FF4004E2 		and	r4, r4, #255
 8086              	.LVL891:
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 8087              		.loc 1 1350 0
 8088 471c FF5005E2 		and	r5, r5, #255
 8089              	.LVL892:
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 8090              		.loc 1 1351 0
 8091 4720 FFC00CE2 		and	ip, ip, #255
 8092              	.LVL893:
1367:../uvc.c      **** 		 {
 8093              		.loc 1 1367 0
 8094 4724 9A03000A 		beq	.L641
 8095 4728 3301009A 		bls	.L890
 8096 472c 24009DE5 		ldr	r0, [sp, #36]
 8097 4730 850050E3 		cmp	r0, #133
 8098 4734 AF03000A 		beq	.L646
 8099 4738 A303003A 		bcc	.L647
 8100 473c 860050E3 		cmp	r0, #134
 8101 4740 9D02000A 		beq	.L648
 8102 4744 870050E3 		cmp	r0, #135
 8103 4748 3C03001A 		bne	.L640
1806:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8104              		.loc 1 1806 0
 8105 474c 02005CE3 		cmp	ip, #2
1807:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8106              		.loc 1 1807 0
 8107 4750 A725DB05 		ldreqb	r2, [fp, #1447]	@ zero_extendqisi2
1808:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 8108              		.loc 1 1808 0
 8109 4754 A835DB05 		ldreqb	r3, [fp, #1448]	@ zero_extendqisi2
1806:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8110              		.loc 1 1806 0
 8111 4758 3304000A 		beq	.L857
1811:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8112              		.loc 1 1811 0
 8113 475c A7E5DBE5 		ldrb	lr, [fp, #1447]	@ zero_extendqisi2
1813:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8114              		.loc 1 1813 0
 8115 4760 A825DBE5 		ldrb	r2, [fp, #1448]	@ zero_extendqisi2
 8116              	.L856:
1814:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 8117              		.loc 1 1814 0
 8118 4764 0030A0E3 		mov	r3, #0
1818:../uvc.c      **** 		 	 if(Len == 2){
 8119              		.loc 1 1818 0
 8120 4768 0C00A0E1 		mov	r0, ip
 8121 476c 8C199FE5 		ldr	r1, .L906+96
1811:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8122              		.loc 1 1811 0
 8123 4770 28E0C8E5 		strb	lr, [r8, #40]
1813:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8124              		.loc 1 1813 0
 8125 4774 2920C8E5 		strb	r2, [r8, #41]
1814:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 8126              		.loc 1 1814 0
 8127 4778 2B30C8E5 		strb	r3, [r8, #43]
1824:../uvc.c      **** 		 	 }
 8128              		.loc 1 1824 0
 8129 477c 28308DE5 		str	r3, [sp, #40]
1818:../uvc.c      **** 		 	 if(Len == 2){
 8130              		.loc 1 1818 0
 8131 4780 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8132              	.LVL894:
1824:../uvc.c      **** 		 	 }
 8133              		.loc 1 1824 0
 8134 4784 00C0A0E3 		mov	ip, #0
1823:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 8135              		.loc 1 1823 0
 8136 4788 2850D8E5 		ldrb	r5, [r8, #40]	@ zero_extendqisi2
 8137              	.LVL895:
1824:../uvc.c      **** 		 	 }
 8138              		.loc 1 1824 0
 8139 478c 2A40D8E5 		ldrb	r4, [r8, #42]	@ zero_extendqisi2
 8140              	.LVL896:
 8141 4790 28E09DE5 		ldr	lr, [sp, #40]
 8142 4794 530100EA 		b	.L650
 8143              	.LVL897:
 8144              	.L627:
 8145              	.LBE204:
 8146              	.LBE203:
3944:../uvc.c      ****      		break;
 8147              		.loc 1 3944 0
 8148 4798 0500A0E3 		mov	r0, #5
 8149 479c FEFFFFEB 		bl	ControlHandle
 8150              	.LVL898:
 8151 47a0 44309DE5 		ldr	r3, [sp, #68]
 8152 47a4 77FEFFEA 		b	.L619
 8153              	.L878:
 8154              	.LVL899:
 8155              	.LBB215:
 8156              	.LBB216:
1359:../uvc.c      ****     /*
 8157              		.loc 1 1359 0
 8158 47a8 40399FE5 		ldr	r3, .L906+80
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 8159              		.loc 1 1348 0
 8160 47ac 6C07DBE5 		ldrb	r0, [fp, #1900]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 8161              		.loc 1 1359 0
 8162 47b0 0040D3E5 		ldrb	r4, [r3]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 8163              		.loc 1 1349 0
 8164 47b4 6D17DBE5 		ldrb	r1, [fp, #1901]	@ zero_extendqisi2
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 8165              		.loc 1 1350 0
 8166 47b8 7B27DBE5 		ldrb	r2, [fp, #1915]	@ zero_extendqisi2
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 8167              		.loc 1 1351 0
 8168 47bc 6E37DBE5 		ldrb	r3, [fp, #1902]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 8169              		.loc 1 1349 0
 8170 47c0 FF1001E2 		and	r1, r1, #255
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 8171              		.loc 1 1350 0
 8172 47c4 FF2002E2 		and	r2, r2, #255
1367:../uvc.c      **** 		 {
 8173              		.loc 1 1367 0
 8174 47c8 830054E3 		cmp	r4, #131
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 8175              		.loc 1 1348 0
 8176 47cc FFC000E2 		and	ip, r0, #255
 8177              	.LVL900:
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 8178              		.loc 1 1349 0
 8179 47d0 2C108DE5 		str	r1, [sp, #44]
 8180              	.LVL901:
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 8181              		.loc 1 1350 0
 8182 47d4 28208DE5 		str	r2, [sp, #40]
 8183              	.LVL902:
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 8184              		.loc 1 1351 0
 8185 47d8 FF3003E2 		and	r3, r3, #255
 8186              	.LVL903:
1367:../uvc.c      **** 		 {
 8187              		.loc 1 1367 0
 8188 47dc 4803000A 		beq	.L734
 8189 47e0 4A01009A 		bls	.L891
 8190 47e4 850054E3 		cmp	r4, #133
 8191 47e8 5D03000A 		beq	.L739
 8192 47ec 6E03003A 		bcc	.L740
 8193 47f0 860054E3 		cmp	r4, #134
 8194 47f4 4F02000A 		beq	.L741
 8195 47f8 870054E3 		cmp	r4, #135
 8196 47fc EE02001A 		bne	.L733
1806:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8197              		.loc 1 1806 0
 8198 4800 020053E3 		cmp	r3, #2
1807:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8199              		.loc 1 1807 0
 8200 4804 77C7DBE5 		ldrb	ip, [fp, #1911]	@ zero_extendqisi2
 8201              	.LVL904:
1818:../uvc.c      **** 		 	 if(Len == 2){
 8202              		.loc 1 1818 0
 8203 4808 0300A0E1 		mov	r0, r3
 8204              	.LVL905:
1808:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 8205              		.loc 1 1808 0
 8206 480c 7827DBE5 		ldrb	r2, [fp, #1912]	@ zero_extendqisi2
1806:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8207              		.loc 1 1806 0
 8208 4810 1402000A 		beq	.L873
 8209              	.L746:
1814:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 8210              		.loc 1 1814 0
 8211 4814 0030A0E3 		mov	r3, #0
 8212              	.LVL906:
1818:../uvc.c      **** 		 	 if(Len == 2){
 8213              		.loc 1 1818 0
 8214 4818 E0189FE5 		ldr	r1, .L906+96
1811:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8215              		.loc 1 1811 0
 8216 481c 28C0C8E5 		strb	ip, [r8, #40]
1813:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8217              		.loc 1 1813 0
 8218 4820 2920C8E5 		strb	r2, [r8, #41]
1814:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 8219              		.loc 1 1814 0
 8220 4824 2B30C8E5 		strb	r3, [r8, #43]
1824:../uvc.c      **** 		 	 }
 8221              		.loc 1 1824 0
 8222 4828 24308DE5 		str	r3, [sp, #36]
 8223 482c 0050A0E3 		mov	r5, #0
1818:../uvc.c      **** 		 	 if(Len == 2){
 8224              		.loc 1 1818 0
 8225 4830 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8226              	.LVL907:
1823:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 8227              		.loc 1 1823 0
 8228 4834 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 8229              	.LVL908:
1824:../uvc.c      **** 		 	 }
 8230              		.loc 1 1824 0
 8231 4838 2A30D8E5 		ldrb	r3, [r8, #42]	@ zero_extendqisi2
 8232              	.LVL909:
 8233 483c 24C09DE5 		ldr	ip, [sp, #36]
 8234 4840 730100EA 		b	.L743
 8235              	.LVL910:
 8236              	.L629:
 8237              	.LBE216:
 8238              	.LBE215:
3933:../uvc.c      **** 			break;
 8239              		.loc 1 3933 0
 8240 4844 0200A0E3 		mov	r0, #2
 8241 4848 FEFFFFEB 		bl	ControlHandle
 8242              	.LVL911:
 8243 484c 44309DE5 		ldr	r3, [sp, #68]
 8244 4850 4CFEFFEA 		b	.L619
 8245              	.L759:
 8246              	.LBE273:
 8247              	.LBE286:
 8248              	.LBB287:
 8249              	.LBB160:
4222:../uvc.c      ****     {
 8250              		.loc 1 4222 0
 8251 4854 010B53E3 		cmp	r3, #1024
 8252 4858 7900000A 		beq	.L762
 8253 485c 050C53E3 		cmp	r3, #1280
 8254 4860 43FEFF1A 		bne	.L620
 8255              	.LVL912:
4242:../uvc.c      ****     		break;
 8256              		.loc 1 4242 0
 8257 4864 1400A0E3 		mov	r0, #20
 8258 4868 FEFFFFEB 		bl	ControlHandle
 8259              	.LVL913:
 8260 486c 44309DE5 		ldr	r3, [sp, #68]
 8261 4870 44FEFFEA 		b	.L619
 8262              	.L883:
4222:../uvc.c      ****     {
 8263              		.loc 1 4222 0
 8264 4874 070C53E3 		cmp	r3, #1792
 8265 4878 6D00000A 		beq	.L766
 8266 487c 020B53E3 		cmp	r3, #2048
 8267 4880 3BFEFF1A 		bne	.L620
 8268              	.LVL914:
4254:../uvc.c      ****     		break;
 8269              		.loc 1 4254 0
 8270 4884 1700A0E3 		mov	r0, #23
 8271 4888 FEFFFFEB 		bl	ControlHandle
 8272              	.LVL915:
 8273 488c 44309DE5 		ldr	r3, [sp, #68]
 8274 4890 3CFEFFEA 		b	.L619
 8275              	.L887:
4222:../uvc.c      ****     {
 8276              		.loc 1 4222 0
 8277 4894 160C53E3 		cmp	r3, #5632
 8278 4898 2E00000A 		beq	.L782
 8279 489c 170C53E3 		cmp	r3, #5888
 8280 48a0 33FEFF1A 		bne	.L620
4322:../uvc.c      **** 			CyU3PDebugPrint (4, "The edgegain command 0x%x 0x%x\r\n", wValue, bRequest);
 8281              		.loc 1 4322 0
 8282 48a4 2A00A0E3 		mov	r0, #42
 8283 48a8 FEFFFFEB 		bl	ControlHandle
 8284              	.LVL916:
4323:../uvc.c      ****    		break;
 8285              		.loc 1 4323 0
 8286 48ac 3C389FE5 		ldr	r3, .L906+80
 8287 48b0 B020D4E1 		ldrh	r2, [r4]
 8288 48b4 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 8289 48b8 0400A0E3 		mov	r0, #4
 8290 48bc 08189FE5 		ldr	r1, .L906+44
 8291 48c0 FEFFFFEB 		bl	CyU3PDebugPrint
 8292              	.LVL917:
 8293 48c4 44309DE5 		ldr	r3, [sp, #68]
 8294 48c8 2EFEFFEA 		b	.L619
 8295              	.L886:
4222:../uvc.c      ****     {
 8296              		.loc 1 4222 0
 8297 48cc 0F0C53E3 		cmp	r3, #3840
 8298 48d0 1C00000A 		beq	.L775
 8299 48d4 010A53E3 		cmp	r3, #4096
 8300 48d8 25FEFF1A 		bne	.L620
 8301              	.LVL918:
4291:../uvc.c      ****     		break;
 8302              		.loc 1 4291 0
 8303 48dc 1F00A0E3 		mov	r0, #31
 8304 48e0 FEFFFFEB 		bl	ControlHandle
 8305              	.LVL919:
 8306 48e4 44309DE5 		ldr	r3, [sp, #68]
 8307 48e8 26FEFFEA 		b	.L619
 8308              	.LVL920:
 8309              	.L884:
 8310 48ec 0030A0E1 		mov	r3, r0
 8311              	.LBE160:
 8312              	.LBE287:
4910:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 8313              		.loc 1 4910 0
 8314 48f0 0320A0E1 		mov	r2, r3
 8315 48f4 0500A0E1 		mov	r0, r5
 8316              	.LVL921:
 8317 48f8 D0179FE5 		ldr	r1, .L906+48
 8318 48fc 20308DE5 		str	r3, [sp, #32]
 8319 4900 FEFFFFEB 		bl	CyU3PDebugPrint
 8320              	.LVL922:
4911:../uvc.c      **** 					}
 8321              		.loc 1 4911 0
 8322 4904 20309DE5 		ldr	r3, [sp, #32]
 8323 4908 0300A0E1 		mov	r0, r3
 8324 490c FEFFFFEB 		bl	CyFxAppErrorHandler
 8325              	.LVL923:
 8326              	.L760:
 8327              	.LBB288:
 8328              	.LBB161:
4226:../uvc.c      ****     		break;
 8329              		.loc 1 4226 0
 8330 4910 1000A0E3 		mov	r0, #16
 8331 4914 FEFFFFEB 		bl	ControlHandle
 8332              	.LVL924:
 8333 4918 44309DE5 		ldr	r3, [sp, #68]
 8334 491c 19FEFFEA 		b	.L619
 8335              	.L785:
4342:../uvc.c      **** 			CyU3PDebugPrint (4, "The AGC Max command 0x%x 0x%x\r\n", wValue, bRequest);
 8336              		.loc 1 4342 0
 8337 4920 2F00A0E3 		mov	r0, #47
 8338 4924 FEFFFFEB 		bl	ControlHandle
 8339              	.LVL925:
4343:../uvc.c      ****     		break;
 8340              		.loc 1 4343 0
 8341 4928 C0379FE5 		ldr	r3, .L906+80
 8342 492c B020D4E1 		ldrh	r2, [r4]
 8343 4930 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 8344 4934 0400A0E3 		mov	r0, #4
 8345 4938 94179FE5 		ldr	r1, .L906+52
 8346 493c FEFFFFEB 		bl	CyU3PDebugPrint
 8347              	.LVL926:
 8348 4940 44309DE5 		ldr	r3, [sp, #68]
 8349 4944 0FFEFFEA 		b	.L619
 8350              	.L775:
 8351              	.LVL927:
4287:../uvc.c      ****     		break;
 8352              		.loc 1 4287 0
 8353 4948 1E00A0E3 		mov	r0, #30
 8354 494c FEFFFFEB 		bl	ControlHandle
 8355              	.LVL928:
 8356 4950 44309DE5 		ldr	r3, [sp, #68]
 8357 4954 0BFEFFEA 		b	.L619
 8358              	.L782:
4317:../uvc.c      **** 			CyU3PDebugPrint (4, "The edgeMode command 0x%x 0x%x\r\n", wValue, bRequest);
 8359              		.loc 1 4317 0
 8360 4958 2900A0E3 		mov	r0, #41
 8361 495c FEFFFFEB 		bl	ControlHandle
 8362              	.LVL929:
4318:../uvc.c      ****     		break;
 8363              		.loc 1 4318 0
 8364 4960 88379FE5 		ldr	r3, .L906+80
 8365 4964 B020D4E1 		ldrh	r2, [r4]
 8366 4968 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 8367 496c 0400A0E3 		mov	r0, #4
 8368 4970 60179FE5 		ldr	r1, .L906+56
 8369 4974 FEFFFFEB 		bl	CyU3PDebugPrint
 8370              	.LVL930:
 8371 4978 44309DE5 		ldr	r3, [sp, #68]
 8372 497c 01FEFFEA 		b	.L619
 8373              	.L769:
 8374              	.LVL931:
4273:../uvc.c      ****     		break;
 8375              		.loc 1 4273 0
 8376 4980 1B00A0E3 		mov	r0, #27
 8377 4984 FEFFFFEB 		bl	ControlHandle
 8378              	.LVL932:
 8379 4988 44309DE5 		ldr	r3, [sp, #68]
 8380 498c FDFDFFEA 		b	.L619
 8381              	.L778:
 8382              	.LVL933:
 8383              	.LBB144:
 8384              	.LBB145:
1359:../uvc.c      ****     /*
 8385              		.loc 1 1359 0
 8386 4990 58C79FE5 		ldr	ip, .L906+80
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8387              		.loc 1 1341 0
 8388 4994 8017DBE5 		ldrb	r1, [fp, #1920]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 8389              		.loc 1 1359 0
 8390 4998 00C0DCE5 		ldrb	ip, [ip]	@ zero_extendqisi2
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8391              		.loc 1 1342 0
 8392 499c 8157DBE5 		ldrb	r5, [fp, #1921]	@ zero_extendqisi2
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8393              		.loc 1 1343 0
 8394 49a0 8F27DBE5 		ldrb	r2, [fp, #1935]	@ zero_extendqisi2
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 8395              		.loc 1 1344 0
 8396 49a4 8237DBE5 		ldrb	r3, [fp, #1922]	@ zero_extendqisi2
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8397              		.loc 1 1341 0
 8398 49a8 FF1001E2 		and	r1, r1, #255
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8399              		.loc 1 1343 0
 8400 49ac FF2002E2 		and	r2, r2, #255
1367:../uvc.c      **** 		 {
 8401              		.loc 1 1367 0
 8402 49b0 83005CE3 		cmp	ip, #131
1359:../uvc.c      ****     /*
 8403              		.loc 1 1359 0
 8404 49b4 28C08DE5 		str	ip, [sp, #40]
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8405              		.loc 1 1341 0
 8406 49b8 30108DE5 		str	r1, [sp, #48]
 8407              	.LVL934:
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8408              		.loc 1 1342 0
 8409 49bc FF5005E2 		and	r5, r5, #255
 8410              	.LVL935:
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8411              		.loc 1 1343 0
 8412 49c0 2C208DE5 		str	r2, [sp, #44]
 8413              	.LVL936:
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 8414              		.loc 1 1344 0
 8415 49c4 FF3003E2 		and	r3, r3, #255
 8416              	.LVL937:
1367:../uvc.c      **** 		 {
 8417              		.loc 1 1367 0
 8418 49c8 9C03000A 		beq	.L788
 8419 49cc 4B02009A 		bls	.L892
 8420 49d0 28C09DE5 		ldr	ip, [sp, #40]
 8421 49d4 85005CE3 		cmp	ip, #133
 8422 49d8 2E02000A 		beq	.L793
 8423 49dc E003003A 		bcc	.L794
 8424 49e0 86005CE3 		cmp	ip, #134
 8425 49e4 CF03000A 		beq	.L795
 8426 49e8 87005CE3 		cmp	ip, #135
 8427 49ec 9F03001A 		bne	.L787
1793:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8428              		.loc 1 1793 0
 8429 49f0 020053E3 		cmp	r3, #2
1794:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8430              		.loc 1 1794 0
 8431 49f4 8BC7DBE5 		ldrb	ip, [fp, #1931]	@ zero_extendqisi2
1818:../uvc.c      **** 		 	 if(Len == 2){
 8432              		.loc 1 1818 0
 8433 49f8 0300A0E1 		mov	r0, r3
1795:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 8434              		.loc 1 1795 0
 8435 49fc 8C27DBE5 		ldrb	r2, [fp, #1932]	@ zero_extendqisi2
1793:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8436              		.loc 1 1793 0
 8437 4a00 A903000A 		beq	.L874
 8438              	.L802:
1800:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8439              		.loc 1 1800 0
 8440 4a04 0030A0E3 		mov	r3, #0
 8441              	.LVL938:
1818:../uvc.c      **** 		 	 if(Len == 2){
 8442              		.loc 1 1818 0
 8443 4a08 F0169FE5 		ldr	r1, .L906+96
1799:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8444              		.loc 1 1799 0
 8445 4a0c 28C0C8E5 		strb	ip, [r8, #40]
1801:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8446              		.loc 1 1801 0
 8447 4a10 2A20C8E5 		strb	r2, [r8, #42]
1800:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8448              		.loc 1 1800 0
 8449 4a14 2930C8E5 		strb	r3, [r8, #41]
1802:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 8450              		.loc 1 1802 0
 8451 4a18 2B30C8E5 		strb	r3, [r8, #43]
1824:../uvc.c      **** 		 	 }
 8452              		.loc 1 1824 0
 8453 4a1c 24308DE5 		str	r3, [sp, #36]
 8454 4a20 0040A0E3 		mov	r4, #0
1818:../uvc.c      **** 		 	 if(Len == 2){
 8455              		.loc 1 1818 0
 8456 4a24 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8457              	.LVL939:
1823:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 8458              		.loc 1 1823 0
 8459 4a28 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 8460              	.LVL940:
1824:../uvc.c      **** 		 	 }
 8461              		.loc 1 1824 0
 8462 4a2c 2A50D8E5 		ldrb	r5, [r8, #42]	@ zero_extendqisi2
 8463              	.LVL941:
 8464 4a30 220200EA 		b	.L797
 8465              	.LVL942:
 8466              	.L766:
 8467              	.LBE145:
 8468              	.LBE144:
4250:../uvc.c      ****     		break;
 8469              		.loc 1 4250 0
 8470 4a34 1600A0E3 		mov	r0, #22
 8471 4a38 FEFFFFEB 		bl	ControlHandle
 8472              	.LVL943:
 8473 4a3c 44309DE5 		ldr	r3, [sp, #68]
 8474 4a40 D0FDFFEA 		b	.L619
 8475              	.L762:
 8476              	.LVL944:
4238:../uvc.c      ****     		break;
 8477              		.loc 1 4238 0
 8478 4a44 1300A0E3 		mov	r0, #19
 8479 4a48 FEFFFFEB 		bl	ControlHandle
 8480              	.LVL945:
 8481 4a4c 44309DE5 		ldr	r3, [sp, #68]
 8482 4a50 CCFDFFEA 		b	.L619
 8483              	.LVL946:
 8484              	.L889:
 8485              	.LBE161:
 8486              	.LBE288:
 8487              	.LBB289:
 8488              	.LBB274:
 8489              	.LBB226:
 8490              	.LBB192:
1367:../uvc.c      **** 		 {
 8491              		.loc 1 1367 0
 8492 4a54 81005CE3 		cmp	ip, #129
 8493 4a58 3203000A 		beq	.L712
 8494 4a5c E601008A 		bhi	.L713
 8495 4a60 01005CE3 		cmp	ip, #1
 8496 4a64 6203001A 		bne	.L709
1828:../uvc.c      **** 				  glEp0Buffer, &readCount);
 8497              		.loc 1 1828 0
 8498 4a68 2000A0E3 		mov	r0, #32
 8499 4a6c 8C169FE5 		ldr	r1, .L906+96
 8500 4a70 42208DE2 		add	r2, sp, #66
 8501 4a74 20308DE5 		str	r3, [sp, #32]
 8502 4a78 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8503              	.LVL947:
1830:../uvc.c      **** 			   {
 8504              		.loc 1 1830 0
 8505 4a7c 20309DE5 		ldr	r3, [sp, #32]
 8506 4a80 000050E3 		cmp	r0, #0
 8507 4a84 34008DE5 		str	r0, [sp, #52]
 8508 4a88 0005001A 		bne	.L725
1832:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 8509              		.loc 1 1832 0
 8510 4a8c 020053E3 		cmp	r3, #2
1833:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 8511              		.loc 1 1833 0
 8512 4a90 2840D9E5 		ldrb	r4, [r9, #40]	@ zero_extendqisi2
1832:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 8513              		.loc 1 1832 0
 8514 4a94 D404000A 		beq	.L893
 8515              	.LVL948:
1837:../uvc.c      **** 				 }
 8516              		.loc 1 1837 0
 8517 4a98 2AC0D9E5 		ldrb	ip, [r9, #42]	@ zero_extendqisi2
1840:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8518              		.loc 1 1840 0
 8519 4a9c 38308DE5 		str	r3, [sp, #56]
1837:../uvc.c      **** 				 }
 8520              		.loc 1 1837 0
 8521 4aa0 24C08DE5 		str	ip, [sp, #36]
 8522              	.LVL949:
1840:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8523              		.loc 1 1840 0
 8524 4aa4 2CC09DE5 		ldr	ip, [sp, #44]
 8525 4aa8 08308DE5 		str	r3, [sp, #8]
 8526 4aac 04C08DE5 		str	ip, [sp, #4]
 8527 4ab0 24C09DE5 		ldr	ip, [sp, #36]
 8528 4ab4 00508DE5 		str	r5, [sp]
 8529 4ab8 10C08DE5 		str	ip, [sp, #16]
 8530 4abc 0C408DE5 		str	r4, [sp, #12]
 8531 4ac0 0400A0E3 		mov	r0, #4
 8532              	.LVL950:
 8533 4ac4 40169FE5 		ldr	r1, .L906+108
 8534 4ac8 0920A0E3 		mov	r2, #9
 8535 4acc 30309DE5 		ldr	r3, [sp, #48]
 8536 4ad0 FEFFFFEB 		bl	CyU3PDebugPrint
 8537              	.LVL951:
2246:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 8538              		.loc 1 2246 0
 8539 4ad4 38C09DE5 		ldr	ip, [sp, #56]
 8540 4ad8 04005CE3 		cmp	ip, #4
 8541 4adc 9B04000A 		beq	.L894
 8542              	.LVL952:
 8543              	.L730:
2263:../uvc.c      **** 			 	 			 break;
 8544              		.loc 1 2263 0
 8545 4ae0 6627DBE5 		ldrb	r2, [fp, #1894]	@ zero_extendqisi2
2262:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
 8546              		.loc 1 2262 0
 8547 4ae4 38C09DE5 		ldr	ip, [sp, #56]
2263:../uvc.c      **** 			 	 			 break;
 8548              		.loc 1 2263 0
 8549 4ae8 6537DBE5 		ldrb	r3, [fp, #1893]	@ zero_extendqisi2
2262:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
 8550              		.loc 1 2262 0
 8551 4aec 04169FE5 		ldr	r1, .L906+88
 8552 4af0 0C108DE8 		stmia	sp, {r2, r3, ip}
 8553 4af4 24309DE5 		ldr	r3, [sp, #36]
 8554 4af8 0400A0E3 		mov	r0, #4
 8555 4afc 0420A0E1 		mov	r2, r4
 8556 4b00 FEFFFFEB 		bl	CyU3PDebugPrint
 8557              	.LVL953:
 8558 4b04 24109DE5 		ldr	r1, [sp, #36]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8559              		.loc 1 1355 0
 8560 4b08 FF50A0E3 		mov	r5, #255
 8561 4b0c 05C0A0E1 		mov	ip, r5
 8562              	.LVL954:
 8563              	.L719:
2279:../uvc.c      **** }
 8564              		.loc 1 2279 0
 8565 4b10 02108DE8 		stmia	sp, {r1, ip}
 8566 4b14 28209DE5 		ldr	r2, [sp, #40]
 8567 4b18 08508DE5 		str	r5, [sp, #8]
 8568 4b1c FD0000EA 		b	.L872
 8569              	.LVL955:
 8570              	.L888:
 8571              	.LBE192:
 8572              	.LBE226:
 8573              	.LBB227:
 8574              	.LBB181:
1367:../uvc.c      **** 		 {
 8575              		.loc 1 1367 0
 8576 4b20 81005EE3 		cmp	lr, #129
 8577 4b24 5104000A 		beq	.L679
 8578 4b28 5301008A 		bhi	.L680
 8579 4b2c 01005EE3 		cmp	lr, #1
 8580 4b30 1803001A 		bne	.L676
1828:../uvc.c      **** 				  glEp0Buffer, &readCount);
 8581              		.loc 1 1828 0
 8582 4b34 42208DE2 		add	r2, sp, #66
 8583 4b38 2000A0E3 		mov	r0, #32
 8584 4b3c BC159FE5 		ldr	r1, .L906+96
 8585 4b40 20308DE5 		str	r3, [sp, #32]
 8586 4b44 1CC08DE5 		str	ip, [sp, #28]
 8587 4b48 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8588              	.LVL956:
1830:../uvc.c      **** 			   {
 8589              		.loc 1 1830 0
 8590 4b4c 20309DE5 		ldr	r3, [sp, #32]
 8591 4b50 1CC09DE5 		ldr	ip, [sp, #28]
 8592 4b54 002050E2 		subs	r2, r0, #0
 8593 4b58 6E04001A 		bne	.L690
1832:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 8594              		.loc 1 1832 0
 8595 4b5c 020053E3 		cmp	r3, #2
1834:../uvc.c      **** 				 }else{
 8596              		.loc 1 1834 0
 8597 4b60 29E0D905 		ldreqb	lr, [r9, #41]	@ zero_extendqisi2
1837:../uvc.c      **** 				 }
 8598              		.loc 1 1837 0
 8599 4b64 2A00D915 		ldrneb	r0, [r9, #42]	@ zero_extendqisi2
 8600              	.LVL957:
1833:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 8601              		.loc 1 1833 0
 8602 4b68 2850D9E5 		ldrb	r5, [r9, #40]	@ zero_extendqisi2
 8603              	.LVL958:
1834:../uvc.c      **** 				 }else{
 8604              		.loc 1 1834 0
 8605 4b6c 28E08D05 		streq	lr, [sp, #40]
 8606              	.LVL959:
1837:../uvc.c      **** 				 }
 8607              		.loc 1 1837 0
 8608 4b70 28008D15 		strne	r0, [sp, #40]
 8609              	.LVL960:
1840:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8610              		.loc 1 1840 0
 8611 4b74 00C08DE5 		str	ip, [sp]
 8612 4b78 28C09DE5 		ldr	ip, [sp, #40]
 8613 4b7c 0400A0E3 		mov	r0, #4
 8614 4b80 08308DE5 		str	r3, [sp, #8]
 8615 4b84 0C508DE5 		str	r5, [sp, #12]
 8616 4b88 2C309DE5 		ldr	r3, [sp, #44]
 8617 4b8c 10C08DE5 		str	ip, [sp, #16]
 8618 4b90 0020A0E1 		mov	r2, r0
 8619              	.LVL961:
 8620 4b94 70159FE5 		ldr	r1, .L906+108
 8621 4b98 04408DE5 		str	r4, [sp, #4]
 8622 4b9c FEFFFFEB 		bl	CyU3PDebugPrint
 8623              	.LVL962:
2139:../uvc.c      **** 							 {
 8624              		.loc 1 2139 0
 8625 4ba0 000055E3 		cmp	r5, #0
2136:../uvc.c      **** 							 //Data0 = Data0 - 1;
 8626              		.loc 1 2136 0
 8627 4ba4 7D55CBE5 		strb	r5, [fp, #1405]
 8628              	.LVL963:
2142:../uvc.c      **** 							 }
 8629              		.loc 1 2142 0
 8630 4ba8 0130A003 		moveq	r3, #1
 8631              	.LVL964:
2147:../uvc.c      **** 							 }
 8632              		.loc 1 2147 0
 8633 4bac 0030A013 		movne	r3, #0
2146:../uvc.c      **** 								 is60Hz = CyFalse;
 8634              		.loc 1 2146 0
 8635 4bb0 0150A013 		movne	r5, #1
2149:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 8636              		.loc 1 2149 0
 8637 4bb4 0400A0E3 		mov	r0, #4
 8638 4bb8 1C159FE5 		ldr	r1, .L906+60
 8639 4bbc 0520A0E1 		mov	r2, r5
2147:../uvc.c      **** 							 }
 8640              		.loc 1 2147 0
 8641 4bc0 6C3088E5 		str	r3, [r8, #108]
 8642              	.LVL965:
2149:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 8643              		.loc 1 2149 0
 8644 4bc4 6C3098E5 		ldr	r3, [r8, #108]
 8645 4bc8 FEFFFFEB 		bl	CyU3PDebugPrint
 8646              	.LVL966:
2150:../uvc.c      **** 							 {
 8647              		.loc 1 2150 0
 8648 4bcc 883098E5 		ldr	r3, [r8, #136]
 8649 4bd0 010053E3 		cmp	r3, #1
 8650 4bd4 A303000A 		beq	.L895
 8651              	.L695:
 8652 4bd8 28109DE5 		ldr	r1, [sp, #40]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8653              		.loc 1 1355 0
 8654 4bdc FF40A0E3 		mov	r4, #255
 8655              	.LVL967:
2178:../uvc.c      **** 							 break;
 8656              		.loc 1 2178 0
 8657 4be0 0130A0E3 		mov	r3, #1
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8658              		.loc 1 1355 0
 8659 4be4 04C0A0E1 		mov	ip, r4
2178:../uvc.c      **** 							 break;
 8660              		.loc 1 2178 0
 8661 4be8 8135CBE5 		strb	r3, [fp, #1409]
 8662              	.LVL968:
 8663              	.L686:
2279:../uvc.c      **** }
 8664              		.loc 1 2279 0
 8665 4bec 02108DE8 		stmia	sp, {r1, ip}
 8666 4bf0 24209DE5 		ldr	r2, [sp, #36]
 8667 4bf4 08408DE5 		str	r4, [sp, #8]
 8668 4bf8 880000EA 		b	.L871
 8669              	.LVL969:
 8670              	.L890:
 8671              	.LBE181:
 8672              	.LBE227:
 8673              	.LBB228:
 8674              	.LBB205:
1367:../uvc.c      **** 		 {
 8675              		.loc 1 1367 0
 8676 4bfc 810052E3 		cmp	r2, #129
 8677 4c00 F701000A 		beq	.L643
 8678 4c04 4301008A 		bhi	.L644
 8679 4c08 010052E3 		cmp	r2, #1
 8680 4c0c 0B02001A 		bne	.L640
1828:../uvc.c      **** 				  glEp0Buffer, &readCount);
 8681              		.loc 1 1828 0
 8682 4c10 42208DE2 		add	r2, sp, #66
 8683 4c14 2000A0E3 		mov	r0, #32
 8684 4c18 E0149FE5 		ldr	r1, .L906+96
 8685 4c1c 1CC08DE5 		str	ip, [sp, #28]
 8686 4c20 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8687              	.LVL970:
1830:../uvc.c      **** 			   {
 8688              		.loc 1 1830 0
 8689 4c24 1CC09DE5 		ldr	ip, [sp, #28]
 8690 4c28 002050E2 		subs	r2, r0, #0
 8691 4c2c 3104001A 		bne	.L656
1832:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 8692              		.loc 1 1832 0
 8693 4c30 02005CE3 		cmp	ip, #2
1833:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 8694              		.loc 1 1833 0
 8695 4c34 28E0D905 		ldreqb	lr, [r9, #40]	@ zero_extendqisi2
1836:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 8696              		.loc 1 1836 0
 8697 4c38 2810D915 		ldrneb	r1, [r9, #40]	@ zero_extendqisi2
1834:../uvc.c      **** 				 }else{
 8698              		.loc 1 1834 0
 8699 4c3c 2900D905 		ldreqb	r0, [r9, #41]	@ zero_extendqisi2
 8700              	.LVL971:
1837:../uvc.c      **** 				 }
 8701              		.loc 1 1837 0
 8702 4c40 2A20D915 		ldrneb	r2, [r9, #42]	@ zero_extendqisi2
 8703              	.LVL972:
1833:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 8704              		.loc 1 1833 0
 8705 4c44 30E08D05 		streq	lr, [sp, #48]
 8706              	.LVL973:
1836:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 8707              		.loc 1 1836 0
 8708 4c48 30108D15 		strne	r1, [sp, #48]
 8709              	.LVL974:
1840:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8710              		.loc 1 1840 0
 8711 4c4c 30108DE8 		stmia	sp, {r4, r5, ip}
 8712 4c50 30C09DE5 		ldr	ip, [sp, #48]
1834:../uvc.c      **** 				 }else{
 8713              		.loc 1 1834 0
 8714 4c54 28008D05 		streq	r0, [sp, #40]
 8715              	.LVL975:
1837:../uvc.c      **** 				 }
 8716              		.loc 1 1837 0
 8717 4c58 28208D15 		strne	r2, [sp, #40]
 8718              	.LVL976:
1840:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8719              		.loc 1 1840 0
 8720 4c5c 0CC08DE5 		str	ip, [sp, #12]
 8721 4c60 28C09DE5 		ldr	ip, [sp, #40]
 8722 4c64 0020A0E3 		mov	r2, #0
 8723 4c68 2C309DE5 		ldr	r3, [sp, #44]
 8724 4c6c 10C08DE5 		str	ip, [sp, #16]
 8725 4c70 94149FE5 		ldr	r1, .L906+108
 8726 4c74 0400A0E3 		mov	r0, #4
 8727 4c78 FEFFFFEB 		bl	CyU3PDebugPrint
 8728              	.LVL977:
2194:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 8729              		.loc 1 2194 0
 8730 4c7c 30C09DE5 		ldr	ip, [sp, #48]
2204:../uvc.c      **** 					 		 }
 8731              		.loc 1 2204 0
 8732 4c80 30E09DE5 		ldr	lr, [sp, #48]
2194:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 8733              		.loc 1 2194 0
 8734 4c84 A9C5CBE5 		strb	ip, [fp, #1449]
2204:../uvc.c      **** 					 		 }
 8735              		.loc 1 2204 0
 8736 4c88 05C5DBE5 		ldrb	ip, [fp, #1285]	@ zero_extendqisi2
2207:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 8737              		.loc 1 2207 0
 8738 4c8c 7C449FE5 		ldr	r4, .L906+112
 8739              	.LVL978:
2204:../uvc.c      **** 					 		 }
 8740              		.loc 1 2204 0
 8741 4c90 8CC38EE1 		orr	ip, lr, ip, asl #7
2207:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 8742              		.loc 1 2207 0
 8743 4c94 1C0094E5 		ldr	r0, [r4, #28]
2204:../uvc.c      **** 					 		 }
 8744              		.loc 1 2204 0
 8745 4c98 FFC00CE2 		and	ip, ip, #255
 8746              	.LVL979:
2207:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 8747              		.loc 1 2207 0
 8748 4c9c 0010E0E3 		mvn	r1, #0
 8749 4ca0 1CC08DE5 		str	ip, [sp, #28]
 8750 4ca4 FEFFFFEB 		bl	_txe_mutex_get
 8751              	.LVL980:
2208:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 8752              		.loc 1 2208 0
 8753 4ca8 1CC09DE5 		ldr	ip, [sp, #28]
 8754 4cac 0010A0E3 		mov	r1, #0
 8755 4cb0 0530A0E1 		mov	r3, r5
 8756 4cb4 00C08DE5 		str	ip, [sp]
 8757 4cb8 2C209DE5 		ldr	r2, [sp, #44]
 8758 4cbc 0400A0E1 		mov	r0, r4
 8759 4cc0 04108DE5 		str	r1, [sp, #4]
 8760 4cc4 FEFFFFEB 		bl	cmdSet
 8761              	.LVL981:
2209:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 8762              		.loc 1 2209 0
 8763 4cc8 1C0094E5 		ldr	r0, [r4, #28]
 8764 4ccc FEFFFFEB 		bl	_txe_mutex_put
 8765              	.LVL982:
2210:../uvc.c      **** 					 		 break;
 8766              		.loc 1 2210 0
 8767 4cd0 0130A0E3 		mov	r3, #1
 8768 4cd4 AD35CBE5 		strb	r3, [fp, #1453]
 8769 4cd8 1CC09DE5 		ldr	ip, [sp, #28]
 8770 4cdc 28E09DE5 		ldr	lr, [sp, #40]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8771              		.loc 1 1355 0
 8772 4ce0 FF40A0E3 		mov	r4, #255
 8773 4ce4 0450A0E1 		mov	r5, r4
 8774              	.LVL983:
 8775              	.L650:
2279:../uvc.c      **** }
 8776              		.loc 1 2279 0
 8777 4ce8 0C30A0E1 		mov	r3, ip
 8778 4cec 00E08DE5 		str	lr, [sp]
 8779 4cf0 04508DE5 		str	r5, [sp, #4]
 8780 4cf4 08408DE5 		str	r4, [sp, #8]
 8781 4cf8 24209DE5 		ldr	r2, [sp, #36]
 8782 4cfc 0400A0E3 		mov	r0, #4
 8783 4d00 E4139FE5 		ldr	r1, .L906+76
 8784 4d04 FEFFFFEB 		bl	CyU3PDebugPrint
 8785              	.LVL984:
 8786 4d08 44309DE5 		ldr	r3, [sp, #68]
 8787 4d0c 1DFDFFEA 		b	.L619
 8788              	.LVL985:
 8789              	.L891:
 8790              	.LBE205:
 8791              	.LBE228:
 8792              	.LBB229:
 8793              	.LBB217:
1367:../uvc.c      **** 		 {
 8794              		.loc 1 1367 0
 8795 4d10 810054E3 		cmp	r4, #129
 8796 4d14 B003000A 		beq	.L736
 8797 4d18 CD00008A 		bhi	.L737
 8798 4d1c 010054E3 		cmp	r4, #1
 8799 4d20 A501001A 		bne	.L733
1828:../uvc.c      **** 				  glEp0Buffer, &readCount);
 8800              		.loc 1 1828 0
 8801 4d24 42208DE2 		add	r2, sp, #66
 8802 4d28 2000A0E3 		mov	r0, #32
 8803 4d2c CC139FE5 		ldr	r1, .L906+96
 8804 4d30 20308DE5 		str	r3, [sp, #32]
 8805 4d34 1CC08DE5 		str	ip, [sp, #28]
 8806 4d38 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8807              	.LVL986:
1830:../uvc.c      **** 			   {
 8808              		.loc 1 1830 0
 8809 4d3c 20309DE5 		ldr	r3, [sp, #32]
 8810 4d40 1CC09DE5 		ldr	ip, [sp, #28]
 8811 4d44 002050E2 		subs	r2, r0, #0
 8812 4d48 EE03001A 		bne	.L747
1832:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 8813              		.loc 1 1832 0
 8814 4d4c 020053E3 		cmp	r3, #2
1834:../uvc.c      **** 				 }else{
 8815              		.loc 1 1834 0
 8816 4d50 29E0D905 		ldreqb	lr, [r9, #41]	@ zero_extendqisi2
1837:../uvc.c      **** 				 }
 8817              		.loc 1 1837 0
 8818 4d54 2A00D915 		ldrneb	r0, [r9, #42]	@ zero_extendqisi2
 8819              	.LVL987:
1833:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 8820              		.loc 1 1833 0
 8821 4d58 2850D9E5 		ldrb	r5, [r9, #40]	@ zero_extendqisi2
 8822              	.LVL988:
1840:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8823              		.loc 1 1840 0
 8824 4d5c 28209DE5 		ldr	r2, [sp, #40]
 8825              	.LVL989:
1834:../uvc.c      **** 				 }else{
 8826              		.loc 1 1834 0
 8827 4d60 24E08D05 		streq	lr, [sp, #36]
 8828              	.LVL990:
1837:../uvc.c      **** 				 }
 8829              		.loc 1 1837 0
 8830 4d64 24008D15 		strne	r0, [sp, #36]
 8831              	.LVL991:
1840:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8832              		.loc 1 1840 0
 8833 4d68 2C109DE5 		ldr	r1, [sp, #44]
 8834 4d6c 2C008DE9 		stmib	sp, {r2, r3, r5}
 8835 4d70 24309DE5 		ldr	r3, [sp, #36]
 8836 4d74 0B20A0E3 		mov	r2, #11
 8837 4d78 00108DE5 		str	r1, [sp]
 8838 4d7c 10308DE5 		str	r3, [sp, #16]
 8839 4d80 84139FE5 		ldr	r1, .L906+108
 8840 4d84 0C30A0E1 		mov	r3, ip
 8841 4d88 0400A0E3 		mov	r0, #4
 8842 4d8c 1CC08DE5 		str	ip, [sp, #28]
 8843 4d90 FEFFFFEB 		bl	CyU3PDebugPrint
 8844              	.LVL992:
2183:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 8845              		.loc 1 2183 0
 8846 4d94 74E39FE5 		ldr	lr, .L906+112
 8847 4d98 0010E0E3 		mvn	r1, #0
 8848 4d9c 1C009EE5 		ldr	r0, [lr, #28]
 8849 4da0 FEFFFFEB 		bl	_txe_mutex_get
 8850              	.LVL993:
2184:../uvc.c      **** 							 dataIdx++;
 8851              		.loc 1 2184 0
 8852 4da4 1CC09DE5 		ldr	ip, [sp, #28]
 8853 4da8 0030A0E3 		mov	r3, #0
 8854 4dac 0C20A0E1 		mov	r2, ip
 8855 4db0 04308DE5 		str	r3, [sp, #4]
 8856 4db4 0B10A0E3 		mov	r1, #11
 8857 4db8 28309DE5 		ldr	r3, [sp, #40]
 8858 4dbc 00508DE5 		str	r5, [sp]
 8859 4dc0 48039FE5 		ldr	r0, .L906+112
 8860 4dc4 FEFFFFEB 		bl	cmdSet
 8861              	.LVL994:
2186:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 8862              		.loc 1 2186 0
 8863 4dc8 24C09DE5 		ldr	ip, [sp, #36]
 8864 4dcc 01E0A0E3 		mov	lr, #1
 8865 4dd0 00C08DE5 		str	ip, [sp]
 8866 4dd4 2C209DE5 		ldr	r2, [sp, #44]
 8867 4dd8 28309DE5 		ldr	r3, [sp, #40]
 8868 4ddc 04E08DE5 		str	lr, [sp, #4]
 8869 4de0 0B10A0E3 		mov	r1, #11
 8870 4de4 24039FE5 		ldr	r0, .L906+112
 8871 4de8 FEFFFFEB 		bl	cmdSet
 8872              	.LVL995:
2187:../uvc.c      **** 
 8873              		.loc 1 2187 0
 8874 4dec 1C139FE5 		ldr	r1, .L906+112
 8875 4df0 1C0091E5 		ldr	r0, [r1, #28]
 8876 4df4 FEFFFFEB 		bl	_txe_mutex_put
 8877              	.LVL996:
2190:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 8878              		.loc 1 2190 0
 8879 4df8 24C09DE5 		ldr	ip, [sp, #36]
2191:../uvc.c      **** 							 break;
 8880              		.loc 1 2191 0
 8881 4dfc 0120A0E3 		mov	r2, #1
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8882              		.loc 1 1355 0
 8883 4e00 FF30A0E3 		mov	r3, #255
2191:../uvc.c      **** 							 break;
 8884              		.loc 1 2191 0
 8885 4e04 7D27CBE5 		strb	r2, [fp, #1917]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8886              		.loc 1 1355 0
 8887 4e08 0320A0E1 		mov	r2, r3
2189:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 8888              		.loc 1 2189 0
 8889 4e0c 8455CBE5 		strb	r5, [fp, #1412]
2190:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 8890              		.loc 1 2190 0
 8891 4e10 86C5CBE5 		strb	ip, [fp, #1414]
 8892              	.LVL997:
 8893              	.L743:
2279:../uvc.c      **** }
 8894              		.loc 1 2279 0
 8895 4e14 0C008DE9 		stmib	sp, {r2, r3}
 8896 4e18 0420A0E1 		mov	r2, r4
 8897              	.LVL998:
 8898 4e1c 00C08DE5 		str	ip, [sp]
 8899              	.LVL999:
 8900              	.L871:
 8901 4e20 0530A0E1 		mov	r3, r5
 8902 4e24 0400A0E3 		mov	r0, #4
 8903 4e28 BC129FE5 		ldr	r1, .L906+76
 8904 4e2c FEFFFFEB 		bl	CyU3PDebugPrint
 8905              	.LVL1000:
 8906 4e30 44309DE5 		ldr	r3, [sp, #68]
 8907 4e34 D3FCFFEA 		b	.L619
 8908              	.LVL1001:
 8909              	.L881:
 8910              	.LBE217:
 8911              	.LBE229:
 8912              	.LBB230:
 8913              	.LBB172:
1367:../uvc.c      **** 		 {
 8914              		.loc 1 1367 0
 8915 4e38 810055E3 		cmp	r5, #129
 8916 4e3c F901000A 		beq	.L662
 8917 4e40 7A00008A 		bhi	.L663
 8918 4e44 010055E3 		cmp	r5, #1
 8919 4e48 1502001A 		bne	.L659
1828:../uvc.c      **** 				  glEp0Buffer, &readCount);
 8920              		.loc 1 1828 0
 8921 4e4c 42208DE2 		add	r2, sp, #66
 8922 4e50 2000A0E3 		mov	r0, #32
 8923 4e54 A4129FE5 		ldr	r1, .L906+96
 8924 4e58 20308DE5 		str	r3, [sp, #32]
 8925 4e5c 1CC08DE5 		str	ip, [sp, #28]
 8926 4e60 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8927              	.LVL1002:
1830:../uvc.c      **** 			   {
 8928              		.loc 1 1830 0
 8929 4e64 20309DE5 		ldr	r3, [sp, #32]
 8930 4e68 1CC09DE5 		ldr	ip, [sp, #28]
 8931 4e6c 002050E2 		subs	r2, r0, #0
 8932 4e70 B203001A 		bne	.L673
1832:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 8933              		.loc 1 1832 0
 8934 4e74 020053E3 		cmp	r3, #2
1834:../uvc.c      **** 				 }else{
 8935              		.loc 1 1834 0
 8936 4e78 29E0D905 		ldreqb	lr, [r9, #41]	@ zero_extendqisi2
1837:../uvc.c      **** 				 }
 8937              		.loc 1 1837 0
 8938 4e7c 2A00D915 		ldrneb	r0, [r9, #42]	@ zero_extendqisi2
 8939              	.LVL1003:
1833:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 8940              		.loc 1 1833 0
 8941 4e80 2840D9E5 		ldrb	r4, [r9, #40]	@ zero_extendqisi2
 8942              	.LVL1004:
1840:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8943              		.loc 1 1840 0
 8944 4e84 28209DE5 		ldr	r2, [sp, #40]
 8945              	.LVL1005:
1834:../uvc.c      **** 				 }else{
 8946              		.loc 1 1834 0
 8947 4e88 24E08D05 		streq	lr, [sp, #36]
 8948              	.LVL1006:
1837:../uvc.c      **** 				 }
 8949              		.loc 1 1837 0
 8950 4e8c 24008D15 		strne	r0, [sp, #36]
 8951              	.LVL1007:
1840:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 8952              		.loc 1 1840 0
 8953 4e90 2C109DE5 		ldr	r1, [sp, #44]
 8954 4e94 1C008DE9 		stmib	sp, {r2, r3, r4}
 8955 4e98 24309DE5 		ldr	r3, [sp, #36]
 8956 4e9c 0120A0E3 		mov	r2, #1
 8957 4ea0 00108DE5 		str	r1, [sp]
 8958 4ea4 10308DE5 		str	r3, [sp, #16]
 8959 4ea8 5C129FE5 		ldr	r1, .L906+108
 8960 4eac 0C30A0E1 		mov	r3, ip
 8961 4eb0 0400A0E3 		mov	r0, #4
 8962 4eb4 FEFFFFEB 		bl	CyU3PDebugPrint
 8963              	.LVL1008:
2102:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
 8964              		.loc 1 2102 0
 8965 4eb8 50C29FE5 		ldr	ip, .L906+112
 8966 4ebc 0010E0E3 		mvn	r1, #0
 8967 4ec0 1C009CE5 		ldr	r0, [ip, #28]
 8968 4ec4 FEFFFFEB 		bl	_txe_mutex_get
 8969              	.LVL1009:
2111:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 8970              		.loc 1 2111 0
 8971 4ec8 0010A0E3 		mov	r1, #0
 8972 4ecc 2C209DE5 		ldr	r2, [sp, #44]
 8973 4ed0 28309DE5 		ldr	r3, [sp, #40]
 8974 4ed4 04108DE5 		str	r1, [sp, #4]
 8975 4ed8 00408DE5 		str	r4, [sp]
 8976 4edc 0110A0E3 		mov	r1, #1
 8977 4ee0 28029FE5 		ldr	r0, .L906+112
 8978 4ee4 FEFFFFEB 		bl	cmdSet
 8979              	.LVL1010:
2112:../uvc.c      **** 
 8980              		.loc 1 2112 0
 8981 4ee8 20E29FE5 		ldr	lr, .L906+112
 8982 4eec 1C009EE5 		ldr	r0, [lr, #28]
 8983 4ef0 FEFFFFEB 		bl	_txe_mutex_put
 8984              	.LVL1011:
 8985 4ef4 24C09DE5 		ldr	ip, [sp, #36]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8986              		.loc 1 1355 0
 8987 4ef8 FF30A0E3 		mov	r3, #255
2115:../uvc.c      **** 							 break;
 8988              		.loc 1 2115 0
 8989 4efc 0110A0E3 		mov	r1, #1
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8990              		.loc 1 1355 0
 8991 4f00 0320A0E1 		mov	r2, r3
2114:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 8992              		.loc 1 2114 0
 8993 4f04 5545CBE5 		strb	r4, [fp, #1365]
2115:../uvc.c      **** 							 break;
 8994              		.loc 1 2115 0
 8995 4f08 5915CBE5 		strb	r1, [fp, #1369]
 8996              	.LVL1012:
 8997              	.L669:
2279:../uvc.c      **** }
 8998              		.loc 1 2279 0
 8999 4f0c 0C008DE9 		stmib	sp, {r2, r3}
 9000 4f10 0520A0E1 		mov	r2, r5
 9001              	.LVL1013:
 9002 4f14 00C08DE5 		str	ip, [sp]
 9003              	.LVL1014:
 9004              	.L872:
 9005              	.LBE172:
 9006              	.LBE230:
 9007              	.LBB231:
 9008              	.LBB193:
 9009 4f18 0430A0E1 		mov	r3, r4
 9010 4f1c 0400A0E3 		mov	r0, #4
 9011 4f20 C4119FE5 		ldr	r1, .L906+76
 9012 4f24 FEFFFFEB 		bl	CyU3PDebugPrint
 9013              	.LVL1015:
 9014 4f28 44309DE5 		ldr	r3, [sp, #68]
 9015 4f2c 95FCFFEA 		b	.L619
 9016              	.L754:
 9017              	.LVL1016:
 9018              	.LBE193:
 9019              	.LBE231:
 9020              	.LBE274:
 9021              	.LBE289:
 9022              	.LBB290:
 9023              	.LBB162:
4279:../uvc.c      ****     		break;
 9024              		.loc 1 4279 0
 9025 4f30 1C00A0E3 		mov	r0, #28
 9026 4f34 FEFFFFEB 		bl	ControlHandle
 9027              	.LVL1017:
 9028 4f38 44309DE5 		ldr	r3, [sp, #68]
 9029 4f3c 91FCFFEA 		b	.L619
 9030              	.L777:
 9031              	.LVL1018:
4303:../uvc.c      ****     		break;
 9032              		.loc 1 4303 0
 9033 4f40 2600A0E3 		mov	r0, #38
 9034 4f44 FEFFFFEB 		bl	ControlHandle
 9035              	.LVL1019:
 9036 4f48 44309DE5 		ldr	r3, [sp, #68]
 9037 4f4c 8DFCFFEA 		b	.L619
 9038              	.L758:
 9039              	.LVL1020:
4234:../uvc.c      ****      		break;
 9040              		.loc 1 4234 0
 9041 4f50 1200A0E3 		mov	r0, #18
 9042 4f54 FEFFFFEB 		bl	ControlHandle
 9043              	.LVL1021:
 9044 4f58 44309DE5 		ldr	r3, [sp, #68]
 9045 4f5c 89FCFFEA 		b	.L619
 9046              	.L784:
4337:../uvc.c      **** 			CyU3PDebugPrint (4, "The gamma command 0x%x 0x%x\r\n", wValue, bRequest);
 9047              		.loc 1 4337 0
 9048 4f60 2E00A0E3 		mov	r0, #46
 9049 4f64 FEFFFFEB 		bl	ControlHandle
 9050              	.LVL1022:
4338:../uvc.c      ****     		break;
 9051              		.loc 1 4338 0
 9052 4f68 80319FE5 		ldr	r3, .L906+80
 9053 4f6c B020D4E1 		ldrh	r2, [r4]
 9054 4f70 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 9055 4f74 0400A0E3 		mov	r0, #4
 9056 4f78 60119FE5 		ldr	r1, .L906+64
 9057 4f7c FEFFFFEB 		bl	CyU3PDebugPrint
 9058              	.LVL1023:
 9059 4f80 44309DE5 		ldr	r3, [sp, #68]
 9060 4f84 7FFCFFEA 		b	.L619
 9061              	.L768:
 9062              	.LVL1024:
4269:../uvc.c      ****     		break;
 9063              		.loc 1 4269 0
 9064 4f88 1A00A0E3 		mov	r0, #26
 9065 4f8c FEFFFFEB 		bl	ControlHandle
 9066              	.LVL1025:
 9067 4f90 44309DE5 		ldr	r3, [sp, #68]
 9068 4f94 7BFCFFEA 		b	.L619
 9069              	.L764:
 9070              	.LVL1026:
4258:../uvc.c      ****      		break;
 9071              		.loc 1 4258 0
 9072 4f98 1800A0E3 		mov	r0, #24
 9073 4f9c FEFFFFEB 		bl	ControlHandle
 9074              	.LVL1027:
 9075 4fa0 44309DE5 		ldr	r3, [sp, #68]
 9076 4fa4 77FCFFEA 		b	.L619
 9077              	.L756:
 9078              	.LVL1028:
4246:../uvc.c      ****      		break;
 9079              		.loc 1 4246 0
 9080 4fa8 1500A0E3 		mov	r0, #21
 9081 4fac FEFFFFEB 		bl	ControlHandle
 9082              	.LVL1029:
 9083 4fb0 44309DE5 		ldr	r3, [sp, #68]
 9084 4fb4 73FCFFEA 		b	.L619
 9085              	.L780:
4327:../uvc.c      **** 			CyU3PDebugPrint (4, "The edge start/end command 0x%x 0x%x\r\n", wValue, bRequest);
 9086              		.loc 1 4327 0
 9087 4fb8 2B00A0E3 		mov	r0, #43
 9088 4fbc FEFFFFEB 		bl	ControlHandle
 9089              	.LVL1030:
4328:../uvc.c      ****     		break;
 9090              		.loc 1 4328 0
 9091 4fc0 28319FE5 		ldr	r3, .L906+80
 9092 4fc4 B020D4E1 		ldrh	r2, [r4]
 9093 4fc8 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 9094 4fcc 0400A0E3 		mov	r0, #4
 9095 4fd0 0C119FE5 		ldr	r1, .L906+68
 9096 4fd4 FEFFFFEB 		bl	CyU3PDebugPrint
 9097              	.LVL1031:
 9098 4fd8 44309DE5 		ldr	r3, [sp, #68]
 9099 4fdc 69FCFFEA 		b	.L619
 9100              	.L773:
 9101              	.LVL1032:
4295:../uvc.c      ****     		break;
 9102              		.loc 1 4295 0
 9103 4fe0 2400A0E3 		mov	r0, #36
 9104 4fe4 FEFFFFEB 		bl	ControlHandle
 9105              	.LVL1033:
 9106 4fe8 44309DE5 		ldr	r3, [sp, #68]
 9107 4fec 65FCFFEA 		b	.L619
 9108              	.L771:
4312:../uvc.c      **** 			CyU3PDebugPrint (4, "The ctrlspd command 0x%x 0x%x\r\n", wValue, bRequest);
 9109              		.loc 1 4312 0
 9110 4ff0 2800A0E3 		mov	r0, #40
 9111 4ff4 FEFFFFEB 		bl	ControlHandle
 9112              	.LVL1034:
4313:../uvc.c      ****     		break;
 9113              		.loc 1 4313 0
 9114 4ff8 F0309FE5 		ldr	r3, .L906+80
 9115 4ffc B020D4E1 		ldrh	r2, [r4]
 9116 5000 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 9117 5004 0400A0E3 		mov	r0, #4
 9118 5008 D8109FE5 		ldr	r1, .L906+72
 9119 500c FEFFFFEB 		bl	CyU3PDebugPrint
 9120              	.LVL1035:
 9121 5010 44309DE5 		ldr	r3, [sp, #68]
 9122 5014 5BFCFFEA 		b	.L619
 9123              	.LVL1036:
 9124              	.L885:
 9125 5018 0250A0E1 		mov	r5, r2
 9126              	.LBE162:
 9127              	.LBE290:
4883:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 9128              		.loc 1 4883 0
 9129 501c 0C00A0E1 		mov	r0, ip
 9130              	.LVL1037:
 9131 5020 A8109FE5 		ldr	r1, .L906+48
 9132 5024 FEFFFFEB 		bl	CyU3PDebugPrint
 9133              	.LVL1038:
4884:../uvc.c      **** 					}
 9134              		.loc 1 4884 0
 9135 5028 0500A0E1 		mov	r0, r5
 9136 502c FEFFFFEB 		bl	CyFxAppErrorHandler
 9137              	.LVL1039:
 9138              	.L663:
 9139              	.LBB291:
 9140              	.LBB275:
 9141              	.LBB232:
 9142              	.LBB173:
1697:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9143              		.loc 1 1697 0
 9144 5030 020053E3 		cmp	r3, #2
1698:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 9145              		.loc 1 1698 0
 9146 5034 4BC5DBE5 		ldrb	ip, [fp, #1355]	@ zero_extendqisi2
 9147              	.LVL1040:
1709:../uvc.c      **** 		 	 if(Len == 2){
 9148              		.loc 1 1709 0
 9149 5038 0300A0E1 		mov	r0, r3
 9150              	.LVL1041:
1699:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9151              		.loc 1 1699 0
 9152 503c 4C25DBE5 		ldrb	r2, [fp, #1356]	@ zero_extendqisi2
1697:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9153              		.loc 1 1697 0
 9154 5040 8CFCFF1A 		bne	.L672
 9155              	.LVL1042:
 9156              	.L859:
1745:../uvc.c      **** 				  if(Len == 2){
 9157              		.loc 1 1745 0
 9158 5044 B4109FE5 		ldr	r1, .L906+96
1734:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9159              		.loc 1 1734 0
 9160 5048 28C0C8E5 		strb	ip, [r8, #40]
1735:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9161              		.loc 1 1735 0
 9162 504c 2920C8E5 		strb	r2, [r8, #41]
 9163 5050 880000EA 		b	.L861
 9164              	.LVL1043:
 9165              	.L737:
 9166              	.LBE173:
 9167              	.LBE232:
 9168              	.LBB233:
 9169              	.LBB218:
1697:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9170              		.loc 1 1697 0
 9171 5054 020053E3 		cmp	r3, #2
1698:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 9172              		.loc 1 1698 0
 9173 5058 6FC7DBE5 		ldrb	ip, [fp, #1903]	@ zero_extendqisi2
 9174              	.LVL1044:
1709:../uvc.c      **** 		 	 if(Len == 2){
 9175              		.loc 1 1709 0
 9176 505c 0300A0E1 		mov	r0, r3
 9177              	.LVL1045:
1699:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9178              		.loc 1 1699 0
 9179 5060 7027DBE5 		ldrb	r2, [fp, #1904]	@ zero_extendqisi2
1697:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9180              		.loc 1 1697 0
 9181 5064 EAFDFF1A 		bne	.L746
 9182              	.LVL1046:
 9183              	.L873:
1807:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 9184              		.loc 1 1807 0
 9185 5068 28C0C8E5 		strb	ip, [r8, #40]
1818:../uvc.c      **** 		 	 if(Len == 2){
 9186              		.loc 1 1818 0
 9187 506c 8C109FE5 		ldr	r1, .L906+96
1808:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 9188              		.loc 1 1808 0
 9189 5070 2920C8E5 		strb	r2, [r8, #41]
1821:../uvc.c      **** 		 	 }else{
 9190              		.loc 1 1821 0
 9191 5074 00C0A0E3 		mov	ip, #0
 9192 5078 370000EA 		b	.L868
 9193              	.LVL1047:
 9194              	.L680:
 9195              	.LBE218:
 9196              	.LBE233:
 9197              	.LBB234:
 9198              	.LBB182:
1697:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9199              		.loc 1 1697 0
 9200 507c 020053E3 		cmp	r3, #2
1698:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 9201              		.loc 1 1698 0
 9202 5080 73C5DBE5 		ldrb	ip, [fp, #1395]	@ zero_extendqisi2
 9203              	.LVL1048:
1709:../uvc.c      **** 		 	 if(Len == 2){
 9204              		.loc 1 1709 0
 9205 5084 0300A0E1 		mov	r0, r3
1699:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9206              		.loc 1 1699 0
 9207 5088 7425DBE5 		ldrb	r2, [fp, #1396]	@ zero_extendqisi2
1697:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9208              		.loc 1 1697 0
 9209 508c 50FDFF1A 		bne	.L689
 9210              	.LVL1049:
 9211              	.L862:
1745:../uvc.c      **** 				  if(Len == 2){
 9212              		.loc 1 1745 0
 9213 5090 68109FE5 		ldr	r1, .L906+96
1734:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9214              		.loc 1 1734 0
 9215 5094 28C0C8E5 		strb	ip, [r8, #40]
1735:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9216              		.loc 1 1735 0
 9217 5098 2920C8E5 		strb	r2, [r8, #41]
 9218 509c 650000EA 		b	.L863
 9219              	.L907:
 9220              		.align	2
 9221              	.L906:
 9222 50a0 00000000 		.word	.LANCHOR0
 9223 50a4 00000000 		.word	.LANCHOR1
 9224 50a8 00000000 		.word	glInterStaBuffer
 9225 50ac 00000000 		.word	wIndex
 9226 50b0 00000000 		.word	wValue
 9227 50b4 AC0C0000 		.word	.LC70
 9228 50b8 00000000 		.word	bmReqType
 9229 50bc 00000000 		.word	wLength
 9230 50c0 300C0000 		.word	.LC69
 9231 50c4 00000000 		.word	glChHandleInterStat
 9232 50c8 880D0000 		.word	.LC76
 9233 50cc 3C0D0000 		.word	.LC74
 9234 50d0 F00D0000 		.word	.LC79
 9235 50d4 D00D0000 		.word	.LC78
 9236 50d8 180D0000 		.word	.LC73
 9237 50dc B8050000 		.word	.LC32
 9238 50e0 B00D0000 		.word	.LC77
 9239 50e4 600D0000 		.word	.LC75
 9240 50e8 F80C0000 		.word	.LC72
 9241 50ec 2C060000 		.word	.LC35
 9242 50f0 00000000 		.word	bRequest
 9243 50f4 D80C0000 		.word	.LC71
 9244 50f8 64050000 		.word	.LC31
 9245 50fc D8050000 		.word	.LC33
 9246 5100 28000000 		.word	.LANCHOR0+40
 9247 5104 38040000 		.word	.LC26
 9248 5108 FC050000 		.word	.LC34
 9249 510c 68040000 		.word	.LC27
 9250 5110 00000000 		.word	cmdQu
 9251 5114 00000000 		.word	.LANCHOR1
 9252              	.LVL1050:
 9253              	.L644:
 9254              	.LBE182:
 9255              	.LBE234:
 9256              	.LBB235:
 9257              	.LBB206:
1697:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9258              		.loc 1 1697 0
 9259 5118 02005CE3 		cmp	ip, #2
1698:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 9260              		.loc 1 1698 0
 9261 511c 9F25DB05 		ldreqb	r2, [fp, #1439]	@ zero_extendqisi2
1709:../uvc.c      **** 		 	 if(Len == 2){
 9262              		.loc 1 1709 0
 9263 5120 0200A003 		moveq	r0, #2
1699:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9264              		.loc 1 1699 0
 9265 5124 A035DB05 		ldreqb	r3, [fp, #1440]	@ zero_extendqisi2
1697:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9266              		.loc 1 1697 0
 9267 5128 C001000A 		beq	.L854
1702:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9268              		.loc 1 1702 0
 9269 512c 9FE5DBE5 		ldrb	lr, [fp, #1439]	@ zero_extendqisi2
1704:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 9270              		.loc 1 1704 0
 9271 5130 A025DBE5 		ldrb	r2, [fp, #1440]	@ zero_extendqisi2
 9272 5134 8AFDFFEA 		b	.L856
 9273              	.LVL1051:
 9274              	.L741:
 9275              	.LBE206:
 9276              	.LBE235:
 9277              	.LBB236:
 9278              	.LBB219:
1780:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9279              		.loc 1 1780 0
 9280 5138 7527DBE5 		ldrb	r2, [fp, #1909]	@ zero_extendqisi2
1786:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9281              		.loc 1 1786 0
 9282 513c 44101FE5 		ldr	r1, .L906+96
1781:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9283              		.loc 1 1781 0
 9284 5140 0030A0E3 		mov	r3, #0
 9285              	.LVL1052:
1786:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9286              		.loc 1 1786 0
 9287 5144 0100A0E3 		mov	r0, #1
1780:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9288              		.loc 1 1780 0
 9289 5148 2820C8E5 		strb	r2, [r8, #40]
1781:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9290              		.loc 1 1781 0
 9291 514c 2930C8E5 		strb	r3, [r8, #41]
 9292              	.LVL1053:
 9293              	.L869:
1769:../uvc.c      **** 			  //CyU3PDebugPrint (4, "The control ResLo: 0x%x, ResHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0], g
 9294              		.loc 1 1769 0
 9295 5150 03C0A0E1 		mov	ip, r3
1764:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9296              		.loc 1 1764 0
 9297 5154 2A30C8E5 		strb	r3, [r8, #42]
1765:../uvc.c      **** 		 	 }
 9298              		.loc 1 1765 0
 9299 5158 2B30C8E5 		strb	r3, [r8, #43]
 9300              	.L868:
1769:../uvc.c      **** 			  //CyU3PDebugPrint (4, "The control ResLo: 0x%x, ResHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0], g
 9301              		.loc 1 1769 0
 9302 515c 24C08DE5 		str	ip, [sp, #36]
 9303 5160 0050A0E3 		mov	r5, #0
1767:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9304              		.loc 1 1767 0
 9305 5164 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9306              	.LVL1054:
1768:../uvc.c      **** 			  sendData1 = glEp0Buffer[1];
 9307              		.loc 1 1768 0
 9308 5168 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 9309              	.LVL1055:
1769:../uvc.c      **** 			  //CyU3PDebugPrint (4, "The control ResLo: 0x%x, ResHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0], g
 9310              		.loc 1 1769 0
 9311 516c 2930D8E5 		ldrb	r3, [r8, #41]	@ zero_extendqisi2
 9312              	.LVL1056:
 9313 5170 24C09DE5 		ldr	ip, [sp, #36]
 9314 5174 26FFFFEA 		b	.L743
 9315              	.LVL1057:
 9316              	.L717:
 9317              	.LBE219:
 9318              	.LBE236:
 9319              	.LBB237:
 9320              	.LBB194:
1780:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9321              		.loc 1 1780 0
 9322 5178 6CE01FE5 		ldr	lr, .L906+116
1786:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9323              		.loc 1 1786 0
 9324 517c 84101FE5 		ldr	r1, .L906+96
1780:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9325              		.loc 1 1780 0
 9326 5180 6127DEE5 		ldrb	r2, [lr, #1889]	@ zero_extendqisi2
1781:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9327              		.loc 1 1781 0
 9328 5184 0030A0E3 		mov	r3, #0
 9329              	.LVL1058:
1786:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9330              		.loc 1 1786 0
 9331 5188 0100A0E3 		mov	r0, #1
1780:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9332              		.loc 1 1780 0
 9333 518c 2820C8E5 		strb	r2, [r8, #40]
1781:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9334              		.loc 1 1781 0
 9335 5190 2930C8E5 		strb	r3, [r8, #41]
1782:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9336              		.loc 1 1782 0
 9337 5194 2A30C8E5 		strb	r3, [r8, #42]
1783:../uvc.c      **** 		 	 }
 9338              		.loc 1 1783 0
 9339 5198 2B30C8E5 		strb	r3, [r8, #43]
 9340              	.LVL1059:
 9341              	.L865:
1748:../uvc.c      **** 				  }else{
 9342              		.loc 1 1748 0
 9343 519c 00C0A0E3 		mov	ip, #0
 9344 51a0 24C08DE5 		str	ip, [sp, #36]
 9345 51a4 0040A0E3 		mov	r4, #0
1745:../uvc.c      **** 				  if(Len == 2){
 9346              		.loc 1 1745 0
 9347 51a8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9348              	.LVL1060:
1747:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 9349              		.loc 1 1747 0
 9350 51ac 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 9351              	.LVL1061:
1748:../uvc.c      **** 				  }else{
 9352              		.loc 1 1748 0
 9353 51b0 2950D8E5 		ldrb	r5, [r8, #41]	@ zero_extendqisi2
 9354              	.LVL1062:
 9355 51b4 24109DE5 		ldr	r1, [sp, #36]
 9356 51b8 54FEFFEA 		b	.L719
 9357              	.LVL1063:
 9358              	.L648:
 9359              	.LBE194:
 9360              	.LBE237:
 9361              	.LBB238:
 9362              	.LBB207:
1780:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9363              		.loc 1 1780 0
 9364 51bc A525DBE5 		ldrb	r2, [fp, #1445]	@ zero_extendqisi2
1786:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9365              		.loc 1 1786 0
 9366 51c0 C8101FE5 		ldr	r1, .L906+96
1781:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9367              		.loc 1 1781 0
 9368 51c4 0030A0E3 		mov	r3, #0
1786:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9369              		.loc 1 1786 0
 9370 51c8 0100A0E3 		mov	r0, #1
1780:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9371              		.loc 1 1780 0
 9372 51cc 2820C8E5 		strb	r2, [r8, #40]
1781:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9373              		.loc 1 1781 0
 9374 51d0 2930C8E5 		strb	r3, [r8, #41]
1782:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9375              		.loc 1 1782 0
 9376 51d4 2A30C8E5 		strb	r3, [r8, #42]
1783:../uvc.c      **** 		 	 }
 9377              		.loc 1 1783 0
 9378 51d8 2B30C8E5 		strb	r3, [r8, #43]
 9379              	.LVL1064:
 9380              	.L858:
1748:../uvc.c      **** 				  }else{
 9381              		.loc 1 1748 0
 9382 51dc 00C0A0E3 		mov	ip, #0
 9383 51e0 28C08DE5 		str	ip, [sp, #40]
1745:../uvc.c      **** 				  if(Len == 2){
 9384              		.loc 1 1745 0
 9385 51e4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9386              	.LVL1065:
1748:../uvc.c      **** 				  }else{
 9387              		.loc 1 1748 0
 9388 51e8 00C0A0E3 		mov	ip, #0
1747:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 9389              		.loc 1 1747 0
 9390 51ec 2850D8E5 		ldrb	r5, [r8, #40]	@ zero_extendqisi2
 9391              	.LVL1066:
1748:../uvc.c      **** 				  }else{
 9392              		.loc 1 1748 0
 9393 51f0 2940D8E5 		ldrb	r4, [r8, #41]	@ zero_extendqisi2
 9394              	.LVL1067:
 9395 51f4 28E09DE5 		ldr	lr, [sp, #40]
 9396 51f8 BAFEFFEA 		b	.L650
 9397              	.LVL1068:
 9398              	.L713:
 9399              	.LBE207:
 9400              	.LBE238:
 9401              	.LBB239:
 9402              	.LBB195:
1697:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9403              		.loc 1 1697 0
 9404 51fc 020053E3 		cmp	r3, #2
 9405 5200 1302000A 		beq	.L896
1702:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9406              		.loc 1 1702 0
 9407 5204 F8E01FE5 		ldr	lr, .L906+116
1709:../uvc.c      **** 		 	 if(Len == 2){
 9408              		.loc 1 1709 0
 9409 5208 0300A0E1 		mov	r0, r3
1702:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9410              		.loc 1 1702 0
 9411 520c 5BC7DEE5 		ldrb	ip, [lr, #1883]	@ zero_extendqisi2
1704:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 9412              		.loc 1 1704 0
 9413 5210 5C27DEE5 		ldrb	r2, [lr, #1884]	@ zero_extendqisi2
 9414 5214 29FDFFEA 		b	.L724
 9415              	.LVL1069:
 9416              	.L684:
 9417              	.LBE195:
 9418              	.LBE239:
 9419              	.LBB240:
 9420              	.LBB183:
1780:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9421              		.loc 1 1780 0
 9422 5218 7925DBE5 		ldrb	r2, [fp, #1401]	@ zero_extendqisi2
1786:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9423              		.loc 1 1786 0
 9424 521c 24111FE5 		ldr	r1, .L906+96
1781:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9425              		.loc 1 1781 0
 9426 5220 0030A0E3 		mov	r3, #0
 9427              	.LVL1070:
1786:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9428              		.loc 1 1786 0
 9429 5224 0100A0E3 		mov	r0, #1
1780:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9430              		.loc 1 1780 0
 9431 5228 2820C8E5 		strb	r2, [r8, #40]
1781:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9432              		.loc 1 1781 0
 9433 522c 2930C8E5 		strb	r3, [r8, #41]
1782:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9434              		.loc 1 1782 0
 9435 5230 2A30C8E5 		strb	r3, [r8, #42]
1783:../uvc.c      **** 		 	 }
 9436              		.loc 1 1783 0
 9437 5234 2B30C8E5 		strb	r3, [r8, #43]
 9438              	.LVL1071:
 9439              	.L863:
1748:../uvc.c      **** 				  }else{
 9440              		.loc 1 1748 0
 9441 5238 00C0A0E3 		mov	ip, #0
 9442 523c 28C08DE5 		str	ip, [sp, #40]
 9443 5240 0050A0E3 		mov	r5, #0
1745:../uvc.c      **** 				  if(Len == 2){
 9444              		.loc 1 1745 0
 9445 5244 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9446              	.LVL1072:
1747:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 9447              		.loc 1 1747 0
 9448 5248 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 9449              	.LVL1073:
1748:../uvc.c      **** 				  }else{
 9450              		.loc 1 1748 0
 9451 524c 2940D8E5 		ldrb	r4, [r8, #41]	@ zero_extendqisi2
 9452              	.LVL1074:
 9453 5250 28109DE5 		ldr	r1, [sp, #40]
 9454 5254 64FEFFEA 		b	.L686
 9455              	.LVL1075:
 9456              	.L667:
 9457              	.LBE183:
 9458              	.LBE240:
 9459              	.LBB241:
 9460              	.LBB174:
1780:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9461              		.loc 1 1780 0
 9462 5258 5125DBE5 		ldrb	r2, [fp, #1361]	@ zero_extendqisi2
1786:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9463              		.loc 1 1786 0
 9464 525c 64111FE5 		ldr	r1, .L906+96
1781:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9465              		.loc 1 1781 0
 9466 5260 0030A0E3 		mov	r3, #0
 9467              	.LVL1076:
1786:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9468              		.loc 1 1786 0
 9469 5264 0100A0E3 		mov	r0, #1
1780:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9470              		.loc 1 1780 0
 9471 5268 2820C8E5 		strb	r2, [r8, #40]
1781:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9472              		.loc 1 1781 0
 9473 526c 2930C8E5 		strb	r3, [r8, #41]
1782:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9474              		.loc 1 1782 0
 9475 5270 2A30C8E5 		strb	r3, [r8, #42]
1783:../uvc.c      **** 		 	 }
 9476              		.loc 1 1783 0
 9477 5274 2B30C8E5 		strb	r3, [r8, #43]
 9478              	.LVL1077:
 9479              	.L861:
1748:../uvc.c      **** 				  }else{
 9480              		.loc 1 1748 0
 9481 5278 00C0A0E3 		mov	ip, #0
 9482 527c 24C08DE5 		str	ip, [sp, #36]
 9483 5280 0040A0E3 		mov	r4, #0
1745:../uvc.c      **** 				  if(Len == 2){
 9484              		.loc 1 1745 0
 9485 5284 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9486              	.LVL1078:
1747:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 9487              		.loc 1 1747 0
 9488 5288 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 9489              	.LVL1079:
1748:../uvc.c      **** 				  }else{
 9490              		.loc 1 1748 0
 9491 528c 2930D8E5 		ldrb	r3, [r8, #41]	@ zero_extendqisi2
 9492              	.LVL1080:
 9493 5290 24C09DE5 		ldr	ip, [sp, #36]
 9494 5294 1CFFFFEA 		b	.L669
 9495              	.LVL1081:
 9496              	.L793:
 9497              	.LBE174:
 9498              	.LBE241:
 9499              	.LBE275:
 9500              	.LBE291:
 9501              	.LBB292:
 9502              	.LBB163:
 9503              	.LBB152:
 9504              	.LBB146:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9505              		.loc 1 1372 0
 9506 5298 0020A0E3 		mov	r2, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9507              		.loc 1 1373 0
 9508 529c 0200A0E3 		mov	r0, #2
 9509 52a0 A8111FE5 		ldr	r1, .L906+96
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9510              		.loc 1 1371 0
 9511 52a4 2830C8E5 		strb	r3, [r8, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9512              		.loc 1 1372 0
 9513 52a8 2920C8E5 		strb	r2, [r8, #41]
1374:../uvc.c      **** 			  break;
 9514              		.loc 1 1374 0
 9515 52ac 24208DE5 		str	r2, [sp, #36]
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9516              		.loc 1 1373 0
 9517 52b0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9518              	.LVL1082:
1374:../uvc.c      **** 			  break;
 9519              		.loc 1 1374 0
 9520 52b4 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 9521              	.LVL1083:
 9522 52b8 0040A0E3 		mov	r4, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9523              		.loc 1 1355 0
 9524 52bc FF50A0E3 		mov	r5, #255
 9525              	.LVL1084:
 9526              	.L797:
2279:../uvc.c      **** }
 9527              		.loc 1 2279 0
 9528 52c0 24109DE5 		ldr	r1, [sp, #36]
 9529 52c4 28209DE5 		ldr	r2, [sp, #40]
 9530 52c8 02108DE8 		stmia	sp, {r1, ip}
 9531 52cc E8111FE5 		ldr	r1, .L906+76
 9532 52d0 0430A0E1 		mov	r3, r4
 9533 52d4 08508DE5 		str	r5, [sp, #8]
 9534 52d8 0400A0E3 		mov	r0, #4
 9535 52dc FEFFFFEB 		bl	CyU3PDebugPrint
 9536              	.LVL1085:
 9537              	.LBE146:
 9538              	.LBE152:
4308:../uvc.c      ****     		break;
 9539              		.loc 1 4308 0
 9540 52e0 F8211FE5 		ldr	r2, .L906+80
 9541 52e4 0400A0E3 		mov	r0, #4
 9542 52e8 0030D2E5 		ldrb	r3, [r2]	@ zero_extendqisi2
 9543 52ec 00121FE5 		ldr	r1, .L906+84
 9544 52f0 B020D7E1 		ldrh	r2, [r7]
 9545 52f4 FEFFFFEB 		bl	CyU3PDebugPrint
 9546              	.LVL1086:
 9547 52f8 44309DE5 		ldr	r3, [sp, #68]
 9548 52fc A1FBFFEA 		b	.L619
 9549              	.LVL1087:
 9550              	.L892:
 9551              	.LBB153:
 9552              	.LBB147:
1367:../uvc.c      **** 		 {
 9553              		.loc 1 1367 0
 9554 5300 81005CE3 		cmp	ip, #129
 9555 5304 6C01000A 		beq	.L790
 9556 5308 6201008A 		bhi	.L791
 9557 530c 01005CE3 		cmp	ip, #1
 9558 5310 5601001A 		bne	.L787
1828:../uvc.c      **** 				  glEp0Buffer, &readCount);
 9559              		.loc 1 1828 0
 9560 5314 2000A0E3 		mov	r0, #32
 9561 5318 20121FE5 		ldr	r1, .L906+96
 9562 531c 42208DE2 		add	r2, sp, #66
 9563 5320 20308DE5 		str	r3, [sp, #32]
 9564 5324 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9565              	.LVL1088:
1830:../uvc.c      **** 			   {
 9566              		.loc 1 1830 0
 9567 5328 20309DE5 		ldr	r3, [sp, #32]
 9568 532c 000050E3 		cmp	r0, #0
 9569 5330 34008DE5 		str	r0, [sp, #52]
 9570 5334 BC01001A 		bne	.L803
1832:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 9571              		.loc 1 1832 0
 9572 5338 020053E3 		cmp	r3, #2
1833:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 9573              		.loc 1 1833 0
 9574 533c 2840D9E5 		ldrb	r4, [r9, #40]	@ zero_extendqisi2
1832:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 9575              		.loc 1 1832 0
 9576 5340 DD02000A 		beq	.L897
 9577              	.LVL1089:
1837:../uvc.c      **** 				 }
 9578              		.loc 1 1837 0
 9579 5344 2AC0D9E5 		ldrb	ip, [r9, #42]	@ zero_extendqisi2
1840:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 9580              		.loc 1 1840 0
 9581 5348 38308DE5 		str	r3, [sp, #56]
1837:../uvc.c      **** 				 }
 9582              		.loc 1 1837 0
 9583 534c 24C08DE5 		str	ip, [sp, #36]
 9584              	.LVL1090:
1840:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 9585              		.loc 1 1840 0
 9586 5350 2CC09DE5 		ldr	ip, [sp, #44]
 9587 5354 08308DE5 		str	r3, [sp, #8]
 9588 5358 04C08DE5 		str	ip, [sp, #4]
 9589 535c 24C09DE5 		ldr	ip, [sp, #36]
 9590 5360 00508DE5 		str	r5, [sp]
 9591 5364 10C08DE5 		str	ip, [sp, #16]
 9592 5368 0C408DE5 		str	r4, [sp, #12]
 9593 536c 0400A0E3 		mov	r0, #4
 9594              	.LVL1091:
 9595 5370 6C121FE5 		ldr	r1, .L906+108
 9596 5374 2720A0E3 		mov	r2, #39
 9597 5378 30309DE5 		ldr	r3, [sp, #48]
 9598 537c FEFFFFEB 		bl	CyU3PDebugPrint
 9599              	.LVL1092:
2055:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 9600              		.loc 1 2055 0
 9601 5380 38C09DE5 		ldr	ip, [sp, #56]
 9602 5384 04005CE3 		cmp	ip, #4
 9603 5388 F302000A 		beq	.L898
 9604              	.LVL1093:
 9605              	.L808:
2072:../uvc.c      **** 				 	 			 break;
 9606              		.loc 1 2072 0
 9607 538c 8E27DBE5 		ldrb	r2, [fp, #1934]	@ zero_extendqisi2
2071:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 9608              		.loc 1 2071 0
 9609 5390 38C09DE5 		ldr	ip, [sp, #56]
2072:../uvc.c      **** 				 	 			 break;
 9610              		.loc 1 2072 0
 9611 5394 8D37DBE5 		ldrb	r3, [fp, #1933]	@ zero_extendqisi2
2071:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 9612              		.loc 1 2071 0
 9613 5398 0400A0E3 		mov	r0, #4
 9614 539c 0C108DE8 		stmia	sp, {r2, r3, ip}
 9615 53a0 B0121FE5 		ldr	r1, .L906+88
 9616 53a4 0420A0E1 		mov	r2, r4
 9617 53a8 24309DE5 		ldr	r3, [sp, #36]
 9618 53ac FEFFFFEB 		bl	CyU3PDebugPrint
 9619              	.LVL1094:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9620              		.loc 1 1355 0
 9621 53b0 FF50A0E3 		mov	r5, #255
 9622 53b4 05C0A0E1 		mov	ip, r5
 9623 53b8 C0FFFFEA 		b	.L797
 9624              	.LVL1095:
 9625              	.L733:
 9626              	.LBE147:
 9627              	.LBE153:
 9628              	.LBE163:
 9629              	.LBE292:
 9630              	.LBB293:
 9631              	.LBB276:
 9632              	.LBB242:
 9633              	.LBB220:
2276:../uvc.c      **** 			  break;
 9634              		.loc 1 2276 0
 9635 53bc 0000A0E3 		mov	r0, #0
 9636 53c0 0020A0E1 		mov	r2, r0
 9637 53c4 0110A0E3 		mov	r1, #1
 9638 53c8 FEFFFFEB 		bl	CyU3PUsbStall
 9639              	.LVL1096:
 9640              	.L867:
 9641 53cc 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9642              		.loc 1 1355 0
 9643 53d0 FF30A0E3 		mov	r3, #255
 9644 53d4 0320A0E1 		mov	r2, r3
2276:../uvc.c      **** 			  break;
 9645              		.loc 1 2276 0
 9646 53d8 24C08DE5 		str	ip, [sp, #36]
 9647 53dc 0C50A0E1 		mov	r5, ip
 9648 53e0 8BFEFFEA 		b	.L743
 9649              	.LVL1097:
 9650              	.L643:
 9651              	.LBE220:
 9652              	.LBE242:
 9653              	.LBB243:
 9654              	.LBB208:
1652:../uvc.c      **** 			 	 			 {
 9655              		.loc 1 1652 0
 9656 53e4 02005CE3 		cmp	ip, #2
 9657 53e8 1503000A 		beq	.L899
1660:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 9658              		.loc 1 1660 0
 9659 53ec 04005CE3 		cmp	ip, #4
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9660              		.loc 1 1355 0
 9661 53f0 FF40A013 		movne	r4, #255
 9662              	.LVL1098:
 9663 53f4 0450A011 		movne	r5, r4
 9664              	.LVL1099:
1660:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 9665              		.loc 1 1660 0
 9666 53f8 7801000A 		beq	.L900
 9667              	.LVL1100:
 9668              	.L652:
1676:../uvc.c      **** 
 9669              		.loc 1 1676 0
 9670 53fc 0C00A0E1 		mov	r0, ip
 9671 5400 08131FE5 		ldr	r1, .L906+96
 9672 5404 1CC08DE5 		str	ip, [sp, #28]
 9673 5408 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9674              	.LVL1101:
1679:../uvc.c      **** //#endif
 9675              		.loc 1 1679 0
 9676 540c 2B00D8E5 		ldrb	r0, [r8, #43]	@ zero_extendqisi2
 9677 5410 2C10D8E5 		ldrb	r1, [r8, #44]	@ zero_extendqisi2
 9678 5414 1CC09DE5 		ldr	ip, [sp, #28]
 9679 5418 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 9680 541c 03108DE8 		stmia	sp, {r0, r1, ip}
 9681 5420 2930D8E5 		ldrb	r3, [r8, #41]	@ zero_extendqisi2
 9682 5424 0400A0E3 		mov	r0, #4
 9683 5428 2C131FE5 		ldr	r1, .L906+100
 9684 542c FEFFFFEB 		bl	CyU3PDebugPrint
 9685              	.LVL1102:
 9686 5430 00C0A0E3 		mov	ip, #0
 9687 5434 28C08DE5 		str	ip, [sp, #40]
 9688 5438 0CE0A0E1 		mov	lr, ip
 9689 543c 29FEFFEA 		b	.L650
 9690              	.LVL1103:
 9691              	.L640:
2276:../uvc.c      **** 			  break;
 9692              		.loc 1 2276 0
 9693 5440 0000A0E3 		mov	r0, #0
 9694 5444 0020A0E1 		mov	r2, r0
 9695 5448 0110A0E3 		mov	r1, #1
 9696 544c FEFFFFEB 		bl	CyU3PUsbStall
 9697              	.LVL1104:
 9698              	.L855:
 9699 5450 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9700              		.loc 1 1355 0
 9701 5454 FF40A0E3 		mov	r4, #255
 9702              	.LVL1105:
 9703 5458 0450A0E1 		mov	r5, r4
 9704              	.LVL1106:
2276:../uvc.c      **** 			  break;
 9705              		.loc 1 2276 0
 9706 545c 28C08DE5 		str	ip, [sp, #40]
 9707 5460 0CE0A0E1 		mov	lr, ip
 9708 5464 1FFEFFEA 		b	.L650
 9709              	.LVL1107:
 9710              	.L683:
 9711              	.LBE208:
 9712              	.LBE243:
 9713              	.LBB244:
 9714              	.LBB184:
1762:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 9715              		.loc 1 1762 0
 9716 5468 77C5DBE5 		ldrb	ip, [fp, #1399]	@ zero_extendqisi2
1763:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9717              		.loc 1 1763 0
 9718 546c 7825DBE5 		ldrb	r2, [fp, #1400]	@ zero_extendqisi2
1767:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9719              		.loc 1 1767 0
 9720 5470 0300A0E1 		mov	r0, r3
1764:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9721              		.loc 1 1764 0
 9722 5474 0030A0E3 		mov	r3, #0
 9723              	.LVL1108:
1767:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9724              		.loc 1 1767 0
 9725 5478 80131FE5 		ldr	r1, .L906+96
1762:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 9726              		.loc 1 1762 0
 9727 547c 28C0C8E5 		strb	ip, [r8, #40]
1763:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9728              		.loc 1 1763 0
 9729 5480 2920C8E5 		strb	r2, [r8, #41]
1764:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9730              		.loc 1 1764 0
 9731 5484 2A30C8E5 		strb	r3, [r8, #42]
1765:../uvc.c      **** 		 	 }
 9732              		.loc 1 1765 0
 9733 5488 2B30C8E5 		strb	r3, [r8, #43]
 9734 548c 69FFFFEA 		b	.L863
 9735              	.LVL1109:
 9736              	.L666:
 9737              	.LBE184:
 9738              	.LBE244:
 9739              	.LBB245:
 9740              	.LBB175:
1762:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 9741              		.loc 1 1762 0
 9742 5490 4FC5DBE5 		ldrb	ip, [fp, #1359]	@ zero_extendqisi2
 9743              	.LVL1110:
1763:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9744              		.loc 1 1763 0
 9745 5494 5025DBE5 		ldrb	r2, [fp, #1360]	@ zero_extendqisi2
1767:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9746              		.loc 1 1767 0
 9747 5498 0300A0E1 		mov	r0, r3
 9748              	.LVL1111:
1764:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9749              		.loc 1 1764 0
 9750 549c 0030A0E3 		mov	r3, #0
 9751              	.LVL1112:
1767:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9752              		.loc 1 1767 0
 9753 54a0 A8131FE5 		ldr	r1, .L906+96
1762:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 9754              		.loc 1 1762 0
 9755 54a4 28C0C8E5 		strb	ip, [r8, #40]
1763:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9756              		.loc 1 1763 0
 9757 54a8 2920C8E5 		strb	r2, [r8, #41]
1764:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9758              		.loc 1 1764 0
 9759 54ac 2A30C8E5 		strb	r3, [r8, #42]
1765:../uvc.c      **** 		 	 }
 9760              		.loc 1 1765 0
 9761 54b0 2B30C8E5 		strb	r3, [r8, #43]
 9762 54b4 6FFFFFEA 		b	.L861
 9763              	.LVL1113:
 9764              	.L665:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9765              		.loc 1 1372 0
 9766 54b8 0020A0E3 		mov	r2, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9767              		.loc 1 1373 0
 9768 54bc 0200A0E3 		mov	r0, #2
 9769 54c0 C8131FE5 		ldr	r1, .L906+96
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9770              		.loc 1 1371 0
 9771 54c4 2830C8E5 		strb	r3, [r8, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9772              		.loc 1 1372 0
 9773 54c8 2920C8E5 		strb	r2, [r8, #41]
1374:../uvc.c      **** 			  break;
 9774              		.loc 1 1374 0
 9775 54cc 24208DE5 		str	r2, [sp, #36]
 9776 54d0 0040A0E3 		mov	r4, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9777              		.loc 1 1373 0
 9778 54d4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9779              	.LVL1114:
1374:../uvc.c      **** 			  break;
 9780              		.loc 1 1374 0
 9781 54d8 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 9782              	.LVL1115:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9783              		.loc 1 1355 0
 9784 54dc FF30A0E3 		mov	r3, #255
 9785 54e0 24C09DE5 		ldr	ip, [sp, #36]
 9786 54e4 88FEFFEA 		b	.L669
 9787              	.LVL1116:
 9788              	.L677:
 9789              	.LBE175:
 9790              	.LBE245:
 9791              	.LBB246:
 9792              	.LBB185:
1734:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9793              		.loc 1 1734 0
 9794 54e8 DCE31FE5 		ldr	lr, .L906+116
1733:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 9795              		.loc 1 1733 0
 9796 54ec 020053E3 		cmp	r3, #2
1734:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9797              		.loc 1 1734 0
 9798 54f0 75C5DEE5 		ldrb	ip, [lr, #1397]	@ zero_extendqisi2
 9799              	.LVL1117:
1745:../uvc.c      **** 				  if(Len == 2){
 9800              		.loc 1 1745 0
 9801 54f4 0300A0E1 		mov	r0, r3
1735:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9802              		.loc 1 1735 0
 9803 54f8 7625DEE5 		ldrb	r2, [lr, #1398]	@ zero_extendqisi2
1733:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 9804              		.loc 1 1733 0
 9805 54fc 34FCFF1A 		bne	.L689
 9806              	.LVL1118:
 9807 5500 E2FEFFEA 		b	.L862
 9808              	.LVL1119:
 9809              	.L734:
 9810              	.LBE185:
 9811              	.LBE246:
 9812              	.LBB247:
 9813              	.LBB221:
1734:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9814              		.loc 1 1734 0
 9815 5504 F8E31FE5 		ldr	lr, .L906+116
1733:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 9816              		.loc 1 1733 0
 9817 5508 020053E3 		cmp	r3, #2
1734:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9818              		.loc 1 1734 0
 9819 550c 71C7DEE5 		ldrb	ip, [lr, #1905]	@ zero_extendqisi2
 9820              	.LVL1120:
1745:../uvc.c      **** 				  if(Len == 2){
 9821              		.loc 1 1745 0
 9822 5510 0300A0E1 		mov	r0, r3
 9823              	.LVL1121:
1735:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9824              		.loc 1 1735 0
 9825 5514 7227DEE5 		ldrb	r2, [lr, #1906]	@ zero_extendqisi2
1733:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 9826              		.loc 1 1733 0
 9827 5518 BDFCFF1A 		bne	.L746
 9828              	.LVL1122:
 9829 551c D1FEFFEA 		b	.L873
 9830              	.LVL1123:
 9831              	.L710:
 9832              	.LBE221:
 9833              	.LBE247:
 9834              	.LBB248:
 9835              	.LBB196:
1734:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9836              		.loc 1 1734 0
 9837 5520 14E41FE5 		ldr	lr, .L906+116
1733:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 9838              		.loc 1 1733 0
 9839 5524 020053E3 		cmp	r3, #2
1734:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9840              		.loc 1 1734 0
 9841 5528 5DC7DEE5 		ldrb	ip, [lr, #1885]	@ zero_extendqisi2
1745:../uvc.c      **** 				  if(Len == 2){
 9842              		.loc 1 1745 0
 9843 552c 0300A0E1 		mov	r0, r3
1735:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9844              		.loc 1 1735 0
 9845 5530 5E27DEE5 		ldrb	r2, [lr, #1886]	@ zero_extendqisi2
1733:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 9846              		.loc 1 1733 0
 9847 5534 61FCFF1A 		bne	.L724
 9848              	.LVL1124:
 9849              	.L864:
1745:../uvc.c      **** 				  if(Len == 2){
 9850              		.loc 1 1745 0
 9851 5538 40141FE5 		ldr	r1, .L906+96
1734:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9852              		.loc 1 1734 0
 9853 553c 28C0C8E5 		strb	ip, [r8, #40]
1735:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9854              		.loc 1 1735 0
 9855 5540 2920C8E5 		strb	r2, [r8, #41]
 9856 5544 14FFFFEA 		b	.L865
 9857              	.LVL1125:
 9858              	.L660:
 9859              	.LBE196:
 9860              	.LBE248:
 9861              	.LBB249:
 9862              	.LBB176:
1734:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9863              		.loc 1 1734 0
 9864 5548 3CE41FE5 		ldr	lr, .L906+116
1733:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 9865              		.loc 1 1733 0
 9866 554c 020053E3 		cmp	r3, #2
1734:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9867              		.loc 1 1734 0
 9868 5550 4DC5DEE5 		ldrb	ip, [lr, #1357]	@ zero_extendqisi2
 9869              	.LVL1126:
1745:../uvc.c      **** 				  if(Len == 2){
 9870              		.loc 1 1745 0
 9871 5554 0300A0E1 		mov	r0, r3
 9872              	.LVL1127:
1735:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9873              		.loc 1 1735 0
 9874 5558 4E25DEE5 		ldrb	r2, [lr, #1358]	@ zero_extendqisi2
1733:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 9875              		.loc 1 1733 0
 9876 555c 45FBFF1A 		bne	.L672
 9877              	.LVL1128:
 9878 5560 B7FEFFEA 		b	.L859
 9879              	.LVL1129:
 9880              	.L739:
 9881              	.LBE176:
 9882              	.LBE249:
 9883              	.LBB250:
 9884              	.LBB222:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9885              		.loc 1 1372 0
 9886 5564 0020A0E3 		mov	r2, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9887              		.loc 1 1373 0
 9888 5568 0200A0E3 		mov	r0, #2
 9889 556c 74141FE5 		ldr	r1, .L906+96
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9890              		.loc 1 1371 0
 9891 5570 2830C8E5 		strb	r3, [r8, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9892              		.loc 1 1372 0
 9893 5574 2920C8E5 		strb	r2, [r8, #41]
1374:../uvc.c      **** 			  break;
 9894              		.loc 1 1374 0
 9895 5578 24208DE5 		str	r2, [sp, #36]
 9896 557c 0050A0E3 		mov	r5, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9897              		.loc 1 1373 0
 9898 5580 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9899              	.LVL1130:
1374:../uvc.c      **** 			  break;
 9900              		.loc 1 1374 0
 9901 5584 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 9902              	.LVL1131:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9903              		.loc 1 1355 0
 9904 5588 FF30A0E3 		mov	r3, #255
 9905 558c 24C09DE5 		ldr	ip, [sp, #36]
 9906 5590 1FFEFFEA 		b	.L743
 9907              	.LVL1132:
 9908              	.L641:
 9909              	.LBE222:
 9910              	.LBE250:
 9911              	.LBB251:
 9912              	.LBB209:
1733:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 9913              		.loc 1 1733 0
 9914 5594 02005CE3 		cmp	ip, #2
 9915 5598 A000000A 		beq	.L901
1738:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9916              		.loc 1 1738 0
 9917 559c 90041FE5 		ldr	r0, .L906+116
 9918 55a0 A1E5D0E5 		ldrb	lr, [r0, #1441]	@ zero_extendqisi2
1740:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 9919              		.loc 1 1740 0
 9920 55a4 A225D0E5 		ldrb	r2, [r0, #1442]	@ zero_extendqisi2
 9921 55a8 6DFCFFEA 		b	.L856
 9922              	.LVL1133:
 9923              	.L740:
 9924              	.LBE209:
 9925              	.LBE251:
 9926              	.LBB252:
 9927              	.LBB223:
1762:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 9928              		.loc 1 1762 0
 9929 55ac 73C7DBE5 		ldrb	ip, [fp, #1907]	@ zero_extendqisi2
 9930              	.LVL1134:
1763:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9931              		.loc 1 1763 0
 9932 55b0 7427DBE5 		ldrb	r2, [fp, #1908]	@ zero_extendqisi2
1767:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9933              		.loc 1 1767 0
 9934 55b4 0300A0E1 		mov	r0, r3
 9935              	.LVL1135:
 9936 55b8 C0141FE5 		ldr	r1, .L906+96
1764:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9937              		.loc 1 1764 0
 9938 55bc 0030A0E3 		mov	r3, #0
 9939              	.LVL1136:
1762:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 9940              		.loc 1 1762 0
 9941 55c0 28C0C8E5 		strb	ip, [r8, #40]
1763:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9942              		.loc 1 1763 0
 9943 55c4 2920C8E5 		strb	r2, [r8, #41]
 9944 55c8 E0FEFFEA 		b	.L869
 9945              	.LVL1137:
 9946              	.L647:
 9947              	.LBE223:
 9948              	.LBE252:
 9949              	.LBB253:
 9950              	.LBB210:
1762:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 9951              		.loc 1 1762 0
 9952 55cc C0041FE5 		ldr	r0, .L906+116
1764:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9953              		.loc 1 1764 0
 9954 55d0 0030A0E3 		mov	r3, #0
1762:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 9955              		.loc 1 1762 0
 9956 55d4 A3E5D0E5 		ldrb	lr, [r0, #1443]	@ zero_extendqisi2
1763:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9957              		.loc 1 1763 0
 9958 55d8 A425D0E5 		ldrb	r2, [r0, #1444]	@ zero_extendqisi2
1767:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9959              		.loc 1 1767 0
 9960 55dc E4141FE5 		ldr	r1, .L906+96
 9961 55e0 0C00A0E1 		mov	r0, ip
1762:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 9962              		.loc 1 1762 0
 9963 55e4 28E0C8E5 		strb	lr, [r8, #40]
1763:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9964              		.loc 1 1763 0
 9965 55e8 2920C8E5 		strb	r2, [r8, #41]
1764:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9966              		.loc 1 1764 0
 9967 55ec 2A30C8E5 		strb	r3, [r8, #42]
1765:../uvc.c      **** 		 	 }
 9968              		.loc 1 1765 0
 9969 55f0 2B30C8E5 		strb	r3, [r8, #43]
 9970 55f4 F8FEFFEA 		b	.L858
 9971              	.L646:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9972              		.loc 1 1372 0
 9973 55f8 0030A0E3 		mov	r3, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9974              		.loc 1 1373 0
 9975 55fc 0200A0E3 		mov	r0, #2
 9976 5600 08151FE5 		ldr	r1, .L906+96
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9977              		.loc 1 1371 0
 9978 5604 28C0C8E5 		strb	ip, [r8, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9979              		.loc 1 1372 0
 9980 5608 2930C8E5 		strb	r3, [r8, #41]
1374:../uvc.c      **** 			  break;
 9981              		.loc 1 1374 0
 9982 560c 28308DE5 		str	r3, [sp, #40]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9983              		.loc 1 1355 0
 9984 5610 FF40A0E3 		mov	r4, #255
 9985              	.LVL1138:
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9986              		.loc 1 1373 0
 9987 5614 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9988              	.LVL1139:
1374:../uvc.c      **** 			  break;
 9989              		.loc 1 1374 0
 9990 5618 00C0A0E3 		mov	ip, #0
 9991 561c 2850D8E5 		ldrb	r5, [r8, #40]	@ zero_extendqisi2
 9992              	.LVL1140:
 9993 5620 28E09DE5 		ldr	lr, [sp, #40]
 9994 5624 AFFDFFEA 		b	.L650
 9995              	.LVL1141:
 9996              	.L662:
 9997              	.LBE210:
 9998              	.LBE253:
 9999              	.LBB254:
 10000              	.LBB177:
1539:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 10001              		.loc 1 1539 0
 10002 5628 0C00A0E1 		mov	r0, ip
 10003 562c 28109DE5 		ldr	r1, [sp, #40]
 10004 5630 20308DE5 		str	r3, [sp, #32]
 10005 5634 FEFFFFEB 		bl	SensorGetControl
 10006              	.LVL1142:
1676:../uvc.c      **** 
 10007              		.loc 1 1676 0
 10008 5638 20309DE5 		ldr	r3, [sp, #32]
1540:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 10009              		.loc 1 1540 0
 10010 563c 30E51FE5 		ldr	lr, .L906+116
1552:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 10011              		.loc 1 1552 0
 10012 5640 0020A0E3 		mov	r2, #0
1676:../uvc.c      **** 
 10013              		.loc 1 1676 0
 10014 5644 4C151FE5 		ldr	r1, .L906+96
1552:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 10015              		.loc 1 1552 0
 10016 5648 2920C8E5 		strb	r2, [r8, #41]
1539:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 10017              		.loc 1 1539 0
 10018 564c 0040A0E1 		mov	r4, r0
 10019              	.LVL1143:
1676:../uvc.c      **** 
 10020              		.loc 1 1676 0
 10021 5650 0300A0E1 		mov	r0, r3
 10022              	.LVL1144:
1540:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 10023              		.loc 1 1540 0
 10024 5654 5545CEE5 		strb	r4, [lr, #1365]
 10025              	.LVL1145:
1551:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 10026              		.loc 1 1551 0
 10027 5658 2840C8E5 		strb	r4, [r8, #40]
1676:../uvc.c      **** 
 10028              		.loc 1 1676 0
 10029 565c 20308DE5 		str	r3, [sp, #32]
 10030 5660 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10031              	.LVL1146:
1679:../uvc.c      **** //#endif
 10032              		.loc 1 1679 0
 10033 5664 29C0D8E5 		ldrb	ip, [r8, #41]	@ zero_extendqisi2
 10034 5668 2B00D8E5 		ldrb	r0, [r8, #43]	@ zero_extendqisi2
 10035 566c 2C10D8E5 		ldrb	r1, [r8, #44]	@ zero_extendqisi2
 10036 5670 20309DE5 		ldr	r3, [sp, #32]
 10037 5674 03008DE8 		stmia	sp, {r0, r1}
 10038 5678 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 10039 567c 08308DE5 		str	r3, [sp, #8]
 10040 5680 0400A0E3 		mov	r0, #4
 10041 5684 0C30A0E1 		mov	r3, ip
 10042 5688 8C151FE5 		ldr	r1, .L906+100
 10043 568c FEFFFFEB 		bl	CyU3PDebugPrint
 10044              	.LVL1147:
 10045 5690 00C0A0E3 		mov	ip, #0
 10046 5694 24C08DE5 		str	ip, [sp, #36]
 10047 5698 0420A0E1 		mov	r2, r4
 10048 569c FF30A0E3 		mov	r3, #255
 10049 56a0 19FEFFEA 		b	.L669
 10050              	.LVL1148:
 10051              	.L659:
2276:../uvc.c      **** 			  break;
 10052              		.loc 1 2276 0
 10053 56a4 0000A0E3 		mov	r0, #0
 10054 56a8 0020A0E1 		mov	r2, r0
 10055 56ac 0110A0E3 		mov	r1, #1
 10056 56b0 FEFFFFEB 		bl	CyU3PUsbStall
 10057              	.LVL1149:
 10058              	.L860:
 10059 56b4 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10060              		.loc 1 1355 0
 10061 56b8 FF30A0E3 		mov	r3, #255
 10062 56bc 0320A0E1 		mov	r2, r3
2276:../uvc.c      **** 			  break;
 10063              		.loc 1 2276 0
 10064 56c0 24C08DE5 		str	ip, [sp, #36]
 10065 56c4 0C40A0E1 		mov	r4, ip
 10066 56c8 0FFEFFEA 		b	.L669
 10067              	.LVL1150:
 10068              	.L715:
 10069              	.LBE177:
 10070              	.LBE254:
 10071              	.LBB255:
 10072              	.LBB197:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10073              		.loc 1 1372 0
 10074 56cc 0020A0E3 		mov	r2, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10075              		.loc 1 1373 0
 10076 56d0 D8151FE5 		ldr	r1, .L906+96
 10077 56d4 0200A0E3 		mov	r0, #2
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10078              		.loc 1 1371 0
 10079 56d8 2830C8E5 		strb	r3, [r8, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10080              		.loc 1 1372 0
 10081 56dc 2920C8E5 		strb	r2, [r8, #41]
1374:../uvc.c      **** 			  break;
 10082              		.loc 1 1374 0
 10083 56e0 24208DE5 		str	r2, [sp, #36]
 10084 56e4 0040A0E3 		mov	r4, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10085              		.loc 1 1373 0
 10086 56e8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10087              	.LVL1151:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10088              		.loc 1 1355 0
 10089 56ec FF50A0E3 		mov	r5, #255
 10090              	.LVL1152:
1374:../uvc.c      **** 			  break;
 10091              		.loc 1 1374 0
 10092 56f0 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 10093              	.LVL1153:
 10094 56f4 24109DE5 		ldr	r1, [sp, #36]
 10095 56f8 04FDFFEA 		b	.L719
 10096              	.LVL1154:
 10097              	.L716:
1762:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10098              		.loc 1 1762 0
 10099 56fc F0E51FE5 		ldr	lr, .L906+116
1767:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10100              		.loc 1 1767 0
 10101 5700 0300A0E1 		mov	r0, r3
1762:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10102              		.loc 1 1762 0
 10103 5704 5FC7DEE5 		ldrb	ip, [lr, #1887]	@ zero_extendqisi2
1763:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 10104              		.loc 1 1763 0
 10105 5708 6027DEE5 		ldrb	r2, [lr, #1888]	@ zero_extendqisi2
1764:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 10106              		.loc 1 1764 0
 10107 570c 0030A0E3 		mov	r3, #0
 10108              	.LVL1155:
1767:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10109              		.loc 1 1767 0
 10110 5710 18161FE5 		ldr	r1, .L906+96
1762:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10111              		.loc 1 1762 0
 10112 5714 28C0C8E5 		strb	ip, [r8, #40]
1763:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 10113              		.loc 1 1763 0
 10114 5718 2920C8E5 		strb	r2, [r8, #41]
1764:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 10115              		.loc 1 1764 0
 10116 571c 2A30C8E5 		strb	r3, [r8, #42]
1765:../uvc.c      **** 		 	 }
 10117              		.loc 1 1765 0
 10118 5720 2B30C8E5 		strb	r3, [r8, #43]
 10119 5724 9CFEFFEA 		b	.L865
 10120              	.LVL1156:
 10121              	.L712:
1652:../uvc.c      **** 			 	 			 {
 10122              		.loc 1 1652 0
 10123 5728 020053E3 		cmp	r3, #2
 10124 572c 5D02000A 		beq	.L902
1660:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 10125              		.loc 1 1660 0
 10126 5730 040053E3 		cmp	r3, #4
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10127              		.loc 1 1355 0
 10128 5734 FF50A013 		movne	r5, #255
 10129              	.LVL1157:
 10130 5738 05C0A011 		movne	ip, r5
1660:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 10131              		.loc 1 1660 0
 10132 573c 9200000A 		beq	.L903
 10133              	.LVL1158:
 10134              	.L721:
1676:../uvc.c      **** 
 10135              		.loc 1 1676 0
 10136 5740 0300A0E1 		mov	r0, r3
 10137 5744 4C161FE5 		ldr	r1, .L906+96
 10138 5748 1CC08DE5 		str	ip, [sp, #28]
 10139 574c 20308DE5 		str	r3, [sp, #32]
 10140 5750 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10141              	.LVL1159:
1679:../uvc.c      **** //#endif
 10142              		.loc 1 1679 0
 10143 5754 2B00D8E5 		ldrb	r0, [r8, #43]	@ zero_extendqisi2
 10144 5758 2C10D8E5 		ldrb	r1, [r8, #44]	@ zero_extendqisi2
 10145 575c 20309DE5 		ldr	r3, [sp, #32]
 10146 5760 29E0D8E5 		ldrb	lr, [r8, #41]	@ zero_extendqisi2
 10147 5764 03008DE8 		stmia	sp, {r0, r1}
 10148 5768 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 10149 576c 08308DE5 		str	r3, [sp, #8]
 10150 5770 74161FE5 		ldr	r1, .L906+100
 10151 5774 0E30A0E1 		mov	r3, lr
 10152 5778 0400A0E3 		mov	r0, #4
 10153 577c FEFFFFEB 		bl	CyU3PDebugPrint
 10154              	.LVL1160:
 10155 5780 0000A0E3 		mov	r0, #0
 10156 5784 24008DE5 		str	r0, [sp, #36]
 10157 5788 0040A0E1 		mov	r4, r0
 10158 578c 1CC09DE5 		ldr	ip, [sp, #28]
 10159 5790 0010A0E1 		mov	r1, r0
 10160 5794 DDFCFFEA 		b	.L719
 10161              	.LVL1161:
 10162              	.L676:
 10163              	.LBE197:
 10164              	.LBE255:
 10165              	.LBB256:
 10166              	.LBB186:
2276:../uvc.c      **** 			  break;
 10167              		.loc 1 2276 0
 10168 5798 0000A0E3 		mov	r0, #0
 10169 579c 0110A0E3 		mov	r1, #1
 10170 57a0 0020A0E1 		mov	r2, r0
 10171 57a4 FEFFFFEB 		bl	CyU3PUsbStall
 10172              	.LVL1162:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10173              		.loc 1 1355 0
 10174 57a8 FF40A0E3 		mov	r4, #255
 10175              	.LVL1163:
2276:../uvc.c      **** 			  break;
 10176              		.loc 1 2276 0
 10177 57ac 0000A0E3 		mov	r0, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10178              		.loc 1 1355 0
 10179 57b0 04C0A0E1 		mov	ip, r4
2276:../uvc.c      **** 			  break;
 10180              		.loc 1 2276 0
 10181 57b4 28008DE5 		str	r0, [sp, #40]
 10182 57b8 0050A0E1 		mov	r5, r0
 10183 57bc 0010A0E1 		mov	r1, r0
 10184 57c0 09FDFFEA 		b	.L686
 10185              	.LVL1164:
 10186              	.L682:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10187              		.loc 1 1372 0
 10188 57c4 0020A0E3 		mov	r2, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10189              		.loc 1 1373 0
 10190 57c8 D0161FE5 		ldr	r1, .L906+96
 10191 57cc 0200A0E3 		mov	r0, #2
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10192              		.loc 1 1371 0
 10193 57d0 2830C8E5 		strb	r3, [r8, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10194              		.loc 1 1372 0
 10195 57d4 2920C8E5 		strb	r2, [r8, #41]
1374:../uvc.c      **** 			  break;
 10196              		.loc 1 1374 0
 10197 57d8 28208DE5 		str	r2, [sp, #40]
 10198 57dc 0050A0E3 		mov	r5, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10199              		.loc 1 1373 0
 10200 57e0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10201              	.LVL1165:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10202              		.loc 1 1355 0
 10203 57e4 FF40A0E3 		mov	r4, #255
 10204              	.LVL1166:
1374:../uvc.c      **** 			  break;
 10205              		.loc 1 1374 0
 10206 57e8 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 10207              	.LVL1167:
 10208 57ec 28109DE5 		ldr	r1, [sp, #40]
 10209 57f0 FDFCFFEA 		b	.L686
 10210              	.LVL1168:
 10211              	.L709:
 10212              	.LBE186:
 10213              	.LBE256:
 10214              	.LBB257:
 10215              	.LBB198:
2276:../uvc.c      **** 			  break;
 10216              		.loc 1 2276 0
 10217 57f4 0000A0E3 		mov	r0, #0
 10218 57f8 0110A0E3 		mov	r1, #1
 10219 57fc 0020A0E1 		mov	r2, r0
 10220 5800 FEFFFFEB 		bl	CyU3PUsbStall
 10221              	.LVL1169:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10222              		.loc 1 1355 0
 10223 5804 FF50A0E3 		mov	r5, #255
 10224              	.LVL1170:
2276:../uvc.c      **** 			  break;
 10225              		.loc 1 2276 0
 10226 5808 0000A0E3 		mov	r0, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10227              		.loc 1 1355 0
 10228 580c 05C0A0E1 		mov	ip, r5
2276:../uvc.c      **** 			  break;
 10229              		.loc 1 2276 0
 10230 5810 24008DE5 		str	r0, [sp, #36]
 10231 5814 0040A0E1 		mov	r4, r0
 10232 5818 0010A0E1 		mov	r1, r0
 10233 581c BBFCFFEA 		b	.L719
 10234              	.LVL1171:
 10235              	.L901:
 10236              	.LBE198:
 10237              	.LBE257:
 10238              	.LBB258:
 10239              	.LBB211:
1734:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10240              		.loc 1 1734 0
 10241 5820 14E71FE5 		ldr	lr, .L906+116
 10242 5824 A125DEE5 		ldrb	r2, [lr, #1441]	@ zero_extendqisi2
1735:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 10243              		.loc 1 1735 0
 10244 5828 A235DEE5 		ldrb	r3, [lr, #1442]	@ zero_extendqisi2
 10245              	.L857:
1745:../uvc.c      **** 				  if(Len == 2){
 10246              		.loc 1 1745 0
 10247 582c 0C00A0E1 		mov	r0, ip
 10248              	.L854:
 10249 5830 38171FE5 		ldr	r1, .L906+96
1734:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10250              		.loc 1 1734 0
 10251 5834 2820C8E5 		strb	r2, [r8, #40]
1735:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 10252              		.loc 1 1735 0
 10253 5838 2930C8E5 		strb	r3, [r8, #41]
 10254 583c 66FEFFEA 		b	.L858
 10255              	.LVL1172:
 10256              	.L788:
 10257              	.LBE211:
 10258              	.LBE258:
 10259              	.LBE276:
 10260              	.LBE293:
 10261              	.LBB294:
 10262              	.LBB164:
 10263              	.LBB154:
 10264              	.LBB148:
1720:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10265              		.loc 1 1720 0
 10266 5840 020053E3 		cmp	r3, #2
1726:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 10267              		.loc 1 1726 0
 10268 5844 85C7DB15 		ldrneb	ip, [fp, #1925]	@ zero_extendqisi2
1745:../uvc.c      **** 				  if(Len == 2){
 10269              		.loc 1 1745 0
 10270 5848 0300A011 		movne	r0, r3
1728:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10271              		.loc 1 1728 0
 10272 584c 8627DB15 		ldrneb	r2, [fp, #1926]	@ zero_extendqisi2
1720:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10273              		.loc 1 1720 0
 10274 5850 6BFCFF1A 		bne	.L802
1721:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10275              		.loc 1 1721 0
 10276 5854 8527DBE5 		ldrb	r2, [fp, #1925]	@ zero_extendqisi2
1722:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10277              		.loc 1 1722 0
 10278 5858 8637DBE5 		ldrb	r3, [fp, #1926]	@ zero_extendqisi2
 10279              	.LVL1173:
1745:../uvc.c      **** 				  if(Len == 2){
 10280              		.loc 1 1745 0
 10281 585c 0200A0E3 		mov	r0, #2
 10282 5860 68171FE5 		ldr	r1, .L906+96
1721:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10283              		.loc 1 1721 0
 10284 5864 2820C8E5 		strb	r2, [r8, #40]
1722:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10285              		.loc 1 1722 0
 10286 5868 2930C8E5 		strb	r3, [r8, #41]
 10287 586c 350000EA 		b	.L870
 10288              	.LVL1174:
 10289              	.L787:
2276:../uvc.c      **** 			  break;
 10290              		.loc 1 2276 0
 10291 5870 0000A0E3 		mov	r0, #0
 10292 5874 0020A0E1 		mov	r2, r0
 10293 5878 0110A0E3 		mov	r1, #1
 10294 587c FEFFFFEB 		bl	CyU3PUsbStall
 10295              	.LVL1175:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10296              		.loc 1 1355 0
 10297 5880 FF50A0E3 		mov	r5, #255
 10298              	.LVL1176:
2276:../uvc.c      **** 			  break;
 10299              		.loc 1 2276 0
 10300 5884 0000A0E3 		mov	r0, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10301              		.loc 1 1355 0
 10302 5888 05C0A0E1 		mov	ip, r5
2276:../uvc.c      **** 			  break;
 10303              		.loc 1 2276 0
 10304 588c 24008DE5 		str	r0, [sp, #36]
 10305 5890 0040A0E1 		mov	r4, r0
 10306 5894 89FEFFEA 		b	.L797
 10307              	.LVL1177:
 10308              	.L791:
1684:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 10309              		.loc 1 1684 0
 10310 5898 020053E3 		cmp	r3, #2
1685:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 10311              		.loc 1 1685 0
 10312 589c 83C7DBE5 		ldrb	ip, [fp, #1923]	@ zero_extendqisi2
1709:../uvc.c      **** 		 	 if(Len == 2){
 10313              		.loc 1 1709 0
 10314 58a0 0300A0E1 		mov	r0, r3
1686:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10315              		.loc 1 1686 0
 10316 58a4 8427DBE5 		ldrb	r2, [fp, #1924]	@ zero_extendqisi2
1684:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 10317              		.loc 1 1684 0
 10318 58a8 55FCFF1A 		bne	.L802
 10319              	.LVL1178:
 10320              	.L874:
1818:../uvc.c      **** 		 	 if(Len == 2){
 10321              		.loc 1 1818 0
 10322 58ac B4171FE5 		ldr	r1, .L906+96
1794:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 10323              		.loc 1 1794 0
 10324 58b0 28C0C8E5 		strb	ip, [r8, #40]
1795:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 10325              		.loc 1 1795 0
 10326 58b4 2920C8E5 		strb	r2, [r8, #41]
 10327 58b8 220000EA 		b	.L870
 10328              	.LVL1179:
 10329              	.L790:
1497:../uvc.c      **** 			 	 			 {
 10330              		.loc 1 1497 0
 10331 58bc 020053E3 		cmp	r3, #2
 10332 58c0 EC01000A 		beq	.L904
1505:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 10333              		.loc 1 1505 0
 10334 58c4 040053E3 		cmp	r3, #4
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10335              		.loc 1 1355 0
 10336 58c8 FF50A013 		movne	r5, #255
 10337              	.LVL1180:
 10338 58cc 05C0A011 		movne	ip, r5
1505:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 10339              		.loc 1 1505 0
 10340 58d0 C801000A 		beq	.L905
 10341              	.LVL1181:
 10342              	.L799:
1676:../uvc.c      **** 
 10343              		.loc 1 1676 0
 10344 58d4 0300A0E1 		mov	r0, r3
 10345 58d8 E0171FE5 		ldr	r1, .L906+96
 10346 58dc 1CC08DE5 		str	ip, [sp, #28]
 10347 58e0 20308DE5 		str	r3, [sp, #32]
 10348 58e4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10349              	.LVL1182:
1679:../uvc.c      **** //#endif
 10350              		.loc 1 1679 0
 10351 58e8 29E0D8E5 		ldrb	lr, [r8, #41]	@ zero_extendqisi2
 10352 58ec 2B00D8E5 		ldrb	r0, [r8, #43]	@ zero_extendqisi2
 10353 58f0 2C10D8E5 		ldrb	r1, [r8, #44]	@ zero_extendqisi2
 10354 58f4 20309DE5 		ldr	r3, [sp, #32]
 10355 58f8 03008DE8 		stmia	sp, {r0, r1}
 10356 58fc 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 10357 5900 08308DE5 		str	r3, [sp, #8]
 10358 5904 0400A0E3 		mov	r0, #4
 10359 5908 0E30A0E1 		mov	r3, lr
 10360 590c 10181FE5 		ldr	r1, .L906+100
 10361 5910 FEFFFFEB 		bl	CyU3PDebugPrint
 10362              	.LVL1183:
 10363 5914 00E0A0E3 		mov	lr, #0
 10364 5918 24E08DE5 		str	lr, [sp, #36]
 10365 591c 0E40A0E1 		mov	r4, lr
 10366 5920 1CC09DE5 		ldr	ip, [sp, #28]
 10367 5924 65FEFFEA 		b	.L797
 10368              	.LVL1184:
 10369              	.L795:
1774:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 10370              		.loc 1 1774 0
 10371 5928 8927DBE5 		ldrb	r2, [fp, #1929]	@ zero_extendqisi2
1786:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 10372              		.loc 1 1786 0
 10373 592c 34181FE5 		ldr	r1, .L906+96
1775:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10374              		.loc 1 1775 0
 10375 5930 0030A0E3 		mov	r3, #0
 10376              	.LVL1185:
1786:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 10377              		.loc 1 1786 0
 10378 5934 0100A0E3 		mov	r0, #1
1774:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 10379              		.loc 1 1774 0
 10380 5938 2820C8E5 		strb	r2, [r8, #40]
1775:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10381              		.loc 1 1775 0
 10382 593c 2930C8E5 		strb	r3, [r8, #41]
1776:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 10383              		.loc 1 1776 0
 10384 5940 2A30C8E5 		strb	r3, [r8, #42]
1777:../uvc.c      **** 		 	 }
 10385              		.loc 1 1777 0
 10386 5944 2B30C8E5 		strb	r3, [r8, #43]
 10387              	.LVL1186:
 10388              	.L870:
1748:../uvc.c      **** 				  }else{
 10389              		.loc 1 1748 0
 10390 5948 00C0A0E3 		mov	ip, #0
 10391 594c 24C08DE5 		str	ip, [sp, #36]
 10392 5950 0040A0E3 		mov	r4, #0
1745:../uvc.c      **** 				  if(Len == 2){
 10393              		.loc 1 1745 0
 10394 5954 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10395              	.LVL1187:
1747:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 10396              		.loc 1 1747 0
 10397 5958 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 10398              	.LVL1188:
1748:../uvc.c      **** 				  }else{
 10399              		.loc 1 1748 0
 10400 595c 2950D8E5 		ldrb	r5, [r8, #41]	@ zero_extendqisi2
 10401              	.LVL1189:
 10402 5960 56FEFFEA 		b	.L797
 10403              	.LVL1190:
 10404              	.L794:
1756:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10405              		.loc 1 1756 0
 10406 5964 87C7DBE5 		ldrb	ip, [fp, #1927]	@ zero_extendqisi2
1757:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10407              		.loc 1 1757 0
 10408 5968 8827DBE5 		ldrb	r2, [fp, #1928]	@ zero_extendqisi2
1767:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10409              		.loc 1 1767 0
 10410 596c 0300A0E1 		mov	r0, r3
1758:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 10411              		.loc 1 1758 0
 10412 5970 0030A0E3 		mov	r3, #0
 10413              	.LVL1191:
1767:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10414              		.loc 1 1767 0
 10415 5974 7C181FE5 		ldr	r1, .L906+96
1756:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10416              		.loc 1 1756 0
 10417 5978 28C0C8E5 		strb	ip, [r8, #40]
1757:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10418              		.loc 1 1757 0
 10419 597c 2920C8E5 		strb	r2, [r8, #41]
1758:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 10420              		.loc 1 1758 0
 10421 5980 2A30C8E5 		strb	r3, [r8, #42]
1759:../uvc.c      **** 		 	 }
 10422              		.loc 1 1759 0
 10423 5984 2B30C8E5 		strb	r3, [r8, #43]
 10424 5988 EEFFFFEA 		b	.L870
 10425              	.LVL1192:
 10426              	.L903:
 10427              	.LBE148:
 10428              	.LBE154:
 10429              	.LBE164:
 10430              	.LBE294:
 10431              	.LBB295:
 10432              	.LBB277:
 10433              	.LBB259:
 10434              	.LBB199:
1661:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 10435              		.loc 1 1661 0
 10436 598c 0500A0E1 		mov	r0, r5
 10437 5990 2C109DE5 		ldr	r1, [sp, #44]
 10438 5994 20308DE5 		str	r3, [sp, #32]
 10439 5998 FEFFFFEB 		bl	SensorGetControl
 10440              	.LVL1193:
1662:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 10441              		.loc 1 1662 0
 10442 599c 90C81FE5 		ldr	ip, .L906+116
1663:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 10443              		.loc 1 1663 0
 10444 59a0 2C109DE5 		ldr	r1, [sp, #44]
1661:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 10445              		.loc 1 1661 0
 10446 59a4 0020A0E1 		mov	r2, r0
1663:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 10447              		.loc 1 1663 0
 10448 59a8 30009DE5 		ldr	r0, [sp, #48]
1662:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 10449              		.loc 1 1662 0
 10450 59ac 6527CCE5 		strb	r2, [ip, #1893]
1661:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 10451              		.loc 1 1661 0
 10452 59b0 2820C8E5 		strb	r2, [r8, #40]
1663:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 10453              		.loc 1 1663 0
 10454 59b4 FEFFFFEB 		bl	SensorGetControl
 10455              	.LVL1194:
1664:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 10456              		.loc 1 1664 0
 10457 59b8 ACE81FE5 		ldr	lr, .L906+116
1665:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 10458              		.loc 1 1665 0
 10459 59bc 0020A0E3 		mov	r2, #0
 10460 59c0 2920C8E5 		strb	r2, [r8, #41]
1666:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 10461              		.loc 1 1666 0
 10462 59c4 2B20C8E5 		strb	r2, [r8, #43]
1667:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 10463              		.loc 1 1667 0
 10464 59c8 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 10465              	.LVL1195:
1664:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 10466              		.loc 1 1664 0
 10467 59cc 6607CEE5 		strb	r0, [lr, #1894]
1663:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 10468              		.loc 1 1663 0
 10469 59d0 0050A0E1 		mov	r5, r0
 10470              	.LVL1196:
 10471 59d4 2A00C8E5 		strb	r0, [r8, #42]
 10472 59d8 20309DE5 		ldr	r3, [sp, #32]
 10473 59dc 57FFFFEA 		b	.L721
 10474              	.LVL1197:
 10475              	.L900:
 10476              	.LBE199:
 10477              	.LBE259:
 10478              	.LBB260:
 10479              	.LBB212:
1661:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 10480              		.loc 1 1661 0
 10481 59e0 0510A0E1 		mov	r1, r5
 10482 59e4 0400A0E1 		mov	r0, r4
 10483 59e8 1CC08DE5 		str	ip, [sp, #28]
 10484 59ec FEFFFFEB 		bl	SensorGetControl
 10485              	.LVL1198:
1663:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 10486              		.loc 1 1663 0
 10487 59f0 0510A0E1 		mov	r1, r5
1661:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 10488              		.loc 1 1661 0
 10489 59f4 0030A0E1 		mov	r3, r0
1663:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 10490              		.loc 1 1663 0
 10491 59f8 2C009DE5 		ldr	r0, [sp, #44]
1661:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 10492              		.loc 1 1661 0
 10493 59fc 2830C8E5 		strb	r3, [r8, #40]
1662:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 10494              		.loc 1 1662 0
 10495 5a00 A935CBE5 		strb	r3, [fp, #1449]
1663:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 10496              		.loc 1 1663 0
 10497 5a04 FEFFFFEB 		bl	SensorGetControl
 10498              	.LVL1199:
1665:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 10499              		.loc 1 1665 0
 10500 5a08 0030A0E3 		mov	r3, #0
 10501 5a0c 2930C8E5 		strb	r3, [r8, #41]
1666:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 10502              		.loc 1 1666 0
 10503 5a10 2B30C8E5 		strb	r3, [r8, #43]
1667:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 10504              		.loc 1 1667 0
 10505 5a14 2850D8E5 		ldrb	r5, [r8, #40]	@ zero_extendqisi2
 10506              	.LVL1200:
1664:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 10507              		.loc 1 1664 0
 10508 5a18 AA05CBE5 		strb	r0, [fp, #1450]
1663:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 10509              		.loc 1 1663 0
 10510 5a1c 0040A0E1 		mov	r4, r0
 10511              	.LVL1201:
 10512 5a20 2A00C8E5 		strb	r0, [r8, #42]
 10513 5a24 1CC09DE5 		ldr	ip, [sp, #28]
 10514 5a28 73FEFFEA 		b	.L652
 10515              	.LVL1202:
 10516              	.L803:
 10517              	.LBE212:
 10518              	.LBE260:
 10519              	.LBE277:
 10520              	.LBE295:
 10521              	.LBB296:
 10522              	.LBB165:
 10523              	.LBB155:
 10524              	.LBB149:
2268:../uvc.c      **** 			   }
 10525              		.loc 1 2268 0
 10526 5a2c 34209DE5 		ldr	r2, [sp, #52]
 10527 5a30 0400A0E3 		mov	r0, #4
 10528              	.LVL1203:
 10529 5a34 34191FE5 		ldr	r1, .L906+104
 10530 5a38 FEFFFFEB 		bl	CyU3PDebugPrint
 10531              	.LVL1204:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10532              		.loc 1 1355 0
 10533 5a3c FF50A0E3 		mov	r5, #255
 10534              	.LVL1205:
2268:../uvc.c      **** 			   }
 10535              		.loc 1 2268 0
 10536 5a40 00E0A0E3 		mov	lr, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10537              		.loc 1 1355 0
 10538 5a44 05C0A0E1 		mov	ip, r5
2268:../uvc.c      **** 			   }
 10539              		.loc 1 2268 0
 10540 5a48 24E08DE5 		str	lr, [sp, #36]
 10541 5a4c 0E40A0E1 		mov	r4, lr
 10542 5a50 1AFEFFEA 		b	.L797
 10543              	.LVL1206:
 10544              	.L896:
 10545              	.LBE149:
 10546              	.LBE155:
 10547              	.LBE165:
 10548              	.LBE296:
 10549              	.LBB297:
 10550              	.LBB278:
 10551              	.LBB261:
 10552              	.LBB200:
1698:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 10553              		.loc 1 1698 0
 10554 5a54 48191FE5 		ldr	r1, .L906+116
1709:../uvc.c      **** 		 	 if(Len == 2){
 10555              		.loc 1 1709 0
 10556 5a58 0300A0E1 		mov	r0, r3
1698:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 10557              		.loc 1 1698 0
 10558 5a5c 5BC7D1E5 		ldrb	ip, [r1, #1883]	@ zero_extendqisi2
1699:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 10559              		.loc 1 1699 0
 10560 5a60 5C27D1E5 		ldrb	r2, [r1, #1884]	@ zero_extendqisi2
 10561 5a64 B3FEFFEA 		b	.L864
 10562              	.LVL1207:
 10563              	.L895:
 10564              	.LBE200:
 10565              	.LBE261:
 10566              	.LBB262:
 10567              	.LBB187:
2152:../uvc.c      **** 			                         {
 10568              		.loc 1 2152 0
 10569 5a68 7030D9E5 		ldrb	r3, [r9, #112]	@ zero_extendqisi2
 10570 5a6c 013043E2 		sub	r3, r3, #1
 10571 5a70 030053E3 		cmp	r3, #3
 10572 5a74 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 10573 5a78 56FCFFEA 		b	.L695
 10574              	.L697:
 10575 5a7c 905B0000 		.word	.L696
 10576 5a80 445B0000 		.word	.L698
 10577 5a84 E85A0000 		.word	.L699
 10578 5a88 8C5A0000 		.word	.L700
 10579              	.L700:
2170:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 10580              		.loc 1 2170 0
 10581 5a8c 6C2098E5 		ldr	r2, [r8, #108]
 10582 5a90 5230DBE5 		ldrb	r3, [fp, #82]	@ zero_extendqisi2
 10583 5a94 000052E3 		cmp	r2, #0
 10584 5a98 B020A003 		moveq	r2, #176
 10585 5a9c 3020A013 		movne	r2, #48
 10586 5aa0 032082E1 		orr	r2, r2, r3
 10587 5aa4 3010A0E3 		mov	r1, #48
 10588 5aa8 5230A0E3 		mov	r3, #82
 10589 5aac 0100A0E3 		mov	r0, #1
 10590 5ab0 FEFFFFEB 		bl	SensorSetIrisControl
 10591              	.LVL1208:
2171:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 10592              		.loc 1 2171 0
 10593 5ab4 7D0FA0E3 		mov	r0, #500
 10594 5ab8 FEFFFFEB 		bl	_tx_thread_sleep
 10595              	.LVL1209:
2172:../uvc.c      **** 			                         	default:
 10596              		.loc 1 2172 0
 10597 5abc 6C1098E5 		ldr	r1, [r8, #108]
 10598 5ac0 5220DBE5 		ldrb	r2, [fp, #82]	@ zero_extendqisi2
 10599 5ac4 000051E3 		cmp	r1, #0
 10600 5ac8 B010A003 		moveq	r1, #176
 10601 5acc 3010A013 		movne	r1, #48
 10602 5ad0 022081E1 		orr	r2, r1, r2
 10603 5ad4 6C3098E5 		ldr	r3, [r8, #108]
 10604 5ad8 E4191FE5 		ldr	r1, .L906+92
 10605 5adc 0400A0E3 		mov	r0, #4
 10606 5ae0 FEFFFFEB 		bl	CyU3PDebugPrint
 10607              	.LVL1210:
 10608 5ae4 3BFCFFEA 		b	.L695
 10609              	.L699:
2165:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 10610              		.loc 1 2165 0
 10611 5ae8 6C2098E5 		ldr	r2, [r8, #108]
 10612 5aec 5230DBE5 		ldrb	r3, [fp, #82]	@ zero_extendqisi2
 10613 5af0 000052E3 		cmp	r2, #0
 10614 5af4 8020A003 		moveq	r2, #128
 10615 5af8 0020A013 		movne	r2, #0
 10616 5afc 032082E1 		orr	r2, r2, r3
 10617 5b00 3010A0E3 		mov	r1, #48
 10618 5b04 5230A0E3 		mov	r3, #82
 10619 5b08 0100A0E3 		mov	r0, #1
 10620 5b0c FEFFFFEB 		bl	SensorSetIrisControl
 10621              	.LVL1211:
2166:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 10622              		.loc 1 2166 0
 10623 5b10 7D0FA0E3 		mov	r0, #500
 10624 5b14 FEFFFFEB 		bl	_tx_thread_sleep
 10625              	.LVL1212:
2167:../uvc.c      **** 			                         		break;
 10626              		.loc 1 2167 0
 10627 5b18 6C1098E5 		ldr	r1, [r8, #108]
 10628 5b1c 5220DBE5 		ldrb	r2, [fp, #82]	@ zero_extendqisi2
 10629 5b20 000051E3 		cmp	r1, #0
 10630 5b24 8010A003 		moveq	r1, #128
 10631 5b28 0010A013 		movne	r1, #0
 10632 5b2c 022081E1 		orr	r2, r1, r2
 10633 5b30 6C3098E5 		ldr	r3, [r8, #108]
 10634 5b34 401A1FE5 		ldr	r1, .L906+92
 10635 5b38 0400A0E3 		mov	r0, #4
 10636 5b3c FEFFFFEB 		bl	CyU3PDebugPrint
 10637              	.LVL1213:
 10638 5b40 24FCFFEA 		b	.L695
 10639              	.L698:
2160:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 10640              		.loc 1 2160 0
 10641 5b44 6C2098E5 		ldr	r2, [r8, #108]
 10642 5b48 3010A0E3 		mov	r1, #48
 10643 5b4c 000052E3 		cmp	r2, #0
 10644 5b50 9220A003 		moveq	r2, #146
 10645 5b54 1220A013 		movne	r2, #18
 10646 5b58 5230A0E3 		mov	r3, #82
 10647 5b5c 0100A0E3 		mov	r0, #1
 10648 5b60 FEFFFFEB 		bl	SensorSetIrisControl
 10649              	.LVL1214:
2161:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 10650              		.loc 1 2161 0
 10651 5b64 7D0FA0E3 		mov	r0, #500
 10652 5b68 FEFFFFEB 		bl	_tx_thread_sleep
 10653              	.LVL1215:
2162:../uvc.c      **** 			                         		break;
 10654              		.loc 1 2162 0
 10655 5b6c 6C2098E5 		ldr	r2, [r8, #108]
 10656 5b70 7C1A1FE5 		ldr	r1, .L906+92
 10657 5b74 000052E3 		cmp	r2, #0
 10658 5b78 6C3098E5 		ldr	r3, [r8, #108]
 10659 5b7c 9220A003 		moveq	r2, #146
 10660 5b80 1220A013 		movne	r2, #18
 10661 5b84 0400A0E3 		mov	r0, #4
 10662 5b88 FEFFFFEB 		bl	CyU3PDebugPrint
 10663              	.LVL1216:
 10664 5b8c 11FCFFEA 		b	.L695
 10665              	.L696:
2155:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 10666              		.loc 1 2155 0
 10667 5b90 6C2098E5 		ldr	r2, [r8, #108]
 10668 5b94 3010A0E3 		mov	r1, #48
 10669 5b98 000052E3 		cmp	r2, #0
 10670 5b9c A220A003 		moveq	r2, #162
 10671 5ba0 2220A013 		movne	r2, #34
 10672 5ba4 5230A0E3 		mov	r3, #82
 10673 5ba8 0100A0E3 		mov	r0, #1
 10674 5bac FEFFFFEB 		bl	SensorSetIrisControl
 10675              	.LVL1217:
2156:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 10676              		.loc 1 2156 0
 10677 5bb0 7D0FA0E3 		mov	r0, #500
 10678 5bb4 FEFFFFEB 		bl	_tx_thread_sleep
 10679              	.LVL1218:
2157:../uvc.c      **** 			                         		break;
 10680              		.loc 1 2157 0
 10681 5bb8 6C2098E5 		ldr	r2, [r8, #108]
 10682 5bbc C81A1FE5 		ldr	r1, .L906+92
 10683 5bc0 000052E3 		cmp	r2, #0
 10684 5bc4 6C3098E5 		ldr	r3, [r8, #108]
 10685 5bc8 A220A003 		moveq	r2, #162
 10686 5bcc 2220A013 		movne	r2, #34
 10687 5bd0 0400A0E3 		mov	r0, #4
 10688 5bd4 FEFFFFEB 		bl	CyU3PDebugPrint
 10689              	.LVL1219:
 10690 5bd8 FEFBFFEA 		b	.L695
 10691              	.LVL1220:
 10692              	.L736:
 10693              	.LBE187:
 10694              	.LBE262:
 10695              	.LBB263:
 10696              	.LBB224:
1595:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
 10697              		.loc 1 1595 0
 10698 5bdc 0C00A0E1 		mov	r0, ip
 10699 5be0 28109DE5 		ldr	r1, [sp, #40]
 10700 5be4 20308DE5 		str	r3, [sp, #32]
 10701 5be8 FEFFFFEB 		bl	SensorGetControl
 10702              	.LVL1221:
1596:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 10703              		.loc 1 1596 0
 10704 5bec 28109DE5 		ldr	r1, [sp, #40]
1595:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
 10705              		.loc 1 1595 0
 10706 5bf0 0050A0E1 		mov	r5, r0
 10707              	.LVL1222:
1596:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 10708              		.loc 1 1596 0
 10709 5bf4 2C009DE5 		ldr	r0, [sp, #44]
 10710              	.LVL1223:
 10711 5bf8 FEFFFFEB 		bl	SensorGetControl
 10712              	.LVL1224:
1676:../uvc.c      **** 
 10713              		.loc 1 1676 0
 10714 5bfc 20309DE5 		ldr	r3, [sp, #32]
1603:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 10715              		.loc 1 1603 0
 10716 5c00 0020A0E3 		mov	r2, #0
1676:../uvc.c      **** 
 10717              		.loc 1 1676 0
 10718 5c04 0C1B1FE5 		ldr	r1, .L906+96
1598:../uvc.c      **** 							glEp0Buffer[2] = Data1;
 10719              		.loc 1 1598 0
 10720 5c08 8455CBE5 		strb	r5, [fp, #1412]
1603:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 10721              		.loc 1 1603 0
 10722 5c0c 2920C8E5 		strb	r2, [r8, #41]
1604:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 10723              		.loc 1 1604 0
 10724 5c10 2B20C8E5 		strb	r2, [r8, #43]
1597:../uvc.c      **** 							WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 10725              		.loc 1 1597 0
 10726 5c14 2850C8E5 		strb	r5, [r8, #40]
1596:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 10727              		.loc 1 1596 0
 10728 5c18 24008DE5 		str	r0, [sp, #36]
 10729              	.LVL1225:
1599:../uvc.c      **** 							WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 10730              		.loc 1 1599 0
 10731 5c1c 24C09DE5 		ldr	ip, [sp, #36]
1676:../uvc.c      **** 
 10732              		.loc 1 1676 0
 10733 5c20 0300A0E1 		mov	r0, r3
1600:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 10734              		.loc 1 1600 0
 10735 5c24 86C5CBE5 		strb	ip, [fp, #1414]
 10736              	.LVL1226:
1599:../uvc.c      **** 							WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 10737              		.loc 1 1599 0
 10738 5c28 2AC0C8E5 		strb	ip, [r8, #42]
1676:../uvc.c      **** 
 10739              		.loc 1 1676 0
 10740 5c2c 20308DE5 		str	r3, [sp, #32]
 10741 5c30 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10742              	.LVL1227:
1679:../uvc.c      **** //#endif
 10743              		.loc 1 1679 0
 10744 5c34 2B00D8E5 		ldrb	r0, [r8, #43]	@ zero_extendqisi2
 10745 5c38 2C10D8E5 		ldrb	r1, [r8, #44]	@ zero_extendqisi2
 10746 5c3c 20309DE5 		ldr	r3, [sp, #32]
 10747 5c40 29E0D8E5 		ldrb	lr, [r8, #41]	@ zero_extendqisi2
 10748 5c44 03008DE8 		stmia	sp, {r0, r1}
 10749 5c48 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 10750 5c4c 08308DE5 		str	r3, [sp, #8]
 10751 5c50 0400A0E3 		mov	r0, #4
 10752 5c54 0E30A0E1 		mov	r3, lr
 10753 5c58 5C1B1FE5 		ldr	r1, .L906+100
 10754 5c5c FEFFFFEB 		bl	CyU3PDebugPrint
 10755              	.LVL1228:
 10756 5c60 24309DE5 		ldr	r3, [sp, #36]
 10757 5c64 0520A0E1 		mov	r2, r5
 10758 5c68 03C0A0E1 		mov	ip, r3
 10759 5c6c 68FCFFEA 		b	.L743
 10760              	.LVL1229:
 10761              	.L679:
 10762              	.LBE224:
 10763              	.LBE263:
 10764              	.LBB264:
 10765              	.LBB188:
1579:../uvc.c      **** 							glEp0Buffer[0] = (Data0&0x80)>>7;
 10766              		.loc 1 1579 0
 10767 5c70 0410A0E1 		mov	r1, r4
 10768 5c74 0100A0E3 		mov	r0, #1
 10769 5c78 20308DE5 		str	r3, [sp, #32]
 10770 5c7c FEFFFFEB 		bl	SensorGetControl
 10771              	.LVL1230:
1582:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
 10772              		.loc 1 1582 0
 10773 5c80 74EB1FE5 		ldr	lr, .L906+116
1676:../uvc.c      **** 
 10774              		.loc 1 1676 0
 10775 5c84 8C1B1FE5 		ldr	r1, .L906+96
1580:../uvc.c      **** 							//glEp0Buffer[0]++;
 10776              		.loc 1 1580 0
 10777 5c88 A0C3A0E1 		mov	ip, r0, lsr #7
 10778 5c8c FFC00CE2 		and	ip, ip, #255
1582:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
 10779              		.loc 1 1582 0
 10780 5c90 7DC5CEE5 		strb	ip, [lr, #1405]
1676:../uvc.c      **** 
 10781              		.loc 1 1676 0
 10782 5c94 20309DE5 		ldr	r3, [sp, #32]
1583:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 10783              		.loc 1 1583 0
 10784 5c98 7E45DEE5 		ldrb	r4, [lr, #1406]	@ zero_extendqisi2
 10785              	.LVL1231:
1579:../uvc.c      **** 							glEp0Buffer[0] = (Data0&0x80)>>7;
 10786              		.loc 1 1579 0
 10787 5c9c 0050A0E1 		mov	r5, r0
 10788              	.LVL1232:
1583:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 10789              		.loc 1 1583 0
 10790 5ca0 FF4004E2 		and	r4, r4, #255
1676:../uvc.c      **** 
 10791              		.loc 1 1676 0
 10792 5ca4 0300A0E1 		mov	r0, r3
 10793              	.LVL1233:
1580:../uvc.c      **** 							//glEp0Buffer[0]++;
 10794              		.loc 1 1580 0
 10795 5ca8 28C0C8E5 		strb	ip, [r8, #40]
1676:../uvc.c      **** 
 10796              		.loc 1 1676 0
 10797 5cac 1CC08DE5 		str	ip, [sp, #28]
1583:../uvc.c      **** 							//curFlag[CtrlID] = CyTrue;
 10798              		.loc 1 1583 0
 10799 5cb0 2940C8E5 		strb	r4, [r8, #41]
 10800              	.LVL1234:
1676:../uvc.c      **** 
 10801              		.loc 1 1676 0
 10802 5cb4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10803              	.LVL1235:
1679:../uvc.c      **** //#endif
 10804              		.loc 1 1679 0
 10805 5cb8 2B00D8E5 		ldrb	r0, [r8, #43]	@ zero_extendqisi2
 10806 5cbc 2C10D8E5 		ldrb	r1, [r8, #44]	@ zero_extendqisi2
 10807 5cc0 20309DE5 		ldr	r3, [sp, #32]
 10808 5cc4 29E0D8E5 		ldrb	lr, [r8, #41]	@ zero_extendqisi2
 10809 5cc8 03008DE8 		stmia	sp, {r0, r1}
 10810 5ccc 2820D8E5 		ldrb	r2, [r8, #40]	@ zero_extendqisi2
 10811 5cd0 08308DE5 		str	r3, [sp, #8]
 10812 5cd4 D81B1FE5 		ldr	r1, .L906+100
 10813 5cd8 0E30A0E1 		mov	r3, lr
 10814 5cdc 0400A0E3 		mov	r0, #4
 10815 5ce0 FEFFFFEB 		bl	CyU3PDebugPrint
 10816              	.LVL1236:
 10817 5ce4 0000A0E3 		mov	r0, #0
 10818 5ce8 28008DE5 		str	r0, [sp, #40]
 10819 5cec 1CC09DE5 		ldr	ip, [sp, #28]
 10820 5cf0 0010A0E1 		mov	r1, r0
 10821 5cf4 BCFBFFEA 		b	.L686
 10822              	.LVL1237:
 10823              	.L656:
 10824              	.LBE188:
 10825              	.LBE264:
 10826              	.LBB265:
 10827              	.LBB213:
2268:../uvc.c      **** 			   }
 10828              		.loc 1 2268 0
 10829 5cf8 F81B1FE5 		ldr	r1, .L906+104
 10830 5cfc 0400A0E3 		mov	r0, #4
 10831              	.LVL1238:
 10832 5d00 FEFFFFEB 		bl	CyU3PDebugPrint
 10833              	.LVL1239:
 10834 5d04 D1FDFFEA 		b	.L855
 10835              	.LVL1240:
 10836              	.L747:
 10837              	.LBE213:
 10838              	.LBE265:
 10839              	.LBB266:
 10840              	.LBB225:
 10841 5d08 081C1FE5 		ldr	r1, .L906+104
 10842 5d0c 0400A0E3 		mov	r0, #4
 10843              	.LVL1241:
 10844 5d10 FEFFFFEB 		bl	CyU3PDebugPrint
 10845              	.LVL1242:
 10846 5d14 ACFDFFEA 		b	.L867
 10847              	.LVL1243:
 10848              	.L690:
 10849              	.LBE225:
 10850              	.LBE266:
 10851              	.LBB267:
 10852              	.LBB189:
 10853 5d18 181C1FE5 		ldr	r1, .L906+104
 10854 5d1c 0400A0E3 		mov	r0, #4
 10855              	.LVL1244:
 10856 5d20 FEFFFFEB 		bl	CyU3PDebugPrint
 10857              	.LVL1245:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10858              		.loc 1 1355 0
 10859 5d24 FF40A0E3 		mov	r4, #255
 10860              	.LVL1246:
2268:../uvc.c      **** 			   }
 10861              		.loc 1 2268 0
 10862 5d28 00E0A0E3 		mov	lr, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10863              		.loc 1 1355 0
 10864 5d2c 04C0A0E1 		mov	ip, r4
2268:../uvc.c      **** 			   }
 10865              		.loc 1 2268 0
 10866 5d30 28E08DE5 		str	lr, [sp, #40]
 10867 5d34 0E50A0E1 		mov	r5, lr
 10868 5d38 0E10A0E1 		mov	r1, lr
 10869 5d3c AAFBFFEA 		b	.L686
 10870              	.LVL1247:
 10871              	.L673:
 10872              	.LBE189:
 10873              	.LBE267:
 10874              	.LBB268:
 10875              	.LBB178:
 10876 5d40 401C1FE5 		ldr	r1, .L906+104
 10877 5d44 0400A0E3 		mov	r0, #4
 10878              	.LVL1248:
 10879 5d48 FEFFFFEB 		bl	CyU3PDebugPrint
 10880              	.LVL1249:
 10881 5d4c 58FEFFEA 		b	.L860
 10882              	.LVL1250:
 10883              	.L894:
 10884              	.LBE178:
 10885              	.LBE268:
 10886              	.LBB269:
 10887              	.LBB201:
2247:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
 10888              		.loc 1 2247 0
 10889 5d50 48CC1FE5 		ldr	ip, .L906+112
 10890 5d54 0010E0E3 		mvn	r1, #0
 10891 5d58 1C009CE5 		ldr	r0, [ip, #28]
 10892 5d5c 3CC08DE5 		str	ip, [sp, #60]
 10893 5d60 FEFFFFEB 		bl	_txe_mutex_get
 10894              	.LVL1251:
2248:../uvc.c      **** 								 {
 10895              		.loc 1 2248 0
 10896 5d64 58EC1FE5 		ldr	lr, .L906+116
 10897 5d68 6537DEE5 		ldrb	r3, [lr, #1893]	@ zero_extendqisi2
 10898 5d6c 030054E1 		cmp	r4, r3
1839:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x 
 10899              		.loc 1 1839 0
 10900 5d70 34309D05 		ldreq	r3, [sp, #52]
2248:../uvc.c      **** 								 {
 10901              		.loc 1 2248 0
 10902 5d74 0900000A 		beq	.L731
2251:../uvc.c      **** 									 dataIdx++;
 10903              		.loc 1 2251 0
 10904 5d78 34C09DE5 		ldr	ip, [sp, #52]
 10905 5d7c 00408DE5 		str	r4, [sp]
 10906 5d80 04C08DE5 		str	ip, [sp, #4]
 10907 5d84 2C309DE5 		ldr	r3, [sp, #44]
 10908 5d88 30209DE5 		ldr	r2, [sp, #48]
 10909 5d8c 3C009DE5 		ldr	r0, [sp, #60]
 10910 5d90 0910A0E3 		mov	r1, #9
2250:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 10911              		.loc 1 2250 0
 10912 5d94 6547CEE5 		strb	r4, [lr, #1893]
2251:../uvc.c      **** 									 dataIdx++;
 10913              		.loc 1 2251 0
 10914 5d98 FEFFFFEB 		bl	cmdSet
 10915              	.LVL1252:
2252:../uvc.c      **** 								 }
 10916              		.loc 1 2252 0
 10917 5d9c 28309DE5 		ldr	r3, [sp, #40]
 10918              	.LVL1253:
 10919              	.L731:
2254:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 10920              		.loc 1 2254 0
 10921 5da0 6627DBE5 		ldrb	r2, [fp, #1894]	@ zero_extendqisi2
 10922 5da4 24C09DE5 		ldr	ip, [sp, #36]
 10923 5da8 02005CE1 		cmp	ip, r2
 10924 5dac 0800000A 		beq	.L732
2255:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 10925              		.loc 1 2255 0
 10926 5db0 A4EC1FE5 		ldr	lr, .L906+116
2256:../uvc.c      **** 								 }
 10927              		.loc 1 2256 0
 10928 5db4 04308DE5 		str	r3, [sp, #4]
 10929 5db8 00C08DE5 		str	ip, [sp]
 10930 5dbc 0520A0E1 		mov	r2, r5
 10931 5dc0 2C309DE5 		ldr	r3, [sp, #44]
 10932              	.LVL1254:
 10933 5dc4 BC0C1FE5 		ldr	r0, .L906+112
 10934 5dc8 0910A0E3 		mov	r1, #9
2255:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 10935              		.loc 1 2255 0
 10936 5dcc 66C7CEE5 		strb	ip, [lr, #1894]
2256:../uvc.c      **** 								 }
 10937              		.loc 1 2256 0
 10938 5dd0 FEFFFFEB 		bl	cmdSet
 10939              	.LVL1255:
 10940              	.L732:
2259:../uvc.c      **** 
 10941              		.loc 1 2259 0
 10942 5dd4 3CC09DE5 		ldr	ip, [sp, #60]
2258:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 10943              		.loc 1 2258 0
 10944 5dd8 0130A0E3 		mov	r3, #1
2259:../uvc.c      **** 
 10945              		.loc 1 2259 0
 10946 5ddc 1C009CE5 		ldr	r0, [ip, #28]
2258:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 10947              		.loc 1 2258 0
 10948 5de0 6937CBE5 		strb	r3, [fp, #1897]
2259:../uvc.c      **** 
 10949              		.loc 1 2259 0
 10950 5de4 FEFFFFEB 		bl	_txe_mutex_put
 10951              	.LVL1256:
 10952 5de8 3CFBFFEA 		b	.L730
 10953              	.LVL1257:
 10954              	.L893:
1834:../uvc.c      **** 				 }else{
 10955              		.loc 1 1834 0
 10956 5dec 29C0D9E5 		ldrb	ip, [r9, #41]	@ zero_extendqisi2
1840:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 10957              		.loc 1 1840 0
 10958 5df0 0400A0E3 		mov	r0, #4
 10959              	.LVL1258:
1834:../uvc.c      **** 				 }else{
 10960              		.loc 1 1834 0
 10961 5df4 24C08DE5 		str	ip, [sp, #36]
 10962              	.LVL1259:
1840:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 10963              		.loc 1 1840 0
 10964 5df8 2CC09DE5 		ldr	ip, [sp, #44]
 10965 5dfc 08308DE5 		str	r3, [sp, #8]
 10966 5e00 04C08DE5 		str	ip, [sp, #4]
 10967 5e04 24C09DE5 		ldr	ip, [sp, #36]
 10968 5e08 30309DE5 		ldr	r3, [sp, #48]
 10969 5e0c 00508DE5 		str	r5, [sp]
 10970 5e10 0C408DE5 		str	r4, [sp, #12]
 10971 5e14 10C08DE5 		str	ip, [sp, #16]
 10972 5e18 141D1FE5 		ldr	r1, .L906+108
 10973 5e1c 0920A0E3 		mov	r2, #9
 10974 5e20 FEFFFFEB 		bl	CyU3PDebugPrint
 10975              	.LVL1260:
2238:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 10976              		.loc 1 2238 0
 10977 5e24 18ED1FE5 		ldr	lr, .L906+116
 10978 5e28 6537DEE5 		ldrb	r3, [lr, #1893]	@ zero_extendqisi2
 10979 5e2c 030054E1 		cmp	r4, r3
 10980 5e30 1100000A 		beq	.L728
2239:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 10981              		.loc 1 2239 0
 10982 5e34 2C5D1FE5 		ldr	r5, .L906+112
 10983              	.LVL1261:
 10984 5e38 0010E0E3 		mvn	r1, #0
 10985 5e3c 1C0095E5 		ldr	r0, [r5, #28]
 10986 5e40 FEFFFFEB 		bl	_txe_mutex_get
 10987              	.LVL1262:
2240:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 10988              		.loc 1 2240 0
 10989 5e44 34C09DE5 		ldr	ip, [sp, #52]
 10990 5e48 30209DE5 		ldr	r2, [sp, #48]
 10991 5e4c 04C08DE5 		str	ip, [sp, #4]
 10992 5e50 2C309DE5 		ldr	r3, [sp, #44]
 10993 5e54 0910A0E3 		mov	r1, #9
 10994 5e58 00408DE5 		str	r4, [sp]
 10995 5e5c 0500A0E1 		mov	r0, r5
 10996 5e60 FEFFFFEB 		bl	cmdSet
 10997              	.LVL1263:
2241:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 10998              		.loc 1 2241 0
 10999 5e64 1C0095E5 		ldr	r0, [r5, #28]
 11000 5e68 FEFFFFEB 		bl	_txe_mutex_put
 11001              	.LVL1264:
2242:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
 11002              		.loc 1 2242 0
 11003 5e6c 60ED1FE5 		ldr	lr, .L906+116
2243:../uvc.c      **** 								 }
 11004              		.loc 1 2243 0
 11005 5e70 34C09DE5 		ldr	ip, [sp, #52]
2242:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
 11006              		.loc 1 2242 0
 11007 5e74 6547CEE5 		strb	r4, [lr, #1893]
2243:../uvc.c      **** 								 }
 11008              		.loc 1 2243 0
 11009 5e78 66C7CEE5 		strb	ip, [lr, #1894]
 11010              	.L728:
2245:../uvc.c      **** 			 	 			 }else if(Len == 4){
 11011              		.loc 1 2245 0
 11012 5e7c 0130A0E3 		mov	r3, #1
1840:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11013              		.loc 1 1840 0
 11014 5e80 02C0A0E3 		mov	ip, #2
2245:../uvc.c      **** 			 	 			 }else if(Len == 4){
 11015              		.loc 1 2245 0
 11016 5e84 6937CBE5 		strb	r3, [fp, #1897]
1840:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11017              		.loc 1 1840 0
 11018 5e88 38C08DE5 		str	ip, [sp, #56]
 11019 5e8c 13FBFFEA 		b	.L730
 11020              	.LVL1265:
 11021              	.L725:
2268:../uvc.c      **** 			   }
 11022              		.loc 1 2268 0
 11023 5e90 901D1FE5 		ldr	r1, .L906+104
 11024 5e94 34209DE5 		ldr	r2, [sp, #52]
 11025 5e98 0400A0E3 		mov	r0, #4
 11026              	.LVL1266:
 11027 5e9c FEFFFFEB 		bl	CyU3PDebugPrint
 11028              	.LVL1267:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11029              		.loc 1 1355 0
 11030 5ea0 FF50A0E3 		mov	r5, #255
 11031              	.LVL1268:
2268:../uvc.c      **** 			   }
 11032              		.loc 1 2268 0
 11033 5ea4 00E0A0E3 		mov	lr, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11034              		.loc 1 1355 0
 11035 5ea8 05C0A0E1 		mov	ip, r5
2268:../uvc.c      **** 			   }
 11036              		.loc 1 2268 0
 11037 5eac 24E08DE5 		str	lr, [sp, #36]
 11038 5eb0 0E40A0E1 		mov	r4, lr
 11039 5eb4 0E10A0E1 		mov	r1, lr
 11040 5eb8 14FBFFEA 		b	.L719
 11041              	.LVL1269:
 11042              	.L897:
 11043              	.LBE201:
 11044              	.LBE269:
 11045              	.LBE278:
 11046              	.LBE297:
 11047              	.LBB298:
 11048              	.LBB166:
 11049              	.LBB156:
 11050              	.LBB150:
1834:../uvc.c      **** 				 }else{
 11051              		.loc 1 1834 0
 11052 5ebc 29C0D9E5 		ldrb	ip, [r9, #41]	@ zero_extendqisi2
1840:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11053              		.loc 1 1840 0
 11054 5ec0 0400A0E3 		mov	r0, #4
 11055              	.LVL1270:
1834:../uvc.c      **** 				 }else{
 11056              		.loc 1 1834 0
 11057 5ec4 24C08DE5 		str	ip, [sp, #36]
 11058              	.LVL1271:
1840:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11059              		.loc 1 1840 0
 11060 5ec8 2CC09DE5 		ldr	ip, [sp, #44]
 11061 5ecc 08308DE5 		str	r3, [sp, #8]
 11062 5ed0 04C08DE5 		str	ip, [sp, #4]
 11063 5ed4 24C09DE5 		ldr	ip, [sp, #36]
 11064 5ed8 30309DE5 		ldr	r3, [sp, #48]
 11065 5edc 00508DE5 		str	r5, [sp]
 11066 5ee0 0C408DE5 		str	r4, [sp, #12]
 11067 5ee4 10C08DE5 		str	ip, [sp, #16]
 11068 5ee8 E41D1FE5 		ldr	r1, .L906+108
 11069 5eec 2720A0E3 		mov	r2, #39
 11070 5ef0 FEFFFFEB 		bl	CyU3PDebugPrint
 11071              	.LVL1272:
2047:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 11072              		.loc 1 2047 0
 11073 5ef4 8D37DBE5 		ldrb	r3, [fp, #1933]	@ zero_extendqisi2
 11074 5ef8 030054E1 		cmp	r4, r3
 11075 5efc 1100000A 		beq	.L806
2048:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 11076              		.loc 1 2048 0
 11077 5f00 F85D1FE5 		ldr	r5, .L906+112
 11078              	.LVL1273:
 11079 5f04 0010E0E3 		mvn	r1, #0
 11080 5f08 1C0095E5 		ldr	r0, [r5, #28]
 11081 5f0c FEFFFFEB 		bl	_txe_mutex_get
 11082              	.LVL1274:
2049:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11083              		.loc 1 2049 0
 11084 5f10 34C09DE5 		ldr	ip, [sp, #52]
 11085 5f14 30209DE5 		ldr	r2, [sp, #48]
 11086 5f18 04C08DE5 		str	ip, [sp, #4]
 11087 5f1c 2C309DE5 		ldr	r3, [sp, #44]
 11088 5f20 2710A0E3 		mov	r1, #39
 11089 5f24 00408DE5 		str	r4, [sp]
 11090 5f28 0500A0E1 		mov	r0, r5
 11091 5f2c FEFFFFEB 		bl	cmdSet
 11092              	.LVL1275:
2050:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 11093              		.loc 1 2050 0
 11094 5f30 1C0095E5 		ldr	r0, [r5, #28]
 11095 5f34 FEFFFFEB 		bl	_txe_mutex_put
 11096              	.LVL1276:
2051:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11097              		.loc 1 2051 0
 11098 5f38 2CEE1FE5 		ldr	lr, .L906+116
2052:../uvc.c      **** 									 }
 11099              		.loc 1 2052 0
 11100 5f3c 34C09DE5 		ldr	ip, [sp, #52]
2051:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11101              		.loc 1 2051 0
 11102 5f40 8D47CEE5 		strb	r4, [lr, #1933]
2052:../uvc.c      **** 									 }
 11103              		.loc 1 2052 0
 11104 5f44 8EC7CEE5 		strb	ip, [lr, #1934]
 11105              	.L806:
2054:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11106              		.loc 1 2054 0
 11107 5f48 0130A0E3 		mov	r3, #1
1840:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11108              		.loc 1 1840 0
 11109 5f4c 02C0A0E3 		mov	ip, #2
2054:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11110              		.loc 1 2054 0
 11111 5f50 9137CBE5 		strb	r3, [fp, #1937]
1840:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len, Data0, Data1);
 11112              		.loc 1 1840 0
 11113 5f54 38C08DE5 		str	ip, [sp, #56]
 11114 5f58 0BFDFFEA 		b	.L808
 11115              	.LVL1277:
 11116              	.L898:
2056:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 11117              		.loc 1 2056 0
 11118 5f5c 54CE1FE5 		ldr	ip, .L906+112
 11119 5f60 0010E0E3 		mvn	r1, #0
 11120 5f64 1C009CE5 		ldr	r0, [ip, #28]
 11121 5f68 3CC08DE5 		str	ip, [sp, #60]
 11122 5f6c FEFFFFEB 		bl	_txe_mutex_get
 11123              	.LVL1278:
2057:../uvc.c      **** 									 {
 11124              		.loc 1 2057 0
 11125 5f70 8D37DBE5 		ldrb	r3, [fp, #1933]	@ zero_extendqisi2
 11126 5f74 030054E1 		cmp	r4, r3
1839:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x 
 11127              		.loc 1 1839 0
 11128 5f78 34309D05 		ldreq	r3, [sp, #52]
2057:../uvc.c      **** 									 {
 11129              		.loc 1 2057 0
 11130 5f7c 0A00000A 		beq	.L809
2060:../uvc.c      **** 										 dataIdx++;
 11131              		.loc 1 2060 0
 11132 5f80 34C09DE5 		ldr	ip, [sp, #52]
2059:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11133              		.loc 1 2059 0
 11134 5f84 78EE1FE5 		ldr	lr, .L906+116
2060:../uvc.c      **** 										 dataIdx++;
 11135              		.loc 1 2060 0
 11136 5f88 00408DE5 		str	r4, [sp]
 11137 5f8c 04C08DE5 		str	ip, [sp, #4]
 11138 5f90 2C309DE5 		ldr	r3, [sp, #44]
 11139 5f94 30209DE5 		ldr	r2, [sp, #48]
 11140 5f98 3C009DE5 		ldr	r0, [sp, #60]
 11141 5f9c 2710A0E3 		mov	r1, #39
2059:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11142              		.loc 1 2059 0
 11143 5fa0 8D47CEE5 		strb	r4, [lr, #1933]
2060:../uvc.c      **** 										 dataIdx++;
 11144              		.loc 1 2060 0
 11145 5fa4 FEFFFFEB 		bl	cmdSet
 11146              	.LVL1279:
2061:../uvc.c      **** 									 }
 11147              		.loc 1 2061 0
 11148 5fa8 28309DE5 		ldr	r3, [sp, #40]
 11149              	.LVL1280:
 11150              	.L809:
2063:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 11151              		.loc 1 2063 0
 11152 5fac 8E27DBE5 		ldrb	r2, [fp, #1934]	@ zero_extendqisi2
 11153 5fb0 24C09DE5 		ldr	ip, [sp, #36]
 11154 5fb4 02005CE1 		cmp	ip, r2
 11155 5fb8 0800000A 		beq	.L810
2064:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11156              		.loc 1 2064 0
 11157 5fbc B0EE1FE5 		ldr	lr, .L906+116
2065:../uvc.c      **** 									 }
 11158              		.loc 1 2065 0
 11159 5fc0 04308DE5 		str	r3, [sp, #4]
 11160 5fc4 00C08DE5 		str	ip, [sp]
 11161 5fc8 0520A0E1 		mov	r2, r5
 11162 5fcc 2C309DE5 		ldr	r3, [sp, #44]
 11163              	.LVL1281:
 11164 5fd0 C80E1FE5 		ldr	r0, .L906+112
 11165 5fd4 2710A0E3 		mov	r1, #39
2064:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11166              		.loc 1 2064 0
 11167 5fd8 8EC7CEE5 		strb	ip, [lr, #1934]
2065:../uvc.c      **** 									 }
 11168              		.loc 1 2065 0
 11169 5fdc FEFFFFEB 		bl	cmdSet
 11170              	.LVL1282:
 11171              	.L810:
2068:../uvc.c      **** 
 11172              		.loc 1 2068 0
 11173 5fe0 3CC09DE5 		ldr	ip, [sp, #60]
2067:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11174              		.loc 1 2067 0
 11175 5fe4 0130A0E3 		mov	r3, #1
2068:../uvc.c      **** 
 11176              		.loc 1 2068 0
 11177 5fe8 1C009CE5 		ldr	r0, [ip, #28]
2067:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11178              		.loc 1 2067 0
 11179 5fec 9137CBE5 		strb	r3, [fp, #1937]
2068:../uvc.c      **** 
 11180              		.loc 1 2068 0
 11181 5ff0 FEFFFFEB 		bl	_txe_mutex_put
 11182              	.LVL1283:
 11183 5ff4 E4FCFFEA 		b	.L808
 11184              	.LVL1284:
 11185              	.L905:
1506:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11186              		.loc 1 1506 0
 11187 5ff8 0500A0E1 		mov	r0, r5
 11188 5ffc 2C109DE5 		ldr	r1, [sp, #44]
 11189 6000 20308DE5 		str	r3, [sp, #32]
 11190 6004 FEFFFFEB 		bl	SensorGetControl
 11191              	.LVL1285:
1508:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11192              		.loc 1 1508 0
 11193 6008 2C109DE5 		ldr	r1, [sp, #44]
1506:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11194              		.loc 1 1506 0
 11195 600c 0020A0E1 		mov	r2, r0
1508:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11196              		.loc 1 1508 0
 11197 6010 30009DE5 		ldr	r0, [sp, #48]
1506:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11198              		.loc 1 1506 0
 11199 6014 2820C8E5 		strb	r2, [r8, #40]
1507:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 11200              		.loc 1 1507 0
 11201 6018 8D27CBE5 		strb	r2, [fp, #1933]
1508:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11202              		.loc 1 1508 0
 11203 601c FEFFFFEB 		bl	SensorGetControl
 11204              	.LVL1286:
1510:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11205              		.loc 1 1510 0
 11206 6020 0020A0E3 		mov	r2, #0
 11207 6024 2920C8E5 		strb	r2, [r8, #41]
1511:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11208              		.loc 1 1511 0
 11209 6028 2B20C8E5 		strb	r2, [r8, #43]
1512:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 11210              		.loc 1 1512 0
 11211 602c 28C0D8E5 		ldrb	ip, [r8, #40]	@ zero_extendqisi2
 11212              	.LVL1287:
1509:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11213              		.loc 1 1509 0
 11214 6030 8E07CBE5 		strb	r0, [fp, #1934]
1508:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11215              		.loc 1 1508 0
 11216 6034 0050A0E1 		mov	r5, r0
 11217              	.LVL1288:
 11218 6038 2A00C8E5 		strb	r0, [r8, #42]
 11219 603c 20309DE5 		ldr	r3, [sp, #32]
 11220 6040 23FEFFEA 		b	.L799
 11221              	.LVL1289:
 11222              	.L899:
 11223              	.LBE150:
 11224              	.LBE156:
 11225              	.LBE166:
 11226              	.LBE298:
 11227              	.LBB299:
 11228              	.LBB279:
 11229              	.LBB270:
 11230              	.LBB214:
1654:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 11231              		.loc 1 1654 0
 11232 6044 0510A0E1 		mov	r1, r5
 11233 6048 2C009DE5 		ldr	r0, [sp, #44]
 11234 604c 1CC08DE5 		str	ip, [sp, #28]
 11235 6050 FEFFFFEB 		bl	SensorGetControl
 11236              	.LVL1290:
1655:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11237              		.loc 1 1655 0
 11238 6054 48EF1FE5 		ldr	lr, .L906+116
1656:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
 11239              		.loc 1 1656 0
 11240 6058 0040A0E3 		mov	r4, #0
 11241              	.LVL1291:
 11242 605c 2940C8E5 		strb	r4, [r8, #41]
1655:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11243              		.loc 1 1655 0
 11244 6060 A905CEE5 		strb	r0, [lr, #1449]
1657:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11245              		.loc 1 1657 0
 11246 6064 AA45CEE5 		strb	r4, [lr, #1450]
1654:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 11247              		.loc 1 1654 0
 11248 6068 0050A0E1 		mov	r5, r0
 11249              	.LVL1292:
 11250 606c 2800C8E5 		strb	r0, [r8, #40]
 11251 6070 1CC09DE5 		ldr	ip, [sp, #28]
 11252 6074 E0FCFFEA 		b	.L652
 11253              	.LVL1293:
 11254              	.L904:
 11255              	.LBE214:
 11256              	.LBE270:
 11257              	.LBE279:
 11258              	.LBE299:
 11259              	.LBB300:
 11260              	.LBB167:
 11261              	.LBB157:
 11262              	.LBB151:
1499:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11263              		.loc 1 1499 0
 11264 6078 30009DE5 		ldr	r0, [sp, #48]
 11265 607c 2C109DE5 		ldr	r1, [sp, #44]
 11266 6080 20308DE5 		str	r3, [sp, #32]
 11267 6084 FEFFFFEB 		bl	SensorGetControl
 11268              	.LVL1294:
1501:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 11269              		.loc 1 1501 0
 11270 6088 0050A0E3 		mov	r5, #0
 11271              	.LVL1295:
 11272 608c 2950C8E5 		strb	r5, [r8, #41]
1500:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11273              		.loc 1 1500 0
 11274 6090 8D07CBE5 		strb	r0, [fp, #1933]
1502:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11275              		.loc 1 1502 0
 11276 6094 8E57CBE5 		strb	r5, [fp, #1934]
1499:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11277              		.loc 1 1499 0
 11278 6098 00C0A0E1 		mov	ip, r0
 11279              	.LVL1296:
 11280 609c 2800C8E5 		strb	r0, [r8, #40]
 11281 60a0 20309DE5 		ldr	r3, [sp, #32]
 11282 60a4 0AFEFFEA 		b	.L799
 11283              	.LVL1297:
 11284              	.L902:
 11285              	.LBE151:
 11286              	.LBE157:
 11287              	.LBE167:
 11288              	.LBE300:
 11289              	.LBB301:
 11290              	.LBB280:
 11291              	.LBB271:
 11292              	.LBB202:
1654:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 11293              		.loc 1 1654 0
 11294 60a8 30009DE5 		ldr	r0, [sp, #48]
 11295 60ac 2C109DE5 		ldr	r1, [sp, #44]
 11296 60b0 20308DE5 		str	r3, [sp, #32]
 11297 60b4 FEFFFFEB 		bl	SensorGetControl
 11298              	.LVL1298:
1655:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11299              		.loc 1 1655 0
 11300 60b8 ACEF1FE5 		ldr	lr, .L906+116
1656:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
 11301              		.loc 1 1656 0
 11302 60bc 0050A0E3 		mov	r5, #0
 11303              	.LVL1299:
 11304 60c0 2950C8E5 		strb	r5, [r8, #41]
1655:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11305              		.loc 1 1655 0
 11306 60c4 6507CEE5 		strb	r0, [lr, #1893]
1657:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11307              		.loc 1 1657 0
 11308 60c8 6657CEE5 		strb	r5, [lr, #1894]
1654:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 11309              		.loc 1 1654 0
 11310 60cc 00C0A0E1 		mov	ip, r0
 11311              	.LVL1300:
 11312 60d0 2800C8E5 		strb	r0, [r8, #40]
 11313 60d4 20309DE5 		ldr	r3, [sp, #32]
 11314 60d8 98FDFFEA 		b	.L721
 11315              	.LBE202:
 11316              	.LBE271:
 11317              	.LBE280:
 11318              	.LBE301:
 11319              		.cfi_endproc
 11320              	.LFE25:
 11322              		.align	2
 11323              		.global	CyFxGpifCB
 11325              	CyFxGpifCB:
 11326              	.LFB13:
3042:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 11327              		.loc 1 3042 0
 11328              		.cfi_startproc
 11329              		@ args = 0, pretend = 0, frame = 0
 11330              		@ frame_needed = 0, uses_anonymous_args = 0
3043:../uvc.c      ****     {
 11331              		.loc 1 3043 0
 11332 60dc 010050E3 		cmp	r0, #1
3042:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 11333              		.loc 1 3042 0
 11334 60e0 10402DE9 		stmfd	sp!, {r4, lr}
 11335              	.LCFI29:
 11336              		.cfi_def_cfa_offset 8
 11337              		.cfi_offset 4, -8
 11338              		.cfi_offset 14, -4
3043:../uvc.c      ****     {
 11339              		.loc 1 3043 0
 11340 60e4 1080BD18 		ldmnefd	sp!, {r4, pc}
 11341              	.LBB306:
 11342              	.LBB307:
2940:../uvc.c      ****     {
 11343              		.loc 1 2940 0
 11344 60e8 C4309FE5 		ldr	r3, .L925
 11345 60ec 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 11346 60f0 030053E3 		cmp	r3, #3
 11347 60f4 1000000A 		beq	.L924
2966:../uvc.c      ****     {
 11348              		.loc 1 2966 0
 11349 60f8 020053E3 		cmp	r3, #2
 11350 60fc 1080BD18 		ldmnefd	sp!, {r4, pc}
2968:../uvc.c      ****         {
 11351              		.loc 1 2968 0
 11352 6100 083041E2 		sub	r3, r1, #8
 11353 6104 0A0053E3 		cmp	r3, #10
 11354 6108 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 11355 610c 200000EA 		b	.L917
 11356              	.L919:
 11357 6110 8C610000 		.word	.L912
 11358 6114 94610000 		.word	.L917
 11359 6118 94610000 		.word	.L917
 11360 611c 5C610000 		.word	.L908
 11361 6120 94610000 		.word	.L917
 11362 6124 94610000 		.word	.L917
 11363 6128 94610000 		.word	.L917
 11364 612c 60610000 		.word	.L923
 11365 6130 94610000 		.word	.L917
 11366 6134 94610000 		.word	.L917
 11367 6138 5C610000 		.word	.L908
 11368              	.L924:
2942:../uvc.c      ****         {
 11369              		.loc 1 2942 0
 11370 613c 0B1041E2 		sub	r1, r1, #11
 11371 6140 030051E3 		cmp	r1, #3
 11372 6144 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 11373 6148 150000EA 		b	.L911
 11374              	.L913:
 11375 614c 8C610000 		.word	.L912
 11376 6150 60610000 		.word	.L923
 11377 6154 5C610000 		.word	.L908
 11378 6158 5C610000 		.word	.L908
 11379              	.L908:
 11380 615c 1080BDE8 		ldmfd	sp!, {r4, pc}
 11381              	.L923:
2968:../uvc.c      ****         {
 11382              		.loc 1 2968 0
 11383 6160 0110A0E3 		mov	r1, #1
 11384              	.L914:
3025:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 11385              		.loc 1 3025 0
 11386 6164 4C009FE5 		ldr	r0, .L925+4
 11387 6168 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
3026:../uvc.c      ****         {
 11388              		.loc 1 3026 0
 11389 616c 004050E2 		subs	r4, r0, #0
 11390 6170 1080BD08 		ldmeqfd	sp!, {r4, pc}
3028:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
 11391              		.loc 1 3028 0
 11392 6174 0400A0E3 		mov	r0, #4
 11393 6178 3C109FE5 		ldr	r1, .L925+8
 11394 617c 0420A0E1 		mov	r2, r4
 11395 6180 FEFFFFEB 		bl	CyU3PDebugPrint
3029:../uvc.c      ****         }
 11396              		.loc 1 3029 0
 11397 6184 0400A0E1 		mov	r0, r4
 11398 6188 FEFFFFEB 		bl	CyFxAppErrorHandler
 11399              	.L912:
2942:../uvc.c      ****         {
 11400              		.loc 1 2942 0
 11401 618c 0010A0E3 		mov	r1, #0
 11402 6190 F3FFFFEA 		b	.L914
 11403              	.L917:
3014:../uvc.c      ****                 /* Unexpected current state. Return error. */
 11404              		.loc 1 3014 0
 11405 6194 0120A0E1 		mov	r2, r1
 11406 6198 0100A0E3 		mov	r0, #1
 11407 619c 1C109FE5 		ldr	r1, .L925+12
 11408 61a0 FEFFFFEB 		bl	CyU3PDebugPrint
 11409              	.L911:
 11410              	.LBE307:
 11411              	.LBE306:
 11412              	.LBB308:
 11413              	.LBB309:
3049:../uvc.c      ****     }
 11414              		.loc 1 3049 0
 11415 61a4 0400A0E3 		mov	r0, #4
 11416 61a8 14109FE5 		ldr	r1, .L925+16
 11417              	.LBE309:
 11418              	.LBE308:
3052:../uvc.c      **** 
 11419              		.loc 1 3052 0
 11420 61ac 1040BDE8 		ldmfd	sp!, {r4, lr}
 11421              	.LBB311:
 11422              	.LBB310:
3049:../uvc.c      ****     }
 11423              		.loc 1 3049 0
 11424 61b0 FEFFFFEA 		b	CyU3PDebugPrint
 11425              	.L926:
 11426              		.align	2
 11427              	.L925:
 11428 61b4 00000000 		.word	.LANCHOR0
 11429 61b8 00000000 		.word	glChHandleUVCStream
 11430 61bc 3C0E0000 		.word	.LC81
 11431 61c0 240E0000 		.word	.LC80
 11432 61c4 6C0E0000 		.word	.LC82
 11433              	.LBE310:
 11434              	.LBE311:
 11435              		.cfi_endproc
 11436              	.LFE13:
 11438              		.align	2
 11439              		.global	CyFxApplicationDefine
 11441              	CyFxApplicationDefine:
 11442              	.LFB27:
5282:../uvc.c      **** }
5283:../uvc.c      **** 
5284:../uvc.c      **** 
5285:../uvc.c      **** /*
5286:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
5287:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
5288:../uvc.c      ****  */
5289:../uvc.c      **** void
5290:../uvc.c      **** CyFxApplicationDefine (
5291:../uvc.c      ****         void)
5292:../uvc.c      **** {
 11443              		.loc 1 5292 0
 11444              		.cfi_startproc
 11445              		@ args = 0, pretend = 0, frame = 32
 11446              		@ frame_needed = 0, uses_anonymous_args = 0
 11447              	.LVL1301:
 11448 61c8 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 11449              	.LCFI30:
 11450              		.cfi_def_cfa_offset 32
 11451              		.cfi_offset 4, -32
 11452              		.cfi_offset 5, -28
 11453              		.cfi_offset 6, -24
 11454              		.cfi_offset 7, -20
 11455              		.cfi_offset 8, -16
 11456              		.cfi_offset 9, -12
 11457              		.cfi_offset 10, -8
 11458              		.cfi_offset 14, -4
5293:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
5294:../uvc.c      ****     uint32_t retThrdCreate;
5295:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
5296:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
5297:../uvc.c      **** 
5298:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
5299:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 11459              		.loc 1 5299 0
 11460 61cc 010AA0E3 		mov	r0, #4096
5292:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
 11461              		.loc 1 5292 0
 11462 61d0 40D04DE2 		sub	sp, sp, #64
 11463              	.LCFI31:
 11464              		.cfi_def_cfa_offset 96
 11465              		.loc 1 5299 0
 11466 61d4 FEFFFFEB 		bl	CyU3PMemAlloc
 11467              	.LVL1302:
 11468 61d8 0070A0E1 		mov	r7, r0
 11469              	.LVL1303:
5300:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 11470              		.loc 1 5300 0
 11471 61dc 010AA0E3 		mov	r0, #4096
 11472              	.LVL1304:
 11473 61e0 FEFFFFEB 		bl	CyU3PMemAlloc
 11474              	.LVL1305:
 11475 61e4 0060A0E1 		mov	r6, r0
 11476              	.LVL1306:
5301:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 11477              		.loc 1 5301 0
 11478 61e8 010AA0E3 		mov	r0, #4096
 11479              	.LVL1307:
 11480 61ec FEFFFFEB 		bl	CyU3PMemAlloc
 11481              	.LVL1308:
5302:../uvc.c      **** 
5303:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 11482              		.loc 1 5303 0
 11483 61f0 000056E3 		cmp	r6, #0
 11484 61f4 00005713 		cmpne	r7, #0
 11485 61f8 00A0A013 		movne	r10, #0
 11486 61fc 01A0A003 		moveq	r10, #1
5301:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 11487              		.loc 1 5301 0
 11488 6200 0090A0E1 		mov	r9, r0
 11489              	.LVL1309:
 11490              		.loc 1 5303 0
 11491 6204 0000001A 		bne	.L938
 11492              	.LVL1310:
 11493              	.L928:
 11494              	.L930:
 11495 6208 FEFFFFEA 		b	.L930
 11496              	.LVL1311:
 11497              	.L938:
 11498              		.loc 1 5303 0 is_stmt 0 discriminator 1
 11499 620c 000050E3 		cmp	r0, #0
 11500 6210 FCFFFF0A 		beq	.L928
 11501              	.LVL1312:
5304:../uvc.c      ****         goto fatalErrorHandler;
5305:../uvc.c      **** 
5306:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
5307:../uvc.c      ****     char *cmdName = "I2CcmdQue";
5308:../uvc.c      ****     char *staName = "I2CstaQue";
5309:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 11502              		.loc 1 5309 0 is_stmt 1
 11503 6214 F4309FE5 		ldr	r3, .L939
 11504 6218 20008DE2 		add	r0, sp, #32
 11505              	.LVL1313:
 11506 621c 00308DE5 		str	r3, [sp]
 11507 6220 4010A0E3 		mov	r1, #64
 11508 6224 E8209FE5 		ldr	r2, .L939+4
 11509 6228 0A30A0E1 		mov	r3, r10
 11510 622c FEFFFFEB 		bl	cmdbufCreate
 11511              	.LVL1314:
 11512 6230 20E08DE2 		add	lr, sp, #32
 11513 6234 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 11514 6238 D8C09FE5 		ldr	ip, .L939+8
5310:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
5311:../uvc.c      **** 	//VdRingBuf  cmdbufCreate(uint16_t size, char * name, uint8_t id, CyU3PMutex *muxPtr);
5312:../uvc.c      **** 
5313:../uvc.c      **** 	/****** initialize command descriptor ***********/
5314:../uvc.c      **** 	cmdquInit(cmdQuptr);
5315:../uvc.c      **** 	cmdquInit(statQuptr);
5316:../uvc.c      **** 
5317:../uvc.c      ****     /* Create the UVC application thread. */
5318:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 11515              		.loc 1 5318 0
 11516 623c 0840A0E3 		mov	r4, #8
5309:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 11517              		.loc 1 5309 0
 11518 6240 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 11519 6244 0F009EE8 		ldmia	lr, {r0, r1, r2, r3}
 11520              		.loc 1 5318 0
 11521 6248 0150A0E3 		mov	r5, #1
5309:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 11522              		.loc 1 5309 0
 11523 624c 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
5314:../uvc.c      **** 	cmdquInit(statQuptr);
 11524              		.loc 1 5314 0
 11525 6250 10004CE2 		sub	r0, ip, #16
 11526 6254 FEFFFFEB 		bl	cmdquInit
 11527              	.LVL1315:
5315:../uvc.c      **** 
 11528              		.loc 1 5315 0
 11529 6258 BC009FE5 		ldr	r0, .L939+12
 11530 625c FEFFFFEB 		bl	cmdquInit
 11531              	.LVL1316:
 11532              		.loc 1 5318 0
 11533 6260 A880A0E3 		mov	r8, #168
 11534 6264 012AA0E3 		mov	r2, #4096
 11535 6268 0A30A0E1 		mov	r3, r10
 11536 626c 14008DE9 		stmib	sp, {r2, r4}
 11537 6270 A8009FE5 		ldr	r0, .L939+16
 11538 6274 00708DE5 		str	r7, [sp]
 11539 6278 10A08DE5 		str	r10, [sp, #16]
 11540 627c 0C408DE5 		str	r4, [sp, #12]
 11541 6280 14508DE5 		str	r5, [sp, #20]
 11542 6284 18808DE5 		str	r8, [sp, #24]
 11543 6288 94109FE5 		ldr	r1, .L939+20
 11544 628c 94209FE5 		ldr	r2, .L939+24
 11545 6290 FEFFFFEB 		bl	_txe_thread_create
 11546              	.LVL1317:
5319:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
5320:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
5321:../uvc.c      ****             0,                                          /* No input parameter to thread */
5322:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
5323:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
5324:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
5325:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
5326:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
5327:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
5328:../uvc.c      ****             );
5329:../uvc.c      ****     if (retThrdCreate != 0)
 11547              		.loc 1 5329 0
 11548 6294 003050E2 		subs	r3, r0, #0
 11549 6298 DAFFFF1A 		bne	.L928
5330:../uvc.c      ****     {
5331:../uvc.c      ****         goto fatalErrorHandler;
5332:../uvc.c      ****     }
5333:../uvc.c      **** 
5334:../uvc.c      ****     /* Create the control request handling thread. */
5335:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 11550              		.loc 1 5335 0
 11551 629c 027BA0E3 		mov	r7, #2048
 11552              	.LVL1318:
 11553 62a0 10308DE5 		str	r3, [sp, #16]
 11554 62a4 00608DE5 		str	r6, [sp]
 11555 62a8 08408DE5 		str	r4, [sp, #8]
 11556 62ac 0C408DE5 		str	r4, [sp, #12]
 11557 62b0 14508DE5 		str	r5, [sp, #20]
 11558 62b4 18808DE5 		str	r8, [sp, #24]
 11559 62b8 04708DE5 		str	r7, [sp, #4]
 11560 62bc 68009FE5 		ldr	r0, .L939+28
 11561              	.LVL1319:
 11562 62c0 68109FE5 		ldr	r1, .L939+32
 11563 62c4 68209FE5 		ldr	r2, .L939+36
 11564 62c8 FEFFFFEB 		bl	_txe_thread_create
 11565              	.LVL1320:
5336:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
5337:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
5338:../uvc.c      ****             0,                                                  /* No input parameter to thread */
5339:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
5340:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
5341:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
5342:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
5343:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
5344:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
5345:../uvc.c      ****             );
5346:../uvc.c      ****     if (retThrdCreate != 0)
 11566              		.loc 1 5346 0
 11567 62cc 003050E2 		subs	r3, r0, #0
 11568 62d0 CCFFFF1A 		bne	.L928
5347:../uvc.c      ****     {
5348:../uvc.c      ****         goto fatalErrorHandler;
5349:../uvc.c      ****     }
5350:../uvc.c      **** #if 1
5351:../uvc.c      ****     /* Create the I2C control command handling thread. */
5352:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 11569              		.loc 1 5352 0
 11570 62d4 00908DE5 		str	r9, [sp]
 11571 62d8 04708DE5 		str	r7, [sp, #4]
 11572 62dc 08408DE5 		str	r4, [sp, #8]
 11573 62e0 0C408DE5 		str	r4, [sp, #12]
 11574 62e4 10308DE5 		str	r3, [sp, #16]
 11575 62e8 14508DE5 		str	r5, [sp, #20]
 11576 62ec 18808DE5 		str	r8, [sp, #24]
 11577 62f0 40009FE5 		ldr	r0, .L939+40
 11578              	.LVL1321:
 11579 62f4 40109FE5 		ldr	r1, .L939+44
 11580 62f8 40209FE5 		ldr	r2, .L939+48
 11581 62fc FEFFFFEB 		bl	_txe_thread_create
 11582              	.LVL1322:
5353:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
5354:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
5355:../uvc.c      ****             0,                                          /* No input parameter to thread */
5356:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
5357:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
5358:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
5359:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
5360:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
5361:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
5362:../uvc.c      ****             );
5363:../uvc.c      ****     if (retThrdCreate != 0)
 11583              		.loc 1 5363 0
 11584 6300 000050E3 		cmp	r0, #0
 11585 6304 BFFFFF1A 		bne	.L928
5364:../uvc.c      ****     {
5365:../uvc.c      ****         goto fatalErrorHandler;
5366:../uvc.c      ****     }
5367:../uvc.c      **** #endif
5368:../uvc.c      **** 
5369:../uvc.c      ****     return;
5370:../uvc.c      **** 
5371:../uvc.c      **** fatalErrorHandler:
5372:../uvc.c      ****     /* Add custom recovery or debug actions here */
5373:../uvc.c      ****     /* Loop indefinitely */
5374:../uvc.c      ****     while (1);
5375:../uvc.c      **** }
 11586              		.loc 1 5375 0
 11587 6308 40D08DE2 		add	sp, sp, #64
 11588              		@ sp needed
 11589 630c F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, pc}
 11590              	.LVL1323:
 11591              	.L940:
 11592              		.align	2
 11593              	.L939:
 11594 6310 00000000 		.word	cmdQuMux
 11595 6314 840E0000 		.word	.LC83
 11596 6318 00000000 		.word	cmdQu
 11597 631c 00000000 		.word	statQu
 11598 6320 A4000000 		.word	.LANCHOR0+164
 11599 6324 900E0000 		.word	.LC84
 11600 6328 00000000 		.word	UVCAppThread_Entry
 11601 632c 4C010000 		.word	.LANCHOR0+332
 11602 6330 A40E0000 		.word	.LC85
 11603 6334 00000000 		.word	UVCAppEP0Thread_Entry
 11604 6338 F4010000 		.word	.LANCHOR0+500
 11605 633c BC0E0000 		.word	.LC86
 11606 6340 00000000 		.word	I2cAppThread_Entry
 11607              		.cfi_endproc
 11608              	.LFE27:
 11610              		.section	.text.startup,"ax",%progbits
 11611              		.align	2
 11612              		.global	main
 11614              	main:
 11615              	.LFB28:
5376:../uvc.c      **** 
5377:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
5378:../uvc.c      ****  * the ThreadX RTOS here.
5379:../uvc.c      ****  */
5380:../uvc.c      **** int
5381:../uvc.c      **** main (
5382:../uvc.c      ****         void)
5383:../uvc.c      **** {
 11616              		.loc 1 5383 0
 11617              		.cfi_startproc
 11618              		@ args = 0, pretend = 0, frame = 56
 11619              		@ frame_needed = 0, uses_anonymous_args = 0
 11620 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 11621              	.LCFI32:
 11622              		.cfi_def_cfa_offset 12
 11623              		.cfi_offset 4, -12
 11624              		.cfi_offset 5, -8
 11625              		.cfi_offset 14, -4
 11626 0004 3CD04DE2 		sub	sp, sp, #60
 11627              	.LCFI33:
 11628              		.cfi_def_cfa_offset 72
5384:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
5385:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
5386:../uvc.c      **** 
5387:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
5388:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
5389:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 11629              		.loc 1 5389 0
 11630 0008 0230A0E3 		mov	r3, #2
5390:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
5391:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
5392:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 11631              		.loc 1 5392 0
 11632 000c 0010A0E3 		mov	r1, #0
5393:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 11633              		.loc 1 5393 0
 11634 0010 0320A0E3 		mov	r2, #3
5388:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 11635              		.loc 1 5388 0
 11636 0014 0150A0E3 		mov	r5, #1
5394:../uvc.c      **** 
5395:../uvc.c      ****     /* Initialize the device */
5396:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 11637              		.loc 1 5396 0
 11638 0018 0D00A0E1 		mov	r0, sp
5388:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 11639              		.loc 1 5388 0
 11640 001c 00508DE5 		str	r5, [sp]
5389:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 11641              		.loc 1 5389 0
 11642 0020 0430CDE5 		strb	r3, [sp, #4]
5390:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 11643              		.loc 1 5390 0
 11644 0024 0530CDE5 		strb	r3, [sp, #5]
5391:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 11645              		.loc 1 5391 0
 11646 0028 0630CDE5 		strb	r3, [sp, #6]
5392:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 11647              		.loc 1 5392 0
 11648 002c 08108DE5 		str	r1, [sp, #8]
5393:../uvc.c      **** 
 11649              		.loc 1 5393 0
 11650 0030 0C20CDE5 		strb	r2, [sp, #12]
 11651              		.loc 1 5396 0
 11652 0034 FEFFFFEB 		bl	CyU3PDeviceInit
 11653              	.LVL1324:
5397:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 11654              		.loc 1 5397 0
 11655 0038 004050E2 		subs	r4, r0, #0
 11656 003c 0000000A 		beq	.L946
 11657              	.L942:
 11658              	.L943:
 11659 0040 FEFFFFEA 		b	.L943
 11660              	.L946:
5398:../uvc.c      ****     {
5399:../uvc.c      ****         goto handle_fatal_error;
5400:../uvc.c      ****     }
5401:../uvc.c      **** 
5402:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
5403:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 11661              		.loc 1 5403 0
 11662 0044 0410A0E1 		mov	r1, r4
 11663 0048 0420A0E1 		mov	r2, r4
 11664 004c 0500A0E1 		mov	r0, r5
 11665              	.LVL1325:
 11666 0050 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 11667              	.LVL1326:
5404:../uvc.c      **** 
5405:../uvc.c      ****     /* Configure the IO matrix for the device. */
5406:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
5407:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
5408:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
5409:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
5410:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
5411:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
5412:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
5413:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
5414:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
5415:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
5416:../uvc.c      **** 
5417:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 11668              		.loc 1 5417 0
 11669 0054 10008DE2 		add	r0, sp, #16
5407:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 11670              		.loc 1 5407 0
 11671 0058 2640CDE5 		strb	r4, [sp, #38]
5408:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 11672              		.loc 1 5408 0
 11673 005c 28408DE5 		str	r4, [sp, #40]
5409:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 11674              		.loc 1 5409 0
 11675 0060 2C408DE5 		str	r4, [sp, #44]
5410:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 11676              		.loc 1 5410 0
 11677 0064 30408DE5 		str	r4, [sp, #48]
5411:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 11678              		.loc 1 5411 0
 11679 0068 34408DE5 		str	r4, [sp, #52]
5414:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 11680              		.loc 1 5414 0
 11681 006c 1C408DE5 		str	r4, [sp, #28]
5415:../uvc.c      **** 
 11682              		.loc 1 5415 0
 11683 0070 20408DE5 		str	r4, [sp, #32]
5406:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 11684              		.loc 1 5406 0
 11685 0074 10508DE5 		str	r5, [sp, #16]
5412:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 11686              		.loc 1 5412 0
 11687 0078 14508DE5 		str	r5, [sp, #20]
5413:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 11688              		.loc 1 5413 0
 11689 007c 18508DE5 		str	r5, [sp, #24]
 11690              		.loc 1 5417 0
 11691 0080 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 11692              	.LVL1327:
5418:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 11693              		.loc 1 5418 0
 11694 0084 004050E2 		subs	r4, r0, #0
 11695 0088 ECFFFF1A 		bne	.L942
5419:../uvc.c      ****     {
5420:../uvc.c      ****         goto handle_fatal_error;
5421:../uvc.c      ****     }
5422:../uvc.c      **** 
5423:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
5424:../uvc.c      ****     CyU3PKernelEntry ();
 11696              		.loc 1 5424 0
 11697 008c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 11698              	.LVL1328:
5425:../uvc.c      **** 
5426:../uvc.c      ****     /* Dummy return to make the compiler happy */
5427:../uvc.c      ****     return 0;
5428:../uvc.c      **** 
5429:../uvc.c      **** handle_fatal_error:
5430:../uvc.c      ****     /* Cannot recover from this error. */
5431:../uvc.c      ****     while (1);
5432:../uvc.c      **** }
 11699              		.loc 1 5432 0
 11700 0090 0400A0E1 		mov	r0, r4
 11701 0094 3CD08DE2 		add	sp, sp, #60
 11702              		@ sp needed
 11703 0098 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 11704              		.cfi_endproc
 11705              	.LFE28:
 11707              		.comm	I2CCmdTimer,44,4
 11708              		.comm	posTick,4,4
 11709              		.global	glUVCHeader
 11710              		.global	glProbeStilCtrl20
 11711              		.global	glProbeCtrl20
 11712              		.global	glProbeStilCtrl
 11713              		.global	glProbeCtrlFull
 11714              		.global	glProbeCtrl
 11715              		.global	streamingStarted
 11716              		.global	clearFeatureRqtReceived
 11717              		.global	usbSpeed
 11718              		.global	isUsbConnected
 11719              		.global	pbcpbak
 11720              		.global	pbcbak
 11721              		.global	pbbak
 11722              		.global	fbbak
 11723              		.global	pbc
 11724              		.global	pb
 11725              		.global	fb
 11726              		.comm	wLength,2,2
 11727              		.comm	wIndex,2,2
 11728              		.comm	wValue,2,2
 11729              		.comm	bRequest,1,1
 11730              		.comm	bmReqType,1,1
 11731              		.comm	imgHdMux,56,4
 11732              		.comm	timMux,56,4
 11733              		.comm	staQuMux,56,4
 11734              		.comm	cmdQuMux,56,4
 11735              		.comm	statQu,32,4
 11736              		.comm	cmdQu,32,4
 11737              		.global	testSnap
 11738              		.global	snapButFlag
 11739              		.comm	glInterStaBuffer,4,4
 11740              		.comm	glChHandleInterStat,172,4
 11741              		.comm	glChHandleStillStream,232,4
 11742              		.comm	glChHandleUVCStream,232,4
 11743              		.global	CyFxGpifConfig_usb2
 11744              		.global	CyFxGpifRegValue_usb2
 11745              		.global	CyFxGpifWavedataPosition_usb2
 11746              		.global	CyFxGpifWavedata_usb2
 11747              		.global	CyFxGpifTransition_usb2
 11748              		.global	CyFxGpifConfig
 11749              		.global	CyFxGpifRegValue
 11750              		.global	CyFxGpifWavedataPosition
 11751              		.global	CyFxGpifWavedata
 11752              		.global	CyFxGpifTransition
 11753              		.section	.rodata
 11754              		.align	2
 11755              		.set	.LANCHOR2,. + 0
 11758              	ShutSp:
 11759 0000 3582     		.short	-32203
 11760 0002 1B41     		.short	16667
 11761 0004 8D20     		.short	8333
 11762 0006 A00F     		.short	4000
 11763 0008 D007     		.short	2000
 11764 000a E803     		.short	1000
 11765 000c F401     		.short	500
 11766 000e C800     		.short	200
 11767 0010 6400     		.short	100
 11768 0012 0A00     		.short	10
 11769 0014 0000     		.short	0
 11770 0016 00000000 		.space	10
 11770      00000000 
 11770      0000
 11773              	pEXTSenCtrl:
 11774 0020 B0050000 		.word	EXTShutter
 11775 0024 10090000 		.word	EXTSensUp
 11776 0028 FC080000 		.word	EXTMirror
 11777 002c E8080000 		.word	EXT3DnoiseReduceMode
 11778 0030 D4080000 		.word	EXT3DNoiseLev
 11779 0034 C0080000 		.word	EXTDayNightMode
 11780 0038 AC080000 		.word	EXTDayNightdely
 11781 003c 98080000 		.word	EXTDayNightlev
 11782 0040 84080000 		.word	EXTNightDaylev
 11783 0044 0C050000 		.word	EXTAexModGainlev
 11784 0048 70080000 		.word	EXTExpReflev
 11785 004c C4050000 		.word	EXTShutlev
 11786 0050 5C080000 		.word	EXTCamMode
 11787 0054 00000000 		.word	0
 11788 0058 48080000 		.word	EXTSensorPare
 11789 005c 34080000 		.word	EXTI2Ccmd
 11790 0060 00000000 		.word	0
 11791 0064 00000000 		.word	0
 11792 0068 00000000 		.word	0
 11793 006c 00000000 		.word	0
 11794 0070 34050000 		.word	EXTBLCWinPos
 11795 0074 20080000 		.word	EXTBLCWeight
 11796 0078 F8040000 		.word	EXTBLCGrid
 11797 007c 80070000 		.word	EXTExHyster
 11798 0080 20050000 		.word	EXTExCtrlSped
 11799 0084 0C080000 		.word	EXTEnhanceMode
 11800 0088 F8070000 		.word	EXTEnhanceGain
 11801 008c E4070000 		.word	EXTEnhanceSTED
 11802 0090 D0070000 		.word	EXT2DNRGain
 11803 0094 BC070000 		.word	EXT2DNRSTED
 11804 0098 A8070000 		.word	EXTGammaCor
 11805 009c 94070000 		.word	EXTAGCMaxLimit
 11806 00a0 00000000 		.word	0
 11807 00a4 00000000 		.space	124
 11807      00000000 
 11807      00000000 
 11807      00000000 
 11807      00000000 
 11810              	pPUCSenCtrl:
 11811 0120 9C050000 		.word	PUCBLC
 11812 0124 48050000 		.word	PUCBright
 11813 0128 4C090000 		.word	PUCContrast
 11814 012c 00000000 		.word	0
 11815 0130 70050000 		.word	PUCPLFreq
 11816 0134 5C050000 		.word	PUCHueC
 11817 0138 38090000 		.word	PUCSaturation
 11818 013c 88050000 		.word	PUCSharp
 11819 0140 00000000 		.word	0
 11820 0144 58070000 		.word	PUCWBMd
 11821 0148 00000000 		.word	0
 11822 014c 6C070000 		.word	PUCWBLC
 11823 0150 00000000 		.word	0
 11824 0154 00000000 		.word	0
 11825 0158 24090000 		.word	PUCDZoom
 11826 015c 00000000 		.word	0
 11829              	curFlag:
 11830 0160 00000000 		.space	64
 11830      00000000 
 11830      00000000 
 11830      00000000 
 11830      00000000 
 11833              	CyFxGpifConfig:
 11834 01a0 0F00     		.short	15
 11835 01a2 0000     		.space	2
 11836 01a4 00000000 		.word	CyFxGpifWavedata
 11837 01a8 00000000 		.word	CyFxGpifWavedataPosition
 11838 01ac 0500     		.short	5
 11839 01ae 0000     		.space	2
 11840 01b0 00000000 		.word	CyFxGpifTransition
 11841 01b4 4C00     		.short	76
 11842 01b6 0000     		.space	2
 11843 01b8 00000000 		.word	CyFxGpifRegValue
 11846              	CyFxGpifConfig_usb2:
 11847 01bc 9300     		.short	147
 11848 01be 0000     		.space	2
 11849 01c0 00000000 		.word	CyFxGpifWavedata_usb2
 11850 01c4 00000000 		.word	CyFxGpifWavedataPosition_usb2
 11851 01c8 0800     		.short	8
 11852 01ca 0000     		.space	2
 11853 01cc 00000000 		.word	CyFxGpifTransition_usb2
 11854 01d0 4C00     		.short	76
 11855 01d2 0000     		.space	2
 11856 01d4 00000000 		.word	CyFxGpifRegValue_usb2
 11857              		.data
 11858              		.align	2
 11859              		.set	.LANCHOR1,. + 0
 11862              	glProbeCtrlFull:
 11863 0000 00       		.byte	0
 11864 0001 00       		.byte	0
 11865 0002 01       		.byte	1
 11866 0003 01       		.byte	1
 11867 0004 15       		.byte	21
 11868 0005 16       		.byte	22
 11869 0006 05       		.byte	5
 11870 0007 00       		.byte	0
 11871 0008 00       		.byte	0
 11872 0009 00       		.byte	0
 11873 000a 00       		.byte	0
 11874 000b 00       		.byte	0
 11875 000c 00       		.byte	0
 11876 000d 00       		.byte	0
 11877 000e 00       		.byte	0
 11878 000f 00       		.byte	0
 11879 0010 00       		.byte	0
 11880 0011 00       		.byte	0
 11881 0012 00       		.byte	0
 11882 0013 C6       		.byte	-58
 11883 0014 99       		.byte	-103
 11884 0015 00       		.byte	0
 11885 0016 00       		.byte	0
 11886 0017 40       		.byte	64
 11887 0018 00       		.byte	0
 11888 0019 00       		.byte	0
 11889 001a 0000     		.space	2
 11892              	glProbeCtrl20:
 11893 001c 00       		.byte	0
 11894 001d 00       		.byte	0
 11895 001e 01       		.byte	1
 11896 001f 01       		.byte	1
 11897 0020 80       		.byte	-128
 11898 0021 1A       		.byte	26
 11899 0022 06       		.byte	6
 11900 0023 00       		.byte	0
 11901 0024 00       		.byte	0
 11902 0025 00       		.byte	0
 11903 0026 00       		.byte	0
 11904 0027 00       		.byte	0
 11905 0028 00       		.byte	0
 11906 0029 00       		.byte	0
 11907 002a 00       		.byte	0
 11908 002b 00       		.byte	0
 11909 002c 00       		.byte	0
 11910 002d 00       		.byte	0
 11911 002e 00       		.byte	0
 11912 002f D2       		.byte	-46
 11913 0030 0F       		.byte	15
 11914 0031 00       		.byte	0
 11915 0032 00       		.byte	0
 11916 0033 40       		.byte	64
 11917 0034 00       		.byte	0
 11918 0035 00       		.byte	0
 11919 0036 0000     		.space	2
 11922              	glProbeCtrl:
 11923 0038 00       		.byte	0
 11924 0039 00       		.byte	0
 11925 003a 01       		.byte	1
 11926 003b 01       		.byte	1
 11927 003c 15       		.byte	21
 11928 003d 16       		.byte	22
 11929 003e 05       		.byte	5
 11930 003f 00       		.byte	0
 11931 0040 00       		.byte	0
 11932 0041 00       		.byte	0
 11933 0042 00       		.byte	0
 11934 0043 00       		.byte	0
 11935 0044 00       		.byte	0
 11936 0045 00       		.byte	0
 11937 0046 00       		.byte	0
 11938 0047 00       		.byte	0
 11939 0048 00       		.byte	0
 11940 0049 00       		.byte	0
 11941 004a 00       		.byte	0
 11942 004b 48       		.byte	72
 11943 004c 3F       		.byte	63
 11944 004d 00       		.byte	0
 11945 004e 00       		.byte	0
 11946 004f 40       		.byte	64
 11947 0050 00       		.byte	0
 11948 0051 00       		.byte	0
 11951              	ROIMode:
 11952 0052 01       		.byte	1
 11953 0053 00       		.space	1
 11956              	glProbeStilCtrl:
 11957 0054 01       		.byte	1
 11958 0055 02       		.byte	2
 11959 0056 00       		.byte	0
 11960 0057 00       		.byte	0
 11961 0058 C6       		.byte	-58
 11962 0059 99       		.byte	-103
 11963 005a 00       		.byte	0
 11964 005b 00       		.byte	0
 11965 005c 40       		.byte	64
 11966 005d 00       		.byte	0
 11967 005e 00       		.byte	0
 11968 005f 00       		.space	1
 11971              	glProbeStilCtrl20:
 11972 0060 01       		.byte	1
 11973 0061 01       		.byte	1
 11974 0062 00       		.byte	0
 11975 0063 00       		.byte	0
 11976 0064 D2       		.byte	-46
 11977 0065 0F       		.byte	15
 11978 0066 00       		.byte	0
 11979 0067 00       		.byte	0
 11980 0068 40       		.byte	64
 11981 0069 00       		.byte	0
 11982 006a 00       		.byte	0
 11983 006b 00       		.space	1
 11986              	ExUCtrlParArry:
 11987 006c 00       		.byte	0
 11988 006d 00       		.byte	0
 11989 006e 04       		.byte	4
 11990 006f 01       		.byte	1
 11991 0070 00       		.byte	0
 11992 0071 38       		.byte	56
 11993 0072 01       		.byte	1
 11994 0073 01       		.byte	1
 11995 0074 00       		.byte	0
 11996 0075 03       		.byte	3
 11997 0076 00       		.byte	0
 11998 0077 4E       		.byte	78
 11999 0078 00       		.byte	0
 12000 0079 4E       		.byte	78
 12001 007a 00       		.byte	0
 12002 007b 30       		.byte	48
 12003 007c 01       		.byte	1
 12004 007d 00       		.byte	0
 12005 007e 00       		.byte	0
 12006 007f 00000000 		.space	5
 12006      00
 12007 0084 00       		.byte	0
 12008 0085 00       		.byte	0
 12009 0086 01       		.byte	1
 12010 0087 00       		.byte	0
 12011 0088 00       		.byte	0
 12012 0089 00       		.byte	0
 12013 008a 00       		.byte	0
 12014 008b 01       		.byte	1
 12015 008c 00       		.byte	0
 12016 008d 03       		.byte	3
 12017 008e 00       		.byte	0
 12018 008f 00       		.byte	0
 12019 0090 00       		.byte	0
 12020 0091 00       		.byte	0
 12021 0092 00       		.byte	0
 12022 0093 30       		.byte	48
 12023 0094 01       		.byte	1
 12024 0095 00       		.byte	0
 12025 0096 00       		.byte	0
 12026 0097 00000000 		.space	5
 12026      00
 12027 009c 00       		.byte	0
 12028 009d 00       		.byte	0
 12029 009e 02       		.byte	2
 12030 009f 00       		.byte	0
 12031 00a0 00       		.byte	0
 12032 00a1 FF       		.byte	-1
 12033 00a2 00       		.byte	0
 12034 00a3 01       		.byte	1
 12035 00a4 00       		.byte	0
 12036 00a5 03       		.byte	3
 12037 00a6 00       		.byte	0
 12038 00a7 01       		.byte	1
 12039 00a8 00       		.byte	0
 12040 00a9 00       		.byte	0
 12041 00aa 00       		.byte	0
 12042 00ab 30       		.byte	48
 12043 00ac 01       		.byte	1
 12044 00ad 01       		.byte	1
 12045 00ae 00       		.byte	0
 12046 00af 00000000 		.space	5
 12046      00
 12047 00b4 00       		.byte	0
 12048 00b5 00       		.byte	0
 12049 00b6 02       		.byte	2
 12050 00b7 00       		.byte	0
 12051 00b8 00       		.byte	0
 12052 00b9 00       		.byte	0
 12053 00ba 00       		.byte	0
 12054 00bb 00       		.byte	0
 12055 00bc 00       		.byte	0
 12056 00bd 03       		.byte	3
 12057 00be 00       		.byte	0
 12058 00bf 00       		.byte	0
 12059 00c0 00       		.byte	0
 12060 00c1 00       		.byte	0
 12061 00c2 00       		.byte	0
 12062 00c3 30       		.byte	48
 12063 00c4 01       		.byte	1
 12064 00c5 01       		.byte	1
 12065 00c6 00       		.byte	0
 12066 00c7 00000000 		.space	5
 12066      00
 12067 00cc 13       		.byte	19
 12068 00cd 14       		.byte	20
 12069 00ce 02       		.byte	2
 12070 00cf 00       		.byte	0
 12071 00d0 00       		.byte	0
 12072 00d1 FF       		.byte	-1
 12073 00d2 FF       		.byte	-1
 12074 00d3 01       		.byte	1
 12075 00d4 00       		.byte	0
 12076 00d5 03       		.byte	3
 12077 00d6 00       		.byte	0
 12078 00d7 66       		.byte	102
 12079 00d8 66       		.byte	102
 12080 00d9 66       		.byte	102
 12081 00da 66       		.byte	102
 12082 00db 30       		.byte	48
 12083 00dc 01       		.byte	1
 12084 00dd 00       		.byte	0
 12085 00de 00       		.byte	0
 12086 00df 00000000 		.space	5
 12086      00
 12087 00e4 11       		.byte	17
 12088 00e5 00       		.byte	0
 12089 00e6 02       		.byte	2
 12090 00e7 01       		.byte	1
 12091 00e8 00       		.byte	0
 12092 00e9 03       		.byte	3
 12093 00ea 00       		.byte	0
 12094 00eb 01       		.byte	1
 12095 00ec 00       		.byte	0
 12096 00ed 03       		.byte	3
 12097 00ee 00       		.byte	0
 12098 00ef 80       		.byte	-128
 12099 00f0 00       		.byte	0
 12100 00f1 80       		.byte	-128
 12101 00f2 00       		.byte	0
 12102 00f3 30       		.byte	48
 12103 00f4 01       		.byte	1
 12104 00f5 01       		.byte	1
 12105 00f6 00       		.byte	0
 12106 00f7 00000000 		.space	5
 12106      00
 12107 00fc 10       		.byte	16
 12108 00fd 00       		.byte	0
 12109 00fe 01       		.byte	1
 12110 00ff 01       		.byte	1
 12111 0100 00       		.byte	0
 12112 0101 02       		.byte	2
 12113 0102 00       		.byte	0
 12114 0103 01       		.byte	1
 12115 0104 00       		.byte	0
 12116 0105 03       		.byte	3
 12117 0106 00       		.byte	0
 12118 0107 00       		.byte	0
 12119 0108 00       		.byte	0
 12120 0109 00       		.byte	0
 12121 010a 00       		.byte	0
 12122 010b 30       		.byte	48
 12123 010c 01       		.byte	1
 12124 010d 01       		.byte	1
 12125 010e 00       		.byte	0
 12126 010f 00000000 		.space	5
 12126      00
 12127 0114 00       		.byte	0
 12128 0115 00       		.byte	0
 12129 0116 04       		.byte	4
 12130 0117 01       		.byte	1
 12131 0118 00       		.byte	0
 12132 0119 38       		.byte	56
 12133 011a 01       		.byte	1
 12134 011b 01       		.byte	1
 12135 011c 00       		.byte	0
 12136 011d 03       		.byte	3
 12137 011e 00       		.byte	0
 12138 011f 4E       		.byte	78
 12139 0120 00       		.byte	0
 12140 0121 4E       		.byte	78
 12141 0122 00       		.byte	0
 12142 0123 30       		.byte	48
 12143 0124 01       		.byte	1
 12144 0125 00       		.byte	0
 12145 0126 00       		.byte	0
 12146 0127 00000000 		.space	5
 12146      00
 12147 012c 00       		.byte	0
 12148 012d 00       		.byte	0
 12149 012e 01       		.byte	1
 12150 012f 00       		.byte	0
 12151 0130 00       		.byte	0
 12152 0131 00       		.byte	0
 12153 0132 00       		.byte	0
 12154 0133 01       		.byte	1
 12155 0134 00       		.byte	0
 12156 0135 03       		.byte	3
 12157 0136 00       		.byte	0
 12158 0137 00       		.byte	0
 12159 0138 00       		.byte	0
 12160 0139 00       		.byte	0
 12161 013a 00       		.byte	0
 12162 013b 30       		.byte	48
 12163 013c 01       		.byte	1
 12164 013d 00       		.byte	0
 12165 013e 00       		.byte	0
 12166 013f 00000000 		.space	5
 12166      00
 12167 0144 00       		.byte	0
 12168 0145 00       		.byte	0
 12169 0146 02       		.byte	2
 12170 0147 00       		.byte	0
 12171 0148 00       		.byte	0
 12172 0149 05       		.byte	5
 12173 014a 00       		.byte	0
 12174 014b 01       		.byte	1
 12175 014c 00       		.byte	0
 12176 014d 03       		.byte	3
 12177 014e 00       		.byte	0
 12178 014f 00       		.byte	0
 12179 0150 00       		.byte	0
 12180 0151 00       		.byte	0
 12181 0152 00       		.byte	0
 12182 0153 30       		.byte	48
 12183 0154 01       		.byte	1
 12184 0155 00       		.byte	0
 12185 0156 00       		.byte	0
 12186 0157 00000000 		.space	5
 12186      00
 12187 015c 00       		.byte	0
 12188 015d 00       		.byte	0
 12189 015e 03       		.byte	3
 12190 015f 00       		.byte	0
 12191 0160 00       		.byte	0
 12192 0161 0A       		.byte	10
 12193 0162 00       		.byte	0
 12194 0163 01       		.byte	1
 12195 0164 00       		.byte	0
 12196 0165 03       		.byte	3
 12197 0166 00       		.byte	0
 12198 0167 00       		.byte	0
 12199 0168 00       		.byte	0
 12200 0169 00       		.byte	0
 12201 016a 00       		.byte	0
 12202 016b 30       		.byte	48
 12203 016c 01       		.byte	1
 12204 016d 00       		.byte	0
 12205 016e 00       		.byte	0
 12206 016f 00000000 		.space	5
 12206      00
 12207 0174 00       		.byte	0
 12208 0175 00       		.byte	0
 12209 0176 02       		.byte	2
 12210 0177 00       		.byte	0
 12211 0178 00       		.byte	0
 12212 0179 40       		.byte	64
 12213 017a 00       		.byte	0
 12214 017b 01       		.byte	1
 12215 017c 00       		.byte	0
 12216 017d 03       		.byte	3
 12217 017e 00       		.byte	0
 12218 017f 0F       		.byte	15
 12219 0180 11       		.byte	17
 12220 0181 00       		.byte	0
 12221 0182 00       		.byte	0
 12222 0183 30       		.byte	48
 12223 0184 01       		.byte	1
 12224 0185 00       		.byte	0
 12225 0186 00       		.byte	0
 12226 0187 00000000 		.space	5
 12226      00
 12227 018c 00       		.byte	0
 12228 018d 00       		.byte	0
 12229 018e 02       		.byte	2
 12230 018f 00       		.byte	0
 12231 0190 00       		.byte	0
 12232 0191 64       		.byte	100
 12233 0192 00       		.byte	0
 12234 0193 01       		.byte	1
 12235 0194 00       		.byte	0
 12236 0195 03       		.byte	3
 12237 0196 00       		.byte	0
 12238 0197 00       		.byte	0
 12239 0198 00       		.byte	0
 12240 0199 00       		.byte	0
 12241 019a 00       		.byte	0
 12242 019b 30       		.byte	48
 12243 019c 01       		.byte	1
 12244 019d 00       		.byte	0
 12245 019e 00       		.byte	0
 12246 019f 00000000 		.space	5
 12246      00
 12247 01a4 00       		.byte	0
 12248 01a5 00       		.byte	0
 12249 01a6 02       		.byte	2
 12250 01a7 00       		.byte	0
 12251 01a8 00       		.byte	0
 12252 01a9 64       		.byte	100
 12253 01aa 00       		.byte	0
 12254 01ab 01       		.byte	1
 12255 01ac 00       		.byte	0
 12256 01ad 03       		.byte	3
 12257 01ae 00       		.byte	0
 12258 01af 00       		.byte	0
 12259 01b0 00       		.byte	0
 12260 01b1 00       		.byte	0
 12261 01b2 00       		.byte	0
 12262 01b3 30       		.byte	48
 12263 01b4 01       		.byte	1
 12264 01b5 00       		.byte	0
 12265 01b6 00       		.byte	0
 12266 01b7 00000000 		.space	5
 12266      00
 12267 01bc 00       		.byte	0
 12268 01bd 00       		.byte	0
 12269 01be 02       		.byte	2
 12270 01bf 00       		.byte	0
 12271 01c0 00       		.byte	0
 12272 01c1 64       		.byte	100
 12273 01c2 00       		.byte	0
 12274 01c3 01       		.byte	1
 12275 01c4 00       		.byte	0
 12276 01c5 03       		.byte	3
 12277 01c6 00       		.byte	0
 12278 01c7 00       		.byte	0
 12279 01c8 00       		.byte	0
 12280 01c9 00       		.byte	0
 12281 01ca 00       		.byte	0
 12282 01cb 30       		.byte	48
 12283 01cc 01       		.byte	1
 12284 01cd 00       		.byte	0
 12285 01ce 00       		.byte	0
 12286 01cf 00000000 		.space	5
 12286      00
 12287 01d4 00       		.byte	0
 12288 01d5 00       		.byte	0
 12289 01d6 02       		.byte	2
 12290 01d7 00       		.byte	0
 12291 01d8 00       		.byte	0
 12292 01d9 64       		.byte	100
 12293 01da 00       		.byte	0
 12294 01db 01       		.byte	1
 12295 01dc 00       		.byte	0
 12296 01dd 03       		.byte	3
 12297 01de 00       		.byte	0
 12298 01df 00       		.byte	0
 12299 01e0 00       		.byte	0
 12300 01e1 00       		.byte	0
 12301 01e2 00       		.byte	0
 12302 01e3 30       		.byte	48
 12303 01e4 01       		.byte	1
 12304 01e5 00       		.byte	0
 12305 01e6 00       		.byte	0
 12306 01e7 00000000 		.space	5
 12306      00
 12309              	CtrlParArry:
 12310 01ec 10       		.byte	16
 12311 01ed 10       		.byte	16
 12312 01ee 02       		.byte	2
 12313 01ef 00       		.byte	0
 12314 01f0 00       		.byte	0
 12315 01f1 03       		.byte	3
 12316 01f2 00       		.byte	0
 12317 01f3 01       		.byte	1
 12318 01f4 00       		.byte	0
 12319 01f5 03       		.byte	3
 12320 01f6 00       		.byte	0
 12321 01f7 03       		.byte	3
 12322 01f8 00       		.byte	0
 12323 01f9 03       		.byte	3
 12324 01fa 00       		.byte	0
 12325 01fb 30       		.byte	48
 12326 01fc 01       		.byte	1
 12327 01fd 00       		.byte	0
 12328 01fe 00       		.byte	0
 12329 01ff 00000000 		.space	5
 12329      00
 12330 0204 15       		.byte	21
 12331 0205 15       		.byte	21
 12332 0206 02       		.byte	2
 12333 0207 00       		.byte	0
 12334 0208 00       		.byte	0
 12335 0209 FF       		.byte	-1
 12336 020a 00       		.byte	0
 12337 020b 01       		.byte	1
 12338 020c 00       		.byte	0
 12339 020d 03       		.byte	3
 12340 020e 00       		.byte	0
 12341 020f 76       		.byte	118
 12342 0210 00       		.byte	0
 12343 0211 76       		.byte	118
 12344 0212 C7       		.byte	-57
 12345 0213 30       		.byte	48
 12346 0214 01       		.byte	1
 12347 0215 01       		.byte	1
 12348 0216 00       		.byte	0
 12349 0217 00000000 		.space	5
 12349      00
 12350 021c 04       		.byte	4
 12351 021d 04       		.byte	4
 12352 021e 02       		.byte	2
 12353 021f 00       		.byte	0
 12354 0220 00       		.byte	0
 12355 0221 FF       		.byte	-1
 12356 0222 00       		.byte	0
 12357 0223 01       		.byte	1
 12358 0224 00       		.byte	0
 12359 0225 03       		.byte	3
 12360 0226 00       		.byte	0
 12361 0227 70       		.byte	112
 12362 0228 00       		.byte	0
 12363 0229 70       		.byte	112
 12364 022a 00       		.byte	0
 12365 022b 30       		.byte	48
 12366 022c 01       		.byte	1
 12367 022d 01       		.byte	1
 12368 022e 00       		.byte	0
 12369 022f 00000000 		.space	5
 12369      00
 12370 0234 00       		.byte	0
 12371 0235 00       		.byte	0
 12372 0236 02       		.byte	2
 12373 0237 00       		.byte	0
 12374 0238 00       		.byte	0
 12375 0239 64       		.byte	100
 12376 023a 00       		.byte	0
 12377 023b 01       		.byte	1
 12378 023c 00       		.byte	0
 12379 023d 03       		.byte	3
 12380 023e 00       		.byte	0
 12381 023f 00       		.byte	0
 12382 0240 00       		.byte	0
 12383 0241 00       		.byte	0
 12384 0242 00       		.byte	0
 12385 0243 30       		.byte	48
 12386 0244 01       		.byte	1
 12387 0245 00       		.byte	0
 12388 0246 00       		.byte	0
 12389 0247 00000000 		.space	5
 12389      00
 12390 024c 07       		.byte	7
 12391 024d 07       		.byte	7
 12392 024e 02       		.byte	2
 12393 024f 00       		.byte	0
 12394 0250 00       		.byte	0
 12395 0251 01       		.byte	1
 12396 0252 00       		.byte	0
 12397 0253 01       		.byte	1
 12398 0254 00       		.byte	0
 12399 0255 03       		.byte	3
 12400 0256 00       		.byte	0
 12401 0257 01       		.byte	1
 12402 0258 00       		.byte	0
 12403 0259 01       		.byte	1
 12404 025a 00       		.byte	0
 12405 025b 30       		.byte	48
 12406 025c 01       		.byte	1
 12407 025d 00       		.byte	0
 12408 025e 00       		.byte	0
 12409 025f 00000000 		.space	5
 12409      00
 12410 0264 DF       		.byte	-33
 12411 0265 E1       		.byte	-31
 12412 0266 02       		.byte	2
 12413 0267 00       		.byte	0
 12414 0268 00       		.byte	0
 12415 0269 FF       		.byte	-1
 12416 026a 00       		.byte	0
 12417 026b 01       		.byte	1
 12418 026c 00       		.byte	0
 12419 026d 03       		.byte	3
 12420 026e 00       		.byte	0
 12421 026f 80       		.byte	-128
 12422 0270 00       		.byte	0
 12423 0271 00       		.byte	0
 12424 0272 00       		.byte	0
 12425 0273 C6       		.byte	-58
 12426 0274 01       		.byte	1
 12427 0275 01       		.byte	1
 12428 0276 00       		.byte	0
 12429 0277 00000000 		.space	5
 12429      00
 12430 027c 85       		.byte	-123
 12431 027d 86       		.byte	-122
 12432 027e 02       		.byte	2
 12433 027f 00       		.byte	0
 12434 0280 00       		.byte	0
 12435 0281 64       		.byte	100
 12436 0282 00       		.byte	0
 12437 0283 01       		.byte	1
 12438 0284 00       		.byte	0
 12439 0285 03       		.byte	3
 12440 0286 00       		.byte	0
 12441 0287 32       		.byte	50
 12442 0288 00       		.byte	0
 12443 0289 32       		.byte	50
 12444 028a 00       		.byte	0
 12445 028b F2       		.byte	-14
 12446 028c 01       		.byte	1
 12447 028d 01       		.byte	1
 12448 028e 00       		.byte	0
 12449 028f 00000000 		.space	5
 12449      00
 12450 0294 06       		.byte	6
 12451 0295 07       		.byte	7
 12452 0296 02       		.byte	2
 12453 0297 00       		.byte	0
 12454 0298 00       		.byte	0
 12455 0299 FF       		.byte	-1
 12456 029a 00       		.byte	0
 12457 029b 01       		.byte	1
 12458 029c 00       		.byte	0
 12459 029d 03       		.byte	3
 12460 029e 00       		.byte	0
 12461 029f 20       		.byte	32
 12462 02a0 00       		.byte	0
 12463 02a1 20       		.byte	32
 12464 02a2 00       		.byte	0
 12465 02a3 30       		.byte	48
 12466 02a4 01       		.byte	1
 12467 02a5 01       		.byte	1
 12468 02a6 00       		.byte	0
 12469 02a7 00000000 		.space	5
 12469      00
 12470 02ac 00       		.byte	0
 12471 02ad 00       		.byte	0
 12472 02ae 02       		.byte	2
 12473 02af 00       		.byte	0
 12474 02b0 00       		.byte	0
 12475 02b1 64       		.byte	100
 12476 02b2 00       		.byte	0
 12477 02b3 01       		.byte	1
 12478 02b4 00       		.byte	0
 12479 02b5 03       		.byte	3
 12480 02b6 00       		.byte	0
 12481 02b7 00       		.byte	0
 12482 02b8 00       		.byte	0
 12483 02b9 00       		.byte	0
 12484 02ba 00       		.byte	0
 12485 02bb 30       		.byte	48
 12486 02bc 01       		.byte	1
 12487 02bd 00       		.byte	0
 12488 02be 00       		.byte	0
 12489 02bf 00000000 		.space	5
 12489      00
 12490 02c4 08       		.byte	8
 12491 02c5 08       		.byte	8
 12492 02c6 02       		.byte	2
 12493 02c7 00       		.byte	0
 12494 02c8 00       		.byte	0
 12495 02c9 05       		.byte	5
 12496 02ca 00       		.byte	0
 12497 02cb 01       		.byte	1
 12498 02cc 00       		.byte	0
 12499 02cd 03       		.byte	3
 12500 02ce 00       		.byte	0
 12501 02cf 00       		.byte	0
 12502 02d0 00       		.byte	0
 12503 02d1 00       		.byte	0
 12504 02d2 00       		.byte	0
 12505 02d3 30       		.byte	48
 12506 02d4 01       		.byte	1
 12507 02d5 00       		.byte	0
 12508 02d6 00       		.byte	0
 12509 02d7 00000000 		.space	5
 12509      00
 12510 02dc 00       		.byte	0
 12511 02dd 00       		.byte	0
 12512 02de 02       		.byte	2
 12513 02df 00       		.byte	0
 12514 02e0 00       		.byte	0
 12515 02e1 40       		.byte	64
 12516 02e2 00       		.byte	0
 12517 02e3 01       		.byte	1
 12518 02e4 00       		.byte	0
 12519 02e5 03       		.byte	3
 12520 02e6 00       		.byte	0
 12521 02e7 00       		.byte	0
 12522 02e8 00       		.byte	0
 12523 02e9 00       		.byte	0
 12524 02ea 00       		.byte	0
 12525 02eb 30       		.byte	48
 12526 02ec 01       		.byte	1
 12527 02ed 00       		.byte	0
 12528 02ee 00       		.byte	0
 12529 02ef 00000000 		.space	5
 12529      00
 12530 02f4 09       		.byte	9
 12531 02f5 0A       		.byte	10
 12532 02f6 04       		.byte	4
 12533 02f7 00       		.byte	0
 12534 02f8 00       		.byte	0
 12535 02f9 40       		.byte	64
 12536 02fa 00       		.byte	0
 12537 02fb 01       		.byte	1
 12538 02fc 00       		.byte	0
 12539 02fd 03       		.byte	3
 12540 02fe 00       		.byte	0
 12541 02ff 20       		.byte	32
 12542 0300 38       		.byte	56
 12543 0301 20       		.byte	32
 12544 0302 38       		.byte	56
 12545 0303 30       		.byte	48
 12546 0304 01       		.byte	1
 12547 0305 00       		.byte	0
 12548 0306 00       		.byte	0
 12549 0307 00000000 		.space	5
 12549      00
 12550 030c 00       		.byte	0
 12551 030d 00       		.byte	0
 12552 030e 02       		.byte	2
 12553 030f 00       		.byte	0
 12554 0310 00       		.byte	0
 12555 0311 64       		.byte	100
 12556 0312 00       		.byte	0
 12557 0313 01       		.byte	1
 12558 0314 00       		.byte	0
 12559 0315 03       		.byte	3
 12560 0316 00       		.byte	0
 12561 0317 00       		.byte	0
 12562 0318 00       		.byte	0
 12563 0319 00       		.byte	0
 12564 031a 00       		.byte	0
 12565 031b 30       		.byte	48
 12566 031c 01       		.byte	1
 12567 031d 00       		.byte	0
 12568 031e 00       		.byte	0
 12569 031f 00000000 		.space	5
 12569      00
 12570 0324 00       		.byte	0
 12571 0325 00       		.byte	0
 12572 0326 02       		.byte	2
 12573 0327 00       		.byte	0
 12574 0328 00       		.byte	0
 12575 0329 64       		.byte	100
 12576 032a 00       		.byte	0
 12577 032b 01       		.byte	1
 12578 032c 00       		.byte	0
 12579 032d 03       		.byte	3
 12580 032e 00       		.byte	0
 12581 032f 00       		.byte	0
 12582 0330 00       		.byte	0
 12583 0331 00       		.byte	0
 12584 0332 00       		.byte	0
 12585 0333 30       		.byte	48
 12586 0334 01       		.byte	1
 12587 0335 00       		.byte	0
 12588 0336 00       		.byte	0
 12589 0337 00000000 		.space	5
 12589      00
 12590 033c 2A       		.byte	42
 12591 033d 2A       		.byte	42
 12592 033e 02       		.byte	2
 12593 033f 00       		.byte	0
 12594 0340 00       		.byte	0
 12595 0341 1B       		.byte	27
 12596 0342 00       		.byte	0
 12597 0343 01       		.byte	1
 12598 0344 00       		.byte	0
 12599 0345 03       		.byte	3
 12600 0346 00       		.byte	0
 12601 0347 00       		.byte	0
 12602 0348 00       		.byte	0
 12603 0349 00       		.byte	0
 12604 034a 00       		.byte	0
 12605 034b 30       		.byte	48
 12606 034c 01       		.byte	1
 12607 034d 00       		.byte	0
 12608 034e 00       		.byte	0
 12609 034f 00000000 		.space	5
 12609      00
 12610 0354 00       		.byte	0
 12611 0355 00       		.byte	0
 12612 0356 02       		.byte	2
 12613 0357 00       		.byte	0
 12614 0358 00       		.byte	0
 12615 0359 64       		.byte	100
 12616 035a 00       		.byte	0
 12617 035b 01       		.byte	1
 12618 035c 00       		.byte	0
 12619 035d 03       		.byte	3
 12620 035e 00       		.byte	0
 12621 035f 00       		.byte	0
 12622 0360 00       		.byte	0
 12623 0361 00       		.byte	0
 12624 0362 00       		.byte	0
 12625 0363 30       		.byte	48
 12626 0364 01       		.byte	1
 12627 0365 00       		.byte	0
 12628 0366 00       		.byte	0
 12629 0367 00000000 		.space	5
 12629      00
 12630 036c 00       		.byte	0
 12631 036d 00       		.byte	0
 12632 036e 02       		.byte	2
 12633 036f 00       		.byte	0
 12634 0370 00       		.byte	0
 12635 0371 12       		.byte	18
 12636 0372 00       		.byte	0
 12637 0373 01       		.byte	1
 12638 0374 00       		.byte	0
 12639 0375 03       		.byte	3
 12640 0376 00       		.byte	0
 12641 0377 00       		.byte	0
 12642 0378 00       		.byte	0
 12643 0379 00       		.byte	0
 12644 037a 00       		.byte	0
 12645 037b 30       		.byte	48
 12646 037c 01       		.byte	1
 12647 037d 00       		.byte	0
 12648 037e 00       		.byte	0
 12649 037f 00000000 		.space	5
 12649      00
 12650 0384 01       		.byte	1
 12651 0385 01       		.byte	1
 12652 0386 02       		.byte	2
 12653 0387 00       		.byte	0
 12654 0388 00       		.byte	0
 12655 0389 09       		.byte	9
 12656 038a 00       		.byte	0
 12657 038b 01       		.byte	1
 12658 038c 00       		.byte	0
 12659 038d 03       		.byte	3
 12660 038e 00       		.byte	0
 12661 038f 00       		.byte	0
 12662 0390 00       		.byte	0
 12663 0391 01       		.byte	1
 12664 0392 00       		.byte	0
 12665 0393 30       		.byte	48
 12666 0394 01       		.byte	1
 12667 0395 00       		.byte	0
 12668 0396 00       		.byte	0
 12669 0397 00000000 		.space	5
 12669      00
 12670 039c 05       		.byte	5
 12671 039d 05       		.byte	5
 12672 039e 02       		.byte	2
 12673 039f 00       		.byte	0
 12674 03a0 00       		.byte	0
 12675 03a1 03       		.byte	3
 12676 03a2 00       		.byte	0
 12677 03a3 01       		.byte	1
 12678 03a4 00       		.byte	0
 12679 03a5 03       		.byte	3
 12680 03a6 00       		.byte	0
 12681 03a7 00       		.byte	0
 12682 03a8 00       		.byte	0
 12683 03a9 00       		.byte	0
 12684 03aa 00       		.byte	0
 12685 03ab 30       		.byte	48
 12686 03ac 01       		.byte	1
 12687 03ad 00       		.byte	0
 12688 03ae 00       		.byte	0
 12689 03af 00000000 		.space	5
 12689      00
 12690 03b4 18       		.byte	24
 12691 03b5 18       		.byte	24
 12692 03b6 02       		.byte	2
 12693 03b7 00       		.byte	0
 12694 03b8 00       		.byte	0
 12695 03b9 01       		.byte	1
 12696 03ba 00       		.byte	0
 12697 03bb 01       		.byte	1
 12698 03bc 00       		.byte	0
 12699 03bd 03       		.byte	3
 12700 03be 00       		.byte	0
 12701 03bf 00       		.byte	0
 12702 03c0 00       		.byte	0
 12703 03c1 00       		.byte	0
 12704 03c2 00       		.byte	0
 12705 03c3 30       		.byte	48
 12706 03c4 01       		.byte	1
 12707 03c5 00       		.byte	0
 12708 03c6 00       		.byte	0
 12709 03c7 00000000 		.space	5
 12709      00
 12710 03cc 19       		.byte	25
 12711 03cd 19       		.byte	25
 12712 03ce 01       		.byte	1
 12713 03cf 00       		.byte	0
 12714 03d0 00       		.byte	0
 12715 03d1 40       		.byte	64
 12716 03d2 00       		.byte	0
 12717 03d3 01       		.byte	1
 12718 03d4 00       		.byte	0
 12719 03d5 03       		.byte	3
 12720 03d6 00       		.byte	0
 12721 03d7 20       		.byte	32
 12722 03d8 00       		.byte	0
 12723 03d9 20       		.byte	32
 12724 03da 00       		.byte	0
 12725 03db 30       		.byte	48
 12726 03dc 01       		.byte	1
 12727 03dd 00       		.byte	0
 12728 03de 00       		.byte	0
 12729 03df 00000000 		.space	5
 12729      00
 12730 03e4 20       		.byte	32
 12731 03e5 20       		.byte	32
 12732 03e6 02       		.byte	2
 12733 03e7 00       		.byte	0
 12734 03e8 00       		.byte	0
 12735 03e9 02       		.byte	2
 12736 03ea 00       		.byte	0
 12737 03eb 01       		.byte	1
 12738 03ec 00       		.byte	0
 12739 03ed 03       		.byte	3
 12740 03ee 00       		.byte	0
 12741 03ef 00       		.byte	0
 12742 03f0 00       		.byte	0
 12743 03f1 00       		.byte	0
 12744 03f2 00       		.byte	0
 12745 03f3 30       		.byte	48
 12746 03f4 01       		.byte	1
 12747 03f5 00       		.byte	0
 12748 03f6 00       		.byte	0
 12749 03f7 00000000 		.space	5
 12749      00
 12750 03fc 22       		.byte	34
 12751 03fd 22       		.byte	34
 12752 03fe 02       		.byte	2
 12753 03ff 00       		.byte	0
 12754 0400 00       		.byte	0
 12755 0401 3F       		.byte	63
 12756 0402 00       		.byte	0
 12757 0403 01       		.byte	1
 12758 0404 00       		.byte	0
 12759 0405 03       		.byte	3
 12760 0406 00       		.byte	0
 12761 0407 00       		.byte	0
 12762 0408 00       		.byte	0
 12763 0409 00       		.byte	0
 12764 040a 00       		.byte	0
 12765 040b 30       		.byte	48
 12766 040c 01       		.byte	1
 12767 040d 00       		.byte	0
 12768 040e 00       		.byte	0
 12769 040f 00000000 		.space	5
 12769      00
 12770 0414 23       		.byte	35
 12771 0415 23       		.byte	35
 12772 0416 02       		.byte	2
 12773 0417 00       		.byte	0
 12774 0418 00       		.byte	0
 12775 0419 64       		.byte	100
 12776 041a 00       		.byte	0
 12777 041b 01       		.byte	1
 12778 041c 00       		.byte	0
 12779 041d 03       		.byte	3
 12780 041e 00       		.byte	0
 12781 041f 10       		.byte	16
 12782 0420 00       		.byte	0
 12783 0421 10       		.byte	16
 12784 0422 00       		.byte	0
 12785 0423 30       		.byte	48
 12786 0424 01       		.byte	1
 12787 0425 00       		.byte	0
 12788 0426 00       		.byte	0
 12789 0427 00000000 		.space	5
 12789      00
 12790 042c 24       		.byte	36
 12791 042d 24       		.byte	36
 12792 042e 02       		.byte	2
 12793 042f 00       		.byte	0
 12794 0430 00       		.byte	0
 12795 0431 64       		.byte	100
 12796 0432 00       		.byte	0
 12797 0433 01       		.byte	1
 12798 0434 00       		.byte	0
 12799 0435 03       		.byte	3
 12800 0436 00       		.byte	0
 12801 0437 10       		.byte	16
 12802 0438 00       		.byte	0
 12803 0439 10       		.byte	16
 12804 043a 00       		.byte	0
 12805 043b 30       		.byte	48
 12806 043c 01       		.byte	1
 12807 043d 00       		.byte	0
 12808 043e 00       		.byte	0
 12809 043f 00000000 		.space	5
 12809      00
 12810 0444 00       		.byte	0
 12811 0445 03       		.byte	3
 12812 0446 04       		.byte	4
 12813 0447 00       		.byte	0
 12814 0448 00       		.byte	0
 12815 0449 7F       		.byte	127
 12816 044a 00       		.byte	0
 12817 044b 01       		.byte	1
 12818 044c 00       		.byte	0
 12819 044d 03       		.byte	3
 12820 044e 00       		.byte	0
 12821 044f 00       		.byte	0
 12822 0450 20       		.byte	32
 12823 0451 00       		.byte	0
 12824 0452 20       		.byte	32
 12825 0453 30       		.byte	48
 12826 0454 01       		.byte	1
 12827 0455 00       		.byte	0
 12828 0456 00       		.byte	0
 12829 0457 00000000 		.space	5
 12829      00
 12830 045c 04       		.byte	4
 12831 045d 04       		.byte	4
 12832 045e 02       		.byte	2
 12833 045f 00       		.byte	0
 12834 0460 00       		.byte	0
 12835 0461 FF       		.byte	-1
 12836 0462 00       		.byte	0
 12837 0463 01       		.byte	1
 12838 0464 00       		.byte	0
 12839 0465 03       		.byte	3
 12840 0466 00       		.byte	0
 12841 0467 60       		.byte	96
 12842 0468 00       		.byte	0
 12843 0469 60       		.byte	96
 12844 046a 00       		.byte	0
 12845 046b 30       		.byte	48
 12846 046c 01       		.byte	1
 12847 046d 00       		.byte	0
 12848 046e 00       		.byte	0
 12849 046f 00000000 		.space	5
 12849      00
 12850 0474 00       		.byte	0
 12851 0475 00       		.byte	0
 12852 0476 02       		.byte	2
 12853 0477 00       		.byte	0
 12854 0478 00       		.byte	0
 12855 0479 19       		.byte	25
 12856 047a 00       		.byte	0
 12857 047b 01       		.byte	1
 12858 047c 00       		.byte	0
 12859 047d 03       		.byte	3
 12860 047e 00       		.byte	0
 12861 047f 00       		.byte	0
 12862 0480 00       		.byte	0
 12863 0481 00       		.byte	0
 12864 0482 00       		.byte	0
 12865 0483 30       		.byte	48
 12866 0484 01       		.byte	1
 12867 0485 00       		.byte	0
 12868 0486 00       		.byte	0
 12869 0487 00000000 		.space	5
 12869      00
 12870 048c 10       		.byte	16
 12871 048d 10       		.byte	16
 12872 048e 02       		.byte	2
 12873 048f 00       		.byte	0
 12874 0490 00       		.byte	0
 12875 0491 06       		.byte	6
 12876 0492 00       		.byte	0
 12877 0493 01       		.byte	1
 12878 0494 00       		.byte	0
 12879 0495 03       		.byte	3
 12880 0496 00       		.byte	0
 12881 0497 03       		.byte	3
 12882 0498 00       		.byte	0
 12883 0499 03       		.byte	3
 12884 049a 00       		.byte	0
 12885 049b 30       		.byte	48
 12886 049c 01       		.byte	1
 12887 049d 00       		.byte	0
 12888 049e 00       		.byte	0
 12889 049f 00000000 		.space	5
 12889      00
 12890 04a4 00       		.byte	0
 12891 04a5 00       		.byte	0
 12892 04a6 02       		.byte	2
 12893 04a7 00       		.byte	0
 12894 04a8 00       		.byte	0
 12895 04a9 03       		.byte	3
 12896 04aa 00       		.byte	0
 12897 04ab 01       		.byte	1
 12898 04ac 00       		.byte	0
 12899 04ad 03       		.byte	3
 12900 04ae 00       		.byte	0
 12901 04af 00       		.byte	0
 12902 04b0 00       		.byte	0
 12903 04b1 00       		.byte	0
 12904 04b2 00       		.byte	0
 12905 04b3 30       		.byte	48
 12906 04b4 01       		.byte	1
 12907 04b5 00       		.byte	0
 12908 04b6 00       		.byte	0
 12909 04b7 00000000 		.space	5
 12909      00
 12910 04bc 50       		.byte	80
 12911 04bd 50       		.byte	80
 12912 04be 01       		.byte	1
 12913 04bf 00       		.byte	0
 12914 04c0 00       		.byte	0
 12915 04c1 03       		.byte	3
 12916 04c2 00       		.byte	0
 12917 04c3 01       		.byte	1
 12918 04c4 00       		.byte	0
 12919 04c5 03       		.byte	3
 12920 04c6 00       		.byte	0
 12921 04c7 00       		.byte	0
 12922 04c8 00       		.byte	0
 12923 04c9 00       		.byte	0
 12924 04ca 00       		.byte	0
 12925 04cb 30       		.byte	48
 12926 04cc 01       		.byte	1
 12927 04cd 00       		.byte	0
 12928 04ce 00       		.byte	0
 12929 04cf 00000000 		.space	5
 12929      00
 12930 04d4 00       		.byte	0
 12931 04d5 00       		.byte	0
 12932 04d6 0B       		.byte	11
 12933 04d7 00       		.byte	0
 12934 04d8 00       		.byte	0
 12935 04d9 FF       		.byte	-1
 12936 04da FF       		.byte	-1
 12937 04db 01       		.byte	1
 12938 04dc 00       		.byte	0
 12939 04dd 03       		.byte	3
 12940 04de 00       		.byte	0
 12941 04df 00       		.byte	0
 12942 04e0 00       		.byte	0
 12943 04e1 00       		.byte	0
 12944 04e2 00       		.byte	0
 12945 04e3 00       		.byte	0
 12946 04e4 01       		.byte	1
 12947 04e5 00       		.byte	0
 12948 04e6 00       		.byte	0
 12949 04e7 00000000 		.space	5
 12949      00
 12952              	glUVCHeader:
 12953 04ec 0C       		.byte	12
 12954 04ed 8C       		.byte	-116
 12955 04ee 00       		.byte	0
 12956 04ef 00       		.byte	0
 12957 04f0 00       		.byte	0
 12958 04f1 00       		.byte	0
 12959 04f2 00       		.byte	0
 12960 04f3 00       		.byte	0
 12961 04f4 00       		.byte	0
 12962 04f5 00       		.byte	0
 12963 04f6 00       		.byte	0
 12964 04f7 00       		.byte	0
 12967              	EXTBLCGrid:
 12968 04f8 10       		.byte	16
 12969 04f9 10       		.byte	16
 12970 04fa 02       		.byte	2
 12971 04fb 01       		.byte	1
 12972 04fc 00       		.byte	0
 12973 04fd 02       		.byte	2
 12974 04fe 00       		.byte	0
 12975 04ff 01       		.byte	1
 12976 0500 00       		.byte	0
 12977 0501 03       		.byte	3
 12978 0502 00       		.byte	0
 12979 0503 00       		.byte	0
 12980 0504 00       		.byte	0
 12981 0505 00       		.byte	0
 12982 0506 00       		.byte	0
 12983 0507 30       		.byte	48
 12984 0508 01       		.byte	1
 12985 0509 00       		.byte	0
 12986 050a 0000     		.space	2
 12989              	EXTAexModGainlev:
 12990 050c 00       		.byte	0
 12991 050d 03       		.byte	3
 12992 050e 04       		.byte	4
 12993 050f 00       		.byte	0
 12994 0510 00       		.byte	0
 12995 0511 7F       		.byte	127
 12996 0512 00       		.byte	0
 12997 0513 01       		.byte	1
 12998 0514 00       		.byte	0
 12999 0515 03       		.byte	3
 13000 0516 00       		.byte	0
 13001 0517 00       		.byte	0
 13002 0518 3F       		.byte	63
 13003 0519 00       		.byte	0
 13004 051a 3F       		.byte	63
 13005 051b 30       		.byte	48
 13006 051c 01       		.byte	1
 13007 051d 00       		.byte	0
 13008 051e 0000     		.space	2
 13011              	EXTExCtrlSped:
 13012 0520 02       		.byte	2
 13013 0521 02       		.byte	2
 13014 0522 02       		.byte	2
 13015 0523 00       		.byte	0
 13016 0524 00       		.byte	0
 13017 0525 FF       		.byte	-1
 13018 0526 00       		.byte	0
 13019 0527 01       		.byte	1
 13020 0528 00       		.byte	0
 13021 0529 03       		.byte	3
 13022 052a 00       		.byte	0
 13023 052b 80       		.byte	-128
 13024 052c 00       		.byte	0
 13025 052d 80       		.byte	-128
 13026 052e 00       		.byte	0
 13027 052f 30       		.byte	48
 13028 0530 01       		.byte	1
 13029 0531 00       		.byte	0
 13030 0532 0000     		.space	2
 13033              	EXTBLCWinPos:
 13034 0534 14       		.byte	20
 13035 0535 13       		.byte	19
 13036 0536 02       		.byte	2
 13037 0537 00       		.byte	0
 13038 0538 00       		.byte	0
 13039 0539 FF       		.byte	-1
 13040 053a FF       		.byte	-1
 13041 053b 01       		.byte	1
 13042 053c 00       		.byte	0
 13043 053d 03       		.byte	3
 13044 053e 00       		.byte	0
 13045 053f 66       		.byte	102
 13046 0540 66       		.byte	102
 13047 0541 66       		.byte	102
 13048 0542 66       		.byte	102
 13049 0543 30       		.byte	48
 13050 0544 01       		.byte	1
 13051 0545 00       		.byte	0
 13052 0546 0000     		.space	2
 13055              	PUCBright:
 13056 0548 15       		.byte	21
 13057 0549 15       		.byte	21
 13058 054a 02       		.byte	2
 13059 054b 00       		.byte	0
 13060 054c 00       		.byte	0
 13061 054d FF       		.byte	-1
 13062 054e 00       		.byte	0
 13063 054f 01       		.byte	1
 13064 0550 00       		.byte	0
 13065 0551 03       		.byte	3
 13066 0552 00       		.byte	0
 13067 0553 76       		.byte	118
 13068 0554 00       		.byte	0
 13069 0555 76       		.byte	118
 13070 0556 77       		.byte	119
 13071 0557 30       		.byte	48
 13072 0558 01       		.byte	1
 13073 0559 00       		.byte	0
 13074 055a 0000     		.space	2
 13077              	PUCHueC:
 13078 055c DF       		.byte	-33
 13079 055d E1       		.byte	-31
 13080 055e 02       		.byte	2
 13081 055f 00       		.byte	0
 13082 0560 00       		.byte	0
 13083 0561 FF       		.byte	-1
 13084 0562 00       		.byte	0
 13085 0563 01       		.byte	1
 13086 0564 00       		.byte	0
 13087 0565 03       		.byte	3
 13088 0566 00       		.byte	0
 13089 0567 80       		.byte	-128
 13090 0568 00       		.byte	0
 13091 0569 00       		.byte	0
 13092 056a 00       		.byte	0
 13093 056b 30       		.byte	48
 13094 056c 01       		.byte	1
 13095 056d 00       		.byte	0
 13096 056e 0000     		.space	2
 13099              	PUCPLFreq:
 13100 0570 07       		.byte	7
 13101 0571 07       		.byte	7
 13102 0572 02       		.byte	2
 13103 0573 00       		.byte	0
 13104 0574 00       		.byte	0
 13105 0575 01       		.byte	1
 13106 0576 00       		.byte	0
 13107 0577 01       		.byte	1
 13108 0578 00       		.byte	0
 13109 0579 03       		.byte	3
 13110 057a 00       		.byte	0
 13111 057b 01       		.byte	1
 13112 057c 00       		.byte	0
 13113 057d 01       		.byte	1
 13114 057e 00       		.byte	0
 13115 057f 30       		.byte	48
 13116 0580 01       		.byte	1
 13117 0581 00       		.byte	0
 13118 0582 0000     		.space	2
 13121              	WBMenuCmpArry:
 13122 0584 20       		.byte	32
 13123 0585 0F       		.byte	15
 13124 0586 38       		.byte	56
 13125 0587 F0       		.byte	-16
 13128              	PUCSharp:
 13129 0588 06       		.byte	6
 13130 0589 07       		.byte	7
 13131 058a 02       		.byte	2
 13132 058b 00       		.byte	0
 13133 058c 00       		.byte	0
 13134 058d FF       		.byte	-1
 13135 058e 00       		.byte	0
 13136 058f 01       		.byte	1
 13137 0590 00       		.byte	0
 13138 0591 03       		.byte	3
 13139 0592 00       		.byte	0
 13140 0593 00       		.byte	0
 13141 0594 00       		.byte	0
 13142 0595 00       		.byte	0
 13143 0596 00       		.byte	0
 13144 0597 30       		.byte	48
 13145 0598 01       		.byte	1
 13146 0599 00       		.byte	0
 13147 059a 0000     		.space	2
 13150              	PUCBLC:
 13151 059c 10       		.byte	16
 13152 059d 11       		.byte	17
 13153 059e 02       		.byte	2
 13154 059f 00       		.byte	0
 13155 05a0 00       		.byte	0
 13156 05a1 03       		.byte	3
 13157 05a2 00       		.byte	0
 13158 05a3 01       		.byte	1
 13159 05a4 00       		.byte	0
 13160 05a5 03       		.byte	3
 13161 05a6 00       		.byte	0
 13162 05a7 03       		.byte	3
 13163 05a8 00       		.byte	0
 13164 05a9 03       		.byte	3
 13165 05aa 00       		.byte	0
 13166 05ab 30       		.byte	48
 13167 05ac 01       		.byte	1
 13168 05ad 00       		.byte	0
 13169 05ae 0000     		.space	2
 13172              	EXTShutter:
 13173 05b0 00       		.byte	0
 13174 05b1 02       		.byte	2
 13175 05b2 02       		.byte	2
 13176 05b3 00       		.byte	0
 13177 05b4 00       		.byte	0
 13178 05b5 08       		.byte	8
 13179 05b6 00       		.byte	0
 13180 05b7 01       		.byte	1
 13181 05b8 00       		.byte	0
 13182 05b9 03       		.byte	3
 13183 05ba 00       		.byte	0
 13184 05bb 00       		.byte	0
 13185 05bc 00       		.byte	0
 13186 05bd 00       		.byte	0
 13187 05be 00       		.byte	0
 13188 05bf 30       		.byte	48
 13189 05c0 01       		.byte	1
 13190 05c1 00       		.byte	0
 13191 05c2 0000     		.space	2
 13194              	EXTShutlev:
 13195 05c4 12       		.byte	18
 13196 05c5 12       		.byte	18
 13197 05c6 02       		.byte	2
 13198 05c7 00       		.byte	0
 13199 05c8 00       		.byte	0
 13200 05c9 FF       		.byte	-1
 13201 05ca 7F       		.byte	127
 13202 05cb 01       		.byte	1
 13203 05cc 00       		.byte	0
 13204 05cd 03       		.byte	3
 13205 05ce 00       		.byte	0
 13206 05cf 3F       		.byte	63
 13207 05d0 00       		.byte	0
 13208 05d1 3F       		.byte	63
 13209 05d2 00       		.byte	0
 13210 05d3 30       		.byte	48
 13211 05d4 01       		.byte	1
 13212 05d5 00       		.byte	0
 13213 05d6 0000     		.space	2
 13216              	CTCtrlParArry:
 13217 05d8 00       		.byte	0
 13218 05d9 00       		.byte	0
 13219 05da 01       		.byte	1
 13220 05db 00       		.byte	0
 13221 05dc 00       		.byte	0
 13222 05dd 03       		.byte	3
 13223 05de 00       		.byte	0
 13224 05df 01       		.byte	1
 13225 05e0 00       		.byte	0
 13226 05e1 03       		.byte	3
 13227 05e2 00       		.byte	0
 13228 05e3 03       		.byte	3
 13229 05e4 00       		.byte	0
 13230 05e5 03       		.byte	3
 13231 05e6 00       		.byte	0
 13232 05e7 30       		.byte	48
 13233 05e8 01       		.byte	1
 13234 05e9 00       		.byte	0
 13235 05ea 00       		.byte	0
 13236 05eb 00000000 		.space	5
 13236      00
 13237 05f0 00       		.byte	0
 13238 05f1 00       		.byte	0
 13239 05f2 01       		.byte	1
 13240 05f3 01       		.byte	1
 13241 05f4 00       		.byte	0
 13242 05f5 0F       		.byte	15
 13243 05f6 00       		.byte	0
 13244 05f7 0F       		.byte	15
 13245 05f8 00       		.byte	0
 13246 05f9 03       		.byte	3
 13247 05fa 00       		.byte	0
 13248 05fb 02       		.byte	2
 13249 05fc 00       		.byte	0
 13250 05fd 02       		.byte	2
 13251 05fe 00       		.byte	0
 13252 05ff 30       		.byte	48
 13253 0600 01       		.byte	1
 13254 0601 01       		.byte	1
 13255 0602 00       		.byte	0
 13256 0603 00000000 		.space	5
 13256      00
 13257 0608 02       		.byte	2
 13258 0609 00       		.byte	0
 13259 060a 01       		.byte	1
 13260 060b 00       		.byte	0
 13261 060c 00       		.byte	0
 13262 060d 01       		.byte	1
 13263 060e 00       		.byte	0
 13264 060f 01       		.byte	1
 13265 0610 00       		.byte	0
 13266 0611 03       		.byte	3
 13267 0612 00       		.byte	0
 13268 0613 00       		.byte	0
 13269 0614 00       		.byte	0
 13270 0615 00       		.byte	0
 13271 0616 00       		.byte	0
 13272 0617 30       		.byte	48
 13273 0618 01       		.byte	1
 13274 0619 01       		.byte	1
 13275 061a 00       		.byte	0
 13276 061b 00000000 		.space	5
 13276      00
 13277 0620 00       		.byte	0
 13278 0621 00       		.byte	0
 13279 0622 04       		.byte	4
 13280 0623 01       		.byte	1
 13281 0624 00       		.byte	0
 13282 0625 38       		.byte	56
 13283 0626 01       		.byte	1
 13284 0627 01       		.byte	1
 13285 0628 00       		.byte	0
 13286 0629 03       		.byte	3
 13287 062a 00       		.byte	0
 13288 062b 4E       		.byte	78
 13289 062c 00       		.byte	0
 13290 062d 4E       		.byte	78
 13291 062e 00       		.byte	0
 13292 062f 30       		.byte	48
 13293 0630 01       		.byte	1
 13294 0631 00       		.byte	0
 13295 0632 00       		.byte	0
 13296 0633 00000000 		.space	5
 13296      00
 13297 0638 04       		.byte	4
 13298 0639 00       		.byte	0
 13299 063a 01       		.byte	1
 13300 063b 00       		.byte	0
 13301 063c 00       		.byte	0
 13302 063d 00       		.byte	0
 13303 063e 00       		.byte	0
 13304 063f 01       		.byte	1
 13305 0640 00       		.byte	0
 13306 0641 03       		.byte	3
 13307 0642 00       		.byte	0
 13308 0643 00       		.byte	0
 13309 0644 00       		.byte	0
 13310 0645 00       		.byte	0
 13311 0646 00       		.byte	0
 13312 0647 30       		.byte	48
 13313 0648 01       		.byte	1
 13314 0649 00       		.byte	0
 13315 064a 00       		.byte	0
 13316 064b 00000000 		.space	5
 13316      00
 13317 0650 05       		.byte	5
 13318 0651 00       		.byte	0
 13319 0652 02       		.byte	2
 13320 0653 00       		.byte	0
 13321 0654 00       		.byte	0
 13322 0655 FF       		.byte	-1
 13323 0656 00       		.byte	0
 13324 0657 01       		.byte	1
 13325 0658 00       		.byte	0
 13326 0659 03       		.byte	3
 13327 065a 00       		.byte	0
 13328 065b 01       		.byte	1
 13329 065c 00       		.byte	0
 13330 065d 00       		.byte	0
 13331 065e 00       		.byte	0
 13332 065f 30       		.byte	48
 13333 0660 01       		.byte	1
 13334 0661 01       		.byte	1
 13335 0662 00       		.byte	0
 13336 0663 00000000 		.space	5
 13336      00
 13337 0668 06       		.byte	6
 13338 0669 00       		.byte	0
 13339 066a 02       		.byte	2
 13340 066b 00       		.byte	0
 13341 066c 00       		.byte	0
 13342 066d 00       		.byte	0
 13343 066e 00       		.byte	0
 13344 066f 00       		.byte	0
 13345 0670 00       		.byte	0
 13346 0671 03       		.byte	3
 13347 0672 00       		.byte	0
 13348 0673 00       		.byte	0
 13349 0674 00       		.byte	0
 13350 0675 00       		.byte	0
 13351 0676 00       		.byte	0
 13352 0677 30       		.byte	48
 13353 0678 01       		.byte	1
 13354 0679 01       		.byte	1
 13355 067a 00       		.byte	0
 13356 067b 00000000 		.space	5
 13356      00
 13357 0680 23       		.byte	35
 13358 0681 00       		.byte	0
 13359 0682 02       		.byte	2
 13360 0683 00       		.byte	0
 13361 0684 00       		.byte	0
 13362 0685 30       		.byte	48
 13363 0686 00       		.byte	0
 13364 0687 01       		.byte	1
 13365 0688 00       		.byte	0
 13366 0689 03       		.byte	3
 13367 068a 0A       		.byte	10
 13368 068b 00       		.byte	0
 13369 068c 00       		.byte	0
 13370 068d 0A       		.byte	10
 13371 068e 00       		.byte	0
 13372 068f 30       		.byte	48
 13373 0690 01       		.byte	1
 13374 0691 01       		.byte	1
 13375 0692 00       		.byte	0
 13376 0693 00000000 		.space	5
 13376      00
 13377 0698 08       		.byte	8
 13378 0699 00       		.byte	0
 13379 069a 01       		.byte	1
 13380 069b 00       		.byte	0
 13381 069c 00       		.byte	0
 13382 069d 7F       		.byte	127
 13383 069e 00       		.byte	0
 13384 069f 01       		.byte	1
 13385 06a0 00       		.byte	0
 13386 06a1 03       		.byte	3
 13387 06a2 00       		.byte	0
 13388 06a3 00       		.byte	0
 13389 06a4 00       		.byte	0
 13390 06a5 00       		.byte	0
 13391 06a6 00       		.byte	0
 13392 06a7 30       		.byte	48
 13393 06a8 01       		.byte	1
 13394 06a9 00       		.byte	0
 13395 06aa 00       		.byte	0
 13396 06ab 00000000 		.space	5
 13396      00
 13397 06b0 09       		.byte	9
 13398 06b1 00       		.byte	0
 13399 06b2 02       		.byte	2
 13400 06b3 00       		.byte	0
 13401 06b4 00       		.byte	0
 13402 06b5 05       		.byte	5
 13403 06b6 00       		.byte	0
 13404 06b7 01       		.byte	1
 13405 06b8 00       		.byte	0
 13406 06b9 03       		.byte	3
 13407 06ba 00       		.byte	0
 13408 06bb 00       		.byte	0
 13409 06bc 00       		.byte	0
 13410 06bd 00       		.byte	0
 13411 06be 00       		.byte	0
 13412 06bf 30       		.byte	48
 13413 06c0 01       		.byte	1
 13414 06c1 00       		.byte	0
 13415 06c2 00       		.byte	0
 13416 06c3 00000000 		.space	5
 13416      00
 13417 06c8 10       		.byte	16
 13418 06c9 00       		.byte	0
 13419 06ca 03       		.byte	3
 13420 06cb 00       		.byte	0
 13421 06cc 00       		.byte	0
 13422 06cd 00       		.byte	0
 13423 06ce 00       		.byte	0
 13424 06cf 00       		.byte	0
 13425 06d0 00       		.byte	0
 13426 06d1 03       		.byte	3
 13427 06d2 00       		.byte	0
 13428 06d3 00       		.byte	0
 13429 06d4 00       		.byte	0
 13430 06d5 00       		.byte	0
 13431 06d6 00       		.byte	0
 13432 06d7 30       		.byte	48
 13433 06d8 01       		.byte	1
 13434 06d9 00       		.byte	0
 13435 06da 00       		.byte	0
 13436 06db 00000000 		.space	5
 13436      00
 13437 06e0 00       		.byte	0
 13438 06e1 00       		.byte	0
 13439 06e2 02       		.byte	2
 13440 06e3 00       		.byte	0
 13441 06e4 00       		.byte	0
 13442 06e5 40       		.byte	64
 13443 06e6 00       		.byte	0
 13444 06e7 01       		.byte	1
 13445 06e8 00       		.byte	0
 13446 06e9 03       		.byte	3
 13447 06ea 00       		.byte	0
 13448 06eb 0F       		.byte	15
 13449 06ec 11       		.byte	17
 13450 06ed 00       		.byte	0
 13451 06ee 00       		.byte	0
 13452 06ef 30       		.byte	48
 13453 06f0 01       		.byte	1
 13454 06f1 00       		.byte	0
 13455 06f2 00       		.byte	0
 13456 06f3 00000000 		.space	5
 13456      00
 13457 06f8 00       		.byte	0
 13458 06f9 00       		.byte	0
 13459 06fa 02       		.byte	2
 13460 06fb 00       		.byte	0
 13461 06fc 00       		.byte	0
 13462 06fd 64       		.byte	100
 13463 06fe 00       		.byte	0
 13464 06ff 01       		.byte	1
 13465 0700 00       		.byte	0
 13466 0701 03       		.byte	3
 13467 0702 00       		.byte	0
 13468 0703 00       		.byte	0
 13469 0704 00       		.byte	0
 13470 0705 00       		.byte	0
 13471 0706 00       		.byte	0
 13472 0707 30       		.byte	48
 13473 0708 01       		.byte	1
 13474 0709 00       		.byte	0
 13475 070a 00       		.byte	0
 13476 070b 00000000 		.space	5
 13476      00
 13477 0710 00       		.byte	0
 13478 0711 00       		.byte	0
 13479 0712 02       		.byte	2
 13480 0713 00       		.byte	0
 13481 0714 00       		.byte	0
 13482 0715 64       		.byte	100
 13483 0716 00       		.byte	0
 13484 0717 01       		.byte	1
 13485 0718 00       		.byte	0
 13486 0719 03       		.byte	3
 13487 071a 00       		.byte	0
 13488 071b 00       		.byte	0
 13489 071c 00       		.byte	0
 13490 071d 00       		.byte	0
 13491 071e 00       		.byte	0
 13492 071f 30       		.byte	48
 13493 0720 01       		.byte	1
 13494 0721 00       		.byte	0
 13495 0722 00       		.byte	0
 13496 0723 00000000 		.space	5
 13496      00
 13497 0728 00       		.byte	0
 13498 0729 00       		.byte	0
 13499 072a 02       		.byte	2
 13500 072b 00       		.byte	0
 13501 072c 00       		.byte	0
 13502 072d 64       		.byte	100
 13503 072e 00       		.byte	0
 13504 072f 01       		.byte	1
 13505 0730 00       		.byte	0
 13506 0731 03       		.byte	3
 13507 0732 00       		.byte	0
 13508 0733 00       		.byte	0
 13509 0734 00       		.byte	0
 13510 0735 00       		.byte	0
 13511 0736 00       		.byte	0
 13512 0737 30       		.byte	48
 13513 0738 01       		.byte	1
 13514 0739 00       		.byte	0
 13515 073a 00       		.byte	0
 13516 073b 00000000 		.space	5
 13516      00
 13517 0740 00       		.byte	0
 13518 0741 00       		.byte	0
 13519 0742 02       		.byte	2
 13520 0743 00       		.byte	0
 13521 0744 00       		.byte	0
 13522 0745 64       		.byte	100
 13523 0746 00       		.byte	0
 13524 0747 01       		.byte	1
 13525 0748 00       		.byte	0
 13526 0749 03       		.byte	3
 13527 074a 00       		.byte	0
 13528 074b 00       		.byte	0
 13529 074c 00       		.byte	0
 13530 074d 00       		.byte	0
 13531 074e 00       		.byte	0
 13532 074f 30       		.byte	48
 13533 0750 01       		.byte	1
 13534 0751 00       		.byte	0
 13535 0752 00       		.byte	0
 13536 0753 00000000 		.space	5
 13536      00
 13539              	PUCWBMd:
 13540 0758 08       		.byte	8
 13541 0759 08       		.byte	8
 13542 075a 02       		.byte	2
 13543 075b 00       		.byte	0
 13544 075c 00       		.byte	0
 13545 075d 05       		.byte	5
 13546 075e 00       		.byte	0
 13547 075f 01       		.byte	1
 13548 0760 00       		.byte	0
 13549 0761 03       		.byte	3
 13550 0762 00       		.byte	0
 13551 0763 00       		.byte	0
 13552 0764 00       		.byte	0
 13553 0765 00       		.byte	0
 13554 0766 00       		.byte	0
 13555 0767 30       		.byte	48
 13556 0768 01       		.byte	1
 13557 0769 00       		.byte	0
 13558 076a 0000     		.space	2
 13561              	PUCWBLC:
 13562 076c 09       		.byte	9
 13563 076d 0A       		.byte	10
 13564 076e 04       		.byte	4
 13565 076f 00       		.byte	0
 13566 0770 00       		.byte	0
 13567 0771 40       		.byte	64
 13568 0772 00       		.byte	0
 13569 0773 01       		.byte	1
 13570 0774 00       		.byte	0
 13571 0775 03       		.byte	3
 13572 0776 00       		.byte	0
 13573 0777 20       		.byte	32
 13574 0778 00       		.byte	0
 13575 0779 38       		.byte	56
 13576 077a 00       		.byte	0
 13577 077b 30       		.byte	48
 13578 077c 01       		.byte	1
 13579 077d 00       		.byte	0
 13580 077e 0000     		.space	2
 13583              	EXTExHyster:
 13584 0780 0B       		.byte	11
 13585 0781 0B       		.byte	11
 13586 0782 02       		.byte	2
 13587 0783 00       		.byte	0
 13588 0784 00       		.byte	0
 13589 0785 FF       		.byte	-1
 13590 0786 00       		.byte	0
 13591 0787 01       		.byte	1
 13592 0788 00       		.byte	0
 13593 0789 03       		.byte	3
 13594 078a 00       		.byte	0
 13595 078b 80       		.byte	-128
 13596 078c 00       		.byte	0
 13597 078d 80       		.byte	-128
 13598 078e 00       		.byte	0
 13599 078f 30       		.byte	48
 13600 0790 01       		.byte	1
 13601 0791 00       		.byte	0
 13604              	snapButFlag:
 13605 0792 01       		.byte	1
 13606 0793 00       		.space	1
 13609              	EXTAGCMaxLimit:
 13610 0794 0C       		.byte	12
 13611 0795 0C       		.byte	12
 13612 0796 02       		.byte	2
 13613 0797 00       		.byte	0
 13614 0798 00       		.byte	0
 13615 0799 10       		.byte	16
 13616 079a 00       		.byte	0
 13617 079b 01       		.byte	1
 13618 079c 00       		.byte	0
 13619 079d 03       		.byte	3
 13620 079e 00       		.byte	0
 13621 079f 00       		.byte	0
 13622 07a0 00       		.byte	0
 13623 07a1 00       		.byte	0
 13624 07a2 00       		.byte	0
 13625 07a3 30       		.byte	48
 13626 07a4 01       		.byte	1
 13627 07a5 00       		.byte	0
 13628 07a6 0000     		.space	2
 13631              	EXTGammaCor:
 13632 07a8 17       		.byte	23
 13633 07a9 17       		.byte	23
 13634 07aa 02       		.byte	2
 13635 07ab 00       		.byte	0
 13636 07ac 00       		.byte	0
 13637 07ad 10       		.byte	16
 13638 07ae 00       		.byte	0
 13639 07af 01       		.byte	1
 13640 07b0 00       		.byte	0
 13641 07b1 03       		.byte	3
 13642 07b2 00       		.byte	0
 13643 07b3 00       		.byte	0
 13644 07b4 00       		.byte	0
 13645 07b5 00       		.byte	0
 13646 07b6 00       		.byte	0
 13647 07b7 30       		.byte	48
 13648 07b8 01       		.byte	1
 13649 07b9 00       		.byte	0
 13650 07ba 0000     		.space	2
 13653              	EXT2DNRSTED:
 13654 07bc 1A       		.byte	26
 13655 07bd 1B       		.byte	27
 13656 07be 04       		.byte	4
 13657 07bf 00       		.byte	0
 13658 07c0 00       		.byte	0
 13659 07c1 FF       		.byte	-1
 13660 07c2 00       		.byte	0
 13661 07c3 01       		.byte	1
 13662 07c4 00       		.byte	0
 13663 07c5 03       		.byte	3
 13664 07c6 00       		.byte	0
 13665 07c7 80       		.byte	-128
 13666 07c8 00       		.byte	0
 13667 07c9 80       		.byte	-128
 13668 07ca 00       		.byte	0
 13669 07cb 30       		.byte	48
 13670 07cc 01       		.byte	1
 13671 07cd 00       		.byte	0
 13672 07ce 0000     		.space	2
 13675              	EXT2DNRGain:
 13676 07d0 18       		.byte	24
 13677 07d1 19       		.byte	25
 13678 07d2 02       		.byte	2
 13679 07d3 00       		.byte	0
 13680 07d4 00       		.byte	0
 13681 07d5 FF       		.byte	-1
 13682 07d6 00       		.byte	0
 13683 07d7 01       		.byte	1
 13684 07d8 00       		.byte	0
 13685 07d9 03       		.byte	3
 13686 07da 00       		.byte	0
 13687 07db 80       		.byte	-128
 13688 07dc 00       		.byte	0
 13689 07dd 80       		.byte	-128
 13690 07de 00       		.byte	0
 13691 07df 30       		.byte	48
 13692 07e0 01       		.byte	1
 13693 07e1 00       		.byte	0
 13694 07e2 0000     		.space	2
 13697              	EXTEnhanceSTED:
 13698 07e4 08       		.byte	8
 13699 07e5 09       		.byte	9
 13700 07e6 04       		.byte	4
 13701 07e7 00       		.byte	0
 13702 07e8 00       		.byte	0
 13703 07e9 FF       		.byte	-1
 13704 07ea 00       		.byte	0
 13705 07eb 01       		.byte	1
 13706 07ec 00       		.byte	0
 13707 07ed 03       		.byte	3
 13708 07ee 00       		.byte	0
 13709 07ef 80       		.byte	-128
 13710 07f0 00       		.byte	0
 13711 07f1 80       		.byte	-128
 13712 07f2 00       		.byte	0
 13713 07f3 30       		.byte	48
 13714 07f4 01       		.byte	1
 13715 07f5 00       		.byte	0
 13716 07f6 0000     		.space	2
 13719              	EXTEnhanceGain:
 13720 07f8 07       		.byte	7
 13721 07f9 07       		.byte	7
 13722 07fa 02       		.byte	2
 13723 07fb 00       		.byte	0
 13724 07fc 00       		.byte	0
 13725 07fd FF       		.byte	-1
 13726 07fe 00       		.byte	0
 13727 07ff 01       		.byte	1
 13728 0800 00       		.byte	0
 13729 0801 03       		.byte	3
 13730 0802 00       		.byte	0
 13731 0803 80       		.byte	-128
 13732 0804 00       		.byte	0
 13733 0805 80       		.byte	-128
 13734 0806 00       		.byte	0
 13735 0807 30       		.byte	48
 13736 0808 01       		.byte	1
 13737 0809 00       		.byte	0
 13738 080a 0000     		.space	2
 13741              	EXTEnhanceMode:
 13742 080c 06       		.byte	6
 13743 080d 06       		.byte	6
 13744 080e 02       		.byte	2
 13745 080f 00       		.byte	0
 13746 0810 00       		.byte	0
 13747 0811 FF       		.byte	-1
 13748 0812 00       		.byte	0
 13749 0813 01       		.byte	1
 13750 0814 00       		.byte	0
 13751 0815 03       		.byte	3
 13752 0816 00       		.byte	0
 13753 0817 80       		.byte	-128
 13754 0818 00       		.byte	0
 13755 0819 80       		.byte	-128
 13756 081a 00       		.byte	0
 13757 081b 30       		.byte	48
 13758 081c 01       		.byte	1
 13759 081d 00       		.byte	0
 13760 081e 0000     		.space	2
 13763              	EXTBLCWeight:
 13764 0820 11       		.byte	17
 13765 0821 11       		.byte	17
 13766 0822 02       		.byte	2
 13767 0823 00       		.byte	0
 13768 0824 00       		.byte	0
 13769 0825 FF       		.byte	-1
 13770 0826 00       		.byte	0
 13771 0827 01       		.byte	1
 13772 0828 00       		.byte	0
 13773 0829 03       		.byte	3
 13774 082a 00       		.byte	0
 13775 082b 80       		.byte	-128
 13776 082c 00       		.byte	0
 13777 082d 80       		.byte	-128
 13778 082e 00       		.byte	0
 13779 082f 30       		.byte	48
 13780 0830 01       		.byte	1
 13781 0831 00       		.byte	0
 13782 0832 0000     		.space	2
 13785              	EXTI2Ccmd:
 13786 0834 00       		.byte	0
 13787 0835 00       		.byte	0
 13788 0836 0B       		.byte	11
 13789 0837 00       		.byte	0
 13790 0838 00       		.byte	0
 13791 0839 FF       		.byte	-1
 13792 083a FF       		.byte	-1
 13793 083b 01       		.byte	1
 13794 083c 00       		.byte	0
 13795 083d 03       		.byte	3
 13796 083e 00       		.byte	0
 13797 083f 00       		.byte	0
 13798 0840 00       		.byte	0
 13799 0841 00       		.byte	0
 13800 0842 00       		.byte	0
 13801 0843 00       		.byte	0
 13802 0844 01       		.byte	1
 13803 0845 00       		.byte	0
 13804 0846 0000     		.space	2
 13807              	EXTSensorPare:
 13808 0848 50       		.byte	80
 13809 0849 50       		.byte	80
 13810 084a 02       		.byte	2
 13811 084b 00       		.byte	0
 13812 084c 00       		.byte	0
 13813 084d 03       		.byte	3
 13814 084e 00       		.byte	0
 13815 084f 01       		.byte	1
 13816 0850 00       		.byte	0
 13817 0851 03       		.byte	3
 13818 0852 00       		.byte	0
 13819 0853 00       		.byte	0
 13820 0854 00       		.byte	0
 13821 0855 00       		.byte	0
 13822 0856 00       		.byte	0
 13823 0857 30       		.byte	48
 13824 0858 01       		.byte	1
 13825 0859 00       		.byte	0
 13826 085a 0000     		.space	2
 13829              	EXTCamMode:
 13830 085c 10       		.byte	16
 13831 085d 10       		.byte	16
 13832 085e 02       		.byte	2
 13833 085f 00       		.byte	0
 13834 0860 00       		.byte	0
 13835 0861 06       		.byte	6
 13836 0862 00       		.byte	0
 13837 0863 01       		.byte	1
 13838 0864 00       		.byte	0
 13839 0865 03       		.byte	3
 13840 0866 00       		.byte	0
 13841 0867 03       		.byte	3
 13842 0868 00       		.byte	0
 13843 0869 03       		.byte	3
 13844 086a 00       		.byte	0
 13845 086b 30       		.byte	48
 13846 086c 01       		.byte	1
 13847 086d 00       		.byte	0
 13848 086e 0000     		.space	2
 13851              	EXTExpReflev:
 13852 0870 04       		.byte	4
 13853 0871 04       		.byte	4
 13854 0872 02       		.byte	2
 13855 0873 00       		.byte	0
 13856 0874 00       		.byte	0
 13857 0875 FF       		.byte	-1
 13858 0876 00       		.byte	0
 13859 0877 01       		.byte	1
 13860 0878 00       		.byte	0
 13861 0879 03       		.byte	3
 13862 087a 00       		.byte	0
 13863 087b 3C       		.byte	60
 13864 087c 00       		.byte	0
 13865 087d 3C       		.byte	60
 13866 087e 00       		.byte	0
 13867 087f 30       		.byte	48
 13868 0880 01       		.byte	1
 13869 0881 00       		.byte	0
 13870 0882 0000     		.space	2
 13873              	EXTNightDaylev:
 13874 0884 24       		.byte	36
 13875 0885 24       		.byte	36
 13876 0886 02       		.byte	2
 13877 0887 00       		.byte	0
 13878 0888 00       		.byte	0
 13879 0889 64       		.byte	100
 13880 088a 00       		.byte	0
 13881 088b 01       		.byte	1
 13882 088c 00       		.byte	0
 13883 088d 03       		.byte	3
 13884 088e 00       		.byte	0
 13885 088f 10       		.byte	16
 13886 0890 00       		.byte	0
 13887 0891 10       		.byte	16
 13888 0892 00       		.byte	0
 13889 0893 30       		.byte	48
 13890 0894 01       		.byte	1
 13891 0895 00       		.byte	0
 13892 0896 0000     		.space	2
 13895              	EXTDayNightlev:
 13896 0898 23       		.byte	35
 13897 0899 23       		.byte	35
 13898 089a 02       		.byte	2
 13899 089b 00       		.byte	0
 13900 089c 00       		.byte	0
 13901 089d 64       		.byte	100
 13902 089e 00       		.byte	0
 13903 089f 01       		.byte	1
 13904 08a0 00       		.byte	0
 13905 08a1 03       		.byte	3
 13906 08a2 00       		.byte	0
 13907 08a3 10       		.byte	16
 13908 08a4 00       		.byte	0
 13909 08a5 10       		.byte	16
 13910 08a6 00       		.byte	0
 13911 08a7 30       		.byte	48
 13912 08a8 01       		.byte	1
 13913 08a9 00       		.byte	0
 13914 08aa 0000     		.space	2
 13917              	EXTDayNightdely:
 13918 08ac 22       		.byte	34
 13919 08ad 22       		.byte	34
 13920 08ae 02       		.byte	2
 13921 08af 00       		.byte	0
 13922 08b0 00       		.byte	0
 13923 08b1 3F       		.byte	63
 13924 08b2 00       		.byte	0
 13925 08b3 01       		.byte	1
 13926 08b4 00       		.byte	0
 13927 08b5 03       		.byte	3
 13928 08b6 00       		.byte	0
 13929 08b7 00       		.byte	0
 13930 08b8 00       		.byte	0
 13931 08b9 00       		.byte	0
 13932 08ba 00       		.byte	0
 13933 08bb 30       		.byte	48
 13934 08bc 01       		.byte	1
 13935 08bd 00       		.byte	0
 13936 08be 0000     		.space	2
 13939              	EXTDayNightMode:
 13940 08c0 20       		.byte	32
 13941 08c1 20       		.byte	32
 13942 08c2 02       		.byte	2
 13943 08c3 00       		.byte	0
 13944 08c4 00       		.byte	0
 13945 08c5 02       		.byte	2
 13946 08c6 00       		.byte	0
 13947 08c7 01       		.byte	1
 13948 08c8 00       		.byte	0
 13949 08c9 03       		.byte	3
 13950 08ca 00       		.byte	0
 13951 08cb 00       		.byte	0
 13952 08cc 00       		.byte	0
 13953 08cd 00       		.byte	0
 13954 08ce 00       		.byte	0
 13955 08cf 30       		.byte	48
 13956 08d0 01       		.byte	1
 13957 08d1 00       		.byte	0
 13958 08d2 0000     		.space	2
 13961              	EXT3DNoiseLev:
 13962 08d4 19       		.byte	25
 13963 08d5 19       		.byte	25
 13964 08d6 02       		.byte	2
 13965 08d7 00       		.byte	0
 13966 08d8 00       		.byte	0
 13967 08d9 40       		.byte	64
 13968 08da 00       		.byte	0
 13969 08db 01       		.byte	1
 13970 08dc 00       		.byte	0
 13971 08dd 03       		.byte	3
 13972 08de 00       		.byte	0
 13973 08df 20       		.byte	32
 13974 08e0 00       		.byte	0
 13975 08e1 20       		.byte	32
 13976 08e2 00       		.byte	0
 13977 08e3 30       		.byte	48
 13978 08e4 01       		.byte	1
 13979 08e5 00       		.byte	0
 13980 08e6 0000     		.space	2
 13983              	EXT3DnoiseReduceMode:
 13984 08e8 18       		.byte	24
 13985 08e9 18       		.byte	24
 13986 08ea 02       		.byte	2
 13987 08eb 00       		.byte	0
 13988 08ec 00       		.byte	0
 13989 08ed 01       		.byte	1
 13990 08ee 00       		.byte	0
 13991 08ef 01       		.byte	1
 13992 08f0 00       		.byte	0
 13993 08f1 03       		.byte	3
 13994 08f2 00       		.byte	0
 13995 08f3 00       		.byte	0
 13996 08f4 00       		.byte	0
 13997 08f5 00       		.byte	0
 13998 08f6 00       		.byte	0
 13999 08f7 30       		.byte	48
 14000 08f8 01       		.byte	1
 14001 08f9 00       		.byte	0
 14002 08fa 0000     		.space	2
 14005              	EXTMirror:
 14006 08fc 05       		.byte	5
 14007 08fd 05       		.byte	5
 14008 08fe 02       		.byte	2
 14009 08ff 00       		.byte	0
 14010 0900 00       		.byte	0
 14011 0901 03       		.byte	3
 14012 0902 00       		.byte	0
 14013 0903 01       		.byte	1
 14014 0904 00       		.byte	0
 14015 0905 03       		.byte	3
 14016 0906 00       		.byte	0
 14017 0907 00       		.byte	0
 14018 0908 00       		.byte	0
 14019 0909 00       		.byte	0
 14020 090a 00       		.byte	0
 14021 090b 30       		.byte	48
 14022 090c 01       		.byte	1
 14023 090d 00       		.byte	0
 14024 090e 0000     		.space	2
 14027              	EXTSensUp:
 14028 0910 01       		.byte	1
 14029 0911 01       		.byte	1
 14030 0912 02       		.byte	2
 14031 0913 00       		.byte	0
 14032 0914 00       		.byte	0
 14033 0915 09       		.byte	9
 14034 0916 00       		.byte	0
 14035 0917 01       		.byte	1
 14036 0918 00       		.byte	0
 14037 0919 03       		.byte	3
 14038 091a 00       		.byte	0
 14039 091b 00       		.byte	0
 14040 091c 00       		.byte	0
 14041 091d 01       		.byte	1
 14042 091e 00       		.byte	0
 14043 091f 30       		.byte	48
 14044 0920 01       		.byte	1
 14045 0921 00       		.byte	0
 14046 0922 0000     		.space	2
 14049              	PUCDZoom:
 14050 0924 2A       		.byte	42
 14051 0925 2A       		.byte	42
 14052 0926 02       		.byte	2
 14053 0927 00       		.byte	0
 14054 0928 00       		.byte	0
 14055 0929 1B       		.byte	27
 14056 092a 00       		.byte	0
 14057 092b 01       		.byte	1
 14058 092c 00       		.byte	0
 14059 092d 03       		.byte	3
 14060 092e 00       		.byte	0
 14061 092f 00       		.byte	0
 14062 0930 00       		.byte	0
 14063 0931 00       		.byte	0
 14064 0932 00       		.byte	0
 14065 0933 30       		.byte	48
 14066 0934 01       		.byte	1
 14067 0935 00       		.byte	0
 14068 0936 0000     		.space	2
 14071              	PUCSaturation:
 14072 0938 85       		.byte	-123
 14073 0939 86       		.byte	-122
 14074 093a 02       		.byte	2
 14075 093b 00       		.byte	0
 14076 093c 00       		.byte	0
 14077 093d 64       		.byte	100
 14078 093e 00       		.byte	0
 14079 093f 01       		.byte	1
 14080 0940 00       		.byte	0
 14081 0941 03       		.byte	3
 14082 0942 00       		.byte	0
 14083 0943 32       		.byte	50
 14084 0944 00       		.byte	0
 14085 0945 32       		.byte	50
 14086 0946 00       		.byte	0
 14087 0947 30       		.byte	48
 14088 0948 01       		.byte	1
 14089 0949 00       		.byte	0
 14090 094a 0000     		.space	2
 14093              	PUCContrast:
 14094 094c 0D       		.byte	13
 14095 094d 0D       		.byte	13
 14096 094e 02       		.byte	2
 14097 094f 00       		.byte	0
 14098 0950 00       		.byte	0
 14099 0951 FF       		.byte	-1
 14100 0952 00       		.byte	0
 14101 0953 01       		.byte	1
 14102 0954 00       		.byte	0
 14103 0955 03       		.byte	3
 14104 0956 00       		.byte	0
 14105 0957 70       		.byte	112
 14106 0958 00       		.byte	0
 14107 0959 70       		.byte	112
 14108 095a 00       		.byte	0
 14109 095b 30       		.byte	48
 14110 095c 01       		.byte	1
 14111 095d 00       		.byte	0
 14112 095e 0000     		.space	2
 14115              	CyFxGpifRegValue_usb2:
 14116 0960 08830080 		.word	-2147450104
 14117 0964 67000000 		.word	103
 14118 0968 01000000 		.word	1
 14119 096c 46000000 		.word	70
 14120 0970 00000000 		.word	0
 14121 0974 00000000 		.word	0
 14122 0978 02000000 		.word	2
 14123 097c 82000000 		.word	130
 14124 0980 82070000 		.word	1922
 14125 0984 40040000 		.word	1088
 14126 0988 FCFF0000 		.word	65532
 14127 098c 28000000 		.word	40
 14128 0990 00000000 		.word	0
 14129 0994 00000000 		.word	0
 14130 0998 00000000 		.word	0
 14131 099c 00000000 		.word	0
 14132 09a0 01000000 		.word	1
 14133 09a4 00000000 		.word	0
 14134 09a8 00000000 		.word	0
 14135 09ac 00000000 		.word	0
 14136 09b0 00000000 		.word	0
 14137 09b4 00000000 		.word	0
 14138 09b8 00000000 		.word	0
 14139 09bc 00000000 		.word	0
 14140 09c0 00000000 		.word	0
 14141 09c4 00000000 		.word	0
 14142 09c8 00000000 		.word	0
 14143 09cc 00000000 		.word	0
 14144 09d0 00000000 		.word	0
 14145 09d4 06000000 		.word	6
 14146 09d8 00000000 		.word	0
 14147 09dc FFFF0000 		.word	65535
 14148 09e0 09010000 		.word	265
 14149 09e4 00000000 		.word	0
 14150 09e8 F71F0000 		.word	8183
 14151 09ec 00000000 		.word	0
 14152 09f0 FFFF0000 		.word	65535
 14153 09f4 09010000 		.word	265
 14154 09f8 00000000 		.word	0
 14155 09fc F71F0000 		.word	8183
 14156 0a00 00000000 		.word	0
 14157 0a04 00000000 		.word	0
 14158 0a08 00000000 		.word	0
 14159 0a0c 00000000 		.word	0
 14160 0a10 00000000 		.word	0
 14161 0a14 00000000 		.word	0
 14162 0a18 00000000 		.word	0
 14163 0a1c 00000000 		.word	0
 14164 0a20 00000000 		.word	0
 14165 0a24 00000000 		.word	0
 14166 0a28 00000000 		.word	0
 14167 0a2c 00000000 		.word	0
 14168 0a30 00000000 		.word	0
 14169 0a34 00000000 		.word	0
 14170 0a38 00000000 		.word	0
 14171 0a3c 00000000 		.word	0
 14172 0a40 00000000 		.word	0
 14173 0a44 00000000 		.word	0
 14174 0a48 00000000 		.word	0
 14175 0a4c 00000000 		.word	0
 14176 0a50 00000000 		.word	0
 14177 0a54 00000000 		.word	0
 14178 0a58 00000000 		.word	0
 14179 0a5c 00040180 		.word	-2147417088
 14180 0a60 01040180 		.word	-2147417087
 14181 0a64 02040180 		.word	-2147417086
 14182 0a68 03040180 		.word	-2147417085
 14183 0a6c 00000000 		.word	0
 14184 0a70 00000000 		.word	0
 14185 0a74 00000000 		.word	0
 14186 0a78 00000000 		.word	0
 14187 0a7c 00000000 		.word	0
 14188 0a80 00000000 		.word	0
 14189 0a84 00000000 		.word	0
 14190 0a88 00000000 		.word	0
 14191 0a8c C1FFFFFF 		.word	-63
 14194              	CyFxGpifWavedataPosition_usb2:
 14195 0a90 00       		.byte	0
 14196 0a91 01       		.byte	1
 14197 0a92 02       		.byte	2
 14198 0a93 03       		.byte	3
 14199 0a94 04       		.byte	4
 14200 0a95 05       		.byte	5
 14201 0a96 06       		.byte	6
 14202 0a97 07       		.byte	7
 14203 0a98 08       		.byte	8
 14204 0a99 09       		.byte	9
 14205 0a9a 0A       		.byte	10
 14206 0a9b 08       		.byte	8
 14207 0a9c 0B       		.byte	11
 14208 0a9d 0C       		.byte	12
 14209 0a9e 0D       		.byte	13
 14210 0a9f 08       		.byte	8
 14211 0aa0 0E       		.byte	14
 14212 0aa1 0F       		.byte	15
 14213 0aa2 08       		.byte	8
 14214 0aa3 08       		.byte	8
 14215 0aa4 08       		.byte	8
 14216 0aa5 08       		.byte	8
 14217 0aa6 08       		.byte	8
 14218 0aa7 08       		.byte	8
 14219 0aa8 08       		.byte	8
 14220 0aa9 08       		.byte	8
 14221 0aaa 08       		.byte	8
 14222 0aab 08       		.byte	8
 14223 0aac 08       		.byte	8
 14224 0aad 08       		.byte	8
 14225 0aae 08       		.byte	8
 14226 0aaf 08       		.byte	8
 14227 0ab0 08       		.byte	8
 14228 0ab1 08       		.byte	8
 14229 0ab2 08       		.byte	8
 14230 0ab3 08       		.byte	8
 14231 0ab4 08       		.byte	8
 14232 0ab5 08       		.byte	8
 14233 0ab6 08       		.byte	8
 14234 0ab7 08       		.byte	8
 14235 0ab8 08       		.byte	8
 14236 0ab9 08       		.byte	8
 14237 0aba 08       		.byte	8
 14238 0abb 08       		.byte	8
 14239 0abc 08       		.byte	8
 14240 0abd 08       		.byte	8
 14241 0abe 08       		.byte	8
 14242 0abf 08       		.byte	8
 14243 0ac0 08       		.byte	8
 14244 0ac1 08       		.byte	8
 14245 0ac2 08       		.byte	8
 14246 0ac3 08       		.byte	8
 14247 0ac4 08       		.byte	8
 14248 0ac5 08       		.byte	8
 14249 0ac6 08       		.byte	8
 14250 0ac7 08       		.byte	8
 14251 0ac8 08       		.byte	8
 14252 0ac9 08       		.byte	8
 14253 0aca 08       		.byte	8
 14254 0acb 08       		.byte	8
 14255 0acc 08       		.byte	8
 14256 0acd 08       		.byte	8
 14257 0ace 08       		.byte	8
 14258 0acf 08       		.byte	8
 14259 0ad0 08       		.byte	8
 14260 0ad1 08       		.byte	8
 14261 0ad2 08       		.byte	8
 14262 0ad3 08       		.byte	8
 14263 0ad4 08       		.byte	8
 14264 0ad5 08       		.byte	8
 14265 0ad6 08       		.byte	8
 14266 0ad7 08       		.byte	8
 14267 0ad8 08       		.byte	8
 14268 0ad9 08       		.byte	8
 14269 0ada 08       		.byte	8
 14270 0adb 08       		.byte	8
 14271 0adc 08       		.byte	8
 14272 0add 08       		.byte	8
 14273 0ade 08       		.byte	8
 14274 0adf 08       		.byte	8
 14275 0ae0 08       		.byte	8
 14276 0ae1 08       		.byte	8
 14277 0ae2 08       		.byte	8
 14278 0ae3 08       		.byte	8
 14279 0ae4 08       		.byte	8
 14280 0ae5 08       		.byte	8
 14281 0ae6 08       		.byte	8
 14282 0ae7 08       		.byte	8
 14283 0ae8 08       		.byte	8
 14284 0ae9 08       		.byte	8
 14285 0aea 08       		.byte	8
 14286 0aeb 08       		.byte	8
 14287 0aec 08       		.byte	8
 14288 0aed 08       		.byte	8
 14289 0aee 08       		.byte	8
 14290 0aef 08       		.byte	8
 14291 0af0 08       		.byte	8
 14292 0af1 08       		.byte	8
 14293 0af2 08       		.byte	8
 14294 0af3 08       		.byte	8
 14295 0af4 08       		.byte	8
 14296 0af5 08       		.byte	8
 14297 0af6 08       		.byte	8
 14298 0af7 08       		.byte	8
 14299 0af8 08       		.byte	8
 14300 0af9 08       		.byte	8
 14301 0afa 08       		.byte	8
 14302 0afb 08       		.byte	8
 14303 0afc 08       		.byte	8
 14304 0afd 08       		.byte	8
 14305 0afe 08       		.byte	8
 14306 0aff 08       		.byte	8
 14307 0b00 08       		.byte	8
 14308 0b01 08       		.byte	8
 14309 0b02 08       		.byte	8
 14310 0b03 08       		.byte	8
 14311 0b04 08       		.byte	8
 14312 0b05 08       		.byte	8
 14313 0b06 08       		.byte	8
 14314 0b07 08       		.byte	8
 14315 0b08 08       		.byte	8
 14316 0b09 08       		.byte	8
 14317 0b0a 08       		.byte	8
 14318 0b0b 08       		.byte	8
 14319 0b0c 08       		.byte	8
 14320 0b0d 08       		.byte	8
 14321 0b0e 08       		.byte	8
 14322 0b0f 08       		.byte	8
 14323 0b10 00       		.byte	0
 14324 0b11 01       		.byte	1
 14325 0b12 02       		.byte	2
 14326 0b13 10       		.byte	16
 14327 0b14 04       		.byte	4
 14328 0b15 05       		.byte	5
 14329 0b16 06       		.byte	6
 14330 0b17 07       		.byte	7
 14331 0b18 08       		.byte	8
 14332 0b19 09       		.byte	9
 14333 0b1a 0A       		.byte	10
 14334 0b1b 08       		.byte	8
 14335 0b1c 11       		.byte	17
 14336 0b1d 0C       		.byte	12
 14337 0b1e 0D       		.byte	13
 14338 0b1f 08       		.byte	8
 14339 0b20 0E       		.byte	14
 14340 0b21 0F       		.byte	15
 14341 0b22 08       		.byte	8
 14342 0b23 00       		.space	1
 14345              	CyFxGpifWavedata_usb2:
 14346 0b24 0181731E 		.word	510886145
 14347 0b28 00000000 		.word	0
 14348 0b2c 00000080 		.word	-2147483648
 14349 0b30 00000000 		.word	0
 14350 0b34 00000000 		.word	0
 14351 0b38 00000000 		.word	0
 14352 0b3c 0201703E 		.word	1047527682
 14353 0b40 00010000 		.word	256
 14354 0b44 A00000C0 		.word	-1073741664
 14355 0b48 00000000 		.word	0
 14356 0b4c 00000000 		.word	0
 14357 0b50 00000000 		.word	0
 14358 0b54 0394731E 		.word	510891011
 14359 0b58 04000020 		.word	536870916
 14360 0b5c 60004080 		.word	-2143289248
 14361 0b60 00000000 		.word	0
 14362 0b64 00000000 		.word	0
 14363 0b68 00000000 		.word	0
 14364 0b6c 0620702E 		.word	779100166
 14365 0b70 0C000000 		.word	12
 14366 0b74 00000080 		.word	-2147483648
 14367 0b78 0620702E 		.word	779100166
 14368 0b7c 0C000000 		.word	12
 14369 0b80 00000080 		.word	-2147483648
 14370 0b84 0394731E 		.word	510891011
 14371 0b88 04000020 		.word	536870916
 14372 0b8c 60004080 		.word	-2143289248
 14373 0b90 0620702E 		.word	779100166
 14374 0b94 0C000000 		.word	12
 14375 0b98 00000080 		.word	-2147483648
 14376 0b9c 0C93731E 		.word	510890764
 14377 0ba0 04000024 		.word	603979780
 14378 0ba4 90004080 		.word	-2143289200
 14379 0ba8 0D20702E 		.word	779100173
 14380 0bac 0C000000 		.word	12
 14381 0bb0 00000080 		.word	-2147483648
 14382 0bb4 0780724E 		.word	1316126727
 14383 0bb8 0A000000 		.word	10
 14384 0bbc 00000080 		.word	-2147483648
 14385 0bc0 08000000 		.word	8
 14386 0bc4 00000000 		.word	0
 14387 0bc8 00010080 		.word	-2147483392
 14388 0bcc 0920702E 		.word	779100169
 14389 0bd0 0C010000 		.word	268
 14390 0bd4 00000080 		.word	-2147483648
 14391 0bd8 0A01701E 		.word	510656778
 14392 0bdc 0E000100 		.word	65550
 14393 0be0 00000080 		.word	-2147483648
 14394 0be4 00000000 		.word	0
 14395 0be8 00000000 		.word	0
 14396 0bec 00000000 		.word	0
 14397 0bf0 00000000 		.word	0
 14398 0bf4 00000000 		.word	0
 14399 0bf8 00000000 		.word	0
 14400 0bfc 0394731E 		.word	510891011
 14401 0c00 04000020 		.word	536870916
 14402 0c04 60004080 		.word	-2143289248
 14403 0c08 08000000 		.word	8
 14404 0c0c 00000000 		.word	0
 14405 0c10 00010080 		.word	-2147483392
 14406 0c14 0B000000 		.word	11
 14407 0c18 00000000 		.word	0
 14408 0c1c 00010080 		.word	-2147483392
 14409 0c20 0C93731E 		.word	510890764
 14410 0c24 04000024 		.word	603979780
 14411 0c28 90004080 		.word	-2143289200
 14412 0c2c 0D20702E 		.word	779100173
 14413 0c30 0C000000 		.word	12
 14414 0c34 00000080 		.word	-2147483648
 14415 0c38 0D20702E 		.word	779100173
 14416 0c3c 0C000000 		.word	12
 14417 0c40 00000080 		.word	-2147483648
 14418 0c44 0E60724E 		.word	1316118542
 14419 0c48 0A000000 		.word	10
 14420 0c4c 00000080 		.word	-2147483648
 14421 0c50 0F000000 		.word	15
 14422 0c54 00000000 		.word	0
 14423 0c58 00010080 		.word	-2147483392
 14424 0c5c 1020702E 		.word	779100176
 14425 0c60 0C010000 		.word	268
 14426 0c64 00000080 		.word	-2147483648
 14427 0c68 1101701E 		.word	510656785
 14428 0c6c 0E000100 		.word	65550
 14429 0c70 00000080 		.word	-2147483648
 14430 0c74 0C93731E 		.word	510890764
 14431 0c78 04000024 		.word	603979780
 14432 0c7c 90004080 		.word	-2143289200
 14433 0c80 0F000000 		.word	15
 14434 0c84 00000000 		.word	0
 14435 0c88 00010080 		.word	-2147483392
 14436 0c8c 12000000 		.word	18
 14437 0c90 00000000 		.word	0
 14438 0c94 00010080 		.word	-2147483392
 14439 0c98 0394731E 		.word	510891011
 14440 0c9c 04000020 		.word	536870916
 14441 0ca0 60004080 		.word	-2143289248
 14442 0ca4 0480732E 		.word	779321348
 14443 0ca8 02010000 		.word	258
 14444 0cac 0000C0C0 		.word	-1061158912
 14445 0cb0 0580732E 		.word	779321349
 14446 0cb4 02010000 		.word	258
 14447 0cb8 0000C0C0 		.word	-1061158912
 14448 0cbc 0580732E 		.word	779321349
 14449 0cc0 02010000 		.word	258
 14450 0cc4 0000C0C0 		.word	-1061158912
 14451 0cc8 0480732E 		.word	779321348
 14452 0ccc 02010000 		.word	258
 14453 0cd0 0000C0C0 		.word	-1061158912
 14456              	CyFxGpifTransition_usb2:
 14457 0cd4 0000     		.short	0
 14458 0cd6 5555     		.short	21845
 14459 0cd8 AAAA     		.short	-21846
 14460 0cda 8888     		.short	-30584
 14461 0cdc 1111     		.short	4369
 14462 0cde 4444     		.short	17476
 14463 0ce0 3333     		.short	13107
 14464 0ce2 CCCC     		.short	-13108
 14467              	CyFxGpifRegValue:
 14468 0ce4 08830080 		.word	-2147450104
 14469 0ce8 67000000 		.word	103
 14470 0cec 00000000 		.word	0
 14471 0cf0 46000000 		.word	70
 14472 0cf4 00000000 		.word	0
 14473 0cf8 00000000 		.word	0
 14474 0cfc 02000000 		.word	2
 14475 0d00 82000000 		.word	130
 14476 0d04 82070000 		.word	1922
 14477 0d08 40040000 		.word	1088
 14478 0d0c FCFF0000 		.word	65532
 14479 0d10 28000000 		.word	40
 14480 0d14 00000000 		.word	0
 14481 0d18 00000000 		.word	0
 14482 0d1c 00000000 		.word	0
 14483 0d20 00000000 		.word	0
 14484 0d24 01000000 		.word	1
 14485 0d28 00000000 		.word	0
 14486 0d2c 00000000 		.word	0
 14487 0d30 00000000 		.word	0
 14488 0d34 00000000 		.word	0
 14489 0d38 00000000 		.word	0
 14490 0d3c 00000000 		.word	0
 14491 0d40 00000000 		.word	0
 14492 0d44 00000000 		.word	0
 14493 0d48 00000000 		.word	0
 14494 0d4c 00000000 		.word	0
 14495 0d50 00000000 		.word	0
 14496 0d54 00000000 		.word	0
 14497 0d58 06000000 		.word	6
 14498 0d5c 00000000 		.word	0
 14499 0d60 FFFF0000 		.word	65535
 14500 0d64 09010000 		.word	265
 14501 0d68 00000000 		.word	0
 14502 0d6c F71F0000 		.word	8183
 14503 0d70 00000000 		.word	0
 14504 0d74 FFFF0000 		.word	65535
 14505 0d78 09010000 		.word	265
 14506 0d7c 00000000 		.word	0
 14507 0d80 F71F0000 		.word	8183
 14508 0d84 00000000 		.word	0
 14509 0d88 00000000 		.word	0
 14510 0d8c 00000000 		.word	0
 14511 0d90 00000000 		.word	0
 14512 0d94 00000000 		.word	0
 14513 0d98 00000000 		.word	0
 14514 0d9c 00000000 		.word	0
 14515 0da0 00000000 		.word	0
 14516 0da4 00000000 		.word	0
 14517 0da8 00000000 		.word	0
 14518 0dac 00000000 		.word	0
 14519 0db0 00000000 		.word	0
 14520 0db4 00000000 		.word	0
 14521 0db8 00000000 		.word	0
 14522 0dbc 00000000 		.word	0
 14523 0dc0 00000000 		.word	0
 14524 0dc4 00000000 		.word	0
 14525 0dc8 00000000 		.word	0
 14526 0dcc 00000000 		.word	0
 14527 0dd0 00000000 		.word	0
 14528 0dd4 00000000 		.word	0
 14529 0dd8 00000000 		.word	0
 14530 0ddc 00000000 		.word	0
 14531 0de0 00040180 		.word	-2147417088
 14532 0de4 01040180 		.word	-2147417087
 14533 0de8 02040180 		.word	-2147417086
 14534 0dec 03040180 		.word	-2147417085
 14535 0df0 00000000 		.word	0
 14536 0df4 00000000 		.word	0
 14537 0df8 00000000 		.word	0
 14538 0dfc 00000000 		.word	0
 14539 0e00 00000000 		.word	0
 14540 0e04 00000000 		.word	0
 14541 0e08 00000000 		.word	0
 14542 0e0c 00000000 		.word	0
 14543 0e10 C1FFFFFF 		.word	-63
 14546              	CyFxGpifWavedataPosition:
 14547 0e14 00       		.byte	0
 14548 0e15 01       		.byte	1
 14549 0e16 02       		.byte	2
 14550 0e17 03       		.byte	3
 14551 0e18 04       		.byte	4
 14552 0e19 05       		.byte	5
 14553 0e1a 06       		.byte	6
 14554 0e1b 07       		.byte	7
 14555 0e1c 08       		.byte	8
 14556 0e1d 09       		.byte	9
 14557 0e1e 0A       		.byte	10
 14558 0e1f 0B       		.byte	11
 14559 0e20 0B       		.byte	11
 14560 0e21 0B       		.byte	11
 14561 0e22 0B       		.byte	11
 14562 0e23 00       		.space	1
 14565              	CyFxGpifWavedata:
 14566 0e24 0181731E 		.word	510886145
 14567 0e28 00000000 		.word	0
 14568 0e2c 00000080 		.word	-2147483648
 14569 0e30 00000000 		.word	0
 14570 0e34 00000000 		.word	0
 14571 0e38 00000000 		.word	0
 14572 0e3c 0201702E 		.word	779092226
 14573 0e40 00010000 		.word	256
 14574 0e44 A0000080 		.word	-2147483488
 14575 0e48 00000000 		.word	0
 14576 0e4c 00000000 		.word	0
 14577 0e50 00000000 		.word	0
 14578 0e54 0380722E 		.word	779255811
 14579 0e58 02010020 		.word	536871170
 14580 0e5c 60000080 		.word	-2147483552
 14581 0e60 00000000 		.word	0
 14582 0e64 00000000 		.word	0
 14583 0e68 00000000 		.word	0
 14584 0e6c 0460722E 		.word	779247620
 14585 0e70 02010024 		.word	603980034
 14586 0e74 90000080 		.word	-2147483504
 14587 0e78 0594731E 		.word	510891013
 14588 0e7c 06000000 		.word	6
 14589 0e80 00000080 		.word	-2147483648
 14590 0e84 0380722E 		.word	779255811
 14591 0e88 02010020 		.word	536871170
 14592 0e8c 60000080 		.word	-2147483552
 14593 0e90 0693731E 		.word	510890758
 14594 0e94 06000000 		.word	6
 14595 0e98 00000080 		.word	-2147483648
 14596 0e9c 0720703E 		.word	1047535623
 14597 0ea0 08010000 		.word	264
 14598 0ea4 00000080 		.word	-2147483648
 14599 0ea8 0820703E 		.word	1047535624
 14600 0eac 08010000 		.word	264
 14601 0eb0 00000080 		.word	-2147483648
 14602 0eb4 0920703E 		.word	1047535625
 14603 0eb8 08010000 		.word	264
 14604 0ebc 00000080 		.word	-2147483648
 14605 0ec0 0A20703E 		.word	1047535626
 14606 0ec4 08010000 		.word	264
 14607 0ec8 00000080 		.word	-2147483648
 14608 0ecc 0380722E 		.word	779255811
 14609 0ed0 02010020 		.word	536871170
 14610 0ed4 60000080 		.word	-2147483552
 14611 0ed8 0B000000 		.word	11
 14612 0edc 00000000 		.word	0
 14613 0ee0 00010080 		.word	-2147483392
 14614 0ee4 0460722E 		.word	779247620
 14615 0ee8 02010024 		.word	603980034
 14616 0eec 90000080 		.word	-2147483504
 14617 0ef0 0D000000 		.word	13
 14618 0ef4 00000000 		.word	0
 14619 0ef8 00010080 		.word	-2147483392
 14620 0efc 0460722E 		.word	779247620
 14621 0f00 02010024 		.word	603980034
 14622 0f04 90000080 		.word	-2147483504
 14623 0f08 0C000000 		.word	12
 14624 0f0c 00000000 		.word	0
 14625 0f10 00010080 		.word	-2147483392
 14626 0f14 0380722E 		.word	779255811
 14627 0f18 02010020 		.word	536871170
 14628 0f1c 60000080 		.word	-2147483552
 14629 0f20 0E000000 		.word	14
 14630 0f24 00000000 		.word	0
 14631 0f28 00010080 		.word	-2147483392
 14632 0f2c 00000000 		.word	0
 14633 0f30 00000000 		.word	0
 14634 0f34 00000000 		.word	0
 14635 0f38 00000000 		.word	0
 14636 0f3c 00000000 		.word	0
 14637 0f40 00000000 		.word	0
 14640              	CyFxGpifTransition:
 14641 0f44 0000     		.short	0
 14642 0f46 5555     		.short	21845
 14643 0f48 8888     		.short	-30584
 14644 0f4a AAAA     		.short	-21846
 14645 0f4c 3333     		.short	13107
 14646 0f4e 0000     		.section	.rodata.str1.4,"aMS",%progbits,1
 14647              		.align	2
 14648              	.LC0:
 14649 0000 49324320 		.ascii	"I2C pos-timer %d %d\015\012\000"
 14649      706F732D 
 14649      74696D65 
 14649      72202564 
 14649      2025640D 
 14650 0016 0000     		.space	2
 14651              	.LC1:
 14652 0018 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 14652      6F207374 
 14652      7265616D 
 14652      20474554 
 14652      20726571 
 14653 003d 000000   		.space	3
 14654              	.LC2:
 14655 0040 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 14655      74686520 
 14655      76696465 
 14655      6F206D6F 
 14655      64652066 
 14656 0061 000000   		.space	3
 14657              	.LC3:
 14658 0064 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 14658      74686520 
 14658      76696465 
 14658      6F206D6F 
 14658      64652066 
 14659 0089 000000   		.space	3
 14660              	.LC4:
 14661 008c 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 14661      43595F46 
 14661      585F5556 
 14661      435F5354 
 14661      5245414D 
 14662 00b2 0000     		.space	2
 14663              	.LC5:
 14664 00b4 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 14664      55564320 
 14664      7374696C 
 14664      6C205072 
 14664      6F622873 
 14665 00df 00       		.space	1
 14666              	.LC6:
 14667 00e0 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 14667      74686520 
 14667      7374696C 
 14667      6C206D6F 
 14667      64652066 
 14668 0101 000000   		.space	3
 14669              	.LC7:
 14670 0104 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 14670      7374696C 
 14670      6C20636F 
 14670      6D6D6974 
 14670      20636F6E 
 14671              	.LC8:
 14672 012c 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 14672      43595F46 
 14672      585F5556 
 14672      435F5354 
 14672      494C5F45 
 14673              	.LC9:
 14674 0150 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 14674      55564320 
 14674      7374696C 
 14674      6C207472 
 14674      69676765 
 14675 0179 000000   		.space	3
 14676              	.LC10:
 14677 017c 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 14677      7374696C 
 14677      6C207472 
 14677      69676765 
 14677      7220636F 
 14678 01a3 00       		.space	1
 14679              	.LC11:
 14680 01a4 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 14680      7065722D 
 14680      74696D65 
 14680      72202564 
 14680      0D0A00
 14681 01b7 00       		.space	1
 14682              	.LC12:
 14683 01b8 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 14683      636F6D6D 
 14683      616E6420 
 14683      71756575 
 14683      65206973 
 14684 01db 00       		.space	1
 14685              	.LC13:
 14686 01dc 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 14686      7220696E 
 14686      206D756C 
 14686      74696368 
 14686      616E6E65 
 14687 020f 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 14687      2025782C 
 14687      20646D61 
 14687      446F6E65 
 14687      20256420 
 14688              	.LC14:
 14689 0228 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 14689      5420656E 
 14689      636F756E 
 14689      74657265 
 14689      642E2E2E 
 14690              	.LC15:
 14691 0248 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 14691      454E4420 
 14691      656E636F 
 14691      756E7465 
 14691      7265642E 
 14692 026a 0000     		.space	2
 14693              	.LC16:
 14694 026c 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 14694      64697363 
 14694      6F6E6E65 
 14694      63746564 
 14694      2E2E2E30 
 14695 028b 00       		.space	1
 14696              	.LC17:
 14697 028c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 14697      43595F46 
 14697      585F5556 
 14697      435F5649 
 14697      44454F5F 
 14698 02bf 0A00     		.ascii	"\012\000"
 14699 02c1 000000   		.space	3
 14700              	.LC18:
 14701 02c4 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 14701      43595F46 
 14701      585F5556 
 14701      435F5649 
 14701      44454F5F 
 14702 02f7 00       		.ascii	"\000"
 14703              	.LC19:
 14704 02f8 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 14704      726E6174 
 14704      65207365 
 14704      7474696E 
 14704      6720302E 
 14705              	.LC20:
 14706 0310 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 14706      72206665 
 14706      61747572 
 14706      65207265 
 14706      71756573 
 14707 0333 00       		.space	1
 14708              	.LC21:
 14709 0334 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 14709      49324320 
 14709      636F6D6D 
 14709      616E6420 
 14709      69732030 
 14710 0367 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 14710      78257820 
 14710      30782578 
 14710      20307825 
 14710      78203078 
 14711              	.LC22:
 14712 0380 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 14712      49324320 
 14712      636F6D6D 
 14712      616E6420 
 14712      73657474 
 14713 03a6 0000     		.space	2
 14714              	.LC23:
 14715 03a8 54686520 		.ascii	"The shutter set value %d 0x%x 0x%x 0x%x\015\012\000"
 14715      73687574 
 14715      74657220 
 14715      73657420 
 14715      76616C75 
 14716 03d2 0000     		.space	2
 14717              	.LC24:
 14718 03d4 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 14718      26414743 
 14718      2073656E 
 14718      7420746F 
 14718      20686F73 
 14719 03fa 0000     		.space	2
 14720              	.LC25:
 14721 03fc 54686520 		.ascii	"The I2C current data is not available. try again. %"
 14721      49324320 
 14721      63757272 
 14721      656E7420 
 14721      64617461 
 14722 042f 64202564 		.ascii	"d %d\015\012\000"
 14722      0D0A00
 14723 0436 0000     		.space	2
 14724              	.LC26:
 14725 0438 54686520 		.ascii	"The current value 0x%x 0x%x 0x%x, 0x%x, %d\015\012\000"
 14725      63757272 
 14725      656E7420 
 14725      76616C75 
 14725      65203078 
 14726 0465 000000   		.space	3
 14727              	.LC27:
 14728 0468 54686520 		.ascii	"The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x d"
 14728      73657420 
 14728      636F6E74 
 14728      726F6C20 
 14728      6374726C 
 14729 049b 65764144 		.ascii	"evADD: 0x%x Len: 0x%x Data0: 0x%x Data1: 0x%x\015\012"
 14729      443A2030 
 14729      78257820 
 14729      4C656E3A 
 14729      20307825 
 14730 04ca 00       		.ascii	"\000"
 14731 04cb 00       		.space	1
 14732              	.LC28:
 14733 04cc 4578704D 		.ascii	"ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\015"
 14733      26414743 
 14733      20676F74 
 14733      74656E20 
 14733      66726F6D 
 14734 04fd 0A00     		.ascii	"\012\000"
 14735 04ff 00       		.space	1
 14736              	.LC29:
 14737 0500 54686520 		.ascii	"The shutter&exposure 0x%x 0x%x 0x%x 0x%x\015\012\000"
 14737      73687574 
 14737      74657226 
 14737      6578706F 
 14737      73757265 
 14738 052b 00       		.space	1
 14739              	.LC30:
 14740 052c 53687574 		.ascii	"Shutter level gotten from host. 0x%x %d; 0x%x 0x%x "
 14740      74657220 
 14740      6C657665 
 14740      6C20676F 
 14740      7474656E 
 14741 055f 25640D0A 		.ascii	"%d\015\012\000"
 14741      00
 14742              	.LC31:
 14743 0564 54686520 		.ascii	"The data gets from host. [0]: 0x%x [1]: 0x%x curLo:"
 14743      64617461 
 14743      20676574 
 14743      73206672 
 14743      6F6D2068 
 14744 0597 20307825 		.ascii	" 0x%x curHi: 0x%x Len: 0x%x\015\012\000"
 14744      78206375 
 14744      7248693A 
 14744      20307825 
 14744      78204C65 
 14745 05b5 000000   		.space	3
 14746              	.LC32:
 14747 05b8 46726571 		.ascii	"Frequency setting is  %d %d\015\012\000"
 14747      75656E63 
 14747      79207365 
 14747      7474696E 
 14747      67206973 
 14748 05d6 0000     		.space	2
 14749              	.LC33:
 14750 05d8 46536574 		.ascii	"FSet the video mode format %x %d\012\000"
 14750      20746865 
 14750      20766964 
 14750      656F206D 
 14750      6F646520 
 14751 05fa 0000     		.space	2
 14752              	.LC34:
 14753 05fc 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 14753      67657420 
 14753      64617461 
 14753      2066726F 
 14753      6D20686F 
 14754 0629 000000   		.space	3
 14755              	.LC35:
 14756 062c 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 14756      52657175 
 14756      65737420 
 14756      30782578 
 14756      20706172 
 14757 065f 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 14757      6E642074 
 14757      6F20686F 
 14757      73742030 
 14757      78257820 
 14758 067a 0000     		.space	2
 14759              	.LC36:
 14760 067c 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 14760      204F7020 
 14760      72656365 
 14760      69766573 
 14760      20284354 
 14761 06a3 00       		.space	1
 14762              	.LC37:
 14763 06a4 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 14763      756C7420 
 14763      73656C65 
 14763      63746F72 
 14763      20284354 
 14764 06c6 0000     		.space	2
 14765              	.LC38:
 14766 06c8 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 14766      756C7420 
 14766      72657175 
 14766      65737420 
 14766      28435429 
 14767 06e9 000000   		.space	3
 14768              	.LC39:
 14769 06ec 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 14769      52657175 
 14769      65737420 
 14769      30782578 
 14769      20706172 
 14770 071f 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 14770      20307825 
 14770      78202F20 
 14770      73656E64 
 14770      20746F20 
 14771 074c 00       		.ascii	"\000"
 14772 074d 000000   		.space	3
 14773              	.LC40:
 14774 0750 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 14774      73657420 
 14774      64656620 
 14774      64617461 
 14774      20307825 
 14775 076f 00       		.space	1
 14776              	.LC41:
 14777 0770 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 14777      73657420 
 14777      64656620 
 14777      64617461 
 14777      20307825 
 14778 07a3 2E0D0A00 		.ascii	".\015\012\000"
 14779 07a7 00       		.space	1
 14780              	.LC42:
 14781 07a8 4572726F 		.ascii	"Error handler...\015\012\000"
 14781      72206861 
 14781      6E646C65 
 14781      722E2E2E 
 14781      0D0A00
 14782 07bb 00       		.space	1
 14783              	.LC43:
 14784 07bc 55415254 		.ascii	"UART initialization failed!\012\000"
 14784      20696E69 
 14784      7469616C 
 14784      697A6174 
 14784      696F6E20 
 14785 07d9 000000   		.space	3
 14786              	.LC44:
 14787 07dc 49324320 		.ascii	"I2C initialization failed!\012\000"
 14787      696E6974 
 14787      69616C69 
 14787      7A617469 
 14787      6F6E2066 
 14788              	.LC45:
 14789 07f8 49324320 		.ascii	"I2C configuration failed!\012\000"
 14789      636F6E66 
 14789      69677572 
 14789      6174696F 
 14789      6E206661 
 14790 0813 00       		.space	1
 14791              	.LC46:
 14792 0814 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 14792      43726561 
 14792      74652045 
 14792      76656E74 
 14792      20666169 
 14793 083e 0000     		.space	2
 14794              	.LC47:
 14795 0840 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 14795      20496E69 
 14795      74206661 
 14795      696C6564 
 14795      2C204572 
 14796 0863 00       		.space	1
 14797              	.LC48:
 14798 0864 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 14798      204F7665 
 14798      72726964 
 14798      65206661 
 14798      696C6564 
 14799 088b 00       		.space	1
 14800              	.LC49:
 14801 088c 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 14801      28323029 
 14801      204F7665 
 14801      72726964 
 14801      65206661 
 14802 08b7 00       		.space	1
 14803              	.LC50:
 14804 08b8 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 14804      28323429 
 14804      204F7665 
 14804      72726964 
 14804      65206661 
 14805 08e3 00       		.space	1
 14806              	.LC51:
 14807 08e4 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 14807      20536574 
 14807      20287265 
 14807      73657420 
 14807      32322920 
 14808 0916 00       		.ascii	"\000"
 14809 0917 00       		.space	1
 14810              	.LC52:
 14811 0918 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 14811      20536574 
 14811      2028706F 
 14811      77657220 
 14811      32302920 
 14812 094a 00       		.ascii	"\000"
 14813 094b 00       		.space	1
 14814              	.LC53:
 14815 094c 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 14815      20536574 
 14815      2028736E 
 14815      61702073 
 14815      686F7420 
 14816 097f 25640A00 		.ascii	"%d\012\000"
 14817 0983 00       		.space	1
 14818              	.LC54:
 14819 0984 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 14819      46756E63 
 14819      74696F6E 
 14819      20466169 
 14819      6C656420 
 14820 09b3 00       		.space	1
 14821              	.LC55:
 14822 09b4 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 14822      46756E63 
 14822      74696F6E 
 14822      20466169 
 14822      6C656420 
 14823 09e3 00       		.space	1
 14824              	.LC56:
 14825 09e4 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 14825      53657420 
 14825      456E6470 
 14825      6F696E74 
 14825      20636F6E 
 14826 0a14 00       		.ascii	"\000"
 14827 0a15 000000   		.space	3
 14828              	.LC57:
 14829 0a18 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 14829      496E7465 
 14829      72727570 
 14829      74205374 
 14829      61747573 
 14830 0a4b 20436F64 		.ascii	" Code = %d\012\000"
 14830      65203D20 
 14830      25640A00 
 14831 0a57 00       		.space	1
 14832              	.LC58:
 14833 0a58 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 14833      65642074 
 14833      6F20616C 
 14833      6C6F6361 
 14833      7465206D 
 14834 0a8b 65720D0A 		.ascii	"er\015\012\000"
 14834      00
 14835              	.LC59:
 14836 0a90 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 14836      4368616E 
 14836      6E656C20 
 14836      43726561 
 14836      74696F6E 
 14837 0abe 0000     		.space	2
 14838              	.LC60:
 14839 0ac0 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 14839      436F6E6E 
 14839      65637420 
 14839      6661696C 
 14839      65642C20 
 14840 0ae5 000000   		.space	3
 14841              	.LC61:
 14842 0ae8 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 14842      74686520 
 14842      76696465 
 14842      6F206D6F 
 14842      64652066 
 14843 0b0a 0000     		.space	2
 14844              	.LC62:
 14845 0b0c 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 14845      4368616E 
 14845      6E656C20 
 14845      52657365 
 14845      74204661 
 14846 0b37 00       		.space	1
 14847              	.LC63:
 14848 0b38 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 14848      4368616E 
 14848      6E656C20 
 14848      53657420 
 14848      5472616E 
 14849 0b69 00       		.ascii	"\000"
 14850 0b6a 0000     		.space	2
 14851              	.LC64:
 14852 0b6c 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 14852      4368616E 
 14852      6E656C20 
 14852      53657420 
 14852      5472616E 
 14853 0b9d 0A00     		.ascii	"\012\000"
 14854 0b9f 00       		.space	1
 14855              	.LC65:
 14856 0ba0 0D0A2073 		.ascii	"\015\012 super gpif\000"
 14856      75706572 
 14856      20677069 
 14856      6600
 14857 0bae 0000     		.space	2
 14858              	.LC66:
 14859 0bb0 0D0A2068 		.ascii	"\015\012 high gpif\000"
 14859      69676820 
 14859      67706966 
 14859      00
 14860 0bbd 000000   		.space	3
 14861              	.LC67:
 14862 0bc0 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 14862      696E6720 
 14862      47504946 
 14862      20436F6E 
 14862      66696775 
 14863 0bf3 0A00     		.ascii	"\012\000"
 14864 0bf5 000000   		.space	3
 14865              	.LC68:
 14866 0bf8 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 14866      74696E67 
 14866      20475049 
 14866      46207374 
 14866      61746520 
 14867 0c2b 0D0A00   		.ascii	"\015\012\000"
 14868 0c2e 0000     		.space	2
 14869              	.LC69:
 14870 0c30 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 14870      73706565 
 14870      64203D20 
 14870      25642065 
 14870      76656E66 
 14871 0c60 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 14871      71756573 
 14871      74203D20 
 14871      30782578 
 14871      20775661 
 14872 0c90 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 14872      203D2030 
 14872      78257820 
 14872      6973666C 
 14872      61672030 
 14873 0caa 0000     		.space	2
 14874              	.LC70:
 14875 0cac 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 14875      64656661 
 14875      756C7420 
 14875      73657475 
 14875      70207265 
 14876              	.LC71:
 14877 0cd8 54686520 		.ascii	"The hyster command 0x%x 0x%x\015\012\000"
 14877      68797374 
 14877      65722063 
 14877      6F6D6D61 
 14877      6E642030 
 14878 0cf7 00       		.space	1
 14879              	.LC72:
 14880 0cf8 54686520 		.ascii	"The ctrlspd command 0x%x 0x%x\015\012\000"
 14880      6374726C 
 14880      73706420 
 14880      636F6D6D 
 14880      616E6420 
 14881              	.LC73:
 14882 0d18 54686520 		.ascii	"The edgeMode command 0x%x 0x%x\015\012\000"
 14882      65646765 
 14882      4D6F6465 
 14882      20636F6D 
 14882      6D616E64 
 14883 0d39 000000   		.space	3
 14884              	.LC74:
 14885 0d3c 54686520 		.ascii	"The edgegain command 0x%x 0x%x\015\012\000"
 14885      65646765 
 14885      6761696E 
 14885      20636F6D 
 14885      6D616E64 
 14886 0d5d 000000   		.space	3
 14887              	.LC75:
 14888 0d60 54686520 		.ascii	"The edge start/end command 0x%x 0x%x\015\012\000"
 14888      65646765 
 14888      20737461 
 14888      72742F65 
 14888      6E642063 
 14889 0d87 00       		.space	1
 14890              	.LC76:
 14891 0d88 54686520 		.ascii	"The 2DNR start/end command 0x%x 0x%x\015\012\000"
 14891      32444E52 
 14891      20737461 
 14891      72742F65 
 14891      6E642063 
 14892 0daf 00       		.space	1
 14893              	.LC77:
 14894 0db0 54686520 		.ascii	"The gamma command 0x%x 0x%x\015\012\000"
 14894      67616D6D 
 14894      6120636F 
 14894      6D6D616E 
 14894      64203078 
 14895 0dce 0000     		.space	2
 14896              	.LC78:
 14897 0dd0 54686520 		.ascii	"The AGC Max command 0x%x 0x%x\015\012\000"
 14897      41474320 
 14897      4D617820 
 14897      636F6D6D 
 14897      616E6420 
 14898              	.LC79:
 14899 0df0 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 14899      65642074 
 14899      6F207365 
 14899      6E642069 
 14899      6E746572 
 14900 0e21 0A00     		.ascii	"\012\000"
 14901 0e23 00       		.space	1
 14902              	.LC80:
 14903 0e24 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 14903      6F6D6D69 
 14903      74656F66 
 14903      20737461 
 14903      7465203D 
 14904              	.LC81:
 14905 0e3c 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 14905      6E656C20 
 14905      53657420 
 14905      57726170 
 14905      55702066 
 14906 0e69 000000   		.space	3
 14907              	.LC82:
 14908 0e6c 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 14908      69742045 
 14908      4F462066 
 14908      61696C65 
 14908      64210D0A 
 14909 0e81 000000   		.space	3
 14910              	.LC83:
 14911 0e84 49324363 		.ascii	"I2CcmdQue\000"
 14911      6D645175 
 14911      6500
 14912 0e8e 0000     		.space	2
 14913              	.LC84:
 14914 0e90 33303A55 		.ascii	"30:UVC App Thread\000"
 14914      56432041 
 14914      70702054 
 14914      68726561 
 14914      6400
 14915 0ea2 0000     		.space	2
 14916              	.LC85:
 14917 0ea4 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 14917      56432041 
 14917      70702045 
 14917      50302054 
 14917      68726561 
 14918 0eba 0000     		.space	2
 14919              	.LC86:
 14920 0ebc 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 14920      32432041 
 14920      70702043 
 14920      54524C20 
 14920      54687265 
 14921 0ed3 00       		.bss
 14922              		.align	2
 14923              		.set	.LANCHOR0,. + 0
 14926              	glFxUVCEvent:
 14927 0000 00000000 		.space	40
 14927      00000000 
 14927      00000000 
 14927      00000000 
 14927      00000000 
 14930              	glEp0Buffer:
 14931 0028 00000000 		.space	32
 14931      00000000 
 14931      00000000 
 14931      00000000 
 14931      00000000 
 14934              	usbSpeed:
 14935 0048 00       		.space	1
 14936 0049 000000   		.space	3
 14939              	glCommitCtrl:
 14940 004c 00000000 		.space	32
 14940      00000000 
 14940      00000000 
 14940      00000000 
 14940      00000000 
 14943              	is60Hz:
 14944 006c 00000000 		.space	4
 14947              	setRes:
 14948 0070 00       		.space	1
 14951              	setstilRes:
 14952 0071 00       		.space	1
 14955              	stiflag:
 14956 0072 00       		.space	1
 14957 0073 00       		.space	1
 14960              	fb:
 14961 0074 0000     		.space	2
 14964              	pb:
 14965 0076 0000     		.space	2
 14968              	pbc:
 14969 0078 0000     		.space	2
 14970 007a 0000     		.space	2
 14973              	hitFV:
 14974 007c 00000000 		.space	4
 14977              	prodCount:
 14978 0080 0000     		.space	2
 14981              	consCount:
 14982 0082 0000     		.space	2
 14985              	streamingStarted:
 14986 0084 00000000 		.space	4
 14989              	gpif_initialized:
 14990 0088 00000000 		.space	4
 14993              	isUsbConnected:
 14994 008c 00000000 		.space	4
 14997              	clearFeatureRqtReceived:
 14998 0090 00000000 		.space	4
 15001              	I2CCMDArry:
 15002 0094 00000000 		.space	12
 15002      00000000 
 15002      00000000 
 15005              	IMcount.8243:
 15006 00a0 00       		.space	1
 15007 00a1 000000   		.space	3
 15010              	uvcAppThread:
 15011 00a4 00000000 		.space	168
 15011      00000000 
 15011      00000000 
 15011      00000000 
 15011      00000000 
 15014              	uvcAppEP0Thread:
 15015 014c 00000000 		.space	168
 15015      00000000 
 15015      00000000 
 15015      00000000 
 15015      00000000 
 15018              	i2cAppThread:
 15019 01f4 00000000 		.space	168
 15019      00000000 
 15019      00000000 
 15019      00000000 
 15019      00000000 
 15022              	pbcpbak:
 15023 029c 0000     		.space	2
 15026              	pbcbak:
 15027 029e 0000     		.space	2
 15030              	pbbak:
 15031 02a0 0000     		.space	2
 15034              	fbbak:
 15035 02a2 0000     		.space	2
 15038              	testSnap:
 15039 02a4 00       		.space	1
 15040 02a5 000000   		.text
 15041              	.Letext0:
 15042              		.file 2 "c:\\program files (x86)\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\s
 15043              		.file 3 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15044              		.file 4 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyfx
 15045              		.file 5 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_p
 15046              		.file 6 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_a
 15047              		.file 7 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15048              		.file 8 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15049              		.file 9 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15050              		.file 10 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15051              		.file 11 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15052              		.file 12 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15053              		.file 13 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15054              		.file 14 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15055              		.file 15 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15056              		.file 16 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15057              		.file 17 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15058              		.file 18 "../sensor.h"
 15059              		.file 19 "../cmdqu.h"
 15060              		.file 20 "../uvc.h"
 15061              		.file 21 "../cyfxgpif2config.h"
 15062              		.file 22 "../cyfxgpif2config_usb2_720.h"
 15063              		.file 23 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:16     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:19     .text:00000000 I2CCmdCb
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:57     .text:00000030 $d
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:63     .text:0000003c $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:65     .text:0000003c UVCHandleVideoStreamingRqts
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:211    .text:00000190 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:218    .text:000001a0 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:404    .text:00000374 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:411    .text:00000384 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:742    .text:000006ec $d
                            *COM*:00000002 wValue
                            *COM*:00000001 bRequest
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:763    .text:00000734 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:766    .text:00000734 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:935    .text:00000894 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:941    .text:000008a4 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:1054   .text:00000974 $d
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:1065   .text:00000994 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:1068   .text:00000994 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:1303   .text:00000b24 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000e8 glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:1313   .text:00000b40 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:1315   .text:00000b40 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:1530   .text:00000cbc $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:1541   .text:00000ccc $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:1543   .text:00000ccc CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:1901   .text:00000f88 $d
                            *COM*:00000002 wLength
                            *COM*:00000002 wIndex
                            *COM*:00000001 bmReqType
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:1919   .text:00000fb4 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:1922   .text:00000fb4 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:2150   .text:000011b8 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:2158   .text:000011cc $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:2161   .text:000011cc setIrisauto
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:2229   .text:00001248 getShutCtrl
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:2254   .text:00001264 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:2267   .text:0000128c $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:2368   .text:00001364 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:2376   .text:00001378 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:2379   .text:00001378 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:2549   .text:000014e0 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:2577   .text:00001544 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:2662   .text:00001604 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:2680   .text:00001644 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:2800   .text:00001748 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:2813   .text:00001774 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:2871   .text:000017f4 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:2886   .text:00001824 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:3557   .text:00001e74 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:3564   .text:00001e84 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:4075   .text:00002344 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:4098   .text:00002394 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:4738   .text:000029d8 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:4885   .text:00002b00 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:4898   .text:00002b28 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:5314   .text:00002f58 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:5325   .text:00002f78 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:5595   .text:0000320c $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:5607   .text:00003230 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:5610   .text:00003230 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:5911   .text:000034ec $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:5918   .text:000034fc $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:5921   .text:000034fc CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:5965   .text:00003540 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:5970   .text:00003548 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:5973   .text:00003548 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:6001   .text:00003564 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:6005   .text:00003568 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:6008   .text:00003568 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:6793   .text:00003be4 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:6799   .text:00003bf4 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:7274   .text:00003fdc $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11325  .text:000060dc CyFxGpifCB
                            *COM*:000000ac glChHandleInterStat
                            *COM*:00000004 glInterStaBuffer
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:7333   .text:000040b4 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:7336   .text:000040b4 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:7405   .text:0000412c $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:7413   .text:0000413c $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:9222   .text:000050a0 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:9259   .text:00005118 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:10575  .text:00005a7c $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:10581  .text:00005a8c $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11357  .text:00006110 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11370  .text:0000613c $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11375  .text:0000614c $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11380  .text:0000615c $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11428  .text:000061b4 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11438  .text:000061c8 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11441  .text:000061c8 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11594  .text:00006310 $d
                            *COM*:00000038 cmdQuMux
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11611  .text.startup:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11614  .text.startup:00000000 main
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:12952  .data:000004ec glUVCHeader
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11971  .data:00000060 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11892  .data:0000001c glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11956  .data:00000054 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11862  .data:00000000 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11922  .data:00000038 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14985  .bss:00000084 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14997  .bss:00000090 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14934  .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14993  .bss:0000008c isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:15022  .bss:0000029c pbcpbak
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:15026  .bss:0000029e pbcbak
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:15030  .bss:000002a0 pbbak
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:15034  .bss:000002a2 fbbak
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14968  .bss:00000078 pbc
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14964  .bss:00000076 pb
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14960  .bss:00000074 fb
                            *COM*:00000038 timMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:15038  .bss:000002a4 testSnap
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13604  .data:00000792 snapButFlag
                            *COM*:000000e8 glChHandleStillStream
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11846  .rodata:000001bc CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14115  .data:00000960 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14194  .data:00000a90 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14345  .data:00000b24 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14456  .data:00000cd4 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11833  .rodata:000001a0 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14467  .data:00000ce4 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14546  .data:00000e14 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14565  .data:00000e24 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14640  .data:00000f44 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11754  .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11758  .rodata:00000000 ShutSp
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11773  .rodata:00000020 pEXTSenCtrl
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13172  .data:000005b0 EXTShutter
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14027  .data:00000910 EXTSensUp
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14005  .data:000008fc EXTMirror
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13983  .data:000008e8 EXT3DnoiseReduceMode
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13961  .data:000008d4 EXT3DNoiseLev
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13939  .data:000008c0 EXTDayNightMode
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13917  .data:000008ac EXTDayNightdely
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13895  .data:00000898 EXTDayNightlev
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13873  .data:00000884 EXTNightDaylev
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:12989  .data:0000050c EXTAexModGainlev
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13851  .data:00000870 EXTExpReflev
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13194  .data:000005c4 EXTShutlev
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13829  .data:0000085c EXTCamMode
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13807  .data:00000848 EXTSensorPare
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13785  .data:00000834 EXTI2Ccmd
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13033  .data:00000534 EXTBLCWinPos
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13763  .data:00000820 EXTBLCWeight
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:12967  .data:000004f8 EXTBLCGrid
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13583  .data:00000780 EXTExHyster
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13011  .data:00000520 EXTExCtrlSped
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13741  .data:0000080c EXTEnhanceMode
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13719  .data:000007f8 EXTEnhanceGain
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13697  .data:000007e4 EXTEnhanceSTED
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13675  .data:000007d0 EXT2DNRGain
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13653  .data:000007bc EXT2DNRSTED
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13631  .data:000007a8 EXTGammaCor
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13609  .data:00000794 EXTAGCMaxLimit
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11810  .rodata:00000120 pPUCSenCtrl
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13150  .data:0000059c PUCBLC
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13055  .data:00000548 PUCBright
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14093  .data:0000094c PUCContrast
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13099  .data:00000570 PUCPLFreq
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13077  .data:0000055c PUCHueC
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14071  .data:00000938 PUCSaturation
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13128  .data:00000588 PUCSharp
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13539  .data:00000758 PUCWBMd
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13561  .data:0000076c PUCWBLC
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14049  .data:00000924 PUCDZoom
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11829  .rodata:00000160 curFlag
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11858  .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11951  .data:00000052 ROIMode
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:11986  .data:0000006c ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:12309  .data:000001ec CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13121  .data:00000584 WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:13216  .data:000005d8 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14647  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14922  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14926  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14930  .bss:00000028 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14939  .bss:0000004c glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14943  .bss:0000006c is60Hz
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14947  .bss:00000070 setRes
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14951  .bss:00000071 setstilRes
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14955  .bss:00000072 stiflag
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14973  .bss:0000007c hitFV
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14977  .bss:00000080 prodCount
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14981  .bss:00000082 consCount
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:14989  .bss:00000088 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:15001  .bss:00000094 I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:15005  .bss:000000a0 IMcount.8243
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:15010  .bss:000000a4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:15014  .bss:0000014c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\cci0rb9V.s:15018  .bss:000001f4 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
CyU3PDebugPrint
_txe_event_flags_set
CyU3PUsbSendEP0Data
CyU3PUsbStall
CyU3PUsbGetEP0Data
SensorSetIrisControl
_tx_thread_sleep
_txe_timer_create
_tx_time_get
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
_txe_timer_change
SensorSetControl
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyFx3BusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbAckSetup
SensorWrite2B
SensorRead2B
SensorWrite2B2
cmdSet
SensorGetControl
memcpy
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PUsbGetSpeed
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PDmaMultiChannelSetWrapUp
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
